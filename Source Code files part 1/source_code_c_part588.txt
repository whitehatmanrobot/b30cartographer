   else
    {
        m_StpCtx.iDYCY = 1;
        iAbsYSize = iYSize;
    }

    BOOL bSlopeIsOne = iAbsXSize == iAbsYSize;
    BOOL bSlopeIsPosOne =
        bSlopeIsOne && ((iXSize ^ iYSize) & 0x80000000) == 0;

    // compute closest pixel for vertices
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for
    // exception (slope == +1) case else use nearest ceiling
    //
    INT32 iXAdjust;
    if (bSlopeIsPosOne)
    {
        iXAdjust = LINE_FIX_HALF;
    }
    else
    {
        iXAdjust = LINE_FIX_NEAR_HALF;
    }
    INT32 iPixX0 = ( iX0 + iXAdjust ) >> LINE_FIX;
    INT32 iPixX1 = ( iX1 + iXAdjust ) >> LINE_FIX;
    INT32 iPixY0 = ( iY0 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;
    INT32 iPixY1 = ( iY1 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;

    // determine major axis and compute step values

    // sign of extent from V0 to V1 in major direction
    BOOL bLineMajorNeg;

    INT32 iLineMajor0;
    INT32 iLineMajor1;
    INT32 iLinePix0;
    INT32 iLinePix1;
    INT32 iLinePixStep;

    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( iAbsXSize >= iAbsYSize )
    {
        // here for X major
        m_StpCtx.uFlags |= LNF_X_MAJOR;
        iLineMajor0 = iX0;
        iLineMajor1 = iX1;
        iLinePix0 = iPixX0;
        iLinePix1 = iPixX1;
        iLinePixStep = m_StpCtx.iDXCY;
        bLineMajorNeg = iXSize & 0x80000000;
        m_StpCtx.iDXNC = m_StpCtx.iDXCY;
        m_StpCtx.iDYNC = 0;
    }
    else
    {
        // here for Y major
        iLineMajor0 = iY0;
        iLineMajor1 = iY1;
        iLinePix0 = iPixY0;
        iLinePix1 = iPixY1;
        iLinePixStep = m_StpCtx.iDYCY;
        bLineMajorNeg = iYSize & 0x80000000;
        m_StpCtx.iDXNC = 0;
        m_StpCtx.iDYNC = m_StpCtx.iDYCY;
    }

    // The multiplies here could be traded for sign tests but there'd
    // be four cases.  On a PII the multiplies will be faster than
    // the branches.
    m_StpCtx.DAttrCY.ipSurface =
        m_StpCtx.iDYCY * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXCY * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipSurface =
        m_StpCtx.iDYNC * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXNC * m_StpCtx.pCtx->iSurfaceStep;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        m_StpCtx.DAttrCY.ipZ =
            m_StpCtx.iDYCY * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXCY * m_StpCtx.pCtx->iZStep;
        m_StpCtx.DAttrNC.ipZ =
            m_StpCtx.iDYNC * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXNC * m_StpCtx.pCtx->iZStep;
    }

    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0 << LINE_FIX),
                                           iY0 - (iPixY0 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1 << LINE_FIX),
                                           iY1 - (iPixY1 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );

#define LINEDIR_CMP( _A, _B ) \
    ( bLineMajorNeg ? ( (_A) > (_B) ) : ( (_A) < (_B) ) )

    // do first pixel handling - not in or behind diamond
    if ( !( bV0InDiamond ||
            LINEDIR_CMP( iLineMajor0, iLinePix0 << LINE_FIX ) ) )
    {
        iLinePix0 += iLinePixStep;
    }

    // do last-pixel handling - don't pull in extent if past diamond
    // (in which case the pixel is always filled) or if in diamond
    // and rendering last pixel
    if ( !( ( !bV1InDiamond &&
              LINEDIR_CMP( iLinePix1 << LINE_FIX, iLineMajor1 ) ||
            ( bV1InDiamond &&
              m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LASTPIXEL] ) ) ) )
    {
        iLinePix1 -= iLinePixStep;
    }

    // compute extent along major axis
    m_StpCtx.cLinePix =
        bLineMajorNeg ? iLinePix0 - iLinePix1 + 1 : iLinePix1 - iLinePix0 + 1;

    // return if no major extent
    if ( m_StpCtx.cLinePix <= 0 )
    {
        return FALSE;
    }

    FLOAT fSlope;
    FLOAT fMinor0;

    // compute final axis-specific line values
    if ( iAbsXSize >= iAbsYSize )
    {
        m_StpCtx.iX = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iX0 - (m_StpCtx.iX << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX0 - iX1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iX << LINE_FIX) - iX0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX1 - iX0);
        }

        fSlope = m_StpCtx.fOoLen * (iY1 - iY0) * OO_LINE_SNAP;

        fMinor0 = (iY0 + LINE_FIX_NEAR_HALF) * OO_LINE_SNAP +
            m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iY = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iY);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }
    else
    {
        m_StpCtx.iY = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iY0 - (m_StpCtx.iY << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY0 - iY1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iY << LINE_FIX) - iY0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY1 - iY0);
        }

        fSlope = m_StpCtx.fOoLen * (iX1 - iX0) * OO_LINE_SNAP;

        fMinor0 = (iX0 + iXAdjust) * OO_LINE_SNAP + m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iX = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iX);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }

#ifdef LINE_CORRECTION_BIAS
    // A fudge factor of one-half is thrown into the correction
    // to avoid undershoot due to negative corrections.
    // This shifts all the attributes along the line,
    // introducing error, but it's better than clamping
    // them.  This is not done to the coordinates to avoid
    // perturbing them.
    m_StpCtx.fDMajor += g_fHalf;
#else
    // The correction factor is clamped to positive numbers to
    // avoid undershooting with attribute values.  This won't
    // cause overshooting issues because it moves attributes by
    // at most one-half.
    if (FLOAT_LTZ(m_StpCtx.fDMajor))
    {
        m_StpCtx.fDMajor = 0;
    }
#endif

    RSDPFM((RSM_LINES, "Line %.2f,%.2f - %.2f,%.2f\n",
            pV0->dvSX, pV0->dvSY, pV1->dvSX, pV1->dvSY));
    RSDPFM((RSM_LINES, "  %c major, %d,%d, %d pix\n",
            (m_StpCtx.uFlags & LNF_X_MAJOR) ? 'X' : 'Y',
            m_StpCtx.iX, m_StpCtx.iY, m_StpCtx.cLinePix));
    RSDPFM((RSM_LINES, "  slope %f, dmajor %f, minor0 %f\n",
            fSlope, m_StpCtx.fDMajor, fMinor0));
    RSDPFM((RSM_LINES, "  frac %d, dfrac %d\n",
            m_StpCtx.iLineFrac, m_StpCtx.iDLineFrac));

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE2(pV0->dvRHW, pV1->dvRHW))
    {
        NormalizeLineRHW(pV0, pV1);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    LineSetup_Start(&m_StpCtx, pV0, pV1);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\point.cpp ===
//----------------------------------------------------------------------------
//
// point.cpp
//
// Point processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

void
PrimProcessor::FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan)
{
    FLOAT fZ;
    FLOAT fZScale;

    pSpan->uPix = 1;
    pSpan->uX = (UINT16)m_StpCtx.iX;
    pSpan->uY = (UINT16)m_StpCtx.iY;

    pSpan->pSurface = m_StpCtx.pCtx->pSurfaceBits +
        m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
        m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;

    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        pSpan->pZ = m_StpCtx.pCtx->pZBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iZStride;

        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        // fZ may be used later so set if from the vertex Z.
        fZ = pV0->dvSZ;
        pSpan->uZ = FTOI(fZ * fZScale);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
        FLOAT fUoW, fVoW;

        // Mipmapping doesn't have any meaning.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_LOD_USED) == 0);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pV0->dvRHW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = g_fOne / pV0->dvRHW;
            }

            pSpan->iW = FTOI(fW * W_SCALE);

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pSpan->iOoW = FTOI(pV0->dvRHW * OOW_SCALE);
        }
        else
        {
            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;
        }

        pSpan->iLOD = 0;
        pSpan->iDLOD = 0;

        pSpan->UVoW[0].iUoW = FTOI(fUoW * TEX_SCALE);
        pSpan->UVoW[0].iVoW = FTOI(fVoW * TEX_SCALE);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)m_StpCtx.pCtx->cActTex; i++)
        {
            if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU *
                         pV0->dvRHW * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV *
                         pV0->dvRHW * TEX_SCALE);
            }
            else
            {
                pSpan->UVoW[i].iUoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTU * TEX_SCALE);
                pSpan->UVoW[i].iVoW =
                    FTOI(((PRAST_GENERIC_VERTEX)pV0)->texCoord[i].dvTV * TEX_SCALE);
            }
        }
    }

    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uG = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uR = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uA = (UINT)RGBA_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = (INT32)CI_MASKALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_FIXED_SHIFT;
        pSpan->iIdxA = (INT32)CI_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uGS = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uRS = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure that fZ has been set.
            RSASSERT(m_StpCtx.uFlags & PRIMSF_Z_USED);

            pSpan->uFog = (UINT16)ComputeTableFog(m_StpCtx.pCtx->pdwRenderState, fZ);
        }
        else
        {
            pSpan->uFog = (UINT16)(
                FTOI((FLOAT)RGBA_GETALPHA(pV0->dcSpecular) *
                     FOG_255_SCALE));
        }
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE1(fV0) \
    (ASUINT32(fV0) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizePointRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function clamps
// the RHW to the proper range.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizePointRHW(LPD3DTLVERTEX pV0)
{
    // Save original value.
    m_dvV0RHW = pV0->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW))
    {
        RSDPF(("Point RHW out of range %f,%f",
               pV0->dvRHW));
    }
#endif

    if (pV0->dvRHW < NORMALIZED_RHW_MIN)
    {
        pV0->dvRHW = NORMALIZED_RHW_MIN;
    }
    else if (pV0->dvRHW > NORMALIZED_RHW_MAX)
    {
        pV0->dvRHW = NORMALIZED_RHW_MAX;
    }
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Point
//
// Provides a point for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Point(LPD3DTLVERTEX pV0,
                     LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-point flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | PTF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X",
            m_uPpFlags, m_StpCtx.uFlags));

    // Round coordinates to integer.
    m_StpCtx.iX = IFLOORF(pV0->dvSX + g_fHalf);
    m_StpCtx.iY = IFLOORF(pV0->dvSY + g_fHalf);

    RSDPFM((RSM_POINTS, "Point\n"));
    RSDPFM((RSM_POINTS, "    V0 (%f,%f,%f) (%d,%d)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ,
            m_StpCtx.iX, m_StpCtx.iY));

    // Clip test.
    if (m_StpCtx.iX < m_StpCtx.pCtx->Clip.left ||
        m_StpCtx.iX >= m_StpCtx.pCtx->Clip.right ||
        m_StpCtx.iY < m_StpCtx.pCtx->Clip.top ||
        m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom)
    {
        return D3D_OK;
    }

    //
    // Fill out a one-pixel span for the point.
    // Since the prim deltas are irrelevant for the span,
    // the span is appended to whatever primitive happens
    // to be available in the buffer.
    //

    PD3DI_RASTSPAN pSpan;
    UINT cSpans = 1;

    hr = AppendPrim();
    if (hr != D3D_OK)
    {
        return hr;
    }

    hr = AllocSpans(&cSpans, &pSpan);
    if (hr != D3D_OK)
    {
        return hr;
    }

    m_StpCtx.pPrim->uSpans++;

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE1(pV0->dvRHW))
    {
        NormalizePointRHW(pV0);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    // Remember flat color controlling vertex for setup, if flat shaded.
    if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
    {
        m_StpCtx.pFlatVtx = pFlatVtx;
    }
    else
    {
        m_StpCtx.pFlatVtx = pV0;
    }


    FillPointSpan(pV0, pSpan);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\walkcpp.cpp ===
//----------------------------------------------------------------------------
//
// walkcpp.cpp
//
// C++ trapezoid edge walking functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Currently empty.
//
// Could use m4 to generate specialized versions of everything,
// but the only overhead is two function calls per span.  I don't
// think it's important enough to justify the extra code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\primproc.cpp ===
//----------------------------------------------------------------------------
//
// primproc.cpp
//
// Miscellaneous PrimProcessor methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// PrimProcessor::BeginPrimSet
//
// Marks the start of a set of primitives that have the same vertex type.
// Computes attributes used from the current state and the vertex type.
//
//----------------------------------------------------------------------------

void
PrimProcessor::BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                            RAST_VERTEX_TYPE VertType)
{
    // If state hasn't changed and the primitive and vertex types match the
    // ones we're already set up for there's no work to do.
    if ((m_uPpFlags & PPF_STATE_CHANGED) == 0 &&
        VertType == m_VertType &&
        PrimType == m_PrimType)
    {
        return;
    }

    m_StpCtx.uFlags &= ~PRIMSF_ALL;

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_STENCILENABLE])
    {
        m_StpCtx.uFlags |= PRIMSF_Z_USED;
    }

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Index is unused during copy mode texturing.
        if (m_StpCtx.pCtx->pdwRenderState
            [D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_COPY ||
            m_StpCtx.pCtx->cActTex == 0)
        {
            m_StpCtx.uFlags |= PRIMSF_DIDX_USED;
        }
    }
    else
    {
        // ATTENTION - Don't set these for copy mode texture?  Is
        // copy mode texture meaningful in RGB?
        m_StpCtx.uFlags |= PRIMSF_DIFF_USED;
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        {
            m_StpCtx.uFlags |= PRIMSF_SPEC_USED;
        }
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SHADEMODE] ==
        D3DSHADE_FLAT)
    {
        m_StpCtx.uFlags |= PRIMSF_FLAT_SHADED;
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        m_StpCtx.uFlags |= PRIMSF_TEX1_USED;

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            m_StpCtx.uFlags |= PRIMSF_TEX2_USED;
        }
    }

    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
    {
        m_StpCtx.uFlags |= PRIMSF_PERSP_USED;
    }

    // Currently only tex1 can be mipmapped.
    if (((m_StpCtx.uFlags & PRIMSF_TEX1_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[0]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[0]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[0]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[0]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    // select between min and mag filters for TEX2
    if (((m_StpCtx.uFlags & PRIMSF_TEX2_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[1]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[1]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[1]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[1]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE])
    {
        // Note, if PWL_FOG is ever brought back to life, enabling
        // PRIMSF_GLOBAL_FOG_USED with no Z buffer will not trivially work
        // if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            switch (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
            {
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                m_StpCtx.uFlags |= PRIMSF_GLOBAL_FOG_USED;
#ifndef PWL_FOG
                // The span routines don't support table fog directly.
                // Instead table fog is computed per vertex and used to
                // set up local fog.
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
#endif
                break;
            default:
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
                break;
            }
        }
    }

    PFN_ADDATTRS *ppfnAddAttrsTable;
    PFN_ADDSCALEDATTRS *ppfnAddScaledAttrsTable;
    PFN_FILLSPANATTRS *ppfnFillSpanAttrsTable;

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Ramp does not support multitexture.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_TEX2_USED) == 0);

        RSASSERT((PRIMSF_TEX1_USED | PRIMSF_DIDX_USED) == 0x14);

        // Derive a function table index from bits 2 and 4 of usage
        // information.
        // An alternative method would be to use bits 0-4 and have the
        // ramp information in the top 16 entries, but splitting the
        // ramp and RGB tables is cleaner and decouples the table sizes.
        // Decoupling is useful since the ramp possibilities are much
        // more limited so its table can be smaller.

        m_iAttrFnIdx =
            ((m_StpCtx.uFlags & PRIMSF_TEX1_USED) >> 2) |
            ((m_StpCtx.uFlags & PRIMSF_DIDX_USED) >> 3);

        ppfnAddAttrsTable = g_pfnRampAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnRampAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnRampFillSpanFloatAttrsTable;
    }
    else
    {
        RSASSERT((PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED |
                  PRIMSF_TEX2_USED) == 0xf);

        // Derive a function table index from the lower four bits of
        // usage information.  The lower bits are deliberately chosen
        // to represent the more performance-sensitive cases while
        // the upper bits generally represent cases handled by generic
        // code.
        //
        // Even restricted to only four bits the index contains unimportant
        // and unreachable cases, such as specular without diffuse or
        // tex2 without tex1.  Tables indexed must account for this.

        m_iAttrFnIdx = m_StpCtx.uFlags & (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED |
                                          PRIMSF_TEX1_USED | PRIMSF_TEX2_USED);

        ppfnAddAttrsTable = g_pfnAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnFillSpanFloatAttrsTable;
    }

    //
    // These functions only depend on the index and so can be set here.
    // Other functions depend on per-triangle information and are set
    // later.
    //

    if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
    {
        // If any slow attrs are on or Z is off use the general functions.
        m_StpCtx.pfnAddScaledAttrs = AddScaledFloatAttrs_Any_Either;
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
        m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
#endif
    }
    else
    {
        m_StpCtx.pfnAddScaledAttrs =
            ppfnAddScaledAttrsTable[m_iAttrFnIdx];
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = ppfnAddAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs = ppfnFillSpanAttrsTable[m_iAttrFnIdx];
#endif
    }

    // Attribute beads can be set here.
    PFN_SETUPTRIATTR *ppfnSlot;

    ppfnSlot = &m_StpCtx.pfnTriSetupFirstAttr;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            *ppfnSlot = TriSetup_Z16;
        }
        else
        {
            *ppfnSlot = TriSetup_Z32;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupZEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX1_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTexEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DiffFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Diff;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DIdxFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_DIdx;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_SpecFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Spec;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupSpecEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        *ppfnSlot = TriSetup_Fog;
        ppfnSlot = &m_StpCtx.pfnTriSetupFogEnd;
    }
    *ppfnSlot = TriSetup_End;

    // Remember the primitive and vertex type and clear the state change bit.
    m_PrimType = PrimType;
    m_VertType = VertType;
    m_uPpFlags &= ~PPF_STATE_CHANGED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\rastcap.h ===
// rastcap.h - declaration of the CRastCapRecord class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCAP_H_
#define _RASTCAP_H_

// the current size of the rasterizer capability bit vector, in DWORDs.
#define RASTCAPRECORD_SIZE  3

// sets bits in the rasterizer capability bit vector
#define SET_VAL(pos, len, val)  ((m_rgdwData[(pos) / 32]) |= \
                                 (((val) & ~(0xFFFFFFFF << (len))) << \
                                  ((pos) % 32)))

// the positions and lengths of fields in the rasterizer capability bit vector
// note: make sure fields do not straddle DWORD boundaries!  SET_VAL cannot
//       currently handle that
#define ZFUNC_POS               0
#define ZFUNC_LEN               8
#define ZFORMAT_POS             8
#define ZFORMAT_LEN             4
#define ZTEST_POS               12
#define ZTEST_LEN               1
#define ZWRITE_POS              13
#define ZWRITE_LEN              1

#define SHADEMODE_POS           16
#define SHADEMODE_LEN           4
#define SPECULAR_POS            20
#define SPECULAR_LEN            1
#define VERTEXFOG_POS           21
#define VERTEXFOG_LEN           1
#define MONO_POS                22
#define MONO_LEN                1

#define TEXTUREFORMAT_POS       32
#define TEXTUREFORMAT_LEN       8
#define TEXTURE_POS             40
#define TEXTURE_LEN             4
#define TEXTUREBLEND_POS        44
#define TEXTUREBLEND_LEN        4
#define TEXTUREFILTER_POS       48
#define TEXTUREFILTER_LEN       4
#define TEXTUREPERSP_POS        52
#define TEXTUREPERSP_LEN        1
#define TEXTUERBORDER_POS       53
#define TEXTUREBORDER_LEN       1
#define TEXTUREADDR_POS         54
#define TEXTUREADDR_LEN         1
#define TEXTUREMIP_POS          55
#define TEXTUREMIP_LEN          1
#define TEXTURELOD_POS          56
#define TEXTURELOD_LEN          1
#define TEXTURECOLORKEY_POS     57
#define TEXTURECOLORKEY_LEN     1
#define TEXTUREALPHAOVERRIDE_POS 58
#define TEXTUREALPHAOVERRIDE_LEN 1

#define TARGETPIXELFORMAT_POS   64
#define TARGETPIXELFORMAT_LEN   8
#define SRCBLEND_POS            72
#define SRCBLEND_LEN            4
#define DESTBLEND_POS           76
#define DESTBLEND_LEN           4
#define STIPPLE_POS             80
#define STIPPLE_LEN             1
#define DITHER_POS              81
#define DITHER_LEN              1
#define ROP_POS                 82
#define ROP_LEN                 1
#define BLEND_POS               83
#define BLEND_LEN               1
#define ALPHATEST_POS           84
#define ALPHATEST_LEN           1
#define ALPHABLEND_POS          85
#define ALPHABLEND_LEN          1
#define STENCIL_POS             86
#define STENCIL_LEN             1

class CRastCapRecord {

    friend class CRastCollection;

private:

    DWORD   m_rgdwData[RASTCAPRECORD_SIZE];

public:

    CRastCapRecord(void)
    {
        memset(m_rgdwData,0,RASTCAPRECORD_SIZE * sizeof(DWORD));
        return;
    }

    void Set_ZTest(int iZTest)
    {
        SET_VAL(ZTEST_POS,ZTEST_LEN,iZTest);
        return;
    }

    void Set_ZFormat(int iZFormat)
    {
        SET_VAL(ZFORMAT_POS,ZFORMAT_LEN,iZFormat);
        return;
    }

    void Set_ZWrite(int iZWrite)
    {
        SET_VAL(ZWRITE_POS,ZWRITE_LEN,iZWrite);
        return;
    }

    void Set_ZFunc(int iZFunc)
    {
        SET_VAL(ZFUNC_POS,ZFUNC_LEN,iZFunc);
        return;
    }

    void Set_Stipple(int iStipple)
    {
        SET_VAL(STIPPLE_POS,STIPPLE_LEN,iStipple);
        return;
    }

    void Set_AlphaTest(int iAlphaTest)
    {
        SET_VAL(ALPHATEST_POS,ALPHATEST_LEN,iAlphaTest);
        return;
    }

    void Set_ShadeMode(int iShadeMode)
    {
        SET_VAL(SHADEMODE_POS,SHADEMODE_LEN,iShadeMode);
        return;
    }

    void Set_Specular(int iSpecular)
    {
        SET_VAL(SPECULAR_POS,SPECULAR_LEN,iSpecular);
        return;
    }

    void Set_VertexFog(int iVertexFog)
    {
        SET_VAL(VERTEXFOG_POS,VERTEXFOG_LEN,iVertexFog);
        return;
    }

    void Set_Texture(int iTexture)
    {
        SET_VAL(TEXTURE_POS,TEXTURE_LEN,iTexture);
        return;
    }

    void Set_TexturePersp(int iTexturePersp)
    {
        SET_VAL(TEXTUREPERSP_POS,TEXTUREPERSP_LEN,iTexturePersp);
        return;
    }

    void Set_TextureBlend(int iTextureBlend)
    {
        SET_VAL(TEXTUREBLEND_POS,TEXTUREBLEND_LEN,iTextureBlend);
        return;
    }

    // for now, just capture texture state for the first texture
    // and assume monolithics are single textured.
    void Set_TextureBorder(int i, int iTextureBorder)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUERBORDER_POS,TEXTUREBORDER_LEN,iTextureBorder);
        }
        return;
    }

    void Set_TextureAddr(int i, int iTextureAddr)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREADDR_POS,TEXTUREADDR_LEN,iTextureAddr);
        }
        return;
    }

    void Set_TextureFilter(int i, int iTextureFilter)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFILTER_POS,TEXTUREFILTER_LEN,iTextureFilter);
        }
        return;
    }

    void Set_TextureMip(int i, int iTextureMip)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREMIP_POS,TEXTUREMIP_LEN,iTextureMip);
        }
        return;
    }

    void Set_TextureLOD(int i, int iTextureLOD)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURELOD_POS,TEXTURELOD_LEN,iTextureLOD);
        }
        return;
    }

    void Set_TextureFormat(int i, int iTextureFormat)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFORMAT_POS,TEXTUREFORMAT_LEN,iTextureFormat);
        }
        return;
    }

    void Set_TextureColorKey(int i, int iTextureColorKey)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURECOLORKEY_POS,TEXTURECOLORKEY_LEN,iTextureColorKey);
        }
        return;
    }

    void Set_TextureAlphaOverride(int i, int iTextureAlphaOverride)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREALPHAOVERRIDE_POS,TEXTUREALPHAOVERRIDE_LEN,iTextureAlphaOverride);
        }
        return;
    }

    void Set_Mono(int iMono)
    {
        SET_VAL(MONO_POS,MONO_LEN,iMono);
        return;
    }

    void Set_AlphaBlend(int iAlphaBlend)
    {
        SET_VAL(ALPHABLEND_POS,ALPHABLEND_LEN,iAlphaBlend);
        return;
    }

    void Set_Blend(int iBlend)
    {
        SET_VAL(BLEND_POS,BLEND_LEN,iBlend);
        return;
    }

    void Set_ROP(int iROP)
    {
        SET_VAL(ROP_POS,ROP_LEN,iROP);
        return;
    }

    void Set_SrcBlend(int iSrcBlend)
    {
        SET_VAL(SRCBLEND_POS,SRCBLEND_LEN,iSrcBlend);
        return;
    }

    void Set_DestBlend(int iDestBlend)
    {
        SET_VAL(DESTBLEND_POS,DESTBLEND_LEN,iDestBlend);
        return;
    }

    void Set_TargetPixelFormat(int iTargetPixelFormat)
    {
        SET_VAL(TARGETPIXELFORMAT_POS,TARGETPIXELFORMAT_LEN,iTargetPixelFormat);
        return;
    }

    void Set_Dither(int iDither)
    {
        SET_VAL(DITHER_POS,DITHER_LEN,iDither);
        return;
    }

    void Set_Stencil(int iStencil)
    {
        SET_VAL(STENCIL_POS,STENCIL_LEN,iStencil);
        return;
    }

#if DBG
    DWORD GetCapDWord(int iNum)
    {
        return m_rgdwData[iNum];
    }
#endif
};

#endif  // _RASTCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\rastcoll.cpp ===
// rastcoll.cpp - implementation of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#include "pch.cpp"
#pragma hdrstop

#include "RastCap.h"
#include "rastcoll.h"
#include "mlrfns.h"

// MMX monolithic rasterizers are for X86 only
#ifdef _X86_
// table containing rasterzer capability bit vectors and
// pointers to functions implementing MMX monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//

static RASTFNREC s_RastListMMX[] = {
    {{ 0x00000000, 0x00000000, 0x00000100 }, MMXMLRast_22, 21, "MMX ml22" },
    {{ 0x00000000, 0x00000000, 0x00000102 }, MMXMLRast_8,   7, "MMX ml8 " },
    {{ 0x00000000, 0x00001100, 0x00000100 }, MMXMLRast_23, 22, "MMX ml23" },
    {{ 0x00000000, 0x00001102, 0x00000102 }, MMXMLRast_9,   8, "MMX ml9 " },
    {{ 0x00000000, 0x00003100, 0x00000100 }, MMXMLRast_26, 25, "MMX ml26" },
    {{ 0x00000000, 0x00003102, 0x00000102 }, MMXMLRast_12, 11, "MMX ml12" },
    {{ 0x00000000, 0x00101200, 0x00000100 }, MMXMLRast_24, 23, "MMX ml24" },
    {{ 0x00000000, 0x00101202, 0x00000102 }, MMXMLRast_10,  9, "MMX ml10" },
    {{ 0x00000000, 0x00103200, 0x00000100 }, MMXMLRast_27, 26, "MMX ml27" },
    {{ 0x00000000, 0x00103202, 0x00000102 }, MMXMLRast_13, 12, "MMX ml13" },
    {{ 0x00000000, 0x00111200, 0x00000100 }, MMXMLRast_25, 24, "MMX ml25" },
    {{ 0x00000000, 0x00111202, 0x00000102 }, MMXMLRast_11, 10, "MMX ml11" },
    {{ 0x00000000, 0x00113200, 0x00000100 }, MMXMLRast_28, 27, "MMX ml28" },
    {{ 0x00000000, 0x00113202, 0x00000102 }, MMXMLRast_14, 13, "MMX ml14" },
    {{ 0x00003003, 0x00000000, 0x00000100 }, MMXMLRast_15, 14, "MMX ml15" },
    {{ 0x00003003, 0x00000000, 0x00000102 }, MMXMLRast_1,   0, "MMX ml1 " },
    {{ 0x00003003, 0x00001100, 0x00000100 }, MMXMLRast_16, 15, "MMX ml16" },
    {{ 0x00003003, 0x00001102, 0x00000102 }, MMXMLRast_2,   1, "MMX ml2 " },
    {{ 0x00003003, 0x00003100, 0x00000100 }, MMXMLRast_19, 18, "MMX ml19" },
    {{ 0x00003003, 0x00003102, 0x00000102 }, MMXMLRast_5,   4, "MMX ml5 " },
    {{ 0x00003003, 0x00101200, 0x00000100 }, MMXMLRast_17, 16, "MMX ml17" },
    {{ 0x00003003, 0x00101202, 0x00000102 }, MMXMLRast_3,   2, "MMX ml3 " },
    {{ 0x00003003, 0x00103200, 0x00000100 }, MMXMLRast_20, 19, "MMX ml20" },
    {{ 0x00003003, 0x00103202, 0x00000102 }, MMXMLRast_6,   5, "MMX ml6 " },
    {{ 0x00003003, 0x00111200, 0x00000100 }, MMXMLRast_18, 17, "MMX ml18" },
    {{ 0x00003003, 0x00111202, 0x00000102 }, MMXMLRast_4,   3, "MMX ml4 " },
    {{ 0x00003003, 0x00113200, 0x00000100 }, MMXMLRast_21, 20, "MMX ml21" },
    {{ 0x00003003, 0x00113202, 0x00000102 }, MMXMLRast_7,   6, "MMX ml7 " },


};
#endif // _X86_

// table containing rasterizer capability bit vectors and
// pointers to functions implementing monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//
static RASTFNREC s_RastListNormal[] = {
    // Don't select these until we are sure they work
//    {{ 0x00113003, 0x00000000, 0x00000100 }, CMLRast_1, 0, "CML 1" },
//    {{ 0x00113003, 0x00000000, 0x00000103 }, CMLRast_2, 1, "CML 2" }
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_1, 0, "CML 1" },
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_2, 1, "CML 2" }
};


int RastCapCompare(DWORD* pdwCap1, DWORD* pdwCap2)
{
    for (int i = 0; i < RASTCAPRECORD_SIZE; i++) {
        if (pdwCap1[i] < pdwCap2[i]) {
            return -1;
        } else if (pdwCap1[i] > pdwCap2[i]) {
            return 1;
        }
    }

    return 0;
}


RASTFNREC*
CRastCollection::RastFnLookup(
    CRastCapRecord* pRastCapRec,
    RASTFNREC* pRastFnTbl,
    int iSize)
{
    int iLow = 0,
        iHigh = iSize - 1,
    iMid;
    RASTFNREC* pfnRastFnRec = NULL;

    // all MMX monolithics can handle either shade mode
    pRastCapRec->m_rgdwData[SHADEMODE_POS/32] &= ~(((1<<SHADEMODE_LEN)-1)<<SHADEMODE_POS);

    do
    {
        iMid = (iLow + iHigh) / 2;
        switch (RastCapCompare(pRastCapRec->
                m_rgdwData,pRastFnTbl[iMid].rgdwRastCap))
        {
        case -1 :
            iHigh = iMid - 1;
            break;
        case 0 :
            // found match
            pfnRastFnRec = &pRastFnTbl[iMid];
            iLow = iHigh + 1;       // exits while loop
            break;
        case 1 :
            iLow = iMid + 1;
            break;
        }
    } while (iLow <= iHigh);

    return pfnRastFnRec;
}


RASTFNREC*
CRastCollection::Search(PD3DI_RASTCTX pCtx,
    CRastCapRecord* pRastCapRec)
{
    RASTFNREC* pfnRastFnRec = NULL;

#ifdef _X86_
    // if we're on an MMX machine, is there an MMX rasterizer to use?
    if ((pCtx->BeadSet == D3DIBS_MMX)||(pCtx->BeadSet == D3DIBS_MMXASRGB)) {
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListMMX,
                             sizeof(s_RastListMMX) /
                             sizeof(s_RastListMMX[0]));
        if (pfnRastFnRec)
        {
            // only code up looking at one mask, for now
            DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);
            int iIndex = pfnRastFnRec->iIndex;
            DDASSERT((iIndex < 32) && (iIndex >= 0));
            if ((pCtx->dwMMXFPDisableMask[0]>>iIndex) & 1)
            {
                // oops, don't choose this one, it is on the disable list
                pfnRastFnRec = NULL;
            }
        }
    } else {
#endif //_X86_
        // no MMX or on ALPHA, so look in the normal list
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListNormal,
                                 sizeof(s_RastListNormal) /
                                 sizeof(s_RastListNormal[0]));
#ifdef _X86_
    }
#endif //_X86_

    return pfnRastFnRec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\sources.inc ===
TARGETNAME = rsetup
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

#C_DEFINES = $(C_DEFINES) -DSTEP_FIXED

SOURCES = \
        ..\attrs.cpp\
        ..\buffer.cpp\
        ..\line.cpp\
        ..\lstp.cpp\
        ..\point.cpp\
        ..\primproc.cpp\
        ..\rsdbg.cpp\
        ..\tri.cpp\
        ..\tstp.cpp\
        ..\walk.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\attrs_mh.h\
        $O\tstp_mh.h\
        $O\walk_mh.h

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\rastcoll.h ===
// RastColl.h - declaration of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCOLL_H_
#define _RASTCOLL_H_

typedef struct _RASTFNREC {
    DWORD           rgdwRastCap[RASTCAPRECORD_SIZE];
    PFNRENDERSPANS  pfnRastFunc;
    int             iIndex;             // index for disable mask
    char            pszRastDesc[128];   // brief human description of monolith
} RASTFNREC;

class CRastCollection {

private:

    RASTFNREC* RastFnLookup(CRastCapRecord*,RASTFNREC*,int);

public:

    RASTFNREC*  Search(PD3DI_RASTCTX,CRastCapRecord*);

};

#endif  // _RASTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\spindbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSpanInitOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIM, INVALID),
    DBG_DECLARE_MODFLAG(SPIM, REPORT),
    0, NULL,
};
static DebugModuleFlags g_RastSpanInitUserFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIU, BREAK_ON_SPANINIT),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSpanInit, SPI,
                 g_RastSpanInitOutputFlags, 0,
                 g_RastSpanInitUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\spindbg.hpp ===
//----------------------------------------------------------------------------
//
// spindbg.hpp
//
// Span Init debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPINDBG_HPP_
#define _SPINDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(SPI);

#define SPIDPF(Args)             DBG_DECLARE_DPF(SPI, Args)
#define SPIDPFM(Args)            DBG_DECLARE_DPFM(SPI, Args)
#define SPIASSERT(Exp)           DBG_DECLARE_ASSERT(SPI, Exp)
#define SPIASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(SPI, Exp, Args)
#define SPIVERIFY(Exp)           DBG_DECLARE_VERIFY(SPI, Exp)
#define SPIVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(SPI, Exp, Args)
#define SPIPROMPT(Args)          DBG_DECLARE_PROMPT(SPI, Args)
#define SPIGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(SPI, Idx)
#define SPISETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(SPI, Idx, Value)
#define SPIHRCHK(Exp)            DBG_DECLARE_HRCHK(SPI, Exp)
#define SPIHRGO(Exp, Label)      DBG_DECLARE_HRGO(SPI, Exp, Label)
#define SPIHRERR(Exp)            DBG_DECLARE_HRERR(SPI, Exp)
#define SPIHRRET(Exp)            DBG_DECLARE_HRRET(SPI, Exp)

#define SPIM_INVALID             0x00000001
#define SPIM_REPORT              0x00000002

#define SPIU_BREAK_ON_SPANINIT   0x00000001

#endif // #ifndef _SPINDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\tri.cpp ===
//----------------------------------------------------------------------------
//
// tri.cpp
//
// PrimProcessor top-level triangle methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Disallow fixed-point edge walkers to be chosen or not.
#if 0
#define DISALLOW_FIXED
#endif

// Maximum length of a PWL span.  Short to make piecewise-linear
// approximation more accurate.
#define MAX_PWL_SPAN_LEN        16
// Maximum normal span length.
#define MAX_SPAN_LEN            256

//----------------------------------------------------------------------------
//
// PrimProcessor::SetTriFunctions
//
// Set up function pointers for triangle processing.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetTriFunctions(void)
{
#if DBG
    if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_PIXEL_SPANS) == 0)
#else
    if ((m_StpCtx.uFlags & TRIF_RASTPRIM_OVERFLOW) == 0)
#endif
    {
        // Valid deltas.  If mipmapping or global fog is on then
        // only allow short subspans so that they can be done
        // reasonably accurately via piecewise linear interpolation.
#ifdef PWL_FOG
        if (m_StpCtx.uFlags & (PRIMSF_LOD_USED | PRIMSF_GLOBAL_FOG_USED))
#else
        if (m_StpCtx.uFlags & PRIMSF_LOD_USED)
#endif
        {
            m_StpCtx.cMaxSpan = MAX_PWL_SPAN_LEN;
        }
        else
        {
            // No mipmapping so we can handle much larger spans.
            // Color values only have 8 bits of fraction so
            // we still need to worry about error accumulation.
            // Cut long spans to cap accumulated error.
            m_StpCtx.cMaxSpan = MAX_SPAN_LEN;
        }
    }
    else
    {
        // Invalid deltas.  There's no way to communicate deltas to
        // the span routines so chop spans into pixels.
        // This case can only occur with very narrow triangles so
        // this isn't as expensive as it might seem at first.
        m_StpCtx.cMaxSpan = 1;
    }

    BOOL bFixed = FALSE;

#ifdef STEP_FIXED
    // No ramp support.
    RSASSERT(m_StpCtx.pCtx->BeadSet != D3DIBS_RAMP);
#endif

    if ((m_StpCtx.uFlags & PRIMF_TRIVIAL_ACCEPT_X) &&
#if DBG
        (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_GENERAL_WALK) == 0 &&
#endif
        m_iXWidth <= m_StpCtx.cMaxSpan)
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general
            // function.
            m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_NoClip;
        }
#if defined(STEP_FIXED) && !defined(DISALLOW_FIXED)
        // Attribute conversion can be a dominant cost for
        // triangles with very few spans, so avoid using fixed point
        // edge walking for them.
        else if ((m_StpCtx.uFlags & PRIMF_FIXED_OVERFLOW) == 0 &&
                 m_uHeight20 > 3)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFixedSpansNoClipTable[m_iAttrFnIdx];
            bFixed = TRUE;
        }
#endif
        else if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnRampWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
        else
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
    }
    else
    {
        // No special cases, just a general function.
        m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_Clip;
    }

#ifdef STEP_FIXED
    if (bFixed)
    {
        RSASSERT((m_StpCtx.uFlags & PRIMSF_SLOW_USED) == PRIMSF_Z_USED);

        m_StpCtx.pfnAddAttrs = g_pfnAddFixedAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs =
            g_pfnFillSpanFixedAttrsTable[m_iAttrFnIdx];

        PFN_FLOATATTRSTOFIXED pfnFloatAttrsToFixed;

        pfnFloatAttrsToFixed = g_pfnFloatAttrsToFixedTable[m_iAttrFnIdx];
        pfnFloatAttrsToFixed(&m_StpCtx.Attr, &m_StpCtx.Attr);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrNC, &m_StpCtx.DAttrNC);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrCY, &m_StpCtx.DAttrCY);
    }
    else
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general functions.
            m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
            m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
        }
        else
        {
            m_StpCtx.pfnAddAttrs = g_pfnAddFloatAttrsTable[m_iAttrFnIdx];
            m_StpCtx.pfnFillSpanAttrs =
                g_pfnFillSpanFloatAttrsTable[m_iAttrFnIdx];
        }
    }

    // Scaled attr functions already set since they only depend on
    // m_iAttrFnIdx.
#else // STEP_FIXED
    // All attr functions already set since they only depend on
    // m_iAttrFnIdx.
#endif // STEP_FIXED
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Tri
//
// Calls triangle setup.  If a triangle is produced by setup
// this routine walks edges, generating spans into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Tri(LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V0\n"));
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V1\n"));
        return hr;
    }
    hr = ValidateVertex(pV2);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V2\n"));
        return hr;
    }
#endif

    // Clear per-triangle flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | TRIF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_TRIS, "Tri\n"));
    RSDPFM((RSM_TRIS, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_TRIS, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));
    RSDPFM((RSM_TRIS, "  V2 (%f,%f,%f)\n",
            pV2->dvSX, pV2->dvSY, pV2->dvSZ));

    GET_PRIM();

    // Set up the triangle and see if anything was produced.
    // Triangles may not be produced due to:
    //   Face culling.
    //   Trivial rejection against the clip rect.
    //   Zero pixel coverage.
    if (TriSetup(pV0, pV1, pV2))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // uSpans and pNext have already been initialized.

        SetTriFunctions();
        COMMIT_PRIM(FALSE);

        if (m_uHeight10 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight10, &m_StpCtx.X10,
                                           &m_StpCtx, m_uHeight21 > 0);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

        if (m_uHeight21 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight21, &m_StpCtx.X21,
                                           &m_StpCtx, FALSE);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

#if DBG
        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FLUSH_AFTER_PRIM)
        {
            Flush();
        }
#endif
    }

    return hr;
}

#if DBG
//----------------------------------------------------------------------------
//
// PrimProcessor::ValidateVertex
//
// Checks the ranges of verifiable contents of vertex, to avoid setting up
// garbage.
//
//----------------------------------------------------------------------------
inline HRESULT PrimProcessor::ValidateVertex(LPD3DTLVERTEX pV)
{
    // from the OptSwExtCaps.dvGuardBand caps.
    if ((pV->sx < -32768.f) || (pV->sx > 32767.f) ||
        (pV->sy < -32768.f) || (pV->sy > 32767.f))
    {
        RSDPF(("ValidateVertex: x,y out of guardband range (%f,%f)\n",pV->sx,pV->sy));
        return DDERR_INVALIDPARAMS;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
    {

        // Allow a little slack for those generating triangles exactly on the
        // depth limit.  Needed for Quake.
        if ((pV->sz < -0.00015f) || (pV->sz > 1.00015f))
        {
            RSDPF(("ValidateVertex: z out of range (%f)\n",pV->sz));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
        {
            if (pV->rhw <= 0 )
            {
                RSDPF(("ValidateVertex: rhw out of range (%f)\n",pV->rhw));
                return DDERR_INVALIDPARAMS;
            }
        }

        // from OptSwExtCaps.dwMaxTextureRepeat cap.
        if ((pV->tu > 256.0F) || (pV->tu < -256.0F) ||
            (pV->tv > 256.0F) || (pV->tv < -256.0F))
        {
            RSDPF(("ValidateVertex: tu,tv out of range (%f,%f)\n",pV->tu,pV->tv));
            return DDERR_INVALIDPARAMS;
        }

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            PRAST_GENERIC_VERTEX pGV = (PRAST_GENERIC_VERTEX)pV;
            if ((pGV->texCoord[1].tu > 256.0F) || (pGV->texCoord[1].tu < -256.0F) ||
                (pGV->texCoord[1].tv > 256.0F) || (pGV->texCoord[1].tv < -256.0F))
            {
                RSDPF(("ValidateVertex: texCoord[1].tu,texCoord[1].tv out of range (%f,%f)\n",pGV->texCoord[1].tu,pGV->texCoord[1].tv));
                return DDERR_INVALIDPARAMS;
            }
        }
    }

    return D3D_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\walk.cpp ===
//----------------------------------------------------------------------------
//
// walk.cpp
//
// TriProcessor edge walking methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_Clip
//
// Walks the given number of spans, using edge 0 - 2 as the attribute
// edge and the given X and DXDY for the other edge.
// Spans are clipped in X against the current clip rect.
//
// The spans can be split into subspans if required.  cPixSplit indicates
// the maximum length span that should be recorded.  Any longer spans will
// be cut into multiple span segments.
//
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_Clip(UINT uSpans, PINTCARRYVAL pXOther,
                             PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    INT cTotalPix;
    INT cPix;
    INT uX, uXO;
    BOOL b20Valid;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;
    uSpansAvail = 0;
    
    for (;;)
    {
        //
        // Clip span and compute length.  No attributes need to be
        // updated here because attributes have already been moved
        // inside the clip boundary.
        //

        uX = pStpCtx->X20.iV;
        uXO = pXOther->iV;
        b20Valid = TRUE;

        RSDPFM((RSM_WALK, "Full span at Y %d, %d - %d\n",
                pStpCtx->iY, uX,
                (pStpCtx->uFlags & TRIF_X_DEC) ? uXO + 1 : uXO - 1));
        
        if (pStpCtx->uFlags & TRIF_X_DEC)
        {
            if (uX >= pStpCtx->pCtx->Clip.right)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.right - 1;
            }
            else if (uX < pStpCtx->pCtx->Clip.left &&
                     pStpCtx->X20.iCY <= 0)
            {
                // Right edge has crossed the left clip boundary
                // travelling left so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }


            // -1 because this edge is displaced by one.
            if (uXO < pStpCtx->pCtx->Clip.left - 1)
            {
                uXO = pStpCtx->pCtx->Clip.left - 1;
            }

            cTotalPix = uX - uXO;
        }
        else
        {
            if (uX < pStpCtx->pCtx->Clip.left)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.left;
            }
            else if (uX >= pStpCtx->pCtx->Clip.right &&
                     pStpCtx->X20.iCY >= 0)
            {
                // Left edge has crossed the right clip boundary
                // travelling right so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }

            if (uXO > pStpCtx->pCtx->Clip.right)
            {
                uXO = pStpCtx->pCtx->Clip.right;
            }

            cTotalPix = uXO - uX;
        }

        if (cTotalPix > 0)
        {
            ATTRSET Attr;
            PATTRSET pAttr;

            // Start without PWL support since the first iteration doesn't
            // have precomputed values.
            pStpCtx->uPwlFlags = 0;
            
            pAttr = &pStpCtx->Attr;
        
            for (;;)
            {
                if (uSpansAvail == 0)
                {
                    // We don't really have a good number to request
                    // since uSpans could result in any number of span
                    // fragments after dicing.  Using uSpans is OK
                    // as long as uSpans is relatively large, but if
                    // uSpans gets small and there's a lot of dicing then
                    // it would result in excessive AllocSpans calls.
                    // Try to avoid this problem by lower-bounding the
                    // request.  Any excess spans will be given back
                    // at the end.
                    uSpansAvail = min(8, uSpans);
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                // Split up remaining pixels if necessary.
                cPix = min(cTotalPix, pStpCtx->cMaxSpan);

                pSpan->uPix = (UINT16)cPix;
                pSpan->uX = (UINT16)uX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                RSDPFM((RSM_WALK, "  Seg at Y %d, X %d, %c%d pix (%d, %d)\n",
                        pStpCtx->iY, uX,
                        (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                        cPix, cTotalPix, pStpCtx->cMaxSpan));

                pStpCtx->pfnFillSpanAttrs(pAttr, pSpan, pStpCtx, cPix);

                cTotalPix -= cPix;
                if (cTotalPix <= 0)
                {
                    break;
                }

                // There are still pixels left in the span so the loop's
                // going to go around again.  Update all the attribute
                // values by cPix dX steps.
                //
                // We don't want to update the real edge attributes so we
                // need to work with a copy.  We do this lazily to
                // avoid the data movement for the normal case where
                // the span isn't split.
                if (pAttr == &pStpCtx->Attr)
                {
                    Attr = pStpCtx->Attr;
                    pAttr = &Attr;
                }

                if (pStpCtx->uFlags & TRIF_X_DEC)
                {
                    uX -= cPix;
                }
                else
                {
                    uX += cPix;
                }
                pStpCtx->pfnAddScaledAttrs(pAttr, &pStpCtx->DAttrDX,
                                           pStpCtx, cPix);
            }
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        // See if the edge has crossed a clip boundary.
        cPix = 0;
        if (b20Valid)
        {
            // Always take a normal step.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

            // See if the edge crossed out of the clip rect and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV >= pStpCtx->pCtx->Clip.right)
                {
                    cPix = pStpCtx->X20.iV - (pStpCtx->pCtx->Clip.right - 1);
                }
            }
            else
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->pCtx->Clip.left - pStpCtx->X20.iV;
                }
            }
        }
        else
        {
            // Always step in Y.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDY, pStpCtx);

            // See if the edge crossed into validity and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.right - 1)
                {
                    cPix = (pStpCtx->pCtx->Clip.right - 1) - pStpCtx->X20.iV;
                }
            }
            else
            {
                if (pStpCtx->X20.iV > pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->X20.iV - pStpCtx->pCtx->Clip.left;
                }
            }
        }

        if (cPix > 0)
        {
            // The edge made a validity transition.  Either the
            // attributes are sitting back at the edge of validity and
            // need to move forward or they've left the clip rect and
            // need to move back.  Either way, cPix has the
            // number of pixels to move in X.
            
            // No precomputed values.
            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnAddScaledAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDX,
                                       pStpCtx, cPix);
        }

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_NoClip
//
// WalkTrapSpans specialized for the trivial-accept clipping case.
// Span dicing is also unsupported.
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_NoClip(UINT uSpans, PINTCARRYVAL pXOther,
                               PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    PINTCARRYVAL pXLeft, pXRight;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;

    if (pStpCtx->uFlags & TRIF_X_DEC)
    {
        pXLeft = pXOther;
        pXRight = &pStpCtx->X20;
    }
    else
    {
        pXLeft = &pStpCtx->X20;
        pXRight = pXOther;
    }

    uSpansAvail = 0;

    for (;;)
    {
        if (pXRight->iV > pXLeft->iV)
        {
            if (uSpansAvail == 0)
            {
                uSpansAvail = uSpans;
                hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                if (hr != D3D_OK)
                {
                    // uSpansAvail is set to zero on failure.
                    goto EH_Exit;
                }
            }
            else
            {
                pSpan++;
            }
            uSpansAvail--;
            pStpCtx->pPrim->uSpans++;

            pSpan->uPix = (UINT16)(pXRight->iV - pXLeft->iV);
            pSpan->uX = (UINT16)pStpCtx->X20.iV;
            pSpan->uY = (UINT16)pStpCtx->iY;

            RSDPFM((RSM_WALK, "Span at Y %d, X %d, %c%d pix\n",
                    pStpCtx->iY, pSpan->uX,
                    (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                    pSpan->uPix));

            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//
// Tables of edge walkers.
// Indexing is with the low four TRISF_*_USED bits.
//

#if !defined(_X86_) || defined(X86_CPP_WALKTRAPSPANS)
#define WalkTrapFloatSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex_NoClip WalkTrapEitherSpans_Any_NoClip
#endif

// Trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFloatSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFloatSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFloatSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFixedSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFixedSpans_Z_Diff_Tex_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_Tex_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFixedSpans_Z_Tex_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Ramp mode trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -I -1 */
    WalkTrapFloatSpans_Z_Tex_NoClip,                   /* 1: -I +1 */
    WalkTrapFloatSpans_Z_DIdx_NoClip,                   /* 2: +I -1 */
    WalkTrapFloatSpans_Z_DIdx_Tex_NoClip,              /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\tstp.cpp ===
//----------------------------------------------------------------------------
//
// setup.cpp
//
// PrimProcessor setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// MINMAX3
//
// Computes the min and max of three integer values.
//
//----------------------------------------------------------------------------

#define MINMAX3(iV0, iV1, iV2, iMin, iMax)                                    \
    if ((iV0) <= (iV1))                                                       \
    {                                                                         \
        if ((iV1) <= (iV2))                                                   \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else if ((iV0) <= (iV2))                                              \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMin) = (iV2);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
    }                                                                         \
    else if ((iV1) <= (iV2))                                                  \
    {                                                                         \
        (iMin) = (iV1);                                                       \
        if ((iV0) <= (iV2))                                                   \
        {                                                                     \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMax) = (iV0);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        (iMin) = (iV2);                                                       \
        (iMax) = (iV0);                                                       \
    }

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
//
// ATTENTION Just wipe this out for now.  Need a test for W too close to
// zero to avoid numerical problems.
//#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
//    ((ASUINT32(fV0) | ASUINT32(fV1) | ASUINT32(fV2)) > INT32_FLOAT_ONE)

#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
    (1)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeTriRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                               LPD3DTLVERTEX pV2)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;
    m_dvV2RHW = pV2->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || 
        FLOAT_LTZ(pV1->dvRHW) || 
        FLOAT_LTZ(pV2->dvRHW))
    {
        RSDPF(("Triangle RHW out of range %f,%f,%f\n",
               pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        if (pV1->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV1->dvRHW;
        }
        else
        {
            fMax = pV1->dvRHW;
        }
    }
    else if (pV1->dvRHW < pV2->dvRHW)
    {
        if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else
        {
            fMax = pV0->dvRHW;
        }
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale;

    fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
    pV2->dvRHW = pV2->dvRHW * fRHWScale;

#ifdef DBG_RHW_NORM
    RSDPF(("%f,%f,%f - %f,%f,%f\n",
           m_dvV0RHW, m_dvV1RHW, m_dvV2RHW,
           pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::TriSetup
//
// Takes three vertices and does triangle setup, filling in both a
// primitive structure for the triangle and a span structure for the first
// span.  All internal intermediates and DY values are computed.
//
// Uses the current D3DI_RASTPRIM and D3DI_RASTSPAN so these pointers must
// be valid before calling this routine.
//
// Returns whether the triangle was kept or not.  Culled triangles return
// FALSE.
//
//----------------------------------------------------------------------------

BOOL
PrimProcessor::TriSetup(LPD3DTLVERTEX pV0,
                        LPD3DTLVERTEX pV1,
                        LPD3DTLVERTEX pV2)
{
    // Preserve original first vertex for flat shading reference.
    m_StpCtx.pFlatVtx = pV0;

    //
    // Sort vertices in Y.
    // This can cause ordering changes from the original vertex set
    // so track reversals.
    //
    // Determinant computation and culling could be done before this.
    // Doing so causes headaches with computing deltas up front, though,
    // because the edges may change during sorting.
    //

    LPD3DTLVERTEX pVTmp;
    UINT uReversed;

    uReversed = 0;
    if (pV0->dvSY <= pV1->dvSY)
    {
        if (pV1->dvSY <= pV2->dvSY)
        {
            // Sorted.
        }
        else if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 0 2 1.
            pVTmp = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 2 0 1.
            pVTmp = pV0;
            pV0 = pV2;
            pV2 = pV1;
            pV1 = pVTmp;
        }
    }
    else if (pV1->dvSY < pV2->dvSY)
    {
        if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 1 0 2.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 1 2 0.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
        }
    }
    else
    {
        // Sorted order is 2 1 0.
        pVTmp = pV0;
        pV0 = pV2;
        pV2 = pVTmp;
        uReversed = 1;
    }

    FLOAT fX0 = pV0->dvSX;
    FLOAT fX1 = pV1->dvSX;
    FLOAT fX2 = pV2->dvSX;
    FLOAT fY0 = pV0->dvSY;
    FLOAT fY1 = pV1->dvSY;
    FLOAT fY2 = pV2->dvSY;

    //
    // Compute x,y deltas.
    //
    m_StpCtx.fDX10 = fX1 - fX0;
    m_StpCtx.fDX20 = fX2 - fX0;
    m_StpCtx.fDY10 = fY1 - fY0;
    m_StpCtx.fDY20 = fY2 - fY0;

    //
    // Compute determinant and do culling.
    //
    FLOAT fDet;

    fDet = m_StpCtx.fDX20 * m_StpCtx.fDY10 - m_StpCtx.fDX10 * m_StpCtx.fDY20;
    if (FLOAT_EQZ(fDet))
    {
        // No area, so bail out
        return FALSE;
    }

    // Get sign of determinant.
    UINT uDetCcw = FLOAT_GTZ(fDet) ? 1 : 0;

    // If culling is off the cull sign to check against is set to a
    // value that can't be matched so this single check is sufficient
    // for all three culling cases.
    //
    // Fold in sign reversal here rather than in uDetCcw because
    // we need the true sign later to determine whether the long edge is
    // to the left or the right.
    if ((uDetCcw ^ uReversed) == m_StpCtx.pCtx->uCullFaceSign)
    {
        return FALSE;
    }

    // Snap bounding vertex Y's to pixel centers and check for trivial reject.

    m_StpCtx.iY = ICEILF(fY0);
    m_iY2 = ICEILF(fY2);

    if (m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom ||
        m_iY2 <= m_StpCtx.pCtx->Clip.top)
    {
        return FALSE;
    }

    INT iX0 = ICEILF(fX0);
    INT iX1 = ICEILF(fX1);
    INT iX2 = ICEILF(fX2);

    // Start 2 - 0 edge DXDY divide so that it's overlapped with the
    // integer processing done during X clip checking.  The assumption
    // is that it's nearly zero cost when overlapped so it's worth
    // it to start it even when the clip check rejects the triangle.
    FLOAT fDX20, fDY20, fDXDY20;

    // Need to use stack variables so the assembly can understand the
    // address.
    fDX20 = m_StpCtx.fDX20;
    fDY20 = m_StpCtx.fDY20;
    FLD_BEGIN_DIVIDE(fDX20, fDY20, fDXDY20);

    // Computing the X triangle bounds involves quite a few operations,
    // but it allows for both trivial rejection and trivial acceptance.
    // Given that guard band clipping can lead to a lot of trivial rejections
    // and that there will usually be a lot of trivial acceptance cases,
    // the work is worth it.

    INT iMinX, iMaxX;
    BOOL bXAccept;

    MINMAX3(iX0, iX1, iX2, iMinX, iMaxX);

    m_iXWidth = iMaxX - iMinX;

    // Use X bounds for trivial reject and accept.
    if (iMinX >= m_StpCtx.pCtx->Clip.right ||
        iMaxX <= m_StpCtx.pCtx->Clip.left ||
        m_iXWidth <= 0)
    {
        bXAccept = FALSE;
    }
    else
    {
        if (iMinX >= m_StpCtx.pCtx->Clip.left &&
            iMaxX <= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.uFlags |= PRIMF_TRIVIAL_ACCEPT_X;
        }
        else
        {
            RSDPFM((RSM_XCLIP, "XClip bounds %5d - %5d, %5d\n",
                    iMinX, iMaxX, m_iXWidth));
        }

        bXAccept = TRUE;
    }

    // Complete divide.
    FSTP_END_DIVIDE(fDXDY20);

    if (!bXAccept)
    {
        return FALSE;
    }

    // Clamp triangle Y's to clip rect.

    m_iY1 = ICEILF(fY1);

    if (m_StpCtx.iY < m_StpCtx.pCtx->Clip.top)
    {
        RSDPFM((RSM_YCLIP, "YClip iY %d to %d\n",
                m_StpCtx.iY, m_StpCtx.pCtx->Clip.top));

        m_StpCtx.iY = m_StpCtx.pCtx->Clip.top;

        if (m_iY1 < m_StpCtx.pCtx->Clip.top)
        {
            RSDPFM((RSM_YCLIP, "YClip iY1 %d to %d\n",
                    m_iY1, m_StpCtx.pCtx->Clip.top));

            m_iY1 = m_StpCtx.pCtx->Clip.top;
        }
    }

    if (m_iY1 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY1 %d, iY2 %d to %d\n",
                m_iY1, m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY1 = m_StpCtx.pCtx->Clip.bottom;
        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }
    else if (m_iY2 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY2 %d to %d\n",
                m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }

    // Compute Y subpixel correction.  This will include any Y
    // offset due to clamping.
    m_StpCtx.fDY = m_StpCtx.iY - fY0;

    // Compute trapzeoid heights.  These will be restricted to
    // lie in the clip rect.

    RSASSERT(m_iY1 >= m_StpCtx.iY && m_iY2 >= m_iY1);

    m_uHeight10 = m_iY1 - m_StpCtx.iY;
    m_uHeight21 = m_iY2 - m_iY1;

    m_uHeight20 = m_uHeight10 + m_uHeight21;
    if (m_uHeight20 == 0)
    {
        // Triangle doesn't cover any pixels.
        return FALSE;
    }

    RSDPFM((RSM_TRIS, "Tstp (%.4f,%.4f) (%.4f,%.4f) (%.4f,%.4f)\n",
            fX0, fY0, fX1, fY1, fX2, fY2));
    RSDPFM((RSM_TRIS, "    (%.4f,%.4f : %.4f,%.4f) %d:%d det %.4f\n",
            m_StpCtx.fDX10, m_StpCtx.fDY10,
            m_StpCtx.fDX20, m_StpCtx.fDY20,
            m_uHeight10, m_uHeight21, fDet));
    RSDPFM((RSM_Z, "    Z (%f) (%f) (%f)\n",
        pV0->dvSZ, pV1->dvSZ, pV2->dvSZ));
    RSDPFM((RSM_DIFF, "    diff (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_DIDX, "    didx (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_SPEC, "    spec (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcSpecular & 0xffffff, pV1->dcSpecular & 0xffffff,
            pV2->dcSpecular & 0xffffff));
    RSDPFM((RSM_OOW, "    OoW (%f) (%f) (%f)\n",
            pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    RSDPFM((RSM_TEX1, "    Tex1 (%f,%f) (%f,%f) (%f,%f)\n",
            pV0->dvTU, pV0->dvTV, pV1->dvTU, pV1->dvTV,
            pV2->dvTU, pV2->dvTV));
    RSDPFM((RSM_FOG, "    Fog (0x%02X) (0x%02X) (0x%02X)\n",
            RGBA_GETALPHA(pV0->dcSpecular),
            RGBA_GETALPHA(pV1->dcSpecular),
            RGBA_GETALPHA(pV2->dcSpecular)));

    // Compute dx/dy for edges and initial X's.

    m_StpCtx.fDX = m_StpCtx.fDY * fDXDY20;
    FLOAT fX20 = fX0 + m_StpCtx.fDX;

    ComputeIntCarry(fX20, fDXDY20, &m_StpCtx.X20);
    m_StpCtx.fX20NC = (FLOAT)m_StpCtx.X20.iNC;
    m_StpCtx.fX20CY = (FLOAT)m_StpCtx.X20.iCY;

    RSDPFM((RSM_TRIS, "    edge20  %f dxdy %f\n", fX20, fDXDY20));
    RSDPFM((RSM_TRIS, "            (?.%d d %d nc %d cy %d)\n",
            m_StpCtx.X20.iFrac,
            m_StpCtx.X20.iDFrac, m_StpCtx.X20.iNC, m_StpCtx.X20.iCY));

    if (m_uHeight10 > 0)
    {
        FLOAT fDXDY10;
        FLOAT fX10;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_EQZ(m_StpCtx.fDX10))
        {
            fDXDY10 = g_fZero;
            fX10 = fX0;
        }
        else
#endif
        {
            fDXDY10 = m_StpCtx.fDX10 / m_StpCtx.fDY10;
            fX10 = fX0 + m_StpCtx.fDY * fDXDY10;
        }

        m_StpCtx.X10.iV = ICEILF(fX10);
        ComputeIntCarry(fX10, fDXDY10, &m_StpCtx.X10);

        RSDPFM((RSM_TRIS, "    edge10  %f dxdy %f\n", fX10, fDXDY10));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X10.iV, m_StpCtx.X10.iFrac,
                m_StpCtx.X10.iDFrac, m_StpCtx.X10.iNC, m_StpCtx.X10.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X10, 0, sizeof(m_StpCtx.X10));
    }
#endif

    if (m_uHeight21 > 0)
    {
        FLOAT fDXDY21;
        FLOAT fX21;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_COMPARE(fX1, ==, fX2))
        {
            fDXDY21 = g_fZero;
            fX21 = fX1;
        }
        else
#endif
        {
            fDXDY21 = (fX2 - fX1) / (fY2 - fY1);
            fX21 = fX1 + (m_iY1 - fY1) * fDXDY21;
        }

        m_StpCtx.X21.iV = ICEILF(fX21);
        ComputeIntCarry(fX21, fDXDY21, &m_StpCtx.X21);

        RSDPFM((RSM_TRIS, "    edge21  %f dxdy %f\n", fX21, fDXDY21));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X21.iV, m_StpCtx.X21.iFrac,
                m_StpCtx.X21.iDFrac, m_StpCtx.X21.iNC, m_StpCtx.X21.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X21, 0, sizeof(m_StpCtx.X21));
    }
#endif

    // The edge walker always walks the long edge so it may either
    // be a left or a right edge.  Determine what side the long edge
    // is and perform appropriate snapping and subpixel adjustment
    // computations.
    //
    // The clip-clamped initial X pixel position is also computed and
    // any necessary offset added into the subpixel correction delta.

    if (uDetCcw)
    {
        // Long edge (0-2) is to the right.

        m_StpCtx.uFlags |= TRIF_X_DEC;
        m_StpCtx.pPrim->uFlags = D3DI_RASTPRIM_X_DEC;

        m_StpCtx.X20.iV = ICEILF(fX20) - 1;

        // Other edges are left edges.  Bias them back by one
        // so that the span width computation can do R - L
        // rather than R - L + 1.
        m_StpCtx.X10.iV--;
        m_StpCtx.X21.iV--;

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV >= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.right - 1;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }
    else
    {
        // Long edge (0-2) is to the left.

        m_StpCtx.pPrim->uFlags = 0;

        m_StpCtx.X20.iV = ICEILF(fX20);

        // Other edges are right edges.  The ICEILF snapping done
        // already leaves them off by one so that R - L works.

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV < m_StpCtx.pCtx->Clip.left)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.left;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }

    // Update X subpixel correction.  This delta includes any
    // offseting due to clamping of the initial pixel position.
    m_StpCtx.fDX += m_StpCtx.iX - fX20;

    RSDPFM((RSM_TRIS, "    subp    %f,%f\n", m_StpCtx.fDX, m_StpCtx.fDY));

    // Compute span-to-span steps for buffer pointers.
    m_StpCtx.DAttrNC.ipSurface = m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipZ = m_StpCtx.pCtx->iZStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iZStep;

    // Start one over determinant divide.  Done after the multiplies
    // since integer multiplies require some of the FP unit.

    FLOAT fOoDet;

    FLD_BEGIN_DIVIDE(g_fOne, fDet, fOoDet);

    if (m_StpCtx.X20.iCY > m_StpCtx.X20.iNC)
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface +
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ + m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface -
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ - m_StpCtx.pCtx->iZStep;
    }

    //
    // Compute attribute functions.
    //

    // Set pure X/Y step deltas for surface and Z so that DX, DY, CY and NC all
    // have complete information and can be used interchangeably.
    if (m_StpCtx.uFlags & TRIF_X_DEC)
    {
        m_StpCtx.DAttrDX.ipSurface = -m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = -m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrDX.ipSurface = m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = m_StpCtx.pCtx->iZStep;
    }
    m_StpCtx.DAttrDY.ipSurface = m_StpCtx.pCtx->iSurfaceStride;
    m_StpCtx.DAttrDY.ipZ = m_StpCtx.pCtx->iZStride;

    // Finish overlapped divide.
    FSTP_END_DIVIDE(fOoDet);

    m_StpCtx.fOoDet = fOoDet;

    // The PrimProcessor is created zeroed out so the initial
    // state is FP clean.  Later uses may put FP values in slots but
    // they should still be valid, so the optional computations here
    // should never result in FP garbage.  It should therefore be
    // OK to use any mixture of attribute handlers since there should
    // never be any case where FP garbage will creep in.

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE3(pV0->dvRHW, pV1->dvRHW, pV2->dvRHW))
    {
        NormalizeTriRHW(pV0, pV1, pV2);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    TriSetup_Start(&m_StpCtx, pV0, pV1, pV2);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
        pV2->dvRHW = m_dvV2RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\makefile.inc ===
$(GENTGT)\bdstr_mh.h: ..\bdstr_mh.mh $(RAST_STD_M4)

$(GENTGT)\beadstr.cpp: ..\beadstr.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\spaninit.cpp: ..\spaninit.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3dhal.h>

#include "rast.h"
#include "spindbg.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\spaninit\sources.inc ===
TARGETNAME = rspanini
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\beadstr.cpp\
        $O\spaninit.cpp\
        ..\spindbg.cpp\
        ..\rastcoll.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = \
        $O\bdstr_mh.h\
        $O\beadstr.cpp\
        $O\spaninit.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipper.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.h
 *  Content:    Clipper definitions
 *
 ***************************************************************************/
#ifndef _CLIPPER_H_
#define _CLIPPER_H_

//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define D3DCLIP_LEFTBIT     1
#define D3DCLIP_RIGHTBIT    2
#define D3DCLIP_TOPBIT      3
#define D3DCLIP_BOTTOMBIT   4
#define D3DCLIP_FRONTBIT    5
#define D3DCLIP_BACKBIT     6
#define D3DCLIPGB_LEFTBIT   13
#define D3DCLIPGB_RIGHTBIT  14
#define D3DCLIPGB_TOPBIT    15
#define D3DCLIPGB_BOTTOMBIT 16

const DWORD __DEBUG_MULTILOOP = 1;      // Disable multi-loop geometry pipeline
const DWORD __DEBUG_ONEPASS = 2;        // Disable clip and light in one pass
const DWORD __DEBUG_MODELSPACE = 4;     // Disable lighting in model space

//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                         DWORD clipFlag, BOOL transformed);
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
void MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in);

#endif // _CLIPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.c
 *  Content:    Clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipper.h"
#include "d3dfei.h"

#define GET_NEW_CLIP_VERTEX \
&pv->ClipperState.clip_vertices[pv->ClipperState.clip_vertices_used++];
//---------------------------------------------------------------------
void SetInterpolationFlags(LPD3DFE_PROCESSVERTICES pv)
{
    // Figure out which pieces need to be interpolated in new vertices.
    pv->dwDeviceFlags &= ~(D3DDEV_INTERPOLATE_COLOR | D3DDEV_INTERPOLATE_SPECULAR);
    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD)
    {
        pv->dwDeviceFlags |= D3DDEV_INTERPOLATE_COLOR;
        if (pv->dwVIDOut & D3DFVF_SPECULAR)
            pv->dwDeviceFlags |= D3DDEV_INTERPOLATE_SPECULAR;
    }
}
//---------------------------------------------------------------------
__inline void
InterpolateColor(ClipVertex *p,
                 ClipVertex *p1,
                 ClipVertex *p2,
                 D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->color);
    g1 = RGBA_GETGREEN(p1->color);
    b1 = RGBA_GETBLUE(p1->color);
    a1 = RGBA_GETALPHA(p1->color);
    r2 = RGBA_GETRED(p2->color);
    g2 = RGBA_GETGREEN(p2->color);
    b2 = RGBA_GETBLUE(p2->color);
    a2 = RGBA_GETALPHA(p2->color);
    p->color = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                         (WORD)(g1 + (g2 - g1) * num_denom),
                         (WORD)(b1 + (b2 - b1) * num_denom),
                         (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
__inline void
InterpolateSpecular(ClipVertex *p,
                    ClipVertex *p1,
                    ClipVertex *p2,
                    D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->specular);
    g1 = RGBA_GETGREEN(p1->specular);
    b1 = RGBA_GETBLUE(p1->specular);
    a1 = RGBA_GETALPHA(p1->specular);
    r2 = RGBA_GETRED(p2->specular);
    g2 = RGBA_GETGREEN(p2->specular);
    b2 = RGBA_GETBLUE(p2->specular);
    a2 = RGBA_GETALPHA(p2->specular);
    p->specular = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                            (WORD)(g1 + (g2 - g1) * num_denom),
                            (WORD)(b1 + (b2 - b1) * num_denom),
                            (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
__inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
        return ((t2 - t1) * num_denom + t1);
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f)
            t -= 1.0f;
        return t;
    }
}
//---------------------------------------------------------------------
void
Interpolate(D3DFE_PROCESSVERTICES *pv,
            ClipVertex *p,
            ClipVertex *p1,
            ClipVertex *p2,
            int code,
            D3DVALUE num, D3DVALUE denom)
{
    D3DVALUE num_denom = num / denom;

    p->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    p->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    p->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    p->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    p->hw = p1->hw + (p2->hw - p1->hw) * num_denom;
    p->color = pv->ClipperState.clip_color;
    p->specular = pv->ClipperState.clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if (pv->dwDeviceFlags & D3DDEV_INTERPOLATE_COLOR)
    {
        InterpolateColor(p, p1, p2, num_denom);
    }

    if (pv->dwDeviceFlags & D3DDEV_INTERPOLATE_SPECULAR)
    {
        InterpolateSpecular(p, p1, p2, num_denom);
    }

    // Assume that D3DRENDERSTATE_WRAPi are sequential
    D3DVALUE *pTexture1 = p1->tex;
    D3DVALUE *pTexture2 = p2->tex;
    D3DVALUE *pTexture = p->tex;
    for (DWORD i = 0; i < pv->nOutTexCoord; i++)
    {
        DWORD wrapState = pv->lpdwRStates[D3DRENDERSTATE_WRAP0 + i];
        DWORD n = (DWORD)(pv->dwTextureCoordSize[i] >> 2);
        DWORD dwWrapBit = 1;
        for (DWORD j=0; j < n; j++)
        {
            *pTexture = InterpolateTexture(*pTexture1, *pTexture2,
                                           num_denom, wrapState & dwWrapBit);
            dwWrapBit <<= 1;
            pTexture ++;
            pTexture1++;
            pTexture2++;
        }
    }
}
//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND
//
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//
int ClipByPlane (D3DFE_PROCESSVERTICES *pv,
                 ClipVertex **inv, 
                 ClipVertex **outv,
                 D3DVECTORH *plane,
                 DWORD dwClipFlag,
                 int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->hx*plane->x + prev->hy*plane->y + 
                  prev->hz*plane->z + prev->hw*plane->w;
    for (i = count; i; i--) 
    {
        curr_inside = curr->hx*plane->x + curr->hy*plane->y + 
                      curr->hz*plane->z + curr->hw*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | dwClipFlag,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            dwClipFlag,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int ClipLineByPlane(D3DFE_PROCESSVERTICES *pv, 
                    ClipTriangle *line, 
                    D3DVECTORH *plane,
                    DWORD dwClipBit)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
    in1 = line->v[0]->hx * plane->x + 
          line->v[0]->hy * plane->y + 
          line->v[0]->hz * plane->z + 
          line->v[0]->hw * plane->w;
    in2 = line->v[1]->hx * plane->x + 
          line->v[1]->hy * plane->y + 
          line->v[1]->hz * plane->z + 
          line->v[1]->hw * plane->w;
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void ComputeScreenCoordinates(D3DFE_PROCESSVERTICES *pv,
                              ClipVertex **inv,
                              int count, D3DRECTV *extent)
{
    int i;
    BOOL updateExtent = !(pv->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS);
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;

    for (i = 0; i < count; i++)
    {
        ClipVertex *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         *      1) Vertices generated during interpolation
         *      2) Vertices marked for clipping by the transform but
         *              not clipped here due to the finite precision
         *              of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE)
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->sx = VPORT.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VPORT.maxXgb; break;
            default:
                p->sx = p->hx * VPORT.scaleX * w + VPORT.offsetX;
                if (p->sx < VPORT.minXgb)
                        p->sx = VPORT.minXgb;
                if (p->sx > VPORT.maxXgb)
                        p->sx = VPORT.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->sy = VPORT.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VPORT.minYgb; break;
            default:
                p->sy = p->hy * VPORT.scaleY * w + VPORT.offsetY;
                if (p->sy < VPORT.minYgb)
                        p->sy = VPORT.minYgb;
                if (p->sy > VPORT.maxYgb)
                        p->sy = VPORT.maxYgb;
            }
            p->sz = p->hz * w * pv->vcache.scaleZ + pv->vcache.offsetZ;
            p->rhw = w;
            if (updateExtent)
            {
                if (p->sx < extent->x1)
                    extent->x1 = p->sx;
                if (p->sy < extent->y1)
                    extent->y1 = p->sy;
                if (p->sx  > extent->x2)
                    extent->x2 = p->sx;
                if (p->sy > extent->y2)
                    extent->y2 = p->sy;
            }
        }
    }
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeUserPlanes(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = D3DCLIP_GEN0;
    for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
    {
        if ((p->hx*pv->userClipPlane[i].x + 
             p->hy*pv->userClipPlane[i].y + 
             p->hz*pv->userClipPlane[i].z + 
             p->hw*pv->userClipPlane[i].w) < 0)
        {
            clip |= dwClipBit;
        }
        dwClipBit <<= 1;
    }
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * pv->vcache.Kgbx1)
        clip |= __D3DCLIPGB_LEFT;
    if (p->hx > p->hw * pv->vcache.Kgbx2)
        clip |= __D3DCLIPGB_RIGHT;
    if (p->hy < p->hw * pv->vcache.Kgby1)
        clip |= __D3DCLIPGB_BOTTOM;
    if (p->hy > p->hw * pv->vcache.Kgby2)
        clip |= __D3DCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= D3DCLIP_LEFT;
    if (p->hx > p->hw)
        clip |= D3DCLIP_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= D3DCLIP_BOTTOM;
    if (p->hy > p->hw)
        clip |= D3DCLIP_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(pv, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//***********************************************************************
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int D3DFE_PVFUNCS::ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                      ClipTriangle *tri,
                                      ClipVertex ***clipVertexPointer)
{
    int accept;
    int i;
    int count;
    ClipVertex **inv;
    ClipVertex **outv;
    ClipVertex *p;
    ULONG_PTR swapv;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;

    count = 3;
    outv = pv->ClipperState.clip_vbuf1;
    pv->ClipperState.clip_color = tri->v[0]->color;
    pv->ClipperState.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)pv->ClipperState.clip_vbuf1;
        tmp2 = (ULONG_PTR)pv->ClipperState.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    pv->ClipperState.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (ClipVertex**) (swapv - (ULONG_PTR) outv)

    if (accept & D3DCLIP_FRONT)
    {
        count = ClipFront(pv, inv, outv, count);
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_LEFT)
        {
            count = ClipLeftGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_RIGHT)
        {
            count = ClipRightGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_BOTTOM)
        {
            count = ClipBottomGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_TOP)
        {
            count = ClipTopGB(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK)
        {
            count = ClipBack(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_LEFT)
        {
            count = ClipLeft(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_RIGHT)
        {
            count = ClipRight(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_BOTTOM)
        {
            count = ClipBottom(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_TOP)
        {
            count = ClipTop(pv, inv, outv, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCLIP_GEN0;
        DWORD dwClippedBit = CLIPPED_GEN0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                count = ClipByPlane(pv, inv, outv, &pv->userClipPlane[i], 
                                    dwClippedBit, count);
                if (count < 3)
                    goto out_of_here;
                SWAP(inv, outv);
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

#undef SWAP

    ComputeScreenCoordinates(pv, inv, count, &pv->rExtents);

    *clipVertexPointer = inv;
    pv->ClipperState.current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}
//*************************************************************************
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleLine"

int
ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
               ClipTriangle *line,
               D3DRECTV *extent)
{
    int         accept;
    D3DVALUE    in1, in2;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (line->v[0]->clip | line->v[1]->clip);

    pv->ClipperState.clip_color = line->v[0]->color;
    pv->ClipperState.clip_specular = line->v[0]->specular;

    if (accept & D3DCLIP_FRONT)
        if (ClipLineFront(pv, line))
            goto out_of_here;
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_LEFT)
            if (ClipLineLeftGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_RIGHT)
            if (ClipLineRightGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_TOP)
            if (ClipLineTopGB(pv, line))
                goto out_of_here;
        if (accept & __D3DCLIPGB_BOTTOM)
            if (ClipLineBottomGB(pv, line))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_LEFT)
            if (ClipLineLeft(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_RIGHT)
            if (ClipLineRight(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_TOP)
            if (ClipLineTop(pv, line))
                goto out_of_here;
        if (accept & D3DCLIP_BOTTOM)
            if (ClipLineBottom(pv, line))
                goto out_of_here;
    }
    if (pv->dwMaxUserClipPlanes)
    {
        DWORD dwClipBit = D3DCLIP_GEN0;
        DWORD dwClippedBit = CLIPPED_GEN0;
        for (DWORD i=0; i < pv->dwMaxUserClipPlanes; i++)
        {
            if (accept & dwClipBit)
            {
                if (ClipLineByPlane(pv, line, &pv->userClipPlane[i], 
                                    dwClippedBit))
                    goto out_of_here;
            }
            dwClipBit <<= 1;
            dwClippedBit <<= 1;
        }
    }

    ComputeScreenCoordinates(pv, line->v, 2, extent);

    return 1;
out_of_here:
    return 0;
} // ClipSingleLine
//----------------------------------------------------------------------
//    GenClipFlags()  Generates clip flags for a set of FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "GenClipFlags"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    DWORD clip_intersection, clip_union;
    float left   = pv->vcache.minX;
    float top    = pv->vcache.minY;
    float right  = pv->vcache.maxX;
    float bottom = pv->vcache.maxY;
    float leftgb  ;         // Guard band window
    float topgb   ;
    float rightgb ;
    float bottomgb;
    DWORD clipZF, clipZB;
    DWORD stride = pv->position.dwStride;

    clipZF = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_FRONT : 0;
    clipZB = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_BACK : 0;

    clip_intersection = (DWORD)~0;
    clip_union = (DWORD)0;

    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        leftgb   = pv->vcache.minXgb;
        topgb    = pv->vcache.minYgb;
        rightgb  = pv->vcache.maxXgb;
        bottomgb = pv->vcache.maxYgb;
    }
    if (pv->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS)
    { /* Only generate clip flags */
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        DWORD i;
        for (i = pv->dwNumVertices; i; i--)
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left)
                clip |= D3DCLIP_LEFT;
            else
            if (x >= right)
                clip |= D3DCLIP_RIGHT;

            if (y < top)
                clip |= D3DCLIP_TOP;
            else
            if (y >= bottom)
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f)
                clip |= clipZF;
            else
            if (z >= 1.0f)
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb)
                    clip |= __D3DCLIPGB_LEFT;
                else
                if (x >= rightgb)
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb)
                    clip |= __D3DCLIPGB_TOP;
                else
                if (y >= bottomgb)
                    clip |= __D3DCLIPGB_BOTTOM;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
    }
    else
    { /* Generate Clip Flags and Update Extents */
        DWORD i;
        float minx = pv->rExtents.x1;
        float miny = pv->rExtents.y1;
        float maxx = pv->rExtents.x2;
        float maxy = pv->rExtents.y2;
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        for (i = pv->dwNumVertices; i; i--)
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left)
                clip |= D3DCLIP_LEFT;
            else
            if (x >= right)
                clip |= D3DCLIP_RIGHT;

            if (y < top)
                clip |= D3DCLIP_TOP;
            else
            if (y >= bottom)
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f)
                clip |= clipZF;
            else
            if (z >= 1.0f)
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb)
                    clip |= __D3DCLIPGB_LEFT;
                else
                if (x >= rightgb)
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb)
                    clip |= __D3DCLIPGB_TOP;
                else
                if (y >= bottomgb)
                    clip |= __D3DCLIPGB_BOTTOM;
            }
            // Update extents only if the vertex is inside
            if (clip == 0 || 
                ((pv->dwDeviceFlags & D3DDEV_GUARDBAND) && 
                 ((clip & ~__D3DCLIP_INGUARDBAND) == 0)))
            {
                if (x < minx)
                    minx = x;
                if (x > maxx)
                    maxx = x;
                if (y < miny)
                    miny = y;
                if (y > maxy)
                    maxy = y;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
        pv->rExtents.x1 = minx;
        pv->rExtents.y1 = miny;
        pv->rExtents.x2 = maxx;
        pv->rExtents.y2 = maxy;
    }

    pv->dwClipIntersection = clip_intersection;
    pv->dwClipUnion = clip_union;

    return clip_intersection;
}   // end of GenClipFlags()
//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                          DWORD clipFlag, BOOL transformed)
{                                                               
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    BYTE *v = (BYTE*)p1;                                               
    if (transformed || !(clipFlag & pv->dwClipMaskOffScreen))         
    {                                                           
        pp1.sx  = ((D3DVALUE*)v)[0];                            
        pp1.sy  = ((D3DVALUE*)v)[1];                            
        pp1.sz  = ((D3DVALUE*)v)[2];                            
        pp1.rhw = ((D3DVALUE*)v)[3];
        pp1.hw  = 1.0f / ((D3DVALUE*)v)[3];                     
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw * VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw * VPORT.scaleYi;                                
        pp1.hz  = (pp1.sz - VPORT.offsetZ) * pp1.hw * VPORT.scaleZi;
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = ((D3DVALUE*)v)[0];                             
        pp1.hy = ((D3DVALUE*)v)[1];                             
        pp1.hz = ((D3DVALUE*)v)[2];                             
        pp1.hw = ((D3DVALUE*)v)[3];                             
    }                                                           
    v += sizeof(D3DVALUE) * 4;                                  
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)                   
    {                                                           
        pp1.color   = *(DWORD*)v;                               
        v += sizeof(D3DVALUE);                                  
                                                                
    }                                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)                  
    {                                                           
        pp1.specular= *(DWORD*)v;                               
        v += sizeof(DWORD);                                     
    }                                                           
    memcpy(pp1.tex, v, pv->dwTextureCoordSizeTotal);
    pp1.clip = clipFlag; 
}              
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
void MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in)
{
    *(D3DVECTORH*)out = *(D3DVECTORH*)&(in)->sx;               
    *(DWORD*)&out[pv->diffuseOffsetOut]  =  (in)->color;               
    *(DWORD*)&out[pv->specularOffsetOut] =  (in)->specular;               
    memcpy(&out[pv->texOffsetOut], in->tex, pv->dwTextureCoordSizeTotal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipfunc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipfunc.h
 *  Content:    Clipper functions
 *
 ***************************************************************************/

#ifndef _CLIPFUNC_H_
#define _CLIPFUNC_H_

#include "clipper.h"

int ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
                   ClipTriangle *line,
                   D3DRECTV *extent);

HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleList (D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedLine(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleList (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedLine(D3DFE_PROCESSVERTICES *pv);
DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);

//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of a primitive
//
inline HRESULT DRAW_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType,
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    return pv->DrawPrim();
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw clipped part of a primitive
//
inline HRESULT DRAW_CLIPPED_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType, 
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;                                    
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    return pv->DrawClippedPrim();
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of an 
// indexed primitive
//
inline HRESULT DRAW_INDEX_PRIM(D3DFE_PROCESSVERTICES *pv, 
                               D3DPRIMITIVETYPE primitiveType, 
                               LPWORD startIndex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpwIndices = startIndex;                                     
    pv->primType = primitiveType;                                    
    pv->dwNumIndices = vertexCount;                                  
    pv->dwNumPrimitives = numPrim;                                   
    return pv->DrawIndexPrim();
}
//----------------------------------------------------------------------
// Clip a triangle made by 3 vertices
// bCanModifyVertices is set to TRUE, if the function can modify the original 
// vertices
//
HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2, ClipVertex *cv3);
HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2);

#endif // _CLIPFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\d3dfei.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfei.hpp
 *  Content:    Direct3D frontend internal include file
 *
 ***************************************************************************/
#ifndef _D3DFEI_H_
#define _D3DFEI_H_

#include "tlhal.h"
#include "clipper.h"

extern void setIdentity(D3DMATRIXI * m);
extern void MatrixProduct(D3DMATRIXI *d, D3DMATRIXI *a, D3DMATRIXI *b);
extern void D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI);
extern void D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to);
extern void SetInterpolationFlags(LPD3DFE_PROCESSVERTICES pv);
extern LIGHT_VERTEX_FUNC_TABLE lightVertexTable;

//---------------------------------------------------------------------
// Clamp extents to viewport window.
// For guard band it is possible that extents are outside viewport window
// after clipping
//
inline void ClampExtents(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && 
        !(pv->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS))
    {
        if (pv->rExtents.x1 < pv->vcache.minX)
            pv->rExtents.x1 = pv->vcache.minX;
        if (pv->rExtents.x2 > pv->vcache.maxX)
            pv->rExtents.x2 = pv->vcache.maxX;
        if (pv->rExtents.y1 < pv->vcache.minY)
            pv->rExtents.y1 = pv->vcache.minY;
        if (pv->rExtents.y2 > pv->vcache.maxY)
            pv->rExtents.y2 = pv->vcache.maxY;
    }
}
//---------------------------------------------------------------------
// Returns TRUE if cipping is needed
//
inline BOOL CheckIfNeedClipping(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        if (pv->dwClipUnion & ~__D3DCLIP_INGUARDBAND)
            return  TRUE;
    }
    else
        if (pv->dwClipUnion)
            return  TRUE;
    return FALSE;
}
//---------------------------------------------------------------------
// Updates lighting and computes process vertices flags
//
extern void DoUpdateState(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
// Updates clip status in the device
//
// We have to mask all guard band bits
//
inline void D3DFE_UpdateClipStatus(LPDIRECT3DDEVICEI lpDevI)
{
    lpDevI->iClipStatus |= lpDevI->dwClipUnion & D3DSTATUS_CLIPUNIONALL;
    lpDevI->iClipStatus &= (~D3DSTATUS_CLIPINTERSECTIONALL |
                         ((lpDevI->dwClipIntersection & D3DSTATUS_CLIPUNIONALL) << 12));
}
#endif // _D3DFEI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\clipprim.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip primitives
 *
 * The following symbol should be defined before included this file:
 * __PROCESS_LINE_NAME  - name for a function to clip triangles
 * __INDEX_PRIM         - name for a function to clip lines
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
#ifdef __INDEX_PRIM
#define __DRAW DRAW_INDEX_PRIM
#else
#define __DRAW DRAW_PRIM
#endif

//*********************************************************************
HRESULT __PROCESS_TRI_LIST_NAME(D3DFE_PROCESSVERTICES *pv)
{
    int vertexSize3;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD      startVertex = pv->lpwIndices;
    LPWORD      index = pv->lpwIndices;
    DWORD       triangleSize;   // 3 for DrawPrimitives, 
                                // 4 for ExecuteBuffers (include wFlags)
    triangleSize = 3;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

    vertexSize3 = vertexSize*3;
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {// This tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                DWORD vertexCount = primitiveCount*3;
                ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                             vertexCount, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = index + triangleSize;
#else
            pv->dwVertexBase += 3;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize3;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped
            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                p1 = vertex + v1*vertexSize;
                p2 = vertex + v2*vertexSize;
                p3 = vertex + v3*vertexSize;
#else
                p1 = vertex;
                p2 = vertex + vertexSize;
                p3 = p2 + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

#ifdef __INDEX_PRIM
#endif
                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            primitiveCount++;
#ifdef __INDEX_PRIM
        index += triangleSize;
#else
        clipCode += 3;
        vertex += vertexSize3;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                     primitiveCount*3, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT __PROCESS_TRI_STRIP_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD lastIndex;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int           primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

    lastIndex = pv->dwNumPrimitives;
    for (i=0; i < lastIndex; i++) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                             primitiveCount+2, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += primitiveCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[1];
#else
            pv->dwVertexBase++;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                if (i & 1)
                { // For odd triangles we have to change orientation
                  // First vertex should remain the first, because it defines
                  // the color in FLAT shade mode
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v3*vertexSize;
                    p3 = vertex + v2*vertexSize;
                }
                else
                {
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v2*vertexSize;
                    p3 = vertex + v3*vertexSize;
                }

#else
                p1 = vertex;
                if (i & 1)
                { // For odd triangles we have to change orientation
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p3 = vertex + vertexSize;
                    p2 = p3 + vertexSize;
                }
                else
                {
                    p2 = vertex + vertexSize;
                    p3 = p2 + vertexSize;
                }
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
        {
            if (primitiveCount == 0 && i & 1)
            { // Triangle strip can not start from an odd triangle
              // Because we use triangle fan, first vertex in the strip
              // should be the second in the fan. 
              // This vertex defines the color in FLAT shading case.
                BYTE tmp[__MAX_VERTEX_SIZE*3];
                BYTE *p = tmp;
#ifdef __INDEX_PRIM
                BYTE *saveVer = (BYTE*)pv->lpvOut;   
                DWORD numVer = pv->dwNumVertices;  
                memcpy (p, vertex + v2*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v1*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v3*vertexSize, vertexSize);
#else
                memcpy(p, vertex + vertexSize, vertexSize);
                p += vertexSize;
                memcpy(p, vertex, vertexSize);
                p += vertexSize;
                memcpy(p, vertex + vertexSize + vertexSize, vertexSize);
#endif
                pv->dwFlags |= D3DPV_NONCLIPPED; 
                ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, tmp, 3, 1);
                pv->dwFlags &= ~D3DPV_NONCLIPPED;
                if (ret)
                    return ret;
                primitiveCount = 0;
#ifdef __INDEX_PRIM
                startVertex = &index[1];
                pv->lpvOut = saveVer;
                pv->dwNumVertices = numVer;
#else
                pv->dwVertexBase++;
                D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
                startVertex = vertex + vertexSize;
#endif
            }   
            else
                primitiveCount++;
        }
#ifdef __INDEX_PRIM
        index++;
#else
        clipCode++;
        vertex += vertexSize;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                     primitiveCount+2, primitiveCount);
        if (ret)
            return ret;
#ifndef __INDEX_PRIM
        pv->dwVertexBase += primitiveCount;
#endif
    }
    return D3D_OK;
} 
//-----------------------------------------------------------------------------
// The same functions is used for line lists and line strips
//
HRESULT __PROCESS_LINE_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD nextLineOffset;       // How many vertices to skip, when going to 
                                // next primitive (1 for strips, 2 for lists)
    DWORD countAdd;             // Used to compute "real" number of vertices
                                // from the vertexCount
    D3DPRIMITIVETYPE primType;
    int numPrim = 0;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;                               
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         vertexCount;    // Primitive count for line strips, 
                                // vertex count for line lists
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    primType = pv->primType;
    if (primType == D3DPT_LINESTRIP)
    {
        nextLineOffset = 1;
        countAdd = 1;
    }
    else
    {
        nextLineOffset = 2;
        countAdd = 0;
    }
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        WORD f1, f2;
#ifdef __INDEX_PRIM
        WORD v1, v2;
        v1 = index[0];
        v2 = index[1];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2) 
            offFrustum = TRUE;
        else
        if ((f1 | f2) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {      // if this line does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            vertexCount = 0;
            numPrim = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[nextLineOffset];
#else
            pv->dwVertexBase += nextLineOffset;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + nextLineOffset*vertexSize;
#endif

            // now deal with the single clipped line
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
#ifdef __INDEX_PRIM
                BYTE *p1 = vertex + v1*vertexSize;
                BYTE *p2 = vertex + v2*vertexSize;
#else
                BYTE *p1 = vertex;
                BYTE *p2 = vertex + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);

                ret = ClipLine(pv, &cv[0], &cv[1]);
                if (ret != D3D_OK)
                    return ret;
            }
        } 
        else 
        {
            vertexCount += nextLineOffset;
            numPrim++;
        }
#ifdef __INDEX_PRIM
        index += nextLineOffset;
#else
        vertex += nextLineOffset*vertexSize;
        clipCode += nextLineOffset;
#endif
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
        if (ret)
            return ret;
    }
    return D3D_OK;
}

#undef __DRAW
#undef __INDEX_PRIM
#undef __PROCESS_LINE_NAME
#undef __PROCESS_TRI_LIST_NAME
#undef __PROCESS_TRI_STRIP_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include "d3dpr.hpp"
#include "haldrv.hpp"
#include "fltval.h"
#include "d3dfei.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
__CLIP_NAME(D3DFE_PROCESSVERTICES *pv,
            ClipVertex **inv, 
            ClipVertex **outv,
            int count)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * pv->vcache.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * pv->vcache.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int __CLIP_LINE_NAME(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\dpclip.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpclip.c
 *  Content:    DrawPrimitive clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipfunc.h"
#include "drawprim.hpp"

//----------------------------------------------------------------------
HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2, ClipVertex *cv3)
{
    ClipTriangle newtri;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    newtri.v[0] = cv1;
    newtri.v[1] = cv2;
    newtri.v[2] = cv3;

    int count;
    ClipVertex** ver;
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    cv1->clip |= CLIPPED_ENABLE;
    cv2->clip |= CLIPPED_ENABLE;
    cv3->clip |= CLIPPED_ENABLE;
    // For the  flat shading mode we have to use first vertex color as 
    // color for all vertices
    D3DCOLOR diffuse1;          // Original colors
    D3DCOLOR specular1;
    D3DCOLOR diffuse2;
    D3DCOLOR specular2;
    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = cv1->color;
        D3DCOLOR specular = cv1->specular;

        //Save original colors
        diffuse1  = cv2->color;
        specular1 = cv2->specular;
        diffuse2  = cv3->color;
        specular2 = cv3->specular;

        cv2->color= diffuse;
        cv2->specular = specular;
        cv3->color = diffuse;
        cv3->specular = specular;
    }

    if (count = lpDevI->pGeometryFuncs->ClipSingleTriangle(pv, &newtri, &ver))
    {
        int i;
        HRESULT ret;
        BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
        BYTE *p = pTLV;

        for (i = 0; i < count; i++) 
        {
            MAKE_TL_VERTEX_FVF(pv, p, ver[i]);
            p += pv->dwOutputSize;
        }
        ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pTLV, count, count-2);
        if (ret)
            return ret;
    }
    // CLIPPED_ENABLE bit could be set in the ClipSingleTriangle.
    // If this bit is not cleared, clipping will be wrong. Because, clip 
    // vertices are re-used by next triangles.
    // This bit should be cleared *after* drawing command. Otherwise, edge flags 
    // will be incorrect
    cv1->clip &= ~CLIPPED_ENABLE;
    cv2->clip &= ~CLIPPED_ENABLE;
    cv3->clip &= ~CLIPPED_ENABLE;

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // Restore original colors
        cv2->color    = diffuse1;
        cv2->specular = specular1;
        cv3->color    = diffuse2;
        cv3->specular = specular2;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//----------------------------------------------------------------------
HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *v1, ClipVertex *v2)
{
    ClipTriangle newline;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    ClipVertex cv1 = *v1;
    ClipVertex cv2 = *v2;
    newline.v[0] = &cv1;
    newline.v[1] = &cv2;

    int count;
    ClipVertex** ver;
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        cv2.color    = cv1.color;
        cv2.specular = cv1.specular;
    }

    if (ClipSingleLine(pv, &newline, &pv->rExtents))
    {
        BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
        BYTE *p = pTLV;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[0]);
        p += pv->dwOutputSize;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[1]);
        HRESULT ret = DRAW_CLIPPED_PRIM(pv, D3DPT_LINELIST, pTLV, 2, 1);
        if (ret)
            return ret;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//------------------------------------------------------------------------------
HRESULT ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    BYTE   *p1;
    DWORD   f1;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    BYTE       *startVertex;                                
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                         
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = (BYTE*)pv->lpvOut;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    f1 = clipCode[0];
    p1 = vertex;
    clipCode++;
    vertex += vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], p1, f1, vertexTransformed);
    for (i = pv->dwNumVertices-2; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        f2 = clipCode[0];
        f3 = clipCode[1];

        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                BYTE tmp[__MAX_VERTEX_SIZE];
                BYTE *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart -= vertexSize;
                    memcpy (tmp, pStart, vertexSize);
                    memcpy (pStart, p1, vertexSize);
                    // Mark this call as gen by clipper, but set non clipped bit
                    pv->dwFlags |= D3DPV_NONCLIPPED; 
                    ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                            vertexCount);
                    pv->dwFlags &= ~D3DPV_NONCLIPPED;
                }
                else
                {
                    ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
                }
                if (ret)
                    return ret;
                if (startVertex != p1)
                    memcpy (pStart, tmp, vertexSize);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = vertex + vertexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex;
                BYTE *p3 = vertex + vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } else 
            vertexCount++;
        clipCode++;
        vertex += vertexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        BYTE tmp[__MAX_VERTEX_SIZE];
        BYTE *pStart = startVertex;
        if (startVertex == p1)
        {
            ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        }
        else
        {
            pStart -= vertexSize;
            memcpy(tmp, pStart, vertexSize);
            memcpy(pStart, p1, vertexSize);
            // Mark this call as gen by clipper
            pv->dwFlags |= D3DPV_NONCLIPPED; 
            ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
        }
        if (ret)
            return ret;

        if (startVertex != p1)
            memcpy(pStart, tmp, vertexSize);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    WORD        *p1;
    DWORD        f1;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    LPWORD       startVertex;                               
    LPWORD index = pv->lpwIndices;                               \
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = pv->lpwIndices;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    f1 = clipCode[index[0]];
    p1 = index;
    index++;
    BYTE *ver = vertex + p1[0]*vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], ver, f1, vertexTransformed);
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        WORD  v1, v2;
        v1 = index[0];
        v2 = index[1];
        f2 = clipCode[v1];
        f3 = clipCode[v2];
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                WORD tmp;
                WORD *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart--;
                    tmp = *pStart;  // Save old value to restore later
                    *pStart = *p1;
                }
                ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                  vertexCount);
                if (ret)
                    return ret;
                if (startVertex != p1)
                    *pStart = tmp;   // Restore old value
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = &index[1];

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex + v1*vertexSize;
                BYTE *p3 = vertex + v2*vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            vertexCount++;
        index++;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        WORD tmp;
        WORD *pStart = startVertex;
        if (startVertex != p1)
        {
            pStart--;
            tmp = *pStart;  // Save old value to restore later
            *pStart = *p1;
        }
        ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        if (ret)
            return ret;
        if (startVertex != p1)
            *pStart = tmp;   // Restore old value
        if (ret)
            return ret;
    }
    return D3D_OK;
} 

#define __PROCESS_LINE_NAME ProcessClippedLine
#define __PROCESS_TRI_LIST_NAME ProcessClippedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedTriangleStrip
#include "clipprim.h"

#define __INDEX_PRIM
#define __PROCESS_TRI_LIST_NAME ProcessClippedIndexedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedIndexedTriangleStrip
#define __PROCESS_LINE_NAME ProcessClippedIndexedLine
#include "clipprim.h"

//---------------------------------------------------------------------
HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    DWORD dwVertexBaseOrg = pv->dwVertexBase;
    for (i=0; i < nVertices; i++) 
    {
        if (clipCode[i]) 
        {       // if this point is clipped
            pv->dwVertexBase = dwVertexBaseOrg + i - count;
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
        } 
        else 
        {
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        pv->dwVertexBase = dwVertexBaseOrg + nVertices - count;
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\gensym.cpp ===
/*
 * $Id: gensym.cpp,v 1.7 1995/11/21 14:45:51 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include <stdio.h>
#include "ddrawp.h"
#include "dpf.h"
#include "d3di.hpp"

#define DEFINE(type, member) \
    printf(#type "_" #member "  equ 0%xh\n", ((LONG)(&((type *)0)->member)))

#define MACRO(name) \
    printf(#name "  equ 0%xh\n", name)

main()
// pcomment prints a comment.

#define pcomment(s)  printf("; %s\n",s)

// pequate prints an equate statement.

#define pequate(name, value) printf("%s equ 0x%08lX\n",name,value);

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     printf("\n")

#define printVCACHE(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_VCACHE_"#name, OFFSET(D3DFE_PROCESSVERTICES, vcache.##name)); \
} 

#define printD3DI_LIGHT(name)   \
{                               \
    printf("%-30s equ 0%LXH\n", "D3DI_LIGHT_"#name, OFFSET(D3DI_LIGHT, name)); \
} 

#define printD3DFE_LIGHTING(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, lighting.##name)); \
} 

#define printDevice(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "DEVI_"#name, OFFSET(DIRECT3DDEVICEI, name)); \
} 

#define printPV(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "D3DPV_"#name, OFFSET(D3DFE_PROCESSVERTICES, name)); \
} 

#define printDeviceDP2(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", #name, OFFSET(CDirect3DDeviceIDP2, name)); \
} 

{
pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: offsets.asm");
    pcomment("");
    pcomment(" Defines D3D assembly-language structures.");
    pcomment(" This file is generated");
    pcomment("");
    pcomment(" Copyright (c) 1998, 1995 Microsoft Corporation");
pcomment("------------------------------------------------------------------");
    pblank();
    pblank();

    DEFINE(D3DINSTRUCTION, wCount);
    DEFINE(D3DINSTRUCTION, bSize);
    DEFINE(D3DINSTRUCTION, bOpcode);
    
    DEFINE(D3DVERTEX, x);
    DEFINE(D3DVERTEX, y);
    DEFINE(D3DVERTEX, z);
    DEFINE(D3DVERTEX, tu);
    DEFINE(D3DVERTEX, tv);

    DEFINE(D3DLVERTEX, color);
    DEFINE(D3DLVERTEX, specular);

    DEFINE(D3DTLVERTEX, sx);
    DEFINE(D3DTLVERTEX, sy);
    DEFINE(D3DTLVERTEX, sz);
    DEFINE(D3DTLVERTEX, rhw);
    DEFINE(D3DTLVERTEX, color);
    DEFINE(D3DTLVERTEX, specular);
    DEFINE(D3DTLVERTEX, tu);
    DEFINE(D3DTLVERTEX, tv);
    printf("D3DTLVERTEX_size    equ %d\n", sizeof(D3DTLVERTEX));

    DEFINE(D3DHVERTEX, dwFlags);
    DEFINE(D3DHVERTEX, hx);
    DEFINE(D3DHVERTEX, hy);
    DEFINE(D3DHVERTEX, hz);
    printf("D3DHVERTEX_size equ %d\n", sizeof(D3DHVERTEX));
    
    DEFINE(D3DTRIANGLE, v1);
    DEFINE(D3DTRIANGLE, v2);
    DEFINE(D3DTRIANGLE, v3);
    DEFINE(D3DTRIANGLE, wFlags);
    printf("D3DTRIANGLE_size equ %d\n", sizeof(D3DTRIANGLE));

    DEFINE(D3DMATRIXI, _11);
    DEFINE(D3DMATRIXI, _12);
    DEFINE(D3DMATRIXI, _13);
    DEFINE(D3DMATRIXI, _14);
    DEFINE(D3DMATRIXI, _21);
    DEFINE(D3DMATRIXI, _22);
    DEFINE(D3DMATRIXI, _23);
    DEFINE(D3DMATRIXI, _24);
    DEFINE(D3DMATRIXI, _31);
    DEFINE(D3DMATRIXI, _32);
    DEFINE(D3DMATRIXI, _33);
    DEFINE(D3DMATRIXI, _34);
    DEFINE(D3DMATRIXI, _41);
    DEFINE(D3DMATRIXI, _42);
    DEFINE(D3DMATRIXI, _43);
    DEFINE(D3DMATRIXI, _44);

    DEFINE(D3DLIGHTINGELEMENT, dvPosition);
    DEFINE(D3DLIGHTINGELEMENT, dvNormal);
    printf("D3DMATRIXI_size equ %d\n", sizeof(D3DMATRIXI));
    printf("D3DFE_LIGHTING_size equ %d\n", sizeof(D3DFE_LIGHTING));
    printf("D3DFE_VIEWPORTCACHE_size equ %d\n", sizeof(D3DFE_VIEWPORTCACHE));

    MACRO(D3DOP_TRIANGLE);

    MACRO(D3DCLIP_LEFT);
    MACRO(D3DCLIP_RIGHT);
    MACRO(D3DCLIP_TOP);
    MACRO(D3DCLIP_BOTTOM);
    MACRO(D3DCLIP_FRONT);
    MACRO(D3DCLIP_BACK);

    MACRO(D3DTBLEND_COPY);
    MACRO(D3DSHADE_FLAT);

    MACRO(D3DCMP_LESSEQUAL);
    MACRO(D3DCMP_GREATEREQUAL);
    MACRO(D3DCMP_ALWAYS);

    MACRO(D3DSTATUS_ZNOTVISIBLE);
    MACRO(D3DDEV_DONOTUPDATEEXTENTS);
    MACRO(D3DDEV_DONOTCLIP);

// Geometry pipeline
pcomment("-------------------- VCACHE ------------------------------------");
    printVCACHE(scaleX);
    printVCACHE(scaleY);
    printVCACHE(scaleZ);
    printVCACHE(offsetX);
    printVCACHE(offsetY);
    printVCACHE(offsetZ);
    printVCACHE(minXgb);
    printVCACHE(minYgb);
    printVCACHE(maxXgb);
    printVCACHE(maxYgb);
    printVCACHE(minX);
    printVCACHE(minY);
    printVCACHE(maxX);
    printVCACHE(maxY);
    printVCACHE(gb11);
    printVCACHE(gb22);
    printVCACHE(gb41);
    printVCACHE(gb42);
    printVCACHE(Kgbx1);
    printVCACHE(Kgby1);
    printVCACHE(Kgbx2);
    printVCACHE(Kgby2);
    printVCACHE(dvX);
    printVCACHE(dvY);
    printVCACHE(dvWidth);
    printVCACHE(dvHeight);
    printVCACHE(scaleXi);
    printVCACHE(scaleYi);
    printVCACHE(minXi);
    printVCACHE(minYi);
    printVCACHE(maxXi);
    printVCACHE(maxYi);
pcomment("---------------- D3DFE_LIGHTING ------------------------------------");
    printD3DFE_LIGHTING(diffuse);
    printD3DFE_LIGHTING(alpha);
    printD3DFE_LIGHTING(diffuse0);
    printD3DFE_LIGHTING(currentSpecTable);
    printD3DFE_LIGHTING(specular);
    printD3DFE_LIGHTING(outDiffuse);
    printD3DFE_LIGHTING(vertexAmbient);
    printD3DFE_LIGHTING(vertexDiffuse);
    printD3DFE_LIGHTING(outSpecular);
    printD3DFE_LIGHTING(vertexSpecular);
    printD3DFE_LIGHTING(dwLightingFlags);
    printD3DFE_LIGHTING(alphaSpecular);
    printD3DFE_LIGHTING(model_eye);
    printD3DFE_LIGHTING(activeLights);
    printD3DFE_LIGHTING(material);
    printD3DFE_LIGHTING(ambientSceneScaled);
    printD3DFE_LIGHTING(ambientScene);
    printD3DFE_LIGHTING(fog_mode);
    printD3DFE_LIGHTING(fog_density);
    printD3DFE_LIGHTING(fog_start);
    printD3DFE_LIGHTING(fog_end);
    printD3DFE_LIGHTING(fog_factor);
    printD3DFE_LIGHTING(specThreshold);
    printD3DFE_LIGHTING(ambient_save);
    printD3DFE_LIGHTING(materialAlpha);
    printD3DFE_LIGHTING(materialAlphaS);
    printD3DFE_LIGHTING(dwDiffuse0);
    printD3DFE_LIGHTING(directionToCamera);
    printD3DFE_LIGHTING(dwAmbientSrcIndex);
    printD3DFE_LIGHTING(dwDiffuseSrcIndex);
    printD3DFE_LIGHTING(dwSpecularSrcIndex);
    printD3DFE_LIGHTING(dwEmissiveSrcIndex);
pcomment("---------------- D3DI_LIGHT ------------------------------------");
    printD3DI_LIGHT(model_position);
    printD3DI_LIGHT(type);
    printD3DI_LIGHT(model_direction);
    printD3DI_LIGHT(flags);
    printD3DI_LIGHT(falloff);
    printD3DI_LIGHT(inv_theta_minus_phi);
    printD3DI_LIGHT(halfway);
    printD3DI_LIGHT(next);
    printD3DI_LIGHT(range_squared);
    printD3DI_LIGHT(attenuation0);
    printD3DI_LIGHT(attenuation1);
    printD3DI_LIGHT(attenuation2);
    printD3DI_LIGHT(cos_theta_by_2);
    printD3DI_LIGHT(cos_phi_by_2);
    printD3DI_LIGHT(position);
    printD3DI_LIGHT(direction);
    printD3DI_LIGHT(range);
  
pcomment("---------------- D3DFE_PROCESSVERTICES ------------------------------");
    printPV(mCTM);
    printPV(dwMaxTextureIndices);
    printPV(lighting);
    printPV(vcache);
    printPV(dvExtentsAdjust);
    printPV(lpdwRStates);
    printPV(ClipperState);
    printPV(dwVertexBase);
    printPV(dwFlags);
    printPV(dwDeviceFlags);
    printPV(dwNumVertices);
    printPV(dwNumPrimitives);
    printPV(dwNumIndices);
    printPV(lpwIndices);
    printPV(primType);
    printPV(nTexCoord);
    printPV(position);
    printPV(normal);
    printPV(diffuse);
    printPV(specular);
    printPV(textures);
    printPV(dwVIDIn);
    printPV(dwVIDOut);
    printPV(dwOutputSize);
    printPV(lpvOut);
    printPV(lpClipFlags);
    printPV(rExtents);
    printPV(dwClipUnion);
    printPV(dwClipIntersection);
    printPV(texOffset);          
    printPV(normalOffset);       
    printPV(diffuseOffset);      
    printPV(specularOffset);     
    printPV(texOffsetOut);       
    printPV(diffuseOffsetOut);   
    printPV(specularOffsetOut);  
    printPV(dwClipMaskOffScreen);
    printPV(dwFirstClippedVertex);
    printPV(dwDP2VertexCount);   
    printPV(dwVertexPoolSize);   
    printPV(userClipPlane);   
    printPV(dwFlags2);   

pcomment("---------------- DIRECT3DDEVICEI ------------------------------------");
    printDevice(mCTM);
    printDevice(dwMaxTextureIndices);
    printDevice(lighting);
    printDevice(vcache);
    printDevice(dvExtentsAdjust);
    printDevice(lpdwRStates);
    printDevice(pD3DMappedTexI);
    printDevice(ClipperState);
    printDevice(dwVertexBase);
    printDevice(dwFlags);
    printDevice(dwDeviceFlags);
    printDevice(dwNumVertices);
    printDevice(dwNumPrimitives);
    printDevice(dwNumIndices);
    printDevice(lpwIndices);
    printDevice(primType);
    printDevice(nTexCoord);
    printDevice(position);
    printDevice(normal);
    printDevice(diffuse);
    printDevice(specular);
    printDevice(textures);
    printDevice(dwVIDIn);
    printDevice(dwVIDOut);
    printDevice(dwOutputSize);
    printDevice(lpvOut);
    printDevice(lpClipFlags);
    printDevice(rExtents);
    printDevice(dwClipUnion);
    printDevice(dwClipIntersection);
    printDevice(deviceType                );
    printDevice(lpDirect3DI               );
    printDevice(list                      );
    printDevice(texBlocks                 );
    printDevice(guid                      );
    printDevice(guid                      );
    printDevice(lpD3DHALCallbacks         );
    printDevice(lpD3DHALGlobalDriverData  );
    printDevice(lpD3DHALCallbacks2        );
    printDevice(lpD3DHALCallbacks3        );
    printDevice(lpDD                      );
    printDevice(lpDDGbl                   );
    printDevice(lpDDSTarget               );
    printDevice(lpDDSZBuffer              );
    printDevice(lpDDPalTarget             );
    printDevice(lpDDSTarget_DDS7          );
    printDevice(lpDDSZBuffer_DDS7         );
    printDevice(transform                 );
    printDevice(dwhContext                );
    printDevice(red_mask                  );
    printDevice(red_scale                 );
    printDevice(red_shift                 );
    printDevice(green_mask);
    printDevice(green_scale);
    printDevice(green_shift);
    printDevice(blue_mask);
    printDevice(blue_scale);
    printDevice(blue_shift);
    printDevice(zmask_shift);
    printDevice(stencilmask_shift);
    printDevice(bDDSTargetIsPalettized);
    printDevice(iClipStatus);
    printDevice(dwFEFlags);
    printDevice(dwDebugFlags);
    printDevice(specular_tables);
    printDevice(specular_table);
    printDevice(lightVertexFuncTable);
    printDevice(pHalProv);
    printDevice(hDllProv);
    printDevice(d3dDevDesc);
    printDevice(lpD3DMappedTexI);
    printDevice(lpD3DMappedBlock);
    printDevice(lpClipper);
    printDevice(dwHintFlags);
    printDevice(lpwDPBuffer);
    printDevice(dwCurrentBatchVID);
    printDevice(HVbuf);
    printDevice(lpD3DExtendedCaps);
    printDevice(rstates);
    printDevice(tsstates);
    printDevice(pfnRastService);
    printDevice(pGeometryFuncs);
    printDevice(mWV);
pcomment("---------------- CDirect3DDeviceIDP2 ----------------------");
    printDeviceDP2(lpDDSCB1);
    printDeviceDP2(allocatedBuf);
    printDeviceDP2(dp2data);
    printDeviceDP2(lpDP2CurrCommand);
    printDeviceDP2(wDP2CurrCmdCnt);
    printDeviceDP2(bDP2CurrCmdOP);
    printDeviceDP2(TLVbuf_size);
    printDeviceDP2(TLVbuf_base);
    printDeviceDP2(dwDP2CommandLength);
    printDeviceDP2(dwDP2CommandBufSize);
    printDeviceDP2(lpvDP2Commands);
    printDeviceDP2(dwDP2Flags);
#ifdef VTABLE_HACK
    printDeviceDP2(dwLastFlags);
    printDeviceDP2(lpDP2LastVBI);
#endif
pcomment("---------------- MISC ------------------------------------");
    /*                                     
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    */
    pequate("_R_", 0);
    pequate("_G_", 4);
    pequate("_B_", 8);

    pequate("_X_", 0);
    pequate("_Y_", 4);
    pequate("_Z_", 8);
    pequate("_W_", 12);
    pequate("D3DLIGHTI_COMPUTE_SPECULAR ", D3DLIGHTI_COMPUTE_SPECULAR);

pcomment("---------------- dwHintFlags-----------------------------------");

    pequate("D3DDEVBOOL_HINTFLAGS_INSCENE        ", D3DDEVBOOL_HINTFLAGS_INSCENE      );
    pequate("D3DDEVBOOL_HINTFLAGS_MULTITHREADED  ", D3DDEVBOOL_HINTFLAGS_MULTITHREADED);

pcomment("---------------- dwFEFlags ------------------------------------");

    pequate("D3DFE_WORLDMATRIX_DIRTY         ", D3DFE_WORLDMATRIX_DIRTY       );
    pequate("D3DFE_WORLDMATRIX1_DIRTY        ", D3DFE_WORLDMATRIX1_DIRTY      );
    pequate("D3DFE_WORLDMATRIX2_DIRTY        ", D3DFE_WORLDMATRIX2_DIRTY      );
    pequate("D3DFE_WORLDMATRIX3_DIRTY        ", D3DFE_WORLDMATRIX3_DIRTY      );
    pequate("D3DFE_TLVERTEX                  ", D3DFE_TLVERTEX                );
    pequate("D3DFE_REALHAL                   ", D3DFE_REALHAL                 );
    pequate("D3DFE_PROJMATRIX_DIRTY          ", D3DFE_PROJMATRIX_DIRTY        );
    pequate("D3DFE_VIEWMATRIX_DIRTY          ", D3DFE_VIEWMATRIX_DIRTY        );
    pequate("D3DFE_RECORDSTATEMODE           ", D3DFE_RECORDSTATEMODE         );
    pequate("D3DFE_EXECUTESTATEMODE          ", D3DFE_EXECUTESTATEMODE        );
    pequate("D3DFE_NEED_TRANSFORM_LIGHTS     ", D3DFE_NEED_TRANSFORM_LIGHTS   );
    pequate("D3DFE_MATERIAL_DIRTY            ", D3DFE_MATERIAL_DIRTY          );
    pequate("D3DFE_CLIPPLANES_DIRTY          ", D3DFE_CLIPPLANES_DIRTY        );
    pequate("D3DFE_LIGHTS_DIRTY              ", D3DFE_LIGHTS_DIRTY            );
    pequate("D3DFE_VERTEXBLEND_DIRTY         ", D3DFE_VERTEXBLEND_DIRTY       );
    pequate("D3DFE_FRUSTUMPLANES_DIRTY       ", D3DFE_FRUSTUMPLANES_DIRTY     );
    pequate("D3DFE_WORLDVIEWMATRIX_DIRTY     ", D3DFE_WORLDVIEWMATRIX_DIRTY   );
    pequate("D3DFE_FVF_DIRTY                 ", D3DFE_FVF_DIRTY               );
    pequate("D3DFE_NEED_TEXTURE_UPDATE       ", D3DFE_NEED_TEXTURE_UPDATE     );
    pequate("D3DFE_MAP_TSS_TO_RS             ", D3DFE_MAP_TSS_TO_RS           );
    pequate("D3DFE_INVWORLDVIEWMATRIX_DIRTY  ", D3DFE_INVWORLDVIEWMATRIX_DIRTY);
    pequate("D3DFE_LOSTSURFACES              ", D3DFE_LOSTSURFACES            );
    pequate("D3DFE_DISABLE_TEXTURES          ", D3DFE_DISABLE_TEXTURES        );
    pequate("D3DFE_CLIPMATRIX_DIRTY          ", D3DFE_CLIPMATRIX_DIRTY        );
    pequate("D3DFE_TLHAL                     ", D3DFE_TLHAL                   );
    pequate("D3DFE_STATESETS                 ", D3DFE_STATESETS               );

pcomment("---------------- pv->dwFlags ------------------------------------");
    pequate("D3DPV_FOG                   ", D3DPV_FOG                 );
    pequate("D3DPV_DOCOLORVERTEX         ", D3DPV_DOCOLORVERTEX       );
    pequate("D3DPV_LIGHTING              ", D3DPV_LIGHTING            );
    pequate("D3DPV_SOA                   ", D3DPV_SOA                 );
    pequate("D3DPV_COLORVERTEX_E         ", D3DPV_COLORVERTEX_E       );
    pequate("D3DPV_COLORVERTEX_D         ", D3DPV_COLORVERTEX_D       );
    pequate("D3DPV_COLORVERTEX_S         ", D3DPV_COLORVERTEX_S       );
    pequate("D3DPV_COLORVERTEX_A         ", D3DPV_COLORVERTEX_A       );
    pequate("D3DPV_DONOTCOPYSPECULAR     ", D3DPV_DONOTCOPYSPECULAR   );
    pequate("D3DPV_RESERVED1             ", D3DPV_RESERVED1           );
    pequate("D3DPV_RESERVED2             ", D3DPV_RESERVED2           );
    pequate("D3DPV_RESERVED3             ", D3DPV_RESERVED3           );
    pequate("D3DPV_NONCLIPPED            ", D3DPV_NONCLIPPED          );
    pequate("D3DPV_FRUSTUMPLANES_DIRTY   ", D3DPV_FRUSTUMPLANES_DIRTY );
    pequate("D3DPV_VBCALL                ", D3DPV_VBCALL              );
    pequate("D3DPV_DONOTCOPYTEXTURE      ", D3DPV_DONOTCOPYTEXTURE    );
    pequate("D3DPV_TLVCLIP               ", D3DPV_TLVCLIP             );
    pequate("D3DPV_TRANSFORMONLY         ", D3DPV_TRANSFORMONLY       );
    pequate("D3DPV_DONOTCOPYDIFFUSE      ", D3DPV_DONOTCOPYDIFFUSE    );
    pequate("D3DPV_PERSIST               ", D3DPV_PERSIST             );
pcomment("---------------- pv->dwDeviceFlags ------------------------------");
    pequate("D3DDEV_GUARDBAND            ", D3DDEV_GUARDBAND          );
    pequate("D3DDEV_RANGEBASEDFOG        ", D3DDEV_RANGEBASEDFOG      );
    pequate("D3DDEV_FOG                  ", D3DDEV_FOG                );
    pequate("D3DDEV_FVF                  ", D3DDEV_FVF                );
    pequate("D3DDEV_DONOTSTRIPELEMENTS   ", D3DDEV_DONOTSTRIPELEMENTS );
    pequate("D3DDEV_TEXTRANSFORMDIRTY    ", D3DDEV_TEXTRANSFORMDIRTY  );
    pequate("D3DDEV_REMAPTEXTUREINDICES  ", D3DDEV_REMAPTEXTUREINDICES);
    pequate("D3DDEV_TRANSFORMDIRTY       ", D3DDEV_TRANSFORMDIRTY     );
    pequate("D3DDEV_LIGHTSDIRTY          ", D3DDEV_LIGHTSDIRTY        );
    pequate("D3DDEV_DONOTCLIP            ", D3DDEV_DONOTCLIP          );
    pequate("D3DDEV_DONOTUPDATEEXTENTS   ", D3DDEV_DONOTUPDATEEXTENTS );
    pequate("D3DDEV_NOFVFANDNOTEXTURE    ", D3DDEV_NOFVFANDNOTEXTURE  );
    pequate("D3DDEV_TLVBUFWRITEONLY      ", D3DDEV_TLVBUFWRITEONLY    );
    pequate("D3DDEV_MODELSPACELIGHTING   ", D3DDEV_MODELSPACELIGHTING );
    pequate("D3DDEV_LOCALVIEWER          ", D3DDEV_LOCALVIEWER        );
    pequate("D3DDEV_NORMALIZENORMALS     ", D3DDEV_NORMALIZENORMALS   );
    pequate("D3DDEV_TEXTURETRANSFORM     ", D3DDEV_TEXTURETRANSFORM   );
    pequate("D3DDEV_STRIDE               ", D3DDEV_STRIDE             );
    pequate("D3DDEV_COLORVERTEX          ", D3DDEV_COLORVERTEX        );
    pequate("D3DDEV_INTERPOLATE_COLOR    ", D3DDEV_INTERPOLATE_COLOR  );
    pequate("D3DDEV_INTERPOLATE_SPECULAR ", D3DDEV_INTERPOLATE_SPECULAR);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\light.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       light.h
 *  Content:    Direct3D lighting include file
 *
 ***************************************************************************/

#ifndef __LIGHT_H__
#define __LIGHT_H__

extern void D3DFE_UpdateLights(LPDIRECT3DDEVICEI);

struct BATCHBUFFER;

extern "C"
{
void Directional7(LPD3DFE_PROCESSVERTICES pv, 
                  D3DI_LIGHT *light, 
                  D3DVERTEX *pInpCoord, 
                  D3DVECTOR *pInpNormal,
                  D3DLIGHTINGELEMENT *pEyeSpaceData);
void Directional7Model(LPD3DFE_PROCESSVERTICES pv, 
                       D3DI_LIGHT *light, 
                       D3DVERTEX *pInpCoord, 
                       D3DVECTOR *pInpNormal,
                       D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7(LPD3DFE_PROCESSVERTICES pv, 
                D3DI_LIGHT *light, 
                D3DVERTEX *pInpCoord, 
                D3DVECTOR *pInpNormal,
                D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7Model(LPD3DFE_PROCESSVERTICES pv, 
                     D3DI_LIGHT *light, 
                     D3DVERTEX *pInpCoord, 
                     D3DVECTOR *pInpNormal,
                     D3DLIGHTINGELEMENT *pEyeSpaceData);
void DirectionalFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
}

#endif  /* __LIGHT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\helxfrm.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helxfrm.c
 *  Content:    Direct3D front-end transform and process vertices
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"

void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);

D3DFE_PVFUNCS GeometryFuncsGuaranteed; // Our implementation

//---------------------------------------------------------------------
void CheckWorldViewMatrix(LPD3DFE_PROCESSVERTICES pv)
{
    D3DMATRIXI *m = &pv->mWV;
    D3DMATRIXI res;
    res._11 = m->_11*m->_11 + m->_12*m->_12 + m->_13*m->_13;
    res._12 = m->_11*m->_21 + m->_12*m->_22 + m->_13*m->_23;
    res._13 = m->_11*m->_31 + m->_12*m->_32 + m->_13*m->_33;

    res._21 = m->_21*m->_11 + m->_22*m->_12 + m->_23*m->_13;
    res._22 = m->_21*m->_21 + m->_22*m->_22 + m->_23*m->_23;
    res._23 = m->_21*m->_31 + m->_22*m->_32 + m->_23*m->_33;

    res._31 = m->_31*m->_11 + m->_32*m->_12 + m->_33*m->_13;
    res._32 = m->_31*m->_21 + m->_32*m->_22 + m->_33*m->_23;
    res._33 = m->_31*m->_31 + m->_32*m->_32 + m->_33*m->_33;

    const D3DVALUE eps = 0.0001f;
    if (m->_14 == 0.0f && 
        m->_24 == 0.0f && 
        m->_34 == 0.0f && 
        m->_44 == 1.0f && 
        ABSF(res._12) < eps && 
        ABSF(res._13) < eps &&
        ABSF(res._21) < eps && 
        ABSF(res._23) < eps &&
        ABSF(res._31) < eps && 
        ABSF(res._32) < eps &&
        ABSF(1.0f - res._11) < eps && 
        ABSF(1.0f - res._22) < eps && 
        ABSF(1.0f - res._33) < eps)
    {
        pv->dwDeviceFlags |= D3DDEV_MODELSPACELIGHTING;
    }
    else
    {
        pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
    }
}
//---------------------------------------------------------------------
void setIdentity(D3DMATRIXI * m)
{
    m->_11 = D3DVAL(1.0); m->_12 = D3DVAL(0.0); m->_13 = D3DVAL(0.0); m->_14 = D3DVAL(0.0);
    m->_21 = D3DVAL(0.0); m->_22 = D3DVAL(1.0); m->_23 = D3DVAL(0.0); m->_24 = D3DVAL(0.0);
    m->_31 = D3DVAL(0.0); m->_32 = D3DVAL(0.0); m->_33 = D3DVAL(1.0); m->_34 = D3DVAL(0.0);
    m->_41 = D3DVAL(0.0); m->_42 = D3DVAL(0.0); m->_43 = D3DVAL(0.0); m->_44 = D3DVAL(1.0);
}
//---------------------------------------------------------------------
/*
 * Combine all matrices.
 */
const DWORD __VPC_DIRTY = D3DFE_VIEWMATRIX_DIRTY |
                          D3DFE_PROJMATRIX_DIRTY;

void updateTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_VIEWPORTCACHE& VPORT = lpDevI->vcache;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    if (lpDevI->dwFEFlags & D3DFE_PROJMATRIX_DIRTY)
    { 
      // We modify the projection matrix to make the clipping rules to be
      // 0 < x,y,z < w
        TRANSFORM.mPC._11 = (TRANSFORM.proj._11 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._12 = (TRANSFORM.proj._12 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._13 = TRANSFORM.proj._13;
        TRANSFORM.mPC._14 = TRANSFORM.proj._14;
        TRANSFORM.mPC._21 = (TRANSFORM.proj._21 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._22 = (TRANSFORM.proj._22 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._23 = TRANSFORM.proj._23;
        TRANSFORM.mPC._24 = TRANSFORM.proj._24;
        TRANSFORM.mPC._31 = (TRANSFORM.proj._31 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._32 = (TRANSFORM.proj._32 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._33 = TRANSFORM.proj._33;
        TRANSFORM.mPC._34 = TRANSFORM.proj._34;
        TRANSFORM.mPC._41 = (TRANSFORM.proj._41 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._42 = (TRANSFORM.proj._42 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._43 = TRANSFORM.proj._43;
        TRANSFORM.mPC._44 = TRANSFORM.proj._44;
    }
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_PROJMATRIX_DIRTY))
    { // Update Mview*Mproj*Mclip
        MatrixProduct(&TRANSFORM.mVPC, &TRANSFORM.view, &TRANSFORM.mPC);
        lpDevI->dwFEFlags |= D3DFE_CLIPMATRIX_DIRTY | D3DFE_CLIPPLANES_DIRTY;
    }

    MatrixProduct(&lpDevI->mCTM, &TRANSFORM.world[0], &TRANSFORM.mVPC);

    // Set dirty bit for world*view matrix (needed for fog and lighting)
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX1_DIRTY |
                             D3DFE_WORLDMATRIX2_DIRTY |
                             D3DFE_WORLDMATRIX3_DIRTY))
    {
        lpDevI->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY | 
                             D3DFE_INVWORLDVIEWMATRIX_DIRTY |
                             D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
    }

    if (lpDevI->dwFEFlags & (__VPC_DIRTY |
                             D3DFE_WORLDMATRIX1_DIRTY |
                             D3DFE_WORLDMATRIX2_DIRTY |
                             D3DFE_WORLDMATRIX3_DIRTY))
    {
        if (lpDevI->dwFEFlags & (__VPC_DIRTY | D3DFE_WORLDMATRIX1_DIRTY))
        {
            MatrixProduct(&lpDevI->mCTM2[0], &TRANSFORM.world[1], &TRANSFORM.mVPC);
        }
        if (lpDevI->dwFEFlags & (__VPC_DIRTY | D3DFE_WORLDMATRIX2_DIRTY))
        {
            MatrixProduct(&lpDevI->mCTM2[1], &TRANSFORM.world[2], &TRANSFORM.mVPC);
        }
        if (lpDevI->dwFEFlags & (__VPC_DIRTY | D3DFE_WORLDMATRIX3_DIRTY))
        {
            MatrixProduct(&lpDevI->mCTM2[2], &TRANSFORM.world[3], &TRANSFORM.mVPC);
        }
    }

    // All matrices are set up
    lpDevI->dwFEFlags &= ~D3DFE_TRANSFORM_DIRTY;

    // Set dirty bit for lighting
    lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS |
                         D3DFE_FRUSTUMPLANES_DIRTY;

    lpDevI->dwDeviceFlags |= D3DDEV_TRANSFORMDIRTY;
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//----------------------------------------------------------------------------
#ifdef DEBUG_PIPELINE

extern DWORD g_DebugFlags;

#endif
//
// DoUpdateState should be called for every DrawPrimitive call in the slow path,
// because it sets some internal pipeline flags. These flags are persistent for the
// fast path
//
void DoUpdateState(LPDIRECT3DDEVICEI lpDevI)
{
    // only set up lights if something has changed
    if (lpDevI->dwFEFlags & D3DFE_LIGHTS_DIRTY) 
    {
        LPDIRECT3DLIGHTI    lpD3DLightI;
        lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_FIRST(&lpDevI->m_ActiveLights);
        lpDevI->lighting.activeLights = NULL;

        // Set lights in the device
        while (lpD3DLightI)
        {
            if (lpD3DLightI->m_LightI.flags & D3DLIGHTI_DIRTY)
                lpD3DLightI->SetInternalData();
            lpD3DLightI->m_LightI.next = lpDevI->lighting.activeLights;
            lpDevI->lighting.activeLights = &lpD3DLightI->m_LightI;
            lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_NEXT(lpD3DLightI, m_List);
        }
    }
    if (lpDevI->dwDeviceFlags & D3DDEV_LIGHTING &&
        lpDevI->dwVIDOut & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR))
    {
        lpDevI->dwFlags |= D3DPV_LIGHTING;
    }
    if (lpDevI->dwDeviceFlags & D3DDEV_FOG && lpDevI->dwVIDOut & D3DFVF_SPECULAR)
    {
        lpDevI->dwFlags |= D3DPV_FOG;
    }

    if (lpDevI->dwFEFlags & D3DFE_VERTEXBLEND_DIRTY)
    {
        lpDevI->dwNumVerBlends = min(lpDevI->rstates[D3DRENDERSTATE_VERTEXBLEND],
                                   ((lpDevI->dwVIDIn & D3DFVF_POSITION_MASK) >> 1) - 2);
        lpDevI->dwFEFlags &= ~D3DFE_VERTEXBLEND_DIRTY;
        // Lighting is done in the camera space when there is vertex blending
        if (lpDevI->dwNumVerBlends)
        {
            if (lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                lpDevI->dwDeviceFlags &= ~(D3DDEV_MODELSPACELIGHTING | D3DFE_NEEDCHECKWORLDVIEWVMATRIX);
                // We have to transform lights to the camera space
                lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
            }
        }
        else
        {
            if (!(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                lpDevI->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
        }
    }

    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
    {
        updateTransform(lpDevI);
    }
    // We need World-View matrix for lighting, fog and when texture coordinates
    // are taken from the vertex data in the camera space
    if (lpDevI->dwFEFlags & D3DFE_WORLDVIEWMATRIX_DIRTY &&
        (lpDevI->dwFlags & (D3DPV_LIGHTING | D3DPV_FOG) ||
        lpDevI->dwDeviceFlags & (D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE)))
    {
        MatrixProduct(&lpDevI->mWV, &lpDevI->transform.world[0],
                                    &lpDevI->transform.view);
        for (DWORD i=0; i < lpDevI->dwNumVerBlends; i++)
        {
            MatrixProduct(&lpDevI->mWV2[i], &lpDevI->transform.world[i+1],
                          &lpDevI->transform.view);
        }
        lpDevI->dwFEFlags &= ~D3DFE_WORLDVIEWMATRIX_DIRTY;
    }
// Detect where to do lighting: in model or eye space 
    if (lpDevI->dwFEFlags & D3DFE_NEEDCHECKWORLDVIEWVMATRIX &&
        lpDevI->dwFlags & D3DPV_LIGHTING)
    {
        // We try to do lighting in the model space if
        // 1. we do not have to normalize normals 
        // 2. we do not need to do vertex blending
        lpDevI->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
        if (lpDevI->dwNumVerBlends == 0 &&
            !(lpDevI->dwDeviceFlags & D3DDEV_NORMALIZENORMALS))
        {
#ifdef DEBUG_PIPELINE
            if (!(g_DebugFlags & __DEBUG_MODELSPACE))
#endif
            {
                CheckWorldViewMatrix(lpDevI);
                lpDevI->dwFEFlags &= ~D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
            }
        }
        // If D3DDEV_MODELSPACELIGHTING has been changed we need to re-transform lights
        lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
    }
    
// Updating inverse World-View matrix
    if (lpDevI->dwFEFlags & D3DFE_INVWORLDVIEWMATRIX_DIRTY &&
        ((lpDevI->dwFlags & D3DPV_LIGHTING && !(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)) || 
         lpDevI->dwDeviceFlags & D3DDEV_NORMALINCAMERASPACE))
    {
        Inverse4x4((D3DMATRIX*)&lpDevI->mWV, (D3DMATRIX*)&lpDevI->mWVI);
        for (DWORD i=0; i < lpDevI->dwNumVerBlends; i++)
        {
            Inverse4x4((D3DMATRIX*)&lpDevI->mWV2[i], (D3DMATRIX*)&lpDevI->mWVI2[i]);
        }
        lpDevI->dwFEFlags &= ~D3DFE_INVWORLDVIEWMATRIX_DIRTY;
    }

    // Update clipping planes if there are any
    if (lpDevI->dwFEFlags & D3DFE_CLIPPLANES_DIRTY)
    {
        if (lpDevI->dwFEFlags & D3DFE_CLIPMATRIX_DIRTY)
        {
            // View and projection matrix are inversed separately, because it 
            // is possible that combined matrix cannot be inverted. This could happend
            // when the view matrix has huge _43 value (> 10^7). Floating point precision
            // is not enough in this case
            D3DMATRIXI mPCInverse;
            if (Inverse4x4((D3DMATRIX*)&lpDevI->transform.mPC, (D3DMATRIX*)&mPCInverse))
            {
                D3D_ERR("Cannot invert projection matrix");
                setIdentity((D3DMATRIXI*)&mPCInverse);
            }
            D3DMATRIXI mViewInverse;
            if (Inverse4x4((D3DMATRIX*)&lpDevI->transform.view, (D3DMATRIX*)&mViewInverse))
            {
                D3D_ERR("Cannot invert view matrix");
                setIdentity((D3DMATRIXI*)&mViewInverse);
            }
            MatrixProduct(&lpDevI->transform.mVPCI, &mPCInverse, &mViewInverse);
            lpDevI->dwFEFlags &= ~D3DFE_CLIPMATRIX_DIRTY;
        }
        DWORD dwMaxUserClipPlanes = 0;
        DWORD dwPlanes = lpDevI->rstates[D3DRENDERSTATE_CLIPPLANEENABLE];
        for (DWORD i=0; i < __MAXUSERCLIPPLANES; i++)
        {
            if (dwPlanes & (1 << i))
            {
                VecMatMul4HT(&lpDevI->transform.userClipPlane[i], 
                             (D3DMATRIX*)&lpDevI->transform.mVPCI, 
                             &lpDevI->userClipPlane[dwMaxUserClipPlanes]);
                dwMaxUserClipPlanes++;
            }
        }
        lpDevI->dwMaxUserClipPlanes = dwMaxUserClipPlanes;
        lpDevI->dwFEFlags &= ~D3DFE_CLIPPLANES_DIRTY;
    }

    if (lpDevI->dwFEFlags & (D3DFE_NEED_TRANSFORM_LIGHTS |
                             D3DFE_LIGHTS_DIRTY |
                             D3DFE_MATERIAL_DIRTY))
    {
        D3DFE_UpdateLights(lpDevI);
        // Set a flag for PSGP
        lpDevI->dwDeviceFlags |= D3DDEV_LIGHTSDIRTY;
    }

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden 
    // by vertex alpha
    lpDevI->lighting.alpha = (DWORD)lpDevI->lighting.materialAlpha;
    lpDevI->lighting.alphaSpecular = (DWORD)lpDevI->lighting.materialAlphaS;

    if (!(lpDevI->dwVIDOut & D3DFVF_DIFFUSE))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYDIFFUSE;
    if (!(lpDevI->dwVIDOut & D3DFVF_SPECULAR))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYSPECULAR;

    // This is a hint that only the inPosition pointer needs to be updated
    // for speed reasons.
    if (((lpDevI->dwVIDIn & ( D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_NORMAL)) == 0) && 
        (lpDevI->nTexCoord == 0))
        lpDevI->dwFlags |= D3DPV_TRANSFORMONLY;

    if (lpDevI->nOutTexCoord == 0)
        lpDevI->dwFlags |= D3DPV_DONOTCOPYTEXTURE;

     SetInterpolationFlags(lpDevI);

    lpDevI->dwFEFlags &= ~D3DFE_FRONTEND_DIRTY;
}
//---------------------------------------------------------------------
// Convert extents from floating point to integer.
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_ConvertExtent"

void D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to)
{
    to->x1 = FTOI(from->x1) - 1;
    to->y1 = FTOI(from->y1) - 1;
    to->x2 = FTOI(from->x2) + 1;
    to->y2 = FTOI(from->y2) + 1;
    if (to->x1 < lpDevI->vcache.minXi)
        to->x1 = lpDevI->vcache.minXi;
    if (to->y1 < lpDevI->vcache.minYi)
        to->y1 = lpDevI->vcache.minYi;
    if (to->x2 > lpDevI->vcache.maxXi)
        to->x2 = lpDevI->vcache.maxXi;
    if (to->y2 > lpDevI->vcache.maxYi)
        to->y2 = lpDevI->vcache.maxYi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


OFFSETS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm

GENSYMFLAGS = -DWIN32 -D_WIN32 -DD3D -Zp $(GENSYMFLAGS) -DIS_32
GENSYMBASE = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gensym
GENSYMEXE = $(GENSYMBASE).exe
GENSYMSOURCE = ..\gensym.cpp
GENSYMINCS = 

INCPATHS = \
	-I$(BASEDIR)\public\sdk\inc\
	-I$(BASEDIR)\public\sdk\inc\crt\
	-I$(BASEDIR)\public\oak\inc\
	-I$(INCLUDES:;= -I)

..\pvvid.mcp: ..\pvvid.mh
..\pvone.mcp: ..\pvvid.mh
..\loops.mcp: ..\pvvid.mh

$(GENTGT)\pvvid.cpp: ..\pvvid.mcp $(RAST_STD_M4)
$(GENTGT)\pvone.cpp: ..\pvone.mcp $(RAST_STD_M4)
$(GENTGT)\loops.cpp: ..\loops.mcp $(RAST_STD_M4)

!ifndef SD_BUILD
COFFFILE = $(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt
!else
COFFFILE = $(BASEDIR)\tools\coffbase.txt
!endif


$(OFFSETS): $(GENSYMSOURCE) $(GENSYMINCS)
    set PASS0ONLY=
   $(TARGET_CPP) -c $(INCPATHS) $(GENSYMFLAGS) -Fo$(GENSYMBASE).obj $(GENSYMSOURCE)
    -link -out:$(GENSYMEXE) @<<
-machine:$(TARGET_DIRECTORY)
-base:@$(COFFFILE),usermode
-subsystem:console
-entry:mainCRTStartup
-ignore:4089
-force:unresolved
-nodefaultlib
$(GENSYMBASE).obj
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\msvcrt.lib
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\kernel32.lib
$(PERFLIBS)
<<
    -$(GENSYMEXE) > $(OFFSETS)
    -erase $(GENSYMBASE).obj
    -erase $(GENSYMEXE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dtnl
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..;$(_OBJ_DIR)\$(TARGET_DIRECTORY);$(INCLUDES)

C_DEFINES = $(C_DEFINES)
USE_NATIVE_EH = 1

ASM_DEFINES = -DNT=1 -DMICROSOFT_NT -DSTACK_CALL  -DD3D -DOTHER_SEG=0 -DWANT_DLL

NTTARGETFILE0= \
             $O\pvvid.cpp \
             $O\pvone.cpp \
             $O\loops.cpp

SOURCES= \
    ..\clipper.cpp   \
    ..\dpclip.cpp   \
    ..\helxfrm.cpp   \
    ..\rgblt.cpp     \
    $O\pvvid.cpp     \
    $O\pvone.cpp     \
    $O\loops.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

	ifdef INTEL
func	macro	name
	public	name
name:
	endm
	else
func	macro	name
	public	_&name
name:			;lay down both labels so I have one I know will
_&name:			;always be available for asm to call.
	endm
	endif

push_all	macro
	irp	z,<edi,esi,edx,ecx,ebx,eax>
	push	z
	endm
	endm

pop_all		macro
	irp	z,<eax,ebx,ecx,edx,esi,edi>
	pop	z
	endm
	endm

push_m	macro	list
	irp	z,<list>
	push	z
	endm
	endm
	
pop_m	macro	list
	irp	z,<list>
	pop	z
	endm
	endm

byte_eax	equ	al
byte_ebx	equ	bl
byte_ecx	equ	cl
byte_edx	equ	dl

word_eax	equ	ax
word_ebx	equ	bx
word_ecx	equ	cx
word_edx	equ	dx
word_edi	equ	di
word_esi	equ	si
word_ebp	equ	bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 017H
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 018h
	shl	eax, 008h
	idiv	divisor
nodivide:
	endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 0fH
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 010h
	shl	eax, 010h
	idiv	divisor
nodivide:
	endm

ES_PREFIX	macro
    ifndef	NT
	db	26h
    endif
	endm

beginargs macro
	align	4
stack	=	4	;return address
vars	=	0	;no vars yet
args	=	0	;no args yet
	endm

endargs	macro
	sub	esp, vars
	endm

savereg	macro	arg
	push	arg
stack	=	stack + 4
	endm

saveregs macro	arglist
	irp	z,<arglist>
	savereg	z
	endm
	endm

defvar  macro	name
name	=	vars
vars	=	vars + 4
stack	=	stack + 4
	endm

defvars	macro	arglist
	irp	z,<arglist>
	defvar	z
	endm
	endm

defarg	macro	name
name	=	stack + args
args	=	args + 4
	endm

defargs	macro	arglist
	irp	z,<arglist>
	defarg	z
	endm
	endm

regarg	macro	name
	ifdef	STACK_CALL
	defarg	name
	else
	defvar	name
	endif
	endm

regargs	macro	arglist
	irp	z,<arglist>
	regarg	z
	endm
	endm

return	macro
	ifdef	STACK_CALL
	ret
	else
	ret	args
	endif
	endm

    ifdef	BCC		;{

beginproc macro	prefix,GF,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	if DEPTH eq 0
prefix&name	equ	_&prefix&GF&Tr&Te&name
	else
	  if DEPTH eq 8
prefix&name	equ	_&prefix&8&GF&Tr&Te&name
	  else
prefix&name	equ	_&prefix&16&GF&Tr&Te&name
	  endif
	endif
	public	prefix&name
prefix&name proc
	endm			;}

    else			;} ifndef BCC {

beginproc macro	prefix,GF,Z,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	ifdef	STACK_CALL	;{
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Z&Tr&Te&name
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8_&GF&Z&Tr&Te&name
	    else
prefix&name	equ	prefix&16_&GF&Z&Tr&Te&name
	    endif
	endif
	else			;} else {
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Tr&Te&name&_
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8&GF&Tr&Te&name&_
	    else
prefix&name	equ	prefix&16&GF&Tr&Te&name&_
	    endif
	endif
	endif			;}
	public	prefix&name
prefix&name proc
	endm			;}
    endif		;}

    ifdef	BCC	;{
endproc	macro prefix,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	if	DEPTH eq 8
_&prefix&name endp
	else
_&prefix&name endp
	endif
	endm			;}

    else		;} ifndef BCC {

endproc	macro prefix,GF,Z,Te,Tr,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	ifdef	STACK_CALL
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name endp
	    else
	    if	DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
	    else
prefix&16_&GF&Z&Tr&Te&name endp
	    endif
	    endif
	else
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
	    else
	    if	DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
	    else
prefix&16&GF&Tr&Te&name&_ endp
	    endif
	    endif
	endif
	endm			;}

    endif		;}

; ************************************************************************
itoval	macro	reg
	shl	reg,10h
	endm

FDUP	macro
	fld	st(0)
	endm

FDROP	macro
	fstp	st(0)
	endm

FRECIPROCAL	macro
	fld1
	fdivrp	st(1),st
	endm

; MASM 6.11d used in NT has native support for fcomi so this macro can't be
; called fcomi

MACRO_FCOMI macro v
	fcom	v
	fnstsw	ax
	sahf
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\pvvid.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pvvid.h
 *  Content:    Common defines for the geometry inner loop
 *
 ***************************************************************************/
#ifndef _PVVID_H
#define _PVVID_H

#include "clipper.h"
// This function should be called every time FVF ID is changed
// All pv flags, input and output FVF id should be set before calling the
// function.
extern void UpdateGeometryLoopData(LPD3DFE_PROCESSVERTICES pv);
// We use power of 2 because it preserves the mantissa when we multiply
const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//--------------------------------------------------------------------------
#define D3DFE_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
//--------------------------------------------------------------------------
inline void ComputeFogFactor(LPD3DFE_PROCESSVERTICES pv, D3DVALUE dist, DWORD *pOutput)
{
    if (pv->lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < pv->lighting.fog_start)
            D3DFE_SET_ALPHA((*pOutput), 255)
        else
        if (dist >= pv->lighting.fog_end)
            D3DFE_SET_ALPHA((*pOutput), 0)
        else
        {
            D3DVALUE v = (pv->lighting.fog_end - dist) * pv->lighting.fog_factor;
            int f = FTOI(v);
            D3DFE_SET_ALPHA((*pOutput), f)
        }
    }
    else
    {
        D3DVALUE tmp = dist*pv->lighting.fog_density;
        if (pv->lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        tmp = (D3DVALUE)exp(-tmp) * 255.0f;
        int f = FTOI(tmp);
        D3DFE_SET_ALPHA((*pOutput), f)
    }
}
//--------------------------------------------------------------------------
// Input:
//      v    - input vertex in the model space
//      le   - vertex, transformed to the camera space
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//
void ComputeFog(LPD3DFE_PROCESSVERTICES pv, D3DVECTOR &v, D3DLIGHTINGELEMENT *le);
//---------------------------------------------------------------------
typedef void (*PFN_TEXTURETRANSFORM)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m);
typedef void (*PFN_TEXTURETRANSFORMLOOP)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m, 
                                        DWORD dwCount, DWORD dwInpStride, DWORD dwOutStride);

extern PFN_TEXTURETRANSFORM g_pfnTextureTransform[16];
extern PFN_TEXTURETRANSFORMLOOP g_pfnTextureTransformLoop[16];
//---------------------------------------------------------------------
inline void ComputeReflectionVector(D3DVECTOR *vertexPosition, D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVECTOR vertex = *vertexPosition;
    VecNormalizeFast(vertex);
    D3DVALUE dot = 2*(vertex.x * normal->x + vertex.y * normal->y + vertex.z * normal->z); 
    reflectionVector->x = vertex.x - dot*normal->x;
    reflectionVector->y = vertex.y - dot*normal->y;
    reflectionVector->z = vertex.z - dot*normal->z;
}
//---------------------------------------------------------------------
inline void ComputeReflectionVectorInfiniteViewer(D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVALUE dot = 2*normal->z; 
    reflectionVector->x = - dot*normal->x;
    reflectionVector->y = - dot*normal->y;
    reflectionVector->z = 1.0f - dot*normal->z;
}
#endif // _PVVID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWINNT -DNT
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX7)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\_ftransg.asm ===
GEN_XFRM = 1
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\_ftransa.asm ===
GEN_XFRM = 0
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\ftrans.asm ===
; $Id: ftrans.asm,v 1.3 1995/10/20 15:14:41 james Exp $
;
; Up to 165K from 143K
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994, 1995
; Version 1.0
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
; NOTE: Need to set integer pop precision...
;
OPTION NOM510
.386p
;.radix  16
                NAME    transform

                include macros.asm
                include offsets.asm

procstart	macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		proc
	    else
&prefix&xfrm_class		proc
	    endif
	    else
&prefix&xfrm_class&_		proc
	    endif
		endm

procend		macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		endp
	    else
&prefix&xfrm_class		endp
	    endif
	    else
&prefix&xfrm_class&_		endp
	    endif
		endm
		
if GEN_XFRM eq 1
xfrmName	equ	General
else
xfrmName	equ	Affine
endif


;ifndef WINNT
;DGROUP          GROUP   _DATA
;endif

_DATA           SEGMENT PARA PUBLIC USE32 'DATA'

; These two are in the same cache line
tx              dq	0
ty		dq	0

_DATA           ENDS

_TEXT           SEGMENT DWORD PUBLIC USE32 'CODE'
;ifdef WINNT
                ASSUME  CS:_TEXT ,DS:_DATA,SS:_DATA
;else
;               ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
;endif

FDROP   macro
        fstp    st(0)
        endm

fmat	macro	op,row,col
	op	dword ptr [ebp + 4 * ((4 * row) + col)]
	endm

column	macro	i,depth
	fld	dword ptr [esi + D3DVERTEX_x]	; [1]	x

	fmat	fmul,0,i			; [2]	x

	fld	dword ptr [esi + D3DVERTEX_y]	; [3]	y	x

	fmat	fmul,1,i			; [4]	y	x

	fld	dword ptr [esi + D3DVERTEX_z]	; [5]	z	y	x

	fmat	fmul,2,i			; [6]	z	y	x
	fxch	st(2)				; 	x	y	z

	fmat	fadd,3,i			; [7]	x	y	z
	endm
		
	procstart	RLDDITransformUnclippedLoop,%xfrmName

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, m, in_size, out_size, z_scale, z_offset>
	defargs	<minx, maxx, miny, maxy>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        endif

	mov     ebx,[esp + count]
	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov     edi,[esp + vout]

	mov	ebp,[esp + m]

	;	eax	ebx	ecx	edx
	;	minx	maxx	miny	maxy

	; Need to do first loop iteration
	column	0,0
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z' x y z
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; tx
	
	column	1,1		;	x'	y'	z'	x
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			;	x'+y'	z'	tx
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx
	
if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count + 8],1
	je	dontscan
	mov	eax,[esi + 32]
	mov	ebx,[edi + 32]
dontscan:
	pop	ebx
	pop	eax

	fxch	st(3)		; tx tz ty 1/tz

	fmul	st,st(3)	; tx/w tz ty 1/tz
	fxch	st(2)		; ty tz tx/w 1/tz

	fmul	st,st(3)	; ty/w tz tx/w 1/tz
	fxch	st(2)		; tx/w tz ty/w 1/tz

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tz
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tz
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tz
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif
	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz

	fmul	st,st(1)
	fxch	st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]

	fstp	dword ptr [edi + D3DTLVERTEX_sz]

	add	edi,32
	add	esi,32

	dec	dword ptr [esp + count]
	jnz	transloop

	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformUnclippedLoop,%xfrmName


cpick	macro	dst,c0,c1			; NO CARRY	CARRY
	sbb	dst,dst				; 0		~0
	and	dst,c0 xor c1			; 0		c0^c1
	xor	dst,c0				; c0		c1
	endm

;************************************************************************

		
	procstart	RLDDITransformClippedLoop,%xfrmName
		

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, hout, m, in_size, out_size, z_scale, z_offset>
	defargs	<x_bound, y_bound, r_scale_x, r_scale_y>
	defargs	<minx, maxx, miny, maxy>
	defargs	<clip_intersection, clip_union>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        else
		mov     ebx,[esp + count]
		mov     ecx,[esp + vout]
        endif

	fldpi

	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov	ebp,[esp + m]
	mov	edi,[esp + vout]

	; Need to do first loop iteration

	column	0,0		; 2 cycle wait here
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z'
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; x'+y'+z'
	
	column	1,1		; 2 cycle wait here
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			; x'+y' z'
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	; Now set up the clip flags in ebp
	xor	ebp,ebp
	fld	dword ptr [esp + 8 + x_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(3+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	x1		; Skip this if (tmp > tx)
	or	ebp,D3DCLIP_RIGHT
x1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(3+GEN_XFRM)	; (tw) tz ty tx
	fnstsw	ax
	sahf
	jbe	xpasses		; Skip this if (-tmp <= tx)
	or	ebp,D3DCLIP_LEFT
xpasses:
	fld	dword ptr [esp + 8 + y_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	y1		; Skip this if (tmp > ty)
	or	ebp,D3DCLIP_TOP
y1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	jbe	ypasses		; Skip this if (-tmp <= ty)
	or	ebp,D3DCLIP_BOTTOM
ypasses:
	fst	[ty]		; ty will hold tw for a while...
	
	; if GEN_XFRM eq 0 then tw == tz
	; if GEN_XFRM eq 1 then tw != tz in general, so we
	; calculate a true 1/tw and then drop the extra tw
	; off the FP stack

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx

if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count],1
	je	dontscan
	mov	eax,[esp + in_size + 8]
	mov	ebx,[esp + out_size + 8]
	mov	eax,[esi + eax]
	mov	ebx,[edi + ebx]
dontscan:
	pop	ebx
	pop	eax

	mov	[esp + vout],edi		
	mov	edi,[esp + hout]
				; 1/tw tz ty tx
	fxch	st(3)		; tx tz ty 1/tw

	fld	dword ptr [esp + r_scale_x]
	fmul	st,st(1)	; hx tx tz ty 1/tw
	fld	dword ptr [esp + r_scale_y]
	fmul	st,st(4)	; hy hx tx tz ty 1/tw
	fxch	st(1)		; hx hy tx tz ty 1/tw

	fstp	dword ptr [edi + D3DHVERTEX_hx]
	fstp	dword ptr [edi + D3DHVERTEX_hy]

	fmul	st,st(3)	; tx/w tz ty 1/tw
	fxch	st(2)		; ty tz tx/w 1/tw

	fmul	st,st(3)	; ty/w tz tx/w 1/tw
	fxch	st(2)		; tx/w tz ty/w 1/tw

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tw
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tw
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tw
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif

	; Last clipping flags
	fst	dword ptr [edi + D3DHVERTEX_hz]
	test	byte ptr [edi + D3DHVERTEX_hz + 3],80h
	jz	nofront
	or	ebp,D3DCLIP_FRONT
nofront:
	fcom	[ty]
	push	eax		;[
	fnstsw	ax
	sahf
	pop	eax		;]
	jb	noback
	or	ebp,D3DCLIP_BACK
noback:
	mov	[edi + D3DHVERTEX_dwFlags],ebp
	mov	edi,[esp + clip_intersection]
	and	[edi],ebp
	mov	edi,[esp + clip_union]
	or	[edi],ebp

	test	ebp,ebp
	jnz	outofplay

	mov	edi,[esp + vout]

	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz y

	fmul	st,st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_sz]
				; 1/tz y

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]
				; y

	add	esi,[esp + in_size]

	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp
	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jnz	transloop
	jmp	cleanup

outofplay:				; tz sx sy 1/tz
	FDROP				; sx sy 1/tz
	FDROP				; sy 1/tz y
	FDROP				; 1/tz y
	mov	edi,[esp + vout]
	fstp	dword ptr [edi + D3DTLVERTEX_rhw]	

	add	esi,[esp + in_size]
	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp

	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jz	calcminmax

	column	0,0		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	jmp	smaxy


cleanup:
	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

calcminmax:
	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

	FDROP

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformClippedLoop,%xfrmName

		
if GEN_XFRM
_Rdtsc	proc
	db	0fh,31h
	shrd	eax,edx,10
	ret
	
_Rdtsc	endp
endif

_TEXT           ENDS

        extrn	_g_fOne:dword
        extrn	_g_fOoTwoPow16:dword
	extrn	_g_dSnap:qword

                END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\rgblt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   rgblt.cpp
 *  Content:    Direct3D lighting
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"
#include "drawprim.hpp"

// Functions to use when lighting is done in the camera space
LIGHT_VERTEX_FUNC_TABLE lightVertexTable =
{
    Directional7,
    PointSpot7,
    DirectionalFirst,
    DirectionalNext,
    PointSpotFirst,
    PointSpotNext
};

// Functions to use when lighting is done in the model space
static LIGHT_VERTEX_FUNC_TABLE lightVertexTableModel =
{
    Directional7Model,
    PointSpot7Model,
    DirectionalFirstModel,
    DirectionalNextModel,
    PointSpotFirstModel,
    PointSpotNextModel
};
//-------------------------------------------------------------------------
SpecularTable* CreateSpecularTable(D3DVALUE power)
{
    SpecularTable* spec;
    int     i;
    float  delta = 1.0f/255.0f;
    float  v;

    D3DMalloc((void**)&spec, sizeof(SpecularTable));

    if (spec == NULL)
        return NULL;

    spec->power = power;

    v = 0.0;
    for (i = 0; i < 256; i++)
    {
        spec->table[i] = powf(v, power);
        v += delta;
    }

    for (; i < 260; i++)
        spec->table[i] = 1.0f;

    return spec;
}
//-------------------------------------------------------------------------
static void inverseRotateVector(D3DVECTOR* d,
                                D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

static void inverseTransformVector(D3DVECTOR* result,
                                   D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    result->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    result->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    result->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}
//-----------------------------------------------------------------------
// Every time the world matrix is modified or lights data is changed the
// lighting vectors have to change to match the model space of the new data
// to be rendered.
// Every time light data is changed or material data is changed or lighting
// state is changed, some pre-computed lighting values sould be updated
//
void D3DFE_UpdateLights(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    D3DI_LIGHT  *light = LIGHTING.activeLights;
    D3DVECTOR   t;
    BOOL        specular;       // TRUE, if specular component sould be computed
    D3DMATERIAL7 *mat = &LIGHTING.material;

    if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
    {

        if (lpDevI->lighting.material.power > D3DVAL(0.001))
        {
            if (lpDevI->lighting.material.power > D3DVAL(0.001))
            {
                SpecularTable* spec;

                for (spec = LIST_FIRST(&lpDevI->specular_tables);
                     spec;
                     spec = LIST_NEXT(spec,list))
                {
                    if (spec->power == lpDevI->lighting.material.power)
                        break;
                }
                if (spec == NULL)
                {
                    spec = CreateSpecularTable(lpDevI->lighting.material.power);
                    if (spec == NULL)
                    {
                        D3D_ERR("Failed tp create specular table");
                        throw DDERR_OUTOFMEMORY;
                    }
                    LIST_INSERT_ROOT(&lpDevI->specular_tables, spec, list);
                }
                lpDevI->specular_table = spec;
                lpDevI->lighting.specThreshold = D3DVAL(pow(0.001, 1.0/lpDevI->lighting.material.power));
            }
            else
                lpDevI->specular_table = NULL;
        }
        if (lpDevI->specular_table && lpDevI->dwDeviceFlags & D3DDEV_SPECULARENABLE)
            specular = TRUE;
        else
            specular = FALSE;

        LIGHTING.materialAlpha = FTOI(D3DVAL(255) * mat->diffuse.a);
        if (LIGHTING.materialAlpha < 0)
            LIGHTING.materialAlpha = 0;
        else
            if (LIGHTING.materialAlpha > 255)
                LIGHTING.materialAlpha = 255 << 24;
            else LIGHTING.materialAlpha <<= 24;

        LIGHTING.materialAlphaS = FTOI(D3DVAL(255) * mat->specular.a);
        if (LIGHTING.materialAlphaS < 0)
            LIGHTING.materialAlphaS = 0;
        else
            if (LIGHTING.materialAlphaS > 255)
                LIGHTING.materialAlphaS = 255 << 24;
            else LIGHTING.materialAlphaS <<= 24;

        LIGHTING.currentSpecTable = lpDevI->specular_table->table;

        LIGHTING.diffuse0.r = LIGHTING.ambientSceneScaled.r * mat->ambient.r;
        LIGHTING.diffuse0.g = LIGHTING.ambientSceneScaled.g * mat->ambient.g;
        LIGHTING.diffuse0.b = LIGHTING.ambientSceneScaled.b * mat->ambient.b;
        LIGHTING.diffuse0.r += mat->emissive.r * D3DVAL(255);
        LIGHTING.diffuse0.g += mat->emissive.g * D3DVAL(255);
        LIGHTING.diffuse0.b += mat->emissive.b * D3DVAL(255);
        int r,g,b;
        r = (int)FTOI(LIGHTING.diffuse0.r);
        g = (int)FTOI(LIGHTING.diffuse0.g);
        b = (int)FTOI(LIGHTING.diffuse0.b);
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;
        LIGHTING.dwDiffuse0 = (r << 16) + (g << 8) + b;
    }

    lpDevI->lighting.model_eye.x = (D3DVALUE)0;
    lpDevI->lighting.model_eye.y = (D3DVALUE)0;
    lpDevI->lighting.model_eye.z = (D3DVALUE)0;
    lpDevI->lighting.directionToCamera.x =  0;
    lpDevI->lighting.directionToCamera.y =  0;
    lpDevI->lighting.directionToCamera.z = -1;
    if (lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
    {
        inverseTransformVector(&lpDevI->lighting.model_eye, 
                               &lpDevI->lighting.model_eye,
                               &lpDevI->mWV);
        lpDevI->lightVertexFuncTable = &lightVertexTableModel;
        inverseRotateVector(&lpDevI->lighting.directionToCamera, 
                            &lpDevI->lighting.directionToCamera,
                            &lpDevI->mWV);
    }
    else
    {
        lpDevI->lightVertexFuncTable = &lightVertexTable;
    }
    while (light)
    {
        // Whenever light type is changed the D3DFE_NEED_TRANSFORM_LIGHTS should be set
        if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
        {
            if (light->type != D3DLIGHT_DIRECTIONAL)
            { // Point and Spot lights
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnPointSpot;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnPointSpotFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnPointSpotNext;
                if (!(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light position to the camera space
                    VecMatMul(&light->position, 
                              (D3DMATRIX*)&lpDevI->transform.view,
                              &light->model_position);
                }
                else
                {
                    inverseTransformVector(&light->model_position, &light->position,
                                           &lpDevI->transform.world[0]);
                }
            }
            else
            { // Directional light
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnDirectional;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnDirectionalFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnDirectionalNext;
            }

            if (light->type != D3DLIGHT_POINT)
            {
                // Light direction is flipped to be the direction TO the light
                if (!(lpDevI->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light direction to the camera space
                    VecMatMul3(&light->direction, 
                               (D3DMATRIX*)&lpDevI->transform.view,
                               &light->model_direction);
                    VecNormalizeFast(light->model_direction);
                }
                else
                {
                    inverseRotateVector(&light->model_direction, &light->direction,
                                           &lpDevI->transform.world[0]);
                }
                VecNeg(light->model_direction, light->model_direction);
                // For the infinite viewer the half vector is constant
                if (!(lpDevI->dwDeviceFlags & D3DDEV_LOCALVIEWER))
                {
                    VecAdd(light->model_direction, lpDevI->lighting.directionToCamera,
                           light->halfway);
                    VecNormalizeFast(light->halfway);
                }
            }
        }

        if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
        {
            light->diffuseMat.r = D3DVAL(255) * mat->diffuse.r * light->diffuse.r;
            light->diffuseMat.g = D3DVAL(255) * mat->diffuse.g * light->diffuse.g;
            light->diffuseMat.b = D3DVAL(255) * mat->diffuse.b * light->diffuse.b;


            if (!(light->flags & D3DLIGHTI_AMBIENT_IS_ZERO))
            {
                light->ambientMat.r = D3DVAL(255) * mat->ambient.r * light->ambient.r;
                light->ambientMat.g = D3DVAL(255) * mat->ambient.g * light->ambient.g;
                light->ambientMat.b = D3DVAL(255) * mat->ambient.b * light->ambient.b;
            }

            if (specular && !(light->flags & D3DLIGHTI_SPECULAR_IS_ZERO))
            {
                light->flags |= D3DLIGHTI_COMPUTE_SPECULAR;
                light->specularMat.r = D3DVAL(255) * mat->specular.r * light->specular.r;
                light->specularMat.g = D3DVAL(255) * mat->specular.g * light->specular.g;
                light->specularMat.b = D3DVAL(255) * mat->specular.b * light->specular.b;
            }
            else
                light->flags &= ~D3DLIGHTI_COMPUTE_SPECULAR;
        }
        light = light->next;
    }

    lpDevI->dwFEFlags &= ~(D3DFE_MATERIAL_DIRTY |
                    D3DFE_NEED_TRANSFORM_LIGHTS |
                    D3DFE_LIGHTS_DIRTY);
}   // end of updateLights()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWIN95 
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX7)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\light.asm ===
.486p

.model flat

include offsets.asm

.data

one DWORD   3f800000h

a1      dd 0.47                 ; Constants to compute inverse square root
a2      dd 1.47
v255    dd 65280.0              ; 255*256
v1_256  dd 0.00390625           ; 1/255
.code

PUBLIC  _Directional2P5S        ; Pentium optimized, specular, unit scale
PUBLIC  _Directional2P5         ; Pentium optimized, no specular, unit scale
;-------------------------------------------------------------------------
; Jim Blinn's method is used to compute inverse square root s = 1/sqrt(x):
;   ONE_AS_INTEGER = 0x3F800000
;   float y;
;   int tmp = ((ONE_AS_INTEGER << 1 + ONE_AS_INTEGER)  - *(long*)&x) >> 1;   
;   y = *(float*)&tmp;  
;   s = y*(1.47f - 0.47f*x*y*y);
; Input:
;   st(0)   = vector length
;   y, len  = should be defined as DWORD PTR
;   a1, a2  = 0.27 and 1.47
; Output:
;   st(0)   = 1/sqrt(vector length)
;
COMPUTE_ISQRT MACRO
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     len                         ; Vector length (x = len)
    sub     eax, len
    sar     eax, 1
    mov     y, eax                      ; y
    fmul    a1                          ; len*0.47  x y z
    fld     y                           ; y len*0.47 x y z
    fld     st(0)                       ; y y len*0.47 x y z
    fmul    st(0), st(1)                ; y*y y len*0.47 x y z
    fld     a2                          ; 1.47 y*y y len*0.47 x y z
    fxch    st(3)                       ; len*0.47 y*y y 1.47 x y z
    fmulp   st(1), st(0)                ; len*0.47*y*y y 1.47 x y z
    fsubp   st(2), st(0)                ; y aaa x y z
    fmulp   st(1), st(0)                ; 1/sqrt(len) x y z
ENDM
;-------------------------------------------------------------------------
; Exit from the function
;
EXIT_FUNC   MACRO
    pop     edx
    pop     ebx
    pop     ecx
    mov     esp, ebp
    pop     ebp
    ret
ENDM
;-------------------------------------------------------------------------
; void Directional2P5S(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Specular is always computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse and pv.lighting.specular are updated
;   pv.lighting.specularComputed is set to 1, if there is specular component
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5S PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit1

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

; if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)

;    test    DWORD PTR [ecx + D3DI_LIGHT_flags], D3DLIGHTI_COMPUTE_SPECULAR
;    jz      exit

; VecSub(in->dvPosition, light->model_eye, eye);

    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _X_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _X_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Y_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Y_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Z_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Z_]    ; z y x
    fxch    st(2)                                           ; x y z

; VecNormalizeFast(eye);
;

; Compute vector length. Leave vector on the FPU stack, because we will use it
;
    fld     st(1)                       ; x x y z
    fmul    st(0), st(0)                ; x*x x y z
    fld     st(2)
    fmul    st(0), st(0)                ; y*y x*x x y z
    fld     st(4)
    fmul    st(0), st(0)                ; z*z y*y x*x x y z
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len x y z

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

; Start normalizing the eye vector
    fmul    st(1), st(0)
    fmul    st(2), st(0)
    fmulp   st(3), st(0)                ; x y z  Normalized "eye" vector

; Calc halfway vector
; VecSub(light->model_direction, eye, h);
;
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fxch    st(1)                       ; y x z
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fxch    st(2)                       ; z x y 
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fxch    st(1)                       ; x z y 

; dot = VecDot(h, in->dvNormal);

    fld     st(0)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     st(3)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     st(3)                       ; z*Nz y*Ny x*Nx x z y
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_]
    fxch    st(2)
    faddp   st(1), st(0)
    faddp   st(1), st(0)                ; dot x z y
    fstp    dot                         ; x z y

; if (FLOAT_GTZ(dot)) 

    cmp     dot, 0
    jle     exit2

; dot *= ISQRTF(VecLenSq(h));
;
    fmul    st(0), st(0)                ; x*x y z
    fxch    st(1)                       ; y x*x z
    fmul    st(0), st(0)                ; y*y x*x z
    fxch    st(2)
    fmul    st(0), st(0)                ; z*z y*y x*x
    fxch    st(2)			            ; 
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

    fmul    dot                         ; dot
    mov     eax, [edx + PV_LIGHT_specThreshold]
    fst     dot

; if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))

    cmp     dot, eax
    jle     exit1

; power = COMPUTE_DOT_POW(&ldrv, dot);
;    int     indx;                
;    float   v;
;    dot *= 255.0f;
;    indx = (int)dot;
;    dot -= indx;                                            
;    ldrv->specularComputed = TRUE;                          
;    v = ldrv->currentSpecTable[indx];
;    return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
;
    fmul    v255            ; dot*255*256
    push    ebx
    fistp   dot             ; indx << 8. 8 bits used to compute dot fraction
    mov     ebx, dot        ; 
    and     dot, 0FFh       ; fractional part of dot
    shr     ebx, 8          ; Table index
    mov     eax, [edx + PV_LIGHT_currentSpecTable]
    lea     eax, [eax + ebx*4]
    fild    dot             ; fractional part of dot
    fmul    v1_256          ; dot*1/256 -> integer fraction to floating point
    fld     DWORD PTR [eax + 4]     ; currentSpecTable[indx+1]
    fsub    DWORD PTR [eax]         ; currentSpecTable[indx]
    fmulp   st(1), st(0)            ; dot*(v2-v1)
    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
    pop     ebx
    fadd    DWORD PTR [eax]

; power = COMPUTE_DOT_POW(&ldrv, dot);
; This is an alternative method to compute x power y.
; Jim Blinn's method is used:
; int tmp = (int)(power*(*(long*)&dot - ONE_AS_INTEGER)) + ONE_AS_INTEGER;
; dot ^ power = *(float*)&tmp;                                           
;
;    sub     dot, 03F800000h
;    fstp    st(0)                       ; Remove dot
;    fld     DWORD PTR [edx + PV_LIGHT_material_power]
;    fimul   dot
;    fistp   dot
;    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
;    add     dot, 03F800000h
;    fld     dot

; ldrv.specular.r += light->local_specR * power;
; ldrv.specular.g += light->local_specG * power;
; ldrv.specular.b += light->local_specB * power;
;
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specB]
    fmulp   st(3), st(0)                ; g r b
    fxch    st(1)                       ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fxch    st(1)                       ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(2)                       ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(1)                       ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _G_]
exit:
    EXIT_FUNC
exit1:
    fstp    st(0)
    EXIT_FUNC
exit2:
    fstp    st(0)
    fstp    st(0)
    fstp    st(0)
    EXIT_FUNC

_Directional2P5S ENDP
;-------------------------------------------------------------------------
; void Directional2P5(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Only diffuse component is computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse is updated
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5 PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit3

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

    EXIT_FUNC
exit3:
    fstp    st(0)
    EXIT_FUNC

_Directional2P5 ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\tclipp5.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul5

_matmul5  PROC    

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;


        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;


; notation in comments on stack gives the progress on the element.
; x, y, z mean input x y z
; x1-4 means x*_11, x*_11+y*_21, x*_11+y*_21+z*_31, x*_11+y*_21+z*_31+_41
; Some intermediate results x*_11+_41 and y*_21+z*_31 are denoted as x2

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31 y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fxch    st(2)                           ; y*_21 y*_24 z*_31 w1 x1
        faddp   st(4),st                        ; y*_24 z*_31 w1 x2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34 y*_24 z*_31 w1 x2
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fxch    st(1)                           ; y*_24 z*_34 z*_31 w1 x2
        faddp   st(3),st                        ; z*_34 z*_31 w2 x2
        fxch    st(1)                           ; z*_31 z*_34 w2 x2
        faddp   st(3),st                        ; z*_34 w2 x3
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 z*_34 w2 x3
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fxch    st(1)                           ; z*_34 y1 w2 x3
        faddp   st(2),st                        ; y1 w3 x3
        fxch    st(2)                           ; x3 w3 y1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x4 w3 y1
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23 y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;
        fxch    st(4)                           ; w3 y*_22 z1 x4 y*_23 y1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w4 y*_22 z1 x4 y*_23 y1
        fxch    st(3)                           ; x4 y*_22 z1 w4 y*_23 y1
        fst     dword ptr [ebp]                 ;
        fxch    st(1)                           ; y*_22 x4 z1 w4 y*_23 y1
        faddp   st(5),st                        ; x4 z1 w4 y*_23 y2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33 z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;
        fxch    st(6)                           ; y2 z*_32 x4 z1 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y3 z*_32 x4 z1 w4 y*_23 z*_33
        fxch    st(3)                           ; z1 z*_32 x4 y3 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 z*_32 x4 y3 w4 y*_23 z*_33
        fxch    st(5)                           ; y*_23 z*_32 x4 y3 w4 z2 z*_33
        faddp   st(6),st                        ; z*_32 x4 y3 w4 z2 z2
        faddp   st(2),st                        ; x4 y4 w4 z2 z2

;;
        fsubr   st,st(2)                        ; xx y4 w4 z2 z2
        fxch    st(4)                           ; z2 y4 w4 z2 xx
        faddp   st(3),st                        ; y4 w4 z4 xx
        fld     st                              ; y4 y4 w4 z4 xx
        fsubr   st,st(2)                        ; yy y4 w4 z4 xx
        fxch    st(1)                           ; y4 yy w4 z4 xx
        fstp    dword ptr [ebp+4]               ; yy w4 z4 xx
        fxch    st(3)                           ; xx w4 z4 yy
        fstp    tempxx                          ; w4 z4 yy
        fxch    st(1)                           ; z4 w4 yy
        fst     dword ptr [ebp+8]               ;
        fsubr   st,st(1)                        ; zz w4 yy
        fxch    st(2)                           ; yy w4 zz
        fstp    tempyy                          ; w4 zz
        fxch    st(1)                           ; zz w4
        fstp    tempzz                          ;

        fld1                                    ; 1 w4
        fdiv	st,st(1)                        ; 1/w w

;; Now compute the clipcodes.


;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

        mov     eax,dword ptr [ebp]     ; Get x
        mov     ebx,dword ptr [ebp+4]   ; Get y

        and     eax,esi                 ;
        and     ebx,esi                 ;

        shr     eax,32-1                ; D3DCLIP_LEFT
        mov     ecx,dword ptr [ebp+8]   ; Get z

        shr     ebx,32-4		; D3DCLIP_BOTTOM
        mov     edx,tempxx		;

        or      eax,ebx			; OR together clip flags
        and     ecx,esi			;

        shr     ecx,32-5		; D3DCLIP_FRONT
        and     edx,esi                 ;

        shr     edx,32-2                ; D3DCLIP_RIGHT
        mov     ebx,tempyy		;

        or      eax,ecx                 ;
        and     ebx,esi                 ;

        shr     ebx,32-3                ; D3DCLIP_TOP
        or      eax,edx                 ;

        mov     edx,tempzz
        or      eax,ebx                 ;

        and     edx,esi                 ;

        shr     edx,32-6                ; D3DCLIP_BACK
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv

        or      eax,edx                 ; Finish clip flag generation
        mov     ebx,pmat                ;

        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;

        test    eax,eax                 ; Bail if clip!=0
        jnz     ClipNonzero             ;

        push    eax                     ; Save clip flags
                                        ; ax gets trashed by fstsw in min/max calcs

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx


        fxch    st(1)                   ; we w
        fstp    st                      ;
                                        ; w
        fld     dword ptr [ebp]         ; x w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fld     dword ptr [ebp+4]       ; y x*scaleX w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(1)                   ; x*scaleX y*scaleY w
        fmul    st,st(2)                ; x*w*scaleX y*scaleY w
        fxch    st(1)                   ; y*scaleY x*w*scaleX w
        fmul    st,st(2)                ; y*w*scaleY x*w*scaleX w
        fxch    st(1)                   ; x*w*scaleX y*w*scaleY w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(1)                   ; y x w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fld     dword ptr [ebp+8]       ; z y x w
        fmul    st,st(3)                ; z y x w
        fxch    st(2)                   ; x y z w

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; x y z w
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
@@:     fxch    st(1)
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
@@:     fxch    st(1)
NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]

        pop     eax         ; Get clip flags back
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    st          ; Get rid of 1/w
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw] ; store we
        jmp     short Return

_matmul5  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\tnl\i386\tclipp6.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.data

gD3DCLIP_LEFT   dd  01h
gD3DCLIP_RIGHT  dd  02h
gD3DCLIP_TOP    dd  04h
gD3DCLIP_BOTTOM dd  08h
gD3DCLIP_FRONT  dd  10h
gD3DCLIP_BACK   dd  20h

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul6

_matmul6  PROC

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;

        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;

        fxch    st(3)                           ; x1 y1 w1 z1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x2 y1 w1 z1
        fxch    st(2)                           ; w1 y1 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w2 y1 x2 z1
        fxch    st(1)                           ; y1 w2 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y2 w2 x2 z1
        fxch    st(3)                           ; z1 w2 x2 y2
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 w2 x2 y2

        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;

        fxch    st(3)       ; y*_21 y*_22 y*_24 y*_23 z2 w2 x2 y2
        faddp   st(6),st    ; y*_22 y*_24 y*_23 z2 w2 x3 y2
        fxch    st(1)       ; y*_24 y*_22 y*_23 z2 w2 x3 y2
        faddp   st(4),st    ; y*_22 y*_23 z2 w3 x3 y2
        faddp   st(5),st    ; y*_23 z2 w3 x3 y3
        faddp   st(1),st    ; z3 w3 x3 y3

        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;

        fxch    st(3)       ; z*_31 z*_32 z*_34 z*_33 z3 w3 x3 y3
        faddp   st(6),st    ; z*_32 z*_34 z*_33 z3 w3 x4 y3
        fxch    st(1)       ; z*_34 z*_32 z*_33 z3 w3 x4 y3
        faddp   st(4),st    ; z*_32 z*_33 z3 w4 x4 y3
        faddp   st(5),st    ; z*_33 z3 w4 x4 y4
        faddp   st(1),st    ; z4 w4 x4 y4

        fldz                ; 0 z4 w4 x4 y4
        fxch    st(4)       ; y4 z4 w4 x4 0
        fxch    st(3)       ; x4 z4 w4 y4 0
        xor     eax,eax     ;
        xor     ebx,ebx     ;
        xor     ecx,ecx     ;
        xor     edx,edx     ;
        fcomi   st,st(4)    ;
        cmovb   eax,gD3DCLIP_LEFT
        fcomi   st,st(2)    ;
        cmovnb  ebx,gD3DCLIP_RIGHT
        fxch    st(3)       ; y4 z4 w4 x4 0
        or      eax,ebx
        xor     ebx,ebx
        fcomi   st,st(4)    ;
        cmovb   ecx,gD3DCLIP_BOTTOM
        fcomi   st,st(2)    ;
        cmovnb  edx,gD3DCLIP_TOP
        or      eax,ecx
        xor     ecx,ecx
        fxch    st(1)       ; z4 y4 w4 x4 0
        fcomi   st,st(4)    ;
        or      edx,edx
        cmovb   ebx,gD3DCLIP_FRONT
        fcomi   st,st(2)    ;
        cmovnb  ecx,gD3DCLIP_BACK
        or      eax,ebx
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv
        or      eax,ecx
        mov     ebx,pmat                ;
        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;
        fxch    st(4)   ; 0 y4 w4 x4 z4
        fstp    st      ; y4 w4 x4 z4

;; Now compute the clipcodes.

;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

;; actually the flags have not been touched since the final OR so we don't 
;; need to test this explicitly
;;      test    eax,eax
        jnz     ClipNonzero             ; jump if clip flags nonzero

        fld1                ; 1 y w x z
        fdivrp  st(2),st    ; y w x z

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx

        ; y w x z
        fabs
        fxch    st(2)
        fabs
        fxch    st(2)

        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(2)   ;
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fxch    st(2)   ; y w x z
        fmul    st,st(1)
        fxch    st(2)   ; x w y z
        fmul    st,st(1) ;
        fxch    st(2)   ; y w x z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fxch    st(2)   ; x w y z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(3)   ; z w y x
        fmul    st,st(1)
        fxch    st(3)   ; x w y z

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; minx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fcomi   st,st(1)
        fcmovnb st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]

    ; maxx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fcomi   st,st(1)
        fcmovb  st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]

    ; miny x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fcomi   st,st(3)
        fcmovnb st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]

    ; maxy x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fcomi   st,st(3)
        fcmovb  st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]

NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        jmp     short Return

_matmul6  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\hrstr.cpp ===
//----------------------------------------------------------------------------
//
// hrstr.cpp
//
// HRESULT-to-string mapper.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

struct HrStringDef
{
    HRESULT hr;
    char *pString;
};

#define HRDEF(Name) \
    Name, #Name

static HrStringDef g_HrStringDefs[] =
{
    // Put specific codes before generic codes so that specific codes
    // are returned in the cases where the HRESULT is the same.
    HRDEF(D3DERR_BADMAJORVERSION),
    HRDEF(D3DERR_BADMINORVERSION),
    HRDEF(D3DERR_EXECUTE_LOCKED),
    HRDEF(D3DERR_EXECUTE_NOT_LOCKED),
    HRDEF(D3DERR_EXECUTE_CREATE_FAILED),
    HRDEF(D3DERR_EXECUTE_DESTROY_FAILED),
    HRDEF(D3DERR_EXECUTE_LOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_UNLOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_FAILED),
    HRDEF(D3DERR_EXECUTE_CLIPPED_FAILED),
    HRDEF(D3DERR_TEXTURE_NO_SUPPORT),
    HRDEF(D3DERR_TEXTURE_NOT_LOCKED),
    HRDEF(D3DERR_TEXTURE_LOCKED),
    HRDEF(D3DERR_TEXTURE_CREATE_FAILED),
    HRDEF(D3DERR_TEXTURE_DESTROY_FAILED),
    HRDEF(D3DERR_TEXTURE_LOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_UNLOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_LOAD_FAILED),
    HRDEF(D3DERR_MATRIX_CREATE_FAILED),
    HRDEF(D3DERR_MATRIX_DESTROY_FAILED),
    HRDEF(D3DERR_MATRIX_SETDATA_FAILED),
    HRDEF(D3DERR_SETVIEWPORTDATA_FAILED),
    HRDEF(D3DERR_MATERIAL_CREATE_FAILED),
    HRDEF(D3DERR_MATERIAL_DESTROY_FAILED),
    HRDEF(D3DERR_MATERIAL_SETDATA_FAILED),
    HRDEF(D3DERR_LIGHT_SET_FAILED),
    HRDEF(DDERR_ALREADYINITIALIZED),
    HRDEF(DDERR_BLTFASTCANTCLIP),
    HRDEF(DDERR_CANNOTATTACHSURFACE),
    HRDEF(DDERR_CANNOTDETACHSURFACE),
    HRDEF(DDERR_CANTCREATEDC),
    HRDEF(DDERR_CANTDUPLICATE),
    HRDEF(DDERR_CLIPPERISUSINGHWND),
    HRDEF(DDERR_COLORKEYNOTSET),
    HRDEF(DDERR_CURRENTLYNOTAVAIL),
    HRDEF(DDERR_DIRECTDRAWALREADYCREATED),
    HRDEF(DDERR_EXCEPTION),
    HRDEF(DDERR_EXCLUSIVEMODEALREADYSET),
    HRDEF(DDERR_GENERIC),
    HRDEF(DDERR_HEIGHTALIGN),
    HRDEF(DDERR_HWNDALREADYSET),
    HRDEF(DDERR_HWNDSUBCLASSED),
    HRDEF(DDERR_IMPLICITLYCREATED),
    HRDEF(DDERR_INCOMPATIBLEPRIMARY),
    HRDEF(DDERR_INVALIDCAPS),
    HRDEF(DDERR_INVALIDCLIPLIST),
    HRDEF(DDERR_INVALIDDIRECTDRAWGUID),
    HRDEF(DDERR_INVALIDMODE),
    HRDEF(DDERR_INVALIDOBJECT),
    HRDEF(DDERR_INVALIDPARAMS),
    HRDEF(DDERR_INVALIDPIXELFORMAT),
    HRDEF(DDERR_INVALIDPOSITION),
    HRDEF(DDERR_INVALIDRECT),
    HRDEF(DDERR_LOCKEDSURFACES),
    HRDEF(DDERR_NO3D),
    HRDEF(DDERR_NOALPHAHW),
    HRDEF(DDERR_NOBLTHW),
    HRDEF(DDERR_NOCLIPLIST),
    HRDEF(DDERR_NOCLIPPERATTACHED),
    HRDEF(DDERR_NOCOLORCONVHW),
    HRDEF(DDERR_NOCOLORKEY),
    HRDEF(DDERR_NOCOLORKEYHW),
    HRDEF(DDERR_NOCOOPERATIVELEVELSET),
    HRDEF(DDERR_NODC),
    HRDEF(DDERR_NODDROPSHW),
    HRDEF(DDERR_NODIRECTDRAWHW),
    HRDEF(DDERR_NOEMULATION),
    HRDEF(DDERR_NOEXCLUSIVEMODE),
    HRDEF(DDERR_NOFLIPHW),
    HRDEF(DDERR_NOGDI),
    HRDEF(DDERR_NOHWND),
    HRDEF(DDERR_NOMIRRORHW),
    HRDEF(DDERR_NOOVERLAYDEST),
    HRDEF(DDERR_NOOVERLAYHW),
    HRDEF(DDERR_NOPALETTEATTACHED),
    HRDEF(DDERR_NOPALETTEHW),
    HRDEF(DDERR_NORASTEROPHW),
    HRDEF(DDERR_NOROTATIONHW),
    HRDEF(DDERR_NOSTRETCHHW),
    HRDEF(DDERR_NOT4BITCOLOR),
    HRDEF(DDERR_NOT4BITCOLORINDEX),
    HRDEF(DDERR_NOT8BITCOLOR),
    HRDEF(DDERR_NOTAOVERLAYSURFACE),
    HRDEF(DDERR_NOTEXTUREHW),
    HRDEF(DDERR_NOTFLIPPABLE),
    HRDEF(DDERR_NOTFOUND),
    HRDEF(DDERR_NOTLOCKED),
    HRDEF(DDERR_NOTPALETTIZED),
    HRDEF(DDERR_NOVSYNCHW),
    HRDEF(DDERR_NOZBUFFERHW),
    HRDEF(DDERR_NOZOVERLAYHW),
    HRDEF(DDERR_OUTOFCAPS),
    HRDEF(DDERR_OUTOFMEMORY),
    HRDEF(DDERR_OUTOFVIDEOMEMORY),
    HRDEF(DDERR_OVERLAYCANTCLIP),
    HRDEF(DDERR_OVERLAYCOLORKEYONLYONEACTIVE),
    HRDEF(DDERR_OVERLAYNOTVISIBLE),
    HRDEF(DDERR_PALETTEBUSY),
    HRDEF(DDERR_PRIMARYSURFACEALREADYEXISTS),
    HRDEF(DDERR_REGIONTOOSMALL),
    HRDEF(DDERR_SURFACEALREADYATTACHED),
    HRDEF(DDERR_SURFACEALREADYDEPENDENT),
    HRDEF(DDERR_SURFACEBUSY),
    HRDEF(DDERR_SURFACEISOBSCURED),
    HRDEF(DDERR_SURFACELOST),
    HRDEF(DDERR_SURFACENOTATTACHED),
    HRDEF(DDERR_TOOBIGHEIGHT),
    HRDEF(DDERR_TOOBIGSIZE),
    HRDEF(DDERR_TOOBIGWIDTH),
    HRDEF(DDERR_UNSUPPORTED),
    HRDEF(DDERR_UNSUPPORTEDFORMAT),
    HRDEF(DDERR_UNSUPPORTEDMASK),
    HRDEF(DDERR_VERTICALBLANKINPROGRESS),
    HRDEF(DDERR_WASSTILLDRAWING),
    HRDEF(DDERR_WRONGMODE),
    HRDEF(DDERR_XALIGN),
    HRDEF(E_OUTOFMEMORY),
    HRDEF(E_INVALIDARG),
    HRDEF(E_FAIL),
    HRDEF(S_FALSE),
    HRDEF(S_OK),
    0, NULL,
};

//----------------------------------------------------------------------------
//
// DebugModule::HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *DebugModule::HrString(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\cppdbg.cpp ===
//----------------------------------------------------------------------------
//
// cppdbg.cpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

#ifdef _ALPHA_
// On Alpha va_list is a structure so it's not compatible with NULL.
static va_list NULLVA;
#else
#define NULLVA NULL
#endif

static DebugModuleFlags g_FailureFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_FAILURE, BREAK),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, OUTPUT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, PROMPT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, FILENAME_ONLY),
    0, NULL,
};

static DebugModuleFlags g_OutputFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, SUPPRESS),
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, ALL_MATCH),
    0, NULL,
};

static char *g_pFlagNames[] =
{
    "AssertFlags",
    "HrFlags",
    "OutputFlags",
    "OutputMask",
    "UserFlags"
};

//----------------------------------------------------------------------------
//
// DebugModule::DebugModule
//
//----------------------------------------------------------------------------

DebugModule::DebugModule(char *pModule, char *pPrefix,
                         DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                         DebugModuleFlags *pUserFlags, UINT uUserFlags)
{
    m_pModule = pModule;
    m_iModuleStartCol = strlen(m_pModule) + 2;
    m_pPrefix = pPrefix;

    m_pModFlags[DBG_ASSERT_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_HR_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_OUTPUT_FLAGS] = g_OutputFlags;
    m_pModFlags[DBG_OUTPUT_MASK] = pOutputMasks;
    m_pModFlags[DBG_USER_FLAGS] = pUserFlags;

    m_uFlags[DBG_ASSERT_FLAGS] = DBG_FAILURE_OUTPUT | DBG_FAILURE_BREAK |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_HR_FLAGS] = DBG_FAILURE_OUTPUT |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_OUTPUT_FLAGS] = 0;
    m_uFlags[DBG_OUTPUT_MASK] = uOutputMask;
    m_uFlags[DBG_USER_FLAGS] = uUserFlags;

    ReadReg();
}

//----------------------------------------------------------------------------
//
// DebugModule::OutVa
//
// Base debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::OutVa(UINT uMask, char *pFmt, va_list Args)
{
    if (m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_SUPPRESS)
    {
        return;
    }

    if ((uMask & DBG_MASK_NO_PREFIX) == 0)
    {
        OutputDebugStringA(m_pModule);
        OutputDebugStringA(": ");
    }

    char chMsg[1024];

    _vsnprintf(chMsg, sizeof(chMsg), pFmt, Args);
    OutputDebugStringA(chMsg);
}

//----------------------------------------------------------------------------
//
// DebugModule::Out
//
// Always-output debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::Out(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    OutVa(0, pFmt, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedVa
//
// Handles assertion failure output and interface.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine)
{
    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        if (OutPathFile("Assertion failed", m_uFlags[DBG_ASSERT_FLAGS]))
        {
            OutVa(DBG_MASK_NO_PREFIX, ":\n    ", NULLVA);
        }
        else
        {
            OutVa(DBG_MASK_NO_PREFIX, ": ", NULLVA);
        }

        OutVa(DBG_MASK_NO_PREFIX, pFmt, Args);
        if (bNewLine)
        {
            OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        }
    }

    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailed
//
// Handles simple expression assertion failures.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailed(char *pExp)
{
    AssertFailedVa(pExp, NULLVA, TRUE);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedMsg
//
// Handles assertion failures with arbitrary debug output.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedMsg(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    AssertFailedVa(pFmt, Args, FALSE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::HrFailure
//
// Handles HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrFailure(HRESULT hr, char *pPrefix)
{
    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        OutPathFile(pPrefix, m_uFlags[DBG_HR_FLAGS]);
        OutMask(DBG_MASK_FORCE_CONT, ": %s\n", HrString(hr));
    }

    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::HrStmtFailed
//
// Handles statement-style HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrStmtFailed(HRESULT hr)
{
    HrFailure(hr, "HR test fail");
}

//----------------------------------------------------------------------------
//
// DebugModule::ReturnHr
//
// Handles expression-style HRESULT failures.
//
//----------------------------------------------------------------------------

HRESULT DebugModule::HrExpFailed(HRESULT hr)
{
    HrFailure(hr, "HR expr fail");
    return hr;
}

//----------------------------------------------------------------------------
//
// DebugModule::Prompt
//
// Allows control over debug options via interactive input.
//
//----------------------------------------------------------------------------

void DebugModule::Prompt(char *pFmt, ...)
{
    va_list Args;

    if (pFmt != NULL)
    {
        va_start(Args, pFmt);
        OutVa(0, pFmt, Args);
        va_end(Args);
    }

#if 0   // ndef WIN95
    // This is DEADCODE, that is can be potentially used on NT ONLY to
    // bring up a debugging prompt. It requires linking with NTDLL.LIB
    char szInput[512];
    char *pIdx;
    int iIdx;
    static char szFlagCommands[] = "ahomu";

    for (;;)
    {
        ULONG uLen;

        uLen = DbgPrompt("[bgaAFhHmMoOrRuU] ", szInput, sizeof(szInput) - 1);
        if (uLen < 2)
        {
            Out("DbgPrompt failed\n");
            DebugBreak();
            return;
        }

        // ATTENTION - Currently DbgPrompt returns a length that is two
        // greater than the actual number of characters.  Presumably this
        // is an artifact of the Unicode/ANSI conversion and should
        // really only be one greater, so attempt to handle both.

        uLen -= 2;
        if (szInput[uLen] != 0)
        {
            uLen++;
            szInput[uLen] = 0;
        }

        if (uLen < 1)
        {
            Out("Empty command ignored\n");
            continue;
        }

        switch(szInput[0])
        {
        case 'b':
            DebugBreak();
            break;
        case 'g':
            return;

        case 'r':
            WriteReg();
            break;
        case 'R':
            ReadReg();
            break;

        case 'a':
        case 'A':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            char chLower;

            if (szInput[0] >= 'A' && szInput[0] <= 'Z')
            {
                chLower = szInput[0] - 'A' + 'a';
            }
            else
            {
                chLower = szInput[0];
            }

            pIdx = strchr(szFlagCommands, chLower);
            if (pIdx == NULL)
            {
                // Should never happen.
                break;
            }

            iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
            if (szInput[0] == chLower)
            {
                // Set.
                m_uFlags[iIdx] = ParseUint(szInput + 1, m_pModFlags[iIdx]);
            }

            // Set or Get.
            OutUint(g_pFlagNames[iIdx], m_pModFlags[iIdx], m_uFlags[iIdx]);
            break;

        case 'F':
            if (uLen < 2)
            {
                Out("'F' must be followed by a flag group specifier\n");
                break;
            }

            pIdx = strchr(szFlagCommands, szInput[1]);
            if (pIdx == NULL)
            {
                Out("Unknown flag group '%c'\n", szInput[1]);
            }
            else
            {
                iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
                ShowFlags(g_pFlagNames[iIdx], m_pModFlags[iIdx]);
            }
            break;

        default:
            Out("Unknown command '%c'\n", szInput[0]);
            break;
        }
    }
#else
    OutUint("OutputMask", m_pModFlags[DBG_OUTPUT_MASK],
            m_uFlags[DBG_OUTPUT_MASK]);
    Out("Prompt not available\n");
#if DBG
    DebugBreak();
#endif
#endif
}

//----------------------------------------------------------------------------
//
// DebugModule::OpenDebugKey
//
// Opens the Direct3D\Debug\m_pModule key.
//
//----------------------------------------------------------------------------

HKEY DebugModule::OpenDebugKey(void)
{
    HKEY hKey;
    char szKeyName[128];

    strcpy(szKeyName, "Software\\Microsoft\\Direct3D\\Debug\\");
    strcat(szKeyName, m_pModule);
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS,
                      &hKey) != ERROR_SUCCESS)
    {
        return NULL;
    }
    else
    {
        return hKey;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::GetRegUint
//
// Gets a UINT value from the given key.
//
//----------------------------------------------------------------------------

UINT DebugModule::GetRegUint(HKEY hKey, char *pValue, UINT uDefault)
{
    DWORD dwType, dwSize;
    DWORD dwVal;

    dwSize = sizeof(dwVal);
    if (RegQueryValueExA(hKey, pValue, NULL, &dwType, (BYTE *)&dwVal,
                         &dwSize) != ERROR_SUCCESS ||
        dwType != REG_DWORD)
    {
        return uDefault;
    }
    else
    {
        return (UINT)dwVal;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::SetRegUint
//
// Sets a UINT value for the given key.
//
//----------------------------------------------------------------------------

BOOL DebugModule::SetRegUint(HKEY hKey, char *pValue, UINT uValue)
{
    return RegSetValueExA(hKey, pValue, NULL, REG_DWORD, (BYTE *)&uValue,
                          sizeof(uValue)) == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
// DebugModule::ReadReg
//
// Reads settings from the registry.
//
//----------------------------------------------------------------------------

void DebugModule::ReadReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            m_uFlags[iIdx] = GetRegUint(hKey, g_pFlagNames[iIdx],
                                        m_uFlags[iIdx]);
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::WriteReg
//
// Writes values to the registry.
//
//----------------------------------------------------------------------------

void DebugModule::WriteReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            if (!SetRegUint(hKey, g_pFlagNames[iIdx], m_uFlags[iIdx]))
            {
                OutputDebugStringA("Error writing registry information\n");
            }
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ParseUint
//
// Parses a string for a numeric value or a set of flag strings.
//
//----------------------------------------------------------------------------

UINT DebugModule::ParseUint(char *pString, DebugModuleFlags *pFlags)
{
    UINT uVal;

    uVal = 0;

    for (;;)
    {
        while (*pString != 0 &&
               (*pString == ' ' || *pString == '\t'))
        {
            pString++;
        }

        if (*pString == 0)
        {
            break;
        }

        char *pEnd;
        int iStepAfter;

        pEnd = pString;
        while (*pEnd != 0 && *pEnd != ' ' && *pEnd != '\t')
        {
            pEnd++;
        }
        iStepAfter = *pEnd != 0 ? 1 : 0;
        *pEnd = 0;

        if (*pString >= '0' && *pString <= '9')
        {
            uVal |= strtoul(pString, &pString, 0);
            if (*pString != 0 && *pString != ' ' && *pString != '\t')
            {
                Out("Unrecognized characters '%s' after number\n", pString);
            }
        }
        else if (pFlags != NULL)
        {
            DebugModuleFlags *pFlag;

            for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
            {
                if (!_stricmp(pString, pFlag->pName))
                {
                    break;
                }
            }

            if (pFlag->uFlag == 0)
            {
                Out("Unrecognized flag string '%s'\n", pString);
            }
            else
            {
                uVal |= pFlag->uFlag;
            }
        }
        else
        {
            Out("No flag definitions, unable to convert '%s'\n", pString);
        }

        pString = pEnd + iStepAfter;
    }

    return uVal;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutUint
//
// Displays a UINT as a set of flag strings.
//
//----------------------------------------------------------------------------

void DebugModule::OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue)
{
    if (pFlags == NULL || uValue == 0)
    {
        Out("%s: 0x%08X\n", pName, uValue);
        return;
    }

    Out("%s:", pName);
    m_iStartCol = m_iModuleStartCol + strlen(pName) + 1;
    m_iCol = m_iStartCol;

    while (uValue != 0)
    {
        DebugModuleFlags *pFlag;

        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            if ((pFlag->uFlag & uValue) == pFlag->uFlag)
            {
                AdvanceCols(strlen(pFlag->pName) + 1);
                OutMask(DBG_MASK_FORCE_CONT, " %s", pFlag->pName);
                uValue &= ~pFlag->uFlag;
                break;
            }
        }

        if (pFlag->uFlag == 0)
        {
            AdvanceCols(11);
            OutMask(DBG_MASK_FORCE_CONT, " 0x%X", uValue);
            uValue = 0;
        }
    }

    OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
}

//----------------------------------------------------------------------------
//
// DebugModule::AdvanceCols
//
// Determines if there's enough space on the current line for
// the given number of columns.  If not, a new line is started.
//
//----------------------------------------------------------------------------

void DebugModule::AdvanceCols(int iCols)
{
    static char szSpaces[] = "                                ";

    m_iCol += iCols;
    if (m_iCol >= 79)
    {
        int iSpace;

        OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        // Force a prefix to be printed to start the line.
        Out("");

        m_iCol = m_iModuleStartCol;
        while (m_iCol < m_iStartCol)
        {
            iSpace = (int)min(sizeof(szSpaces) - 1, m_iStartCol - m_iCol);
            OutMask(DBG_MASK_FORCE_CONT, "%.*s", iSpace, szSpaces);
            m_iCol += iSpace;
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ShowFlags
//
// Shows the given flag set.
//
//----------------------------------------------------------------------------

void DebugModule::ShowFlags(char *pName, DebugModuleFlags *pFlags)
{
    DebugModuleFlags *pFlag;

    Out("%s:\n", pName);
    if (pFlags == NULL)
    {
        Out("    None defined\n");
    }
    else
    {
        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            Out("    0x%08X - %s\n", pFlag->uFlag, pFlag->pName);
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::PathFile
//
// Returns the trailing filename component or NULL if the path is
// only a filename.
//
//----------------------------------------------------------------------------

char *DebugModule::PathFile(char *pPath)
{
    char *pFile, *pSlash, *pBack, *pColon;

    pBack = strrchr(pPath, '\\');
    pSlash = strrchr(pPath, '/');
    pColon = strrchr(pPath, ':');

    pFile = pBack;
    if (pSlash > pFile)
    {
        pFile = pSlash;
    }
    if (pColon > pFile)
    {
        pFile = pColon;
    }

    return pFile != NULL ? pFile + 1 : NULL;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutPathFile
//
// Outputs the given string plus a path and filename.
// Returns whether the full path was output or not.
//
//----------------------------------------------------------------------------

BOOL DebugModule::OutPathFile(char *pPrefix, UINT uFailureFlags)
{
    char *pFile;

    if (uFailureFlags & DBG_FAILURE_FILENAME_ONLY)
    {
        pFile = PathFile(m_pFile);
    }
    else
    {
        pFile = NULL;
    }

    if (pFile == NULL)
    {
        Out("%s %s(%d)", pPrefix, m_pFile, m_iLine);
        return TRUE;
    }
    else
    {
        Out("%s <>\\%s(%d)", pPrefix, pFile, m_iLine);
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_ONCE(Global, G, NULL, 0, NULL, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\cppdbg.hpp ===
//----------------------------------------------------------------------------
//
// cppdbg.hpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _CPPDBG_HPP_
#define _CPPDBG_HPP_

#if DBG

#include <stdarg.h>

typedef unsigned int UINT;
        
//
// Mask bits common to all modules.
//

#define DBG_MASK_NO_PREFIX              0x80000000
#define DBG_MASK_FORCE                  0x40000000

// Mask bits checked against output mask.
#define DBG_MASK_CHECK                  (~(DBG_MASK_NO_PREFIX | \
                                           DBG_MASK_FORCE))

// Forced continuation mask.
#define DBG_MASK_FORCE_CONT             (DBG_MASK_NO_PREFIX | DBG_MASK_FORCE)

//
// Failure control bits for assert and HRESULT failures.
//

#define DBG_FAILURE_BREAK               0x00000001
#define DBG_FAILURE_OUTPUT              0x00000002
#define DBG_FAILURE_PROMPT              0x00000004
#define DBG_FAILURE_FILENAME_ONLY       0x00000008

//
// Overall output control bits.
//

#define DBG_OUTPUT_SUPPRESS             0x00000001
#define DBG_OUTPUT_ALL_MATCH            0x00000002

//----------------------------------------------------------------------------
//
// DebugModule
//
//----------------------------------------------------------------------------

struct DebugModuleFlags
{
    UINT uFlag;
    char *pName;
};

// Declares a DebugModuleFlags entry.
#define DBG_DECLARE_MODFLAG(Group, Name) \
    Group ## _ ## Name, #Name

enum
{
    DBG_ASSERT_FLAGS,
    DBG_HR_FLAGS,
    DBG_OUTPUT_FLAGS,
    DBG_OUTPUT_MASK,
    DBG_USER_FLAGS,
    DBG_FLAGS_COUNT
};

class DebugModule
{
public:
    DebugModule(char *pModule, char *pPrefix,
                DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                DebugModuleFlags *pUserFlags, UINT uUserFlags);

    void Out(char *pFmt, ...);

    void OutMask(UINT uMask, char *pFmt, ...)
    {
        if ((uMask & DBG_MASK_FORCE) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) == uMask) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) == 0 &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) != 0))
        {
            va_list Args;

            va_start(Args, pFmt);
            OutVa(uMask, pFmt, Args);
            va_end(Args);
        }
    }
    
    void AssertFailed(char *pExp);
    void AssertFailedMsg(char *pFmt, ...);

    void HrStmtFailed(HRESULT hr);
    HRESULT HrExpFailed(HRESULT hr);
    
    void SetFileLine(char *pFile, int iLine)
    {
        m_pFile = pFile;
        m_iLine = iLine;
    }

    void Prompt(char *pFmt, ...);

    UINT GetFlags(int iIdx)
    {
        return m_uFlags[iIdx];
    }
    void SetFlags(int iIdx, UINT uValue)
    {
        m_uFlags[iIdx] = uValue;
    }

private:
    void OutVa(UINT uMask, char *pFmt, va_list Args);
    void AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine);

    HKEY OpenDebugKey(void);
    UINT GetRegUint(HKEY hKey, char *pValue, UINT uDefault);
    BOOL SetRegUint(HKEY hKey, char *pValue, UINT uValue);
    void ReadReg(void);
    void WriteReg(void);

    UINT ParseUint(char *pString, DebugModuleFlags *pFlags);
    void OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue);

    void AdvanceCols(int iCols);

    void ShowFlags(char *pName, DebugModuleFlags *pFlags);

    char *PathFile(char *pPath);
    BOOL OutPathFile(char *pPrefix, UINT uFailureFlags);

    void HrFailure(HRESULT hr, char *pPrefix);
    char *HrString(HRESULT hr);
    
    // Module information given.
    char *m_pModule;
    char *m_pPrefix;
    
    // Flag descriptions and values.
    DebugModuleFlags *m_pModFlags[DBG_FLAGS_COUNT];
    UINT m_uFlags[DBG_FLAGS_COUNT];

    // Temporary file and line number storage.
    char *m_pFile;
    int m_iLine;

    // Output column during multiline display.
    int m_iModuleStartCol;
    int m_iCol;
    int m_iStartCol;
};

//----------------------------------------------------------------------------
//
// Support macros.
//
//----------------------------------------------------------------------------

#define DBG_MODULE(Prefix) Prefix ## _Debug

// Put this in one source file.
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags) \
    DebugModule DBG_MODULE(Prefix)(#Module, #Prefix, \
                                   pOutputMasks, uOutputMask, \
                                   pUserFlags, uUserFlags)

// Put this in your derived debugging header.
#define DBG_DECLARE_HEADER(Prefix) \
    extern DebugModule DBG_MODULE(Prefix)

// Put this in every file.
#define DBG_DECLARE_FILE() \
    static char *g_pStaticDebugFile = __FILE__

#define DBG_DECLARE_DPF(Prefix, Args) \
    DBG_MODULE(Prefix).Out Args
#define DBG_DECLARE_DPFM(Prefix, Args) \
    DBG_MODULE(Prefix).OutMask Args

#define DBG_DECLARE_ASSERT(Prefix, Exp) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailed(#Exp); } \
    else 0
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailedMsg Args ; } \
    else 0
#define DBG_DECLARE_VERIFY(Prefix, Exp) \
    DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args)\
    DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)

#define DBG_DECLARE_PROMPT(Prefix, Args) \
    DBG_MODULE(Prefix).Prompt Args

#define DBG_DECLARE_GETFLAGS(Prefix, Idx) \
    DBG_MODULE(Prefix).GetFlags(Idx)
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value) \
    DBG_MODULE(Prefix).SetFlags(Idx, Value)

//
// These macros assume a variable 'hr' exists.
//

// HRESULT test in expression form.
#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    ((hr = (Exp)) != S_OK ? \
      (DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__), \
       DBG_MODULE(Prefix).HrExpFailed(hr)) : hr)

// HRESULT test in if/then form.
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).HrStmtFailed(hr); \
      DoFail; } \
    else hr

#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#else // #if DBG

//
// Empty macros for free builds.
//

#define DBG_MODULE(Prefix) 0
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags)
#define DBG_DECLARE_HEADER(Prefix)
#define DBG_DECLARE_FILE()

#define DBG_DECLARE_DPF(Prefix, Args)
#define DBG_DECLARE_DPFM(Prefix, Args)
#define DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)
#define DBG_DECLARE_PROMPT(Prefix, Args)
#define DBG_DECLARE_GETFLAGS(Prefix, Idx) 0
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value)

//
// Macros which evaluate to code on free builds.
//

#define DBG_DECLARE_VERIFY(Prefix, Exp) (Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args) (Exp)

#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    (hr = (Exp))
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) DoFail; else hr
#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_HEADER(G);

#define GDPF(Args)              DBG_DECLARE_DPF(G, Args)
#define GDPFM(Args)             DBG_DECLARE_DPFM(G, Args)
#define GASSERT(Exp)            DBG_DECLARE_ASSERT(G, Exp)
#define GASSERTMSG(Exp, Args)   DBG_DECLARE_ASSERTMSG(G, Exp, Args)
#define GVERIFY(Exp)            DBG_DECLARE_VERIFY(G, Exp)
#define GVERIFYMSG(Exp)         DBG_DECLARE_VERIFYMSG(G, Exp, Args)
#define GPROMPT(Args)           DBG_DECLARE_PROMPT(G, Args)
#define GGETFLAGS(Idx)          DBG_DECLARE_GETFLAGS(G, Idx)
#define GSETFLAGS(Idx, Value)   DBG_DECLARE_SETFLAGS(G, Idx, Value)
#define GHRCHK(Exp)             DBG_DECLARE_HRCHK(G, Exp)
#define GHRGO(Exp, Label)       DBG_DECLARE_HRGO(G, Exp, Label)
#define GHRERR(Exp)             DBG_DECLARE_HRERR(G, Exp)
#define GHRRET(Exp)             DBG_DECLARE_HRRET(G, Exp)

#endif // #ifndef _CPPDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\texdiff.h ===
//----------------------------------------------------------------------------
//
// texdiff.h
//
// TextureDiff base code for inclusion as an inline function or
// regular function from common code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------

{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern DOUBLE g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <span.h>
#include "cppdbg.hpp"

DBG_DECLARE_FILE();

// Declare TextureDiff as an out-of-line function.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    GDPF(("!! DebugBreakFn called.  Leaving this function may destroy\n"));
    GDPF(("   the stack frame. !!\n"));
#if DBG
    DebugBreak();
#endif
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif
#define MAX_LEN 1
#ifdef MAX_LEN
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and take the max of each length
    // like classic OpenGL and the current RefRast implementation
    fCoverage = max(OctagonNorm(fDUDX, fDVDX), OctagonNorm(fDUDY, fDVDY));
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGSTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    GASSERTMSG(FALSE, ("ComputeTableFog unreachable\n"));
    return 0;
}

//----------------------------------------------------------------------------
//
// pVecNormalize2
//
// Normalizes the given D3DVECTOR.  Supports in-place operation.
//
//----------------------------------------------------------------------------

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes)
{
    FLOAT fLen;

    fLen = pVecLenSq(pVec);
    if (FLOAT_CMP_POS(fLen, <=, g_fNearZero))
    {
        pVecSet(pRes, 0.0f, 0.0f, 0.0f);
        return;
    }
    fLen = ISQRTF(fLen);
    pVecScale(pVec, fLen, pRes);
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3, D3DVECTORH *plane)
{
    D3DVECTOR a;
    D3DVECTOR b;

    pVecSub(v2, v1, &a);
    pVecSub(v3, v1, &b);

    plane->x = a.y*b.z - a.z*b.y;
    plane->y = a.z*b.x - a.x*b.z;
    plane->z = a.x*b.y - a.y*b.x;
    plane->w = - pVecDot(v1, plane);

    double tmp = pVecDot(plane, plane);
    if (tmp <= 0)
        return -1;
    tmp = 1.0/sqrt(tmp);

    plane->x = (D3DVALUE)(plane->x * tmp);
    plane->y = (D3DVALUE)(plane->y * tmp);
    plane->z = (D3DVALUE)(plane->z * tmp);
    plane->w = (D3DVALUE)(plane->w * tmp);
    return 0;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        for (INT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(dwFVF, i))
            {
            case D3DFVF_TEXTUREFORMAT2: dwStride += sizeof(D3DVALUE) * 2; break;
            case D3DFVF_TEXTUREFORMAT1: dwStride += sizeof(D3DVALUE) * 1; break;
            case D3DFVF_TEXTUREFORMAT3: dwStride += sizeof(D3DVALUE) * 3; break;
            case D3DFVF_TEXTUREFORMAT4: dwStride += sizeof(D3DVALUE) * 4; break;
            }
        }
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return D3D_OK;
}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <d3dp.h>
#include <cppdbg.hpp>
#include "d3ditype.h"
#include "d3dflt.h"
#include "d3dutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#include <d3dflt.h>

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#ifdef __cplusplus
extern "C" {
#endif

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//
// D3DVECTOR operations.
//

#define pVecLenSq(pVec)                                                       \
    pVecDot(pVec, pVec)
#define pVecLen(pVec)                                                         \
    SQRTF(pVecLenSq(pVec))

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes);

#define pVecNormalize(pVec)             pVecNormalize2(pVec, pVec)
#define VecNormalize(Vec)               pVecNormalize(&(Vec))
#define VecNormalize2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))

#define pVecDot(pVec1, pVec2)                                                 \
    ((pVec1)->x * (pVec2)->x + (pVec1)->y * (pVec2)->y +                      \
     (pVec1)->z * (pVec2)->z)

#define pVecAdd(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x + (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y + (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z + (pVec2)->z)

#define pVecSub(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x - (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y - (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z - (pVec2)->z)

#define pVecScale(pVec, fScale, pRes)                                         \
    ((pRes)->x = (pVec)->x * (fScale),                                        \
     (pRes)->y = (pVec)->y * (fScale),                                        \
     (pRes)->z = (pVec)->z * (fScale))

#define pVecNeg(pVec, pRes)                                                   \
    ((pRes)->x = NEGF((pVec)->x),                                             \
     (pRes)->y = NEGF((pVec)->y),                                             \
     (pRes)->z = NEGF((pVec)->z))

#define pVecSet(pVec, fX, fY, fZ)                                             \
    ((pVec)->x = (fX), (pVec)->y = (fY), (pVec)->z = (fZ))

#define VecLenSq(Vec)                   pVecLenSq(&(Vec))
#define VecLen(Vec)                     pVecLen(&(Vec))

#ifdef _X86_

// Vector normalize through a table
void  FASTCALL TableVecNormalize(float *result, float *normal);
// Vector normalize using Jim Blinn's floating point trick
void  FASTCALL JBVecNormalize(float *result, float *normal);

#define VecNormalizeFast(Vec)          TableVecNormalize((float*)&(Vec), (float*)&(Vec))
#define VecNormalizeFast2(Vec, Res)    TableVecNormalize((float*)&(Res), (float*)&(Vec))
#define pVecNormalizeFast(Vec)         TableVecNormalize((float*)pVec, (float*)pVec)
#define pVecNormalizeFast2(pVec, pRes) TableVecNormalize((float*)pRes, (float*)pVec)

#else

#define VecNormalizeFast(Vec)               pVecNormalize((LPD3DVECTOR)&(Vec))
#define VecNormalizeFast2(Vec, Res)         pVecNormalize2((LPD3DVECTOR)&(Vec), &(Res))
#define pVecNormalizeFast(pVec)             pVecNormalize((LPD3DVECTOR)(pVec))
#define pVecNormalizeFast2(pVec, pRes)      pVecNormalize2((LPD3DVECTOR)(pVec), pRes)

#endif // _X86_

#define VecDot(Vec1, Vec2)              pVecDot(&(Vec1), &(Vec2))
#define VecAdd(Vec1, Vec2, Res)         pVecAdd(&(Vec1), &(Vec2), &(Res))
#define VecSub(Vec1, Vec2, Res)         pVecSub(&(Vec1), &(Vec2), &(Res))
#define VecScale(Vec1, fScale, Res)     pVecScale(&(Vec1), fScale, &(Res))
#define VecNeg(Vec, Res)                pVecNeg(&(Vec), &(Res))
#define VecSet(Vec, fX, fY, fZ)         pVecSet(&(Vec), fX, fY, fZ)

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = (D3DVALUE) 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by transposed 4x4 matrix, producing a 
// homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4HT(D3DVECTORH *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3,
                     D3DVECTORH *plane);
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\sources.inc ===
TARGETNAME = d3dutil
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = $(INCLUDES);$(D3DDX7)\tnl
        
SOURCES = \
        ..\cppdbg.cpp\
        ..\d3dflt.cpp\
        ..\d3dutil.cpp\
        ..\_dpf.cpp\
        ..\hrstr.cpp\
        ..\_memalloc.c

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\_dpf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define PROF_SECT "Direct3D"
#define START_STR "Direct3D7: "
#include "..\..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\_memalloc.c ===
#include <stdlib.h>
#define __DXGUSEALLOC 1
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\init.c ===
#define INITGUID

#include <objbase.h>
#ifdef BUILD_MSREF
#include <d3dp.h>
#else   
#include <d3d.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\util\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .list

; float __fastcall TableInvSqrt(float value);
;
; void  __fastcall TableVecNormalize(float *resultNormal, floar *normal);
;
;           resultNormal and normal could have the same address
;

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

a1  dd 0.47
a2  dd 1.47

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


__FLOAT_ONE equ 03F800000h

;----------------------------------------------------------------------
;
; float __fastcall JBInvSqrt(float x);
;
; Input:
;   esp + 4 = x
; Output:
;   result is on the floating point stack
; Algorithm:
;   The floating point trick, described in IEEE Computer Graphics and 
;   Applications v.17 number 4 in Jim Blinn's article, is used.
;
;   ONE_AS_INTEGER = 0x3F800000;
;   int   tmp = (ONE_AS_INTEGER << 1 + ONE_AS_INTEGER - *(long*)&x) >> 1;   
;   float y = *(float*)&tmp;                                             
;   result = y*(1.47f - 0.47f*x*y*y);
;
@JBInvSqrt@4 PROC NEAR
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    sub     eax, [esp+4]
    sub     esp, 4                      ; place for temporary variable "y"
    sar     eax, 1
    mov     [esp], eax                  ; y
    fld     a1
    fmul    DWORD PTR [esp+8]           ; x*0.47
    fld     DWORD PTR [esp]
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y 1.47-x*0.47*y*y
    fmulp   st(1), st(0)                ; result
    add     esp, 4
    ret     4
@JBInvSqrt@4 endp
;----------------------------------------------------------------------
; void __fastcall JBInvSqrt(float *result, float *nomal);
;
; Input:
;   ecx = address of the result
;   edx = address of the normal
;
;
@JBVecNormalize@8 PROC NEAR
    fld     DWORD PTR [edx]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 4]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 8]
    fmul    st(0), st(0)                ; z y x
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len
    sub     esp, 4                      ; Place for temporary variable "y"
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     DWORD PTR [esp]             ; Vector length
    sub     eax, [esp]
    sar     eax, 1
    mov     [esp], eax                  ; y
    fmul    a1                          ; x*0.47
    fld     DWORD PTR [esp]             ; y x*0.47
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y aaa       
    fmulp   st(1), st(0)                ; 1/sqrt(len)
    fld     DWORD PTR [edx]             ; Start normalizing the normal
    fmul    st, st(1)
    fld     DWORD PTR [edx + 4]
    fmul    st, st(2)
    fld     DWORD PTR [edx + 8]
    fmulp   st(3), st(0)                ; y x z
    fxch    st(1)
    add     esp, 4
    fstp    DWORD PTR [ecx]
    fstp    DWORD PTR [ecx + 4]
    fstp    DWORD PTR [ecx + 8]
	ret	
@JBVecNormalize@8 endp
;----------------------------------------------------------------------
; Input:
;     [esp+4] = x
;
;
x 	    equ DWORD PTR [esp + 12]
num 	equ DWORD PTR [esp]

@TableInvSqrt@4 PROC NEAR
    mov     eax, [esp + 4]          ; x
    push    ecx
    mov     ecx, eax
	sub	    esp, 4                  ; Place for num
    shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
    and     eax, CLAMP_MASK		    ;; clamp number to [0.5, 2.0]
    and     ecx, TABLE_MASK		    ;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+ecx]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, x                  ;; divide exponent by 2
    fadd    [invSqrtTab+ecx+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent
    add     esp, 4
    pop     ecx
	ret     4
@TableInvSqrt@4 endp
;----------------------------------------------------------------------
;
len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@TableVecNormalize@8 PROC NEAR
	push	ebp
	mov	    ebp, esp
	sub	    esp, 8
	fld	    DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	    DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	    DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
    mov     edi, eax
    shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
    and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
    and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+edi]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, len                ;; divide exponent by 2
    fadd    [invSqrtTab+edi+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent

	fld	    DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	    DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	    DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@TableVecNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\dprim2.cpp ===
//----------------------------------------------------------------------------
//
// dprim2.cpp
//
// Implements DrawPrimitives2.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
//---------------------------------------------------------------------
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};

HRESULT
RRFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride )
{
    if( NULL == pdwStride )
    {
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD vertexType = dwFVF & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if( dwFVF & g_TextureFormatMask[dwTexCoord] )
    {
        DPFM( 0, TNL, ("FVF has incorrect texture format") );
        return DDERR_INVALIDPARAMS;
    }

    if( dwFVF & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) ||
        ((dwFVF & D3DFVF_RESERVED1) && !(dwFVF & D3DFVF_LVERTEX)) )
    {
        DPFM( 0, TNL, ("FVF has reserved bit(s) set") );
        return DDERR_INVALIDPARAMS;
    }

    if( !(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5) )
    {
        DPFM( 0, TNL, ("FVF has incorrect position type") );
        return DDERR_INVALIDPARAMS;
    }

    if( (vertexType == D3DFVF_XYZRHW) && (dwFVF & D3DFVF_NORMAL) )
    {
        DPFM( 0, TNL, ("Normal should not be used with XYZRHW position type"));
        return DDERR_INVALIDPARAMS;
    }

    *pdwStride = GetFVFVertexSize( dwFVF );
    return D3D_OK;
}


inline D3DPRIMITIVETYPE ConvertDP2OPToPrimType(D3DHAL_DP2OPERATION Dp2Op)
{
    switch (Dp2Op)
    {
    case D3DDP2OP_POINTS              :
        return D3DPT_POINTLIST;
    case D3DDP2OP_INDEXEDLINELIST     :
    case D3DDP2OP_INDEXEDLINELIST2    :
    case D3DDP2OP_LINELIST_IMM        :
    case D3DDP2OP_LINELIST            :
        return D3DPT_LINELIST;
    case D3DDP2OP_TRIANGLELIST        :
    case D3DDP2OP_INDEXEDTRIANGLELIST :
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        return D3DPT_TRIANGLELIST;
    case D3DDP2OP_LINESTRIP           :
    case D3DDP2OP_INDEXEDLINESTRIP    :
        return D3DPT_LINESTRIP;
    case D3DDP2OP_TRIANGLESTRIP       :
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        return D3DPT_TRIANGLESTRIP;
    case D3DDP2OP_TRIANGLEFAN         :
    case D3DDP2OP_INDEXEDTRIANGLEFAN  :
    case D3DDP2OP_TRIANGLEFAN_IMM     :
        return D3DPT_TRIANGLEFAN;
    case D3DDP2OP_RENDERSTATE         :
    case D3DDP2OP_TEXTURESTAGESTATE   :
    case D3DDP2OP_VIEWPORTINFO        :
    case D3DDP2OP_WINFO               :
    default:
        DPFM(4, DRV, ("(RefRast)Non primitive operation operation in DrawPrimitives2"));
        return (D3DPRIMITIVETYPE)0;
    }
}



//----------------------------------------------------------------------------
//
// RefRastDrawPrimitives2
//
// This is called by D3DIM for API DrawPrimitives2 to draw a set of primitives
// using a vertex buffer.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data)
{
    HRESULT hr = D3D_OK;

    ReferenceRasterizer *pRefRast;
    DWORD dwStride;
    PUINT8 pVtData = NULL;

    VALIDATE_REFRAST_CONTEXT("RefRastDrawPrimitives", pDPrim2Data);

    if( pDPrim2Data->lpVertices )
    {
        if (pDPrim2Data->dwFlags & D3DHALDP2_USERMEMVERTICES)
            pVtData = (PUINT8)pDPrim2Data->lpVertices + 
                pDPrim2Data->dwVertexOffset;
        else
            pVtData = (PUINT8)pDPrim2Data->lpDDVertex->lpGbl->fpVidMem + 
                pDPrim2Data->dwVertexOffset;
    }
    
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)
                                ((PUINT8)pDPrim2Data->lpDDCommands->lpGbl->fpVidMem +
                                 pDPrim2Data->dwCommandOffset);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd +
                               pDPrim2Data->dwCommandLength;


    // Unconditionally get the vertex stride, since it can not change
    if ((pDPrim2Data->ddrval = RRFVFCheckAndStride(
                        (DWORD)pDPrim2Data->dwVertexType, &dwStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pDPrim2Data->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    // Skip state check and texture lock if the first thing is state change
    //
    // WINFO is excluded here because it currently does not affect RGB/MMX
    // and refrast does not care if it changes between begin/endrendering.
    //
    // VIEWPORTINFO is excluded here because it is OK to change the viewport
    // between begin/endrendering on both RGB/MMX and Ref.
    //

    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        LPDWORD lpdwRStates;
        if (pDPrim2Data->dwFlags & D3DHALDP2_EXECUTEBUFFER)
            lpdwRStates = pDPrim2Data->lpdwRStates;
        else
            lpdwRStates = NULL;

        BOOL bWireframe = pRefRast->GetRenderState()[D3DRENDERSTATE_FILLMODE]
                        == D3DFILL_WIREFRAME;
        pDPrim2Data->ddrval = DoDrawPrimitives2(pRefRast,
                                                (UINT16)dwStride,
                                                (DWORD)pDPrim2Data->dwVertexType,
                                                pVtData,
                                                pDPrim2Data->dwVertexLength,
                                                &pCmd,
                                                lpdwRStates,
                                                bWireframe
                                                );
        if (pDPrim2Data->ddrval != D3D_OK)
        {
            if (pDPrim2Data->ddrval == D3DERR_COMMAND_UNPARSED)
            {
                pDPrim2Data->dwErrorOffset = (UINT32)((ULONG_PTR)pCmd -
                          (UINT_PTR)(pDPrim2Data->lpDDCommands->lpGbl->fpVidMem));
            }
            goto EH_Exit;
        }
        if ((UINT_PTR)pCmd >= CmdBoundary)
            break;
    }

 EH_Exit:

    // As an optimization a check could be made here to see if it has
    // locked
    if (pRefRast->TexturesAreLocked())
    {
        hr = pRefRast->EndRendering();
        RefRastUnlockTexture(pRefRast);
        pRefRast->ClearTexturesLocked();
    }
    RefRastUnlockTarget(pRefRast);
    if (pDPrim2Data->ddrval == D3D_OK)
    {
        pDPrim2Data->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

HRESULT FASTCALL
DoDrawIndexedTriList2(ReferenceRasterizer *pCtx,
                  DWORD dwStride,
                  PUINT8 pVtx,
                  WORD cPrims,
                  D3DHAL_DP2INDEXEDTRIANGLELIST *pTriList)
{
    INT i;
    D3DHAL_DP2INDEXEDTRIANGLELIST *pTri = pTriList;

    for (i = 0; i < cPrims; i ++)
    {
        HRESULT hr;

        PUINT8 pVtx0, pVtx1, pVtx2;
        pVtx0 = pVtx + dwStride * pTri->wV1;
        pVtx1 = pVtx + dwStride * pTri->wV2;
        pVtx2 = pVtx + dwStride * pTri->wV3;
        pCtx->DrawTriangle(pVtx0, pVtx1, pVtx2, pTri->wFlags);
        pTri ++;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawPrimitives2
//
// It's called by RefRastDrawPrimitives2. .
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawPrimitives2(ReferenceRasterizer *pCtx,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  DWORD dwNumVertices,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe
                  )
{
    LPD3DHAL_DP2COMMAND pCmd = *ppCmd;
    HRESULT hr;

    DPFM(7, DRV, ("(RefRast)Read Ins: %08lx", *(LPDWORD)pCmd));

    //
    // Lock textures and setup the floating point state if the
    // command is a drawing command, only if it has not been locked before
    //
    switch(pCmd->bCommand)
    {
    case D3DDP2OP_POINTS:
    case D3DDP2OP_LINELIST:
    case D3DDP2OP_LINESTRIP:
    case D3DDP2OP_TRIANGLELIST:
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
    case D3DDP2OP_INDEXEDLINELIST:
    case D3DDP2OP_INDEXEDLINELIST2:
    case D3DDP2OP_INDEXEDLINESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLELIST:
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        // If there is no vertex information, then we cannot draw, quit
        // with an error.
        if( NULL == pVtx )
            return DDERR_OUTOFMEMORY; // The most likely cause
        // Fall through
    case D3DDP2OP_TRIANGLEFAN_IMM:
    case D3DDP2OP_LINELIST_IMM:

        if (!pCtx->TexturesAreLocked())
        {
            HR_RET(RefRastLockTexture( pCtx ));
            HR_RET(pCtx->BeginRendering( dwFvf ));
            pCtx->SetTexturesLocked();
        }
    }

    switch(pCmd->bCommand)
    {
    case D3DDP2OP_STATESET:
        {
            LPD3DHAL_DP2STATESET pStateSetOp = (LPD3DHAL_DP2STATESET)(pCmd + 1);

            switch (pStateSetOp->dwOperation)
            {
            case D3DHAL_STATESETBEGIN  :
                hr = pCtx->BeginStateSet(pStateSetOp->dwParam);
                break;
            case D3DHAL_STATESETEND    :
                hr = pCtx->EndStateSet();
                break;
            case D3DHAL_STATESETDELETE :
                hr = pCtx->DeleteStateSet(pStateSetOp->dwParam);
                break;
            case D3DHAL_STATESETEXECUTE:
                hr = pCtx->ExecuteStateSet(pStateSetOp->dwParam);
                break;
            case D3DHAL_STATESETCAPTURE:
                hr = pCtx->CaptureStateSet(pStateSetOp->dwParam);
                break;
            default :
                hr = DDERR_INVALIDPARAMS;
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pStateSetOp + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_VIEWPORTINFO:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetViewport(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_WINFO:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetWRange(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2WINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_RENDERSTATE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetRenderStates(pCtx, dwFvf, pCmd, lpdwRStates));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2RENDERSTATE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2TextureStageState(pCtx, dwFvf, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
               ((LPD3DHAL_DP2TEXTURESTAGESTATE)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    // This is a special case because it has edge flags. Other D3DDP2OP
    // can actually make use of DoDrawOneIndexedPrimitive/DoDrawOnePrimitive.
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_INDEXEDTRIANGLELIST" );

            WORD cPrims = pCmd->wPrimitiveCount;
            HR_RET(DoDrawIndexedTriList2(pCtx,
                                         dwStride,
                                         pVtx,
                                         cPrims,
                                         (D3DHAL_DP2INDEXEDTRIANGLELIST *)(pCmd + 1)));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                            sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST) * cPrims);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_INDEXEDLINELIST" );

            HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                             dwStride,
                                             pVtx,
                                             (LPWORD)(pCmd + 1),
                                             D3DPT_LINELIST,
                                             pCmd->wPrimitiveCount * 2));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    // Following ops All use DoDrawOneIndexedPrimitive/DoDrawOnePrimitive.
    // There are some extra overheads introduced because those two functions
    // need to switch over the PrimTypes while we already know it here.
    // Striping out the code to add inline functions for each PrimType means
    // adding about twenty functions(considering the types of prim times types
    // of vertex). So I have used DoDrawOneIndexedPrimitive/DoDrawOnePrimitive
    // here anyway. We can later change it if necessary.
    case D3DDP2OP_POINTS:
        {
            WORD cPrims = pCmd->wPrimitiveCount;
            D3DHAL_DP2POINTS *pPt = (D3DHAL_DP2POINTS *)(pCmd + 1);
            WORD i;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                for (i = 0; i < cPrims; i++)
                {
                    pCtx->SavePrimitiveData( dwFvf,
                                             (LPVOID) (pVtx +
                                                       pPt->wVStart * dwStride),
                                             pPt->wCount,
                                             D3DPT_POINTLIST );
                    HR_RET(pCtx->ProcessPrimitive( FALSE ));
                    pPt ++;
                }
            }
            else
            {
                for (i = 0; i < cPrims; i++)
                {
                    pCtx->SavePrimitiveData( dwFvf,
                                             (LPVOID) (pVtx +
                                                       pPt->wVStart * dwStride),
                                             pPt->wCount,
                                             D3DPT_POINTLIST );

                    HR_RET(DoDrawOnePrimitive(pCtx,
                                              dwStride,
                                              (PUINT8) (pVtx +
                                                        pPt->wVStart * dwStride),
                                              D3DPT_POINTLIST,
                                              pPt->wCount));
                    pPt ++;
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pPt;
        }
        break;
    case D3DDP2OP_LINELIST:
        {
            D3DHAL_DP2LINELIST *pLine = (D3DHAL_DP2LINELIST *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID) (pVtx +
                                               pLine->wVStart * dwStride),
                                     pCmd->wPrimitiveCount * 2,
                                     D3DPT_LINELIST );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pLine->wVStart * dwStride),
                                          D3DPT_LINELIST,
                                          pCmd->wPrimitiveCount * 2));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_LINELIST,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_LINELIST,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_LINESTRIP:
        {
            D3DHAL_DP2LINESTRIP *pLine = (D3DHAL_DP2LINESTRIP *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID) (pVtx +
                                               pLine->wVStart * dwStride),
                                     pCmd->wPrimitiveCount + 1,
                                     D3DPT_LINESTRIP );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pLine->wVStart * dwStride),
                                          D3DPT_LINESTRIP,
                                          pCmd->wPrimitiveCount + 1));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 1;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_LINESTRIP,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_LINESTRIP,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLELIST:
        {
            D3DHAL_DP2TRIANGLELIST *pTri = (D3DHAL_DP2TRIANGLELIST *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx + pTri->wVStart * dwStride),
                                     pCmd->wPrimitiveCount * 3,
                                     D3DPT_TRIANGLELIST );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pTri->wVStart * dwStride),
                                          D3DPT_TRIANGLELIST,
                                          pCmd->wPrimitiveCount * 3));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_TRIANGLELIST,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_TRIANGLELIST,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        {
            D3DHAL_DP2TRIANGLESTRIP *pTri = (D3DHAL_DP2TRIANGLESTRIP *)(pCmd + 1);
            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (pVtx + pTri->wVStart * dwStride),
                                     pCmd->wPrimitiveCount + 2,
                                     D3DPT_TRIANGLESTRIP );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pTri->wVStart * dwStride),
                                          D3DPT_TRIANGLESTRIP,
                                          pCmd->wPrimitiveCount + 2));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount+2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_TRIANGLESTRIP,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_TRIANGLESTRIP,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN:
        {
            D3DHAL_DP2TRIANGLEFAN *pTri = (D3DHAL_DP2TRIANGLEFAN *)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID) (pVtx +
                                               pTri->wVStart * dwStride),
                                     pCmd->wPrimitiveCount + 2,
                                     D3DPT_TRIANGLEFAN );

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( FALSE ));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          (pVtx + pTri->wVStart * dwStride),
                                          D3DPT_TRIANGLEFAN,
                                          pCmd->wPrimitiveCount + 2));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not
            pCtx->SavePrimitiveData( dwFvf,
                                     (LPVOID)(pVtx +
                                              lpStartVertex->wVStart*dwStride),
                                     dwNumVertices-lpStartVertex->wVStart,
                                     D3DPT_TRIANGLEFAN,
                                     (LPWORD)(lpStartVertex + 1),
                                     dwNumIndices );


            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(pCtx->ProcessPrimitive( TRUE ));
            }
            else
            {
                HR_RET(DoDrawOneIndexedPrimitive(pCtx,
                                                 dwStride,
                                                 pVtx + lpStartVertex->wVStart*dwStride,
                                                 (LPWORD)(lpStartVertex + 1),
                                                 D3DPT_TRIANGLEFAN,
                                                 dwNumIndices));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount + 2;
            // Make sure the pFanVtx pointer is DWORD aligned:
            //                                             (pFanVtx +3) % 4
            PUINT8 pFanVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) +
                                       sizeof(D3DHAL_DP2TRIANGLEFAN_IMM) + 3) & ~3);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not. Only the dwFVF is interesting
            // so the rest of the stuff is NULL/0
            pCtx->SavePrimitiveData( dwFvf,
                                     NULL,
                                     0,
                                     D3DPT_TRIANGLEFAN,
                                     0,
                                     0 );


            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_TRIANGLEFAN_IMM" );

            if (bWireframe)
            {
                // Read edge flags
                UINT32 dwEdgeFlags =
                    ((LPD3DHAL_DP2TRIANGLEFAN_IMM)(pCmd + 1))->dwEdgeFlags;
                HR_RET(DoDrawOneEdgeFlagTriangleFan(pCtx,
                                                    dwStride,
                                                    pFanVtx,
                                                    vertexCount,
                                                    dwEdgeFlags));
            }
            else
            {
                HR_RET(DoDrawOnePrimitive(pCtx,
                                          dwStride,
                                          pFanVtx,
                                          D3DPT_TRIANGLEFAN,
                                          vertexCount));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pFanVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_LINELIST_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount * 2;
            // Make sure the pLineVtx pointer is DWORD aligned:
            // (pLineVtx +3) % 4
            PUINT8 pLineVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) + 3) & ~3);

            // Save all the DP2 data passed, irregardless whether it is
            // already transformed or not. Only the dwFVF is interesting
            // so the rest of the stuff is NULL/0
            pCtx->SavePrimitiveData( dwFvf,
                                     NULL,
                                     0,
                                     D3DPT_LINELIST,
                                     0,
                                     0 );



            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_LINELIST_IMM" );

            HR_RET(DoDrawOnePrimitive(pCtx,
                                      dwStride,
                                      pLineVtx,
                                      D3DPT_LINELIST,
                                      vertexCount));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pLineVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_ZRANGE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetZRange(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2ZRANGE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETMATERIAL:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetMaterial(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETLIGHT:
        {
            DWORD dwSLStride = 0;
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetLight(pCtx, pCmd,
                                                          &dwSLStride));
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCmd  + dwSLStride);
        }
        break;
    case D3DDP2OP_CREATELIGHT:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2CreateLight(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2CREATELIGHT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETTRANSFORM:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetTransform(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_EXT:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetExtention(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2EXT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETRENDERTARGET:
        {
            HR_RET(pCtx->Dp2SetRenderTarget(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLEAR:
        {
            HR_RET(pCtx->Clear(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                sizeof(D3DHAL_DP2CLEAR) + (pCmd->wStateCount - 1) * sizeof(RECT));
        }
        break;
    case D3DDP2OP_SETCLIPPLANE:
        {
            HR_RET(pCtx->pStateSetFuncTbl->pfnDp2SetClipPlane(pCtx, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2SETCLIPPLANE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    default :
        hr = D3DParseUnknownCommand((LPVOID)pCmd, (LPVOID*)ppCmd);
        break;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// DoDrawOnePrimitive
//
// Draw one list of primitives. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOnePrimitive(ReferenceRasterizer *pCtx,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch (PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            pCtx->DrawPoint(pVtx);
            pVtx += FvfStride;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pCtx->DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;

            // Disable last-pixel setting for shared verties and store prestate.
            pCtx->StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pVtx += FvfStride;
                pV1 = pVtx;
                pCtx->DrawLine(pV0, pV1);
            }

            // Restore last-pixel setting.
            pCtx->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride;
                pCtx->DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;
            pCtx->DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                pCtx->DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                pCtx->DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx;
            pVtx += FvfStride;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += FvfStride;
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx;
                pVtx += FvfStride;
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneIndexedPrimitive
//
// Draw one list of indexed primitives. It's called by
// RastDrawOneIndexedPrimitive.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(ReferenceRasterizer *pCtx,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch(PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pCtx->DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pCtx->DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            pCtx->StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            pCtx->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride * (*puIndices);
                pCtx->DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);
            pCtx->DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx + FvfStride * (*puIndices++);
            // Preload initial pV0.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                pCtx->DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(ReferenceRasterizer *pCtx,
                             UINT16 FvfStride,
                             PUINT8 pVtx,
                             UINT cVertices,
                             UINT32 dwEdgeFlags)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    pV2 = pVtx;
    pVtx += FvfStride;
    pV0 = pVtx;
    pVtx += FvfStride;
    pV1 = pVtx;
    pVtx += FvfStride;
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        pCtx->DrawTriangle(pV0, pV1, pV2, wFlags);
        return D3D_OK;
    }
    pCtx->DrawTriangle(pV0, pV1, pV2, wFlags);
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = pVtx;
        pVtx += FvfStride;
        if(dwEdgeFlags & dwMask)
        {
            pCtx->DrawTriangle(pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1);
        }
        else
        {
            pCtx->DrawTriangle(pV0, pV1, pV2, 0);
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = pVtx;
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    pCtx->DrawTriangle(pV0, pV1, pV2, wFlags);

    return D3D_OK;
}

#define DDS_LCL(x) ((LPDDRAWI_DDRAWSURFACE_INT)(x))->lpLcl

//----------------------------------------------------------------------------
//
// RendPoint
//
// Draw lists of points. Called by RastRenderPrimitive() for drawing points.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendPoints(ReferenceRasterizer *pCtx,
             LPD3DINSTRUCTION pIns,
             LPD3DTLVERTEX pVtx,
             LPD3DPOINT pPt)
{
    INT i;
    LPD3DTLVERTEX pV;

    for (i = pIns->wCount; i > 0; i--)
    {
        INT iPts;
        for (iPts = pPt->wCount, pV = pVtx + pPt->wFirst;
             iPts > 0;
             iPts --, pV ++)
        {
            HRESULT hr;
            pCtx->DrawPoint((PUINT8)pV);
        }
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendLine
//
// Draw a list of lines. Called by RastRenderPrimitive() for drawing lines.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendLines(ReferenceRasterizer *pCtx,
            LPD3DINSTRUCTION pIns,
            LPD3DTLVERTEX pVtx,
            LPD3DLINE pLine)
{
    INT i;
    LPD3DTLVERTEX pV0, pV1;

    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pLine->v1;
        pV1 = pVtx + pLine->v2;
        pLine = (LPD3DLINE)((PINT8)pLine + pIns->bSize);
        pCtx->DrawLine((PUINT8)pV0, (PUINT8)pV1);
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendTriangle
//
// Draw a list of triangles. Called by RastRenderPrimitive() for drawing
// triangles.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendTriangles(ReferenceRasterizer *pCtx,
                LPD3DINSTRUCTION pIns,
                LPD3DTLVERTEX pVtx,
                LPD3DTRIANGLE pTri)
{
    LPD3DTLVERTEX pV0, pV1, pV2;
    INT i;
    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pTri->v1;
        pV1 = pVtx + pTri->v2;
        pV2 = pVtx + pTri->v3;
        pCtx->DrawTriangle((PUINT8)pV0, (PUINT8)pV1, 
                           (PUINT8)pV2, pTri->wFlags);
        pTri = (LPD3DTRIANGLE)((PINT8)pTri + pIns->bSize);
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\primfns.hpp ===
//-----------------------------------------------------------------------------
//
// Primitive functions for REFRast.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------
#ifndef __PRIMFNS_HPP_
#define __PRIMFNS_HPP_

#endif //__PRIMFNS_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\primfns.cpp ===
//----------------------------------------------------------------------------
//
// primfns.cpp
//
// Primitive functions for RAMP/RGB/REF.
//
// Copyright (C) Microsoft Corporation, 1998.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

extern HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast);
extern void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast);
extern HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast);
extern void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast);

HRESULT WrapDp2SetViewport( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetViewport(pCmd);
}

HRESULT WrapDp2SetWRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetWRange(pCmd);
}

HRESULT WrapDp2SetZRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetZRange(pCmd);
}

HRESULT WrapDp2SetRenderStates( ReferenceRasterizer *pRefRast,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefRast->Dp2SetRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2SetTextureStageState( ReferenceRasterizer *pRefRast, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2SetMaterial ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetMaterial(pCmd);
}

HRESULT WrapDp2SetLight( ReferenceRasterizer *pRefRast,
                         LPD3DHAL_DP2COMMAND pCmd,
                         LPDWORD pdwStride )
{
    return pRefRast->Dp2SetLight(pCmd, pdwStride);
}

HRESULT WrapDp2CreateLight ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2CreateLight(pCmd);
}

HRESULT WrapDp2SetTransform( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetTransform(pCmd);
}

HRESULT WrapDp2SetExtention( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetExtention(pCmd);
}

HRESULT WrapDp2SetClipPlane( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2SetClipPlane(pCmd);
}

HRESULT WrapDp2RecViewport( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecViewport(pCmd);
}

HRESULT WrapDp2RecWRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecWRange(pCmd);
}

HRESULT WrapDp2RecZRange  ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecZRange(pCmd);
}

HRESULT WrapDp2RecRenderStates( ReferenceRasterizer *pRefRast,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefRast->Dp2RecRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2RecTextureStageState( ReferenceRasterizer *pRefRast, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2RecMaterial ( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecMaterial(pCmd);
}

HRESULT WrapDp2RecSetLight ( ReferenceRasterizer *pRefRast,
                             LPD3DHAL_DP2COMMAND pCmd,
                             LPDWORD pdwStride)
{
    return pRefRast->Dp2RecSetLight(pCmd, pdwStride);
}

HRESULT WrapDp2RecCreateLight( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecCreateLight(pCmd);
}

HRESULT WrapDp2RecTransform( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecTransform(pCmd);
}

HRESULT WrapDp2RecExtention( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecExtention(pCmd);
}

HRESULT WrapDp2RecClipPlane( ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefRast->Dp2RecClipPlane(pCmd);
}

static REF_STATESETFUNCTIONTBL StateRecFunctions =
{
    sizeof(REF_STATESETFUNCTIONTBL),
    WrapDp2RecRenderStates,
    WrapDp2RecTextureStageState,
    WrapDp2RecViewport,
    WrapDp2RecWRange,
    WrapDp2RecMaterial,
    WrapDp2RecZRange,
    WrapDp2RecSetLight,
    WrapDp2RecCreateLight,
    WrapDp2RecTransform,
    WrapDp2RecExtention,
    WrapDp2RecClipPlane
};

static REF_STATESETFUNCTIONTBL StateSetFunctions =
{
    sizeof(REF_STATESETFUNCTIONTBL),
    WrapDp2SetRenderStates,
    WrapDp2SetTextureStageState,
    WrapDp2SetViewport,
    WrapDp2SetWRange,
    WrapDp2SetMaterial,
    WrapDp2SetZRange,
    WrapDp2SetLight,
    WrapDp2CreateLight,
    WrapDp2SetTransform,
    WrapDp2SetExtention,
    WrapDp2SetClipPlane
};


void
ReferenceRasterizer::StoreLastPixelState(BOOL bStore)
{
    if (bStore)
    {
        m_LastState = GetRenderState()[D3DRENDERSTATE_LASTPIXEL];
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, 0);
    }
    else
    {
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, m_LastState);
    }
}

void
ReferenceRasterizer::SetRecStateFunctions(void)
{
    pStateSetFuncTbl = &StateRecFunctions;
}

void
ReferenceRasterizer::SetSetStateFunctions(void)
{
    pStateSetFuncTbl = &StateSetFunctions;
}

HRESULT
ReferenceRasterizer::Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Check for overrides
        if (IS_OVERRIDE(type))
        {
            UINT32 override = GET_OVERRIDE(type);

            if (pRenderState->dwState)
                STATESET_SET(m_renderstate_override, override);
            else
                STATESET_CLEAR(m_renderstate_override, override);
            continue;
        }

        if (STATESET_ISSET(m_renderstate_override, type))
            continue;


        // Set the runtime copy (if necessary)
        if (NULL != lpdwRuntimeRStates)
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

        // Set the state
        this->SetRenderState(pRenderState->RenderState,
                                 pRenderState->dwState);
    }

    return hr;
}

HRESULT
ReferenceRasterizer::Dp2SetTextureStageState(DWORD dwFvf,
                                          LPD3DHAL_DP2COMMAND pCmd )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2TEXTURESTAGESTATE  *pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);

    //
    // The textures are already locked, unlock them
    //
    if (TexturesAreLocked())
    {
        RefRastUnlockTexture(this);
    }

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        this->SetTextureStageState(pTexStageState->wStage,
                                   pTexStageState->TSState,
                                   pTexStageState->dwValue);
    }

    //
    // We didnt unset this bool, hence lock the textures back again
    //
    if (TexturesAreLocked())
    {
        HR_RET(RefRastLockTexture(this));
    }

    return hr;
}

HRESULT
ReferenceRasterizer::Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2VIEWPORTINFO pVpt;

    // Keep only the last viewport notification
    pVpt = (D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    m_Viewport.dwX = pVpt->dwX;
    m_Viewport.dwY = pVpt->dwY;
    m_Viewport.dwWidth = pVpt->dwWidth;
    m_Viewport.dwHeight = pVpt->dwHeight;
    m_dwDirtyFlags |= RRPV_DIRTY_VIEWRECT;

    // get render target; update it; put it back
    RRRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_Clip.left   = pVpt->dwX;
    pRendTgt->m_Clip.top    = pVpt->dwY;
    pRendTgt->m_Clip.right  = pVpt->dwX + pVpt->dwWidth - 1;
    pRendTgt->m_Clip.bottom = pVpt->dwY + pVpt->dwHeight - 1;
    this->SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2WINFO pWInfo;

    // Keep only the last viewport notification
    pWInfo = (D3DHAL_DP2WINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // get render target; update it; put it back
    RRRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_fWRange[0]  = pWInfo->dvWNear;
    pRendTgt->m_fWRange[1]  = pWInfo->dvWFar;
    this->SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    // Keep only the last viewport notification
    pZRange = (D3DHAL_DP2ZRANGE *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    m_Viewport.dvMinZ = pZRange->dvMinZ;
    m_Viewport.dvMaxZ = pZRange->dvMaxZ;
    m_dwDirtyFlags |= RRPV_DIRTY_ZRANGE;

    return D3D_OK;
}


HRESULT
ReferenceRasterizer::Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    // Keep only the last material notification
    pSetMat = (D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + (pCmd->wStateCount - 1);

    m_Material = *(D3DMATERIAL7 *)pSetMat;
    m_dwDirtyFlags |= RRPV_DIRTY_MATERIAL;

    return D3D_OK;
}


HRESULT
ReferenceRasterizer::Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumCreateLight = pCmd->wStateCount;
    LPD3DHAL_DP2CREATELIGHT pCreateLight = (LPD3DHAL_DP2CREATELIGHT)(pCmd + 1);
    HRESULT hr = D3D_OK;

    for (int i = 0; i < wNumCreateLight; i++, pCreateLight++)
    {
        // If the index is not already allocated, grow the light array
        // by REF_LIGHTARRAY_GROWTH_SIZE
        if (pCreateLight->dwIndex >= m_dwLightArraySize)
        {
            HR_RET(GrowLightArray(pCreateLight->dwIndex));
        }
    }

    return hr;
}

#define ARRAYGROW_DELTA     32 // Should be a power of 2

HRESULT
ReferenceRasterizer::GrowLightArray(const DWORD dwIndex)
{
    // Allocate a few extra in anticipation of more light being used in the
    // future
    DWORD dwNewArraySize = dwIndex+16;
    RRLight *pTmpActiveLights = NULL;
    RRLight *pTmpLightArray = new RRLight[dwNewArraySize];
    if (pTmpLightArray == NULL)
        return DDERR_OUTOFMEMORY;

    // Save all the created lights
    for (DWORD i=0; i<m_dwLightArraySize; i++)
    {
        // If it is a valid, i.e. a light that has been set,
        // then save it in the new array
        pTmpLightArray[i] = m_pLightArray[i];

        // If the light is enabled, update the ActiveList pointer
        if (m_pLightArray[i].IsEnabled())
        {
            pTmpLightArray[i].m_Next = pTmpActiveLights;
            pTmpActiveLights = &pTmpLightArray[i];
        }
    }
    delete m_pLightArray;
    m_lighting.pActiveLights = pTmpActiveLights;
    m_pLightArray = pTmpLightArray;
    m_dwLightArraySize = dwNewArraySize;
    return D3D_OK;
}


HRESULT
ReferenceRasterizer::Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd,
                                 LPDWORD pdwStride)
{

    HRESULT hr = D3D_OK;
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT( pdwStride != NULL, "pdwStride is Null" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);
    D3DLIGHT7 *pLightData = NULL;

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex = pSetLight->dwIndex;

        // Assert that create was not called here
        _ASSERTf(dwIndex < m_dwLightArraySize,
                ( "Create was not called prior to the SetLight for light %d",
                 dwIndex ));

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            m_pLightArray[dwIndex].Enable(&m_lighting.pActiveLights);
            m_dwDirtyFlags |= RRPV_DIRTY_SETLIGHT;
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            m_pLightArray[dwIndex].Disable(&m_lighting.pActiveLights);
            break;
        case D3DHAL_SETLIGHT_DATA:
            pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
            dwStride += sizeof(D3DLIGHT7);
            HR_RET(m_pLightArray[pSetLight->dwIndex].SetLight(pLightData));
            m_dwDirtyFlags |= RRPV_DIRTY_SETLIGHT;
            break;
        default:
            DPFM(0,TNL,("Unknown SetLight command"));
            hr = DDERR_INVALIDPARAMS;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return hr;
}


HRESULT
ReferenceRasterizer::Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumXfrms = pCmd->wStateCount;
    D3DHAL_DP2SETTRANSFORM *pSetXfrm = (D3DHAL_DP2SETTRANSFORM*)(pCmd + 1);

    for (int i = 0; i < (int) wNumXfrms; i++, pSetXfrm++)
    {
        this->SetXfrm( pSetXfrm->xfrmType, &pSetXfrm->matrix);
    }

    return D3D_OK;
}

static D3DMATRIX matIdent =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

void
ReferenceRasterizer::SetXfrm(D3DTRANSFORMSTATETYPE xfrmType, D3DMATRIX *pMat)
{
    // ATTENTION is there a define for 0x80000000?
    BOOL bSetIdentity = (xfrmType & 0x80000000) != 0;
    DWORD dwxfrmType = (DWORD)xfrmType & (~0x80000000);
    switch (dwxfrmType)
    {
    case D3DTRANSFORMSTATE_WORLD:
        memcpy(&(m_xfmWorld[0]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLDXFM;
        break;
    case D3DTRANSFORMSTATE_VIEW:
        memcpy(&m_xfmView, pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_VIEWXFM;
        break;
    case D3DTRANSFORMSTATE_PROJECTION:
        memcpy(&m_xfmProj, pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_PROJXFM;
        break;
    case D3DTRANSFORMSTATE_WORLD1:
        memcpy(&(m_xfmWorld[1]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLD1XFM;
        break;
    case D3DTRANSFORMSTATE_WORLD2:
        memcpy(&(m_xfmWorld[2]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLD2XFM;
        break;
    case D3DTRANSFORMSTATE_WORLD3:
        memcpy(&(m_xfmWorld[3]), pMat, sizeof(D3DMATRIX));
        m_dwDirtyFlags |= RRPV_DIRTY_WORLD3XFM;
        break;
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        {
            DWORD dwStage = xfrmType - D3DTRANSFORMSTATE_TEXTURE0;
            if (bSetIdentity)
            {
                memcpy(&m_TextureStageState[dwStage].m_dwVal[D3DTSSI_MATRIX], &matIdent, sizeof(D3DMATRIX));
            }
            else
            {
                memcpy(&m_TextureStageState[dwStage].m_dwVal[D3DTSSI_MATRIX], pMat, sizeof(D3DMATRIX));
            }
        }
        break;
    default:
        DPFM(0,TNL,("Ignoring unknown transform type"));
    }
}


HRESULT
ReferenceRasterizer::Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumClipPlanes = pCmd->wStateCount;
    LPD3DHAL_DP2SETCLIPPLANE pSetClipPlane =
        (LPD3DHAL_DP2SETCLIPPLANE)(pCmd + 1);

    for (int i = 0; i < (int) wNumClipPlanes; i++, pSetClipPlane++)
    {
        _ASSERTf( pSetClipPlane->dwIndex < RRMAX_USER_CLIPPLANES,
                 ("Refrast does not support %d clip planes",
                  pSetClipPlane->dwIndex ) );

        memcpy( &m_userClipPlanes[pSetClipPlane->dwIndex],
                pSetClipPlane->plane, sizeof(RRVECTOR4) );
    }
    m_dwDirtyFlags |= RRPV_DIRTY_CLIPPLANES;

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2RENDERSTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
ReferenceRasterizer::Dp2RecTextureStageState(DWORD dwFvf,
                                          LPD3DHAL_DP2COMMAND pCmd )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
ReferenceRasterizer::Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2VIEWPORTINFO));
}

HRESULT
ReferenceRasterizer::Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2WINFO));
}

HRESULT
ReferenceRasterizer::Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2ZRANGE));
}


HRESULT
ReferenceRasterizer::Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2SETMATERIAL));
}


HRESULT
ReferenceRasterizer::Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2CREATELIGHT);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
ReferenceRasterizer::Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd,
                                    LPDWORD pdwStride)
{
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT(pdwStride != NULL, "pdwStride is NULL" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            break;
        case D3DHAL_SETLIGHT_DATA:
            dwStride += sizeof(D3DLIGHT7);
            break;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return RecordStates((PUINT8)pCmd, *pdwStride);
}


HRESULT
ReferenceRasterizer::Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETTRANSFORM);

    return RecordStates((PUINT8)pCmd, dwSize);
}


HRESULT
ReferenceRasterizer::Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
ReferenceRasterizer::Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETCLIPPLANE);

    return RecordStates((PUINT8)pCmd, dwSize);
}


//-----------------------------------------------------------------------------
//
// RecordStates - This function copies the state data into the internal stateset
// buffer. It assumes that the current state set has already been properly set
// up in BeginStateSet().
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::RecordStates(PUINT8 pData, DWORD dwSize)
{
    HRESULT ret;
    LPStateSetData pCurStateSets = m_pStateSets.CurrentItem();
    DWORD dwCurIdx = pCurStateSets->CurrentIndex();

    // Check if the buffer has enough space
    if ((ret = pCurStateSets->CheckAndGrow(dwCurIdx + dwSize,
                                            REF_STATESET_GROWDELTA)) != D3D_OK)
    {
        return ret;
    }
    // Copy the data and update the ptr.
    PUINT8 pDest = (PUINT8)&((*pCurStateSets)[dwCurIdx]);
    memcpy(pDest, pData, dwSize);
    pCurStateSets->SetCurrentIndex(dwCurIdx + dwSize);

    return D3D_OK;
}

HRESULT ReferenceRasterizer::RecordLastState(LPD3DHAL_DP2COMMAND pCmd,
                                             DWORD dwUnitSize)
{
    _ASSERT(pCmd->wStateCount != 0, "Number of states to record is zero" );
    if (pCmd->wStateCount == 1)
    {
        return RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND) + dwUnitSize);
    }
    else
    {
        HRESULT ret;
        WORD wCount = pCmd->wStateCount;
        pCmd->wStateCount = 1;
        ret = RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND));
        if (ret != D3D_OK)
        {
            return ret;
        }
        ret = RecordStates((PUINT8)(pCmd + 1) + dwUnitSize * (wCount - 1),
                            dwUnitSize);
        if (ret != D3D_OK)
        {
            return ret;
        }
        pCmd->wStateCount = wCount;
        return D3D_OK;
    }
}

HRESULT
ReferenceRasterizer::BeginStateSet(DWORD dwHandle)
{
    HRESULT ret;

    // Grow the array if no more space left
    if ((ret = m_pStateSets.CheckAndGrow(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    _ASSERT(m_pStateSets[dwHandle] == NULL, "pStateSets array is NULL" );

    // Create the new StateSet
    LPStateSetData pNewStateSet = new StateSetData;
    if (pNewStateSet == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }

    m_pStateSets.SetCurrentIndex(dwHandle);
    m_pStateSets.SetCurrentItem(pNewStateSet);

    // Switch to record mode
    SetRecStateFunctions();

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::EndStateSet(void)
{
    // Switch to execute mode
    SetSetStateFunctions();

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::ExecuteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if ((ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if (pStateSet == NULL)
    {
        return DDERR_INVALIDPARAMS;
    }

    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)&((*pStateSet)[0]);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd + pStateSet->CurrentIndex();

    // Loop through the data, update render states
    for (;;)
    {
        ret = DoDrawPrimitives2(this,
                                (UINT16)0,
                                (DWORD)0,
                                NULL,
                                0,
                                &pCmd,
                                NULL,
                                0);
        if (ret != D3D_OK)
        {
            return ret;
        }
        if ((UINT_PTR)pCmd >= CmdBoundary)
            break;
    }

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::DeleteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if ((ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    if (m_pStateSets[dwHandle] != NULL)
    {
        delete m_pStateSets[dwHandle];
        m_pStateSets[dwHandle] = NULL;
    }

    return D3D_OK;
}

HRESULT
ReferenceRasterizer::CaptureStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if ((ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK)
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if (pStateSet == NULL)
    {
        return DDERR_INVALIDPARAMS;
    }

    BYTE *p = &((*pStateSet)[0]);
    UINT_PTR pEnd = (UINT_PTR)(p + pStateSet->CurrentIndex());

    while((UINT_PTR)p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)p;
        p += sizeof(D3DHAL_DP2COMMAND);
        switch(pCmd->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2RENDERSTATE pData = (LPD3DHAL_DP2RENDERSTATE)p;
                    pData->dwState = GetRenderState()[pData->RenderState];
                    p += sizeof(D3DHAL_DP2RENDERSTATE);
                }
                break;
            }
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p += sizeof(D3DHAL_DP2SETLIGHT);
                    if(pData->dwIndex >= m_dwLightArraySize)
                    {
                        return D3DERR_LIGHT_SET_FAILED;
                    }
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                        if(!m_pLightArray[pData->dwIndex].IsEnabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                        break;
                    case D3DHAL_SETLIGHT_DISABLE:
                        if(m_pLightArray[pData->dwIndex].IsEnabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        m_pLightArray[pData->dwIndex].GetLight((LPD3DLIGHT7)p);
                        p += sizeof(D3DLIGHT7);
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                    *pData = m_Material;
                    p += sizeof(D3DHAL_DP2SETMATERIAL);
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                    switch(pData->xfrmType)
                    {
                    case D3DTRANSFORMSTATE_WORLD:
                        pData->matrix = m_xfmWorld[0];
                        break;
                    case D3DTRANSFORMSTATE_WORLD1:
                        pData->matrix = m_xfmWorld[1];
                        break;
                    case D3DTRANSFORMSTATE_WORLD2:
                        pData->matrix = m_xfmWorld[2];
                        break;
                    case D3DTRANSFORMSTATE_WORLD3:
                        pData->matrix = m_xfmWorld[3];
                        break;
                    case D3DTRANSFORMSTATE_VIEW:
                        pData->matrix = m_xfmView;
                        break;
                    case D3DTRANSFORMSTATE_PROJECTION:
                        pData->matrix = m_xfmProj;
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE0:
                    case D3DTRANSFORMSTATE_TEXTURE1:
                    case D3DTRANSFORMSTATE_TEXTURE2:
                    case D3DTRANSFORMSTATE_TEXTURE3:
                    case D3DTRANSFORMSTATE_TEXTURE4:
                    case D3DTRANSFORMSTATE_TEXTURE5:
                    case D3DTRANSFORMSTATE_TEXTURE6:
                    case D3DTRANSFORMSTATE_TEXTURE7:
                        pData->matrix = *((LPD3DMATRIX)&m_TextureStageState[pData->xfrmType - D3DTRANSFORMSTATE_TEXTURE0].m_dwVal[D3DTSSI_MATRIX]);
                        break;
                    }
                    p += sizeof(D3DHAL_DP2SETTRANSFORM);
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    pData->dwValue = m_TextureStageState[pData->wStage].m_dwVal[pData->TSState];
                    p += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    D3DVIEWPORT7 viewport;
                    LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                    lpVwpData->dwX      = m_Viewport.dwX;
                    lpVwpData->dwY      = m_Viewport.dwY;
                    lpVwpData->dwWidth  = m_Viewport.dwWidth;
                    lpVwpData->dwHeight = m_Viewport.dwHeight;
                    p += sizeof(D3DHAL_DP2VIEWPORTINFO);
                }
                break;
            }
        case D3DDP2OP_ZRANGE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                    pData->dvMinZ = m_Viewport.dvMinZ;
                    pData->dvMaxZ = m_Viewport.dvMaxZ;
                    p += sizeof(D3DHAL_DP2ZRANGE);
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                    *((LPRRVECTOR4)pData->plane) = m_userClipPlanes[pData->dwIndex];
                    p += sizeof(D3DHAL_DP2SETCLIPPLANE);
                }
                break;
            }
        default:
            _ASSERT(FALSE, "Ununderstood DP2 command in Capture");
        }
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// SetRenderState -
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetRenderState( DWORD dwState, DWORD dwValue )
{
    // check for range before continuing
    if ( dwState >= D3DHAL_MAX_RSTATES )
    {
        return;
    }

    // set value in internal object
    m_dwRenderState[dwState] = dwValue;

    // do special validation work for some render states
    switch ( dwState )
    {

    case D3DRENDERSTATE_ANTIALIAS:
        m_bFragmentProcessingEnabled =
            ( D3DANTIALIAS_SORTINDEPENDENT == dwValue );
        break;
    case D3DRENDERSTATE_LIGHTING:
        if (dwValue)
            m_dwTLState |= RRPV_DOLIGHTING;
        else
            m_dwTLState &= ~RRPV_DOLIGHTING;
        break;
    case D3DRENDERSTATE_CLIPPING:
        if (dwValue)
            m_dwTLState |=  RRPV_DOCLIPPING;
        else
            m_dwTLState &=  ~RRPV_DOCLIPPING;
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        {
            if (dwValue)
                m_dwTLState |=  RRPV_NORMALIZENORMALS;
            else
                m_dwTLState &=  ~RRPV_NORMALIZENORMALS;
        }
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        {
            if (dwValue)
                m_dwTLState |=  RRPV_LOCALVIEWER;
            else
                m_dwTLState &=  ~RRPV_LOCALVIEWER;
        }
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        {
            if (dwValue)
                m_dwTLState |= RRPV_DOSPECULAR;
            else
                m_dwTLState &= ~RRPV_DOSPECULAR;
        }
        break;
    case D3DRENDERSTATE_COLORVERTEX:
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
            m_dwDirtyFlags |= RRPV_DIRTY_COLORVTX;
        break;
    case D3DRENDERSTATE_FOGCOLOR:
        {
            m_lighting.fog_color = (D3DCOLOR) dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLESTART:
        {
            m_lighting.fog_start = *(D3DVALUE*)&dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEEND:
        {
            m_lighting.fog_end = *(D3DVALUE*)&dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        {
            m_lighting.fog_density = *(D3DVALUE*)&dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        {
            m_lighting.fog_mode = (int) dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            m_lighting.ambient_red   = D3DVAL(RGBA_GETRED(dwValue))/D3DVALUE(255);
            m_lighting.ambient_green = D3DVAL(RGBA_GETGREEN(dwValue))/D3DVALUE(255);
            m_lighting.ambient_blue  = D3DVAL(RGBA_GETBLUE(dwValue))/D3DVALUE(255);
            m_lighting.ambient_save  = dwValue;
            m_dwDirtyFlags |= RRPV_DIRTY_MATERIAL;
        }
        break;
    //
    // map legacy texture to multi-texture stage 0
    //
    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESS] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPMAPLODBIAS] = dwValue;
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_TextureStageState[0].m_dwVal[D3DTSS_BORDERCOLOR] = dwValue;
        break;
    case D3DRENDERSTATE_ANISOTROPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAXANISOTROPY] = dwValue;
        // fall thru to update filter state
    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        break;

    case D3DRENDERSTATE_TEXTUREHANDLE:
        // map thru to set handle for first stage
        SetTextureStageState( 0, D3DTSS_TEXTUREMAP, dwValue );
        break;

    //
    // map legacy WRAPU/V state through to controls for tex coord 0
    //
    case D3DRENDERSTATE_WRAPU:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_U : 0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_V : 0);
        break;

    //
    // Scene Capture
    //
    case D3DRENDERSTATE_SCENECAPTURE:
        if (dwValue)
            SceneCapture(D3DHAL_SCENE_CAPTURE_START);
        else
            SceneCapture(D3DHAL_SCENE_CAPTURE_END);
        break;

    case D3DRENDERSTATE_CLIPPLANEENABLE:
        m_dwDirtyFlags |= RRPV_DIRTY_CLIPPLANES;
        break;

#ifdef __POINTSPRITES
    case D3DRENDERSTATE_POINTSIZE:
        m_fPointSize = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTATTENUATION_A:
        m_fPointAttA = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTATTENUATION_B:
        m_fPointAttB = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTATTENUATION_C:
        m_fPointAttC = m_fRenderState[dwState];
        break;

    case D3DRENDERSTATE_POINTSIZEMIN:
        m_fPointSizeMin = m_fRenderState[dwState];
        break;
#endif //__POINTSPRITES
    }
}

extern DWORD __stdcall
RefRastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData);

HRESULT ReferenceRasterizer::Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd)
{
    D3DHAL_SETRENDERTARGETDATA SRTDataOld;
    LPD3DHAL_DP2SETRENDERTARGET pSRTData;
    BOOL bIsNew = FALSE;
    HRESULT hr;

    // Get new data by ignoring all but the last structure
    pSRTData = (D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Fill SRTDataOld with the info from the last SRTData struct
    // in the command
    DWORD handle = pSRTData->hRenderTarget;
    SRTDataOld.dwhContext = (ULONG_PTR)this;
    SRTDataOld.lpDDSLcl = GetDDSurfaceLocal(m_pDDLcl, handle, &bIsNew);
    if( SRTDataOld.lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
    {
        if (handle >= m_dwTexArrayLength)
        {
            HR_RET(GrowTexArray( handle ));
        }
        if (m_ppTextureArray[handle] == NULL)
        {
            if (TextureCreate(handle, &m_ppTextureArray[handle])
                == FALSE)
            {
                return DDERR_OUTOFMEMORY;
            }
            
            HR_RET(m_ppTextureArray[handle]->Initialize( 
                SRTDataOld.lpDDSLcl ));
        }
        else if( bIsNew )
        {
            HR_RET(m_ppTextureArray[handle]->Initialize( 
                SRTDataOld.lpDDSLcl ));
        }
    }
    
    if( pSRTData->hZBuffer )
    {
        bIsNew = FALSE;
        handle = pSRTData->hZBuffer;
        SRTDataOld.lpDDSZLcl = GetDDSurfaceLocal(m_pDDLcl, pSRTData->hZBuffer,
                                                 &bIsNew);
        if( SRTDataOld.lpDDSZLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        {
            if (handle >= m_dwTexArrayLength)
            {
                HR_RET(GrowTexArray( handle ));
            }
            if (m_ppTextureArray[handle] == NULL)
            {
                if (TextureCreate(handle, &m_ppTextureArray[handle])
                    == FALSE)
                {
                    return DDERR_OUTOFMEMORY;
                }
                
                HR_RET(m_ppTextureArray[handle]->Initialize( 
                    SRTDataOld.lpDDSZLcl ));
            }
            else if( bIsNew )
            {
                HR_RET(m_ppTextureArray[handle]->Initialize( 
                    SRTDataOld.lpDDSZLcl ));
            }
        }
    }
    else
        SRTDataOld.lpDDSZLcl = NULL;

    // Need to unlock the current target, first
    RefRastUnlockTarget(this);

    // Call the old function
    if ((hr = RefRastSetRenderTarget(&SRTDataOld)) != DDHAL_DRIVER_HANDLED)
        return hr;

    // Lock the new render target
    RefRastLockTarget(this);

    return SRTDataOld.ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>

#include <ddraw.h>
#include <ddrawi.h>

#include <d3d.h>
#include "d3dhal.h"
#include "halprov.h"

#include "d3dref.h"
#include "refrast.hpp"     
//@@BEGIN_MSINTERNAL
#if 0
//@@END_MSINTERNAL
#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT
#include "EdgeFunc.hpp"     // edge function processing
#include "AttrFunc.hpp"     // attribute function processing
#include "refrasti.hpp"     // private interfaces
#include "clipping.hpp"
typedef unsigned long UINT_PTR, *PUINT_PTR; 
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "refprov.hpp"
#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\sources.inc ===
TARGETNAME=refdrv
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES =             \
    ..\refprov.cpp    \
    ..\refif.cpp      \
    ..\dprim2.cpp     \
    ..\primfns.cpp    \
    ..\drawprim.cpp   \
    ..\rralloc.cpp    \
    ..\init.c

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)


PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\refprov.hpp ===
//----------------------------------------------------------------------------
//
// refprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFPROV_HPP_
#define _REFPROV_HPP_

//----------------------------------------------------------------------------
//
// RefHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class RefHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// RefRastHalProvider
//
// Specific provider for the reference rasterizer.
//
//----------------------------------------------------------------------------

class RefRastHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider
//
// Specific provider for the null device.
//
//----------------------------------------------------------------------------

class NullDeviceHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _REFPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\rralloc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrmem.cpp
//
// Direct3D Reference Implementation - Memory functions
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//
// RRAlloc method implementation
//
///////////////////////////////////////////////////////////////////////////////
void *
RRAlloc::operator new(size_t s)
{
    void* pMem = MEMALLOC( s );
    _ASSERTa( NULL != pMem, "malloc failure", return NULL; );
    return pMem;
}

void 
RRAlloc::operator delete(void* p, size_t)
{
    MEMFREE( p );
}


//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\refif.hpp ===
//----------------------------------------------------------------------------
//
// refif.hpp
//
// Refrast front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFIF_HPP_
#define _REFIF_HPP_

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32


// Lock surfaces before rendering
inline HRESULT LockSurface(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, LPVOID *ppData)
{
    if (pDDSLcl)
    {
        if (!VIDEO_MEMORY(pDDSLcl))
        {
            if (SURFACE_LOCKED(pDDSLcl))
            return DDERR_SURFACEBUSY;
            *ppData = (LPVOID)SURFACE_MEMORY(pDDSLcl);
            return DD_OK;
        }
        else
        {
            HRESULT ddrval;
            do
            {
                ddrval = DDInternalLock(pDDSLcl, ppData);
            } while (ddrval == DDERR_WASSTILLDRAWING);
            return ddrval;
        }
    }
    return DD_OK;
}
// Unlock surfaces after rendering
inline void UnlockSurface(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    if (pDDSLcl && VIDEO_MEMORY(pDDSLcl))
    {
        DDInternalUnlock(pDDSLcl);
    }
}

HRESULT FASTCALL
DoRendPoints(ReferenceRasterizer * pCtx,
             LPD3DINSTRUCTION pIns,
             LPD3DTLVERTEX pVtx,
             LPD3DPOINT pPt);
HRESULT FASTCALL
DoRendLines(ReferenceRasterizer * pCtx,
            LPD3DINSTRUCTION pIns,
            LPD3DTLVERTEX pVtx,
            LPD3DLINE pLine);
HRESULT FASTCALL
DoRendTriangles(ReferenceRasterizer *pCtx,
                LPD3DINSTRUCTION pIns,
                LPD3DTLVERTEX pVtx,
                LPD3DTRIANGLE pTri);
HRESULT FASTCALL
DoDrawPrimitives2(ReferenceRasterizer *pCtx,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  DWORD dwNumVertices,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe = FALSE
    );



// Macros to check if a pointer is valid
#if DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        DPFM(0, DRV, ("in %s, data pointer = NULL", (caller_name)));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        DPFM(0, DRV, ("in %s, dwhContext = NULL", (caller_name)));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate ReferenceRasterizer. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefRast, ReferenceRasterizer*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  RRSurfaceType *pFmt);

BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                             INT16 ivSize, INT16 ivShift);
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize);

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast);
HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast);

// DXT block size array
extern int g_DXTBlkSize[];

#endif // #ifndef _REFIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\refif.cpp ===
//----------------------------------------------------------------------------
//
// refrastfn.cpp
//
// Reference rasterizer callback functions for D3DIM.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

// Primitive functions
#include "primfns.hpp"

#define MAX_CLIPPING_PLANES     12
#define MAX_CLIP_VERTICES       (( 2 * MAX_CLIPPING_PLANES ) + 3 )
#define MAX_VERTEX_COUNT 2048
#define BASE_VERTEX_COUNT (MAX_VERTEX_COUNT - MAX_CLIP_VERTICES)

HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast);
HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast);
void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast);

//----------------------------------------------------------------------------
//
// Stiches together device descs
//
//----------------------------------------------------------------------------
void
D3DDeviceDescConvert(LPD3DDEVICEDESC7 lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt)
{
    if(lpV1!=NULL)
    {
        lpOut->dwDevCaps = lpV1->dwDevCaps;
        lpOut->dpcLineCaps = lpV1->dpcLineCaps;
        lpOut->dpcTriCaps = lpV1->dpcTriCaps;
        lpOut->dwDeviceRenderBitDepth = lpV1->dwDeviceRenderBitDepth;
        lpOut->dwDeviceZBufferBitDepth = lpV1->dwDeviceZBufferBitDepth;
    }

    if (lpExt)
    {
        // DX5
        lpOut->dwMinTextureWidth = lpExt->dwMinTextureWidth;
        lpOut->dwMaxTextureWidth = lpExt->dwMaxTextureWidth;
        lpOut->dwMinTextureHeight = lpExt->dwMinTextureHeight;
        lpOut->dwMaxTextureHeight = lpExt->dwMaxTextureHeight;

        // DX6
        lpOut->dwMaxTextureRepeat = lpExt->dwMaxTextureRepeat;
        lpOut->dwMaxTextureAspectRatio = lpExt->dwMaxTextureAspectRatio;
        lpOut->dwMaxAnisotropy = lpExt->dwMaxAnisotropy;
        lpOut->dvGuardBandLeft = lpExt->dvGuardBandLeft;
        lpOut->dvGuardBandTop = lpExt->dvGuardBandTop;
        lpOut->dvGuardBandRight = lpExt->dvGuardBandRight;
        lpOut->dvGuardBandBottom = lpExt->dvGuardBandBottom;
        lpOut->dvExtentsAdjust = lpExt->dvExtentsAdjust;
        lpOut->dwStencilCaps = lpExt->dwStencilCaps;
        lpOut->dwFVFCaps = lpExt->dwFVFCaps;
        lpOut->dwTextureOpCaps = lpExt->dwTextureOpCaps;
        lpOut->wMaxTextureBlendStages = lpExt->wMaxTextureBlendStages;
        lpOut->wMaxSimultaneousTextures = lpExt->wMaxSimultaneousTextures;

        // DX7
        lpOut->dwMaxActiveLights = lpExt->dwMaxActiveLights;
        lpOut->dvMaxVertexW = lpExt->dvMaxVertexW;
        lpOut->wMaxUserClipPlanes = lpExt->wMaxUserClipPlanes;
        lpOut->wMaxVertexBlendMatrices = lpExt->wMaxVertexBlendMatrices;
        lpOut->dwVertexProcessingCaps = lpExt->dwVertexProcessingCaps;
        lpOut->dwReserved1 = lpExt->dwReserved1;
        lpOut->dwReserved2 = lpExt->dwReserved2;
        lpOut->dwReserved3 = lpExt->dwReserved3;
        lpOut->dwReserved4 = lpExt->dwReserved4;
    }
}

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to RRSurfaceType.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt, RRSurfaceType *pFmt)
{
    if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = RR_STYPE_Z16S0; break;
        case 0xFFFFFF00:
            if (pDdPixFmt->dwStencilBitMask == 0x000000FF)
            {
                *pFmt = RR_STYPE_Z24S8;
            }
            else
            {
                *pFmt = RR_STYPE_Z24S4;
            }
            break;
        case 0x00FFFFFF:
            if (pDdPixFmt->dwStencilBitMask == 0xFF000000)
            {
                *pFmt = RR_STYPE_S8Z24;
            }
            else
            {
                *pFmt = RR_STYPE_S4Z24;
            }
            break;
        case 0x0000FFFE: *pFmt = RR_STYPE_Z15S1; break;
        case 0x00007FFF: *pFmt = RR_STYPE_S1Z15; break;
        case 0xFFFFFFFF: *pFmt = RR_STYPE_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 24:
                *pFmt = RR_STYPE_U8V8L8;
                break;
            case 16:
                *pFmt = RR_STYPE_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = RR_STYPE_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        *pFmt = RR_STYPE_PALETTE8;
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = RR_STYPE_PALETTE4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = RR_STYPE_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = RR_STYPE_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = RR_STYPE_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = RR_STYPE_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = RR_STYPE_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = RR_STYPE_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = RR_STYPE_DXT5;
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = RR_STYPE_B8G8R8X8;
                break;
            case 24:
                *pFmt = RR_STYPE_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = RR_STYPE_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RR_STYPE_B5G5R5A1;
            }
            else
            {
                *pFmt = RR_STYPE_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = RR_STYPE_B5G5R5;
            break;
        case 0xff0:
            *pFmt = RR_STYPE_B4G4R4;
            break;
        case 0xfff0:
            *pFmt = RR_STYPE_B4G4R4A4;
            break;
        case 0xff:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RR_STYPE_L4A4;
            }
            else
            {
                *pFmt = RR_STYPE_L8;
            }
            break;
        case 0xffff:
            *pFmt = RR_STYPE_L8A8;
            break;
        case 0xfc:
            *pFmt = RR_STYPE_B2G3R3;
            break;
        case 0xfffc:
            *pFmt = RR_STYPE_B2G3R3A8;
            break;
        default:
            *pFmt = RR_STYPE_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidTextureSize
//
// checks for power of two texture size
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                 INT16 ivSize, INT16 ivShift)
{
    if (iuSize == 1)
    {
        if (ivSize == 1)
        {
            return TRUE;
        }
        else
        {
            return !(ivSize & (~(1 << ivShift)));
        }
    }
    else
    {
        if (ivSize == 1)
        {
            return !(iuSize & (~(1 << iuShift)));
        }
        else
        {
            return (!(iuSize & (~(1 << iuShift)))
                    && !(iuSize & (~(1 << iuShift))));
        }
    }
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}


//----------------------------------------------------------------------------
//
// RefRastLockTarget
//
// Lock current RenderTarget.
//
//----------------------------------------------------------------------------
HRESULT
RefRastLockTarget(ReferenceRasterizer *pRefRast)
{
    HRESULT hr;
    RRRenderTarget *pRrTarget;

    pRrTarget = pRefRast->GetRenderTarget();

    HR_RET(LockSurface(pRrTarget->m_pDDSLcl, (LPVOID*)&(pRrTarget->m_pColorBufBits)));
    if (pRrTarget->m_pDDSZLcl)
    {
        HR_RET(LockSurface(pRrTarget->m_pDDSZLcl,
                         (LPVOID*)&(pRrTarget->m_pDepthBufBits)));
    }
    else
    {
        pRrTarget->m_pDepthBufBits = NULL;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastUnlockTexture
//
// Unlock current RenderTarget.
//
//----------------------------------------------------------------------------
void
RefRastUnlockTarget(ReferenceRasterizer *pRefRast)
{
    RRRenderTarget *pRrTarget;

    pRrTarget = pRefRast->GetRenderTarget();

    UnlockSurface(pRrTarget->m_pDDSLcl);
    if (pRrTarget->m_pDDSZLcl)
    {
        UnlockSurface(pRrTarget->m_pDDSZLcl);
    }
}


//----------------------------------------------------------------------------
//
// RRTextureMapSetSizes
//
// Sets sizes, pitches, etc, based on the current iFirstSurf.
//
//----------------------------------------------------------------------------
static HRESULT RRTextureMapSetSizes( RRTexture *pRRTex, INT iFirstSurf, INT cEnvMap )
{
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = pRRTex->m_pDDSLcl[iFirstSurf];
    RRSurfaceType SurfType = pRRTex->m_SurfType;
    INT i, j;

    // Init texturemap.
    pRRTex->m_iWidth = DDSurf_Width( pDDSLcl );
    pRRTex->m_iHeight = DDSurf_Height( pDDSLcl );

    for ( j = 0; j < cEnvMap; j++ )
    {
        if ((SurfType == RR_STYPE_DXT1) ||
            (SurfType == RR_STYPE_DXT2) ||
            (SurfType == RR_STYPE_DXT3) ||
            (SurfType == RR_STYPE_DXT4) ||
            (SurfType == RR_STYPE_DXT5))
        {
            // Note, here is the assumption that:
            // 1) width and height are reported correctly by the driver that
            //    created the surface
            // 2) The allocation of the memory is contiguous (as done by hel)
                pRRTex->m_iPitch[j] = ((pRRTex->m_iWidth+3)>>2) *
                g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
        }
        else
        {
                pRRTex->m_iPitch[j] = DDSurf_Pitch( pDDSLcl );
        }
    }

    // Check if the texture size is power of 2
    if (!ValidTextureSize((INT16)pRRTex->m_iWidth, (INT16)IntLog2(pRRTex->m_iWidth),
                          (INT16)pRRTex->m_iHeight, (INT16)IntLog2(pRRTex->m_iHeight)))
    {
        return DDERR_INVALIDPARAMS;
    }

    // Check for mipmap if any.
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = (INT16)pRRTex->m_iWidth, iPreSizeV = (INT16)pRRTex->m_iHeight;
    for ( i = iFirstSurf + cEnvMap; i <= pRRTex->m_cLOD*cEnvMap; i += cEnvMap)
    {
        for ( j = 0; j < cEnvMap; j++ )
        {
            pDDSLcl = pRRTex->m_pDDSLcl[i+j];
            if (NULL == pDDSLcl) continue;
            if ((SurfType == RR_STYPE_DXT1) ||
                (SurfType == RR_STYPE_DXT2) ||
                (SurfType == RR_STYPE_DXT3) ||
                (SurfType == RR_STYPE_DXT4) ||
                (SurfType == RR_STYPE_DXT5))
            {
                // Note, here is the assumption that:
                // 1) width and height are reported correctly by the driver that
                //    created the surface
                // 2) The allocation of the memory is contiguous (as done by hel)
                pRRTex->m_iPitch[i-iFirstSurf+j] =
                    ((DDSurf_Width( pDDSLcl )+3)>>2) *
                    g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
            }
            else
            {
                    pRRTex->m_iPitch[i-iFirstSurf+j] = DDSurf_Pitch( pDDSLcl );
            }

            if (j == 0)
            {
                // Check for invalid mipmap texture size
                if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width( pDDSLcl )) ||
                    !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height( pDDSLcl )))
                {
                    return DDERR_INVALIDPARAMS;
                }
            }
            iPreSizeU = (INT16)DDSurf_Width( pDDSLcl );
            iPreSizeV = (INT16)DDSurf_Height( pDDSLcl );
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastLockTexture
//
// Lock current texture surface before the texture bits are accessed.
//
//----------------------------------------------------------------------------
HRESULT
RefRastLockTexture(ReferenceRasterizer *pRefRast)
{
    INT i, j, k;
    RRTexture* pRRTex[D3DHAL_TSS_MAXSTAGES];
    D3DTEXTUREHANDLE phTex[D3DHAL_TSS_MAXSTAGES];
    HRESULT hr;
    int cActTex;

    if ((cActTex = pRefRast->GetCurrentTextureMaps(phTex, pRRTex)) == 0)
    {
        return D3D_OK;
    }

    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRRTex[j] ) continue;

        // Don't lock anything that is currently locked
        if ((pRRTex[j]->m_uFlags & RR_TEXTURE_LOCKED) == 0)
        {
            INT32 iMaxMipLevels = 0;
            if ( NULL != pRRTex[j]->m_pStageState )
            {
                iMaxMipLevels = pRRTex[j]->m_pStageState->m_dwVal[D3DTSS_MAXMIPLEVEL];
            }
            INT iFirstSurf = min(iMaxMipLevels, pRRTex[j]->m_cLODDDS);
            INT cEnvMap = (pRRTex[j]->m_uFlags & RR_TEXTURE_ENVMAP) ? (6) : (1);
            iFirstSurf *= cEnvMap;

            HR_RET(RRTextureMapSetSizes(pRRTex[j], iFirstSurf, cEnvMap));

            for (i = iFirstSurf; i <= pRRTex[j]->m_cLODDDS*cEnvMap; i += cEnvMap)
            {
                for ( k = 0; k < cEnvMap; k++ )
                {
                    hr = LockSurface(pRRTex[j]->m_pDDSLcl[i+k],
                                     (LPVOID*)&(pRRTex[j]->m_pTextureBits[i-iFirstSurf+k]));

                    if (hr != D3D_OK)
                    {
                        // Unlock any partial mipmap locks we've taken, as
                        // RastUnlock can only handle entire textures being
                        // locked or unlocked.
                            while (--i + k >= 0)
                        {
                                UnlockSurface(pRRTex[j]->m_pDDSLcl[i+k]);
                        }

                        // Make sure that i is signed and that the above
                        // loop exited properly.
                            _ASSERT(i+k < 0,
                                    "Unlock of partial mipmap locks failed" );

                        goto EH_Unlock;
                    }
                }
            }

            // Set the transparent bit and the transparent color with pDDS[0]
            LPDDRAWI_DDRAWSURFACE_LCL pLcl;
            pLcl = pRRTex[j]->m_pDDSLcl[0];
            if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
            {
                pRRTex[j]->m_uFlags |= RR_TEXTURE_HAS_CK;
                pRRTex[j]->m_dwColorKey = pLcl->ddckCKSrcBlt.dwColorSpaceLowValue;
            }
            else
            {
                pRRTex[j]->m_uFlags &= ~RR_TEXTURE_HAS_CK;
            }

            // set the empty face color with pDDS[0]
            // note that ddckCKDestOverlay is unioned with dwEmptyFaceColor, but
            // not in the internal structure
            pRRTex[j]->m_dwEmptyFaceColor = pLcl->ddckCKDestOverlay.dwColorSpaceLowValue;

            // Update palette
            if (pRRTex[j]->m_SurfType == RR_STYPE_PALETTE8 ||
                pRRTex[j]->m_SurfType == RR_STYPE_PALETTE4)
            {
                if (pLcl->lpDDPalette)
                {
                    LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
                    pRRTex[j]->m_pPalette = (DWORD*)pPal->lpColorTable;
                    if (pPal->dwFlags & DDRAWIPAL_ALPHA)
                    {
                        pRRTex[j]->m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
                    }
                }
            }

            pRRTex[j]->m_uFlags |= RR_TEXTURE_LOCKED;
        }
    }

    // validate texture internals
    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRRTex[j] ) continue;

        if ( !(pRRTex[j]->Validate()) )
        {
            hr = DDERR_INVALIDPARAMS;
            goto EH_Unlock;
        }
    }

    return D3D_OK;

EH_Unlock:
    // Unlock complete textures we've already locked.
    // RastUnlock will check the flags to figure
    // out which ones to unlock.
    RefRastUnlockTexture(pRefRast);

    return hr;
}

//----------------------------------------------------------------------------
//
// RefRastUnlockTexture
//
// Unlock texture surface after the texture bits are accessed.
//
//----------------------------------------------------------------------------
void
RefRastUnlockTexture(ReferenceRasterizer *pRefRast)
{
    INT i, j, k;
    RRTexture* pRRTex[D3DHAL_TSS_MAXSTAGES];
    D3DTEXTUREHANDLE phTex[D3DHAL_TSS_MAXSTAGES];
    int cActTex;

    if ((cActTex = pRefRast->GetCurrentTextureMaps(phTex, pRRTex)) == 0)
    {
        return ;
    }

    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRRTex[j] ) continue;

        // RastUnlock is used for cleanup in RastLock so it needs to
        // be able to handle partially locked mipmap chains.
        if (pRRTex[j]->m_uFlags & RR_TEXTURE_LOCKED)
        {
            INT32 iMaxMipLevels = 0;
            if ( NULL != pRRTex[j]->m_pStageState )
            {
                iMaxMipLevels = pRRTex[j]->m_pStageState->m_dwVal[D3DTSS_MAXMIPLEVEL];
            }
            INT iFirstSurf = min(iMaxMipLevels, pRRTex[j]->m_cLODDDS);
            INT cEnvMap = (pRRTex[j]->m_uFlags & RR_TEXTURE_ENVMAP) ? (6) : (1);
            iFirstSurf *= cEnvMap;

            for (i = iFirstSurf; i <= pRRTex[j]->m_cLODDDS*cEnvMap; i += cEnvMap)
            {
                for ( k = 0; k < cEnvMap; k++ )
                {
                    UnlockSurface(pRRTex[j]->m_pDDSLcl[i+k]);
                    pRRTex[j]->m_pTextureBits[i-iFirstSurf+k] = NULL;
                }
            }

            // Reset the flags
            pRRTex[j]->m_uFlags &= ~RR_TEXTURE_LOCKED;
            pRRTex[j]->m_uFlags &= ~RR_TEXTURE_HAS_CK;

            pRRTex[j]->Validate();
        }
    }
}

//----------------------------------------------------------------------------
//
// FillRRRenderTarget
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
FillRRRenderTarget(LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                   LPDDRAWI_DDRAWSURFACE_LCL pLclZ,
                   RRRenderTarget *pRrTarget)
{
    HRESULT hr;
    RRSurfaceType ColorFmt;
    RRSurfaceType ZFmt = RR_STYPE_NULL;

    // Release objects we hold pointers to
    if (pRrTarget->m_pDDSLcl)
    {
        pRrTarget->m_pDDSLcl = NULL;
    }
    if (pRrTarget->m_pDDSZLcl)
    {
        pRrTarget->m_pDDSZLcl = NULL;
    }

    HR_RET(FindOutSurfFormat(&DDSurf_PixFmt(pLclColor), &ColorFmt));

    if (NULL != pLclZ)
    {
        HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLclZ)), &ZFmt));
        pRrTarget->m_pDepthBufBits = (char *)SURFACE_MEMORY(pLclZ);
        pRrTarget->m_iDepthBufPitch = DDSurf_Pitch(pLclZ);
        pRrTarget->m_pDDSZLcl = pLclZ;
    }
    else
    {
        pRrTarget->m_pDepthBufBits = NULL;
        pRrTarget->m_iDepthBufPitch = 0;
        pRrTarget->m_pDDSZLcl = NULL;
    }

    pRrTarget->m_Clip.left = 0;
    pRrTarget->m_Clip.top = 0;
    pRrTarget->m_Clip.bottom = DDSurf_Height(pLclColor) - 1;
    pRrTarget->m_Clip.right = DDSurf_Width(pLclColor) - 1;
    pRrTarget->m_iWidth = DDSurf_Width(pLclColor);
    pRrTarget->m_iHeight = DDSurf_Height(pLclColor);
    pRrTarget->m_pColorBufBits = (char *)SURFACE_MEMORY(pLclColor);
    pRrTarget->m_iColorBufPitch = DDSurf_Pitch(pLclColor);
    pRrTarget->m_ColorSType = (RRSurfaceType)ColorFmt;
    pRrTarget->m_DepthSType = (RRSurfaceType)ZFmt;
    pRrTarget->m_pDDSLcl = pLclColor;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastContextCreate
//
// Creates a ReferenceRasterizer and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    ReferenceRasterizer *pRefRast;
    RRRenderTarget *pRendTgt;
    INT i;
    RRDEVICETYPE dwDriverType;

    // Surface7 pointers for QI
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    DPFM(0, DRV, ("In the new RefRast Dll\n"));

    // this only needs to be called once, but once per context won't hurt
    RefRastSetMemif(&malloc, &free, &realloc);

    if ((pRendTgt = new RRRenderTarget()) == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    // If it is expected to be a DX7+ driver
    if (pCtxData->ddrval < (DWORD)RRTYPE_DX7HAL)
    {
        if (pCtxData->lpDDS)
            pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDS))->lpLcl;
        if (pCtxData->lpDDSZ)
            pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDSZ))->lpLcl;
    }
    else
    {
        pColorLcl = pCtxData->lpDDSLcl;
        pZLcl     = pCtxData->lpDDSZLcl;
    }

    // save the ddrval that is being sent down to communicate the driver
    // type that the runtime expects it to be.
    dwDriverType = (RRDEVICETYPE) pCtxData->ddrval;

    // Collect surface information where the failures are easy to handle.
    pCtxData->ddrval = FillRRRenderTarget(pColorLcl, pZLcl, pRendTgt);
    if (pCtxData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Note (Hacks):
    // dwhContext is used by the runtime to inform the driver, which
    // d3d interface is calling the driver.
    // ddrval is used by the runtime to inform the driver the DriverStyle
    // value it read. This is a RefRast specific hack.
    if ((pRefRast = new ReferenceRasterizer( pCtxData->lpDDLcl,
                                             (DWORD)(pCtxData->dwhContext),
                                             dwDriverType)) == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pRefRast->SetRenderTarget(pRendTgt);

    //  return RR object pointer as context handle
    pCtxData->dwhContext = (ULONG_PTR)pRefRast;

    pCtxData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastContextDestroy
//
// Destroy a ReferenceRasterizer.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastContextDestroy", pCtxDestroyData);

    // Clean up override bits

    RRRenderTarget *pRendTgt = pRefRast->GetRenderTarget();
    if ( NULL != pRendTgt ) { delete pRendTgt; }

    delete pRefRast;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSceneCapture
//
// Pass scene capture callback to ref rast.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastSceneCapture", pData);

    pRefRast->SceneCapture( pData->dwFlag );

    pData->ddrval = D3D_OK;        // Should this be changed to a QI ?

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSetRenderTarget
//
// Update a RefRast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    ReferenceRasterizer *pRefRast;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastSetRenderTarget", pTgtData);

    RRRenderTarget *pRendTgt = pRefRast->GetRenderTarget();
    if ( NULL == pRendTgt ) { return DDHAL_DRIVER_HANDLED; }


    if (pRefRast->IsInterfaceDX6AndBefore() ||
        pRefRast->IsDriverDX6AndBefore())
    {
        if( pTgtData->lpDDS )
            pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDS))->lpLcl;
        if( pTgtData->lpDDSZ )
            pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDSZ))->lpLcl;
    }
    else
    {
        pColorLcl = pTgtData->lpDDSLcl;
        pZLcl = pTgtData->lpDDSZLcl;
    }

    // Collect surface information.
    pTgtData->ddrval = FillRRRenderTarget(pColorLcl, pZLcl, pRendTgt);
    if (pTgtData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pRefRast->SetRenderTarget(pRendTgt);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastValidateTextureStageState
//
// Validate current blend operations.  RefRast does everything.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;
    pData->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastDrawOneIndexedPrimitive
//
// Draw one list of primitives. This is called by D3DIM for API
// DrawIndexedPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                               pOneIdxPrimData)
{
    ReferenceRasterizer *pRefRast;
    HRESULT hr;
    DWORD dwVStride;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastDrawOneIndexedPrimitive",
                             pOneIdxPrimData);

    if ((pOneIdxPrimData->ddrval=RRFVFCheckAndStride(pOneIdxPrimData->dwFVFControl, &dwVStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOneIdxPrimData->ddrval= RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOneIdxPrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
    {
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOneIdxPrimData->ddrval=
         pRefRast->BeginRendering((DWORD)pOneIdxPrimData->dwFVFControl)) != D3D_OK)
    {
        RefRastUnlockTexture(pRefRast);
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }

    pOneIdxPrimData->ddrval =
    DoDrawOneIndexedPrimitive(pRefRast,
                              (UINT16)dwVStride,
                              (PUINT8)pOneIdxPrimData->lpvVertices,
                              pOneIdxPrimData->lpwIndices,
                              pOneIdxPrimData->PrimitiveType,
                              pOneIdxPrimData->dwNumIndices);
    hr = pRefRast->EndRendering();
    RefRastUnlockTexture(pRefRast);
    RefRastUnlockTarget(pRefRast);
    if (pOneIdxPrimData->ddrval == D3D_OK)
    {
        pOneIdxPrimData->ddrval = hr;
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastDrawOnePrimitive
//
// Draw one list of primitives. This is called by D3DIM for API DrawPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
    ReferenceRasterizer *pRefRast;
    HRESULT hr;
    DWORD dwVStride;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastDrawOnePrimitive", pOnePrimData);

    if ((pOnePrimData->ddrval=RRFVFCheckAndStride(pOnePrimData->dwFVFControl, &dwVStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOnePrimData->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOnePrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
    {
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pOnePrimData->ddrval=
         pRefRast->BeginRendering(pOnePrimData->dwFVFControl)) != D3D_OK)
    {
        RefRastUnlockTexture(pRefRast);
        RefRastUnlockTarget(pRefRast);
        return DDHAL_DRIVER_HANDLED;
    }
    pOnePrimData->ddrval =
        DoDrawOnePrimitive(pRefRast,
                           (UINT16)dwVStride,
                           (PUINT8)pOnePrimData->lpvVertices,
                           pOnePrimData->PrimitiveType,
                           pOnePrimData->dwNumVertices);
    hr = pRefRast->EndRendering();
    // Unlock texture/rendertarget
    RefRastUnlockTexture(pRefRast);
    RefRastUnlockTarget(pRefRast);
    if (pOnePrimData->ddrval == D3D_OK)
    {
        pOnePrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastDrawPrimitives
//
// This is called by D3DIM for a list of batched API DrawPrimitive calls.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData)
{
    ReferenceRasterizer *pRefRast;
    PUINT8  pData = (PUINT8)pDrawPrimData->lpvData;
    LPD3DHAL_DRAWPRIMCOUNTS pDrawPrimitiveCounts;
    HRESULT hr;
    DWORD dwVStride;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastDrawPrimitives", pDrawPrimData);

    pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
    // Check for FVF only if there is something to be drawn
    if (pDrawPrimitiveCounts->wNumVertices > 0)
    {
        // Unconditionally get the vertex stride, since it can not change
        if ((pDrawPrimData->ddrval =
             RRFVFCheckAndStride(pDrawPrimData->dwFVFControl, &dwVStride)) != D3D_OK)
        {
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if ((pDrawPrimData->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Skip BeginRendering & RefRastLockTexture if first thing is state change
    if (pDrawPrimitiveCounts->wNumStateChanges <= 0)
    {
        if ((pDrawPrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
        {
            RefRastUnlockTarget(pRefRast);
            return DDHAL_DRIVER_HANDLED;
        }
        if ((pDrawPrimData->ddrval =
             pRefRast->BeginRendering(pDrawPrimData->dwFVFControl)) != D3D_OK)
        {
            RefRastUnlockTexture(pRefRast);
            RefRastUnlockTarget(pRefRast);
            return DDHAL_DRIVER_HANDLED;
        }
    }
    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
        pData += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        // Update render states
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            UINT32 StateType,StateValue;
            LPDWORD pStateChange = (LPDWORD)pData;
            INT i;
            for (i = 0; i < pDrawPrimitiveCounts->wNumStateChanges; i++)
            {
                StateType = *pStateChange;
                pStateChange ++;
                StateValue = *pStateChange;
                pStateChange ++;
                pRefRast->SetRenderState(StateType, StateValue);
            }

            pData += pDrawPrimitiveCounts->wNumStateChanges *
                     sizeof(DWORD) * 2;
        }

        // Check for exit
        if (pDrawPrimitiveCounts->wNumVertices == 0)
        {
            break;
        }

        // Align pointer to vertex data
        pData = (PUINT8)
                ((ULONG_PTR)(pData + (DP_VTX_ALIGN - 1)) & ~(DP_VTX_ALIGN - 1));

        // The texture might changed
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            RefRastUnlockTexture(pRefRast);
            if ((pDrawPrimData->ddrval=pRefRast->EndRendering()) != D3D_OK)
            {
                RefRastUnlockTarget(pRefRast);
                return DDHAL_DRIVER_HANDLED;
            }
            if ((pDrawPrimData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK)
            {
                RefRastUnlockTarget(pRefRast);
                return DDHAL_DRIVER_HANDLED;
            }
            if ((pDrawPrimData->ddrval =
                 pRefRast->BeginRendering(pDrawPrimData->dwFVFControl)) != D3D_OK)
            {
                RefRastUnlockTexture(pRefRast);
                RefRastUnlockTarget(pRefRast);
                return DDHAL_DRIVER_HANDLED;
            }
        }

        // Draw primitives
        pDrawPrimData->ddrval =
            DoDrawOnePrimitive(pRefRast,
                               (UINT16)dwVStride,
                               (PUINT8)pData,
                               (D3DPRIMITIVETYPE)
                               pDrawPrimitiveCounts->wPrimitiveType,
                               pDrawPrimitiveCounts->wNumVertices);
        if (pDrawPrimData->ddrval != DD_OK)
        {
            goto EH_exit;
        }

        pData += pDrawPrimitiveCounts->wNumVertices * dwVStride;
    }

    EH_exit:
    hr = pRefRast->EndRendering();
    RefRastUnlockTexture(pRefRast);
    RefRastUnlockTarget(pRefRast);
    if (pDrawPrimData->ddrval == D3D_OK)
    {
        pDrawPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}



//----------------------------------------------------------------------------
//
// RefRastTextureCreate
//
// Creates a RefRast texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    ReferenceRasterizer *pRefRast;
    RRTexture* pRRTex;
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;

    if (pTexData->lpDDS)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pTexData->lpDDS)->lpLcl;
    }

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastTextureCreate", pTexData);

    // Runtime shouldnt be calling TextureCreate for DX7 and newer
    // driver models
    if ((pRefRast->IsInterfaceDX6AndBefore() == FALSE) &&
        (pRefRast->IsDriverDX6AndBefore() == FALSE))
    {
        pTexData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    // assume OKness
    pTexData->ddrval = D3D_OK;

    // Allocate RRTexture
    if ( !(pRefRast->TextureCreate(
        (LPD3DTEXTUREHANDLE)&(pTexData->dwHandle), &pRRTex ) ) )
    {
        pTexData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    // Init texturemap.
    hr = pRRTex->Initialize( pLcl );
    if (hr != D3D_OK)
    {
        pTexData->ddrval = hr;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureDestroy
//
// Destroy a RefRast texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastTextureDestroy", pTexDestroyData);

    // Runtime shouldnt be Calling TextureCreate for DX7 and newer
    // driver models
    if ((pRefRast->IsInterfaceDX6AndBefore() == FALSE) &&
        (pRefRast->IsDriverDX6AndBefore() == FALSE))
    {
        pTexDestroyData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    if (!(pRefRast->TextureDestroy(pTexDestroyData->dwHandle)))
    {
        pTexDestroyData->ddrval = DDERR_GENERIC;
    }
    else
    {
        pTexDestroyData->ddrval = D3D_OK;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastTextureGetSurf", pTexGetSurf);

    pTexGetSurf->lpDDS = pRefRast->TextureGetSurf(pTexGetSurf->dwHandle);
    pTexGetSurf->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastRenderPrimitive
//
// Called by Execute() for drawing primitives.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData)
{
    ReferenceRasterizer *pRefRast;
    LPD3DINSTRUCTION pIns;
    LPD3DTLVERTEX pVtx;
    PUINT8 pData, pPrim;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastRenderPrimitive", pRenderData);

    if (pRefRast->GetRenderState()[D3DRENDERSTATE_ZVISIBLE])
    {
        pRenderData->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        pRenderData->ddrval = D3D_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find out necessary data
    pData = (PUINT8)(((LPDDRAWI_DDRAWSURFACE_INT)
                      (pRenderData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);
    pIns = &pRenderData->diInstruction;
    pPrim = pData + pRenderData->dwOffset;
    pVtx = (LPD3DTLVERTEX)((PUINT8)((LPDDRAWI_DDRAWSURFACE_INT)
                                    (pRenderData->lpTLBuf))->lpLcl->lpGbl->fpVidMem +
                           pRenderData->dwTLOffset);

    if ( (pRenderData->ddrval=RefRastLockTarget(pRefRast)) != D3D_OK )
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ( (pRenderData->ddrval=RefRastLockTexture(pRefRast)) != D3D_OK )
    {
        return DDHAL_DRIVER_HANDLED;
    }
    if ( (pRenderData->ddrval=pRefRast->BeginRendering(D3DFVF_TLVERTEX)) != D3D_OK )
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Render
    switch (pIns->bOpcode) {
    case D3DOP_POINT:
        pRenderData->ddrval = DoRendPoints(pRefRast,
                                           pIns, pVtx,
                                           (LPD3DPOINT)pPrim);
        break;
    case D3DOP_LINE:
        pRenderData->ddrval = DoRendLines(pRefRast,
                                          pIns, pVtx,
                                          (LPD3DLINE)pPrim);
        break;
    case D3DOP_TRIANGLE:
        pRenderData->ddrval = DoRendTriangles(pRefRast,
                                              pIns, pVtx,
                                              (LPD3DTRIANGLE)pPrim);
        break;
    default:
        DPFM(0, DRV, ("(RefRast) Wrong Opcode passed to the new rasterizer."));
        pRenderData->ddrval =  DDERR_INVALIDPARAMS;
        break;
    }

    HRESULT hr = pRefRast->EndRendering();
    RefRastUnlockTarget(pRefRast);
    RefRastUnlockTexture(pRefRast);
    if (pRenderData->ddrval == D3D_OK)
    {
        pRenderData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastRenderState
//
// Called by Execute() for setting render states.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
    VALIDATE_REFRAST_CONTEXT("RefRastRenderState", pStateData);

    PUINT8 pData;
    LPD3DSTATE pState;
    INT i;
    pData = (PUINT8) (((LPDDRAWI_DDRAWSURFACE_INT)
                       (pStateData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);

    // Updates states
    for (i = 0, pState = (LPD3DSTATE) (pData + pStateData->dwOffset);
        i < (INT)pStateData->dwCount;
        i ++, pState ++)
    {
        UINT32 type = (UINT32) pState->drstRenderStateType;

        // Set the state
        pRefRast->SetRenderState(type, pState->dwArg[0]);
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastGetDriverState
//
// Called by the runtime to get any kind of driver information
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastGetDriverState(LPDDHAL_GETDRIVERSTATEDATA pGDSData)
{
    ReferenceRasterizer *pRefRast;

    // Check ReferenceRasterizer
#if DBG
    if ((pGDSData) == NULL)
    {
        DPFM(0, DRV, ("in %s, data pointer = NULL", "RefRastGetDriverState"));
        return DDHAL_DRIVER_HANDLED;
    }
    pRefRast = (ReferenceRasterizer *)((pGDSData)->dwhContext);
    if (!pRefRast)
    {
        DPFM(0, DRV, ("in %s, dwhContext = NULL", "RefRastGetDriverState"));
        pGDSData->ddRVal = D3DHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }
#else // !DBG
    pRefRast = (ReferenceRasterizer *)((pGDSData)->dwhContext);
#endif // !DBG

    //
    // No implementation yet, so nothing is understood yet
    //
    pGDSData->ddRVal = S_FALSE;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastHalProvider::GetCaps/GetInterface
//
// Returns the reference rasterizer's HAL interface.
//
//----------------------------------------------------------------------------

extern D3DDEVICEDESC7 g_nullDevDesc;

static D3DHAL_CALLBACKS Callbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    RefRastContextCreate,
    RefRastContextDestroy,
    NULL,
    RefRastSceneCapture,
    NULL,
    NULL,
    RefRastRenderState,
    RefRastRenderPrimitive,
    NULL,
    RefRastTextureCreate,
    RefRastTextureDestroy,
    NULL,
    RefRastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 Callbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
    D3DHAL2_CB32_DRAWONEPRIMITIVE |
    D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
    D3DHAL2_CB32_DRAWPRIMITIVES,
    RefRastSetRenderTarget,
    NULL,
    RefRastDrawOnePrimitive,
    RefRastDrawOneIndexedPrimitive,
    RefRastDrawPrimitives
};

static D3DHAL_CALLBACKS3 Callbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, // lpvReserved
    RefRastValidateTextureStageState,
    RefRastDrawPrimitives2,  // DrawVB
};

static D3DDEVICEDESC7 RefDevDesc = { 0 };
static D3DHAL_D3DEXTENDEDCAPS RefExtCaps;

static void
FillOutDeviceCaps( BOOL bIsNullDevice )
{
    //
    //  set device description
    //
    RefDevDesc.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     |
        D3DDEVCAPS_DRAWPRIMITIVES2EX    |
        D3DDEVCAPS_HWTRANSFORMANDLIGHT  ;

    RefDevDesc.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    RefDevDesc.dpcTriCaps.dwMiscCaps =
    D3DPMISCCAPS_MASKZ    |
    D3DPMISCCAPS_CULLNONE |
    D3DPMISCCAPS_CULLCW   |
    D3DPMISCCAPS_CULLCCW  ;
    RefDevDesc.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG |
        D3DPRASTERCAPS_ZFOG;
    RefDevDesc.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    RefDevDesc.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    RefDevDesc.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    RefDevDesc.dpcTriCaps.dwAlphaCmpCaps =
    RefDevDesc.dpcTriCaps.dwZCmpCaps;
    RefDevDesc.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    RefDevDesc.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE              |
        D3DPTEXTURECAPS_POW2                     |
        D3DPTEXTURECAPS_ALPHA                    |
        D3DPTEXTURECAPS_TRANSPARENCY             |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_BORDER                   |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_PROJECTED                |
        D3DPTEXTURECAPS_CUBEMAP                  |
        D3DPTEXTURECAPS_COLORKEYBLEND;
    RefDevDesc.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MINFANISOTROPIC  |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       |
        D3DPTFILTERCAPS_MAGFANISOTROPIC  ;
    RefDevDesc.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    RefDevDesc.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    RefDevDesc.dpcTriCaps.dwStippleWidth = 0;
    RefDevDesc.dpcTriCaps.dwStippleHeight = 0;

    //  line caps - copy tricaps and modify
    memcpy( &RefDevDesc.dpcLineCaps, &RefDevDesc.dpcTriCaps, sizeof(D3DPRIMCAPS) );

    //  disable antialias cap
    RefDevDesc.dpcLineCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
//        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
//        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG;

    RefDevDesc.dwDeviceRenderBitDepth = DDBD_16 | DDBD_24 | DDBD_32;
    RefDevDesc.dwDeviceZBufferBitDepth = DDBD_16 | DDBD_32;

    // DX5 stuff (should be in sync with the extended caps reported below)
    RefDevDesc.dwMinTextureWidth = 1;
    RefDevDesc.dwMaxTextureWidth = 4096;
    RefDevDesc.dwMinTextureHeight = 1;
    RefDevDesc.dwMaxTextureHeight = 4096;

    //
    //  set extended caps
    //
    RefExtCaps.dwSize = sizeof(RefExtCaps);

    RefExtCaps.dwMinTextureWidth = 1;
    RefExtCaps.dwMaxTextureWidth = 4096;
    RefExtCaps.dwMinTextureHeight = 1;
    RefExtCaps.dwMaxTextureHeight = 4096;
    RefExtCaps.dwMinStippleWidth = 0;   //  stipple unsupported
    RefExtCaps.dwMaxStippleWidth = 0;
    RefExtCaps.dwMinStippleHeight = 0;
    RefExtCaps.dwMaxStippleHeight = 0;

    RefExtCaps.dwMaxTextureRepeat = 32768;
    RefExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    RefExtCaps.dwMaxAnisotropy = 16;

    RefExtCaps.dvGuardBandLeft   = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandTop    = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandRight  = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvGuardBandBottom = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    RefExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    RefExtCaps.dwFVFCaps = 8;   // max number of tex coord sets
    RefExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
        D3DTEXOPCAPS_ADDSIGNED2X               |
        D3DTEXOPCAPS_SUBTRACT                  |
        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
        D3DTEXOPCAPS_PREMODULATE               |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP                |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       |
        D3DTEXOPCAPS_DOTPRODUCT3               ;
    RefExtCaps.wMaxTextureBlendStages = 8;
    RefExtCaps.wMaxSimultaneousTextures = 8;
    RefExtCaps.dwMaxActiveLights = 0xffffffff;
    RefExtCaps.dvMaxVertexW = 1.0e10;

    RefExtCaps.wMaxUserClipPlanes = RRMAX_USER_CLIPPLANES;
    RefExtCaps.wMaxVertexBlendMatrices = RRMAX_WORLD_MATRICES;

    RefExtCaps.dwVertexProcessingCaps = (D3DVTXPCAPS_TEXGEN            |
                                         D3DVTXPCAPS_MATERIALSOURCE7   |
                                         D3DVTXPCAPS_VERTEXFOG         |
                                         D3DVTXPCAPS_DIRECTIONALLIGHTS |
                                         D3DVTXPCAPS_POSITIONALLIGHTS  |
                                         D3DVTXPCAPS_LOCALVIEWER);
    RefExtCaps.dwReserved1 = 0;
    RefExtCaps.dwReserved2 = 0;
    RefExtCaps.dwReserved3 = 0;
    RefExtCaps.dwReserved4 = 0;
}


static D3DHAL_GLOBALDRIVERDATA RefDriverData;

static void DevDesc7ToDevDescV1( D3DDEVICEDESC_V1 *pOut, D3DDEVICEDESC7 *pIn )
{

    // These fields are not available in D3DDEVICEDESC7.
    // Zeroing them out, the front-end should not be using them
    //     DWORD            dwFlags
    //     D3DCOLORMODEL    dcmColorModel
    //     D3DTRANSFORMCAPS dtcTransformCaps
    //     BOOL             bClipping
    //     D3DLIGHTINGCAPS  dlcLightingCaps
    //     DWORD            dwMaxBufferSize
    //     DWORD            dwMaxVertexCount
    //     DWORD            dwMinStippleWidth, dwMaxStippleWidth
    //     DWORD            dwMinStippleHeight, dwMaxStippleHeight;
    //
    ZeroMemory( pOut, sizeof( D3DDEVICEDESC_V1 ) );
    pOut->dwSize = sizeof( D3DDEVICEDESC_V1 );

    // These are available in D3DDEVICEDESC7 so copy field by field
    // to avoid any future problems based on the assumptions of size
    pOut->dwDevCaps = pIn->dwDevCaps;
    pOut->dpcLineCaps = pIn->dpcLineCaps;
    pOut->dpcTriCaps = pIn->dpcTriCaps;
    pOut->dwDeviceRenderBitDepth = pIn->dwDeviceRenderBitDepth;
    pOut->dwDeviceZBufferBitDepth = pIn->dwDeviceZBufferBitDepth;
}

static void DevDesc7ToDevDesc( D3DDEVICEDESC *pOut, D3DDEVICEDESC7 *pIn )
{

    pOut->dwSize = sizeof( D3DDEVICEDESC );

    // These fields are not available in D3DDEVICEDESC7.
    // Setting them to some sensible values

    pOut->dwFlags =
        D3DDD_COLORMODEL            |
        D3DDD_DEVCAPS               |
        D3DDD_TRANSFORMCAPS         |
        D3DDD_LIGHTINGCAPS          |
        D3DDD_BCLIPPING             |
        D3DDD_LINECAPS              |
        D3DDD_TRICAPS               |
        D3DDD_DEVICERENDERBITDEPTH  |
        D3DDD_DEVICEZBUFFERBITDEPTH |
        D3DDD_MAXBUFFERSIZE         |
        D3DDD_MAXVERTEXCOUNT        ;
    pOut->dcmColorModel = D3DCOLOR_RGB;
    pOut->dtcTransformCaps.dwSize = sizeof(D3DTRANSFORMCAPS);
    pOut->dtcTransformCaps.dwCaps = D3DTRANSFORMCAPS_CLIP;
    pOut->bClipping = TRUE;
    pOut->dlcLightingCaps.dwSize = sizeof(D3DLIGHTINGCAPS);
    pOut->dlcLightingCaps.dwCaps =
        D3DLIGHTCAPS_POINT         |
        D3DLIGHTCAPS_SPOT          |
        D3DLIGHTCAPS_DIRECTIONAL   ;
    pOut->dlcLightingCaps.dwLightingModel = D3DLIGHTINGMODEL_RGB;
    pOut->dlcLightingCaps.dwNumLights = 0;
    pOut->dwMaxBufferSize = 0;
    pOut->dwMaxVertexCount = BASE_VERTEX_COUNT;
    pOut->dwMinStippleWidth  = 0;
    pOut->dwMaxStippleWidth  = 0;
    pOut->dwMinStippleHeight = 0;
    pOut->dwMaxStippleHeight = 0;

    // These are available in D3DDEVICEDESC7 so copy field by field
    // to avoid any future problems based on the assumptions of size
    pOut->dwDevCaps = pIn->dwDevCaps;
    pOut->dpcLineCaps = pIn->dpcLineCaps;
    pOut->dpcTriCaps = pIn->dpcTriCaps;
    pOut->dwDeviceRenderBitDepth = pIn->dwDeviceRenderBitDepth;
    pOut->dwDeviceZBufferBitDepth = pIn->dwDeviceZBufferBitDepth;
    pOut->dwMinTextureWidth = pIn->dwMinTextureWidth;
    pOut->dwMinTextureHeight = pIn->dwMinTextureHeight;
    pOut->dwMaxTextureWidth = pIn->dwMaxTextureWidth;
    pOut->dwMaxTextureHeight = pIn->dwMaxTextureHeight;
    pOut->dwMaxTextureRepeat = pIn->dwMaxTextureRepeat;
    pOut->dwMaxTextureAspectRatio = pIn->dwMaxTextureAspectRatio;
    pOut->dwMaxAnisotropy = pIn->dwMaxAnisotropy;
    pOut->dvGuardBandLeft = pIn->dvGuardBandLeft;
    pOut->dvGuardBandTop = pIn->dvGuardBandTop;
    pOut->dvGuardBandRight = pIn->dvGuardBandRight;
    pOut->dvGuardBandBottom = pIn->dvGuardBandBottom;
    pOut->dvExtentsAdjust = pIn->dvExtentsAdjust;
    pOut->dwStencilCaps = pIn->dwStencilCaps;
    pOut->dwFVFCaps = pIn->dwFVFCaps;
    pOut->dwTextureOpCaps = pIn->dwTextureOpCaps;
    pOut->wMaxTextureBlendStages = pIn->wMaxTextureBlendStages;
    pOut->wMaxSimultaneousTextures = pIn->wMaxSimultaneousTextures;
}

STDMETHODIMP
RefRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{
    //  fill out device description & extended caps
    FillOutDeviceCaps(FALSE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //  fill out GLOBALDRIVERDATA (initially zero)
    RefDriverData.dwSize = sizeof(RefDriverData);

    //
    // Need to fix up RefDriverData.hwCaps (D3DDEVICEDESC) from
    // rgbDevDesc (D3DDEVICEDESC7)
    //
    DevDesc7ToDevDescV1( &RefDriverData.hwCaps, &RefDevDesc );

    RefDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    RefDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    RefDriverData.dwNumTextureFormats =
        GetRefTextureFormats(IID_IDirect3DRefDevice,
                             &RefDriverData.lpTextureFormats, dwVersion);

    //  set interface data for return
    pInterfaceData->pGlobalData = &RefDriverData;
    pInterfaceData->pExtCaps = &RefExtCaps;
    pInterfaceData->pCallbacks = &Callbacks;
    pInterfaceData->pCallbacks2 = &Callbacks2;
    pInterfaceData->pCallbacks3 = &Callbacks3;

    //
    // This dwVersion==4 corresponds to DX7+
    // This HalProvider interface is a hack to enable sw-drivers to
    // behave like hw-hals hence this mysteriousness!
    //
    if( dwVersion >= 4 )
    {
        pInterfaceData->pfnGetDriverState = RefRastGetDriverState;
    }

    return S_OK;
}

STDMETHODIMP
RefRastHalProvider::GetCaps(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DDEVICEDESC7 pHwDesc,
                            LPD3DDEVICEDESC7 pHelDesc,
                            DWORD dwVersion)
{
    //  fill out device description & extended caps
    FillOutDeviceCaps(FALSE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //
    // This dwVersion==4 corresponds to DX7+
    // This HalProvider interface is a hack to enable sw-drivers to
    // behave like hw-hals hence this mysteriousness!
    //
    if (dwVersion < 4)
    {
        ZeroMemory( pHwDesc, sizeof( D3DDEVICEDESC ));
        ((D3DDEVICEDESC *)pHwDesc)->dwSize = sizeof( D3DDEVICEDESC );
        DevDesc7ToDevDesc( (D3DDEVICEDESC *)pHelDesc, &RefDevDesc );
    }
    else
    {
        memcpy(pHwDesc, &g_nullDevDesc, sizeof(D3DDEVICEDESC7));
        memcpy(pHelDesc, &RefDevDesc, sizeof(D3DDEVICEDESC7));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// Null Device implementation section
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// NullDeviceContextCreate
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceContextCreate(LPD3DHAL_CONTEXTCREATEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceContextDestroy
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceSceneCapture
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceSetRenderTarget
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawOneIndexedPrimitive
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawOnePrimitive
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawPrimitives
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceDrawPrimitives2
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceTextureCreate
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceTextureCreate(LPD3DHAL_TEXTURECREATEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceTextureDestroy
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceTextureGetSurf
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceRenderPrimitive
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
// NullDeviceRenderState
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceRenderState(LPD3DHAL_RENDERSTATEDATA pData)
{
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
// NullDeviceValidateTextureStageState
//----------------------------------------------------------------------------
DWORD __stdcall
NullDeviceValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    pData->dwNumPasses = 1;
    pData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider::GetCaps/GetInterface
//
// Returns the null device's HAL interface.
// RefRast's caps are reflected by this device. Only the actual callbacks
// are different.
//----------------------------------------------------------------------------

static D3DHAL_CALLBACKS NullCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    NullDeviceContextCreate,
    NullDeviceContextDestroy,
    NULL,
    NullDeviceSceneCapture,
    NULL,
    NULL,
    NullDeviceRenderState,
    NullDeviceRenderPrimitive,
    NULL,
    NullDeviceTextureCreate,
    NullDeviceTextureDestroy,
    NULL,
    NullDeviceTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 NullCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
    D3DHAL2_CB32_DRAWONEPRIMITIVE |
    D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
    D3DHAL2_CB32_DRAWPRIMITIVES,
    NullDeviceSetRenderTarget,
    NULL,
    NullDeviceDrawOnePrimitive,
    NullDeviceDrawOneIndexedPrimitive,
    NullDeviceDrawPrimitives
};

static D3DHAL_CALLBACKS3 NullCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, // lpvReserved
    NullDeviceValidateTextureStageState,
    NullDeviceDrawPrimitives2,
};

STDMETHODIMP
NullDeviceHalProvider::GetInterface(THIS_
                                    LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                    LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                    DWORD dwVersion)
{
    //  fill out device description & extended caps
    FillOutDeviceCaps(TRUE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //  fill out GLOBALDRIVERDATA (initially zero)
    RefDriverData.dwSize = sizeof(RefDriverData);

    DevDesc7ToDevDescV1( &RefDriverData.hwCaps, &RefDevDesc );

    RefDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    RefDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    RefDriverData.dwNumTextureFormats =
        GetRefTextureFormats(IID_IDirect3DNullDevice,
                             &RefDriverData.lpTextureFormats, dwVersion);

    //  set interface data for return
    pInterfaceData->pGlobalData = &RefDriverData;
    pInterfaceData->pExtCaps = &RefExtCaps;
    pInterfaceData->pCallbacks = &NullCallbacks;
    pInterfaceData->pCallbacks2 = &NullCallbacks2;
    pInterfaceData->pCallbacks3 = &NullCallbacks3;

    return S_OK;
}

STDMETHODIMP
NullDeviceHalProvider::GetCaps(THIS_
                               LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                               LPD3DDEVICEDESC7 pHwDesc,
                               LPD3DDEVICEDESC7 pHelDesc,
                               DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;

    //  fill out device description & extended caps
    FillOutDeviceCaps(TRUE);
    // add extended caps to RefDevDesc
    D3DDeviceDescConvert(&RefDevDesc,NULL,&RefExtCaps);

    //
    // This dwVersion==4 corresponds to DX7+
    // This HalProvider interface is a hack to enable sw-drivers to
    // behave like hw-hals hence this mysteriousness!
    //
    if (dwVersion < 4)
    {
        ZeroMemory( pHwDesc, sizeof( D3DDEVICEDESC ));
        ((D3DDEVICEDESC *)pHwDesc)->dwSize = sizeof( D3DDEVICEDESC );
        DevDesc7ToDevDesc( (D3DDEVICEDESC *)pHelDesc, &RefDevDesc );
    }
    else
    {
        memcpy(pHwDesc, &g_nullDevDesc, sizeof(D3DDEVICEDESC7));
        memcpy(pHelDesc, &RefDevDesc, sizeof(D3DDEVICEDESC7));
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\drv\refprov.cpp ===
//----------------------------------------------------------------------------
//
// swprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"

#define nullPrimCaps \
{                                                                             \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                \
}

#define nullTransCaps \
{                                                                             \
    sizeof(D3DTRANSFORMCAPS), 0                                               \
}

#define nullLightCaps \
{                                                                             \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0                                          \
}

D3DDEVICEDESC7 g_nullDevDesc =
{
    0,                          /* dwDevCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwMaxBufferSize */
    0,                          /* dwMaxVertexCount */
    0, 0,
    0, 0,
};


//----------------------------------------------------------------------------
//
// RefHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP RefHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// RefHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) RefHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// RefHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) RefHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// GetRefHALProvider
//
// Returns the appropriate reference software HAL provider based on the given
// GUID.
//
//----------------------------------------------------------------------------

static RefRastHalProvider g_RefRastHalProvider;
static NullDeviceHalProvider g_NullDeviceHalProvider;

STDAPI GetRefHalProvider(REFIID riid, IHalProvider **ppHalProvider,
                        HINSTANCE *phDll)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DRefDevice))
    {
        *ppHalProvider = &g_RefRastHalProvider;
    }
    else if (IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        *ppHalProvider = &g_NullDeviceHalProvider;
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_TEXTURE_FORMATS   28

STDAPI
GetRefTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd,
                     DWORD dwVersion)
{
    int i = 0;

    static DDSURFACEDESC ddsd_RefNull_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RefNull_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    DDSURFACEDESC *ddsd;

    if (dwVersion >= 3)
    {
        ddsd = ddsd_RefNull_Dev3;
    }
    else
    {
        ddsd = ddsd_RefNull_Dev2;
    }

    /* 888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 8888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 565 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xf800;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x07e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* 555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* pal4 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;

    i++;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    /* 1555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    // A formats for PC98 consistency
    // 4444 ARGB (it is already supported by S3 Virge)
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
    ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x0f00;
    ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x00f0;
    ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x000f;

    i++;

    if (dwVersion >= 2)
    {
        // 332 8-bit RGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0xe0;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x1c;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x03;

        i++;
    }

    if (dwVersion >= 3)
    {
        /* 8 bit luminance-only */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        /* 16 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        // A couple of formats for PC98 consistency
        // UYVY
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('U', 'Y', 'V', 'Y');

        i++;

            // YVY2
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('Y', 'U', 'Y', '2');

        i++;

        // S3 compressed texture format 1
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '1');

        i++;

        // S3 compressed texture format 2
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '2');

        i++;

        // S3 compressed texture format 3
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '3');

        i++;

        // S3 compressed texture format 4
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '4');

        i++;

        // S3 compressed texture format 5
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '5');

        i++;

        // Add a few bump map formats
        // U8V8
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV;
        ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x00ff;
        ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0x0;

        i++;

        // U5V5L6
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
            DDPF_BUMPLUMINANCE;
        ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x001f;
        ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x03e0;
        ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xfc00;

        i++;

        // U8V8L8
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
            DDPF_BUMPLUMINANCE;
        ddsd[i].ddpfPixelFormat.dwBumpBitCount = 24;
        ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x0000ff;
        ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x00ff00;
        ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xff0000;

        i++;

        /* 8 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask =  0xf0;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0x0f;

        i++;

        // 8332 16-bit ARGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x00e0;
        ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x001c;
        ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x0003;

        i++;

#if 0
// for Shadow Buffer prototype API

        // Z16S0 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 16;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 0;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xffff;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x0000;

        i++;

        // Z24S8 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 32;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 8;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xffffff00;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x000000ff;

        i++;

        // Z15S1 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 16;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 1;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xfffe;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x0001;

        i++;

        // Z32S0 16 bit Z buffer format for shadow buffer
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_ZBUFFER;
        ddsd[i].ddpfPixelFormat.dwZBufferBitDepth = 32;
        ddsd[i].ddpfPixelFormat.dwStencilBitDepth = 0;
        ddsd[i].ddpfPixelFormat.dwZBitMask = 0xffffffff;
        ddsd[i].ddpfPixelFormat.dwStencilBitMask = 0x00000000;

        i++;
#endif

    }

    *lplpddsd = ddsd;

    return i;
}

#define NUM_SUPPORTED_ZBUFFER_FORMATS   8


//----------------------------------------------------------------------------
//
// GetRefZBufferFormats
//
// Must return union of all the Z buffer formats supported by all rasterizers.
// CreateDevice will screen out device-specific ones (i.e. ones ramp doesnt handle) later.
// Called at device creation time and by DDHEL to validate software ZBuffer
// creation.
//
//----------------------------------------------------------------------------

STDAPI
GetRefZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    memset(&DDPF[0],0,sizeof(DDPF));

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;

    /* 24 bit Z; 8 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x000000ff;

    i++;

    /* 15 bit Z; 1 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 1;
    DDPF[i].dwZBitMask = 0xfffe;
    DDPF[i].dwStencilBitMask = 0x0001;

    i++;

    /* 32bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffffffff;
    DDPF[i].dwStencilBitMask = 0x00000000;

    i++;

    /* 8 bit stencil; 24 bit Z  */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0x00ffffff;
    DDPF[i].dwStencilBitMask = 0xff000000;

    i++;

    /* 1 bit stencil; 15 bit Z */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 1;
    DDPF[i].dwZBitMask = 0x7fff;
    DDPF[i].dwStencilBitMask = 0x8000;

    i++;

    /* 24 bit Z; 4 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 4;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x0000000f;

    i++;

    /* 4 bit stencil; 24 bit Z  */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 4;
    DDPF[i].dwZBitMask = 0x00ffffff;
    DDPF[i].dwStencilBitMask = 0x0f000000;

    i++;

    *ppDDPF = DDPF;

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\inc\d3dref.h ===
//----------------------------------------------------------------------------
//
// d3dref.h
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DREF_H_
#define _D3DREF_H_


STDAPI GetRefHalProvider(REFCLSID riid,
                         IHalProvider **ppHalProvider, HINSTANCE *phDll);
STDAPI GetRefZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetRefTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

typedef HRESULT (STDAPICALLTYPE* PFNGETREFHALPROVIDER)(REFCLSID,IHalProvider**,HINSTANCE*);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFZBUFFERFORMATS)(REFCLSID, DDPIXELFORMAT**);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFTEXTUREFORMATS)(REFCLSID, LPDDSURFACEDESC*, DWORD);

inline FARPROC LoadReferenceDeviceProc( char* szProc )
{
    HINSTANCE hRefDLL;
    if (NULL == (hRefDLL = LoadLibrary("d3dref.dll")) )
    {
        return NULL;
    }
    return GetProcAddress(hRefDLL, szProc);
}

#endif // #ifndef _D3DREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\inc\refrast.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrast.hpp
//
// Direct3D Reference Rasterizer - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFRAST_HPP
#define  _REFRAST_HPP

// Leave this defined so various all the code compiles.  However,
// it will never be set, since it is a part of D3DFVF_RESERVED2 until
// DX8.
#define D3DFVF_S                0x1000
#include <rrutil.hpp>
#include <reftnl.hpp>

#include <templarr.hpp>

//-----------------------------------------------------------------------------
//
// Uncomment this to enable point sprites in the reference rasterizer
//
//-----------------------------------------------------------------------------
//#define __POINTSPRITES 1

//-----------------------------------------------------------------------------
//
// Uncomment this to enable shadowbuffer in the reference rasterizer
//
//-----------------------------------------------------------------------------
//#define __SHADOWBUFFER 1

//-----------------------------------------------------------------------------
//
// RefRastSetMemif - Routine to set memory allocation interface for reference
// rasterizer - takes pointers to functions to use for malloc, free, and realloc.
//
// These must be set prior to new'ing any ReferenceRasterizer objects.  These are
// used for allocating rasterizer objects, and for allocation of the fragment
// pointer array and fragment records used for sort-independent antialiasing and
// transluscency.
//
//-----------------------------------------------------------------------------
void
RefRastSetMemif(
    LPVOID( _cdecl* pfnMemAlloc )( size_t ),
    void( _cdecl* pfnMemFree )( PVOID ),
    LPVOID( _cdecl* pfnMemReAlloc )( PVOID, size_t ) );

//-----------------------------------------------------------------------------
//
// Surface types for rendering surfaces and textures.  Different subsets are
// supported for render targets and for textures.
//
//-----------------------------------------------------------------------------
typedef enum _RRSurfaceType
{
    RR_STYPE_NULL     = 0,
    RR_STYPE_B8G8R8   = 1,
    RR_STYPE_B8G8R8A8 = 2,
    RR_STYPE_B8G8R8X8 = 3,
    RR_STYPE_B5G6R5   = 4,
    RR_STYPE_B5G5R5   = 5,
    RR_STYPE_PALETTE4 = 6,
    RR_STYPE_PALETTE8 = 7,
    RR_STYPE_B5G5R5A1 = 8,
    RR_STYPE_B4G4R4   = 9,
    RR_STYPE_B4G4R4A4 =10,
    RR_STYPE_L8       =11,          // 8 bit luminance-only
    RR_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RR_STYPE_U8V8     =13,          // 16 bit bump map format
    RR_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RR_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RR_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RR_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RR_STYPE_DXT1     =18,          // S3 texture compression technique 1
    RR_STYPE_DXT2     =19,          // S3 texture compression technique 2
    RR_STYPE_DXT3     =20,          // S3 texture compression technique 3
    RR_STYPE_DXT4     =21,          // S3 texture compression technique 4
    RR_STYPE_DXT5     =22,          // S3 texture compression technique 5
    RR_STYPE_B2G3R3   =23,          // 8 bit RGB texture format
    RR_STYPE_L4A4     =24,          // 8 bit alpha-luminance
    RR_STYPE_B2G3R3A8 =25,          // 16 bit alpha-rgb

    RR_STYPE_Z16S0    =32,
    RR_STYPE_Z24S8    =33,
    RR_STYPE_Z15S1    =34,
    RR_STYPE_Z32S0    =35,
    RR_STYPE_S1Z15    =36,
    RR_STYPE_S8Z24    =37,
    RR_STYPE_Z24S4    =38,
    RR_STYPE_S4Z24    =39,

} RRSurfaceType;

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
#define SPRITETEXCOORDMAX (4095.75f/4096.0f)

//-----------------------------------------------------------------------------
//
// forward declarations, mostly from refrasti.hpp
//
//-----------------------------------------------------------------------------
class RRColorComp;
class RRColor;
class RRDepth;
class RRPixel;
class RRTexture;
class RRTextureCoord;
class RREnvTextureCoord;
class RRFVFExtractor;

typedef UINT16 RRCvgMask;
typedef struct _RRFRAGMENT RRFRAGMENT;
typedef struct _RRSCANCNVSTATE RRSCANCNVSTATE;
typedef struct _RRSTATS RRSTATS;

//-----------------------------------------------------------------------------
//
// RRRenderTarget - Class which encompasses all informatio about rendering
// target, including size, type/pointer/stride for color and depth/stencil
// buffers, guard band clip info, W range info.
//
// Usage is to instantiate, fill out public members, and install into a
// ReferenceRasterizer object via ReferenceRasterizer::SetRenderTarget.
//
//-----------------------------------------------------------------------------
class RRRenderTarget
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RRRenderTarget( void );
    ~RRRenderTarget( void );
    static void* operator new( size_t );
    static void operator delete( void* pv, size_t );
//
// these need to be filled in by the user before installing in a
// ReferenceRasterizer object
//
    int     m_iWidth;       // size of target surfaces (color & depth/stencil
    int     m_iHeight;      // must be same size

    RECT    m_Clip;
    FLOAT   m_fWRange[2];   // range of device W (W at near and far clip planes)

    RRSurfaceType m_ColorSType;
    char*   m_pColorBufBits;
    int     m_iColorBufPitch;

    RRSurfaceType m_DepthSType;
    char*   m_pDepthBufBits;
    int     m_iDepthBufPitch;

//
// these are used only to facilitate the way refrast is used in the D3D runtime
// and are not referenced within the refrast core
//
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSLcl;
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSZLcl;

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    friend class ReferenceRasterizer;

    void ReadPixelColor   ( INT32 iX, INT32 iY, RRColor& Color );
    void WritePixelColor  ( INT32 iX, INT32 iY, const RRColor& Color, BOOL bDither );
    void WritePixelDepth  ( INT32 iX, INT32 iY, const RRDepth& Depth );
    void ReadPixelDepth   ( INT32 iX, INT32 iY, RRDepth& Depth );
    void WritePixelStencil( INT32 iX, INT32 iY, UINT8 uStencil );
    void ReadPixelStencil ( INT32 iX, INT32 iY, UINT8& uStencil );
    void Clear            ( RRColor fillColor, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepth       ( RRDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd );
    void ClearStencil     ( UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepthStencil( RRDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
};

//-----------------------------------------------------------------------------
//
// RRTextureStageState - This holds the per-stage state for texture mapping.
// An array of these are instanced in the ReferenceRasterizer object.
//
// Store texture matrix at the end of the texture stage state.
//
//-----------------------------------------------------------------------------
#define D3DTSSI_MATRIX (D3DTSS_MAX)
class RRTextureStageState
{
public:
    union
    {
        DWORD   m_dwVal[D3DTSS_MAX+16]; // state array (unsigned)
        FLOAT   m_fVal[D3DTSS_MAX+16];  // state array (float)
    };
    RRTexture* m_pTexture;
};

//-----------------------------------------------------------------------------
//
// RRTexture - Class instanced once per texture which encompasses information
// about a chain of surfaces used as a texture map.  Includes size and type
// (assumed same for each level of detail) and pointer/stride for each LOD.
//
// Also includes pointer to palette, and colorkey value (legacy support only).
//
// Usage is to create RRTexture (and associated handle) with call to
// ReferenceRasterizer::TextureCreate and install in ReferenceRasterizer
// by passing handle into ReferenceRasterizer::SetRenderState.
//
//-----------------------------------------------------------------------------
#define RRTEX_MAXCLOD   12*6     // supports base texture up to 4kx4k
                                 // for 6 envmaps

class RRTexture
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RRTexture( void );
    ~RRTexture( void );
    static void* operator new( size_t );
    static void operator delete( void* pv, size_t );

//
// this needs to be called after changing any of the public state to validate
// internal (private) state
//
    BOOL Validate( void );

//
// these need to be filled in by the user before installing in a
// ReferenceRasterizer object
//
    DWORD           m_uFlags;       // RR_TEXTURE_* bitdefs
// bit definitions for RRTexture::uFlags
#define RR_TEXTURE_HAS_CK           (1L<< 0)    // set if texture has colorkey
#define RR_TEXTURE_LOCKED           (1L<< 1)    // set if DD surface is locked (external use only)
#define RR_TEXTURE_ALPHAINPALETTE   (1L<< 2)    // set if alpha channel in palette
#define RR_TEXTURE_ENVMAP           (1L<< 3)    // set if texture is envmap with 6 times
                                                // the usual number of surfaces
#define RR_TEXTURE_SHADOWMAP        (1L<< 4)    // set if the texture is a ZBuffer

    // basic info
    RRSurfaceType   m_SurfType;                     // format of pixel
    int             m_iWidth;                       // size of largest map
    int             m_iHeight;
    char*           m_pTextureBits[RRTEX_MAXCLOD];  // pointer to surface bits
    int             m_iPitch[RRTEX_MAXCLOD];        // pitch in bytes
    int             m_cLOD;     // 0..(n-1) count of LODs currently available

    DWORD           m_dwColorKey;   // D3DCOLOR colorkey value

    DWORD           m_dwEmptyFaceColor;     // D3DCOLOR empty cubemap empty face value

    DWORD*          m_pPalette;     // pointer to D3DCOLOR palette (may be NULL)

//
// these are used only to facilitate the way refrast is used in the D3D runtime
// and are not referenced within the refrast core
//
    // DD surface pointers for locking/unlocking and GetSurf callback
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSLcl[RRTEX_MAXCLOD];
    int             m_cLODDDS;  // 0..(n-1) count of LODs actually in the pDDS array

//
// may be useful to other users to have this public
//
    D3DTEXTUREHANDLE    m_hTex; // texture handle

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    friend class ReferenceRasterizer;

    // pointer to head of texture stage states, &m_TextureStageState[0]
    RRTextureStageState*    m_pStageState;

// texture.cpp - main interface methods used by ReferenceRasterizer object methods
    void DoLookupAndFilter( INT32 iStage, RRTextureCoord, RRColor& TextureColor );
    void DoBumpMapping( INT32 iStage, RRTextureCoord TCoord,
        FLOAT& fBumpMapUDelta, FLOAT& fBumpMapVDelta, RRColor& BumpMapModulate );
    void DoShadow(INT32 iStage, FLOAT* pfCoord, RRColor& OutputColor);
    // environment mapping versions
    void DoEnvProcessNormal( INT32 iStage, RREnvTextureCoord, RRColor& TextureColor );
    void DoEnvLookupAndFilter(INT32 iStage, INT16 iFace, FLOAT fMajor, FLOAT fDMDX, FLOAT fDMDY, RRTextureCoord TCoord, RRColor& TextureColor);
    void DoEnvReMap(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD, RRColor &Texel,
                    BOOL &bColorKeyMatched);
    void DoTableInterp(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD,
                         UINT8 uUSign, UINT8 uVSign, RRColor &Texel, BOOL &bColorKeyMatched);


    BOOL            m_bMipMapEnable;    // TRUE if mipmapping is enabled for this texture

    INT16           m_iTexSize[2];      // LOD 0 size
    INT16           m_iTexShift[2];     // LOD 0 log2 size (valid for power-of-2 size only)
    UINT16          m_uTexMask[2];      // LOD 0 (1<<log2(size))-1

    BOOL            m_bHasAlpha;        // TRUE if texture has an alpha channel
    BOOL            m_bDoColorKeyKill;  // TRUE is colorkey enabled for this texture and should kill pixel
    BOOL            m_bDoColorKeyZero;  // TRUE is colorkey enabled for this texture and should zero pixel
    BOOL            m_bColorKeyMatched; // TRUE if colorkey matched on one or more contributing samples

// texture.cpp
    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl );
    RRColor DoMapLookupLerp(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD);
    RRColor DoMapLookupNearest(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD, BOOL &bColorKeyMatched);
    RRColor DoLookup(INT32 iStage, float U, float V, INT16 iLOD, BOOL bNearest);
    void DoMagnify ( INT32 iStage, RRTextureCoord& TCoord, RRColor& Texel );
    void DoMinify  ( INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel );
    void DoTrilerp ( INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel );
    void DoAniso   ( INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, FLOAT fRatio, FLOAT fDelta[], RRColor& Texel );
    // environment mapping versions
    RRColor DoEnvLookup(INT32 iStage, RRTextureCoord TCoord, INT16 iFace, INT16 iLOD, BOOL bNearest);
    void DoEnvMagnify ( INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, RRColor& Texel );
    void DoEnvMinify  ( INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel );
    void DoEnvTrilerp ( INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel );
    void DoTextureTransform( INT32 iStage, BOOL bAlreadyXfmd, FLOAT* pfC, FLOAT* pfO, FLOAT* pfQ );

// texmap.cpp
    void ReadColor(
        INT32 iX, INT32 iY, INT32 iLOD,
        RRColor& Texel, BOOL &bColorKeyMatched );
};

#define REF_STATESET_GROWDELTA      1

#define RRSTATEOVERRIDE_DWORD_BITS      32
#define RRSTATEOVERRIDE_DWORD_SHIFT     5

typedef TemplArray<UINT8> StateSetData;
typedef StateSetData *LPStateSetData;

class ReferenceRasterizer;

typedef HRESULT (*PFN_DP2REFOPERATION)(ReferenceRasterizer *pRefRast, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFSETRENDERSTATES)(ReferenceRasterizer *pRefRast,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2REFTEXTURESTAGESTATE)(ReferenceRasterizer *pRefRast,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFSETLIGHT)(ReferenceRasterizer *pRefRast,
                                      LPD3DHAL_DP2COMMAND pCmd,
                                      LPDWORD pdwStride);
typedef struct _REF_STATESETFUNCTIONTBL
{
    DWORD                       dwSize;                 // size of struct
    PFN_DP2REFSETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2REFTEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2REFOPERATION pfnDp2SetViewport;
    PFN_DP2REFOPERATION pfnDp2SetWRange;
    PFN_DP2REFOPERATION pfnDp2SetMaterial;
    PFN_DP2REFOPERATION pfnDp2SetZRange;
    PFN_DP2REFSETLIGHT  pfnDp2SetLight;
    PFN_DP2REFOPERATION pfnDp2CreateLight;
    PFN_DP2REFOPERATION pfnDp2SetTransform;
    PFN_DP2REFOPERATION pfnDp2SetExtention;
    PFN_DP2REFOPERATION pfnDp2SetClipPlane;
} REF_STATESETFUNCTIONTBL, *LPREF_STATESETFUNCTIONTBL;

//
// The device type that the RefRast should emulate
//
typedef enum {
    RRTYPE_OLDHAL = 1,
    RRTYPE_DPHAL,
    RRTYPE_DP2HAL,          // DX6 HAL
    RRTYPE_DX7HAL,          // DX7 HAL w/out T&L, with state sets
    RRTYPE_DX7TLHAL
} RRDEVICETYPE;

typedef struct _RRSTATEOVERRIDES
{
    DWORD    bits[D3DSTATE_OVERRIDE_BIAS >> RRSTATEOVERRIDE_DWORD_SHIFT];
} RRSTATEOVERRIDES;

//-----------------------------------------------------------------------------
//
// ReferenceRasterizer - Primary object for reference rasterizer.  Each instance
// of this corresponds to a D3D device.
//
// Usage is to instantiate, install RRRenderTarget (and optional RRTexture's),
// and set state and draw primitives.
//
//-----------------------------------------------------------------------------
class ReferenceRasterizer : public RRProcessVertices
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    ReferenceRasterizer( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                         DWORD dwInterfaceType,
                         RRDEVICETYPE dwDriverType
                         );
    ~ReferenceRasterizer( void );
    static void* operator new( size_t );
    static void operator delete( void* pv, size_t );

    // Dp2 token handling functions
    HRESULT Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2RecTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd, LPDWORD pdwStride);
    HRESULT Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd);

    HRESULT Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2SetTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd, PDWORD pdwStride);
    HRESULT Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd);

    // StateSet related functions
    void SetRecStateFunctions(void);
    void SetSetStateFunctions(void);
    HRESULT BeginStateSet(DWORD dwHandle);
    HRESULT EndStateSet(void);
    HRESULT ExecuteStateSet(DWORD dwHandle);
    HRESULT DeleteStateSet(DWORD dwHandle);
    HRESULT CaptureStateSet(DWORD dwHandle);

    HRESULT RecordStates(PUINT8 pData, DWORD dwSize);
    HRESULT RecordLastState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwUnitSize);

    LPREF_STATESETFUNCTIONTBL pStateSetFuncTbl;

    // Interface style
    BOOL IsInterfaceDX6AndBefore() {return (m_dwInterfaceType <= 2);}
    // DriverStyle
    BOOL IsDriverDX6AndBefore()
    {
        return ((m_dwDriverType <= RRTYPE_DP2HAL) && (m_dwDriverType > 0));
    }

    // Last State hack
    void StoreLastPixelState(BOOL bStore);

    // state management functions
    void SetRenderTarget( RRRenderTarget* pRenderTarget );
    RRRenderTarget* GetRenderTarget( void );
    void SetRenderState( DWORD dwState, DWORD dwValue );
    DWORD* GetRenderState( void );
    DWORD* GetTextureStageState(DWORD dwStage);
    void SetTextureStageState( DWORD dwStage, DWORD dwStageState, DWORD dwValue );
    void SceneCapture( DWORD dwFlags );

    // texture management functions
    BOOL TextureCreate  ( LPD3DTEXTUREHANDLE phTex, RRTexture** ppTexture );
    BOOL TextureCreate  ( DWORD dwHandle, RRTexture** ppTex );

    BOOL TextureDestroy ( D3DTEXTUREHANDLE hTex );

    DWORD TextureGetSurf( D3DTEXTUREHANDLE hTex );

    // rendering functions
    HRESULT Clear(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT BeginRendering( DWORD dwFVFControl );
    HRESULT EndRendering( void  );

    BOOL DoAreaCalcs(FLOAT* pfDet, RRFVFExtractor* pVtx0,
                     RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2);
    void DoTexCoordCalcs(INT32 iStage, RRFVFExtractor* pVtx0,
                         RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2);
    void DrawTriangle( void* pvV0, void* pvV1, void* pvV2,
                       WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );
    void DrawLine( void* pvV0, void* pvV1, void* pvVFlat = NULL );
    void DrawPoint( void* pvV0, void* pvVFlat = NULL );

    void DrawClippedTriangle( void* pvV0, RRCLIPCODE c0,
                              void* pvV1, RRCLIPCODE c1,
                              void* pvV2, RRCLIPCODE c2,
                              WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );
    void DrawClippedLine( void* pvV0, RRCLIPCODE c0,
                          void* pvV1, RRCLIPCODE c1,
                          void* pvVFlat = NULL );
    void DrawClippedPoint( void* pvV0, RRCLIPCODE c0,
                           void* pvVFlat = NULL );

//
// these are used to facilitate the way refrast is used in the D3D runtime
//
    // functions to manipulate current set of texture
    int GetCurrentTextureMaps( D3DTEXTUREHANDLE* phTex, RRTexture** pTex );
    BOOL SetTextureMap( D3DTEXTUREHANDLE hTex, RRTexture* pTex );

//
// T&L Hal specific functions
//
    // For Non-Indexed Primitives
    void SavePrimitiveData( DWORD dwFVFIn, LPVOID pVtx,
                            UINT cVertices,
                            D3DPRIMITIVETYPE PrimType );
    // For Indexed Primitives
    void SavePrimitiveData( DWORD dwFVFIn, LPVOID pVtx, UINT cVertices,
                            D3DPRIMITIVETYPE PrimType,
                            LPWORD pIndices, UINT cIndices);
    HRESULT ProcessPrimitive( BOOL bIndexedPrim );
    HRESULT UpdateTLState();
    int ClipSingleLine( RRCLIPTRIANGLE *line );
    int ClipSingleTriangle(RRCLIPTRIANGLE *tri,
                           RRCLIPVTX ***clipVertexPointer);

//
// Texture locking and Unlocking control
//
    inline BOOL TexturesAreLocked()   {return m_bTexturesAreLocked;};
    inline void SetTexturesLocked()   {m_bTexturesAreLocked = TRUE;};
    inline void ClearTexturesLocked() {m_bTexturesAreLocked = FALSE;};
private:
    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    //-------------------------------------------------------------------------
    // state
    //-------------------------------------------------------------------------
    // DDraw Local, needed for the new texture handles from DX7 onwards
    LPDDRAWI_DIRECTDRAW_LCL m_pDDLcl;

    // This is obtained from CONTEXTCREATE->ddrval, indicates
    // what kind of emulation (DX3, DX5, DX6 or DX7) the driver should do.
    RRDEVICETYPE    m_dwDriverType;

    // This is obtained from CONTEXTCREATE->dwhContext, indicates
    // which D3D Device interface called the driver.
    DWORD           m_dwInterfaceType;

    // save area for floating point unit control
    WORD            m_wSaveFP;

    // TRUE if in begin/end primitive sequence
    BOOL            m_bInBegin;

    // TRUE if in rendering point sprite triangles
    BOOL            m_bPointSprite;

    // current Flexible Vertex Format control word
    UINT64          m_qwFVFControl;


    // render target (color & Z buffer)
    RRRenderTarget* m_pRenderTarget;
    FLOAT           m_fWBufferNorm[2]; // { Wnear, 1/(Wfar-Wnear) } to normalize W buffer value

    // fragment buffer
    RRFRAGMENT**    m_ppFragBuf;
    INT             m_iFragBufWidth;
    INT             m_iFragBufHeight;
    BOOL            m_bFragmentProcessingEnabled;

    // D3D renderstate
    union
    {
        DWORD       m_dwRenderState[D3DHAL_MAX_RSTATES];
        FLOAT       m_fRenderState[D3DHAL_MAX_RSTATES];
    };

    // State Override flags
    RRSTATEOVERRIDES m_renderstate_override;

    // texture state - per-stage state and pointer to associated texture
    int                 m_cActiveTextureStages; // count of active texture stages (range 0..D3DHAL_TSS_MAXSTAGES)
    RRTextureStageState m_TextureStageState[D3DHAL_TSS_MAXSTAGES];
    RRTexture*          m_pTexture[D3DHAL_TSS_MAXSTAGES];  //  texture maps associated with texture stages

    // DX7 style texture objects, where the handle is specified by the
    // runtime. It is basically an index into an array.
    // This array is dynamically allocated and grown very much like the light
    // array.
    RRTexture**         m_ppTextureArray;
    DWORD               m_dwTexArrayLength;

    // scan converter state
    RRSCANCNVSTATE* m_pSCS;

    // statistics
    RRSTATS*        m_pStt;

    // Last state
    DWORD m_LastState;

    // Array of StateSets, which are in turn implemented with TemplArray as
    // TemplArray<UINT8> StateSetData
    TemplArray<LPStateSetData> m_pStateSets;

    // This bool indicates that the textures are already locked
    BOOL m_bTexturesAreLocked;

    //-------------------------------------------------------------------------
    // methods
    //-------------------------------------------------------------------------

// refrasti.cpp
    HRESULT GrowTexArray( DWORD dwHandle );
    HRESULT SetTextureHandle( int iStage, DWORD dwHandle );
    void MapTextureHandleToDevice( int iStage );
    void UpdateActiveTexStageCount( void );
    RRTexture* MapHandleToTexture( D3DTEXTUREHANDLE hTex );

// MapLegcy.cpp
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

// setup.cpp
    void SetPrimitiveAttributeFunctions(
        const RRFVFExtractor& Vtx0,
        const RRFVFExtractor& Vtx1,
        const RRFVFExtractor& Vtx2,
        const RRFVFExtractor& VtxFlat );

// scancnv.cpp
    FLOAT ComputePixelAttrib( int iAttrib );
    FLOAT ComputePixelAttribClamp( int iAttrib );
    FLOAT ComputePixelAttribTex( int iTex, int iCrd );
    void ComputeFogIntensity( RRPixel& Pixel );
    void DoScanCnvGenPixel( RRCvgMask CvgMask, BOOL bTri );
    void DoScanCnvTri( int iEdgeCount );
    void DoScanCnvLine( void );

// texstage.cpp
    void DoTexture( const RRPixel& Pixel, RRColor& OutputColor);
    void ComputeTextureBlendArg(
        DWORD dwArgCtl, BOOL bAlphaOnly,
        const RRColor& DiffuseColor,
        const RRColor& SpecularColor,
        const RRColor& CurrentColor,
        const RRColor& TextureColor,
        RRColor& BlendArg);
    void DoTextureBlendStage(
        int iStage,
        const RRColor& DiffuseColor,
        const RRColor& SpecularColor,
        const RRColor& CurrentColor,
        const RRColor& TextureColor,
        RRColor& OutputColor);

// pixproc.cpp
    BOOL DepthCloser( const RRDepth& DepthVal, const RRDepth& DepthBuf );
    BOOL AlphaTest( const RRColorComp& Alpha );
    BOOL DoStencil( UINT8 uStncBuf, BOOL bDepthTest, RRSurfaceType DepthSType, UINT8& uStncRet );
    void DoAlphaBlend( const RRColor& SrcColor, const RRColor& DstColor,
                       RRColor& ResColor );
    void DoPixel( RRPixel& Pixel );

// fragproc.cpp
    BOOL DoFragmentGenerationProcessing( RRPixel& Pixel );
    void DoFragmentBufferFixup( const RRPixel& Pixel );
    RRFRAGMENT*     FragAlloc( void );
    void            FragFree( RRFRAGMENT* pFrag );

// fragrslv.cpp
    void DoBufferResolve( void);
    void DoFragResolve(
        RRColor& ResolvedColor, RRDepth& ResolvedDepth,
        RRFRAGMENT* pFragList,
        const RRColor& PixelColor );

// PixRef.cpp
    void WritePixel(
        INT32 iX, INT32 iY,
        const RRColor& Color, const RRDepth& Depth);

// primfns.cpp
    void SetXfrm( D3DTRANSFORMSTATETYPE xfrmType, D3DMATRIX *pMat );
    HRESULT GrowLightArray(const DWORD dwIndex);
};

//-----------------------------------------------------------------------------
//
// RRFVFExtractor - Encases Flexible Vertex Format pointer and control to get
// vertex data.
//
//-----------------------------------------------------------------------------
#ifndef D3DFVF_GETTEXCOORDSIZE
#define D3DFVF_GETTEXCOORDSIZE(FVF, CoordIndex) ((FVF >> (CoordIndex*2 + 16)) & 0x3)
#endif
class RRFVFExtractor
{
private:
    void* m_pvData;
    UINT64 m_qwControl;
    BOOL  m_bPerspectiveEnable;
    int   m_iXYZ;
    int   m_iDiffuse;
    int   m_iSpecular;
    int   m_iTexCrd[D3DHAL_TSS_MAXSTAGES+1];
    int   m_iS;
    int   m_iEyeNormal;
    int   m_iEyeXYZ;
public:
    // constructor
    RRFVFExtractor( void* pvData, UINT64 qwControl, BOOL bPerspectiveEnable )
    {
        m_pvData = pvData;
        m_qwControl = qwControl;
        m_bPerspectiveEnable = bPerspectiveEnable;

        // compute offsets to fields within FVF
        m_iXYZ = 0 +
            ( m_qwControl & D3DFVF_RESERVED0 ? 1 : 0 );
        m_iDiffuse = m_iXYZ +
            ( m_qwControl & D3DFVF_XYZ       ? 3 : 0 ) +
            ( m_qwControl & D3DFVF_XYZRHW    ? 4 : 0 ) +
            ( m_qwControl & D3DFVF_NORMAL    ? 3 : 0 ) +
            ( m_qwControl & D3DFVF_RESERVED1 ? 1 : 0 );
        m_iSpecular = m_iDiffuse +
            ( m_qwControl & D3DFVF_DIFFUSE   ? 1 : 0 );
        m_iTexCrd[0] = m_iSpecular +
            ( m_qwControl & D3DFVF_SPECULAR  ? 1 : 0 );
        m_iS = m_iTexCrd[0];
        for(int i = 0; i < TexCrdCount(); i++)
        {
            int iTexND;
            switch (D3DFVF_GETTEXCOORDSIZE(m_qwControl, i))
            {
            case D3DFVF_TEXTUREFORMAT2:  iTexND = 2; break;
            case D3DFVF_TEXTUREFORMAT3:  iTexND = 3; break;
            case D3DFVF_TEXTUREFORMAT4:  iTexND = 4; break;
            case D3DFVF_TEXTUREFORMAT1:  iTexND = 1; break;
            }
            m_iTexCrd[i+1] = m_iTexCrd[i] + iTexND;
            m_iS = m_iTexCrd[i+1];      // generate one more iTexCrd pointer than
                                        // needed, and use it for size
        }
        m_iEyeNormal = m_iS +
            ( m_qwControl & D3DFVF_S  ? 1 : 0 );
        m_iEyeXYZ = m_iEyeNormal +
            ( m_qwControl & D3DFVFP_EYENORMAL  ? 3 : 0 );
    }

    // coordinate access methods
    FLOAT* GetPtrXYZ( void ) const { return (FLOAT*)m_pvData + m_iXYZ; }
    FLOAT GetX( void ) const  { return *( GetPtrXYZ() + 0 ); }
    FLOAT GetY( void ) const  { return *( GetPtrXYZ() + 1 ); }
    FLOAT GetZ( void ) const  { return *( GetPtrXYZ() + 2 ); }
    FLOAT GetRHW( void ) const
    {
        // return 1. if perspective not enabled
        if ( !m_bPerspectiveEnable ) return 1.f;
        // return 1/W if available else default value 1.0
        return ( m_qwControl & D3DFVF_XYZRHW )
            ? *( GetPtrXYZ() + 3 )
            : 1.f ;
    }

    // color access methods
    DWORD GetDiffuse( void ) const
    {
        // return color if available else white (default)
        return ( m_qwControl & D3DFVF_DIFFUSE )
            ? *( (DWORD*)m_pvData + m_iDiffuse )
            : 0xffffffff;
    }
    DWORD GetSpecular( void ) const
    {
        // return color if available else black and zero vertex fog (default)
        return ( m_qwControl & D3DFVF_SPECULAR )
            ? *( (DWORD*)m_pvData + m_iSpecular )
            : 0x00000000;
    }

    // texture coordinate access methods
    int TexCrdCount( void ) const
    {
        return (int)(( m_qwControl & D3DFVF_TEXCOUNT_MASK ) >> D3DFVF_TEXCOUNT_SHIFT);
    }
    FLOAT GetTexCrd( int iCrd, int iCrdSet ) const
    {
        return ( (TexCrdCount() > iCrdSet) && (iCrd < 4) )
            ? *( (FLOAT*)m_pvData + m_iTexCrd[iCrdSet] + iCrd )
            : 0.f;
    }
    FLOAT* GetPtrTexCrd( int iCrd, int iCrdSet ) const
    {
        return (FLOAT*)m_pvData + m_iTexCrd[iCrdSet] + iCrd;
    }
    FLOAT GetS( void ) const
    {
        return ( m_qwControl & D3DFVF_S )
            ? *( (FLOAT*)m_pvData + m_iS )
            : 1.0f;
    }
    FLOAT* GetPtrS( void ) const { return (FLOAT*)m_pvData + m_iS; }
    FLOAT GetEyeNormal( int iCrd ) const
    {
        return (m_qwControl & D3DFVFP_EYENORMAL)
            ? *( (FLOAT*)m_pvData + m_iEyeNormal + iCrd)
            : 0.f;
    }
    FLOAT* GetPtrEyeNormal( void ) const { return (FLOAT*)m_pvData + m_iEyeNormal; }
    FLOAT GetEyeXYZ( int iCrd ) const
    {
        return (m_qwControl & D3DFVFP_EYEXYZ)
            ? *( (FLOAT*)m_pvData + m_iEyeXYZ + iCrd)
            : 0.f;
    }
    FLOAT* GetPtrEyeXYZ( void ) const { return (FLOAT*)m_pvData + m_iEyeXYZ; }
};

//-------------------------------------------------------------------------
// S3 compressed texture formats
//-------------------------------------------------------------------------
// number of s3 compression formats
#define NUM_DXT_FORMATS    5
// number of pixels in block
#define DXT_BLOCK_PIXELS   16

typedef struct  {
    BYTE    rgba[4];
} DXT_COLOR;

typedef WORD        RGB565;     // packed color
typedef DWORD       PIXBM;      // 2 BPP bitmap


typedef struct  {
    RGB565      rgb0;       // color for index 0
    RGB565      rgb1;       // color for index 1
    PIXBM       pixbm;      // pixel bitmap
} DXTBlockRGB;

typedef struct  {
    WORD        alphabm[4]; // alpha bitmap at 4 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha4;

typedef struct  {
    BYTE        alpha0;     // alpha for index 0
    BYTE        alpha1;     // alpha for index 1
    BYTE        alphabm[6]; // alpha bitmap at 3 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha3;

void DecodeBlockRGB (DXTBlockRGB *pblockSrc,
                     DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);

///////////////////////////////////////////////////////////////////////////////
#endif // _REFRAST_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\inc\templarr.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// temparr.hpp
//
// Template class used by Direct3D ReferenceRasterizer for stateset and so on.
//
// The following error codes should be defined before included this file:
// DDERR_OUTOFMEMORY
// D3D_OK
// DDERR_INVALIDPARAMS
///////////////////////////////////////////////////////////////////////////////
#ifndef  _TEMPLARR_HPP
#define  _TEMPLARR_HPP


template <class T> class TemplArray 
{
public:
    TemplArray( void );
    ~TemplArray( void );

    // It is the user of this operator who makes sure 0<=iIndex<m_dwArraySize.
    T& operator []( int iIndex );

    HRESULT CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta = 16 );
    HRESULT CheckRange ( DWORD iIndex );

    // The user needs to make sure 0<=m_dwCurrent<m_dwArraySize.
    inline T CurrentItem(void) { return m_pArray[m_dwCurrent];};
    inline void SetCurrentItem(T item) { m_pArray[m_dwCurrent] = item;};
    inline DWORD CurrentIndex(void) { return m_dwCurrent;};
    inline void SetCurrentIndex(DWORD dwIdx) {m_dwCurrent = dwIdx;};

    inline DWORD ArraySize(void) { return m_dwArraySize;};

private:
    T *m_pArray;
    DWORD m_dwArraySize;
    // Index to the current item or the size of data stored in the array
    DWORD m_dwCurrent;
};


template <class T> 
TemplArray< T >::TemplArray( void )
{
    m_pArray = NULL;
    m_dwArraySize = 0;
    m_dwCurrent = 0;
}

template <class T> 
TemplArray< T >::~TemplArray( void )
{
    if (m_pArray != NULL)
        delete m_pArray;
    m_dwArraySize = 0;
}

template <class T> T& 
TemplArray< T >::operator[]( int iIndex )
{
    return m_pArray[iIndex];
}

template <class T> HRESULT
TemplArray< T >::CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta )
{
    if (iIndex >= m_dwArraySize)
    {
        DWORD dwNewArraySize = m_dwArraySize + dwGrowDelta;
        while (iIndex >= dwNewArraySize)
            dwNewArraySize += dwGrowDelta;

        T *pTmpArray = new T[dwNewArraySize];
        if (pTmpArray == NULL)
            return DDERR_OUTOFMEMORY;
        memset(pTmpArray, 0, sizeof(T) * dwNewArraySize);

        if (m_pArray != NULL)
        {
            _ASSERT(m_dwArraySize != 0, 
                    "CheckAndGrow: Array size cannot be NULL" );

            // Copy existing stuff into new array
            memcpy(pTmpArray, m_pArray, m_dwArraySize * sizeof(T));

            // Free up existing array
            delete m_pArray;
        }

        
        // Assign new array
        m_pArray = pTmpArray;
        m_dwArraySize = dwNewArraySize;
    }
    return D3D_OK;
}

template <class T> HRESULT
TemplArray< T >::CheckRange( DWORD iIndex )
{
    if (iIndex >= m_dwArraySize)
    {
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

#endif _TEMPLARR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\link\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dref
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\$(TARGETNAME).def

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

!if "$(BUILD_MSREF)" != ""

!ifdef SD_BUILD

REFLIBPATH = $(PROJECT_LIB_PATH)

!else

TARGETPATHLIB=$(BASEDIR)\public\sdk\lib\$(ALT_PROJECT_TARGET)
REFLIBPATH = $(BASEDIR)\public\sdk\lib\*

!endif

DDRAWLIB = ddrawp

!else

REFLIBPATH = $(DDK_LIB_PATH)
DDRAWLIB = ddraw

!endif

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
        $(SDK_LIB_PATH)\user32.lib   \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\uuid.lib     \
        $(SDK_LIB_PATH)\kernel32.lib \
    	$(REFLIBPATH)\$(DDRAWLIB).lib                


LINKLIBS = \
        ..\..\rast\$(PLAT_DIR)\$(_OBJ_DIR)\*\refrast.lib  \
        ..\..\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\reftnl.lib    \
        ..\..\drv\$(PLAT_DIR)\$(_OBJ_DIR)\*\refdrv.lib 

DLLENTRY = _DllMainCRTStartup

SOURCES = \
    ..\d3dref.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\inc\rrutil.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrutil.hpp
//
// Direct3D Reference Rasterizer - Utilities
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _RRUTIL_HPP
#define  _RRUTIL_HPP

#include <math.h>

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// memory allocation callbacks
extern LPVOID (__cdecl *g_pfnMemAlloc)( size_t size );
extern void   (__cdecl *g_pfnMemFree)( LPVOID lptr );
extern LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size );

// debug print controls
extern int g_iDPFLevel;
extern unsigned long g_uDPFMask;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Typedefs                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

// width-specific typedefs for basic types
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

typedef float                   FLOAT, *PFLOAT;
typedef double                  DOUBLE, *PDOUBLE;
typedef int                     BOOL;


typedef struct _RRVECTOR4
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} RRVECTOR4, *LPRRVECTOR4;

//-----------------------------------------------------------------------------
//
// Private FVF flags for texgen.
//
//-----------------------------------------------------------------------------
#define D3DFVFP_EYENORMAL     ((UINT64)1<<32)
#define D3DFVFP_EYEXYZ        ((UINT64)1<<33)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
#define ABS(a) (((a) < 0) ? (-(a)) : (a))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != D3D_OK)                                                         \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}


//-----------------------------------------------------------------------------
//
// macros for accessing floating point data as 32 bit integers and vice versa
//
// This is used primarily to do floating point to fixed point conversion with
// the unbiased nearest-even rounding that IEEE floating point does internally
// between operations.  Adding a big number slides the mantissa down to where
// the fixed point equivalent is aligned to the LSB.  IEEE applies a nearest-
// even round to the bits it lops off before storing.  The mantissa can then
// be grabbed by the AS_INT* operations.  Note that the sign and exponent are
// still there, so the easiest thing is to do it with doubles and grab the low
// 32 bits.
//
// The snap values (i.e. the "big number") is the sum of 2**n and 2**(n-1),
// which makes the trick return signed numbers (at least within the mantissa).
//
//-----------------------------------------------------------------------------

#if 0
// NOTE: vc5 optimizing compiler bug breaks this pointer casting technique
#define AS_FLOAT(i) ( *(FLOAT*)&(i) )
#define AS_INT32(f) ( *(INT32*)&(f) )
#define AS_INT16(f) ( *(INT16*)&(f) )
#define AS_UINT32(f) ( *(UINT32*)&(f) )

#else

// workaround using union
typedef union { float f; UINT32 u; INT32 i; } VAL32;
typedef union { double d; UINT64 u; INT64 i; } VAL64;
inline FLOAT AS_FLOAT( long int iVal ) { VAL32 v; v.i = iVal; return v.f; }
inline FLOAT AS_FLOAT( unsigned long int uVal ) { VAL32 v; v.u = uVal; return v.f; }
inline INT32 AS_INT32(  FLOAT fVal ) { VAL32 v; v.f = fVal; return v.i; }
inline INT32 AS_INT32( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT32)(v.u & 0xffffffff); }
inline INT16 AS_INT16(  FLOAT fVal ) { VAL32 v; v.f = fVal; return (INT16)(v.u & 0xffff); }
inline INT16 AS_INT16( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT16)(v.u & 0xffff); }
inline INT32 AS_UINT32( FLOAT fVal ) { VAL32 v; v.f = fVal; return v.u; }

#endif

//-----------------------------------------------------------------------------
//
// Some common FP values as constants
// point values
//
//-----------------------------------------------------------------------------
#define g_fZero                 (0.0f)
#define g_fOne                  (1.0f)

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

//-----------------------------------------------------------------------------
//
// these are handy to form 'magic' constants to snap real values to fixed
// point values
//
//-----------------------------------------------------------------------------
#define C2POW0 1
#define C2POW1 2
#define C2POW2 4
#define C2POW3 8
#define C2POW4 16
#define C2POW5 32
#define C2POW6 64
#define C2POW7 128
#define C2POW8 256
#define C2POW9 512
#define C2POW10 1024
#define C2POW11 2048
#define C2POW12 4096
#define C2POW13 8192
#define C2POW14 16384
#define C2POW15 32768
#define C2POW16 65536
#define C2POW17 131072
#define C2POW18 262144
#define C2POW19 524288
#define C2POW20 1048576
#define C2POW21 2097152
#define C2POW22 4194304
#define C2POW23 8388608
#define C2POW24 16777216
#define C2POW25 33554432
#define C2POW26 67108864
#define C2POW27 134217728
#define C2POW28 268435456
#define C2POW29 536870912
#define C2POW30 1073741824
#define C2POW31 2147483648
#define C2POW32 4294967296
#define C2POW33 8589934592
#define C2POW34 17179869184
#define C2POW35 34359738368
#define C2POW36 68719476736
#define C2POW37 137438953472
#define C2POW38 274877906944
#define C2POW39 549755813888
#define C2POW40 1099511627776
#define C2POW41 2199023255552
#define C2POW42 4398046511104
#define C2POW43 8796093022208
#define C2POW44 17592186044416
#define C2POW45 35184372088832
#define C2POW46 70368744177664
#define C2POW47 140737488355328
#define C2POW48 281474976710656
#define C2POW49 562949953421312
#define C2POW50 1125899906842624
#define C2POW51 2251799813685248
#define C2POW52 4503599627370496

#define FLOAT_0_SNAP    (FLOAT)(C2POW23+C2POW22)
#define FLOAT_4_SNAP    (FLOAT)(C2POW19+C2POW18)
#define FLOAT_5_SNAP    (FLOAT)(C2POW18+C2POW17)
#define FLOAT_8_SNAP    (FLOAT)(C2POW15+C2POW14)
#define FLOAT_17_SNAP   (FLOAT)(C2POW6 +C2POW5 )
#define FLOAT_18_SNAP   (FLOAT)(C2POW5 +C2POW4 )

#define DOUBLE_0_SNAP   (DOUBLE)(C2POW52+C2POW51)
#define DOUBLE_4_SNAP   (DOUBLE)(C2POW48+C2POW47)
#define DOUBLE_5_SNAP   (DOUBLE)(C2POW47+C2POW46)
#define DOUBLE_8_SNAP   (DOUBLE)(C2POW44+C2POW43)
#define DOUBLE_17_SNAP  (DOUBLE)(C2POW35+C2POW34)
#define DOUBLE_18_SNAP  (DOUBLE)(C2POW34+C2POW33)

//-----------------------------------------------------------------------------
//
// Floating point related macros
//
//-----------------------------------------------------------------------------
#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

#ifdef _X86_
#define FLOAT_CMP_POS(fa, op, fb)       (AS_INT32(fa) op AS_INT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (AS_INT32(flt) op INT32_FLOAT_ONE)

__inline int FLOAT_GTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define FTOI(f)                 ((INT)(f))

#endif // _X86_



//-----------------------------------------------------------------------------
//
// macro wrappers for memory allocation - wrapped around global function ptrs
// set by RefRastSetMemif
//
//-----------------------------------------------------------------------------
#define MEMALLOC(_size)         ((*g_pfnMemAlloc)(_size))
#define MEMFREE(_ptr)           { if (NULL != (_ptr)) { ((*g_pfnMemFree)(_ptr)); } }
#define MEMREALLOC(_ptr,_size)  ((*g_pfnMemReAlloc)((_ptr),(_size)))


//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// Utility Functions                                                            //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// debug printf support
//
//-----------------------------------------------------------------------------

void RRDebugPrintfL( int iLevel, const char* pszFormat, ... );
void RRDebugPrintf( const char* pszFormat, ... );

#define _DPF_IF     0x0001
#define _DPF_INPUT  0x0002
#define _DPF_SETUP  0x0004
#define _DPF_RAST   0x0008
#define _DPF_TEX    0x0010
#define _DPF_PIX    0x0020
#define _DPF_FRAG   0x0040
#define _DPF_STATS  0x0080
#define _DPF_DRV    0x0100
#define _DPF_TNL    0x0200
#define _DPF_ANY    0xffff
#define _DPF_TEMP   0x8000

#ifdef DBG
    #define DPFRR RRDebugPrintfL
    #define DPFM( _level, _mask, _message) \
        if ((g_iDPFLevel >= (_level)) && (g_uDPFMask & (_DPF_##_mask))) { \
            RRDebugPrintf ## _message; \
        }
#else
    #pragma warning(disable:4002)
    #define DPFRR()
    #define DPFM( _level, _mask, _message)
#endif


//-----------------------------------------------------------------------------
//
// assert macros and reporting functions
//
//-----------------------------------------------------------------------------

// ASSERT with simple string
#undef _ASSERT
#define _ASSERT( value, string )                  \
if ( !(value) ) {                                 \
    RRAssertReport( string, __FILE__, __LINE__ ); \
}
// ASSERT with formatted string - note extra parenthesis on report
// usage: _ASSERTf(foo,("foo is %d",foo))
#undef _ASSERTf
#define _ASSERTf(value,report)                      \
if (!(value)) {                                     \
    char __sz__FILE__[] = __FILE__;                 \
    RRAssertReportPrefix(__sz__FILE__,__LINE__);   \
    RRAssertReportMessage ## report;               \
}
// ASSERT with action field
#undef _ASSERTa
#define _ASSERTa(value,string,action)       \
if (!(value)) {                             \
    RRAssertReport(string,__FILE__,__LINE__); \
    action                                  \
}
// ASSERTf with action field
#undef _ASSERTfa
#define _ASSERTfa(value,report,action)     \
if (!(value)) {                            \
    RRAssertReportPrefix(__FILE__,__LINE__); \
    RRAssertReportMessage ## report;         \
    action                                 \
}

extern void RRAssertReport( const char* pszString, const char* pszFile, int iLine );
extern void RRAssertReportPrefix( const char* pszFile, int iLine );
extern void RRAssertReportMessage( const char* pszFormat, ... );


//-----------------------------------------------------------------------------
//
// bit twiddling utilities
//
//-----------------------------------------------------------------------------

extern INT32 CountSetBits( UINT32 uVal, INT32 nBits );
extern INT32 FindFirstSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindMostSignificantSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindLastSetBit( UINT32 uVal, INT32 nBits );

// TRUE if integer is a power of 2
inline BOOL IsPowerOf2( INT32 i )
{
    if ( i <= 0 ) return 0;
    return ( 0x0 == ( i & (i-1) ) );
}


//-----------------------------------------------------------------------------
//
// multiply/add routines & macros for unsigned 8 bit values, signed 16 bit values
//
// These are not currently used, but the Mult8x8Scl is an interesting routine
// for hardware designers to look at.  This does a 8x8 multiply combined with
// a 256/255 scale which accurately solves the "0xff * value = value" issue.
// There are refinements on this (involving half-adders) which are not easily
// representable in C.  Credits to Steve Gabriel and Jim Blinn.
//
//-----------------------------------------------------------------------------

// straight 8x8 unsigned multiply returning 8 bits, tossing fractional
// bits (no rounding)
inline UINT8 Mult8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 unsigned multiply with ff*val = val scale adjustment (scale by (256/255))
inline UINT8 Mult8x8Scl( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    uRes16 += 0x0080;
    uRes16 += (uRes16>>8);
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 saturated addition - result > 0xff returns 0xff
inline UINT8 SatAdd8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16+uB16;
    UINT8  uRes8 = (uRes16 > 0xff) ? (0xff) : ((UINT8)uRes16);
    return uRes8;
}

//----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//----------------------------------------------------------------------------
inline UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//////////////////////////////////////////////////////////////////////////////
// FVF related macros
//////////////////////////////////////////////////////////////////////////////
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)


//////////////////////////////////////////////////////////////////////////////
// State Override Macros
//////////////////////////////////////////////////////////////////////////////
#define IS_OVERRIDE(type)   ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)  ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)       \
    (set).bits[((state) - 1) >> RRSTATEOVERRIDE_DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (RRSTATEOVERRIDE_DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
    STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
    STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
    STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//---------------------------------------------------------------------
// GetFVFVertexSize:
//     Computes total vertex size in bytes for given fvf
//     including the texture coordinates
//---------------------------------------------------------------------
__inline DWORD
GetFVFVertexSize( UINT64 qwFVF )
{
    // Texture formats size  00   01   10   11
    static DWORD dwTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwSize = 3 << 2;
    switch( qwFVF & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZRHW: dwSize += 4;      break;
    case D3DFVF_XYZB1:  dwSize += 1*4;    break;
    case D3DFVF_XYZB2:  dwSize += 2*4;    break;
    case D3DFVF_XYZB3:  dwSize += 3*4;    break;
    case D3DFVF_XYZB4:  dwSize += 4*4;    break;
    case D3DFVF_XYZB5:  dwSize += 5*4;    break;
    }
    if (qwFVF & D3DFVF_NORMAL)
        dwSize += 3*4;
    if (qwFVF & D3DFVF_RESERVED1)
        dwSize += 4;

    if (qwFVF & D3DFVF_DIFFUSE)
        dwSize += 4;
    if (qwFVF & D3DFVF_SPECULAR)
        dwSize += 4;

    // Texture coordinates
    DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
    DWORD dwTextureFormats = (DWORD)qwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwSize += dwNumTexCoord * 2 * 4;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            dwSize += dwTextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }

    if (qwFVF & D3DFVF_S)
        dwSize += 4;

    if (qwFVF & D3DFVFP_EYENORMAL)
        dwSize += 3*4;

    if (qwFVF & D3DFVFP_EYEXYZ)
        dwSize += 3*4;

    return dwSize;
}

HRESULT
RRFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride );

///////////////////////////////////////////////////////////////////////////////
// Matrix and Vector routines
///////////////////////////////////////////////////////////////////////////////

inline void
ReverseVector(const D3DVECTOR &in, D3DVECTOR &out)
{
    out.x = -in.x;
    out.y = -in.y;
    out.z = -in.z;
}

inline void
AddVector(const D3DVECTOR &v1, const D3DVECTOR &v2, D3DVECTOR &out)
{
    out.x = v1.x + v2.x;
    out.y = v1.y + v2.y;
    out.z = v1.z + v2.z;
}

inline void
SubtractVector(const D3DVECTOR &v1, const D3DVECTOR &v2, D3DVECTOR &out)
{
    out.x = v1.x - v2.x;
    out.y = v1.y - v2.y;
    out.z = v1.z - v2.z;
}

inline void
SetIdentity(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 1.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
SetNull(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 0.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
CopyMatrix(D3DMATRIX &s, D3DMATRIX &d)
{
    d._11 = s._11;
    d._12 = s._12;
    d._13 = s._13;
    d._14 = s._14;
    d._21 = s._21;
    d._22 = s._22;
    d._23 = s._23;
    d._24 = s._24;
    d._31 = s._31;
    d._32 = s._32;
    d._33 = s._33;
    d._34 = s._34;
    d._41 = s._41;
    d._42 = s._42;
    d._43 = s._43;
    d._44 = s._44;
}

inline D3DVALUE
SquareMagnitude (const D3DVECTOR& v)
{
    return v.x*v.x + v.y*v.y + v.z*v.z;
}


inline D3DVALUE
Magnitude (const D3DVECTOR& v)
{
    return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVECTOR
Normalize (const D3DVECTOR& v)
{
    D3DVECTOR nv = {0.0f, 0.0f, 0.0f};
    D3DVALUE mag = Magnitude(v);

    nv.x = v.x/mag;
    nv.y = v.y/mag;
    nv.z = v.z/mag;

    return nv;
}

inline void
Normalize (D3DVECTOR& v)
{
    D3DVALUE mag = Magnitude(v);

    v.x = v.x/mag;
    v.y = v.y/mag;
    v.z = v.z/mag;

    return;
}

inline D3DVECTOR
CrossProduct (const D3DVECTOR& v1, const D3DVECTOR& v2)
{
        D3DVECTOR result;

        result.x = v1.y*v2.z - v1.z*v2.y;
        result.y = v1.z*v2.x - v1.x*v2.z;
        result.z = v1.x*v2.y - v1.y*v2.x;

        return result;
}

inline D3DVALUE
DotProduct (const D3DVECTOR& v1, const D3DVECTOR& v2)
{
        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
}

//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by a 4x4 matrix transposed,
// producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4Transposed(RRVECTOR4 *v, D3DMATRIX *m, RRVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4(RRVECTOR4 *v, D3DMATRIX *m, RRVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + v->w*m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + v->w*m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + v->w*m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x4(D3DVECTOR *v, D3DMATRIX *m, RRVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
Xform3VecBy3x3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}

//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//---------------------------------------------------------------------
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);


////////////////////////////////////////////////////////////////////////
//
// Macros used to access DDRAW surface info.
//
////////////////////////////////////////////////////////////////////////
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDSLcl) \
    (!((pDDSLcl)->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDSLcl) \
    ((pDDSLcl)->lpGbl->dwUsageCount > 0)
#define SURFACE_MEMORY(surfLcl) \
(LPVOID)((surfLcl)->lpGbl->fpVidMem)

//---------------------------------------------------------------------
// DDraw extern functions
//---------------------------------------------------------------------
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

extern "C" HRESULT WINAPI DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl);
extern "C" LPDDRAWI_DDRAWSURFACE_LCL WINAPI
GetDDSurfaceLocal( LPDDRAWI_DIRECTDRAW_LCL this_lcl, DWORD handle, BOOL* isnew );


///////////////////////////////////////////////////////////////////////////////
#endif  // _RRUTIL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\inc\reftnl.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.hpp
//
// Direct3D Reference Transform and Lighting - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFTNL_HPP
#define  _REFTNL_HPP

#define MAX_REFERENCE_LIGHTS          128
// Default color values that should be used when ther is no lighting and
// color in vertices provided
#define RR_DEFAULT_DIFFUSE  0xFFFFFFFF;
#define RR_DEFAULT_SPECULAR 0;

#define REF_GB_LEFT   -32768.f
#define REF_GB_TOP    -32768.f
#define REF_GB_RIGHT   32767.f
#define REF_GB_BOTTOM  32767.f

//----------------------------------------------------------------------------
// FVF related macros
//----------------------------------------------------------------------------
const DWORD RRMAX_FVF_TEXCOORD = 8;

//-----------------------------------------------------------------------------
//
// Typedefs
//
//-----------------------------------------------------------------------------
// Number of clipping planes
#define RRMAX_USER_CLIPPLANES 6

// Number of clipping planes
#define RRMAX_CLIPPING_PLANES (6+RRMAX_USER_CLIPPLANES)

// Number of world matrices
#define RRMAX_WORLD_MATRICES 4

// Space for vertices generated/copied while clipping one triangle
#define RRMAX_CLIP_VERTICES   (( 2 * RRMAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles
#define RRMAX_CLIP_TRIANGLES  ( RRMAX_CLIP_VERTICES - 2 )

// make smaller than guard band for easier clipping
#define RRMAX_POINT_SIZE  ( REF_GB_RIGHT )

typedef DWORD RRCLIPCODE;

typedef struct _RRCLIPVTX
{
    D3DVALUE    hx;
    D3DVALUE    hy;
    D3DVALUE    hz;
    D3DVALUE    hw;
    DWORD       clip;
    D3DCOLOR    color;
    D3DCOLOR    specular;
    D3DVALUE    sx;
    D3DVALUE    sy;
    D3DVALUE    sz;
    D3DVALUE    rhw;
    _RRCLIPVTX  *next;
    D3DVALUE    tex[RRMAX_FVF_TEXCOORD*4];
    D3DVALUE    s;
    D3DVALUE    eyenx;
    D3DVALUE    eyeny;
    D3DVALUE    eyenz;
    D3DVALUE    eyex;
    D3DVALUE    eyey;
    D3DVALUE    eyez;
} RRCLIPVTX;

typedef struct _RRCLIPTRIANGLE
{
    RRCLIPVTX  *v[3];
} RRCLIPTRIANGLE;

typedef struct _RRUSERCLIPPLANE
{
    RRVECTOR4       plane;
    BOOL             bActive;
} RRUSERCLIPPLANE, *LPRRUSERCLIPPLANE;

//-----------------------------------------------------------------------------
//
// forward declarations, mostly from reftnli.hpp
//
//-----------------------------------------------------------------------------
class RRMaterial;
class RRLight;
class RRTransform;


//-----------------------------------------------------------------------------
//
// Base class for all RefTnL classes to use common allocation functions
//
//-----------------------------------------------------------------------------
class RRAlloc
{
public:
    void* operator new(size_t s);
    void operator delete(void* p, size_t);
};

//-----------------------------------------------------------------------------
//
// RRVECTORH - Homogeneous vector
//
//-----------------------------------------------------------------------------
typedef struct tagRRVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} RRVECTORH, *PRRVECTORH;
//-----------------------------------------------------------------------------
//
// RRMATRIX - Matrix data-structure
//
//-----------------------------------------------------------------------------
typedef enum tagRRMATRIXTYPE
{
    RRMatrixIdentity,
    RRMatrixTranslate,
    RRMatrixRotateTranslate,
    RRMatrixAffine,
    RRMatrixGeneral
} RRMATRIXTYPE;


typedef D3DMATRIX RRMATRIX;

//-----------------------------------------------------------------------------
//
// RRTRANSFORMDATA - Transformation data used by Refrence T&L implementation
// to transform vertices.
//
//-----------------------------------------------------------------------------
typedef struct tagRRTRANSFORMDATA
{
    RRMATRIX      m_PS;         // Mproj * Mshift
    RRMATRIX      m_VPS;        // Mview * PS
    RRMATRIX      m_VPSInv;     // Inverse( Mview * PS )
    RRMATRIX      m_CTMI;       // Inverse current transformation matrix
    RRVECTORH     m_frustum[6]; // Normalized plane equations for viewing
                                // frustum in the model space
    DWORD          m_dwFlags;
} RRTRANSFORMDATA, *PRRTRANSFORMDATA;

//---------------------------------------------------------------------
// RRLIGHTING
// All the lighting related state clubbed together
//---------------------------------------------------------------------
typedef struct {D3DVALUE r,g,b;} RRCOLOR;

typedef struct _RRLIGHTING
{
    // Active Light list
    RRLight           *pActiveLights;

    // Temporary data used when computing lighting

    D3DVECTOR       eye_in_eye;         // eye position in eye space
                                        // It is (0, 0, 0)

    // Ma * La + Me (Ambient and Emissive) ------
    RRCOLOR           ambEmiss;

    // ColorVertex stuff ------------------------
    RRCOLOR *pAmbientSrc;
    RRCOLOR *pDiffuseSrc;
    RRCOLOR *pSpecularSrc;
    RRCOLOR *pEmissiveSrc;

    // Diffuse ----------------------------------
    RRCOLOR           vertexDiffuse; // Provided with a vertex, used if
                                     // COLORVERTEX is enabled and a diffuse
                                     // color is provided in the vertex
    RRCOLOR           diffuse;       // Diffuse accumulates here
    DWORD             outDiffuse;    // Diffuse color result of lighting


    // Specular --------------------------------
    RRCOLOR           vertexSpecular;// Provided with a vertex, used if
                                     // COLORVERTEX is enabled and a specular
                                     // color is provided in the vertex
    RRCOLOR           specular;      // Specular accumulates here
    DWORD             outSpecular;   // Specular color result of lighting

    D3DVALUE          specThreshold;  // If the dot product is less than this
                                      // value, specular factor is zero
    // End of temporary data

    // RENDERSTATEAMBIENT --------------------------------------

    // Ambient color set by D3DRENDERSTATE_AMBIENT
    // They are all scaled to 0 - 1
    D3DVALUE          ambient_red;
    D3DVALUE          ambient_green;
    D3DVALUE          ambient_blue;
    DWORD             ambient_save;       // Original unscaled color

    // Fog -----------------------------------------------------

    int               fog_mode;
    D3DCOLOR          fog_color;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)

    D3DCOLORMODEL     color_model;

    // Material ------------------------------------------------

    // For color material
    LPDWORD           pDiffuseAlphaSrc;
    LPDWORD           pSpecularAlphaSrc;

    DWORD               materialDiffAlpha;  // Current material diffuse
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    DWORD               materialSpecAlpha;  // Current material specular
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    DWORD               vertexDiffAlpha;    // Current material diffuse
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    DWORD               vertexSpecAlpha;    // Current material specular
                                            // alpha (0-255) shifted left
                                            // by 24 bits

    D3DMATERIAL7      material;           // Cached material data
    RRCOLOR           matAmb;
    RRCOLOR           matDiff;
    RRCOLOR           matSpec;
    RRCOLOR           matEmis;
} RRLIGHTING;

//-----------------------------------------------------------------------------
//
// RRLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the ReferenceRasterizer object.
//
//-----------------------------------------------------------------------------
typedef struct _RRLIGHTI
{
    DWORD           flags;

    D3DVECTOR       position_in_eye;  // In the eye space
    D3DVECTOR       direction_in_eye; // In the eye space

    //
    // Saved light colors scaled from 0 - 255, needed for COLORVERTEX
    //
    D3DCOLORVALUE   La;         //  light ambient
    D3DCOLORVALUE   Ld;         //  light diffuse
    D3DCOLORVALUE   Ls;         //  light specular

    //
    // Precomputed colors scaled from 0 - 255,
    //
    D3DCOLORVALUE   Ma_La;         // Material ambient times light ambient
    D3DCOLORVALUE   Md_Ld;         // Material diffuse times light diffuse
    D3DCOLORVALUE   Ms_Ls;         // Material specular times light specular


    D3DVECTOR       halfway;

    // Stuff for SpotLights
    D3DVALUE        range_squared;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVALUE        inv_theta_minus_phi;

} RRLIGHTI;


//-----------------------------------------------------------------------------
// Function pointer to the functions that light a vertex
//-----------------------------------------------------------------------------
typedef void (*RRLIGHTVERTEXFN)( RRLIGHTING& LData, D3DLIGHT7 *pLight,
                                 RRLIGHTI *pLightI, D3DLIGHTINGELEMENT *in,
                                 DWORD dwFlags, DWORD dwFVFIn );

//-----------------------------------------------------------------------------
// Functions to compute lighting
//-----------------------------------------------------------------------------
typedef struct _RRLIGHTVERTEX_FUNC_TABLE
{
    RRLIGHTVERTEXFN   pfnDirectional;
    RRLIGHTVERTEXFN   pfnParallelPoint;
    RRLIGHTVERTEXFN   pfnSpot;
    RRLIGHTVERTEXFN   pfnPoint;
} RRLIGHTVERTEX_FUNC_TABLE;

//-----------------------------------------------------------------------------
//
// RRLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the ReferenceRasterizer object.
//
//-----------------------------------------------------------------------------
#define RRLIGHT_ENABLED              0x00000001  // Is the light active
#define RRLIGHT_NEEDSPROCESSING      0x00000002  // Is the light data processed

class RRLight : public RRAlloc
{
public:
    RRLight();
    BOOL IsEnabled() {return (m_dwFlags & RRLIGHT_ENABLED);}
    BOOL NeedsProcessing() {return (m_dwFlags & RRLIGHT_NEEDSPROCESSING);}
    HRESULT SetLight(LPD3DLIGHT7 pLight);
    HRESULT GetLight( LPD3DLIGHT7 pLight );
    void ProcessLight( D3DMATERIAL7 *mat, RRLIGHTVERTEX_FUNC_TABLE *pTbl);
    void XformLight( D3DMATRIX* mV );
    void Enable( RRLight **ppRoot );
    void Disable( RRLight **ppRoot );

private:

    // Flags
    DWORD m_dwFlags;

    // Active List next element
    RRLight *m_Next;

    // Specific function to light the vertex
    RRLIGHTVERTEXFN   m_pfnLightVertex;

    // Light data set by the runtime
    D3DLIGHT7 m_Light;

    // Light data computed by the driver
    RRLIGHTI  m_LightI;

    friend class ReferenceRasterizer;
    friend class RRProcessVertices;
};

//-----------------------------------------------------------------------------
//
// RRMaterial - Class for materials data used for lighting by the driver
//
//-----------------------------------------------------------------------------
class RRMaterial : public RRAlloc
{
public:
    RRMaterial();
    ~RRMaterial();
    HRESULT SetMaterial(LPD3DMATERIAL7);
    HRESULT GetMaterial(LPD3DMATERIAL7);

private:
    // Data describing material
    D3DMATERIAL7         dmMaterial;
};


//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//---------------------------------------------------------------------

class RefAlignedBuffer32
{
public:
    RefAlignedBuffer32()  {m_size = 0; m_allocatedBuf = 0; m_alignedBuf = 0;}
    ~RefAlignedBuffer32() {if (m_allocatedBuf) free(m_allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return m_alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return m_size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
    {
        if (dwSize > m_size)
            return Grow(dwSize + 1024);
        else
            return S_OK;
    }
protected:
    LPVOID m_allocatedBuf;
    LPVOID m_alignedBuf;
    DWORD  m_size;
};

//---------------------------------------------------------------------
// Digested Viewport information
// calculated from viewport settings
//---------------------------------------------------------------------
typedef struct _RR_VIEWPORTDATA
{

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleX;            // dvWidth/2
    D3DVALUE scaleY;            // dvHeight/2
    D3DVALUE scaleZ;            // (Viewport->dvMaxZ - Viewport->dvMinZ)
    D3DVALUE offsetX;           // dvX + scaleX
    D3DVALUE offsetY;           // dvY + scaleY
    D3DVALUE offsetZ;           // Viewport->dvMinZ

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ

    // Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY

    // Min and max window values with guard band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;

    // Coefficients to transform a vertex to perform the guard band clipping
    // x*gb11 + w*gb41
    // y*gb22 + w*gb42
    //
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;

    // Coefficients to apply clipping rules for the guard band clipping
    // They are used by clipping routins
    // w*Kgbx1 < x < w*Kgbx2
    // w*Kgby1 < y < w*Kgby2
    //
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;
} RRVIEWPORTDATA;


//---------------------------------------------------------------------
// RRCLIPPING
// Cached clipping data
//---------------------------------------------------------------------
typedef struct __RRCLIPPING
{
    RefAlignedBuffer32    ClipBuf;
    RRCLIPVTX  *clip_vbuf1[RRMAX_CLIP_VERTICES];
    RRCLIPVTX  *clip_vbuf2[RRMAX_CLIP_VERTICES];
    RRCLIPVTX **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    RRCLIPVTX   clip_vertices[RRMAX_CLIP_VERTICES];
    DWORD       dwInterpolate;
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
} RRCLIPPING;


// RRProcessVertices::m_dwTLState flags
#define RRPV_DOLIGHTING                0x00000001
#define RRPV_DOCLIPPING                0x00000002
#define RRPV_GUARDBAND                 0x00000004
#define RRPV_DOFOG                     0x00000008
#define RRPV_DOSPECULAR                0x00000010
#define RRPV_RANGEFOG                  0x00000020
#define RRPV_NORMALIZENORMALS          0x00000040
#define RRPV_LOCALVIEWER               0x00000080
#define RRPV_DOCOMPUTEPOINTSIZE        0x00000100
#define RRPV_DOPASSEYENORMAL           0x00000200
#define RRPV_DOPASSEYEXYZ              0x00000400

// ColorVertexFlags
#define RRPV_VERTEXDIFFUSENEEDED       0x00000800
#define RRPV_VERTEXSPECULARNEEDED      0x00001000
#define RRPV_COLORVERTEXAMB            0x00002000
#define RRPV_COLORVERTEXDIFF           0x00004000
#define RRPV_COLORVERTEXSPEC           0x00008000
#define RRPV_COLORVERTEXEMIS           0x00010000
#define RRPV_COLORVERTEXFLAGS     (RRPV_VERTEXDIFFUSENEEDED       | \
                                   RRPV_VERTEXSPECULARNEEDED      | \
                                   RRPV_COLORVERTEXAMB            | \
                                   RRPV_COLORVERTEXDIFF           | \
                                   RRPV_COLORVERTEXSPEC           | \
                                   RRPV_COLORVERTEXEMIS )


// RRProcessVertices::m_dwDirtyFlags flags
#define RRPV_DIRTY_PROJXFM     0x00000001
#define RRPV_DIRTY_VIEWXFM     0x00000002
#define RRPV_DIRTY_WORLDXFM    0x00000004
#define RRPV_DIRTY_WORLD1XFM   0x00000008
#define RRPV_DIRTY_WORLD2XFM   0x00000010
#define RRPV_DIRTY_WORLD3XFM   0x00000020
#define RRPV_DIRTY_VIEWRECT    0x00000040
#define RRPV_DIRTY_ZRANGE      0x00000080
#define RRPV_DIRTY_XFORM       (RRPV_DIRTY_PROJXFM   | \
                                RRPV_DIRTY_VIEWXFM   | \
                                RRPV_DIRTY_VIEWRECT  | \
                                RRPV_DIRTY_WORLDXFM  | \
                                RRPV_DIRTY_WORLD1XFM | \
                                RRPV_DIRTY_WORLD2XFM | \
                                RRPV_DIRTY_WORLD3XFM | \
                                RRPV_DIRTY_ZRANGE)
#define RRPV_DIRTY_MATERIAL        0x00000100
#define RRPV_DIRTY_SETLIGHT        0x00000200
#define RRPV_DIRTY_NEEDXFMLIGHT    0x00000400
#define RRPV_DIRTY_COLORVTX        0x00000800
#define RRPV_DIRTY_LIGHTING    (RRPV_DIRTY_MATERIAL     | \
                                RRPV_DIRTY_SETLIGHT     | \
                                RRPV_DIRTY_NEEDXFMLIGHT | \
                                RRPV_DIRTY_COLORVTX)
#define RRPV_DIRTY_FOG              0x00010000
#define RRPV_DIRTY_CLIPPLANES       0x00020000
#define RRPV_DIRTY_INVERSEWORLDVIEW 0x00040000

//---------------------------------------------------------------------
// Transform & Lighting related data is encapsulated here
//---------------------------------------------------------------------
class RRProcessVertices
{
protected:

    //-------------------------------------------------------------------------
    // Unprocessed state set by the DDI
    //-------------------------------------------------------------------------
    // Growable Light array
    RRLight  *m_pLightArray;
    // RRLight  *m_pLightArray;
    DWORD    m_dwLightArraySize;        // Size of the light array allocated

    // Current material to use for lighting
    D3DMATERIAL7 m_Material;

    // Vertex components
    // Note: position is used to store the vertex buffer in the non-strided
    // driver emulation mode
    D3DDP_PTRSTRIDE m_position;
    D3DDP_PTRSTRIDE m_normal;
    D3DDP_PTRSTRIDE m_specular;
    D3DDP_PTRSTRIDE m_diffuse;
    D3DDP_PTRSTRIDE m_tex0;
    D3DDP_PTRSTRIDE m_tex1;
    D3DDP_PTRSTRIDE m_tex2;
    D3DDP_PTRSTRIDE m_tex3;
    D3DDP_PTRSTRIDE m_tex4;
    D3DDP_PTRSTRIDE m_tex5;
    D3DDP_PTRSTRIDE m_tex6;
    D3DDP_PTRSTRIDE m_tex7;

    // Transformation state stored by the reference implementation
    RRMATRIX      m_xfmProj;
    RRMATRIX      m_xfmView;
    RRMATRIX      m_xfmWorld[RRMAX_WORLD_MATRICES];

    // Viewport data
    D3DVIEWPORT7 m_Viewport;

    // User defined clipping planes
    RRVECTOR4 m_userClipPlanes[RRMAX_USER_CLIPPLANES];

    //-------------------------------------------------------------------------
    // Cached T&L related render-state info
    //-------------------------------------------------------------------------
    DWORD m_dwTLState;           // RenderState related flags
    DWORD m_dwDirtyFlags;        // Dirty flags

    //-------------------------------------------------------------------------
    // Transformation data
    //-------------------------------------------------------------------------
    // Buffer to store clip flags
    RefAlignedBuffer32    m_ClipFlagBuf;
    RRCLIPCODE *m_pClipBuf;

    // Buffer to store transformed vertices
    RefAlignedBuffer32    m_TLVBuf;
    LPVOID m_pvOut;

    // Current transformation matrix
    RRMATRIX m_xfmCurrent[RRMAX_WORLD_MATRICES];  // using WORLDi matrix
    RRMATRIX m_xfmToEye[RRMAX_WORLD_MATRICES];    // Transforms to camera
                                                  // space (Mworld*Mview)
    RRMATRIX m_xfmToEyeInv[RRMAX_WORLD_MATRICES]; // and its Inverse

    D3DPRIMITIVETYPE m_primType;  // Current primitive being drawn
    DWORD m_dwNumVertices;        // Number of vertices to process

    DWORD m_dwNumIndices;         // Number of indices for Indexed Prims
    LPWORD m_pIndices;

    DWORD m_dwFVFIn;              // FVF of the input vertices
    UINT64 m_qwFVFOut;             // Desired FVF for the output vertices
    DWORD m_dwOutputVtxSize;      // Size of the output vertex
    DWORD m_dwNumTexCoords;       // Number of the texture coordinate sets
    DWORD m_dwTexCoordSize[D3DDP_MAXTEXCOORD]; // Size of each one of them in
                                               // bytes
    DWORD m_dwTextureCoordSizeTotal;    // In Bytes

    DWORD   m_dwTexOffset;        // Offsets in the input FVF vertex.
    DWORD   m_dwDiffuseOffset;    // Recomputed when FVF is changed.
    DWORD   m_dwSpecularOffset;
    DWORD   m_dwNormalOffset;

    int     m_numVertexBlends;
    RRTRANSFORMDATA m_TransformData;
    RRVIEWPORTDATA m_ViewData;   // Computed Viewport dependent info.

    FLOAT m_fPointSize;
    FLOAT m_fPointAttA;
    FLOAT m_fPointAttB;
    FLOAT m_fPointAttC;
    FLOAT m_fPointSizeMin;

    //-------------------------------------------------------------------------
    // Lighting data
    //-------------------------------------------------------------------------
    RRLIGHTVERTEX_FUNC_TABLE    m_LightVertexTable;
    RRLIGHTING                  m_lighting;   // Lighting state

    //-------------------------------------------------------------------------
    // Clipping data
    //-------------------------------------------------------------------------
    // Clipping related
    RRCLIPCODE m_clipUnion;            // OR of all vertex clip flags
    RRCLIPCODE m_clipIntersection;     // AND of all vertex clip flags
    RRCLIPPING m_clipping;
    // User clip planes transformed
    RRUSERCLIPPLANE m_xfmUserClipPlanes[RRMAX_USER_CLIPPLANES];


    ///////////////////////////////////////////////////////////////////////////
    // Methods
    ///////////////////////////////////////////////////////////////////////////
    HRESULT UpdateXformData();
    HRESULT UpdateLightingData();
    HRESULT UpdateFogData();
    HRESULT UpdateClippingData( DWORD dwClipPlanesEnable );

    RRCLIPCODE
    ComputeClipCodes(RRCLIPCODE* pclipIntersection, RRCLIPCODE* pclipUnion,
        FLOAT x_clip, FLOAT y_clip, FLOAT z_clip, FLOAT w_clip, FLOAT fPointSize);
    RRCLIPCODE ProcessVertices();
    HRESULT DoIPrim();
    HRESULT DoNIPrim();

    void SetupFVFData(BOOL bFogEnabled, BOOL bSpecularEnable);

    void LightVertex( D3DLIGHTINGELEMENT *le );
    void FogVertex  ( D3DVECTOR &v, D3DLIGHTINGELEMENT *le,
                      int numVertexBlends,
                      float *pBlendFactors,
                      BOOL bVertexInEyeSpace );

    void InitTLData();

    // DrawClippedPrimitive
    HRESULT DrawOneClippedIndexedPrimitive();
    HRESULT DrawOneClippedPrimitive();


    // Clipping Related
    void Interpolate(RRCLIPVTX *out, RRCLIPVTX *p1, RRCLIPVTX *p2,
                     int code, D3DVALUE num, D3DVALUE denom);

    int ClipLeft( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipRight( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipTop( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipBottom( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipFront( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipBack( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipLeftGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipRightGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipTopGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);
    int ClipBottomGB( RRCLIPVTX **inv, RRCLIPVTX **outv, int count);

    int ClipLineLeft( RRCLIPTRIANGLE *inv);
    int ClipLineRight( RRCLIPTRIANGLE *inv);
    int ClipLineTop( RRCLIPTRIANGLE *inv);
    int ClipLineBottom( RRCLIPTRIANGLE *inv);
    int ClipLineFront( RRCLIPTRIANGLE *inv);
    int ClipLineBack( RRCLIPTRIANGLE *inv);
    int ClipLineLeftGB( RRCLIPTRIANGLE *inv);
    int ClipLineRightGB( RRCLIPTRIANGLE *inv);
    int ClipLineTopGB( RRCLIPTRIANGLE *inv);
    int ClipLineBottomGB( RRCLIPTRIANGLE *inv);

    int ClipByPlane( RRCLIPVTX **inv, RRCLIPVTX **outv, RRVECTOR4 *plane,
                     DWORD dwClipFlag, int count );
    int ClipLineByPlane( RRCLIPTRIANGLE *line, RRVECTOR4 *plane,
                         DWORD dwClipBit);
};

// Vertex Lighting functions
void RRLV_Directional( RRLIGHTING&, D3DLIGHT7 *, RRLIGHTI *,
                       D3DLIGHTINGELEMENT *, DWORD, DWORD );
void RRLV_PointAndSpot( RRLIGHTING&, D3DLIGHT7 *, RRLIGHTI *,
                        D3DLIGHTINGELEMENT *, DWORD, DWORD );

// For TL Refrast
// Following primitive functions are shared by REF rasterizers
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(ReferenceRasterizer * pCtx,
                          UINT16 FvfStride,
                          PUINT8 pVtx,
                          LPWORD puIndices,
                          D3DPRIMITIVETYPE PrimType,
                          UINT cIndices);
HRESULT FASTCALL
DoDrawOnePrimitive(ReferenceRasterizer * pCtx,
                   UINT16 FvfStride,
                   PUINT8 pVtx,
                   D3DPRIMITIVETYPE PrimType,
                   UINT cVertices);
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(ReferenceRasterizer * pCtx,
                             UINT16 FvfStride,
                             PUINT8 pVtx,
                             UINT cVertices,
                             UINT32 dwEdgeFlags);

//---------------------------------------------------------------------
// ComputeTextureCoordSize:
// Computes the following device data
//  - bTextureCoordSizeTotal
//  - bTextureCoordSize[] array, based on the input FVF id
//---------------------------------------------------------------------
__inline void ComputeTextureCoordSize(DWORD dwFVF,
                                      LPDWORD pdwTexCoordSizeArray,
                                      LPDWORD pdwTexCoordSizeTotal)
{
    // Texture formats size  00   01   10   11
    static BYTE bTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        *pdwTexCoordSizeTotal = (BYTE)dwNumTexCoord * 2 * 4;
        for (DWORD i=0; i < dwNumTexCoord; i++)
            pdwTexCoordSizeArray[i] = 4*2;
    }
    else
    {
        *pdwTexCoordSizeTotal = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = bTextureSize[dwTextureFormats & 3];
            pdwTexCoordSizeArray[i] = dwSize;
            *pdwTexCoordSizeTotal += dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
#endif // _REFTNL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\inc\refutil.h ===
//----------------------------------------------------------------------------
//
// refutil.h
//
// Umbrella header file for the reference implementation
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFUTIL_H_
#define _REFUTIL_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

#include <d3dref.h>
#include <d3ditype.h>
#include <d3dutil.h>
#include <span.h>
#include <d3dflt.h>

#endif // #ifndef _REFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\attrfunc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// AttrFunc.cpp
//
// Direct3D Reference Rasterizer - Attribute Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// WrapDiff - returns the difference (B-A) as defined under the D3D WRAPU/V
// rules which is the shortest path between the two assuming a coincident
// position at 1. and 0.  The fA and fB input range is 0. to 1.
//
//-----------------------------------------------------------------------------
static FLOAT
WrapDiff( FLOAT fB, FLOAT fA )
{
    // compute straight distance
    FLOAT fDist1 = fB - fA;
    // compute distance 'warping' between 0. and 1.
    FLOAT fDist2 = ( fDist1 < 0 ) ? ( fDist1+1 ) : ( fDist1-1 );

    // return minimum of these
    return ( fabs( fDist1) < fabs( fDist2) ) ? ( fDist1) : ( fDist2 );
}


///////////////////////////////////////////////////////////////////////////////
//
// RRAttribFuncStatic - Attribute function data which is shared by all
// attributes and contains per-primitive and per-pixel data.  Cannot use static
// data members in RRAttribFunc class because there can be multiple instances
// of rasterizer object.
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetPerTriangleData - Called once per triangle during setup to set per-triangle
// data used to compute attribute functions.
//
//-----------------------------------------------------------------------------
void
RRAttribFuncStatic::SetPerTriangleData(
    FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
    FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
    FLOAT fX2, FLOAT fY2, FLOAT fRHW2,
    INT32 cTextureStages,
    FLOAT* pfRHQW,
    FLOAT fDet )
{
    m_PrimType = RR_TRIANGLE;

    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    INT32 iX0 = AS_INT32( (DOUBLE)fX0 + DOUBLE_4_SNAP );
    INT32 iY0 = AS_INT32( (DOUBLE)fY0 + DOUBLE_4_SNAP );
    INT32 iX1 = AS_INT32( (DOUBLE)fX1 + DOUBLE_4_SNAP );
    INT32 iY1 = AS_INT32( (DOUBLE)fY1 + DOUBLE_4_SNAP );
    INT32 iX2 = AS_INT32( (DOUBLE)fX2 + DOUBLE_4_SNAP );
    INT32 iY2 = AS_INT32( (DOUBLE)fY2 + DOUBLE_4_SNAP );
    fX0 = (FLOAT)iX0 * 1.0F/16.0F;
    fY0 = (FLOAT)iY0 * 1.0F/16.0F;
    fX1 = (FLOAT)iX1 * 1.0F/16.0F;
    fY1 = (FLOAT)iY1 * 1.0F/16.0F;
    fX2 = (FLOAT)iX2 * 1.0F/16.0F;
    fY2 = (FLOAT)iY2 * 1.0F/16.0F;

    m_fX0 = fX0;
    m_fY0 = fY0;
    m_cTextureStages = cTextureStages;

    m_fRHW0 = fRHW0;
    m_fRHW1 = fRHW1;
    m_fRHW2 = fRHW2;

    m_fDelX10 = fX1 - fX0;
    m_fDelX02 = fX0 - fX2;
    m_fDelY01 = fY0 - fY1;
    m_fDelY20 = fY2 - fY0;

    // compute inverse determinant
    m_fTriOODet = 1.f/fDet;

    // compute linear function for 1/W (for perspective correction)

    // compute linear deltas along two edges
    FLOAT fDelAttrib10 = m_fRHW1 - m_fRHW0;
    FLOAT fDelAttrib20 = m_fRHW2 - m_fRHW0;

    // compute A & B terms (dVdX and dVdY)
    m_fRHWA = m_fTriOODet * ( fDelAttrib10 * m_fDelY20 + fDelAttrib20 * m_fDelY01 );
    m_fRHWB = m_fTriOODet * ( fDelAttrib20 * m_fDelX10 + fDelAttrib10 * m_fDelX02 );

    // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
    m_fRHWC = m_fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );

    for(INT32 i = 0; i < m_cTextureStages; i++)
    {
        m_fRHQW0[i] = pfRHQW[0];
        m_fRHQW1[i] = pfRHQW[1];
        m_fRHQW2[i] = pfRHQW[2];
        pfRHQW += 3;

        // compute linear function for Q/W (for transformed, projected, perspective corrected texture)
        fDelAttrib10 = m_fRHQW1[i] - m_fRHQW0[i];
        fDelAttrib20 = m_fRHQW2[i] - m_fRHQW0[i];

        // compute A & B terms (dVdX and dVdY)
        m_fRHQWA[i] = m_fTriOODet * ( fDelAttrib10 * m_fDelY20 + fDelAttrib20 * m_fDelY01 );
        m_fRHQWB[i] = m_fTriOODet * ( fDelAttrib20 * m_fDelX10 + fDelAttrib10 * m_fDelX02 );

        // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
        m_fRHQWC[i] = m_fRHQW0[i] - ( m_fRHQWA[i] * m_fX0 ) - ( m_fRHQWB[i] * m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
// SetPerLineData - Called once per line during setup to set per-line
// data used to compute attribute functions.
//
//-----------------------------------------------------------------------------
void
RRAttribFuncStatic::SetPerLineData(
    FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
    FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
    INT32 cTextureStages,
    FLOAT* pfRHQW,
    FLOAT fMajorExtent, BOOL bXMajor )
{
    m_PrimType = RR_LINE;

    m_fLineMajorLength = fMajorExtent;
    m_bLineXMajor = bXMajor;

    m_fX0 = fX0;
    m_fY0 = fY0;
    m_cTextureStages = cTextureStages;

    m_fRHW0 = fRHW0;
    m_fRHW1 = fRHW1;

    // compute linear function for 1/W (for perspective correction)
    FLOAT fDelta = ( m_fRHW1 - m_fRHW0 ) / m_fLineMajorLength;
    m_fRHWA = ( m_bLineXMajor ) ? ( fDelta ) : ( 0. );
    m_fRHWB = ( m_bLineXMajor ) ? ( 0. ) : ( fDelta );
    m_fRHWC = fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );
    for(INT32 i = 0; i < m_cTextureStages; i++)
    {
        m_fRHQW0[i] = pfRHQW[0];
        m_fRHQW1[i] = pfRHQW[1];
        pfRHQW += 3;

        // compute linear function for Q/W (for transformed, projected, perspective corrected texture)
        FLOAT fDelta = ( m_fRHQW1[i] - m_fRHQW0[i] ) / m_fLineMajorLength;
        m_fRHQWA[i] = ( m_bLineXMajor ) ? ( fDelta ) : ( 0. );
        m_fRHQWB[i] = ( m_bLineXMajor ) ? ( 0. ) : ( fDelta );
        m_fRHQWC[i] = m_fRHQW0[i] - ( m_fRHQWA[i] * m_fX0 ) - ( m_fRHQWB[i] * m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
// SetPixel - Called once per pixel to do preparation for per-pixel attribute
// evaluations.
//
//-----------------------------------------------------------------------------
void
RRAttribFuncStatic::SetPerPixelData( INT16 iX, INT16 iY )
{
    m_iX = iX;
    m_iY = iY;

    // evalute 1/W function
    FLOAT fPixelRHW =
        ( m_fRHWA * (FLOAT)m_iX ) + ( m_fRHWB * (FLOAT)m_iY ) + m_fRHWC;
    m_fPixelW = ( 0. != fPixelRHW ) ? ( 1./fPixelRHW ) : ( 0. );
    for(INT32 i = 0; i < m_cTextureStages; i++)
    {
        FLOAT fPixelRHQW =
            ( m_fRHQWA[i] * (FLOAT)m_iX ) + ( m_fRHQWB[i] * (FLOAT)m_iY ) + m_fRHQWC[i];
        m_fPixelQW[i] = ( 0. != fPixelRHQW ) ? ( 1./fPixelRHQW ) : ( 0. );
    }
}

//-----------------------------------------------------------------------------
//
// GetPixelW,GetPixelQW,GetRhwXGradient,GetRhwYGradient,
// GetRhqwXGradient,GetRhqwYGradient - Functions to get static
// data members.
//
//-----------------------------------------------------------------------------
FLOAT RRAttribFuncStatic::GetPixelW( void ) { return m_fPixelW; }
FLOAT RRAttribFuncStatic::GetPixelQW( INT32 iStage ) { return m_fPixelQW[iStage]; }
FLOAT RRAttribFuncStatic::GetRhqwXGradient( INT32 iStage ) { return m_fRHQWA[iStage]; }
FLOAT RRAttribFuncStatic::GetRhqwYGradient( INT32 iStage ) { return m_fRHQWB[iStage]; }


///////////////////////////////////////////////////////////////////////////////
//
// RRAttribFunc - methods
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetConstant - Sets function to evaluate to constant value.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetConstant(
    FLOAT fC )
{
    m_bIsPerspective = FALSE;
    m_fA = 0.; m_fB = 0.; m_fC = fC;
}

//-----------------------------------------------------------------------------
//
// SetLinearFunc - Computes linear function for scalar attribute specified at
// triangle vertices.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetLinearFunc(
    FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 )
{
    m_bIsPerspective = FALSE;

    switch ( m_pSD->m_PrimType )
    {
    case RR_TRIANGLE:
        {
            // compute A,B,C for triangle function

            // compute linear deltas along two edges
            FLOAT fDelAttrib10 = fVal1 - fVal0;
            FLOAT fDelAttrib20 = fVal2 - fVal0;

            // compute A & B terms (dVdX and dVdY)
            m_fA = m_pSD->m_fTriOODet *
                ( fDelAttrib10 * m_pSD->m_fDelY20 + fDelAttrib20 * m_pSD->m_fDelY01 );
            m_fB = m_pSD->m_fTriOODet *
                ( fDelAttrib20 * m_pSD->m_fDelX10 + fDelAttrib10 * m_pSD->m_fDelX02 );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = fVal0 - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );
        }
        break;

    case RR_LINE:
        {
            // compute A,B,C for line function - delta is normalized difference
            // in major direction; C is computed from knowing the function value
            // at the vertices (vertex 0 is always used here)
            FLOAT fDelta = ( fVal1 - fVal0 ) / m_pSD->m_fLineMajorLength;
            m_fA = ( m_pSD->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
            m_fB = ( m_pSD->m_bLineXMajor ) ? ( 0. ) : ( fDelta );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = fVal0 - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );
        }
        break;

    case RR_POINT:

        // use constant function for point
        m_fA = 0.;
        m_fB = 0.;
        m_fC = fVal0;

        break;
    }

}

//-----------------------------------------------------------------------------
//
// SetPerspFunc - Computes perspective corrected function for scalar attribute
// specified at triangle vertices.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetPerspFunc(
    FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 )
{
    switch ( m_pSD->m_PrimType )
    {
    case RR_TRIANGLE:
        {
            // triangle function

            // compute adjusted values for vertices 1,2 based on wrap flag
            FLOAT fVal1P = (fVal1);
            FLOAT fVal2P = (fVal2);

            // compute perspective corrected linear deltas along two edges
            FLOAT fDelAttrib10 = ( fVal1P * m_pSD->m_fRHW1 ) - ( fVal0 * m_pSD->m_fRHW0 );
            FLOAT fDelAttrib20 = ( fVal2P * m_pSD->m_fRHW2 ) - ( fVal0 * m_pSD->m_fRHW0 );

            // compute A & B terms (dVdX and dVdY)
            m_fA = m_pSD->m_fTriOODet *
                ( fDelAttrib10 * m_pSD->m_fDelY20 + fDelAttrib20 * m_pSD->m_fDelY01 );
            m_fB = m_pSD->m_fTriOODet *
                ( fDelAttrib20 * m_pSD->m_fDelX10 + fDelAttrib10 * m_pSD->m_fDelX02 );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0* m_pSD->m_fRHW0)
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_LINE:
        {
            // line function

            FLOAT fVal1P = (fVal1);
            FLOAT fDelta =
                ( fVal1P*m_pSD->m_fRHW1 - fVal0*m_pSD->m_fRHW0) / m_pSD->m_fLineMajorLength;
            m_fA = ( m_pSD->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
            m_fB = ( m_pSD->m_bLineXMajor ) ? ( 0. ) : ( fDelta );
            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0* m_pSD->m_fRHW0)
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_POINT:

        // use constant function for point
        m_fA = 0.;
        m_fB = 0.;
        m_fC = fVal0;

        // don't correct constant functions
        m_bIsPerspective = FALSE;

        break;
    }
}

//-----------------------------------------------------------------------------
//
// Eval - Evaluates function at pixel position set in RRAttribFunc::SetPerPixelData.
// Functions know if they are perspective corrected or not, and if so then do
// the multiply through by the 1/(1/w) term to normalize.
//
//-----------------------------------------------------------------------------
FLOAT
RRAttribFunc::Eval( void )
{
    FLOAT fRet =
        ( m_fA * (FLOAT)m_pSD->m_iX ) + ( m_fB * (FLOAT)m_pSD->m_iY ) + m_fC;
    if ( m_bIsPerspective ) { fRet *= m_pSD->m_fPixelW; }
    return fRet;
}

//-----------------------------------------------------------------------------
//
// SetPerspFunc - Computes perspective corrected function for scalar attribute
// specified at triangle vertices.
//
//-----------------------------------------------------------------------------
void
RRAttribFunc::SetPerspFunc(
    FLOAT fVal0, FLOAT fVal1, FLOAT fVal2,
    BOOL bWrap, BOOL bIsShadowMap )
{
    switch ( m_pSD->m_PrimType )
    {
    case RR_TRIANGLE:
        {
            // triangle function
            FLOAT fRHW0 = m_pSD->m_fRHW0;
            FLOAT fRHW1 = m_pSD->m_fRHW1;
            FLOAT fRHW2 = m_pSD->m_fRHW2;
            if (bIsShadowMap)
            {
                fRHW0 = 1.0f;
                fRHW1 = 1.0f;
                fRHW2 = 1.0f;
            }

            // compute adjusted values for vertices 1,2 based on wrap flag
            FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);
            FLOAT fVal2P = bWrap ? ( fVal0 + WrapDiff(fVal2,fVal0) ) : (fVal2);

            // compute perspective corrected linear deltas along two edges
            FLOAT fDelAttrib10 = ( fVal1P * fRHW1 ) - ( fVal0 * fRHW0 );
            FLOAT fDelAttrib20 = ( fVal2P * fRHW2 ) - ( fVal0 * fRHW0 );

            // compute A & B terms (dVdX and dVdY)
            m_fA = m_pSD->m_fTriOODet *
                ( fDelAttrib10 * m_pSD->m_fDelY20 + fDelAttrib20 * m_pSD->m_fDelY01 );
            m_fB = m_pSD->m_fTriOODet *
                ( fDelAttrib20 * m_pSD->m_fDelX10 + fDelAttrib10 * m_pSD->m_fDelX02 );

            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0 * fRHW0 )
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_LINE:
        {
            // line function

            FLOAT fRHW0 = m_pSD->m_fRHW0;
            FLOAT fRHW1 = m_pSD->m_fRHW1;
            if (bIsShadowMap)
            {
                fRHW0 = 1.0f;
                fRHW1 = 1.0f;
            }

            FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);
            FLOAT fDelta =
                ( fVal1P*fRHW1 - fVal0*fRHW0) / m_pSD->m_fLineMajorLength;
            m_fA = ( m_pSD->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
            m_fB = ( m_pSD->m_bLineXMajor ) ? ( 0. ) : ( fDelta );
            // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
            m_fC = ( fVal0* fRHW0)
                - ( m_fA * m_pSD->m_fX0 ) - ( m_fB * m_pSD->m_fY0 );

            m_bIsPerspective = TRUE;
        }
        break;

    case RR_POINT:

        // use constant function for point
        m_fA = 0.;
        m_fB = 0.;
        m_fC = fVal0;

        // don't correct constant functions
        m_bIsPerspective = FALSE;

        break;
    }
}

//-----------------------------------------------------------------------------
//
// Eval - Evaluates function at pixel position set in RRAttribFunc::SetPerPixelData.
// Functions know if they are perspective corrected or not, and if so then do
// the multiply through by the 1/(q/w) term to normalize.
//
//-----------------------------------------------------------------------------
FLOAT
RRAttribFunc::Eval( INT32 iStage )
{
    FLOAT fRet =
        ( m_fA * (FLOAT)m_pSD->m_iX ) + ( m_fB * (FLOAT)m_pSD->m_iY ) + m_fC;
    // m_bIsPerspective will always be set since persp function is always
    // used for texture coords
    if ( m_bIsPerspective ) { fRet *= m_pSD->m_fPixelQW[iStage]; }
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\attrfunc.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// AttrFunc.hpp
//
// Direct3D Reference Rasterizer - Attribute Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _ATTRFUNC_HPP
#define _ATTRFUNC_HPP

enum RRPrimType { RR_POINT, RR_LINE, RR_TRIANGLE };

//-----------------------------------------------------------------------------
//
// RRAttribFuncStatic - static data for attribute functions.  This is
// per-primitive data (as opposed to per-attribute data which is in arrays of
// RRAttribFunc objects).  This would be more elegantly done as static
// data in the RRAttribFunc class, but we need to be able to multiply instance
// the ReferenceRasterizer object and cannot have variable global state.
//
//-----------------------------------------------------------------------------
class RRAttribFuncStatic
{
private:
    RRPrimType m_PrimType;

// per-primitive data
    FLOAT m_fX0, m_fY0;         // first vertex (for initial evaluation)
    FLOAT m_fRHW0, m_fRHW1, m_fRHW2;   // 1/W data for perspective correction
    FLOAT m_fRHQW0[D3DHAL_TSS_MAXSTAGES]; // Q/W data for texture perspective correction
    FLOAT m_fRHQW1[D3DHAL_TSS_MAXSTAGES];
    FLOAT m_fRHQW2[D3DHAL_TSS_MAXSTAGES];

    FLOAT m_fDelX10, m_fDelX02; // x,y deltas
    FLOAT m_fDelY01, m_fDelY20; //

    FLOAT m_fTriOODet;          // 1/determinant for triangle function normalization

    FLOAT m_fLineMajorLength;   // major length for line function
    BOOL  m_bLineXMajor;        // TRUE if X major for line function

    FLOAT m_fRHWA, m_fRHWB, m_fRHWC;    // linear function for 1/W
    INT32 m_cTextureStages;
    FLOAT m_fRHQWA[D3DHAL_TSS_MAXSTAGES];    // linear function for texture Q/W
    FLOAT m_fRHQWB[D3DHAL_TSS_MAXSTAGES];
    FLOAT m_fRHQWC[D3DHAL_TSS_MAXSTAGES];

// per-pixel data
    INT16 m_iX, m_iY;
    FLOAT m_fPixelW;
    FLOAT m_fPixelQW[D3DHAL_TSS_MAXSTAGES];

    friend class RRAttribFunc;

public:

// Set/Get Per-primitive Data
    void SetPerTriangleData(
        FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
        FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
        FLOAT fX2, FLOAT fY2, FLOAT fRHW2,
        INT32 cTextureStages,
        FLOAT* pfRHQW,
        FLOAT fDet );
    void SetPerLineData(
        FLOAT fX0, FLOAT fY0, FLOAT fRHW0,
        FLOAT fX1, FLOAT fY1, FLOAT fRHW1,
        INT32 cTextureStages,
        FLOAT* pfRHQW,
        FLOAT fMajorExtent, BOOL bXMajor );

    void SetPerPixelData( INT16 iX, INT16 iY );

    FLOAT GetPixelW( void );
    FLOAT GetPixelQW( INT32 iStage );
    FLOAT GetRhqwXGradient( INT32 iStage );
    FLOAT GetRhqwYGradient( INT32 iStage );
};

//-----------------------------------------------------------------------------
//
// Primitive attribute function - Stores linear function of form
// `F = A*x + B*y + C'  computed during setup and used to compute primitive
// attributes at each pixel location.  One of these is used per scalar vertex
// attribute (i.e. one per Red,Green,Blue,Alpha,Z, ...)
//
//-----------------------------------------------------------------------------
class RRAttribFunc
{
private:

// pointer to static data structure
    RRAttribFuncStatic* m_pSD;

// attribute function
    FLOAT m_fA;
    FLOAT m_fB;
    FLOAT m_fC;

// flags
    BOOL  m_bIsPerspective;

public:
    void SetStaticDataPointer( RRAttribFuncStatic* pSD ) { m_pSD = pSD; }

// DEFINE
    void SetConstant( FLOAT fVal );
    void SetLinearFunc( FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 );
    void SetPerspFunc( FLOAT fVal0, FLOAT fVal1, FLOAT fVal2 );
    void SetPerspFunc( FLOAT fVal0, FLOAT fVal1, FLOAT fVal2, BOOL bWrap, BOOL bIsShadowMap );

    FLOAT GetXGradient( void ) { return m_fA; }
    FLOAT GetYGradient( void ) { return m_fB; }

// EVALUATE
    FLOAT Eval( void );
    FLOAT Eval( INT32 iStage );
};

//////////////////////////////////////////////////////////////////////////////
#endif  // _ATTRFUNC_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\cvgmask.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// cvgmask.cpp
//
// Direct3D Reference Rasterizer - Antialiasing Coverage Mask Generation
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop



#if 0

// from edgefunc.hpp
    // Normalization factor for antialising is stored in floating point.  This is
    // computed during the setup and applied per-pixel after the (non-normalized)
    // edge distance is evaluated.
    //
    DOUBLE  m_dNorm;
    INT16   m_iEdgeYGradBits;   // 1.8 fixed point

// from edgefunc.cpp ::Set
    if ( bFragProcEnable )
    {
        // compute normalization factor for antialiasing - normalizes for 'square'
        // distance (a.k.a 'manhatten' distance) such that an equidistant point
        // sweep of a distance of 0.5 is a square 1.0 pixel area.
        m_dNorm = 1.0 / ( fabs( fY0-fY1 ) + fabs( fX1-fX0 ) );

        // compute rounded fixed point Y gradient bits for generation of
        // antialiasing coverage mask
        m_iEdgeYGradBits = AS_INT16( ((fY0-fY1)*m_dNorm) + DOUBLE_8_SNAP );
    }

// from ::AATest
    // The edge evaluation is done exactly the same as the point sample case, then
    // it is converted to double precision floating point for the normalization and
    // rounding.  Using doubles makes it very easy to carry adequate precision in
    // the normalization factor and to convert to 32 bit signed integer (holding
    // the n.5 fixed point distance) with round to nearest even.
    //

    // evaluate edge distance function (n.8 fixed point)
    INT64 iEdgeDist =
        ( (INT64)m_iA * (INT64)(iX<<4) ) +  // n.4 * n.4 = n.8
        ( (INT64)m_iB * (INT64)(iY<<4) ) +  // n.4 * n.4 = n.8
        (INT64)m_iC;                        // n.8

    // convert to double (adjust for n.8 fixed point) for normalization
    // and rounding
    DOUBLE dEdgeDist = (DOUBLE)iEdgeDist * (1./(DOUBLE)(1<<8));

    // normalize edge distance
    dEdgeDist *= m_dNorm;

    // convert distance to fixed point with nearest-even round;
    // keep 5 fractional bits for antialiasing
    INT32 iEdgeDistRnd = AS_INT32( dEdgeDist + DOUBLE_5_SNAP );

    // pixel is fully outside of edge if out by +.5 or more
    if ( iEdgeDistRnd >= +(1<<4) ) return 0x0000;

    // pixel is fully inside of edge if in by -.5 or more
    if ( iEdgeDistRnd <= -(1<<4) ) return 0xFFFF;

    // here when pixel is within 1/2 (square distance) of edge
    // compute coverage mask for this edge
    return ComputeCoverageMask( m_iEdgeYGradBits, m_bAPos, m_bBPos, iEdgeDistRnd );

#endif


//-----------------------------------------------------------------------------
//
// Tables used in computation of coverage mask
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// These are the ranges of the x gradient (the 'A' of F=Ax+By+c) for one
// octant into which the edge slopes are binned.
//-----------------------------------------------------------------------------
#define A_RANGES 4
static UINT16 uARanges[A_RANGES] = {
    // 0.0.8 values
    0x00,  // 0.00
    0x40,  // 0.25
    0x55,  // 0.33
    0x66,  // 0.40
};

//-----------------------------------------------------------------------------
// These are the 16 bit coverage masks for each of the A ranges.  The
// 15 values within each range define the order in which the coverage
// mask bits are enabled, thus the least-significant index is the number
// of coverage mask bits that need to be enabled.
//-----------------------------------------------------------------------------
static UINT16 CvgMasks[A_RANGES][15] = {
    { // 0.000 .. 0.250
        0x1,
        0x3,
        0x7,
        0xF,
        0x1F,
        0x3F,
        0x7F,
        0xFF,
        0x1FF,
        0x3FF,
        0x7FF,
        0xFFF,
        0x1FFF,
        0x3FFF,
        0x7FFF,
    },
    { // 0.250 .. 0.333
        0x1,
        0x3,
        0x7,
        0x17,
        0x1F,
        0x3F,
        0x7F,
        0x17F,
        0x1FF,
        0x3FF,
        0x7FF,
        0x17FF,
        0x1FFF,
        0x3FFF,
        0x7FFF,
    },
    { // 0.333 .. 0.400
        0x1,
        0x3,
        0x13,
        0x17,
        0x37,
        0x3F,
        0x13F,
        0x17F,
        0x37F,
        0x3FF,
        0x13FF,
        0x17FF,
        0x37FF,
        0x3FFF,
        0x7FFF,
    },
    { // 0.400 .. 0.500
        0x1,
        0x3,
        0x13,
        0x17,
        0x37,
        0x137,
        0x13F,
        0x17F,
        0x37F,
        0x137F,
        0x13FF,
        0x17FF,
        0x37FF,
        0x3FFF,
        0x7FFF,
    },
};

//-----------------------------------------------------------------------------
// This table is used for a rough area approximation.  The [16] index
// is the top 4 bits of the edge distance (i.e. the distance from the
// edge to the center of the pixel).  The [4] index is the top two bits
// of the A gradient term.  The return is the number of bits that should
// be set in the coverage mask, which is a function of the area covered.
//-----------------------------------------------------------------------------
static INT16 nBitsA = 2;
static INT16 nBitsE = 4;
static INT16 nBitsToEnable[4][16] = {
    {   // A: 0.000; B: 1.000
         8,  9,  9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16,
    },
    {   // A: 0.125; B: 0.875
         8,  9,  9, 10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 16,
    },
    {   // A: 0.250; B: 0.750
         8,  9,  9, 10, 11, 11, 12, 13, 13, 14, 15, 15, 15, 16, 16, 16,
    },
    {   // A: 0.375; B: 0.625
         8,  9, 10, 10, 11, 12, 13, 13, 14, 14, 15, 15, 15, 16, 16, 16,
    },
};

//-----------------------------------------------------------------------------
//
// Mask manipulation functions - these are needed because coverage mask
// table (indexed by angle) is for one octant only and need to be
// munged in various ways for other octants
//
//-----------------------------------------------------------------------------
static void
doCvgMaskTBFlip(UINT16 &CvgMask)
{
    UINT16 CvgMaskT = CvgMask;
    CvgMask = 0;
    CvgMask |= (((CvgMaskT >>  0) & 0x1) << 12);
    CvgMask |= (((CvgMaskT >>  1) & 0x1) << 13);
    CvgMask |= (((CvgMaskT >>  2) & 0x1) << 14);
    CvgMask |= (((CvgMaskT >>  3) & 0x1) << 15);
    CvgMask |= (((CvgMaskT >>  4) & 0x1) <<  8);
    CvgMask |= (((CvgMaskT >>  5) & 0x1) <<  9);
    CvgMask |= (((CvgMaskT >>  6) & 0x1) << 10);
    CvgMask |= (((CvgMaskT >>  7) & 0x1) << 11);
    CvgMask |= (((CvgMaskT >>  8) & 0x1) <<  4);
    CvgMask |= (((CvgMaskT >>  9) & 0x1) <<  5);
    CvgMask |= (((CvgMaskT >> 10) & 0x1) <<  6);
    CvgMask |= (((CvgMaskT >> 11) & 0x1) <<  7);
    CvgMask |= (((CvgMaskT >> 12) & 0x1) <<  0);
    CvgMask |= (((CvgMaskT >> 13) & 0x1) <<  1);
    CvgMask |= (((CvgMaskT >> 14) & 0x1) <<  2);
    CvgMask |= (((CvgMaskT >> 15) & 0x1) <<  3);
}
//-----------------------------------------------------------------------------
static void
doCvgMaskSFlip(UINT16 &CvgMask)
{
    UINT16 CvgMaskT = CvgMask;
    CvgMask = 0;
    CvgMask |= (((CvgMaskT >>  0) & 0x1) <<  0);
    CvgMask |= (((CvgMaskT >>  1) & 0x1) <<  4);
    CvgMask |= (((CvgMaskT >>  2) & 0x1) <<  8);
    CvgMask |= (((CvgMaskT >>  3) & 0x1) << 12);
    CvgMask |= (((CvgMaskT >>  4) & 0x1) <<  1);
    CvgMask |= (((CvgMaskT >>  5) & 0x1) <<  5);
    CvgMask |= (((CvgMaskT >>  6) & 0x1) <<  9);
    CvgMask |= (((CvgMaskT >>  7) & 0x1) << 13);
    CvgMask |= (((CvgMaskT >>  8) & 0x1) <<  2);
    CvgMask |= (((CvgMaskT >>  9) & 0x1) <<  6);
    CvgMask |= (((CvgMaskT >> 10) & 0x1) << 10);
    CvgMask |= (((CvgMaskT >> 11) & 0x1) << 14);
    CvgMask |= (((CvgMaskT >> 12) & 0x1) <<  3);
    CvgMask |= (((CvgMaskT >> 13) & 0x1) <<  7);
    CvgMask |= (((CvgMaskT >> 14) & 0x1) << 11);
    CvgMask |= (((CvgMaskT >> 15) & 0x1) << 15);
}

//-----------------------------------------------------------------------------
//
// ComputeCoverageMask - Computes the 16 bit coverage mask.  Called once per
// pixel per crossing edge (i.e. up to 3 times per pixel).
//
// This is doing the algorithm described in Schilling's Siggraph paper, with
// modifications to perform the operation for a single virtual octant and
// then munging the result for the actual octant.
//
// Note that the A and B signs for the edges must be computed very carefully
// to guarantee that shared edges will always result in full complimentary
// coverage of pixels on the shared edge.
//
//-----------------------------------------------------------------------------
RRCvgMask
ComputeCoverageMask(
    INT16 iABits,           // 1.8 value
    BOOL bAPos, BOOL bBPos,
    INT16 iEBits)           // 1.5.5 value, but ranges from -.5 to +.5 here
{
    RRCvgMask CvgMask;    // return value

    // grab already rounded 8 bit value and take absolute value
    UINT16 uMagA = (iABits < 0) ? ((UINT16)-iABits) : ((UINT16)iABits);
    UINT16 uABits = uMagA & 0x1ff;

    // compute booleans for manipulating masks
    BOOL bMaskInvert = TRUE;
    BOOL bMaskRFlip = !(bAPos ^ bBPos);
    if (!bAPos) {
        iEBits = -iEBits;
        bMaskInvert = FALSE;
    }

    //
    // compute A offset from x or y axis
    //
    // mirror around 45 degree axis - keep track of this because
    // the 45 degree mirroring requires a side-to-side mask flip
    BOOL bMaskSFlip = (uABits > 0x80);  // > 0.5F ?
    if (bMaskSFlip)  { uABits = 0x100 - uABits; }

    // uABits is now a 0.0.8 value in the range 0x00 to 0x80

    //
    // determine number of bits to enable in mask based on the area covered
    //
    // extract bits from A for area lookup
    UINT16 uAAreaBits = (uABits == 0x80)
        ? ((1<<nBitsA)-1) : (uABits >> (7-nBitsA));

    // grab distance bits for area lookup - take absolute value and clamp
    UINT16 uEBits = (iEBits < 0) ? ((UINT16)-iEBits) : ((UINT16)iEBits);
    uEBits = MIN(uEBits,(UINT16)(((1<<nBitsE)-1))); // clamp

    // look up area in table - returns number of bits to enable
    INT16 iNumCvgBits =  nBitsToEnable[uAAreaBits][uEBits];

    // flip for negative distance
    if (iEBits < 0) { iNumCvgBits = 16 - iNumCvgBits; }

    //
    // compute slope range index and look up coverage mask
    //
    INT16 iARange = 3;
    for (INT16 i=0; i<(A_RANGES-1); i++) {
        if ((uARanges[i] <= uABits) && (uABits < uARanges[i+1])) {
            iARange = i; break;
        }
    }

    // check for zero/full coverage else look up coverage mask
    if (0 == iNumCvgBits) {
        CvgMask = 0x0000;
    } else if (16 == iNumCvgBits) {
        CvgMask = 0xffff;
    } else {
        CvgMask = CvgMasks[iARange][iNumCvgBits-1];
    }

    //
    // adjust mask for different quadrants and directions
    //
    // first to side-to-side mask flip for 45 degree mirroring
    if (bMaskSFlip)  { doCvgMaskSFlip(CvgMask); }
    // invert for 'backwards' line directions
    if (bMaskInvert) { CvgMask ^= 0xffff; }
    // flip for same sign quadrants
    if (bMaskRFlip) { doCvgMaskTBFlip(CvgMask); }

    return CvgMask;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include <ddraw.h>
#include <ddrawi.h>

#include <d3d.h>
#include <d3dhal.h>
#include "halprov.h"
#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT

#include "refrast.hpp"      // public interfaces

#include "EdgeFunc.hpp"     // edge function processing
#include "AttrFunc.hpp"     // attribute function processing
#include "refrasti.hpp"     // private interfaces
#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\maplegcy.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// MapLegcy.cpp
//
// Direct3D Reference Rasterizer - Mapping Legacy Modes to Current Functionality
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter - Map filter state from renderstate to per-stage state.
// This is invoked when a texture is bound via the TEXTUREHANDLE renderstate,
// indicating that we are in 'legacy' texture mode.  The rasterizer always
// refers to per-stage filtering control state, so in legacy mode the filtering
// controls in the renderstate are mapped into the filtering controls associated
// with the texture object bound to D3DRS_TEXTUREHANDLE.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::MapLegacyTextureFilter( void )
{
    // first check if anisotropic filtering is enabled (indicated by the
    // limit value being set to > 1) - if so then aniso filter will be used
    // for linear mag filter or 'linear within map' min filter
    BOOL bAnisoEnabled = ( m_dwRenderState[D3DRENDERSTATE_ANISOTROPY] > 1 );

    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] = D3DTFG_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] =
            bAnisoEnabled ? D3DTFG_ANISOTROPIC : D3DTFG_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTFN_ANISOTROPIC : D3DTFN_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTFN_ANISOTROPIC : D3DTFN_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTFN_ANISOTROPIC : D3DTFN_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    }
}


//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_TextureStageState[1].m_dwVal[D3DTSS_COLOROP] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        // a special legacy alpha operation is called for that depends
        // on the format of the texture
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_LEGACY_ALPHAOVR;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_ADD;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\edgefunc.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// EdgeFunc.hpp
//
// Direct3D Reference Rasterizer - Edge Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _EDGEFUNC_HPP
#define _EDGEFUNC_HPP

//-----------------------------------------------------------------------------
//
// Utility to compute determinant - must be computed in manner consistent with
// other edge function processing.
//
//-----------------------------------------------------------------------------
FLOAT
ComputeDeterminant(
    FLOAT fX0, FLOAT fY0,
    FLOAT fX1, FLOAT fY1,
    FLOAT fX2, FLOAT fY2 );

//-----------------------------------------------------------------------------
//
// Primitive edge function - Computes, stores, and evaluates linear function
// for edges.  Basic function is stored in fixed point.  Gradient sign terms
// are computed and stored separately to adhere to fill rules.
//
//-----------------------------------------------------------------------------
class RREdgeFunc
{
private:
    INT32   m_iA;       // n.4 fixed point
    INT32   m_iB;       // n.4 fixed point
    INT64   m_iC;       // n.8 fixed point
    BOOL    m_bAPos;    // carefully computed signs of A,B
    BOOL    m_bBPos;

public:
// DEFINE
    void Set(
        FLOAT fX0, FLOAT fY0, FLOAT fX1, FLOAT fY1,
        FLOAT fDet, BOOL bFragProcEnable );

// Point Sampling Test
// returns 0000=outside,  FFFF=inside
    RRCvgMask PSTest( INT16 iX, INT16 iY );

// Anti Alias test
// returns coverage mask (0000=outside, FFFF=completely inside, partial otherwise)
    RRCvgMask AATest( INT16 iX, INT16 iY );
};

//////////////////////////////////////////////////////////////////////////////
#endif  // _EDGEFUNC_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\fragrslv.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// fragrslv.cpp
//
// Direct3D Reference Rasterizer - Fragment Resolve Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// fragment resolution controls - need to expose these somehow (maybe...)
static BOOL g_bPreMultAlpha = TRUE;
static BOOL g_bDoCoverageOnly = FALSE;

//-----------------------------------------------------------------------------
//
// CountFrags - Utility to count fragments in a linked list.
//
//-----------------------------------------------------------------------------
int
CountFrags(RRFRAGMENT* pFrag)
{
    if (g_iDPFLevel < 4) { return 0; }
    int iRet = 0;
    while ( NULL != pFrag ) { pFrag = (RRFRAGMENT* )pFrag->pNext; iRet++; }
    return iRet;
}

//-----------------------------------------------------------------------------
//
// DPFFrags - Utility to debug-print fragment list.
//
//-----------------------------------------------------------------------------
void
DPFFrags(RRFRAGMENT* pFrag)
{
    if (g_iDPFLevel < 7) { return; }
    while (NULL != pFrag)
    {
        DPFM(7,FRAG,("    (%06x,%06x) %08x %f %04x\n",
            pFrag,pFrag->pNext,UINT32(pFrag->Color),FLOAT(pFrag->Depth),pFrag->CvgMask))
        pFrag = (RRFRAGMENT *)pFrag->pNext;
    }
}

//-----------------------------------------------------------------------------
//
// DoFragResolve - Invoked during the buffer-resolve for each pixel which
// has fragments.  Takes a pointer to a linked list of fragments and returns
// the resolved color.
//
// This constists of two steps: fragment sorting; and fragment resolve
// accumulation.  The fragments are sorted by stepping through the original
// linked list and moving the fragments into a new linked list (using the
// same link pointers) which is sorted in Z.
//
// The fragment resolve occurs in one of two ways depending on if any non-opaque
// fragments exist in the list (this is determined during the sort).  If there
// are only opaque fragments, then the resolve accumulation depends only on
// the coverage masks and is thus simplified.  For cases with fragments due
// to transparency, and more complex (and slower) resolve accumulation is
// performed.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoFragResolve(
    RRColor& ResolvedColor,         // out: final color for pixel
    RRDepth& ResolvedDepth,         // out: final depth for pixel
    RRFRAGMENT* pFrag,              // in: pointer to frag list for pixel
    const RRColor& CoveredColor )   // out: color of frontmost fully covered sample
{
    DPFM(7,FRAG,("    presort\n"))  DPFFrags(pFrag);
    //
    // reform fragments into sorted (front-to-back) linked list
    //
    // put first fragment into sortlist
    RRFRAGMENT* pFragSort = pFrag;
    pFrag = (RRFRAGMENT *)pFrag->pNext;
    pFragSort->pNext = NULL;
    // track if any non-opaque alphas (used to select resolve routine)
    //     init value by checking the first one (already in sort list)
    BOOL bAnyNonOpaque = ( UINT8(pFragSort->Color.A) < 0xff );
    // step thru fragment list and move each fragment into sort list
    while ( NULL != pFrag )
    {
        // check for non-opaque alpha
        if ( UINT8(pFrag->Color.A) < 0xff ) { bAnyNonOpaque = TRUE; }

        // get ptr to next here so it can be overwritten
        RRFRAGMENT* pFragNext = (RRFRAGMENT *)pFrag->pNext;

        // use this to step thru sort list and insert
        RRFRAGMENT **ppFragSortT = &pFragSort;
        while ( NULL != *ppFragSortT )
        {
            if ( DepthCloser( pFrag->Depth, (*ppFragSortT)->Depth ) )
            {
                // current frag is closer than sort list entry, so
                // before this sort entry
                pFrag->pNext = *ppFragSortT;
                *ppFragSortT = pFrag;
                break;
            }
            else if ( NULL == (*ppFragSortT)->pNext )
            {
                // if last, then insert after this sort list entry
                (*ppFragSortT)->pNext = pFrag;
                pFrag->pNext = NULL;
                break;
            }
            ppFragSortT = (RRFRAGMENT **)&((*ppFragSortT)->pNext);
        }
        // advance input frag list
        pFrag = pFragNext;
    }
    // all fragments have now been passed to sort list in front-to-back order
    DPFM(7,FRAG,("    postsort\n"))  DPFFrags(pFragSort);


    // return first sorted fragment (this is the closest, which is as good
    // as anything to put into the depth buffer for the resolved pixels...)
    ResolvedDepth = pFragSort->Depth;

    //
    // now step thru sorted list and accumulate color
    //
    if ( bAnyNonOpaque )
    {

        // here for fragment resolve accumulation which also does
        // full transparency computations - use this only if any
        // non-opaque fragments

        // instantiate and reset fragment resolve accumulator
        FragResolveAccum ResAccum;
        ResAccum.Reset();

        // per frag
        pFrag = pFragSort;
        BOOL bCovered = FALSE;
        while ( NULL != pFrag )
        {
            bCovered = ResAccum.Accum( pFrag->CvgMask, pFrag->Color );
            if (bCovered) { break; }    // fully covered, so don't do rest of frags (or background)
            pFrag = (RRFRAGMENT *)pFrag->pNext;
        }
        // add in background color (last)
        if ( !bCovered && ( UINT8(CoveredColor.A) > 0 ) )
        {
            ResAccum.Accum( TL_CVGFULL, CoveredColor );
        }

        // unload accumulator
        ResAccum.GetColor( ResolvedColor );
    }
    else
    {
        //
        // here for fragment resolve of all fully opaque fragments
        //

        //
        //     accumulated coverage and color
        //
        CVGMASK CvgMaskAccum = 0x0;
        FLOAT fRAcc = 0.F;  // these 0. to 1. range
        FLOAT fGAcc = 0.F;
        FLOAT fBAcc = 0.F;
        FLOAT fWeightAccum = 0.F;

        // per frag
        pFrag = pFragSort;
        while ( NULL != pFrag )
        {
            // compute this fragment's contribution
            CVGMASK CvgMaskContrib = pFrag->CvgMask & ~(CvgMaskAccum);
            FLOAT fWeight = (1.f/16.f) * (FLOAT)CountSetBits(CvgMaskContrib, 16);
            // accumulate rgb
            fRAcc += fWeight * FLOAT(pFrag->Color.R);
            fGAcc += fWeight * FLOAT(pFrag->Color.G);
            fBAcc += fWeight * FLOAT(pFrag->Color.B);
            // accumulate total coverage and weight
            CvgMaskAccum |= CvgMaskContrib;
            fWeightAccum += fWeight;
            // bail out early if fully covered
            if ( TL_CVGFULL == CvgMaskAccum ) { goto DoneAccumulating; }
            // next
            pFrag = (RRFRAGMENT *)pFrag->pNext;
        }

        // blend with background color/alpha
        if ( (fWeightAccum < 1.f) && ( UINT8(CoveredColor.A) > 0 ) )
        {
            // blend in remaining weight of background color
            FLOAT fWeightBg = 1.F - fWeightAccum;
            fRAcc += fWeightBg * FLOAT(CoveredColor.R);
            fGAcc += fWeightBg * FLOAT(CoveredColor.G);
            fBAcc += fWeightBg * FLOAT(CoveredColor.B);

            //  fix accumulated weight - pixel is fully covered now
            fWeightAccum = 1.f;
        }

DoneAccumulating:
        // clamp accumulators
        if ( fWeightAccum > 1.F ) { fWeightAccum = 1.F; }
        if ( fRAcc > 1.F ) { fRAcc = 1.F; }
        if ( fGAcc > 1.F ) { fGAcc = 1.F; }
        if ( fBAcc > 1.F ) { fBAcc = 1.F; }

        // set in color return
        ResolvedColor.A = fWeightAccum;
        ResolvedColor.R = fRAcc;
        ResolvedColor.G = fGAcc;
        ResolvedColor.B = fBAcc;
    }


    // free this pixel's fragments
    pFrag = pFragSort;
    while ( NULL != pFrag )
    {
        RRFRAGMENT* pFragFree = pFrag;
        pFrag = (RRFRAGMENT*)pFrag->pNext;
        FragFree( pFragFree );
    }
    return;
}

//-----------------------------------------------------------------------------
//
// DoBufferResolve - Invoked at EndScene to resolve fragments into single
// color for each pixel location.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoBufferResolve(void)
{
    DPFM(2,FRAG,("  DoBufferResolve (%d,%d)\n",m_pRenderTarget->m_iWidth,m_pRenderTarget->m_iHeight))

    // buffer may not be allocated if there were no fragments
    if (NULL == m_ppFragBuf) { return; }

    for ( int iY=0; iY < m_pRenderTarget->m_iHeight; iY++ )
    {
        for ( int iX=0; iX < m_pRenderTarget->m_iWidth; iX++ )
        {
            RRFRAGMENT* pFrag = *(m_ppFragBuf + (m_pRenderTarget->m_iWidth*iY) + iX);
            if ( NULL != pFrag )
            {
                DPFM(5,FRAG,("  DoResolve(%d,%d) %d\n",iX,iY,CountFrags(pFrag)))
                // read buffer color for background blend
                RRColor PixelColor; m_pRenderTarget->ReadPixelColor( iX,iY, PixelColor);

                // do resolve
                RRColor ResolvedColor;
                RRDepth ResolvedDepth(pFrag->Depth.GetSType());
                DoFragResolve( ResolvedColor, ResolvedDepth, pFrag, PixelColor );

                // write color back to buffer; write frontmost depth back to
                // pixel buffer (it's at least a little better than the backmost
                // opaque sample...)
                WritePixel( iX,iY, ResolvedColor, ResolvedDepth );
                // show frags freed (free happens during resolve)
                *(m_ppFragBuf + (m_pRenderTarget->m_iWidth*iY) + iX) = NULL;
            }
        }
    }
    DPFM(3,FRAG,("  DoBufferResolve - done\n"))
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Fragment Resolve Accumulator                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// FragResolveAccum - This object is the fragment resolver used when
// non-opaque fragments are present.  This has the effect of resolving
// each of the 16 subpixel locations independently to produce the fully
// correct result.  Several optimizations are used to minimize the actual
// number of accumulation computations that need to occur.
//

//-----------------------------------------------------------------------------
//
// Reset - Called prior to resolving a list of fragments to initialize the
// internal state.
//
//-----------------------------------------------------------------------------
void
FragResolveAccum::Reset(void)
{
    DPFM(5, FRAG, ("  FragResolveAccum: reset\n"))
    m_ArrayUsageMask = 0x0001;  // use first array entry only (at first)
    m_CvgArray[0].Mask = TL_CVGFULL;
    m_CvgArray[0].fAlpha = 1.;
    m_fA = 0.;
    m_fR = 0.;
    m_fG = 0.;
    m_fB = 0.;
    m_CvgOpaqueMask = 0x0000;
}

//-----------------------------------------------------------------------------
//
// Accum - Called for each fragment.  Fragments must be accumulated in front-
// to-back order (sort is done prior to accumulation).
//
// Returns TRUE if full coverage has been achieved and thus subsequent
// fragments will have no further contribution to the final pixel color and
// opacity.
//
//-----------------------------------------------------------------------------
BOOL
FragResolveAccum::Accum(
    const CVGMASK CvgMask,
    const RRColor& ColorFrag)
{
    DPFM(6, FRAG, ("  FragResolveAccum: accum %04x %08x\n",
        CvgMask, UINT32(ColorFrag) ) )

    FLOAT fAlphaFrag = FLOAT(ColorFrag.A);

    // exit (don't accum) if all covered
    if (TL_CVGFULL == m_CvgOpaqueMask)  { return TRUE; }

    // controls for doing (up to) 4 accumulations at a time
    INT32 iAccumsDeferred = 0;  // the current number of deferred accumulations
    FLOAT fColorScaleAccum;     // the accumulated color scale for the deferred accums

    // compute ArrayCheck - each set bit indicates a coverage mask
    // bit for which an accumulation needs to be done (indicated by
    // a valid entry in the coverage array which is not opaque and
    // for which the corresponding bit is set in this fragment's
    // coverage mask)
    CVGMASK ArrayCheck = 0x0;
    for (INT32 i=0; i<16; i++)
    {
        if  (m_CvgArray[i].Mask & CvgMask)
        {
            ArrayCheck |= ((0x1 << i) & ~(m_CvgOpaqueMask));
        }
    }

    INT32 iIdx;
    CVGMASK ArrayMaskT = m_ArrayUsageMask;
    while (0x0 != ArrayMaskT)
    {
        // track from MSB to LSB of usage mask
        iIdx = FindLastSetBit(ArrayMaskT,TL_CVGBITS);
        ArrayMaskT &= ~(0x1 << iIdx);

        // compute masks for overlapped coverage (requiring
        // accumulation) and non-overlapped area (which may
        // require an updated coverage/alpha entry)
        CVGMASK AccumCvgMask = m_CvgArray[iIdx].Mask & CvgMask;
        CVGMASK UpdateCvgMask = m_CvgArray[iIdx].Mask & ~CvgMask;

        // remove bits in the overlapped coverage mask for subsamples
        // which already have opaque alphas
        AccumCvgMask &= ~(m_CvgOpaqueMask);

        // read alpha old here - the location that this is stored
        // may be changed in the accumulate step but needs to be
        // remembered for the update (non-covered area) step
        FLOAT fAlphaOld = m_CvgArray[iIdx].fAlpha;

        // compute alpha scale value - this is used to scale color
        // for accumulation and to compute updated alpha for overlap
        FLOAT fAlphaScale = fAlphaOld * fAlphaFrag;

        // new alpha for overlapped area (this cannot go negative
        // since 0 < AlphaScale < AlphaOld)
        // AlphaNext = AlphaOld(1 - Alpha) = AlphaOld - AlphaOld*Alpha =
        FLOAT fAlphaNext = fAlphaOld - fAlphaScale;

        if (0x0 != AccumCvgMask)
        {
            // contribution to accumulate - this is the portion
            // the previous mask starting at the uIdx bit location
            // which is covered by the new fragment, so accumulate
            // this coverage and update the mask and alpha
            UINT32 iIdxT = FindFirstSetBit(AccumCvgMask,TL_CVGBITS);
            m_ArrayUsageMask |= (0x1 << iIdxT);
            m_CvgArray[iIdxT].Mask = AccumCvgMask;

            // set the alpha of the overlapped area
            m_CvgArray[iIdxT].fAlpha = fAlphaNext;

            // compute scale for color channels - depends on if
            // we want pre-multiplied alphas or not...
            //
            // base for scale is either array value alone or product
            // of array value and Afrag (AlphaScale)
            FLOAT fColorScaleBase = (g_bPreMultAlpha) ? (fAlphaOld) : (fAlphaScale);

            // do either multiply or bypass for full coverage
            FLOAT fColorScale = fColorScaleBase;
            if ( TL_CVGFULL != AccumCvgMask )
            {
                FLOAT fCvgFraction =
                    (FLOAT)(CountSetBits(AccumCvgMask, TL_CVGBITS)) * (1./TL_CVGBITS);
                fColorScale *= fCvgFraction;
            }

            // accumulate up to four accumulations to do at once - the accumulated
            // value is the color scale to be applied to the multiple locations

            // update color scale accum - either set (1st deferral) or
            // accumulate (subsequent deferrals)
            fColorScaleAccum = (0 == iAccumsDeferred) ?
                (fColorScale) : (fColorScale + fColorScaleAccum);

            // track number of deferrals and bypass accumulation if not
            // up to 4 (or if this is the last one)
            if ( (++iAccumsDeferred != 4) &&
                 (0x0 != (ArrayMaskT & ArrayCheck)) )
            {
                goto _update_CvgMask_Location;
            }

            // start over on deferral
            iAccumsDeferred = 0;

            // clamp color scale to max before accumulation
            fColorScale = MIN( fColorScaleAccum, 1. );

            // do accumulation and write back to accumulator

            // decide what to use for alpha accumulate - if we are using
            // pre-multiplied alphas, then AFrag is not incorporated into
            // color scale, thus mult by AFrag
            FLOAT fAPartial = fColorScale * ( (g_bPreMultAlpha) ? (fAlphaFrag) : (1.) );
            FLOAT fRPartial = fColorScale * FLOAT(ColorFrag.R);
            FLOAT fGPartial = fColorScale * FLOAT(ColorFrag.G);
            FLOAT fBPartial = fColorScale * FLOAT(ColorFrag.B);

            m_fA += fAPartial;
            m_fR += fRPartial;
            m_fG += fGPartial;
            m_fB += fBPartial;
        }

_update_CvgMask_Location:

        if (0x0 != UpdateCvgMask)
        {
            // mask to update - this is the portion of the
            // previous mask starting at the uIdx bit location
            // which is still visible, so update the coverage
            // (the alpha stays the same)
            UINT32 iIdxT = FindFirstSetBit(UpdateCvgMask,TL_CVGBITS);
            m_ArrayUsageMask |= (0x1 << iIdxT);
            m_CvgArray[iIdxT].Mask = UpdateCvgMask;
            m_CvgArray[iIdxT].fAlpha = fAlphaOld;
        }
    }

    // determine if this new fragment is has an opaque alpha
    // if so then update opaque mask - this must be done after
    // the accumulations because the opaque mask refers to the
    // current state of the coverage array and should apply only to
    // accumulations of subsequent fragments
    //
    // g_bDoCoverageOnly overrides this to always act as if fragments'
    // alphas are opaque for the purposes of generating antialiased
    // shadow attenuation surfaces
    {
        if ((fAlphaFrag >= 1.) || (g_bDoCoverageOnly))
            { m_CvgOpaqueMask |= CvgMask; }
    }

    // check opaque mask for return boolean - returns TRUE if we
    // are done
    return (TL_CVGFULL == m_CvgOpaqueMask) ? (TRUE) : (FALSE);
}

//-----------------------------------------------------------------------------
//
// GetColor - Called after accumulating a series of fragments to get the final
// pixel color and alpha.
//
//-----------------------------------------------------------------------------
void
FragResolveAccum::GetColor( RRColor& Color )
{
    // clamp and assign for return
    Color.A = (FLOAT)MIN( m_fA, 1. );
    Color.R = (FLOAT)MIN( m_fR, 1. );
    Color.G = (FLOAT)MIN( m_fG, 1. );
    Color.B = (FLOAT)MIN( m_fB, 1. );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\edgefunc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// EdgeFunc.cpp
//
// Direct3D Reference Rasterizer - Edge Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// ComputeDeterminant - Computes triangle determinant for later use in edge
// functions.  Computed in fixed point but returned as single precision
// floating point number.
//
//-----------------------------------------------------------------------------
FLOAT
ComputeDeterminant(
    FLOAT fX0, FLOAT fY0,
    FLOAT fX1, FLOAT fY1,
    FLOAT fX2, FLOAT fY2 )
{
    // compute determinant with integer coordinates snapped to n.4 grid
    INT32 iDelX10 =
        AS_INT32( (DOUBLE)(fX1) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fX0) + DOUBLE_4_SNAP );
    INT32 iDelX02 =
        AS_INT32( (DOUBLE)(fX0) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fX2) + DOUBLE_4_SNAP );
    INT32 iDelY01 =
        AS_INT32( (DOUBLE)(fY0) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fY1) + DOUBLE_4_SNAP );
    INT32 iDelY20 =
        AS_INT32( (DOUBLE)(fY2) + DOUBLE_4_SNAP ) -
        AS_INT32( (DOUBLE)(fY0) + DOUBLE_4_SNAP );

    // iDet is n.8 fixed point value (n.4 * n.4 = n.8)
    INT64 iDet =
        ( (INT64)iDelX10 * (INT64)iDelY20 ) -
        ( (INT64)iDelX02 * (INT64)iDelY01 );

    // convert to float for return
    FLOAT fDet = (1./(FLOAT)(1<<8)) * (FLOAT)iDet;

    return fDet;
}

//-----------------------------------------------------------------------------
//
// Set - Computes edge function and associated information.
//
// Fragment processing boolean is passed to enable use of better techniques
// than the simple but not particularly good subpixel point sample done here.
//
//-----------------------------------------------------------------------------
void
RREdgeFunc::Set(
    FLOAT fX0, FLOAT fY0, FLOAT fX1, FLOAT fY1,
    FLOAT fDet, BOOL bFragProcEnable )
{
    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    INT32 iX0 = AS_INT32( (DOUBLE)fX0 + DOUBLE_4_SNAP );
    INT32 iY0 = AS_INT32( (DOUBLE)fY0 + DOUBLE_4_SNAP );
    INT32 iX1 = AS_INT32( (DOUBLE)fX1 + DOUBLE_4_SNAP );
    INT32 iY1 = AS_INT32( (DOUBLE)fY1 + DOUBLE_4_SNAP );

    // compute A,B (gradient) terms - these are n.4 fixed point
    m_iA = iY0 - iY1;
    m_iB = iX1 - iX0;

    // flip gradient signs if backfacing so functions are consistently
    // greater than zero outside of primitive
    if ( fDet > 0. ) { m_iA = -m_iA; m_iB = -m_iB; }

    // compute C term
    //
    // function is by definition zero at the vertices, so:
    //     0 = A*Xv + B*Yv + C  =>  C = - A*Xv - B*Yv
    //
    // A*Xv & B*Yv are n.4 * n.4 = n.8, so C is n.8 fixed point
    m_iC = - ( (INT64)iX0 * (INT64)m_iA ) - ( (INT64)iY0 * (INT64)m_iB );

    // compute edge function sign flags - must be done consistently for vertical
    // and horizontal cases to adhere to point sample fill rules and avoid
    // under- and over-coverage for antialiasing
    BOOL bEdgeAEQZero = ( m_iA == 0. );
    BOOL bEdgeBEQZero = ( m_iB == 0. );
    BOOL bEdgeAGTZero = ( m_iA > 0. );
    BOOL bEdgeBGTZero = ( m_iB > 0. );
    m_bAPos = bEdgeAEQZero ? bEdgeBGTZero : bEdgeAGTZero;
    m_bBPos = bEdgeBEQZero ? bEdgeAGTZero : bEdgeBGTZero;
}

//-----------------------------------------------------------------------------
//
// PSTest - Point sampling test, returns coverage mask of all zero's if point
// is outside the edge, all 1's if point is inside.  Supports the Direct3D
// left-top fill rule.
//
//-----------------------------------------------------------------------------
RRCvgMask
RREdgeFunc::PSTest( INT16 iX, INT16 iY )
{
    // evaluate edge distance function (n.8 fixed point)
    INT64 iEdgeDist =
        ( (INT64)m_iA * (INT64)(iX<<4) ) +  // n.4 * n.4 = n.8
        ( (INT64)m_iB * (INT64)(iY<<4) ) +  // n.4 * n.4 = n.8
        (INT64)m_iC;                        // n.8

    // pixel sample position is outside edge if distance is > zero
    //
    // This implements the D3D left-top fill rule
    //
    // For exactly-on-edge case (distance == zero), the sign of the Y gradient
    // is used to determine if the pixel is to be considered inside or outside
    // of the edge. For the non-horizontal case, the m_bAPos bit is based
    // simply on the sign of the Y slope.  This implements the 'left' part of
    // the 'left-top' rule.
    //
    // For the horizontal case,  the sign of the B gradient (X slope) is taken
    // into account in the computation of the m_bAPos bit when the A gradient
    // is exactly zero, which forces a pixel exactly on a 'top' edge to be
    // considered in and a pixel exactly on a 'bottom' edge to be considered out.
    //
    if ( ( iEdgeDist > 0 ) || ( ( iEdgeDist == 0 ) && m_bAPos ) )
    {
        // pixel is out
        return 0x0000;
    }
    // pixel is in
    return 0xFFFF;
}

//-----------------------------------------------------------------------------
//
// AATest - Anti alias edge test, returns coverage mask of all zero's if point
// is outside the edge, all 1's if point is inside, and partial if point is on
// or near the edge.
//
//-----------------------------------------------------------------------------
RRCvgMask
RREdgeFunc::AATest( INT16 iX, INT16 iY )
{
    RRCvgMask Mask = 0;

    // n.4 integer representation of pixel center
    INT64 iX64Center = (INT64)(iX<<4);
    INT64 iY64Center = (INT64)(iY<<4);

    // step across 4x4 subpixel sample points and point sample 16 locations
    // to form coverage mask; area is split into eights to center samples
    // around pixel center (for example, the two inner sample positions are
    // each 1/8 of a pixel distance from the pixel center, and thus 1/4 of
    // a pixel distance apart)
    INT32 iYSub, iYEightths, iXSub, iXEightths;
    for (iYSub = 0, iYEightths = -3; iYSub < 4; iYSub++, iYEightths += 2)
    {
        for (iXSub = 0, iXEightths = -3; iXSub < 4; iXSub++, iXEightths += 2)
        {
            // compute sample location, which is some n/8 offset from the
            // pixel center (+/- 3/8 or 1/8)
            INT64 iX64 = iX64Center + (iXEightths<<1);
            INT64 iY64 = iY64Center + (iYEightths<<1);
            INT64 iEdgeDist =
                ( (INT64)m_iA * iX64 ) +    // n.4 * n.4 = n.8
                ( (INT64)m_iB * iY64 ) +    // n.4 * n.4 = n.8
                (INT64)m_iC;                // n.8

            // if the center is in (same left-top rule as in point sample)
            if (!( ( iEdgeDist > 0 ) || ( ( iEdgeDist == 0 ) && m_bAPos ) ))
            {
                // pixel is in
                Mask |= 1 << (iXSub + iYSub*4);
            }
        }
    }

    return Mask;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\fragproc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// fragproc.cpp
//
// Direct3D Reference Rasterizer - Fragment Processing Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//
// Fragments are managed by a separate 'surface' of fragment pointers which
// form an (initially empty) linked list of fragment structures for each pixel.
//
// The fragment management consists of generating fragments for partially
// covered pixels (either due to coverage mask or non-opaque alpha), and
// freeing fragments which are obscurred by a fully covered pixel in
// front of them.
//
// The fragment generation occurs when a new pixel is partially covered.
// If the pixel location already has at least one fragment, then a fragment
// merge is attempted.  This merge is attempted with the fragment most recently
// added to the pixel (at the front of the linked list), which has the best
// chance of merging since it is most likely to be from the same object.
// The merge tests the Z and color values, and if they are within a threshold
// then the new fragmented pixel's contribution is OR'd into the existing
// fragment instead of generating a new fragment.  The depth merge criteria is
// an absolute value compare.  The color merge criteria is done with a bitmask
// (because ripping apart the color into channels for the value compare is too
// expensive).  Set bits in bitmask FRAGMERGE_COLORDIFF_MASK are bits for which
// the two colors must match.  This actually works pretty well...
//
// If the merge fails, then a new fragment is allocated, filled out, and added
// to the linked list for this pixel location.
//
// If the merge results in a fully covered pixel, then the fragment is freed
// and the fragment's color and depth are written to the color/depth buffers.
//

//
// controls for fragment merging
//

// TODO - not sure that merge works correctly right now...
//#define DO_FRAGMERGE

// mask for crude (but fast) color differencing - this is not so fast now
// that colors are stored as floats...
#define FRAGMERGE_COLORDIFF_MASK 0xe0c0e0c0

// depth difference must be less than this for merge to occur
FLOAT g_fFragMergeDepthThreshold = 1.F/(FLOAT)(1<<16);

//-----------------------------------------------------------------------------
//
// DoFragmentGenerationProcessing - Does initial work of generating a fragment
// buffer entry (if appropriate) and filling it out.  Also attempts fragment
// merge.
//
// Returns TRUE if processing for this pixel is complete.
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::DoFragmentGenerationProcessing( RRPixel& Pixel )
{
    // TRUE if pixel is geometrically partially covered
    BOOL bDoFragCvg = ( TL_CVGFULL != Pixel.CvgMask );
    // TRUE if pixel is partially covered due to transparency
    BOOL bDoFragTransp = FALSE;
    if ( m_dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] )
    {
        // only generate fragments for transparency if
        // D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT is enabled and the
        // alpha is less than the threshold
        bDoFragTransp = ( UINT8(Pixel.Color.A) < g_uTransparencyAlphaThreshold );
    }
    else
    {
        // so we won't use alpha for determining transparency in fragment resolve
        Pixel.Color.A = 1.0F;
    }

    // get pointer to fragment list for this pixel location - may be NULL due to
    // deferred allocation of fragment buffer
    RRFRAGMENT** ppFrag = (NULL == m_ppFragBuf) ? (NULL)
        : (m_ppFragBuf + (m_pRenderTarget->m_iWidth*Pixel.iY) + Pixel.iX);

    if ( bDoFragCvg || bDoFragTransp )
    {
        // get pointer to pointer to first fragment in linked list for this pixel
        if (NULL == m_ppFragBuf)
        {
            // do (deferred) allocation of fragment pointer buffer - clear this
            // initially and it will always be cleared during the fragment resolve process
            size_t cbBuf = sizeof(RRFRAGMENT*)*m_pRenderTarget->m_iWidth*m_pRenderTarget->m_iHeight;
            // allocate fragment pointer buffer for rendering core - clear initially
            m_ppFragBuf = (RRFRAGMENT**)MEMALLOC( cbBuf );
            _ASSERTa( NULL != m_ppFragBuf, "malloc failure on RRFRAGMENT pointer buffer",
                return FALSE; );
            memset( m_ppFragBuf, 0x0, cbBuf );
            // ppFrag only not set if (NULL == m_ppFragBuf)
            ppFrag = (m_ppFragBuf + (m_pRenderTarget->m_iWidth*Pixel.iY) + Pixel.iX);
        }


#ifdef  DO_FRAGMERGE
        // try to do fragment merge
        if ( NULL != (*ppFrag) )
        {
            // check if new depth is close enough to depth of first frag in list
            FLOAT fDepthDiff = fabs( FLOAT((*ppFrag)->Depth) - FLOAT(Pixel.Depth) );
            BOOL bDepthClose = ( fDepthDiff < g_fFragMergeDepthThreshold );

            // check if new color is close enough to color of first frag in list
            UINT32 uARGBSame = ~( UINT32(Pixel.Color) ^ UINT32((*ppFrag)->Color) );
            BOOL bColorClose = ( FRAGMERGE_COLORDIFF_MASK == ( uARGBSame & FRAGMERGE_COLORDIFF_MASK ) );

            if ( bDepthClose && bColorClose )
            {
                m_pStt->cFragsMerged++;

                // here to do merge
                CVGMASK FirstFragCvgMask =  (*ppFrag)->CvgMask;
                CVGMASK MergedCvgMask = FirstFragCvgMask | Pixel.CvgMask;

                // check for merge to full coverage
                if ( ( TL_CVGFULL == MergedCvgMask ) && !bDoFragTransp )
                {
                    m_pStt->cFragsMergedToFull++;
                    // free first fragment
                    RRFRAGMENT* pFragFree = (*ppFrag);    // keep ptr to frag to free
                    (*ppFrag) = (RRFRAGMENT*)(*ppFrag)->pNext;  // set buffer to point to next
                    FragFree( pFragFree);

                    // now need to write this pixel into pixel buffer, so return
                    // FALSE so pixel processing will continue
                    return FALSE;
                }
                else
                {
                    // mask not full, so update first frag's cm and done
                    (*ppFrag)->CvgMask = MergedCvgMask;
                    // done with this pixel
                    return TRUE;
                }
            }
            // else fall into allocating new frag
        }
#endif
        // allocate and fill fragment
        RRFRAGMENT* pFragNew = FragAlloc();
        if ( NULL == pFragNew ) { return FALSE; }
        pFragNew->Color = Pixel.Color;
        pFragNew->Depth = Pixel.Depth;
        pFragNew->CvgMask = Pixel.CvgMask;
        // insert at front of list (before fragment we're looking at)
        pFragNew->pNext = (void*)(*ppFrag);
        (*ppFrag) = pFragNew;

        // done with this pixel
        return TRUE;
    }

    // not done with this pixel
    return FALSE;
}

//-----------------------------------------------------------------------------
//
// DoFragmentBufferFixup - Routine to free fragments which are behind
// fully covered sample just written into the pixel buffer.  This minimizes
// the total number of fragment needed for a scene.  This step involves walking
// the linked list and freeing fragments behind the pixel about to be written.
// This also simplifies the fragment resolve since the Z buffer is not needed
// (all fragments are known to be in front of the fully-covered sample in the
// color/Z buffer).
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoFragmentBufferFixup( const RRPixel& Pixel )
{
    // get pointer to fragment list for this pixel location - may be NULL due to
    // deferred allocation of fragment buffer
    RRFRAGMENT** ppFrag = (NULL == m_ppFragBuf)
        ? (NULL)
        : (m_ppFragBuf + (m_pRenderTarget->m_iWidth*Pixel.iY) + Pixel.iX);

    //
    // walk fragment array to free fragments behind covered sample
    //
    if ( NULL != ppFrag )
    {
        while ( NULL != (*ppFrag) )
        {
            if ( DepthCloser( Pixel.Depth, (*ppFrag)->Depth ) )
            {
                // covered sample is closer than fragment, so free the frag
                RRFRAGMENT* pFragFree = (*ppFrag);    // keep ptr to frag to free
                (*ppFrag) = (RRFRAGMENT*)(*ppFrag)->pNext;   // remove from list
                // ppFrag now points to a pointer to the next frag
                FragFree( pFragFree );
            }
            else
            {
                // advance pointer to point to pointer to next frag
                ppFrag = (RRFRAGMENT **)&((*ppFrag)->pNext);
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Fragment Allocation Methods                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// These methods are used by the pixel engine and fragment resolver to
// allocate and free fragments.
//

//-----------------------------------------------------------------------------
//
// Allocates a single fragment record, returning pointer
//
//-----------------------------------------------------------------------------
RRFRAGMENT*
ReferenceRasterizer::FragAlloc( void )
{
    RRFRAGMENT* pFrag = (RRFRAGMENT*)MEMALLOC( sizeof(RRFRAGMENT) );
    _ASSERTa( NULL != pFrag, "malloc failed on RRFRAGMENT", return NULL; );

    // update stats
    m_pStt->cFragsAllocd++;
    if (m_pStt->cFragsAllocd > m_pStt->cMaxFragsAllocd ) { m_pStt->cMaxFragsAllocd = m_pStt->cFragsAllocd; }

    return pFrag;
}

//-----------------------------------------------------------------------------
//
// Frees a single fragment record
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::FragFree( RRFRAGMENT* pFrag )
{
    MEMFREE( pFrag );

    // update stats
    m_pStt->cFragsAllocd--;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\refrasti.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrasti.cpp
//
// Direct3D Reference Rasterizer - Main Internal Object Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// global controls                                                              //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

// alpha needs to be less than this for a pixel  to be considered non-opaque
UINT8 g_uTransparencyAlphaThreshold = 0xff;


//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// ReferenceRasterizer Methods                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Overload new & delete for core object so that it can be allocated from
// caller-controlled pool
//
//-----------------------------------------------------------------------------
void*
ReferenceRasterizer::operator new(size_t)
{
    void* pMem = (void*)MEMALLOC( sizeof(ReferenceRasterizer) );
    _ASSERTa( NULL != pMem, "malloc failure on RR object", return NULL; );
    return pMem;
}
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::operator delete(void* pv,size_t)
{
    MEMFREE( pv );
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor for renderer core object.
//
//-----------------------------------------------------------------------------
ReferenceRasterizer::ReferenceRasterizer( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                                          DWORD dwInterfaceType,
                                          RRDEVICETYPE dwDriverType )
{
    memset( this, 0, sizeof(*this) );

    // allocate scan converter state and statistics
    m_pSCS = (RRSCANCNVSTATE*)MEMALLOC( sizeof( *m_pSCS ) );
    m_pStt = (RRSTATS*)MEMALLOC( sizeof( *m_pStt ) );

    _ASSERTa( ( NULL != m_pSCS ) && ( NULL != m_pStt),
        "malloc failure on ReferenceRasterizer object", return; );

    // associate the (single) static attribute data structure with each attribute
    // function instance
    int i, j;
    for ( i = 0; i < RR_N_ATTRIBS; i++ )
    {
        m_pSCS->AttribFuncs[i].SetStaticDataPointer( &(m_pSCS->AttribFuncStatic) );
    }
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( j = 0; j < RR_N_TEX_ATTRIBS; j++)
        {
            m_pSCS->TextureFuncs[i][j].SetStaticDataPointer( &(m_pSCS->AttribFuncStatic) );
        }
    }

    // this is zero'ed above, so just set the 1.0 elements
    // of the identity matrices
    //
    //  0  1  2  3
    //  4  5  6  7
    //  8  9 10 11
    // 12 13 14 15
    //
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+0] = 1.0f;
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+5] = 1.0f;
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+10] = 1.0f;
        m_TextureStageState[i].m_fVal[D3DTSSI_MATRIX+15] = 1.0f;
    }

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    m_dwInterfaceType = dwInterfaceType;
    m_dwDriverType = dwDriverType;
    m_pDDLcl = pDDLcl;

    // defer allocating and clearing of fragment pointer buffer until fragments
    // are actually generated
    m_ppFragBuf = NULL;

    // Texture handles
    m_ppTextureArray = NULL;
    m_dwTexArrayLength = 0;

    // StateOverride initialize
    STATESET_INIT( m_renderstate_override );

    // Initialize TL state and Data
    InitTLData();

    SetSetStateFunctions();

    ClearTexturesLocked();
}
//-----------------------------------------------------------------------------
ReferenceRasterizer::~ReferenceRasterizer( void )
{
    MEMFREE( m_ppFragBuf );
    MEMFREE( m_pSCS);
    MEMFREE( m_pStt);

    // Clean up statesets
    for (DWORD i = 0; i < m_pStateSets.ArraySize(); i++)
    {
        if (m_pStateSets[i] != NULL)
            delete m_pStateSets[i];
    }

    // Free the Light Array
    if (m_pLightArray) delete m_pLightArray;

    // Free the Texture Array
    for (i = 0; i<m_dwTexArrayLength; i++)
    {
        RRTexture* pTex = m_ppTextureArray[i];
        if (pTex) delete pTex;
    }
    if (m_ppTextureArray) delete m_ppTextureArray;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// State Management Utilities                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// MapTextureHandleToDevice - This is called when texture handles change or
// when leaving legacy texture mode.  This maps the texture handle embedded
// in the per-stage state to texture object pointers.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::MapTextureHandleToDevice( int iStage )
{
    // map one
    m_pTexture[iStage] =
        MapHandleToTexture( m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] );

    // initialize m_pStageState pointer in texture
    if (m_pTexture[iStage])
    {
        m_pTexture[iStage]->m_pStageState = &m_TextureStageState[0];
    }

    // update num active stages
    UpdateActiveTexStageCount();
}


//-----------------------------------------------------------------------------
//
// GrowTexArray - On DX7.
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::GrowTexArray( DWORD dwTexHandle )
{
    DWORD dwNewArraySize = dwTexHandle+16;
    RRTexture **ppTmpTexArray =
        (RRTexture **)MEMALLOC( dwNewArraySize*sizeof(RRTexture*) );
    if (ppTmpTexArray == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    memset( ppTmpTexArray, 0, dwNewArraySize*sizeof(RRTexture*) );

    // Save all the textures
    for (DWORD i=0; i<m_dwTexArrayLength; i++)
    {
        ppTmpTexArray[i] = m_ppTextureArray[i];
    }

    if (m_ppTextureArray)
    {
        delete m_ppTextureArray;
    }
    m_ppTextureArray = ppTmpTexArray;
    m_dwTexArrayLength = dwNewArraySize;
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// SetTextureHandle - On DX7, this is called when a texture handle is set.
// This maps the texture handle embedded in the per-stage state to texture
// object pointers.
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::SetTextureHandle( int iStage, DWORD dwTexHandle )
{
    HRESULT hr = D3D_OK;

    // Special case, if texture handle == 0, then unmap the texture from the TSS
    if (dwTexHandle == 0)
    {
        m_pTexture[iStage] = NULL;

        // update num active stages
        UpdateActiveTexStageCount();
        return D3D_OK;
    }

    //
    // If the texture handle is greater than the length of the array,
    // the array needs to be grown.
    //
    if (dwTexHandle >= m_dwTexArrayLength)
    {
        HR_RET(GrowTexArray( dwTexHandle ));
    }

    // Ask DDraw to decipher what this particular handle meant wrt. to the
    // the DDraw_Local associated with this instance of the Refrast
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = NULL;
    BOOL bIsNew = FALSE;
    pDDSLcl = GetDDSurfaceLocal(m_pDDLcl, dwTexHandle, &bIsNew);

    //
    // If the particular array element is NULL it means that the
    // texture has not yet been created.
    //
    if (m_ppTextureArray[dwTexHandle] == NULL)
    {
        if (TextureCreate(dwTexHandle, &m_ppTextureArray[dwTexHandle])
            == FALSE)
        {
            return DDERR_OUTOFMEMORY;
        }

        HR_RET(m_ppTextureArray[dwTexHandle]->Initialize( pDDSLcl ));
    }
    // This means that the texture bound to the dwHandle is not the
    // same as what Refrast thinks it is, hence revalidate everything
    else if (bIsNew)
    {
        HR_RET(m_ppTextureArray[dwTexHandle]->Initialize( pDDSLcl ));
    }

    // map one
    m_pTexture[iStage] = m_ppTextureArray[dwTexHandle];

    // initialize m_pStageState pointer in texture
    if (m_pTexture[iStage])
    {
#if DBG
        int iTexCount = 0;
        for (int i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
        {
            if (m_pTexture[iStage] == m_pTexture[i])
            {
                iTexCount ++;
            }
        }
        if (iTexCount > 1)
        {
            DPFM(0,RAST,("Same texture handle was used more than once.\n"))
        }
#endif
        m_pTexture[iStage]->m_pStageState = &m_TextureStageState[0];
    }

    // update num active stages
    UpdateActiveTexStageCount();
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Steps through per-stage renderstate and computes
// a count of currently active texture stages.  For legacy texture, the count
// is always one.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::UpdateActiveTexStageCount( void )
{
    // always one active texture stage for legacy texture mode
    if ( NULL != m_dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
    {
        m_cActiveTextureStages = 1; return;
    }

    // count number of contiguous-from-zero active texture blend stages
    m_cActiveTextureStages = 0;
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        // check fir disabled stage (subsequent are thus inactive)
        if ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }

        // check for incorrectly enabled stage (may be legacy)
        if ( ( m_pTexture[iStage] == NULL ) &&
             ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG1] == D3DTA_TEXTURE ) )
        {
            break;
        }

        // stage is active
        m_cActiveTextureStages++;
    }
}

//-----------------------------------------------------------------------------
//
// MapHandleToTexture - Map handle to RRTexture pointer.  Handle is a ppTex,
// so test it and reference it.
//
//-----------------------------------------------------------------------------
RRTexture*
ReferenceRasterizer::MapHandleToTexture( D3DTEXTUREHANDLE hTex )
{
    if ( 0x0 == hTex ) { return NULL; }
    return ( *(RRTexture**)ULongToPtr(hTex) );
}


///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\pixproc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pixproc.cpp
//
// Direct3D Reference Rasterizer - Pixel Processor
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// DoPixel - Invoked for each pixel by the scan converter, applies texture,
// specular, fog, alpha blend, and writes result to surface.  Also implements
// depth, alpha, and stencil tests.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoPixel( RRPixel& Pixel )
{

    // apply texture (includes lookup&filter and blending)
    if ( m_cActiveTextureStages > 0 )
    {
        RRColor TexturedColor = Pixel.Color;
        DoTexture( Pixel, TexturedColor );
        Pixel.Color = TexturedColor;

        // check colorkey
        for (INT32 i = 0; i < m_cActiveTextureStages; i++)
        {
            if ( NULL != m_pTexture[i] )
            {
                // kill pixel if colorkey killing and any samples matched
                if ( m_pTexture[i]->m_bDoColorKeyKill &&
                     m_pTexture[i]->m_bColorKeyMatched )
                {
                    return;
                }
            }
        }
    }


    // do alpha test - bail out if failed
    if ( m_dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] &&
         !AlphaTest( Pixel.Color.A ) )
    {
        return;
    }

    // add specular and saturate
    if ( m_dwRenderState[D3DRENDERSTATE_SPECULARENABLE] )
    {
        Pixel.Color.R += Pixel.Specular.R;
        Pixel.Color.G += Pixel.Specular.G;
        Pixel.Color.B += Pixel.Specular.B;
        Pixel.Color.R = minimum( 1.f, Pixel.Color.R );
        Pixel.Color.G = minimum( 1.f, Pixel.Color.G );
        Pixel.Color.B = minimum( 1.f, Pixel.Color.B );
    }

    // apply fog
    if ( m_dwRenderState[D3DRENDERSTATE_FOGENABLE] )
    {
        // get RRColor version of fog color
        RRColor FogColor = m_dwRenderState[D3DRENDERSTATE_FOGCOLOR];

        // do fog blend
        // (TODO: account for pre-multiplied alpha here??)
        RRColorComp ObjColorFrac = Pixel.FogIntensity;  // f
        RRColorComp FogColorFrac = ~Pixel.FogIntensity; // 1. - f
        Pixel.Color.R = (ObjColorFrac * Pixel.Color.R) + (FogColorFrac * FogColor.R);
        Pixel.Color.G = (ObjColorFrac * Pixel.Color.G) + (FogColorFrac * FogColor.G);
        Pixel.Color.B = (ObjColorFrac * Pixel.Color.B) + (FogColorFrac * FogColor.B);

        // NOTE: this can be done with a single (signed) multiply as
        //   (f)*Cp + (1-f)*Cf = f*(Cp-Cf) + Cf
    }

    //
    // read current depth for this pixel and do depth test - cannot
    // bail out if failed because stencil may need to be updated
    //
    RRDepth BufferDepth(Pixel.Depth.GetSType());
    BOOL bDepthTestPassed = TRUE;
    if ( m_dwRenderState[D3DRENDERSTATE_ZENABLE] )
    {
        m_pRenderTarget->ReadPixelDepth( Pixel.iX, Pixel.iY, BufferDepth );
        bDepthTestPassed = DepthCloser( Pixel.Depth, BufferDepth );
    }

    //
    // do stencil operation
    //
    BOOL bStencilTestPassed = TRUE;
    if ( m_dwRenderState[D3DRENDERSTATE_STENCILENABLE] )
    {
        // read stencil buffer and do stencil operation
        UINT8 uStncBuf = 0x0;
        m_pRenderTarget->ReadPixelStencil( Pixel.iX, Pixel.iY, uStncBuf );
        UINT8 uStncNew;
        bStencilTestPassed = DoStencil( uStncBuf, bDepthTestPassed, Pixel.Depth.GetSType(), uStncNew );

        // update stencil only if changed
        if ( uStncNew != uStncBuf )
        {
            // compute new buffer value based on write mask
            UINT8 uStncWMask = m_dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK];
            UINT8 uStncBufNew = (uStncBuf & ~uStncWMask) | (uStncNew & uStncWMask);
            m_pRenderTarget->WritePixelStencil( Pixel.iX, Pixel.iY, uStncBufNew );
        }
    }

    if ( !(bDepthTestPassed && bStencilTestPassed) )
    {
        return;
    }

    //
    // do fragment generation processing - this is done prior to alpha blend
    // somewhat arbitrarily because fragment generation and incremental alpha
    // blending are mutually exclusive (blending of fragments requires multipass
    // and fragment matching to get the correct result - fragment matching is
    // not implemented here yet)  (TODO: fragment matching)
    //
    // this may or may not complete the processing of this pixel
    //
    if ( m_bFragmentProcessingEnabled )
    {
        if ( DoFragmentGenerationProcessing( Pixel ) ) { return; }
    }

    //
    // do alpha blend
    //
    if ( m_dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] )
    {
        RRColor BufferColor;
        m_pRenderTarget->ReadPixelColor( Pixel.iX, Pixel.iY, BufferColor );
        DoAlphaBlend( Pixel.Color, BufferColor, Pixel.Color );
    }

    //
    // update color and depth buffers
    //
    WritePixel( Pixel.iX, Pixel.iY, Pixel.Color, Pixel.Depth );

    // additional fragment processing associated with buffer write
    if ( m_bFragmentProcessingEnabled ) { DoFragmentBufferFixup( Pixel ); }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Processing Utility Functions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Depth compare method used for Z buffering and fragment processing.
//
// Returns TRUE if DepthVal is closer than DepthBuf.  DepthA is the generated
// value and DepthB
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::DepthCloser(
    const RRDepth& DepthVal,
    const RRDepth& DepthBuf )
{
    if ( !m_dwRenderState[D3DRENDERSTATE_ZENABLE] ) { return TRUE; }


    switch ( m_dwRenderState[D3DRENDERSTATE_ZFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return ( DOUBLE(DepthVal) <  DOUBLE(DepthBuf) );
    case D3DCMP_EQUAL:        return ( DOUBLE(DepthVal) == DOUBLE(DepthBuf) );
    case D3DCMP_LESSEQUAL:    return ( DOUBLE(DepthVal) <= DOUBLE(DepthBuf) );
    case D3DCMP_GREATER:      return ( DOUBLE(DepthVal) >  DOUBLE(DepthBuf) );
    case D3DCMP_NOTEQUAL:     return ( DOUBLE(DepthVal) != DOUBLE(DepthBuf) );
    case D3DCMP_GREATEREQUAL: return ( DOUBLE(DepthVal) >= DOUBLE(DepthBuf) );
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// Alpha test method for pixel processing.
//
// Returns TRUE if alpha test passes.
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::AlphaTest( const RRColorComp& Alpha )
{
    // grab 8 bit unsigned alpha value
    UINT8 uAlpha = UINT8( Alpha );

    // form 8 bit alpha reference value
    UINT8 uAlphaRef8 = m_dwRenderState[D3DRENDERSTATE_ALPHAREF];

    // do alpha test and either return directly or pass through
    switch ( m_dwRenderState[D3DRENDERSTATE_ALPHAFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return (uAlpha <  uAlphaRef8);
    case D3DCMP_EQUAL:        return (uAlpha == uAlphaRef8);
    case D3DCMP_LESSEQUAL:    return (uAlpha <= uAlphaRef8);
    case D3DCMP_GREATER:      return (uAlpha >  uAlphaRef8);
    case D3DCMP_NOTEQUAL:     return (uAlpha != uAlphaRef8);
    case D3DCMP_GREATEREQUAL: return (uAlpha >= uAlphaRef8);
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoStencil - Performs stencil test.  Returns TRUE if stencil test passed.
// Also computes stencil result value (to be written back to stencil planes
// if test passes, subject to stencil write mask).
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::DoStencil(
    UINT8 uStncBuf,     // in: stencil buffer value
    BOOL bDepthTest,    // in: boolean result of depth test
    RRSurfaceType DepthSType,   // in: surface type of Z buffer
    UINT8& uStncRet)    // out: stencil value result
{
    // support 8 bit stencil only, so do everything as UINT8's

    // get reference from renderstate
    UINT8 uStncRef = (UINT8)(m_dwRenderState[D3DRENDERSTATE_STENCILREF]);

    // form masked values for test
    UINT8 uStncMask = (UINT8)(m_dwRenderState[D3DRENDERSTATE_STENCILMASK]);
    UINT8 uStncBufM = uStncBuf & uStncMask;
    UINT8 uStncRefM = uStncRef & uStncMask;
    // max value for saturation ops
    UINT8 uStncMax;
    switch(DepthSType)
    {
    case RR_STYPE_Z24S8:
    case RR_STYPE_S8Z24: uStncMax = 0xff; break;
    case RR_STYPE_Z15S1:
    case RR_STYPE_S1Z15: uStncMax = 0x1;  break;
    case RR_STYPE_Z24S4:
    case RR_STYPE_S4Z24: uStncMax = 0xf;  break;
    default:             uStncMax = 0;    break;  // don't let stencil become non 0
    }

    // do stencil compare function
    BOOL bStncTest = FALSE;
    switch ( m_dwRenderState[D3DRENDERSTATE_STENCILFUNC] )
    {
    case D3DCMP_NEVER:        bStncTest = FALSE; break;
    case D3DCMP_LESS:         bStncTest = (uStncRefM <  uStncBufM); break;
    case D3DCMP_EQUAL:        bStncTest = (uStncRefM == uStncBufM); break;
    case D3DCMP_LESSEQUAL:    bStncTest = (uStncRefM <= uStncBufM); break;
    case D3DCMP_GREATER:      bStncTest = (uStncRefM >  uStncBufM); break;
    case D3DCMP_NOTEQUAL:     bStncTest = (uStncRefM != uStncBufM); break;
    case D3DCMP_GREATEREQUAL: bStncTest = (uStncRefM >= uStncBufM); break;
    case D3DCMP_ALWAYS:       bStncTest = TRUE; break;
    }

    // determine which stencil operation to perform
    DWORD dwStencilOp;
    if ( !bStncTest )
    {
        // stencil test failed - depth test does not matter
        dwStencilOp = m_dwRenderState[D3DRENDERSTATE_STENCILFAIL];
    }
    else
    {
        // stencil test passed - select based on depth pass/fail
        dwStencilOp = ( !bDepthTest )
            ? ( m_dwRenderState[D3DRENDERSTATE_STENCILZFAIL] )
            : ( m_dwRenderState[D3DRENDERSTATE_STENCILPASS] );
    }

    uStncRet = 0x0;
    switch ( dwStencilOp )
    {
    case D3DSTENCILOP_KEEP:    uStncRet = uStncBuf; break;
    case D3DSTENCILOP_ZERO:    uStncRet = 0x00; break;
    case D3DSTENCILOP_REPLACE: uStncRet = uStncRef; break;
    case D3DSTENCILOP_INCRSAT:
        uStncRet = (uStncBuf==uStncMax)?(uStncMax):(uStncBuf+1); break;
    case D3DSTENCILOP_DECRSAT:
        uStncRet = (uStncBuf==0x00)?(0x00):(uStncBuf-1); break;
    case D3DSTENCILOP_INVERT:  uStncRet = ~uStncBuf; break;
    case D3DSTENCILOP_INCR:    uStncRet = uStncBuf+1; break;
    case D3DSTENCILOP_DECR:    uStncRet = uStncBuf-1; break;
    }

    return bStncTest;
}

//-----------------------------------------------------------------------------
//
// DoAlphaBlend - Performs color blending of source and destination colors
// producing a result color.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoAlphaBlend(
    const RRColor& SrcColor,    // in: source pixel color
    const RRColor& DstColor,    // in: destination (buffer) color
    RRColor& ResColor)          // out: result (blended) color
{
    RRColor SrcColorFactor;
    RRColor DstColorFactor;
    BOOL bDestBlendOverride = FALSE;

    // compute source blend factors
    switch ( m_dwRenderState[D3DRENDERSTATE_SRCBLEND] )
    {

    default:
    case D3DBLEND_ZERO:
        SrcColorFactor.SetAllChannels( 0.F );
        break;

    case D3DBLEND_ONE:
        SrcColorFactor.SetAllChannels( 1.F );
        break;

    case D3DBLEND_SRCCOLOR:
        SrcColorFactor.R = SrcColor.R;
        SrcColorFactor.G = SrcColor.G;
        SrcColorFactor.B = SrcColor.B;
        SrcColorFactor.A = SrcColor.A;
        break;

    case D3DBLEND_INVSRCCOLOR:
        SrcColorFactor.R = ~SrcColor.R;
        SrcColorFactor.G = ~SrcColor.G;
        SrcColorFactor.B = ~SrcColor.B;
        SrcColorFactor.A = ~SrcColor.A;
        break;

    case D3DBLEND_SRCALPHA:
        SrcColorFactor.SetAllChannels( SrcColor.A );
        break;

    case D3DBLEND_INVSRCALPHA:
        SrcColorFactor.SetAllChannels( ~SrcColor.A );
        break;

    case D3DBLEND_DESTALPHA:
        SrcColorFactor.SetAllChannels( DstColor.A );
        break;

    case D3DBLEND_INVDESTALPHA:
        SrcColorFactor.SetAllChannels( ~DstColor.A );
        break;

    case D3DBLEND_DESTCOLOR:
        SrcColorFactor.R = DstColor.R;
        SrcColorFactor.G = DstColor.G;
        SrcColorFactor.B = DstColor.B;
        SrcColorFactor.A = DstColor.A;
        break;

    case D3DBLEND_INVDESTCOLOR:
        SrcColorFactor.R = ~DstColor.R;
        SrcColorFactor.G = ~DstColor.G;
        SrcColorFactor.B = ~DstColor.B;
        SrcColorFactor.A = ~DstColor.A;
        break;

    case D3DBLEND_SRCALPHASAT:
        {
            RRColorComp F = minimum( SrcColor.A, ~DstColor.A );
            SrcColorFactor.R = F;
            SrcColorFactor.G = F;
            SrcColorFactor.B = F;
        }
        SrcColorFactor.A = 1.F;
        break;

    // these are for SRCBLEND only and override DESTBLEND
    case D3DBLEND_BOTHSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( SrcColor.A );
        DstColorFactor.SetAllChannels( ~SrcColor.A );
        break;

    case D3DBLEND_BOTHINVSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( ~SrcColor.A );
        DstColorFactor.SetAllChannels( SrcColor.A );
        break;
    }

    // compute destination blend factors
    if ( !bDestBlendOverride )
    {
        switch ( m_dwRenderState[D3DRENDERSTATE_DESTBLEND] )
        {

        default:
        case D3DBLEND_ZERO:
            DstColorFactor.SetAllChannels( 0.F );
            break;

        case D3DBLEND_ONE:
            DstColorFactor.SetAllChannels( 1.F );
            break;

        case D3DBLEND_SRCCOLOR:
            DstColorFactor.R = SrcColor.R;
            DstColorFactor.G = SrcColor.G;
            DstColorFactor.B = SrcColor.B;
            DstColorFactor.A = SrcColor.A;
            break;

        case D3DBLEND_INVSRCCOLOR:
            DstColorFactor.R = ~SrcColor.R;
            DstColorFactor.G = ~SrcColor.G;
            DstColorFactor.B = ~SrcColor.B;
            DstColorFactor.A = ~SrcColor.A;
            break;

        case D3DBLEND_SRCALPHA:
            DstColorFactor.SetAllChannels( SrcColor.A );
            break;

        case D3DBLEND_INVSRCALPHA:
            DstColorFactor.SetAllChannels( ~SrcColor.A );
            break;

        case D3DBLEND_DESTALPHA:
            DstColorFactor.SetAllChannels( DstColor.A );
            break;

        case D3DBLEND_INVDESTALPHA:
            DstColorFactor.SetAllChannels( ~DstColor.A );
            break;

        case D3DBLEND_DESTCOLOR:
            DstColorFactor.R = DstColor.R;
            DstColorFactor.G = DstColor.G;
            DstColorFactor.B = DstColor.B;
            DstColorFactor.A = DstColor.A;
            break;

        case D3DBLEND_INVDESTCOLOR:
            DstColorFactor.R = ~DstColor.R;
            DstColorFactor.G = ~DstColor.G;
            DstColorFactor.B = ~DstColor.B;
            DstColorFactor.A = ~DstColor.A;
            break;

        case D3DBLEND_SRCALPHASAT:
            {
                RRColorComp F = minimum( SrcColor.A, ~DstColor.A );
                DstColorFactor.R = F;
                DstColorFactor.G = F;
                DstColorFactor.B = F;
            }
            DstColorFactor.A = 1.F;
            break;
        }
    }

    // apply blend factors to update pixel color
    ResColor.R = (SrcColorFactor.R * SrcColor.R) + (DstColorFactor.R * DstColor.R);
    ResColor.G = (SrcColorFactor.G * SrcColor.G) + (DstColorFactor.G * DstColor.G);
    ResColor.B = (SrcColorFactor.B * SrcColor.B) + (DstColorFactor.B * DstColor.B);
    ResColor.A = (SrcColorFactor.A * SrcColor.A) + (DstColorFactor.A * DstColor.A);

    // clamp result
    ResColor.R = minimum( 1.f, maximum( 0.f, ResColor.R ) );
    ResColor.G = minimum( 1.f, maximum( 0.f, ResColor.G ) );
    ResColor.B = minimum( 1.f, maximum( 0.f, ResColor.B ) );
    ResColor.A = minimum( 1.f, maximum( 0.f, ResColor.A ) );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\pixref.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// PixRef.cpp
//
// Direct3D Reference Rasterizer - Pixel Buffer Referencing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

extern int g_DXTBlkSize[];

//-----------------------------------------------------------------------------
//
// PixelAddress - Form character address of locations within buffers using base
// pointer, pitch and type.
//
//-----------------------------------------------------------------------------
char*
PixelAddress( int iX, int iY, char* pBits, int iYPitch, RRSurfaceType SType )
{
    // initialize return value to start of scan line (pitch is always in bytes)
    char* pPixAddr = pBits + iY*iYPitch;

    // bump along scan line depending on surface type to point to pixel data
    switch ( SType )
    {
    default:
        _ASSERTa(0, "Unknown RRSurfaceType value", return NULL;);
    case RR_STYPE_NULL:
        break;

    case RR_STYPE_B8G8R8A8:
    case RR_STYPE_B8G8R8X8:
    case RR_STYPE_Z24S8:
    case RR_STYPE_S8Z24:
    case RR_STYPE_Z24S4:
    case RR_STYPE_S4Z24:
    case RR_STYPE_Z32S0:
        pPixAddr += iX*4;
        break;

    case RR_STYPE_B5G6R5:
    case RR_STYPE_B5G5R5:
    case RR_STYPE_B5G5R5A1:
    case RR_STYPE_L8A8:
    case RR_STYPE_U8V8:
    case RR_STYPE_U5V5L6:
    case RR_STYPE_Z16S0:
    case RR_STYPE_Z15S1:
    case RR_STYPE_S1Z15:
    case RR_STYPE_B4G4R4A4:
    case RR_STYPE_YUY2:
    case RR_STYPE_UYVY:
    case RR_STYPE_B2G3R3A8:
        pPixAddr += iX*2;
        break;

    case RR_STYPE_B8G8R8:
    case RR_STYPE_U8V8L8:
        pPixAddr += iX*3;
        break;

    case RR_STYPE_PALETTE8:
    case RR_STYPE_L8:
    case RR_STYPE_B2G3R3:
    case RR_STYPE_L4A4:
        pPixAddr += iX;
        break;

    case RR_STYPE_PALETTE4:
        pPixAddr += (iX>>1);
        break;

    // For the DXT texture formats, obtain the address of the
    // block from whih to decompress the texel from
    case RR_STYPE_DXT1:
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        pPixAddr = pBits + (iY >> 2)*iYPitch + (iX>>2) *
            g_DXTBlkSize[(int)SType - (int)RR_STYPE_DXT1];
        break;
    }
    return pPixAddr;
}

//-----------------------------------------------------------------------------
//
// WritePixel - Writes pixel and (maybe) depth to current render target.
//
//  called by ReferenceRasterizer::DoPixel
//        and ReferenceRasterizer::DoBufferResolve
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::WritePixel(
    INT32 iX, INT32 iY,
    const RRColor& Color, const RRDepth& Depth)
{
    m_pRenderTarget->WritePixelColor( iX, iY, Color,
        m_dwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    // don't write if Z buffering disabled or Z write disabled
    if ( !( m_dwRenderState[D3DRENDERSTATE_ZENABLE     ] ) ||
         !( m_dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] ) ) { return; }

    m_pRenderTarget->WritePixelDepth( iX, iY, Depth );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\refrast.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrast.cpp
//
// Direct3D Reference Rasterizer - public interface
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// This is a global static array of the block sizes in bytes for the
// various S3 compression formats
int g_DXTBlkSize[NUM_DXT_FORMATS] =
{
    sizeof(DXTBlockRGB),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha3),
    sizeof(DXTBlockAlpha3),
};

//-----------------------------------------------------------------------------
//
// Memory management function installation
//
//-----------------------------------------------------------------------------

//  global pointers to memory allocation functions (used through MEM* macros)
LPVOID (__cdecl *g_pfnMemAlloc)( size_t size ) = NULL;
void   (__cdecl *g_pfnMemFree)( LPVOID lptr ) = NULL;
LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size ) = NULL;

// install memory management functions - must be called before instancing
// rasterizer object
void RefRastSetMemif(
    LPVOID(__cdecl *pfnMemAlloc)(size_t),
    void(__cdecl *pfnMemFree)(LPVOID),
    LPVOID(__cdecl *pfnMemReAlloc)(LPVOID,size_t))
{
    DPFRR(1, "RefRastSetMemif %08x %08x %08x\n",
        pfnMemAlloc,pfnMemFree,pfnMemReAlloc);
    g_pfnMemAlloc = pfnMemAlloc;
    g_pfnMemFree = pfnMemFree;
    g_pfnMemReAlloc = pfnMemReAlloc;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Interface Methods                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetRenderTarget -
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetRenderTarget( RRRenderTarget* pRenderTarget )
{
    m_pRenderTarget = pRenderTarget;

    // update the W scaling values for mapping interpolated W's into buffer range
    m_fWBufferNorm[0] = pRenderTarget->m_fWRange[0];
    FLOAT fWRange = pRenderTarget->m_fWRange[1] - pRenderTarget->m_fWRange[0];
    m_fWBufferNorm[1] = ( 0. != fWRange ) ? ( 1./fWRange ) : ( 1. );

    // free fragment buffer array - will reallocate with new size when needed
    if (pRenderTarget->m_iWidth != m_iFragBufWidth ||
        pRenderTarget->m_iHeight != m_iFragBufHeight)
    {
        MEMFREE( m_ppFragBuf ); m_ppFragBuf = NULL;
        m_iFragBufWidth = pRenderTarget->m_iWidth;
        m_iFragBufHeight = pRenderTarget->m_iHeight;
    }
}

//-----------------------------------------------------------------------------
//
// SetTextureStageState -
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetTextureStageState(
    DWORD dwStage, DWORD dwStageState, DWORD dwValue )
{
    // check for range before continuing
    if ( dwStage >= D3DHAL_TSS_MAXSTAGES )
    {
        return;
    }
    if ( dwStageState > D3DTSS_MAX )
    {
        return;
    }

    // set in internal per-stage state
    m_TextureStageState[dwStage].m_dwVal[dwStageState] = dwValue;

    switch ( dwStageState )
    {

    case D3DTSS_TEXTUREMAP:

        // bind texture indicated by handle to m_pTexture array
        if (IsDriverDX6AndBefore() || IsInterfaceDX6AndBefore())
        {
            // This is the legacy behavior (prev. to DX7)
            MapTextureHandleToDevice( dwStage );
        }
        else
        {
            // This is the new behavior (DX7 and beyond)
            SetTextureHandle( dwStage, dwValue );
        }
        break;

    case D3DTSS_COLOROP:
        // may need to recompute count of active textures based on COLOROP change
        UpdateActiveTexStageCount();
        break;

    case D3DTSS_ADDRESS:
        // map single set ADDRESS to both U and V controls
        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
    }
}

//-----------------------------------------------------------------------------
//
// TextureCreate - Instantiates new RRTexture object, computes texture handle
// to associate with it, and returns both to caller.  Note that texture handle
// is a pointer and can be used to get at the corresponding texture object.
//
// TODO: this is not 64 bit clean
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::TextureCreate(
    LPD3DTEXTUREHANDLE phTex, RRTexture** ppTex )
{
    // allocate internal texture structure
    *ppTex = new RRTexture( );
    _ASSERTa( NULL != *ppTex, "new failure on texture create", return FALSE; );

    // use separately allocated pointer for handle
    RRTexture** ppTexForHandle = (RRTexture**)MEMALLOC( sizeof(RRTexture*) );
    _ASSERTa( NULL != ppTexForHandle, "malloc failure on texture create", return FALSE; );
    *ppTexForHandle = *ppTex;

    // return texture handle
    (*ppTex)->m_hTex = (ULONG_PTR)ppTexForHandle;
    *phTex = (*ppTex)->m_hTex;

    return TRUE;
}
//-----------------------------------------------------------------------------
//
// TextureCreate -
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::TextureCreate(
    DWORD dwHandle, RRTexture** ppTex )
{
    // allocate internal texture structure
    *ppTex = new RRTexture( );
    _ASSERTa( NULL != *ppTex, "new failure on texture create", return FALSE; );

    // assign texture handle
    (*ppTex)->m_hTex = dwHandle;

    return TRUE;
}
//-----------------------------------------------------------------------------
//
// TextureDestroy -
//
//-----------------------------------------------------------------------------
BOOL
ReferenceRasterizer::TextureDestroy( D3DTEXTUREHANDLE hTex )
{
    // first check if texture about to be destroyed is mapped - if so then
    // unmap it
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        if ( hTex == m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] )
        {
            SetTextureStageState( iStage, D3DTSS_TEXTUREMAP, 0x0 );
        }
    }

    // resolve handle to RRTexture pointer
    RRTexture* pTex = MapHandleToTexture( hTex );
    if ( NULL == pTex ) { return FALSE; }

    // free the handle pointer
    RRTexture** ppTex = (RRTexture**)ULongToPtr(hTex);
    if ( NULL != ppTex) { MEMFREE( ppTex ); }

    // free the RRTexture
    delete pTex;

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// TextureGetSurf -
//
//-----------------------------------------------------------------------------
DWORD
ReferenceRasterizer::TextureGetSurf( D3DTEXTUREHANDLE hTex )
{
    RRTexture* pTex = MapHandleToTexture(hTex);
    if ( NULL == pTex ) { return 0x0; }
    return (ULONG_PTR)( pTex->m_pDDSLcl[0] );
}

//-----------------------------------------------------------------------------
//
// GetCurrentTextureMaps - This function fills in a passed array texture handles
// and pointers.  The array should be sized by D3DHAL_TSS_MAXSTAGES.
//
// This is used to facilitate external locking/unlocking of surfaces used for
// textures.
//
//-----------------------------------------------------------------------------
int
ReferenceRasterizer::GetCurrentTextureMaps(
    D3DTEXTUREHANDLE *phTex, RRTexture** pTex)
{
    UpdateActiveTexStageCount();

    for ( int i=0; i<m_cActiveTextureStages; i++ )
    {
        if ( NULL == m_pTexture[i] )
        {
            phTex[i] = 0x0;
            pTex[i] = NULL;
        }
        else
        {
            phTex[i] = m_pTexture[i]->m_hTex;
            pTex[i] = m_pTexture[i];
        }
    }
    return m_cActiveTextureStages;
}


//-----------------------------------------------------------------------------
//
// SceneCapture - Used to trigger fragment buffer resolve.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SceneCapture( DWORD dwFlags )
{
    switch (dwFlags)
    {
    case D3DHAL_SCENE_CAPTURE_START:
        break;
    case D3DHAL_SCENE_CAPTURE_END:
        DoBufferResolve();
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Query functions to get pointer to current render target and render state.
//
//-----------------------------------------------------------------------------
RRRenderTarget*
ReferenceRasterizer::GetRenderTarget(void)
{
    return m_pRenderTarget;
}
//-----------------------------------------------------------------------------
DWORD*
ReferenceRasterizer::GetRenderState(void)
{
    return &(m_dwRenderState[0]);
}
//-----------------------------------------------------------------------------
DWORD*
ReferenceRasterizer::GetTextureStageState(DWORD dwStage)
{
    return &(m_TextureStageState[dwStage].m_dwVal[0]);
}

//-----------------------------------------------------------------------------
//
// Begin/End bracket functions - Called before/after a list of primitives are
// rendered.
//
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::BeginRendering( DWORD dwFVFControl )
{
    // set FVF control word - this specifies the vertex types for this
    // begin/end sequence
    if ( dwFVFControl )
    {
        m_qwFVFControl = dwFVFControl;
    }
    else
    {
        // Legacy TLVERTEX's
        m_qwFVFControl = D3DFVF_TLVERTEX;
    }

    // set colorkey enable
    for (INT32 i = 0; i < m_cActiveTextureStages; i++)
    {
        if ( m_pTexture[i] != NULL )
        {
            m_pTexture[i]->m_bDoColorKeyKill = FALSE;
            m_pTexture[i]->m_bDoColorKeyZero = FALSE;
            if ( m_pTexture[i]->m_uFlags & RR_TEXTURE_HAS_CK)
            {
                if ( m_dwRenderState[D3DRENDERSTATE_COLORKEYBLENDENABLE] )
                {
                    m_pTexture[i]->m_bDoColorKeyZero = TRUE;
                }
                else
                {
                    if ( m_dwRenderState[D3DRENDERSTATE_COLORKEYENABLE] )
                    {
                        m_pTexture[i]->m_bDoColorKeyKill = TRUE;
                    }
                }
            }
        }
    }

#ifdef _X86_
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSave
            mov ax, wSave
            or ax, 300h    ;; extended precision mode
            mov wTemp, ax
            fldcw   wTemp
        }
        m_wSaveFP = wSave;
    }
#endif

    m_bInBegin = TRUE;
    return S_OK;
}
//-----------------------------------------------------------------------------
HRESULT
ReferenceRasterizer::EndRendering( void )
{
    if ( m_bInBegin )
    {

#ifdef _X86_
        // restore floating point mode
        {
            WORD wSave = m_wSaveFP;
            __asm {fldcw   wSave}
        }
#endif

        m_bInBegin = FALSE;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
HRESULT ReferenceRasterizer::Clear(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);
    WORD i;
    INT32 x,y;
    RRColor fillColor(pData->dwFillColor);
    RRDepth fillDepth(m_pRenderTarget->m_DepthSType);

    fillDepth = pData->dvFillDepth;

#ifdef _X86_
    // Float to integer conversion routines for 24+ bit buffers work
    // only with extended FPU mode.
    //
    WORD wSaveFP;
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSaveFP
            mov ax, wSaveFP
            or ax, 300h    ;; extended precision mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#endif

    if(pData->dwFlags & D3DCLEAR_TARGET)
    {
        if (m_dwRenderState[D3DRENDERSTATE_DITHERENABLE] == FALSE)
        {
            m_pRenderTarget->Clear(fillColor, pCmd);
        }
        else
        {
            for (i = 0; i < pCmd->wStateCount; i++)
            {
                for (y = pData->Rects[i].top; y < pData->Rects[i].bottom; ++y)
                {
                    for (x = pData->Rects[i].left; x < pData->Rects[i].right; ++x)
                    {
                        m_pRenderTarget->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }


    switch (pData->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))
    {
    case (D3DCLEAR_ZBUFFER):
        m_pRenderTarget->ClearDepth(fillDepth, pCmd);
        break;
    case (D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearStencil(pData->dwFillStencil, pCmd);
        break;
    case (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearDepthStencil(fillDepth, pData->dwFillStencil, pCmd);
        break;
    }

#ifdef _X86_
    // restore floating point mode
    {
        __asm {fldcw   wSaveFP}
    }
#endif
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::Clear(RRColor fillColor, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);
    UINT32 dwColor = 0;
    fillColor.ConvertTo( m_ColorSType, 0.5f, (char*)&dwColor);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pColorBufBits, m_iColorBufPitch, m_ColorSType );
        switch ( m_ColorSType )
        {
        case RR_STYPE_B8G8R8A8:
        case RR_STYPE_B8G8R8X8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = dwColor;
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;

        case RR_STYPE_B8G8R8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = ((UINT8*)&dwColor)[0];
                        *p++ = ((UINT8*)&dwColor)[1];
                        *p++ = ((UINT8*)&dwColor)[2];
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;

        case RR_STYPE_B4G4R4A4:
        case RR_STYPE_B5G6R5:
        case RR_STYPE_B5G5R5A1:
        case RR_STYPE_B5G5R5:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT16)dwColor;
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;

        case RR_STYPE_B2G3R3:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT8)dwColor;
                    }
                    pSurface += m_iColorBufPitch;
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::ClearDepth(RRDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType);
        switch (m_DepthSType)
        {
        case RR_STYPE_Z16S0:
            {
                UINT16 Depth = UINT16(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z24S8:
        case RR_STYPE_Z24S4:
            {
                UINT32 Depth = UINT32(fillDepth) << 8;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xffffff00)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S8Z24:
        case RR_STYPE_S4Z24:
            {
                UINT32 Depth = UINT32(fillDepth) & 0x00ffffff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x00ffffff)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z15S1:
            {
                UINT16 Depth = UINT16(fillDepth) << 1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xfffe)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S1Z15:
            {
                UINT16 Depth = UINT16(fillDepth) & 0x7fff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x7fff)) | Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z32S0:
            {
                UINT32 Depth = UINT32(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the stencil buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::ClearStencil(UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType);
        switch (m_DepthSType)
        {
        case RR_STYPE_Z24S8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S8Z24:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)&pSurface[3];
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z24S4:
            {
                UINT32 stencil = uStencil & 0xf;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x000000ff)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S4Z24:
            {
                UINT32 stencil = (uStencil & 0xf) << 24;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0xff000000)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z15S1:
            {
                UINT16 stencil = uStencil & 0x1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x0001)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_S1Z15:
            {
                UINT16 stencil = uStencil << 15;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x8000)) | stencil;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z16S0:
        case RR_STYPE_Z32S0:
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth and stencil buffers
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RRRenderTarget::ClearDepthStencil(RRDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = pData->Rects[i].right - x0;
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType);
        switch (m_DepthSType)
        {
        case RR_STYPE_Z16S0:
        case RR_STYPE_Z32S0:
            break;
        case RR_STYPE_Z24S8:
        case RR_STYPE_S8Z24:
        case RR_STYPE_Z24S4:
        case RR_STYPE_S4Z24:
            {
                UINT32 v;
                switch (m_DepthSType)
                {
                case RR_STYPE_Z24S8: v = (UINT32(fillDepth) << 8) + uStencil;    break;
                case RR_STYPE_S8Z24: v = (UINT32(fillDepth)  & 0x00ffffff) + (uStencil << 24); break;
                case RR_STYPE_Z24S4: v = (UINT32(fillDepth) << 8) + (uStencil & 0xf);  break;
                case RR_STYPE_S4Z24: v = (UINT32(fillDepth) & 0x00ffffff) + ((uStencil & 0xf) << 24); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        case RR_STYPE_Z15S1:
        case RR_STYPE_S1Z15:
            {
                UINT16 v;
                switch (m_DepthSType)
                {
                case RR_STYPE_Z15S1:    v = (UINT16(fillDepth) << 1) + (uStencil & 0x1); break;
                case RR_STYPE_S1Z15:    v = (UINT16(fillDepth) & 0x7fff) + (uStencil << 15); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_iDepthBufPitch;
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\refrasti.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refrasti.hpp
//
// Direct3D Reference Rasterizer - Main Internal Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFRASTI_HPP
#define  _REFRASTI_HPP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Component Classes                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Color Component Class - Class used for color channel (alpha & rgb)
// processing.
//
// Internal format is single precision floating point.  The 1.0 value maps
// to 0xff for 8 bit color.
//
//-----------------------------------------------------------------------------
class RRColorComp
{
    FLOAT m_fVal;

public:

    // default, UINT8, & FLOAT assignment constructor
    RRColorComp(void)       : m_fVal(0.F)               {;}
    RRColorComp(UINT8 uVal) : m_fVal((FLOAT)uVal/255.F) {;}
    RRColorComp(FLOAT fVal) : m_fVal(fVal)              {;}

    // copy and assignment operators
    RRColorComp& operator=(const RRColorComp& A) { m_fVal = A.m_fVal; return *this; }
    RRColorComp& operator=(UINT8 uVal) { m_fVal = (1.f/255.f)*(FLOAT)uVal; return *this; }
    RRColorComp& operator=(FLOAT fVal) { m_fVal = fVal; return *this; }
    // round for integer get operations
    operator UINT8() const { return (UINT8)( ( (255.f)*m_fVal) + .5f); }
    operator unsigned() const { return (unsigned)( ( (255.f)*m_fVal ) + .5f); }
    operator FLOAT() const { return m_fVal; }

    // fixed point get function - specify number of integral and fractional bits
    INT32 GetFixed( int iIntBits, int iFracBits ) const
    {
        // float value is in 0. to 1. range, so scale up by the total number of
        // bits (the '-1' does the mapping such that (2**n)-1 is the max representable
        // value, for example 0xff is max for 8 integral bits (not 0x100))
        return (INT32)( ( m_fVal * (FLOAT)((1<<(iIntBits+iFracBits))-1) ) + .5f);
    }

    //
    // overloaded arithmetic operators - not much going on here for floating
    // point (would be much more interesting if internal representation was
    // fixed point)
    //

    // use compliment operator for component inverse (1. - value)
    friend RRColorComp operator~(const RRColorComp& A)
    {
        return RRColorComp( 1.F - A.m_fVal );
    }

    friend RRColorComp operator+(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( A.m_fVal + B.m_fVal );
    }
    RRColorComp& operator+=(const RRColorComp& A)
    {
        m_fVal += A.m_fVal; return *this;
    }

    friend RRColorComp operator-(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( A.m_fVal - B.m_fVal );
    }
    friend RRColorComp operator-(const RRColorComp& A, FLOAT fB)
    {
        return RRColorComp( A.m_fVal - fB );
    }

    friend RRColorComp operator*(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( A.m_fVal * B.m_fVal );
    }
    friend RRColorComp operator*(const RRColorComp& A, FLOAT fB)
    {
        return RRColorComp( A.m_fVal * fB );
    }
    RRColorComp& operator*=(const RRColorComp& A)
    {
        m_fVal *= A.m_fVal; return *this;
    }
    RRColorComp& operator*=(const UINT8 uA)
    {
        m_fVal *= ((1./255.)*(FLOAT)uA); return *this;
    }

    friend RRColorComp minimum(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( min( A.m_fVal, B.m_fVal ) );
    }
    friend RRColorComp maximum(const RRColorComp& A, const RRColorComp& B)
    {
        return RRColorComp( max( A.m_fVal, B.m_fVal ) );
    }
};

//-----------------------------------------------------------------------------
//
// Color Value Class - Holds an Alpha,Red,Green,Blue color value consisting of
// four RRColorComp objects.
//
//-----------------------------------------------------------------------------
class RRColor
{
public:
    RRColorComp A;
    RRColorComp R;
    RRColorComp G;
    RRColorComp B;

    // default and UINT32 assignment constructor
    RRColor( void ) : A(0.F), R(0.F), G(0.F), B(0.F) {;}
    RRColor( UINT32 uVal ) :
        A (UINT8( RGBA_GETALPHA( uVal ) )),
        R (UINT8( RGBA_GETRED(   uVal ) )),
        G (UINT8( RGBA_GETGREEN( uVal ) )),
        B (UINT8( RGBA_GETBLUE(  uVal ) ))  {;}
    RRColor( FLOAT fR, FLOAT fG, FLOAT fB, FLOAT fA ) :
        R(fR), G(fG), B(fB), A(fA) {;}

    // UINT32 copy operator
    void operator=(const UINT32 uVal) // TODO: implement proper assignment operator?
    {
        A = UINT8( RGBA_GETALPHA( uVal ) );
        R = UINT8( RGBA_GETRED(   uVal ) );
        G = UINT8( RGBA_GETGREEN( uVal ) );
        B = UINT8( RGBA_GETBLUE(  uVal ) );
    }
    // casting operator
    operator UINT32() const
    {
        return D3DRGBA( FLOAT(R), FLOAT(G), FLOAT(B), FLOAT(A) );
    }

    // methods to set all channels
    void SetAllChannels( const RRColorComp& Val )
    {
        A = Val; R = Val; G = Val; B = Val;
    }
    void SetAllChannels( FLOAT fVal )
    {
        A = fVal; R = fVal; G = fVal; B = fVal;
    }

    //
    // conversions between surface format and RRColor - these define the
    // correct way to map between resolutions
    //

    // convert from surface type format to RRColor
    void ConvertFrom( RRSurfaceType Type, const char* pSurfaceBits )
    {
        UINT16 u16BITS;

        switch (Type)
        {
        default:
        case RR_STYPE_NULL: return;
        case RR_STYPE_B8G8R8A8: *this = *((UINT32*)pSurfaceBits); break;
        case RR_STYPE_B8G8R8X8: *this = *((UINT32*)pSurfaceBits); A = 1.F; break;

        case RR_STYPE_B5G6R5:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(6+5)) & 0x001F)/31.f;
            G = ((u16BITS>>   5) & 0x003F)/63.f;
            B = ((u16BITS      ) & 0x001F)/31.f;
            A = 1.F;
            break;

        case RR_STYPE_B5G5R5:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
            G = ((u16BITS>>   5) & 0x001F)/31.f;
            B = ((u16BITS      ) & 0x001F)/31.f;
            A = 1.F;
            break;

        case RR_STYPE_B5G5R5A1:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
            G = ((u16BITS>>   5) & 0x001F)/31.f;
            B = ((u16BITS      ) & 0x001F)/31.f;
            A = ( u16BITS & 0x8000 ) ? 1.f : 0.f;
            break;

        case RR_STYPE_B4G4R4A4:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(4+4)) & 0x000F)/15.f;
            G = ((u16BITS>>   4) & 0x000F)/15.f;
            B = ((u16BITS      ) & 0x000F)/15.f;
            A = ((u16BITS>>(4+4+4)) & 0x000F)/15.f;
            break;

        case RR_STYPE_B8G8R8:
            R = *((UINT8*)pSurfaceBits+2);
            G = *((UINT8*)pSurfaceBits+1);
            B = *((UINT8*)pSurfaceBits+0);
            A = 1.F;
            break;

        case RR_STYPE_L8:
            R = G = B = *((UINT8*)pSurfaceBits);
            A = 1.F;
            break;

        case RR_STYPE_L8A8:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = G = B = (UINT8)(0xff & u16BITS);
            A = (UINT8)(0xff & (u16BITS >> 8));
            break;

        case RR_STYPE_B2G3R3:
            u16BITS = *((UINT8*)pSurfaceBits);
            R = ((u16BITS>>(3+2)) & 0x07)/7.f;
            G = ((u16BITS>>   2) & 0x07)/7.f;
            B = ((u16BITS      ) & 0x03)/3.f;
            A = 1.F;
            break;

        case RR_STYPE_L4A4:
            u16BITS = *((UINT8*)pSurfaceBits);
            R = G = B = (u16BITS & 0x0f)/15.f;
            A =    ((u16BITS>>4) & 0x0f)/15.f;
            break;

        case RR_STYPE_B2G3R3A8:
            u16BITS = *((UINT16*)pSurfaceBits);
            R = ((u16BITS>>(3+2)) & 0x07)/7.f;
            G = ((u16BITS>>   2) & 0x07)/7.f;
            B = ((u16BITS      ) & 0x03)/3.f;
            A = (UINT8)(0xff & (u16BITS >> 8));
            break;

        case RR_STYPE_U8V8:
            {
                INT8 iDU = *(( INT8*)pSurfaceBits+0);
                INT8 iDV = *(( INT8*)pSurfaceBits+1);
                // signed values are normalized with 2^(N-1), since -2^(N-1) can
                // be exactly expressed in N bits
                R = (FLOAT)iDU * (1.0F/128.0F);     // fDU
                G = (FLOAT)iDV * (1.0F/128.0F);     // fDV
                B = 1.0F;                           // fL
            }
            break;

        case RR_STYPE_U5V5L6:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                INT8 iDU = (INT8)(u16BITS & 0x1f);
                INT8 iDV = (INT8)((u16BITS>>5) & 0x1f);
                UINT8 uL = (UINT8)(u16BITS >> 10);
                iDU <<= 3; iDU >>= 3;   // sign extension
                iDV <<= 3; iDV >>= 3;
                // signed values are normalized with 2^(N-1), since -2^(N-1) can
                // be exactly expressed in N bits
                R = (FLOAT)iDU * (1.0F/16.0F);      // fDU
                G = (FLOAT)iDV * (1.0F/16.0F);      // fDV
                // the unsigned uL is normalized with 2^N - 1, since this is the
                // largest representable value
                B = (FLOAT)uL * (1.0F/63.0F);       // fL
            }
            break;

        case RR_STYPE_U8V8L8:
            {
                INT8 iDU = *(( INT8*)pSurfaceBits+0);
                INT8 iDV = *(( INT8*)pSurfaceBits+1);
                UINT8 uL  = *((UINT8*)pSurfaceBits+2);
                // signed values are normalized with 2^(N-1), since -2^(N-1) can
                // be exactly expressed in N bits
                R = (FLOAT)iDU * (1.0F/128.0F);     // fDU
                G = (FLOAT)iDV * (1.0F/128.0F);     // fDV
                // the unsigned uL is normalized with 2^N - 1, since this is the
                // largest representable value
                B = (FLOAT)uL * (1.0F/255.0F);      // fL
            }
            break;

        // shadow map texture formats (read only, not needed for ConvertTo)
        case RR_STYPE_Z16S0:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)u16BITS * (1.0F/(FLOAT)0xffff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_Z24S8:
        case RR_STYPE_Z24S4:
            {
                UINT32 u32BITS = *((UINT32*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u32BITS>>8) * (1.0F/(FLOAT)0xffffff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_S8Z24:
        case RR_STYPE_S4Z24:
            {
                UINT32 u32BITS = *((UINT32*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u32BITS&0x00ffffff) * (1.0F/(FLOAT)0xffffff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_Z15S1:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u16BITS>>1) * (1.0F/(FLOAT)0x7fff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_S1Z15:
            {
                UINT16 u16BITS = *((UINT16*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)(u16BITS&0x7fff) * (1.0F/(FLOAT)0x7fff);
                B = 0.0F;
            }
            break;

        case RR_STYPE_Z32S0:
            {
                UINT32 u32BITS = *((UINT32*)pSurfaceBits);
                R = 0.0F;
                G = (FLOAT)u32BITS * (1.0F/(FLOAT)0xffffffff);
                B = 0.0F;
            }
            break;
        }
    }

    // Convert surface type format to RRColor
    void ConvertTo( RRSurfaceType Type, float fRoundOffset, char* pSurfaceBits ) const
    {
        int iR, iG, iB, iA;

        switch (Type)
        {
        case RR_STYPE_B8G8R8A8:
            *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+3) = (UINT8)((FLOAT)A * 255. + fRoundOffset);
            break;

        case RR_STYPE_B8G8R8X8:
            *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+3) = 0x00;
            break;

        case RR_STYPE_B8G8R8:
            *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
            *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
            break;

        case RR_STYPE_B4G4R4A4:
            iA = (FLOAT)A * 15. + fRoundOffset;
            iR = (FLOAT)R * 15. + fRoundOffset;
            iG = (FLOAT)G * 15. + fRoundOffset;
            iB = (FLOAT)B * 15. + fRoundOffset;
            *((UINT16*)pSurfaceBits) = (iA<<12) | (iR<<8) | (iG<<4) | iB;
            break;

        case RR_STYPE_B5G6R5:
            iR = (FLOAT)R * 31. + fRoundOffset; // apply rounding bias then truncate
            iG = (FLOAT)G * 63. + fRoundOffset;
            iB = (FLOAT)B * 31. + fRoundOffset;
            *((UINT16*)pSurfaceBits) =            (iR<<11) | (iG<<5) | iB;
            break;

        case RR_STYPE_B5G5R5A1:
            iA = (FLOAT)A *  1. + fRoundOffset;
            iR = (FLOAT)R * 31. + fRoundOffset;
            iG = (FLOAT)G * 31. + fRoundOffset;
            iB = (FLOAT)B * 31. + fRoundOffset;
            *((UINT16*)pSurfaceBits) = (iA<<15) | (iR<<10) | (iG<<5) | iB;
            break;

        case RR_STYPE_B5G5R5:
            iR = (FLOAT)R * 31. + fRoundOffset;
            iG = (FLOAT)G * 31. + fRoundOffset;
            iB = (FLOAT)B * 31. + fRoundOffset;
            *((UINT16*)pSurfaceBits) = (iR<<10) | (iG<<5) | iB;
            break;

        case RR_STYPE_B2G3R3:
            iR = (FLOAT)R * 7. + fRoundOffset;
            iG = (FLOAT)G * 7. + fRoundOffset;
            iB = (FLOAT)B * 3. + fRoundOffset;
            *((UINT8*)pSurfaceBits) = (iR<<5) | (iG<<2) | iB;
            break;
        }
    }
};

//-----------------------------------------------------------------------------
//
// RRDepth - Class for storing and manipulating pixel depth values.  Underlying
// storage is a double precision floating point, which has sufficient precision
// and range to support 16 and 32 bit fixed point and 32 bit floating point.
//
// The UINT32 methods receive a 24 or 32 bit value, and the UINT16
// methods receive a 15 or 16 bit value.
//
//-----------------------------------------------------------------------------
class RRDepth
{
    DOUBLE m_dVal;
    RRSurfaceType m_DepthSType;
    DOUBLE dGetValClamped(void) const { return min(1.,max(0.,m_dVal)); }
    DOUBLE dGetCnvScale(void) const
    {
        switch(m_DepthSType)
        {
        case RR_STYPE_Z16S0:
            return DOUBLE((1<<16)-1);
        case RR_STYPE_Z24S8:
        case RR_STYPE_S8Z24:
        case RR_STYPE_Z24S4:
        case RR_STYPE_S4Z24:
            return DOUBLE((1<<24)-1);
        case RR_STYPE_Z15S1:
        case RR_STYPE_S1Z15:
            return DOUBLE((1<<15)-1);
        case RR_STYPE_Z32S0:
            return DOUBLE(0xffffffff);  // too big to be generated as above without INT64's
        default:
            DPFRR(0, "RRDepth not initialized correctly");
            return DOUBLE(0.0);
        }
    }
public:
    // default and UINT16/32 assignment constructor
    // default only for Pixel class, and requires that SetSType be called later
    RRDepth()                                : m_dVal(0.F), m_DepthSType(RR_STYPE_NULL)                 {;}
    RRDepth(RRSurfaceType SType)             : m_dVal(0.F), m_DepthSType(SType)                         {;}
    RRDepth(UINT16 uVal, RRSurfaceType SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal/dGetCnvScale()) {;}
    RRDepth(UINT32 uVal, RRSurfaceType SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal/dGetCnvScale()) {;}

    // copy and assignment operators
    RRDepth& operator=(const RRDepth& A) { m_dVal = A.m_dVal; m_DepthSType = A.m_DepthSType; return *this; }
    RRDepth& operator=(UINT16 uVal) { m_dVal = (DOUBLE)uVal/dGetCnvScale(); return *this; }
    RRDepth& operator=(UINT32 uVal) { m_dVal = (DOUBLE)uVal/dGetCnvScale(); return *this; }
    RRDepth& operator=(FLOAT fVal) { m_dVal = (DOUBLE)fVal; return *this; }

    // round for integer get operations
    operator UINT16() const { return (UINT16)( (dGetValClamped()*dGetCnvScale()) + .5); }
    operator UINT32() const { return (UINT32)( (dGetValClamped()*dGetCnvScale()) + .5); }

    operator DOUBLE() const { return dGetValClamped(); }
    operator FLOAT()  const { return (FLOAT)dGetValClamped(); }
    void SetSType(RRSurfaceType SType)  { m_DepthSType = SType; }
    RRSurfaceType GetSType(void) const { return m_DepthSType; }
};

//-----------------------------------------------------------------------------
//
// RRPixel - Class for encapsulation of all pixel information passed from
// scan conversion to pixel and fragment processing.
//
//-----------------------------------------------------------------------------
class RRPixel
{
public:
    INT16 iX;                   // pixel location
    INT16 iY;                   //
    RRColor Color;              // pixel diffuse color
    RRColor Specular;           // pixel specular color (rgb only - alpha unused)
    RRDepth Depth;              // pixel depth
    FLOAT fW;                   // pixel W value (unnormalized)
    RRColorComp FogIntensity;   // fog intensity (scalar)
    RRCvgMask CvgMask;          // coverage mask
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Setup & Scan Convert                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Scan Converter State - Holds input and current state of scan converter.
// Filled in by setup.
//
//-----------------------------------------------------------------------------
struct _RRSCANCNVSTATE
{
    // primitive vertex data
    FLOAT fX0, fY0, fRHW0;
    FLOAT fX1, fY1, fRHW1;
    FLOAT fX2, fY2, fRHW2;
    // primitive transformed texture coord data
    FLOAT fTexCoord[D3DHAL_TSS_MAXSTAGES][3][4];
    FLOAT fRHQW[D3DHAL_TSS_MAXSTAGES][3];
    BOOL  bWrap[D3DHAL_TSS_MAXSTAGES][4];

    // x,y deltas
    FLOAT fDelX10, fDelX02, fDelX21;
    FLOAT fDelY01, fDelY20, fDelY12;

    // triangle edge functions and gradient data
    RREdgeFunc  EdgeFuncs[4];   // A,B,C values and A,B sign bits for 4 edges
                                // the fourth edge is only used to scan convert points

    // triangle bounding box
    INT16 iXMin, iXMax;
    INT16 iYMin, iYMax;

    // line drawing data
    INT64  iLineEdgeFunc[3];    // line function: Pminor = ([0]*Pmajor + [1])/[2]
    BOOL   bXMajor;             // TRUE if X major; else Y major
    INT16  iLineMin, iLineMax;  // min and max pixel extent in major direction
    INT16  iLineStep;           // +1 or -1 depending on line major direction

    // depth range for primitive (for clamp when sampling outside primitive area)
    // may be Z or W
    FLOAT fDepthMin, fDepthMax;

    //
    // attribute functions - static (per-primitive) data, non-texture,
    // and texture functions
    //
    RRAttribFuncStatic  AttribFuncStatic;

#define ATTRFUNC_R          0
#define ATTRFUNC_G          1
#define ATTRFUNC_B          2
#define ATTRFUNC_A          3
#define ATTRFUNC_SR         4
#define ATTRFUNC_SG         5
#define ATTRFUNC_SB         6
#define ATTRFUNC_SA         7
#define ATTRFUNC_F          8
#define ATTRFUNC_Z          9
#define RR_N_ATTRIBS        10
    RRAttribFunc AttribFuncs[RR_N_ATTRIBS];

#define TEXFUNC_0           0
#define TEXFUNC_1           1
#define TEXFUNC_2           2
#define TEXFUNC_3           3
#define RR_N_TEX_ATTRIBS    4
    RRAttribFunc TextureFuncs[D3DHAL_TSS_MAXSTAGES][RR_N_TEX_ATTRIBS];


    //
    // per-pixel data
    //

    // current position
    INT16 iX,iY;

};


//-----------------------------------------------------------------------------
//
// Texture
//
//-----------------------------------------------------------------------------

//
// structure containing texture coordinate and gradient information
// for lookup and filtering
//
class RRTextureCoord
{
public:
    FLOAT fU;       // texture coordinate
    FLOAT fV;
    FLOAT fDUDX;    // texture gradient dU/dX
    FLOAT fDUDY;    // texture gradient dU/dY
    FLOAT fDVDX;    // texture gradient dV/dX
    FLOAT fDVDY;    // texture gradient dV/dY
};

//
// structure containing normal and gradient information
// for environment map lookup and filtering
//
class RREnvTextureCoord
{
public:
    FLOAT fNX;       // normal or reflection normal
    FLOAT fNY;
    FLOAT fNZ;
//    FLOAT fENX;      // eye normal
//    FLOAT fENY;
//    FLOAT fENZ;
    FLOAT fDNXDX;    // normal gradient dNX/dX
    FLOAT fDNXDY;    // normal gradient dNX/dY
    FLOAT fDNYDX;    // normal gradient dNY/dX
    FLOAT fDNYDY;    // normal gradient dNY/dY
    FLOAT fDNZDX;    // normal gradient dNZ/dX
    FLOAT fDNZDY;    // normal gradient dNZ/dY
};

//
// routines to compute level of detail (texel->pixel coverage)
//
// (texfilt.cpp)
void
ComputeSimpleLevelOfDetail(
    const RRTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeEnvMapLevelOfDetail(
    const RRTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeAnisotropicLevelOfDetail(
    const RRTextureCoord& TCoord, FLOAT fMaxAniso,  //  inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] );   //  outputs


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Engine                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// coverage mask values
#define TL_CVGFULL 0xffff
#define TL_CVGZERO 0x0000
#define TL_CVGBITS 16
#define TL_CVGBITSm 4

typedef UINT16 CVGMASK;

// fragment - fragmented pixels have linked lists of these
struct _RRFRAGMENT
{
    RRColor Color;
    RRDepth Depth;
    CVGMASK CvgMask;
    void* pNext;
};

int CountFrags(RRFRAGMENT* pFrag);
void DPFFrags(RRFRAGMENT* pFrag);

//-----------------------------------------------------------------------------
//
// Fragment Resolution Accumulator - accumulates fragments presented in
// front-to-back order; does fully correct transparency computations for
// non-opaque fragments
//
//-----------------------------------------------------------------------------
class FragResolveAccum
{
public:
    // coverage accumulation array - holds up to CVGBITS different
    // alpha values and associated coverage masks; UsageMask indicates
    // which entries are currently in use - each set bit in Usage mask
    // indicates that the array entry corresponding to the index of the
    // that bit holds a valid mask and alpha;
    //
    // the general idea here is that, in cases in which there are few
    // fragments, numerous sample locations (within the pixel) will have
    // the same alpha value, and thus can be grouped for the accumulation
    struct {
        CVGMASK Mask;
        FLOAT fAlpha;
    } m_CvgArray[TL_CVGBITS];
    CVGMASK m_ArrayUsageMask;

    // accumulated color and alpha value
    FLOAT m_fA, m_fR, m_fG, m_fB;

    // mask where set bit indicates a subpixel with opaque alpha
    CVGMASK m_CvgOpaqueMask;

    // reset before each use...
    void Reset( void );

    // accumulate new fragment (front to back) - returns TRUE if
    // full coverage achieved, FALSE otherwise
    BOOL Accum( const CVGMASK CvgMask, const RRColor& Color );

    // get RRColor from accumulator
    void GetColor( RRColor& Color );
};


//-----------------------------------------------------------------------------
//
// statistics
//
//-----------------------------------------------------------------------------
struct _RRSTATS
{
    INT32 cFragsAllocd;
    INT32 cMaxFragsAllocd;
    INT32 cFragsMerged;
    INT32 cFragsMergedToFull;
};


//-----------------------------------------------------------------------------
//
// utilities
//
//-----------------------------------------------------------------------------

// compute pixel address from base, pitch, and surface type
char*
PixelAddress( int iX, int iY, char* pBits, int iYPitch, RRSurfaceType SType );


//-----------------------------------------------------------------------------
//
// color interpolation utilities
//
//-----------------------------------------------------------------------------
void LerpColor(RRColor& Color,
    const RRColor& Color0, const RRColor& Color1, UINT8 uT);
void BiLerpColor( RRColor& OutColor,
    const RRColor& Color00, const RRColor& Color01,
    const RRColor& Color10, const RRColor& Color11,
    UINT8 uA, UINT8 uB);

//-----------------------------------------------------------------------------
//
// Globals
//
//-----------------------------------------------------------------------------

// something to experiment with sometime - this sets the threshold at which
// pixel samples are considered opaque (and thus don't generate fragment
// buffer entries when doing D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT);
// no need to have all those 0xfe's generate fragments...
extern UINT8 g_uTransparencyAlphaThreshold;

//-----------------------------------------------------------------------------
//
// One special legacy texture op we can't easily map into the new texture
// ops.
//
//-----------------------------------------------------------------------------

#define D3DTOP_LEGACY_ALPHAOVR  (0x7fffffff)

///////////////////////////////////////////////////////////////////////////////
#endif  // _REFRASTI_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\rrutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrutil.cpp
//
// Direct3D Reference Rasterizer - Utilities
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// DPF support                                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

// control globals
int g_iDPFLevel = 0;
unsigned long g_uDPFMask = 0x0;

//-----------------------------------------------------------------------------
//
// RRDebugPrintf(L) - Utilities to print varargs-formatted strings of debugging
// info.  The 'L' version takes a level into account in deciding to print or
// not.
//
//-----------------------------------------------------------------------------
void
RRDebugPrintf( const char* pszFormat, ... )
{
    char tmp[1024] = "D3DRR: ";
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
    OutputDebugString(tmp);
    printf(tmp);
}
void
RRDebugPrintfL( int iLevel, const char* pszFormat, ... )
{
    if ( (iLevel <= g_iDPFLevel) )
    {
        char tmp[1024] = "D3DRR: ";
        va_list marker;
        va_start(marker, pszFormat);
        _vsnprintf(tmp+lstrlen(tmp), 1024-lstrlen(tmp), pszFormat, marker);
        OutputDebugString(tmp);
        printf(tmp);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Assert Reporting
//
///////////////////////////////////////////////////////////////////////////////

// little-bit-o-state to track file and line number reporting - this is makes
// this code non-reentrant and non-threadsafe...  oh well...
static const char* _pszLastReportFile = NULL;
static int _iLastReportLine = -1;

//-----------------------------------------------------------------------------
void
RRAssertReport( const char* pszString, const char* pszFile, int iLine )
{
    char szNum[33];
    _itoa( iLine, szNum, 10 );

    char szTmp[ 1024 ] = "D3DRR ASSERT: <";
    strcat( szTmp, szNum );

    char* pCur = szTmp + strlen( szTmp );
    char* const pEnd = szTmp + sizeof( szTmp ) / sizeof( szTmp[ 0 ] ) - 1;

    if( pCur < pEnd )
    {
        const char szNext[] = ",";
        strncpy( pCur, szNext, pEnd - pCur );
        pCur += sizeof( szNext ) / sizeof( szNext[ 0 ] ) - 1;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const size_t uiFileLen = strlen( pszFile );
        strncpy( pCur, pszFile, pEnd - pCur );
        pCur += uiFileLen;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const char szNext[] = "> ";
        strncpy( pCur, szNext, pEnd - pCur );
        pCur += sizeof( szNext ) / sizeof( szNext[ 0 ] ) - 1;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const size_t uiStringLen = strlen( pszString );
        strncpy( pCur, pszString, pEnd - pCur );
        pCur += uiStringLen;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const char szNext[] = "\n";
        strncpy( pCur, szNext, pEnd - pCur );
        pCur += sizeof( szNext ) / sizeof( szNext[ 0 ] ) - 1;
        pCur = min( pCur, pEnd );
    }

    *pEnd = '\0';

    OutputDebugString( szTmp );
}
//-----------------------------------------------------------------------------
void
RRAssertReportPrefix( const char* pszFile, int iLine )
{
    _pszLastReportFile = pszFile;
    _iLastReportLine = iLine;
}
//-----------------------------------------------------------------------------
void
RRAssertReportMessage( const char* pszFormat, ... )
{
    char szTmp[1024];
    va_list marker;
    va_start( marker, pszFormat );
    _vsnprintf( szTmp, 1024, pszFormat, marker );
    RRAssertReport( szTmp, _pszLastReportFile, _iLastReportLine );
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Generic bit twiddling utilities                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// CountSetBits - Returns number of set bits in a multibit value (up to
// 32 bits).
//
//-----------------------------------------------------------------------------
INT32
CountSetBits( UINT32 uVal, INT32 nBits )
{
    INT32 iRet = 0;
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { iRet++; }
    }
    return iRet;
}

//-----------------------------------------------------------------------------
//
// FindFirstSetBit - Returns index of first set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindFirstSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { return i; }
    }
    return -1;
}

//-----------------------------------------------------------------------------
//
// FindMostSignificantSetBit - Returns index of first set bit in a
// multibit value (up to 32 bits) or 0 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindMostSignificantSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=nBits; i>=0; i--) {
        if (uVal & (0x1<<i)) { return i+1; }
    }
    return 0;
}

//-----------------------------------------------------------------------------
//
// FindLastSetBit - Returns index of last set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindLastSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<(nBits-i-1))) { return (nBits-i-1); }
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Arithmetic utilities                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// LerpColor - Performs a linear interpolation between two RRColors
//
// uT is in 1.5 format (1<<5 represents a unit value)
//
//-----------------------------------------------------------------------------
void
LerpColor(
    RRColor& Color,
    const RRColor& Color0, const RRColor& Color1, UINT8 uT )
{
    FLOAT fT = (1./(FLOAT)(1<<5))*(FLOAT)uT;
    Color.A = Color0.A + (Color1.A - Color0.A)*fT;
    Color.R = Color0.R + (Color1.R - Color0.R)*fT;
    Color.G = Color0.G + (Color1.G - Color0.G)*fT;
    Color.B = Color0.B + (Color1.B - Color0.B)*fT;
}

//-----------------------------------------------------------------------------
//
// Bilerp - Performs bilinear interpolation of 4 RRColors returning one RRColor.
//
//-----------------------------------------------------------------------------
void
BiLerpColor(
    RRColor& OutColor,
    const RRColor& Color00, const RRColor& Color01,
    const RRColor& Color10, const RRColor& Color11,
    UINT8 uA, UINT8 uB )
{
    RRColor Color0, Color1;
    LerpColor( Color0, Color00, Color01, uA);
    LerpColor( Color1, Color10, Color11, uA);
    LerpColor( OutColor, Color0, Color1, uB);
}

///////////////////////////////////////////////////////////////////////////////
//
// RRAlloc method implementation
//
///////////////////////////////////////////////////////////////////////////////
void *
RRAlloc::operator new(size_t s)
{
    void* pMem = (void*)MEMALLOC( s );
    _ASSERTa( NULL != pMem, "malloc failure", return NULL; );
    return pMem;
}

void 
RRAlloc::operator delete(void* p, size_t)
{
    MEMFREE( p );
};


//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\rtarget.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rtarget.hpp
//
// Direct3D Reference Rasterizer - Render Target Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// overload new & delete so that it can be allocated from caller-controlled
// pool
//
//-----------------------------------------------------------------------------
void*
RRRenderTarget::operator new(size_t)
{
    void* pMem = (void*)MEMALLOC( sizeof(RRRenderTarget) );
    _ASSERTa( NULL != pMem, "malloc failure on render target object", return NULL; );
    return pMem;
}
//-----------------------------------------------------------------------------
void
RRRenderTarget::operator delete(void* pv,size_t)
{
    MEMFREE( pv );
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RRRenderTarget::RRRenderTarget( void )
{
    memset( this, 0, sizeof(*this) );
}
//-----------------------------------------------------------------------------
RRRenderTarget::~RRRenderTarget( void )
{
    // Release nothing because we didnt take any ref-counts,
    // simply return
    return;
}

//-----------------------------------------------------------------------------
//
// ReadPixelColor - Reads color buffer bits and expands out into an RRColor
// value.  Buffer types without alpha return a 1.0 value for alpha.  Low
// bits of <8 bit colors are returned as zero.
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::ReadPixelColor(
    INT32 iX, INT32 iY,
    RRColor& Color)
{
    if ( NULL == m_pColorBufBits ) return;

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pColorBufBits, m_iColorBufPitch, m_ColorSType );
    Color.ConvertFrom( m_ColorSType, pSurfaceBits );
}

//-----------------------------------------------------------------------------
//
// WritePixelColor - Takes an RRColor value, formats it for the color buffer
// format, and writes the value into buffer.
//
// Dithering is applied here, when enabled, for <8 bits/channel surfaces.
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::WritePixelColor(
    INT32 iX, INT32 iY,
    const RRColor& Color, BOOL bDither)
{
    if ( NULL == m_pColorBufBits ) return;

    // default to round to nearest
    FLOAT fRoundOffset = .5F;
    if ( bDither )
    {
        static  FLOAT fDitherTable[16] =
        {
            .0000f,  .5000f,  .1250f,  .6750f,
            .7500f,  .2500f,  .8750f,  .3750f,
            .1875f,  .6875f,  .0625f,  .5625f,
            .9375f,  .4375f,  .8125f,  .3125f
        };

        // form 4 bit offset into dither table (2 LSB's of x and y) and get offset
        unsigned uDitherOffset = ( ( iX << 2) & 0xc ) | (iY & 0x3 );
        fRoundOffset = fDitherTable[uDitherOffset];
    }

    char* pSurfaceBits = PixelAddress( iX, iY, m_pColorBufBits, m_iColorBufPitch, m_ColorSType );
    Color.ConvertTo( m_ColorSType, fRoundOffset, pSurfaceBits );
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelDepth - Read/write depth buffer
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::WritePixelDepth(
    INT32 iX, INT32 iY,
    const RRDepth& Depth )
{
    // don't write if no Z buffer
    if ( NULL == m_pDepthBufBits ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    switch (m_DepthSType)
    {
    case RR_STYPE_Z16S0:
        *((UINT16*)pSurfaceBits) = UINT16(Depth);
        break;
    case RR_STYPE_Z24S8:
    case RR_STYPE_Z24S4:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xffffff00);
            uBufferBits |= (UINT32(Depth) << 8);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S8Z24:
    case RR_STYPE_S4Z24:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x00ffffff);
            uBufferBits |= (UINT32(Depth) & 0x00ffffff);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z15S1:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0xfffe);
            uBufferBits |= (UINT16(Depth) << 1);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S1Z15:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x7fff);
            uBufferBits |= (UINT16(Depth) & 0x7fff);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z32S0:
        *((UINT32*)pSurfaceBits) = UINT32(Depth);
        break;
    }
}
//-----------------------------------------------------------------------------
void
RRRenderTarget::ReadPixelDepth(
    INT32 iX, INT32 iY,
    RRDepth& Depth )
{
    // don't read if no Z buffer
    if ( NULL == m_pDepthBufBits ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    switch (m_DepthSType)
    {
    case RR_STYPE_Z16S0:
        Depth = *((UINT16*)pSurfaceBits);
        break;
    case RR_STYPE_Z24S8:
    case RR_STYPE_Z24S4:
        // take upper 24 bits aligned to LSB
        Depth = ( *((UINT32*)pSurfaceBits) ) >> 8;
        break;
    case RR_STYPE_S8Z24:
    case RR_STYPE_S4Z24:
        // take lower 24 bits
        Depth = ( *((UINT32*)pSurfaceBits) ) & 0x00ffffff;
        break;
    case RR_STYPE_Z15S1:
        // take upper 15 bits aligned to LSB
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) >> 1);
        break;
    case RR_STYPE_S1Z15:
        // take lower 15 bits
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) & 0x7fff);
        break;
    case RR_STYPE_Z32S0:
        Depth = *((UINT32*)pSurfaceBits);
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelStencil - Read/Write of stencil bits within depth buffer
// surface; write is done with read-modify-write so depth bits are not disturbed;
// stencil mask is applied outside
//
//-----------------------------------------------------------------------------
void
RRRenderTarget::WritePixelStencil(
    INT32 iX, INT32 iY,
    UINT8 uStencil)
{
    // don't write if no Z/Stencil buffer or no stencil in Z buffer
    if ( (NULL == m_pDepthBufBits) ||
        ((RR_STYPE_Z24S8 != m_DepthSType) &&
         (RR_STYPE_S8Z24 != m_DepthSType) &&
         (RR_STYPE_S1Z15 != m_DepthSType) &&
         (RR_STYPE_Z15S1 != m_DepthSType) &&
         (RR_STYPE_Z24S4 != m_DepthSType) &&
         (RR_STYPE_S4Z24 != m_DepthSType)) ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    // need to do read-modify-write to not step on Z
    switch(m_DepthSType)
    {
    case RR_STYPE_Z24S8:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= uStencil;
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S8Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= (uStencil << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z24S4:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= (uStencil & 0xf);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S4Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= ((uStencil & 0xf) << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_Z15S1:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x0001);
            uBufferBits |= uStencil & 0x1;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RR_STYPE_S1Z15:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x8000);
            uBufferBits |= uStencil << 15;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    }

}
//-----------------------------------------------------------------------------
void
RRRenderTarget::ReadPixelStencil(
    INT32 iX, INT32 iY,
    UINT8& uStencil)
{
    // don't read if no Z/Stencil buffer or no stencil in Z buffer
    if ( (NULL == m_pDepthBufBits) ||
        ((RR_STYPE_Z24S8 != m_DepthSType) &&
         (RR_STYPE_S8Z24 != m_DepthSType) &&
         (RR_STYPE_S1Z15 != m_DepthSType) &&
         (RR_STYPE_Z15S1 != m_DepthSType) &&
         (RR_STYPE_Z24S4 != m_DepthSType) &&
         (RR_STYPE_S4Z24 != m_DepthSType) ) ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pDepthBufBits, m_iDepthBufPitch, m_DepthSType );

    switch(m_DepthSType)
    {
    case RR_STYPE_Z24S8:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xff );
        break;
    case RR_STYPE_S8Z24:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) >> 24 );
        break;
    case RR_STYPE_Z15S1:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) & 0x1 );
        break;
    case RR_STYPE_S1Z15:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) >> 15 );
        break;
    case RR_STYPE_Z24S4:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xf );
        break;
    case RR_STYPE_S4Z24:
        uStencil = (UINT8)( ( ( *((UINT32*)pSurfaceBits) ) >> 24 ) & 0xf);
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\refs3tc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// refs3tc.cpp
//
// Direct3D Reference Rasterizer - S3 texture compression functions
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"

// Primary color components (use DirextX byte ordering)
#undef RED
#define RED   0
#undef GRN
#define GRN   1
#undef BLU
#define BLU   2
#undef ALFA
#define ALFA 3

typedef struct  {
        float           rgba[4];
} FCOLOR;       // internal color format

//
// Processing all primaries is such a common idiom
// that we define a macro for this action.
// Any self-respecting C compiler should easily optimize
// this by unrolling the loop!
//
#define ForAllPrimaries         for( primary = 0; primary < NUM_PRIMARIES; ++primary)

// Similarly, processing all pixels in a block is a common idiom.
#define ForAllPixels            for(pixel=0; pixel < DXT_BLOCK_PIXELS; ++pixel)

#define NUM_PRIMARIES   3
#define NUM_COMPONENTS  4
//
// Quantization constants for RGB565
//
#define PRIMARY_BITS    8

#define RED_BITS        5
#define GRN_BITS        6
#define BLU_BITS        5

#define RED_SHIFT       (PRIMARY_BITS-RED_BITS)
#define GRN_SHIFT       (PRIMARY_BITS-GRN_BITS)
#define BLU_SHIFT       (PRIMARY_BITS-BLU_BITS)

#if 0
#define RED_MASK        0xf8
#define GRN_MASK        0xfc
#define BLU_MASK        0xf8
#endif

// Weighting for each primary based on NTSC luminance
static  float   wtPrimary[NUM_PRIMARIES] = {
        0.0820f,        // blue
        0.6094f,        // green
        0.3086f         // red
};

//-----------------------------------------------------------------------------
// unpack a fixed point color
//-----------------------------------------------------------------------------
static  void    RGBToColor (RGB565 *prgb, DXT_COLOR *pcolor)
{
        WORD    rgb;
        DXT_COLOR      color;

        rgb = *((WORD *)prgb);

        // pick off bits in groups of 5, 6, and 5
        color.rgba[BLU] = (unsigned char) rgb;
        rgb >>= BLU_BITS;
        color.rgba[GRN] = (unsigned char) rgb;
        rgb >>= GRN_BITS;
        color.rgba[RED] = (unsigned char) rgb;

        // shift primaries into the appropriate LSBs
        color.rgba[BLU] <<= BLU_SHIFT;
        color.rgba[GRN] <<= GRN_SHIFT;
        color.rgba[RED] <<= RED_SHIFT;

        // replicate primaries MSBs into LSBs
        color.rgba[BLU] |= color.rgba[BLU] >> BLU_BITS;
        color.rgba[GRN] |= color.rgba[GRN] >> GRN_BITS;
        color.rgba[RED] |= color.rgba[RED] >> RED_BITS;

        *pcolor = color;
}

//-----------------------------------------------------------------------------
// DecodeBlockRGB - decompress a color block
//-----------------------------------------------------------------------------
void DecodeBlockRGB (DXTBlockRGB *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
        int     lev;
        DXT_COLOR      clut[4];
        PIXBM   pixbm;
        int     pixel;
        int     primary;

        // if source block is invalid, ...
        if (pblockSrc == NULL)
                return;

        // determine the number of color levels in the block
        lev = (pblockSrc->rgb0 <= pblockSrc->rgb1) ? 2 : 3;

        // Fill extrema values into pixel code lookup table.
        RGBToColor(&pblockSrc->rgb0, &clut[0]);
        RGBToColor(&pblockSrc->rgb1, &clut[1]);

        clut[0].rgba[ALFA] =
        clut[1].rgba[ALFA] =
        clut[2].rgba[ALFA] = 255;

        if (lev == 3) { // No transparency info present, all color info.
                ForAllPrimaries {
                        WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
                        WORD temp1 = clut[1].rgba[primary];
                        clut[2].rgba[primary] = (BYTE)((2*temp0 + temp1 + 1)/3);
                        clut[3].rgba[primary] = (BYTE)((temp0 + 2*temp1 + 1)/3);
                }
                clut[3].rgba[ALFA] = 255;
        }
        else {  // transparency info.
                ForAllPrimaries {
                        WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
                        WORD temp1 = clut[1].rgba[primary];
                        clut[2].rgba[primary] = (BYTE)((temp0 + temp1)/2);
                        clut[3].rgba[primary] = 0;     // jvanaken added this
                }
                clut[3].rgba[ALFA] = 0;
        }

        // munge a local copy
        pixbm = pblockSrc->pixbm;

        // Look up the actual pixel color in the table.
        ForAllPixels {
                // lookup color from pixel bitmap
                ForAllPrimaries
                        colorDst[pixel].rgba[primary] = clut[pixbm & 3].rgba[primary];

                colorDst[pixel].rgba[ALFA] = clut[pixbm & 3].rgba[ALFA];

                // prepare to extract next index
                pixbm >>= 2;
        }
}

//-----------------------------------------------------------------------------
// DecodeBlockAlpha4 - decompress a block with alpha at 4 BPP
//-----------------------------------------------------------------------------
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
        int     row, col;
        WORD    alpha;

        DecodeBlockRGB(&pblockSrc->rgb, colorDst);

        for (row = 0; row < 4; ++row) {
                alpha = pblockSrc->alphabm[row];

                for (col = 0; col < 4; ++col) {
                        colorDst[4 * row + col].rgba[ALFA] =
                                  ((alpha & 0xf) << 4)
                                | (alpha & 0xf);
                        alpha >>= 4;
                }
        }
}

//-----------------------------------------------------------------------------
// DecodeBlockAlpha3 - decompress a block with alpha at 3 BPP
//-----------------------------------------------------------------------------
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
        int     pixel;
        int     alpha[8];       // alpha lookup table
        DWORD   dwBM = 0;       // alpha bitmap in DWORD cache

        DecodeBlockRGB(&pblockSrc->rgb, colorDst);

        alpha[0] = pblockSrc->alpha0;
        alpha[1] = pblockSrc->alpha1;

        // if 8 alpha ramp, ...
        if (alpha[0] > alpha[1]) {
                // interpolate intermediate colors
                alpha[2] = (6 * alpha[0] + 1 * alpha[1]) / 7;
                alpha[3] = (5 * alpha[0] + 2 * alpha[1]) / 7;
                alpha[4] = (4 * alpha[0] + 3 * alpha[1]) / 7;
                alpha[5] = (3 * alpha[0] + 4 * alpha[1]) / 7;
                alpha[6] = (2 * alpha[0] + 5 * alpha[1]) / 7;
                alpha[7] = (1 * alpha[0] + 6 * alpha[1]) / 7;
        }
        else { // else 6 alpha ramp with 0 and 255
                // interpolate intermediate colors
                alpha[2] = (4 * alpha[0] + 1 * alpha[1]) / 5;
                alpha[3] = (3 * alpha[0] + 2 * alpha[1]) / 5;
                alpha[4] = (2 * alpha[0] + 3 * alpha[1]) / 5;
                alpha[5] = (1 * alpha[0] + 4 * alpha[1]) / 5;
                alpha[6] = 0;
                alpha[7] = 255;
        }

        ForAllPixels {
                // reload bitmap dword cache every 8 pixels
                if ((pixel & 7) == 0) {
                        if (pixel == 0) {
                                // pack 3 bytes into dword
                                dwBM  = pblockSrc->alphabm[2];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[1];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[0];
                        }
                        else {  // pixel == 8
                                // pack 3 bytes into dword
                                dwBM  = pblockSrc->alphabm[5];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[4];
                                dwBM <<= 8;
                                dwBM |= pblockSrc->alphabm[3];
                        }
                }

                // unpack bitmap dword 3 bits at a time
                colorDst[pixel].rgba[ALFA] = (BYTE)alpha[(dwBM & 7)];
                dwBM >>= 3;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\shadow.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1997.
//
// shadow.cpp
//
// Direct3D Reference Rasterizer - Shadow Mapping Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// Fast but adequate 16 bit linear congruential random number generators
//
// fRand returns 0.0 to 1.0, fRand2 returns -1.0 to 1.0
//
//-----------------------------------------------------------------------------
static UINT16 _uRandDum = 123;
static FLOAT fRand(void)
{
//   Slower 32 bit LC random number generator
//   static long _uRandDum = 123;
//   idum = 1664525L*_uRandDum + 1013904223L;

    _uRandDum = 25173*_uRandDum + 13849;
    return ((FLOAT)_uRandDum/(FLOAT)0xffff);
}
//
static FLOAT fRand2(void)
{
    _uRandDum = 25173*_uRandDum + 13849;
    return ((FLOAT)_uRandDum/(FLOAT)0x8000) - 1.0F;
}

//-----------------------------------------------------------------------------
//
// DoShadow - Performs Shadow Z buffer Algorithm on a per-fragment basis.
//
//-----------------------------------------------------------------------------
void RRTexture::DoShadow(INT32 iStage, FLOAT* pfCoord, RRColor& OutputColor)
{
#ifdef __SHADOWBUFFER
    FLOAT fW = pfCoord[3];

    // set output color to white in case there is no attenuation
    OutputColor = 0xffffffff;

    // don't shadow behind the light
    if (fW > 0.0F)
    {
        // these are already multiplied by fW
        FLOAT fU = pfCoord[0];
        FLOAT fV = pfCoord[1];
        FLOAT fZ = pfCoord[2];

        /////////////////////////////////////////////////
        // Do shadow filter
        /////////////////////////////////////////////////
        fZ -= m_pStageState[iStage].m_fVal[D3DTSS_SHADOWZBIASMIN];
        FLOAT fZRange = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWZBIASMAX] -
            m_pStageState[iStage].m_fVal[D3DTSS_SHADOWZBIASMIN];
        if (fZ >= 0.0F)
        {
            FLOAT fShad;
            FLOAT fAtten = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWATTENUATION];
            if (fZ > 1.0F)
            {
                // full shadow
                fShad = fAtten;
            }
            else
            {
                INT32 iFilterSize = m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] - D3DTFG_SHADOW_1 + 1;
                UINT32 uFilterArea = iFilterSize*iFilterSize;
                INT32 iMaskU = m_iWidth - 1;
                INT32 iMaskV = m_iHeight - 1;
                FLOAT fUCenter = (fU * m_iWidth/2) + m_iWidth/2;
                FLOAT fVCenter = (-fV * m_iHeight/2) + m_iHeight/2;
                INT32 u, v;
                UINT32 uShad = 0;

                for (v = -(iFilterSize-1)/2; v <= iFilterSize/2; v++)
                {
                    for (u = -(iFilterSize-1)/2; u <= iFilterSize/2; u++)
                    {

                        // Now, do U, V jitter
                        FLOAT fU = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWSIZE]*fRand2();
                        FLOAT fV = m_pStageState[iStage].m_fVal[D3DTSS_SHADOWSIZE]*fRand2();

                        // add offset to center of sample
                        fU += fUCenter;
                        fV += fVCenter;

                        INT32 iU = u + (INT32)fU;
                        INT32 iV = v + (INT32)fV;

                        if (((iU & ~iMaskU) == 0) && ((iV & ~iMaskV) == 0)) {
                            FLOAT fZJit = fZRange*fRand();
                            RRColor Texel;
                            BOOL bColorKeyMatched;  // ignore this for shadow mapping
                            ReadColor( iU, iV, 0, Texel, bColorKeyMatched );
                            if ( fZ > (FLOAT(Texel.G) + fZJit) ) {
                                // in shadow
                                uShad++;
                            }
                        }
                    }
                }

                fShad = (FLOAT)(uFilterArea - uShad);
                fShad = (1.0F - fAtten)*fShad/(FLOAT)uFilterArea + fAtten;
                fShad = min(fShad, 1.0F);
            }

            if (fShad < 1.0F)
            {
                OutputColor.A = fShad;
                OutputColor.R = fShad;
                OutputColor.G = fShad;
                OutputColor.B = fShad;
            }
        }
    }
#endif //__SHADOWBUFFER
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\setup.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// setup.cpp
//
// Direct3D Reference Rasterizer - Primitive Setup
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// SetPrimitiveAttributeFunctions - Common routine to compute attribute
// functions used for triangles, lines, and points.  (This could be done more
// efficiently for lines and points...).
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::SetPrimitiveAttributeFunctions(
    const RRFVFExtractor& Vtx0,
    const RRFVFExtractor& Vtx1,
    const RRFVFExtractor& Vtx2,
    const RRFVFExtractor& VtxFlat )
{

    // compute depth function
    m_pSCS->AttribFuncs[ATTRFUNC_Z].SetLinearFunc( Vtx0.GetZ(), Vtx1.GetZ(), Vtx2.GetZ() );

    // compute depth range for primitive (needed because we may sample slightly outside
    // the primitive when antialiasing which is generally OK for color and texture indices
    // but not for depth buffering)
    if ( D3DZB_USEW == m_dwRenderState[D3DRENDERSTATE_ZENABLE] )
    {
        // using W for depth buffering
        FLOAT fW0 = 1./Vtx0.GetRHW();
        FLOAT fW1 = 1./Vtx1.GetRHW();
        FLOAT fW2 = 1./Vtx2.GetRHW();
        m_pSCS->fDepthMin = MIN( fW0, fW1 );
        m_pSCS->fDepthMin = MIN( m_pSCS->fDepthMin, fW2 );
        m_pSCS->fDepthMax = MAX( fW0, fW1 );
        m_pSCS->fDepthMax = MAX( m_pSCS->fDepthMax, fW2 );
    }
    else
    {
        // using Z for depth buffering
        m_pSCS->fDepthMin = MIN( Vtx0.GetZ(), Vtx1.GetZ() );
        m_pSCS->fDepthMin = MIN( m_pSCS->fDepthMin, Vtx2.GetZ() );
        m_pSCS->fDepthMax = MAX( Vtx0.GetZ(), Vtx1.GetZ() );
        m_pSCS->fDepthMax = MAX( m_pSCS->fDepthMax, Vtx2.GetZ() );
    }

    // compute diffuse color functions
    if ( D3DSHADE_FLAT != m_dwRenderState[D3DRENDERSTATE_SHADEMODE] )
    {
        RRColor VtxColor0( Vtx0.GetDiffuse() );
        RRColor VtxColor1( Vtx1.GetDiffuse() );
        RRColor VtxColor2( Vtx2.GetDiffuse() );
        m_pSCS->AttribFuncs[ATTRFUNC_R].SetPerspFunc( VtxColor0.R, VtxColor1.R, VtxColor2.R );
        m_pSCS->AttribFuncs[ATTRFUNC_G].SetPerspFunc( VtxColor0.G, VtxColor1.G, VtxColor2.G );
        m_pSCS->AttribFuncs[ATTRFUNC_B].SetPerspFunc( VtxColor0.B, VtxColor1.B, VtxColor2.B );
        m_pSCS->AttribFuncs[ATTRFUNC_A].SetPerspFunc( VtxColor0.A, VtxColor1.A, VtxColor2.A );
    }
    else
    {
        RRColor VtxColor0( VtxFlat.GetDiffuse() );
        m_pSCS->AttribFuncs[ATTRFUNC_R].SetConstant( VtxColor0.R );
        m_pSCS->AttribFuncs[ATTRFUNC_G].SetConstant( VtxColor0.G );
        m_pSCS->AttribFuncs[ATTRFUNC_B].SetConstant( VtxColor0.B );
        m_pSCS->AttribFuncs[ATTRFUNC_A].SetConstant( VtxColor0.A );
    }

    // compute specular functions
    if ( m_qwFVFControl & D3DFVF_SPECULAR  )
    {
        if ( D3DSHADE_FLAT != m_dwRenderState[D3DRENDERSTATE_SHADEMODE] )
        {
            RRColor VtxSpecular0( Vtx0.GetSpecular() );
            RRColor VtxSpecular1( Vtx1.GetSpecular() );
            RRColor VtxSpecular2( Vtx2.GetSpecular() );
            m_pSCS->AttribFuncs[ATTRFUNC_SR].SetPerspFunc( VtxSpecular0.R, VtxSpecular1.R, VtxSpecular2.R );
            m_pSCS->AttribFuncs[ATTRFUNC_SG].SetPerspFunc( VtxSpecular0.G, VtxSpecular1.G, VtxSpecular2.G );
            m_pSCS->AttribFuncs[ATTRFUNC_SB].SetPerspFunc( VtxSpecular0.B, VtxSpecular1.B, VtxSpecular2.B );
            m_pSCS->AttribFuncs[ATTRFUNC_SA].SetPerspFunc( VtxSpecular0.A, VtxSpecular1.A, VtxSpecular2.A );
        }
        else
        {
            RRColor VtxSpecular0( VtxFlat.GetSpecular() );
            m_pSCS->AttribFuncs[ATTRFUNC_SR].SetConstant( VtxSpecular0.R );
            m_pSCS->AttribFuncs[ATTRFUNC_SG].SetConstant( VtxSpecular0.G );
            m_pSCS->AttribFuncs[ATTRFUNC_SB].SetConstant( VtxSpecular0.B );
            m_pSCS->AttribFuncs[ATTRFUNC_SA].SetConstant( VtxSpecular0.A );
        }
    }

    // compute vertex fog function
    if ( m_dwRenderState[D3DRENDERSTATE_FOGENABLE] &&
         ( m_dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] == D3DFOG_NONE ) )
    {
        FLOAT fF0 = (1/255.F)*(FLOAT)RGBA_GETALPHA( Vtx0.GetSpecular() );
        FLOAT fF1 = (1/255.F)*(FLOAT)RGBA_GETALPHA( Vtx1.GetSpecular() );
        FLOAT fF2 = (1/255.F)*(FLOAT)RGBA_GETALPHA( Vtx2.GetSpecular() );
        m_pSCS->AttribFuncs[ATTRFUNC_F].SetPerspFunc( fF0, fF1, fF2 );
    }

    // compute functions for all potential texture coordinates
    for(INT32 iStage = 0; iStage < m_cActiveTextureStages; iStage++)
    {
        for(INT32 i = 0; i < 4; i++)
        {
            if (m_pTexture[iStage])
            {
                m_pSCS->TextureFuncs[iStage][TEXFUNC_0 + i].SetPerspFunc(
                    m_pSCS->fTexCoord[iStage][0][i],
                    m_pSCS->fTexCoord[iStage][1][i],
                    m_pSCS->fTexCoord[iStage][2][i], m_pSCS->bWrap[iStage][i],
                    ((m_pTexture[iStage]->m_uFlags & RR_TEXTURE_SHADOWMAP) != 0));
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Triangle Drawing                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DoAreaCalcs - Takes 3 vertices and does screen area computations.
// Saves x, y, w's in RRSCANCNVSTATE, computes determinant, and does
// screen bounding box calculations.  Returns TRUE if the triangle is visible,
// FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL ReferenceRasterizer::DoAreaCalcs(FLOAT* pfDet, RRFVFExtractor* pVtx0,
                                      RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2)
{
    // set vertex data
    m_pSCS->fX0   = pVtx0->GetX();
    m_pSCS->fY0   = pVtx0->GetY();
    m_pSCS->fRHW0 = pVtx0->GetRHW();
    m_pSCS->fX1   = pVtx1->GetX();
    m_pSCS->fY1   = pVtx1->GetY();
    m_pSCS->fRHW1 = pVtx1->GetRHW();
    m_pSCS->fX2   = pVtx2->GetX();
    m_pSCS->fY2   = pVtx2->GetY();
    m_pSCS->fRHW2 = pVtx2->GetRHW();

    // compute determinant
    *pfDet = ComputeDeterminant(
        m_pSCS->fX0, m_pSCS->fY0,
        m_pSCS->fX1, m_pSCS->fY1,
        m_pSCS->fX2, m_pSCS->fY2 );

    if ( 0. == *pfDet ) { return FALSE; } // bail out if degenerate (no area)

    //
    // compute bounding box for scan area
    //
    FLOAT fXMin = MIN( m_pSCS->fX0, MIN( m_pSCS->fX1, m_pSCS->fX2 ) );
    FLOAT fXMax = MAX( m_pSCS->fX0, MAX( m_pSCS->fX1, m_pSCS->fX2 ) );
    FLOAT fYMin = MIN( m_pSCS->fY0, MIN( m_pSCS->fY1, m_pSCS->fY2 ) );
    FLOAT fYMax = MAX( m_pSCS->fY0, MAX( m_pSCS->fY1, m_pSCS->fY2 ) );
    // convert to integer (round to +inf)
    m_pSCS->iXMin = (INT16)(fXMin+.5);
    m_pSCS->iXMax = (INT16)(fXMax+.5);
    m_pSCS->iYMin = (INT16)(fYMin+.5);
    m_pSCS->iYMax = (INT16)(fYMax+.5);

    // clip bbox to rendering surface
    m_pSCS->iXMin = MAX( m_pSCS->iXMin, m_pRenderTarget->m_Clip.left   );
    m_pSCS->iXMax = MIN( m_pSCS->iXMax, m_pRenderTarget->m_Clip.right  );
    m_pSCS->iYMin = MAX( m_pSCS->iYMin, m_pRenderTarget->m_Clip.top    );
    m_pSCS->iYMax = MIN( m_pSCS->iYMax, m_pRenderTarget->m_Clip.bottom );

    // reject if no coverage
    if ( ( m_pSCS->iXMin < m_pRenderTarget->m_Clip.left   ) ||
         ( m_pSCS->iXMax > m_pRenderTarget->m_Clip.right  ) ||
         ( m_pSCS->iYMin < m_pRenderTarget->m_Clip.top    ) ||
         ( m_pSCS->iYMax > m_pRenderTarget->m_Clip.bottom ) )
    {
        return FALSE;
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoTexCoordCalcs - Takes 2 or 3 vertices and does texture coordinate setup.
// Sets up wrap flags, and conditionally does texture transform.
//
//-----------------------------------------------------------------------------
void ReferenceRasterizer::DoTexCoordCalcs(INT32 iStage, RRFVFExtractor* pVtx0,
                                      RRFVFExtractor* pVtx1, RRFVFExtractor* pVtx2)
{
    INT32 iCoordSet = m_pTexture[iStage]->m_pStageState[iStage].m_dwVal[D3DTSS_TEXCOORDINDEX];
    INT32 iTexGen = iCoordSet & 0xffff0000;
    iCoordSet &= 0xffff;

    // map per-coordinate set WRAP controls into per-stage WRAP controls
    m_pSCS->bWrap[iStage][0] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<0))?TRUE:FALSE;
    m_pSCS->bWrap[iStage][1] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<1))?TRUE:FALSE;
    m_pSCS->bWrap[iStage][2] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<2))?TRUE:FALSE;
    m_pSCS->bWrap[iStage][3] = (m_dwRenderState[D3DRENDERSTATE_WRAP0+iCoordSet] & (1<<3))?TRUE:FALSE;

    INT32 iNumCoords = 0;
    switch (D3DFVF_GETTEXCOORDSIZE(m_qwFVFControl, iCoordSet))
    {
    case D3DFVF_TEXTUREFORMAT1: iNumCoords = 1; break;
    case D3DFVF_TEXTUREFORMAT2: iNumCoords = 2; break;
    case D3DFVF_TEXTUREFORMAT3: iNumCoords = 3; break;
    case D3DFVF_TEXTUREFORMAT4: iNumCoords = 4; break;
    }

    FLOAT fTexGen[3][3];
    if (iTexGen != D3DTSS_TCI_PASSTHRU)
    {
        iNumCoords = 3;
        RRFVFExtractor* ppVtx[3] = { pVtx0, pVtx1, pVtx2 };

        for (INT32 i = 0; i < 3; i++)
        {
            if (ppVtx[i])
            {
                switch (iTexGen)
                {
                case D3DTSS_TCI_CAMERASPACENORMAL:
                    fTexGen[i][0] = ppVtx[i]->GetEyeNormal(0);
                    fTexGen[i][1] = ppVtx[i]->GetEyeNormal(1);
                    fTexGen[i][2] = ppVtx[i]->GetEyeNormal(2);
                    break;

                case D3DTSS_TCI_CAMERASPACEPOSITION:
                    fTexGen[i][0] = ppVtx[i]->GetEyeXYZ(0);
                    fTexGen[i][1] = ppVtx[i]->GetEyeXYZ(1);
                    fTexGen[i][2] = ppVtx[i]->GetEyeXYZ(2);
                    break;

                case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                    {
                        FLOAT fNX = ppVtx[i]->GetEyeNormal(0);
                        FLOAT fNY = ppVtx[i]->GetEyeNormal(1);
                        FLOAT fNZ = ppVtx[i]->GetEyeNormal(2);

                        if( GetRenderState()[D3DRENDERSTATE_LOCALVIEWER] == TRUE )
                        {
                            FLOAT fX = ppVtx[i]->GetEyeXYZ(0);
                            FLOAT fY = ppVtx[i]->GetEyeXYZ(1);
                            FLOAT fZ = ppVtx[i]->GetEyeXYZ(2);

                            // have to normalize before we reflect,
                            // result will be normalized
                            FLOAT fNorm = 1.0f/(FLOAT)sqrt(fX*fX + fY*fY + fZ*fZ);
                            fX *= fNorm; fY *= fNorm; fZ *= fNorm;
                            FLOAT fDot2 = 2.0f*(fX*fNX + fY*fNY + fZ*fNZ);
                            fTexGen[i][0] = fX - fNX*fDot2;
                            fTexGen[i][1] = fY - fNY*fDot2;
                            fTexGen[i][2] = fZ - fNZ*fDot2;
                        }
                        else
                        {
                            FLOAT fDot2 = 2.0f*fNZ;
                            fTexGen[i][0] = -fNX*fDot2;
                            fTexGen[i][1] = -fNY*fDot2;
                            fTexGen[i][2] = 1.f - fNZ*fDot2;
                        }

                    }
                    break;
                }
            }
        }
    }

    FLOAT fC[3][4];
    for (INT32 i = 0; i < 4; i++)
    {
        if (i < iNumCoords)
        {
            if (iTexGen != D3DTSS_TCI_PASSTHRU)
            {
                fC[0][i] = fTexGen[0][i];
                fC[1][i] = fTexGen[1][i];
                fC[2][i] = fTexGen[2][i];
            }
            else
            {
                fC[0][i] = pVtx0->GetTexCrd(i, iCoordSet);
                fC[1][i] = pVtx1->GetTexCrd(i, iCoordSet);
                if (pVtx2)
                {
                    fC[2][i] = pVtx2->GetTexCrd(i, iCoordSet);
                }
            }
        }
        else
        {
            if (i == iNumCoords)
            {
                fC[0][i] = 1.0f;
                fC[1][i] = 1.0f;
                fC[2][i] = 1.0f;
            }
            else
            {
                fC[0][i] = 0.0f;
                fC[1][i] = 0.0f;
                fC[2][i] = 0.0f;
            }
        }
    }

        // Do texture transform only if the original
    // vertices passed to the refrast were untransformed
    BOOL bAlreadyXfmd = FVF_TRANSFORMED( m_dwFVFIn );
    if (m_bPointSprite)
    {
        // disable texture transform if in point sprite mode
        bAlreadyXfmd = TRUE;
    }

    m_pTexture[iStage]->DoTextureTransform( iStage, bAlreadyXfmd, fC[0],
        m_pSCS->fTexCoord[iStage][0], &m_pSCS->fRHQW[iStage][0] );
    m_pTexture[iStage]->DoTextureTransform( iStage, bAlreadyXfmd, fC[1],
        m_pSCS->fTexCoord[iStage][1], &m_pSCS->fRHQW[iStage][1] );
    if (pVtx2)
    {
        m_pTexture[iStage]->DoTextureTransform( iStage, bAlreadyXfmd, fC[2],
            m_pSCS->fTexCoord[iStage][2], &m_pSCS->fRHQW[iStage][2] );
    }
    // shadow map interpolation must not envolve the W of the current
    // (viewing) perspective transform
    if ((m_pTexture[iStage]->m_uFlags & RR_TEXTURE_SHADOWMAP) == 0)
    {
        m_pSCS->fRHQW[iStage][0] *= m_pSCS->fRHW0;
        m_pSCS->fRHQW[iStage][1] *= m_pSCS->fRHW1;
        if (pVtx2)
        {
            m_pSCS->fRHQW[iStage][2] *= m_pSCS->fRHW2;
        }
    }
}

//-----------------------------------------------------------------------------
//
// DrawTriangle - Takes three vertices and does triangle setup, setting the
// primitive structure which is input to the triangle scanner, then
// invokes the scan conversion.
//
// This computes the triangle determinant (for culling and normalization) and
// the normalized edge distance and attribute functions.
//
// wFlags - Edge (and other) flags.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DrawTriangle(
   void* pvV0, void* pvV1, void* pvV2, WORD wFlags )
{
    DPFM(3, SETUP, ("DrawTriangle:\n"));

    // encase FVF vertex pointer and control in class to extract fields
    RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx1( pvV1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx2( pvV2, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

    FLOAT fDet;
    if (DoAreaCalcs(&fDet, &Vtx0, &Vtx1, &Vtx2) == FALSE)
    {
        return;
    }

    // do culling
    if (!m_bPointSprite)
    {
        switch ( m_dwRenderState[D3DRENDERSTATE_CULLMODE] )
        {
        case D3DCULL_NONE:  break;
        case D3DCULL_CW:    if ( fDet > 0. )  { return; }  break;
        case D3DCULL_CCW:   if ( fDet < 0. )  { return; }  break;
        }
    }

    //
    // process point and wireframe fill mode
    //
    if (!m_bPointSprite)
    {
        if ( m_dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT )
        {
            DrawPoint( pvV0, pvV0 );
            DrawPoint( pvV1, pvV0 );
            DrawPoint( pvV2, pvV0 );
            return;
        }
        else if ( m_dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME )
        {
            if ( wFlags & D3DTRIFLAG_EDGEENABLE1 ) { DrawLine( pvV0, pvV1, pvV0 ); }
            if ( wFlags & D3DTRIFLAG_EDGEENABLE2 ) { DrawLine( pvV1, pvV2, pvV0 ); }
            if ( wFlags & D3DTRIFLAG_EDGEENABLE3 ) { DrawLine( pvV2, pvV0, pvV0 ); }
            return;
        }
    }

    //
    // compute edge functions
    //
    m_pSCS->EdgeFuncs[0].Set( m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fX1, m_pSCS->fY1,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[1].Set( m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fX2, m_pSCS->fY2,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[2].Set( m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fX0, m_pSCS->fY0,
        fDet, m_bFragmentProcessingEnabled );

    // compute functions for texture coordinates
    if (m_cActiveTextureStages)
    {
        for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
        {
            if (m_pTexture[iStage])
            {
                DoTexCoordCalcs(iStage, &Vtx0, &Vtx1, &Vtx2);
            }
        }
    }

    // set attribute function static data to values for this triangle
    m_pSCS->AttribFuncStatic.SetPerTriangleData(
        m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fRHW0,
        m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fRHW1,
        m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fRHW2,
        m_cActiveTextureStages,
        (FLOAT*)&m_pSCS->fRHQW[0][0],
        fDet );

    // set attribute functions
    SetPrimitiveAttributeFunctions( Vtx0, Vtx1, Vtx2, Vtx0 );

    // not culled, so rasterize it
    DoScanCnvTri(3);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line Drawing                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// PointDiamondCheck - Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is pixel-relative
// test - this corresponds to an upper-left test for a vertex-relative position.
//
//-----------------------------------------------------------------------------
BOOL
PointDiamondCheck(
    INT32 iXFrac, INT32 iYFrac,
    BOOL bSlopeIsOne, BOOL bSlopeIsPosOne )
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf ) return TRUE;

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
        return TRUE;

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
        return TRUE;

    // return true if slope is one, vertex is on edge, and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
            return TRUE;

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
            return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//
// DrawLine - Takes two vertices and draws a line.
//
// This implements the Grid Intersect Quanization (GIQ) convention (which is
// also used in Windows).
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DrawLine(
   void* pvV0, void* pvV1, void* pvVFlat )
{
    DPFM(3, SETUP, ("DrawLine:\n"));

    // encase FVF vertex pointer and control in class to extract fields
    RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx1( pvV1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor VtxFlat( ( ( NULL != pvVFlat ) ? pvVFlat : pvV0 ),
        m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

    // set vertex data
    m_pSCS->fX0   = Vtx0.GetX();
    m_pSCS->fY0   = Vtx0.GetY();
    m_pSCS->fRHW0 = Vtx0.GetRHW();
    m_pSCS->fX1   = Vtx1.GetX();
    m_pSCS->fY1   = Vtx1.GetY();
    m_pSCS->fRHW1 = Vtx1.GetRHW();

    // compute n.4 fixed point vertex values
    INT32 iX0 = AS_INT32( (DOUBLE)m_pSCS->fX0 + DOUBLE_4_SNAP );
    INT32 iX1 = AS_INT32( (DOUBLE)m_pSCS->fX1 + DOUBLE_4_SNAP );
    INT32 iY0 = AS_INT32( (DOUBLE)m_pSCS->fY0 + DOUBLE_4_SNAP );
    INT32 iY1 = AS_INT32( (DOUBLE)m_pSCS->fY1 + DOUBLE_4_SNAP );

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // TODO: is this right???
    if ( ( iXSize == 0 ) && ( iYSize == 0 ) ) { return; }

    // determine major direction and compute line function
    FLOAT fLineMajorExtent; // signed extent from V0 to V1 in major direction
    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( labs( iXSize ) >= labs( iYSize )  )
    {
        // here for X major
        m_pSCS->bXMajor = TRUE;
        fLineMajorExtent = (FLOAT)iXSize * (1./16.);

        // line function: y = F(x) = ( [0]*x + [1] ) / [2]
        m_pSCS->iLineEdgeFunc[0] = iYSize;
        m_pSCS->iLineEdgeFunc[1] = (INT64)iY0*(INT64)iX1 - (INT64)iY1*(INT64)iX0;
        m_pSCS->iLineEdgeFunc[2] = iXSize;
    }
    else
    {
        // here for Y major
        m_pSCS->bXMajor = FALSE;
        fLineMajorExtent = (FLOAT)iYSize * (1./16.);

        // line function: x = F(y) = ( [0]*y + [1] ) / [2]
        m_pSCS->iLineEdgeFunc[0] = iXSize;
        m_pSCS->iLineEdgeFunc[1] = (INT64)iX0*(INT64)iY1 - (INT64)iX1*(INT64)iY0;
        m_pSCS->iLineEdgeFunc[2] = iYSize;
    }

    BOOL bSlopeIsOne = ( labs( iXSize ) == labs( iYSize ) );
    BOOL bSlopeIsPosOne =
        bSlopeIsOne &&
        ( ( (FLOAT)m_pSCS->iLineEdgeFunc[0]/(FLOAT)m_pSCS->iLineEdgeFunc[2] ) > 0. );

    // compute candidate pixel location for line endpoints
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for exception (slope == +1)
    // case else use nearest ceiling
    //
    // nearest ceiling of Y is ceil( Y - .5), and is done by converting to floor via:
    //
    //   ceil( A/B ) = floor( (A+B-1)/B )
    //
    // where A is coordinate - .5, and B is 0x10 (thus A/B is an n.4 fixed point number)
    //
    // A+B-1 = ( (Y - half) + B - 1 = ( (Y-0x8) + 0x10 - 0x1 = Y + 0x7
    // since B is 2**4, divide by B is right shift by 4
    //
    INT32 iPixX0 = ( iX0 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixX1 = ( iX1 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixY0 = ( iY0 + 0x7 ) >> 4;
    INT32 iPixY1 = ( iY1 + 0x7 ) >> 4;


    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0<<4), iY0 - (iPixY0<<4), bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1<<4), iY1 - (iPixY1<<4), bSlopeIsOne, bSlopeIsPosOne );

    // compute step value
    m_pSCS->iLineStep = ( fLineMajorExtent > 0 ) ? ( +1 ) : ( -1 );

    // compute float and integer major start (V0) and end (V1) positions
    INT32 iLineMajor0 = ( m_pSCS->bXMajor ) ? ( iX0 ) : ( iY0 );
    INT32 iLineMajor1 = ( m_pSCS->bXMajor ) ? ( iX1 ) : ( iY1 );
    m_pSCS->iLineMin = ( m_pSCS->bXMajor ) ? ( iPixX0 ) : ( iPixY0 );
    m_pSCS->iLineMax = ( m_pSCS->bXMajor ) ? ( iPixX1 ) : ( iPixY1 );

// need to do lots of compares which are flipped if major direction is negative
#define LINEDIR_CMP( _A, _B ) \
( ( fLineMajorExtent > 0 ) ? ( (_A) < (_B) ) : ( (_A) > (_B) ) )

    // do first pixel handling - keep first pixel if not in or behind diamond
    if ( !( bV0InDiamond || LINEDIR_CMP( iLineMajor0, (m_pSCS->iLineMin<<4) ) ) )
    {
        m_pSCS->iLineMin += m_pSCS->iLineStep;
    }

    // do last-pixel handling - keep last pixel if past diamond (in which case
    // the pixel is always filled) or if in diamond and rendering last pixel
    if ( !( ( !bV1InDiamond && LINEDIR_CMP( (m_pSCS->iLineMax<<4), iLineMajor1 ) ) ||
            ( bV1InDiamond && m_dwRenderState[D3DRENDERSTATE_LASTPIXEL] ) ) )
    {
        m_pSCS->iLineMax -= m_pSCS->iLineStep;
    }

    // return if no (major) extent (both before and after clamping to render buffer)
    if ( LINEDIR_CMP( m_pSCS->iLineMax, m_pSCS->iLineMin ) ) return;

    // snap major extent to render buffer
    INT16 iRendBufMajorMin = m_pSCS->bXMajor ? m_pRenderTarget->m_Clip.left  : m_pRenderTarget->m_Clip.top;
    INT16 iRendBufMajorMax = m_pSCS->bXMajor ? m_pRenderTarget->m_Clip.right : m_pRenderTarget->m_Clip.bottom;
    if ( ( ( m_pSCS->iLineMin < iRendBufMajorMin ) &&
           ( m_pSCS->iLineMax < iRendBufMajorMin ) ) ||
         ( ( m_pSCS->iLineMin > iRendBufMajorMax ) &&
           ( m_pSCS->iLineMax > iRendBufMajorMax ) ) )  { return; }
    m_pSCS->iLineMin = MAX( 0, MIN( iRendBufMajorMax, m_pSCS->iLineMin ) );
    m_pSCS->iLineMax = MAX( 0, MIN( iRendBufMajorMax, m_pSCS->iLineMax ) );

    // return if no (major) extent
    if ( LINEDIR_CMP( m_pSCS->iLineMax, m_pSCS->iLineMin ) ) return;


    // reject if line does not cross surface
    {
        // TODO
    }

    // compute functions for texture coordinates
    if (m_cActiveTextureStages)
    {
        for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
        {
            if (m_pTexture[iStage])
            {
                DoTexCoordCalcs(iStage, &Vtx0, &Vtx1, NULL);
            }
        }
    }

    // set attribute function static data to values for this line
    m_pSCS->AttribFuncStatic.SetPerLineData(
        m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fRHW0,
        m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fRHW1,
        m_cActiveTextureStages,
        (FLOAT*)&m_pSCS->fRHQW[0][0],
        fLineMajorExtent, m_pSCS->bXMajor );

    // set attribute functions
    SetPrimitiveAttributeFunctions( Vtx0, Vtx1, Vtx1, VtxFlat );

    // rasterize it
    DoScanCnvLine();
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Point Drawing                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

void
ReferenceRasterizer::DrawPoint(
   void* pvV0Public, void* pvVFlat )
{
    DPFM(3, SETUP, ("DrawPoint:\n"));

    DWORD dwStride = GetFVFVertexSize(m_qwFVFControl);
    void *pvV0 = MEMALLOC( dwStride );
    void *pvV1 = MEMALLOC( dwStride );
    void *pvV2 = MEMALLOC( dwStride );

    _ASSERTa( ( NULL != pvV0 ) && ( NULL != pvV1 ) && ( NULL != pvV2),
        "malloc failure on ReferenceRasterizer::DrawPoint", return; );

    memcpy(pvV0, pvV0Public, dwStride);
    memcpy(pvV1, pvV0Public, dwStride);
    memcpy(pvV2, pvV0Public, dwStride);

    // encase FVF vertex pointer and control in class to extract fields
    RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx1( pvV1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
    RRFVFExtractor Vtx2( pvV2, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

    // use per vertex S if it exists, otherwise use D3DRENDERSTATE_POINTSIZE
    BOOL bAlreadyXfmd = FVF_TRANSFORMED( m_dwFVFIn );

    FLOAT fS = 1.0f;
#ifdef __POINTSPRITES
    if (m_qwFVFControl & D3DFVF_S)
    {
        fS = Vtx0.GetS();
    }
    else if( m_dwDriverType > RRTYPE_DP2HAL )
    {
        fS = m_fRenderState[D3DRENDERSTATE_POINTSIZE];
    }
#endif

    // divide point size by 2 to get delta
    fS *= .5f;

    // Move points based on point size
    FLOAT *pXY = Vtx0.GetPtrXYZ();
    FLOAT fX3 = pXY[0] + fS;
    FLOAT fY3 = pXY[1] + fS;
    pXY[0] += -fS;
    pXY[1] += -fS;

    pXY = Vtx1.GetPtrXYZ();
    pXY[0] +=  fS;
    pXY[1] += -fS;

    pXY = Vtx2.GetPtrXYZ();
    pXY[0] += -fS;
    pXY[1] +=  fS;

    FLOAT fDet;
    if (DoAreaCalcs(&fDet, &Vtx0, &Vtx1, &Vtx2) == FALSE)
    {
        goto PointCleanupAndExit;
    }

    //
    // compute edge functions
    //
    m_pSCS->EdgeFuncs[0].Set( m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fX1, m_pSCS->fY1,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[1].Set( m_pSCS->fX1, m_pSCS->fY1, fX3, fY3,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[2].Set( fX3, fY3, m_pSCS->fX2, m_pSCS->fY2,
        fDet, m_bFragmentProcessingEnabled );
    m_pSCS->EdgeFuncs[3].Set( m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fX0, m_pSCS->fY0,
        fDet, m_bFragmentProcessingEnabled );

    // compute functions for texture coordinates
    if (m_cActiveTextureStages)
    {
        for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
        {
            if (m_pTexture[iStage])
            {
                DoTexCoordCalcs(iStage, &Vtx0, &Vtx1, &Vtx2);

#ifdef __POINTSPRITES
                if (m_dwRenderState[D3DRENDERSTATE_POINTSPRITEENABLE])
                {
                    // vtx0
                    m_pSCS->fTexCoord[iStage][0][0] = 0.0f;
                    m_pSCS->fTexCoord[iStage][0][1] = 0.0f;
                    m_pSCS->fTexCoord[iStage][0][2] = 1.0f;
                    m_pSCS->fTexCoord[iStage][0][3] = 0.0f;
                    m_pSCS->fRHQW[iStage][0] = m_pSCS->fRHW0;

                    // vtx1
                    m_pSCS->fTexCoord[iStage][1][0] = SPRITETEXCOORDMAX;
                    m_pSCS->fTexCoord[iStage][1][1] = 0.0f;
                    m_pSCS->fTexCoord[iStage][1][2] = 1.0f;
                    m_pSCS->fTexCoord[iStage][1][3] = 0.0f;
                    m_pSCS->fRHQW[iStage][1] = m_pSCS->fRHW1;

                    // vtx2
                    m_pSCS->fTexCoord[iStage][2][0] = 0.0f;
                    m_pSCS->fTexCoord[iStage][2][1] = SPRITETEXCOORDMAX;
                    m_pSCS->fTexCoord[iStage][2][2] = 1.0f;
                    m_pSCS->fTexCoord[iStage][2][3] = 0.0f;
                    m_pSCS->fRHQW[iStage][2] = m_pSCS->fRHW2;
                }
#endif //__POINTSPRITES
            }
        }
    }

    // set attribute function static data to values for this quad
    // (since slopes are constant for quad, any triangle can be used
    // to set them).
    m_pSCS->AttribFuncStatic.SetPerTriangleData(
        m_pSCS->fX0, m_pSCS->fY0, m_pSCS->fRHW0,
        m_pSCS->fX1, m_pSCS->fY1, m_pSCS->fRHW1,
        m_pSCS->fX2, m_pSCS->fY2, m_pSCS->fRHW2,
        m_cActiveTextureStages,
        (FLOAT*)&m_pSCS->fRHQW[0][0],
        fDet );

    // set attribute functions
    SetPrimitiveAttributeFunctions( Vtx0, Vtx1, Vtx2, Vtx0 );

    // not culled, so rasterize it
    DoScanCnvTri(4);

PointCleanupAndExit:
    MEMFREE(pvV0);
    MEMFREE(pvV1);
    MEMFREE(pvV2);
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\scancnv.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// scancnv.cpp
//
// Direct3D Reference Rasterizer - Primitive Scan Conversion
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Scan Conversion Utilities                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ComputePixelAttrib(Clamp/Tex) - Evaluates given linear function at current
// scan conversion position (m_SCCS.iX,iY).  Return is FLOAT value.
//
// Clamp version clamps result to 0. to 1. range.
//
// Tex version does texture coordinate function (unclamped).
//
//-----------------------------------------------------------------------------
FLOAT
ReferenceRasterizer::ComputePixelAttrib( int iAttrib )
{
    return m_pSCS->AttribFuncs[iAttrib].Eval();
}
FLOAT
ReferenceRasterizer::ComputePixelAttribClamp( int iAttrib )
{
    FLOAT fValue = ComputePixelAttrib( iAttrib );
    fValue = MAX( MIN( fValue, 1. ), 0. );
    return fValue;
}
//
// iStage specifies set of transformed texture coordinates
// iCrd specifies which value within coord
FLOAT
ReferenceRasterizer::ComputePixelAttribTex( int iStage, int iCrd )
{
    return m_pSCS->TextureFuncs[iStage][iCrd].Eval(iStage);
}

//-----------------------------------------------------------------------------
//
// ComputeFogIntensity - Computes scalar fog intensity value and writes it to
// the RRPixel.FogIntensity value.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::ComputeFogIntensity( RRPixel& Pixel )
{
    FLOAT fFogDensity, fPow;
    FLOAT fFogStart, fFogEnd;

    // select fog index - this is either Z or W depending on the W range
    //
    // use Z if projection matrix is set to an affine projection, else use W
    // (both for perspective projection and an unset projection matrix - the
    // latter is preferred for legacy content which uses TLVERTEX)
    //
    FLOAT fFogIndex =
        ( ( 1.f == m_pRenderTarget->m_fWRange[0] ) &&
          ( 1.f == m_pRenderTarget->m_fWRange[1] ) )
        ? ( MAX( MIN( ComputePixelAttribClamp( ATTRFUNC_Z ),
                m_pSCS->fDepthMax ), m_pSCS->fDepthMin ) )  // use clamped Z for affine projection
        : ( Pixel.fW );                                     // use W for non-affine projection

    // compute fog intensity
    if ( m_dwRenderState[D3DRENDERSTATE_FOGENABLE] )
    {
        // select between vertex and table fog - vertex fog is selected if
        // fog is enabled but the renderstate fog table mode is disabled
        switch ( m_dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] )
        {
        default:
        case D3DFOG_NONE:
            // table fog disabled, so use interpolated vertex fog value for fog intensity
            Pixel.FogIntensity = ComputePixelAttribClamp( ATTRFUNC_F );
            break;

        case D3DFOG_EXP:
            fFogDensity = m_fRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
            fPow = fFogDensity * fFogIndex;
            // note that exp(-x) returns a result in the range (0.0, 1.0]
            // for x >= 0
            Pixel.FogIntensity = (float)exp( -fPow );
            break;

        case D3DFOG_EXP2:
            fFogDensity = m_fRenderState[D3DRENDERSTATE_FOGTABLEDENSITY];
            fPow = fFogDensity * fFogIndex;
            Pixel.FogIntensity = (float)exp( -(fPow*fPow) );
            break;

        case D3DFOG_LINEAR:
            fFogStart = m_fRenderState[D3DRENDERSTATE_FOGTABLESTART];
            fFogEnd   = m_fRenderState[D3DRENDERSTATE_FOGTABLEEND];
            if (fFogIndex >= fFogEnd)
            {
                Pixel.FogIntensity = 0.0f;
            }
            else if (fFogIndex <= fFogStart)
            {
                Pixel.FogIntensity = 1.0f;
            }
            else
            {
                Pixel.FogIntensity = ( fFogEnd - fFogIndex ) / ( fFogEnd - fFogStart );
            }
            break;
        }
    }
}


//-----------------------------------------------------------------------------
//
// DoScanCnvGenPixel - This is called for each generated pixel, and extracts and
// processes attributes from the interpolator state, and passes the pixels on to
// the pixel processing module.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoScanCnvGenPixel( RRCvgMask CvgMask, BOOL bTri )
{
    // set per-pixel state for attribute evaluators
    m_pSCS->AttribFuncStatic.SetPerPixelData( m_pSCS->iX, m_pSCS->iY );

    // instantiate and fill out pixel struct
    RRPixel Pixel;
    memset(&Pixel, 0, sizeof(Pixel));
    Pixel.iX = m_pSCS->iX;
    Pixel.iY = m_pSCS->iY;
    Pixel.fW = m_pSCS->AttribFuncStatic.GetPixelW();
    Pixel.CvgMask = CvgMask;
    Pixel.Depth.SetSType(m_pRenderTarget->m_DepthSType);

    // get depth from clamp interpolator and clamp
    if ( m_dwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_dwRenderState[D3DRENDERSTATE_FOGENABLE])
    {
        if ( D3DZB_USEW == m_dwRenderState[D3DRENDERSTATE_ZENABLE] )
        {
            // depth buffering with W value
            FLOAT fW = Pixel.fW;

            // clamp to primitive range (due to sampling outside primitive for antialiasing)
            // (triangles only)
            if ( bTri )
            {
                fW = MAX( MIN( fW, m_pSCS->fDepthMax ), m_pSCS->fDepthMin );
            }

            // apply normalization to get to 0. to 1. range
            fW = (fW - m_fWBufferNorm[0]) * m_fWBufferNorm[1];

            Pixel.Depth = fW;
        }
        else
        {
            // depth buffering with Z value
            FLOAT fZ = ComputePixelAttribClamp( ATTRFUNC_Z );

            // clamp to primitive range (due to sampling outside primitive for antialiasing)
            // (triangles only)
            if ( bTri )
            {
                fZ = MAX( MIN( fZ, m_pSCS->fDepthMax ), m_pSCS->fDepthMin );
            }

            Pixel.Depth = fZ;
        }

        // snap off extra bits by converting to/from buffer format
        //
        // this is mainly because of storing RRDepth values in the fragment buffer
        // and then comparing these (higher resolution) values to the buffer value
        // when forming the fragment lists at each pixel - cleanly snapping off the
        // extra bits here solves this problem
        //
        switch ( m_pRenderTarget->m_DepthSType)
        {
        case RR_STYPE_Z16S0: Pixel.Depth = UINT16( Pixel.Depth ); break;
        case RR_STYPE_Z24S4:
        case RR_STYPE_Z24S8: Pixel.Depth = UINT32( Pixel.Depth ); break;
        case RR_STYPE_Z15S1: Pixel.Depth = UINT16( Pixel.Depth ); break;
        case RR_STYPE_Z32S0: Pixel.Depth = UINT32( Pixel.Depth ); break;
        case RR_STYPE_S1Z15: Pixel.Depth = UINT16( Pixel.Depth ); break;
        case RR_STYPE_S4Z24:
        case RR_STYPE_S8Z24: Pixel.Depth = UINT32( Pixel.Depth ); break;
        }
    }

    // set pixel diffuse color from clamped interpolator values
    Pixel.Color.A = ComputePixelAttribClamp( ATTRFUNC_A );
    Pixel.Color.R = ComputePixelAttribClamp( ATTRFUNC_R );
    Pixel.Color.G = ComputePixelAttribClamp( ATTRFUNC_G );
    Pixel.Color.B = ComputePixelAttribClamp( ATTRFUNC_B );

    // set pixel specular color from clamped interpolator values
    if ( m_qwFVFControl & D3DFVF_SPECULAR )
    {
        Pixel.Specular.A = ComputePixelAttribClamp( ATTRFUNC_SA );
        Pixel.Specular.R = ComputePixelAttribClamp( ATTRFUNC_SR );
        Pixel.Specular.G = ComputePixelAttribClamp( ATTRFUNC_SG );
        Pixel.Specular.B = ComputePixelAttribClamp( ATTRFUNC_SB );
    }

    // compute fog intensity
    ComputeFogIntensity( Pixel );

    // send to pixel processor
    DoPixel( Pixel );
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Triangle Scan Conversion                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DoScanCnvTri - Scans the bounding box of the triangle and generates pixels.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoScanCnvTri( int iEdgeCount )
{
    DPFM(3,RAST,("DoScanCnvTri:\n"))

    //
    // do simple scan of surface-intersected triangle bounding box
    //
    for ( m_pSCS->iY = m_pSCS->iYMin;
          m_pSCS->iY <= m_pSCS->iYMax;
          m_pSCS->iY++ )
    {
        for ( m_pSCS->iX = m_pSCS->iXMin;
              m_pSCS->iX <= m_pSCS->iXMax;
              m_pSCS->iX++ )
        {
            RRCvgMask CvgMask = 0xFFFF; // assume pixel is inside all edges

            for ( int iEdge=0; iEdge<iEdgeCount; iEdge++ )
            {
                if ( m_bFragmentProcessingEnabled )
                {
                    CvgMask &= m_pSCS->EdgeFuncs[iEdge].AATest( m_pSCS->iX, m_pSCS->iY) ;
                }
                else
                {
                    CvgMask &= m_pSCS->EdgeFuncs[iEdge].PSTest( m_pSCS->iX, m_pSCS->iY) ;
                }
            }

            if ( CvgMask != 0x0000 )
            {
                // pixel is not out, so process it
                DoScanCnvGenPixel( CvgMask, TRUE );
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line Scan Conversion                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.  Always returns true if wRepeatFactor is 0, which
// means pattern is disabled.
//
//----------------------------------------------------------------------------

static BOOL LinePatternStateMachine(DWORD dwLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    union
    {
        D3DLINEPATTERN LPat;
        DWORD dwLPat;
    } LinePat;
    LinePat.dwLPat = dwLinePattern;

    if (LinePat.LPat.wRepeatFactor)
    {
        WORD wBit = (LinePat.LPat.wLinePattern >> wPatterni) & 1;
        if (++wRepeati >= LinePat.LPat.wRepeatFactor)
        {
            wRepeati = 0;
            wPatterni = (wPatterni+1) & 0xf;
        }
        return (BOOL)wBit;
    }
    else
    {
        return TRUE;
    }
}

//-----------------------------------------------------------------------------
//
// DivRoundDown(A,B) = ceiling(A/B - 1/2)
//
// ceiling(A/B - 1/2) == floor(A/B + 1/2 - epsilon)
// == floor( (A + (B/2 - epsilon))/B )
//
// Does correct thing for all sign combinations of A and B.
//
//-----------------------------------------------------------------------------
INT64 DivRoundDown(INT64 iA, INT32 iB)
{
    INT32 i = 0;
    static const INT32 iEps[3] =
    {
        1,      // iA > 0, iB > 0
        0,      // iA < 0, iB > 0  OR iA > 0, iB < 0
        1       // iA < 0, iB < 0
    };
    if (iA < 0)
    {
        i++;
        iA = -iA;
    }
    if (iB < 0)
    {
        i++;
        iB = -iB;
    }
    iA += (iB-iEps[i]) >> 1;
    iA /= iB;
    if (iEps[i] == 0)
        iA = -iA;
    return(iA);
}

//-----------------------------------------------------------------------------
//
// DoScanCnvLine - Walks the line major axis, computes the appropriate minor
// axis coordinate, and generates pixels.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoScanCnvLine( void )
{
    DPFM(3,RAST,("DoScanCnvLine:\n"))

    // step in major axis
    INT16 iMajorCoord = m_pSCS->iLineMin;
    int cSteps = abs( m_pSCS->iLineMax - m_pSCS->iLineMin );
    // state for line pattern state machine
    WORD wRepeati = 0;
    WORD wPatterni = 0;

    for ( int cStep = 0; cStep <= cSteps; cStep++ )
    {
        // evaluate line function to compute minor coord for this major
        INT64 iMinorCoord =
            ( ( m_pSCS->iLineEdgeFunc[0] * (INT64)(iMajorCoord<<4) ) + m_pSCS->iLineEdgeFunc[1] );
        iMinorCoord = DivRoundDown(iMinorCoord, m_pSCS->iLineEdgeFunc[2]<<4);

        m_pSCS->iX = m_pSCS->bXMajor ? iMajorCoord : iMinorCoord;
        m_pSCS->iY = m_pSCS->bXMajor ? iMinorCoord : iMajorCoord;

        // check if the point is inside the viewport
        if ( ( m_pSCS->iX >= m_pRenderTarget->m_Clip.left   ) &&
             ( m_pSCS->iX <= m_pRenderTarget->m_Clip.right  ) &&
             ( m_pSCS->iY >= m_pRenderTarget->m_Clip.top    ) &&
             ( m_pSCS->iY <= m_pRenderTarget->m_Clip.bottom ) )
        {
            // The line pattern should have been walked in from its origin, which may have been
            // offscreen, to be completely correct.
            if (LinePatternStateMachine(m_dwRenderState[D3DRENDERSTATE_LINEPATTERN], wRepeati, wPatterni))
            {
                DoScanCnvGenPixel( 0xFFFF, FALSE );
            }
        }

        iMajorCoord += m_pSCS->iLineStep;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\texmap.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texmap.cpp
//
// Direct3D Reference Rasterizer - Texture Map Access Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

inline UINT8 CLAMP_BYTE(double f)
{
    if (f > 255.0) return 255;
    if (f < 0.0) return 0;
    return (BYTE) f;
}

//-----------------------------------------------------------------------------
// TexelFromBlock - decompress a color block and obtain texel color
//-----------------------------------------------------------------------------
UINT32 TexelFromBlock(RRSurfaceType surfType, char *pblockSrc,
                      int x, int y)
{
    UINT32 index = ((y & 0x3)<<2) + (x & 0x3);
    DDRGBA colorDst[DXT_BLOCK_PIXELS];

    switch(surfType)
    {
    case RR_STYPE_DXT1:
        DecodeBlockRGB((DXTBlockRGB *)pblockSrc, (DXT_COLOR *)colorDst);
        break;
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
        DecodeBlockAlpha4((DXTBlockAlpha4 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        DecodeBlockAlpha3((DXTBlockAlpha3 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    }

    return RGBA_MAKE(colorDst[index].red,
                     colorDst[index].green,
                     colorDst[index].blue,
                     colorDst[index].alpha);
}

//-----------------------------------------------------------------------------
//
// ReadTexelColor - Reads texel from texture map at given LOD; converts to
// RRColor format, applying palette if necessary; also performs colorkey by
// zero-ing out alpha
//
//-----------------------------------------------------------------------------
void
RRTexture::ReadColor(
    INT32 iX, INT32 iY, INT32 iLOD,
    RRColor& Texel, BOOL &bColorKeyMatched )
{
    if ( (iLOD > m_cLOD) && !(m_uFlags & RR_TEXTURE_ENVMAP) )
    {
        return;
    }
    if ( NULL == m_pTextureBits[iLOD] ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, m_pTextureBits[iLOD], m_iPitch[iLOD], m_SurfType );

    switch ( m_SurfType )
    {
    default:
        Texel.ConvertFrom( m_SurfType, pSurfaceBits );
        break;

    case RR_STYPE_PALETTE8:
        {
            UINT8 uIndex = *((UINT8*)pSurfaceBits);
            UINT32 uTexel = *( (UINT32*)(m_pPalette) + uIndex );
            Texel = RGBA_MAKE(
                (uTexel>> 0) & 0xff,
                (uTexel>> 8) & 0xff,
                (uTexel>>16) & 0xff,
                (uTexel>>24) & 0xff);
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RR_STYPE_PALETTE4:
        {
            UINT8 uIndex = *((INT8*)pSurfaceBits);
            if ((iX & 1) == 0) { uIndex &= 0xf; }
            else               { uIndex >>= 4;  }
            UINT32 uTexel = *( (UINT32*)(m_pPalette) + uIndex );
            Texel = RGBA_MAKE(
                (uTexel>> 0) & 0xff,
                (uTexel>> 8) & 0xff,
                (uTexel>>16) & 0xff,
                (uTexel>>24) & 0xff);
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RR_STYPE_UYVY:
    case RR_STYPE_YUY2:
        // Converts a given YUV (8bits each) to RGB scaled between 0 and 255
        // These are using the YCrCb to RGB algorithms given on page 30
        // in "VIDEO DEMYSTIFIED" by Keith Jack
        // ISBN#: 1-878707-09-4
        // IN PC graphics, even though they call it YUV, it is really YCrCb
        // formats that are used by most framegrabbers etc. Hence the pixel
        // data we will obtain in these YUV surfaces will most likely be this
        // and not the original YUV which is actually used in PAL broadcast
        // only (NTSC uses YIQ). So really, U should be called Cb (Blue color
        // difference) and V should be called Cr (Red color difference)
        //
        // These equations are meant to handle the following ranges
        // (from the same book):
        // Y (16 to 235), U and V (16 to 240, 128 = zero)
        //          -----------
        //           Y   U   V
        //          -----------
        // White  : 180 128 128
        // Black  : 16  128 128
        // Red    : 65  100 212
        // Green  : 112 72  58
        // Blue   : 35  212 114
        // Yellow : 162 44  142
        // Cyan   : 131 156 44
        // Magenta: 84  184 198
        //          -----------
        // It is assumed that the gamma corrected RGB range is (0 - 255)
        //
        // UYVY: U0Y0 V0Y1 U2Y2 V2Y3 (low byte always has current Y)
        // If iX is even, hight-byte has current U (Cb)
        // If iX is odd, hight-byte has previous V (Cr)
        //
        // YUY2: Y0U0 Y1V0 Y2U2 Y3V2 (high byte always has current Y)
        //       (UYVY bytes flipped)
        //
        // In this algorithm, we use U and V values from two neighboring
        // pixels
        {
            UINT8 Y, U, V;
            UINT16 u16Curr = *((UINT16*)pSurfaceBits);
            UINT16 u16ForU = 0; // Extract U from this
            UINT16 u16ForV = 0; // Extract V from this

            // By default we assume YUY2. Change it later if it is UYVY
            int uvShift = 8;
            int yShift  = 0;

            if (m_SurfType == RR_STYPE_UYVY)
            {
                uvShift = 0;
                yShift  = 8;
            }

            if ((iX & 1) == 0)
            {
                // Current U available
                u16ForU = u16Curr;

                // Obtain V from the next pixel
                if ( (iX < (m_iWidth >> iLOD)) || (m_uFlags & RR_TEXTURE_ENVMAP) )
                {
                    u16ForV = *((UINT16*)PixelAddress( iX+1, iY,
                                                       m_pTextureBits[iLOD],
                                                       m_iPitch[iLOD],
                                                       m_SurfType ));
                }
                else
                {
                    // This case should not be hit because the texture
                    // width is even (actually, a power of two)
                    _ASSERTa(0, "iX exceeds width", u16ForV = u16Curr;)
                }

            }
            else
            {
                // Current V available
                u16ForV = u16Curr;

                // Obtain U from the previous pixel
                if (iX > 0)
                {
                    u16ForU = *((UINT16*)PixelAddress( iX-1, iY,
                                                       m_pTextureBits[iLOD],
                                                       m_iPitch[iLOD],
                                                       m_SurfType ));
                }
                else
                {
                    // This case should not be hit because the texture
                    // width is even (actually, a power of two)
                    _ASSERTa(0, "iX is negative", u16ForU = u16Curr;)
                }
            }

            Y = (u16Curr >> yShift) & 0xff;
            U = (u16ForU >> uvShift) & 0xff;
            V = (u16ForV >> uvShift) & 0xff;

            Texel = RGB_MAKE(
                CLAMP_BYTE(1.164*(Y-16) + 1.596*(V-128)),
                CLAMP_BYTE(1.164*(Y-16) - 0.813*(V-128) - 0.391*(U-128)),
                CLAMP_BYTE(1.164*(Y-16) + 2.018*(U-128))
                );
            Texel.A = 1.f;
        }
        break;

    // S3 compressed formats:
    // We have the address to the block, now extract the actual color
    case RR_STYPE_DXT1:
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        Texel = TexelFromBlock(m_SurfType, pSurfaceBits, iX, iY);
        break;
    }

    // colorkey (only supported for legacy behavior)
    if ( m_bDoColorKeyKill || m_bDoColorKeyZero )
    {
        DWORD dwBits;
        switch ( m_SurfType )
        {
        default:
        case RR_STYPE_NULL:
            return;     // don't colorkey unknown or null surfaces

        case RR_STYPE_PALETTE4:
            {
                UINT8 uIndex = *((INT8*)pSurfaceBits);
                if ((iX & 1) == 0) { uIndex &= 0xf; }
                else               { uIndex >>= 4;  }
                dwBits = (DWORD)uIndex;
                }
            break;

        case RR_STYPE_L8:
        case RR_STYPE_PALETTE8:
        case RR_STYPE_B2G3R3:
        case RR_STYPE_L4A4:
            {
                UINT8 uBits = *((UINT8*)pSurfaceBits);
                dwBits = (DWORD)uBits;
                }
            break;

        case RR_STYPE_B5G6R5:
        case RR_STYPE_B5G5R5:
        case RR_STYPE_B5G5R5A1:
        case RR_STYPE_B4G4R4A4:
        case RR_STYPE_L8A8:
        case RR_STYPE_B2G3R3A8:
            {
                UINT16 uBits = *((UINT16*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;

        case RR_STYPE_B8G8R8:
            {
                UINT32 uBits = 0;
                uBits |= ( *((UINT8*)pSurfaceBits+0) ) <<  0;
                uBits |= ( *((UINT8*)pSurfaceBits+1) ) <<  8;
                uBits |= ( *((UINT8*)pSurfaceBits+2) ) << 16;
                dwBits = (DWORD)uBits;
            }
            break;

        case RR_STYPE_B8G8R8A8:
        case RR_STYPE_B8G8R8X8:
            {
                UINT32 uBits = *((UINT32*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;
        }

        if ( dwBits == m_dwColorKey )
        {
            bColorKeyMatched = TRUE;
            if (m_bDoColorKeyZero)
            {
                Texel.A = 0.F;
                Texel.R = 0.F;
                Texel.G = 0.F;
                Texel.B = 0.F;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\sources.inc ===
TARGETNAME = refrast
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);..\..\drv

SOURCES = \
        ..\refrast.cpp\
        ..\refrasti.cpp\
        ..\rtarget.cpp\
        ..\MapLegcy.cpp\
        ..\setup.cpp\
        ..\EdgeFunc.cpp\
        ..\AttrFunc.cpp\
        ..\scancnv.cpp\
        ..\texture.cpp\
        ..\texmap.cpp\
        ..\texstage.cpp\
        ..\pixproc.cpp\
        ..\PixRef.cpp\
        ..\fragproc.cpp\
        ..\fragrslv.cpp\
        ..\rrutil.cpp\
        ..\refs3tc.cpp\
        ..\shadow.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\clipping.hpp ===
#ifndef __CLIPPER_HPP_
#define __CLIPPER_HPP_

//----------------------------------------------------------------------------
// Clipping macros
//----------------------------------------------------------------------------
// Interpolation flags
#define RRCLIP_INTERPOLATE_COLOR       (1<< 0)
#define RRCLIP_INTERPOLATE_SPECULAR    (1<< 1)
#define RRCLIP_INTERPOLATE_TEXTURE     (1<< 2)
#define RRCLIP_INTERPOLATE_S           (1<< 3)
#define RRCLIP_INTERPOLATE_EYENORMAL   (1<< 4)
#define RRCLIP_INTERPOLATE_EYEXYZ      (1<< 5)

// Non guardband clipping bits
#define RRCLIP_LEFT   D3DCLIP_LEFT
#define RRCLIP_RIGHT  D3DCLIP_RIGHT
#define RRCLIP_TOP    D3DCLIP_TOP
#define RRCLIP_BOTTOM D3DCLIP_BOTTOM
#define RRCLIP_FRONT  D3DCLIP_FRONT
#define RRCLIP_BACK   D3DCLIP_BACK

//----------------------------------------------------------------------------
// User define clip plane bits.
// Each of these bits is set if the vertex is clipped by the associated
// clip plane.
//----------------------------------------------------------------------------
#define RRCLIP_USERCLIPPLANE0    D3DCLIP_GEN0
#define RRCLIP_USERCLIPPLANE1    D3DCLIP_GEN1
#define RRCLIP_USERCLIPPLANE2    D3DCLIP_GEN2
#define RRCLIP_USERCLIPPLANE3    D3DCLIP_GEN3
#define RRCLIP_USERCLIPPLANE4    D3DCLIP_GEN4
#define RRCLIP_USERCLIPPLANE5    D3DCLIP_GEN5
const DWORD RRCLIP_USERPLANES_ALL =  (RRCLIP_USERCLIPPLANE0 |
                                      RRCLIP_USERCLIPPLANE1 |
                                      RRCLIP_USERCLIPPLANE2 |
                                      RRCLIP_USERCLIPPLANE3 |
                                      RRCLIP_USERCLIPPLANE4 |
                                      RRCLIP_USERCLIPPLANE5 );

//---------------------------------------------------------------------
// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     RRCLIP_LEFT bit is set
// if x < -w*ax1           RRCLIPGB_LEFT bit is set
//---------------------------------------------------------------------

#define RRCLIPGB_LEFT    (RRCLIP_USERCLIPPLANE5 << 1)
#define RRCLIPGB_RIGHT   (RRCLIP_USERCLIPPLANE5 << 2)
#define RRCLIPGB_TOP     (RRCLIP_USERCLIPPLANE5 << 3)
#define RRCLIPGB_BOTTOM  (RRCLIP_USERCLIPPLANE5 << 4)




#define RRCLIP_ALL (RRCLIP_LEFT  | RRCLIP_RIGHT   |         \
                    RRCLIP_TOP   | RRCLIP_BOTTOM  |         \
                    RRCLIP_FRONT | RRCLIP_BACK    |         \
                    RRCLIP_USERPLANES_ALL)

#define RRCLIPGB_ALL (RRCLIPGB_LEFT | RRCLIPGB_RIGHT |      \
                      RRCLIPGB_TOP | RRCLIPGB_BOTTOM |      \
                      RRCLIP_FRONT | RRCLIP_BACK     |      \
                      RRCLIP_USERPLANES_ALL)

// If only these bits are set, then this point is inside the guard band
#define RRCLIP_INGUARDBAND (RRCLIP_LEFT | RRCLIP_RIGHT |    \
                            RRCLIP_TOP  | RRCLIP_BOTTOM)
//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define RRCLIP_LEFTBIT     1
#define RRCLIP_RIGHTBIT    2
#define RRCLIP_TOPBIT      3
#define RRCLIP_BOTTOMBIT   4
#define RRCLIP_FRONTBIT    5
#define RRCLIP_BACKBIT     6

#define RRCLIP_USERCLIPLANE0BIT     7
#define RRCLIP_USERCLIPLANE1BIT     8
#define RRCLIP_USERCLIPLANE2BIT     9
#define RRCLIP_USERCLIPLANE3BIT     10
#define RRCLIP_USERCLIPLANE4BIT     11
#define RRCLIP_USERCLIPLANE5BIT     12

#define RRCLIPGB_LEFTBIT   13
#define RRCLIPGB_RIGHTBIT  14
#define RRCLIPGB_TOPBIT    15
#define RRCLIPGB_BOTTOMBIT 16

#define CLIPPED_LEFT    (RRCLIP_USERCLIPPLANE5 << 1)
#define CLIPPED_RIGHT   (RRCLIP_USERCLIPPLANE5 << 2)
#define CLIPPED_TOP     (RRCLIP_USERCLIPPLANE5 << 3)
#define CLIPPED_BOTTOM  (RRCLIP_USERCLIPPLANE5 << 4)
#define CLIPPED_FRONT   (RRCLIP_USERCLIPPLANE5 << 5)
#define CLIPPED_BACK    (RRCLIP_USERCLIPPLANE5 << 6)

#define CLIPPED_ENABLE  (RRCLIP_USERCLIPPLANE5 << 7) // wireframe enable flag

#define CLIPPED_ALL (CLIPPED_LEFT|CLIPPED_RIGHT     \
             |CLIPPED_TOP|CLIPPED_BOTTOM            \
             |CLIPPED_FRONT|CLIPPED_BACK)

const DWORD CLIPPED_USERCLIPPLANE0 = RRCLIP_USERCLIPPLANE5 << 8;
const DWORD CLIPPED_USERCLIPPLANE1 = RRCLIP_USERCLIPPLANE5 << 9;
const DWORD CLIPPED_USERCLIPPLANE2 = RRCLIP_USERCLIPPLANE5 << 10;
const DWORD CLIPPED_USERCLIPPLANE3 = RRCLIP_USERCLIPPLANE5 << 11;
const DWORD CLIPPED_USERCLIPPLANE4 = RRCLIP_USERCLIPPLANE5 << 12;
const DWORD CLIPPED_USERCLIPPLANE5 = RRCLIP_USERCLIPPLANE5 << 13;


//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// cn    - clipVertex
// pVtx    - a TL vertex
// qwFVF - FVF of the input TL vertex
//---------------------------------------------------------------------
inline void
MakeClipVertexFromFVF( RRCLIPVTX& cv, LPVOID pVtx,
                       const RRVIEWPORTDATA& VData,
                       DWORD dwTexCoordSize,
                       UINT64 qwFVF, DWORD dwClipFlag,
                       DWORD dwClipMask)
{
    LPBYTE pv = (LPBYTE)pVtx;

    // If the clip flag for this vertex is set, that means that the
    // transformation loop has not computed the screen coordinates for
    // this vertex, it has simply stored the clip coordinates for this
    // vertex

#if 0
    float x = *(D3DVALUE *)&((DWORD *)pv)[0]
    float y = *(D3DVALUE *)&((DWORD *)pv)[1]
    float z = *(D3DVALUE *)&((DWORD *)pv)[2]
    float w = *(D3DVALUE *)&((DWORD *)pv)[3]
#endif

    if (dwClipFlag & dwClipMask)
    {
        // This is a clipped vertex, simply no screen coordinates
        cv.sx  = D3DVALUE(0);
        cv.sy  = D3DVALUE(0);
        cv.sz  = D3DVALUE(0);
        cv.rhw = D3DVALUE(0);

        // Since this vertex has been clipped, the transformation loop
        // has put in the clip coordinates instead
        cv.hx  = ((D3DVALUE*)pv)[0];
        cv.hy  = ((D3DVALUE*)pv)[1];
        cv.hz  = ((D3DVALUE*)pv)[2];
        cv.hw  = ((D3DVALUE*)pv)[3];
    }
    else
    {
        // This vertex is not clipped, so its screen coordinates have been
        // computed
        cv.sx  = ((D3DVALUE*)pv)[0];
        cv.sy  = ((D3DVALUE*)pv)[1];
        cv.sz  = ((D3DVALUE*)pv)[2];
        cv.rhw = ((D3DVALUE*)pv)[3];

        // Transform the screen coordinate back to the clipping space
        cv.hw  = 1.0f / cv.rhw;
        cv.hx  = (cv.sx - VData.offsetX) * cv.hw * VData.scaleXi;
        cv.hy  = (cv.sy - VData.offsetY) * cv.hw * VData.scaleYi;
        cv.hz  = (cv.sz - VData.offsetZ) * cv.hw * VData.scaleZi;

    }

    pv += sizeof(D3DVALUE) * 4;
    if (qwFVF & D3DFVF_DIFFUSE)
    {
        cv.color   = *(DWORD*)pv;
        pv += sizeof(D3DVALUE);

    }
    if (qwFVF & D3DFVF_SPECULAR)
    {
        cv.specular= *(DWORD*)pv;
        pv += sizeof(DWORD);
    }
    memcpy(cv.tex, pv, dwTexCoordSize);
    pv += dwTexCoordSize;
    if (qwFVF & D3DFVF_S)
    {
        cv.s= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYENORMAL)
    {
        cv.eyenx= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyeny= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyenz= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYEXYZ)
    {
        cv.eyex= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyey= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
        cv.eyez= *(FLOAT*)pv;
        pv += sizeof(FLOAT);
    }
    cv.clip = dwClipFlag;
}

//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//---------------------------------------------------------------------
inline void
MakeFVFVertexFromClip(LPVOID out, RRCLIPVTX *cv,
                      UINT64 qwFVF, DWORD dwTexCoordSize)
{
    LPBYTE pv = (LPBYTE)out;
    ((D3DVALUE*)pv)[0] = cv->sx;
    ((D3DVALUE*)pv)[1] = cv->sy;
    ((D3DVALUE*)pv)[2] = cv->sz;
    ((D3DVALUE*)pv)[3] = D3DVAL(1)/cv->hw;
    pv += sizeof(D3DVALUE)*4;
    if (qwFVF & D3DFVF_DIFFUSE)
    {
        *(DWORD*)pv = cv->color;
        pv += sizeof(DWORD);
    }
    if (qwFVF & D3DFVF_SPECULAR)
    {
        *(DWORD*)pv = cv->specular;
        pv += sizeof(DWORD);
    }
    memcpy(pv, &cv->tex, dwTexCoordSize);
    pv += dwTexCoordSize;
    if (qwFVF & D3DFVF_S)
    {
        *(FLOAT*)pv = cv->s;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYENORMAL)
    {
        *(FLOAT*)pv = cv->eyenx;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyeny;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyenz;
        pv += sizeof(FLOAT);
    }
    if (qwFVF & D3DFVFP_EYEXYZ)
    {
        *(FLOAT*)pv = cv->eyex;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyey;
        pv += sizeof(FLOAT);
        *(FLOAT*)pv = cv->eyez;
        pv += sizeof(FLOAT);
    }
}

//---------------------------------------------------------------------
// Returns TRUE if clipping is needed
//---------------------------------------------------------------------
inline BOOL
NeedClipping(BOOL bUseGB, RRCLIPCODE clipUnion)
{
    if( bUseGB && (clipUnion & ~RRCLIP_INGUARDBAND) )
    {
        return  TRUE;
    }
    else if( clipUnion )
    {
        return  TRUE;
    }

    return FALSE;
}


#endif //__CLIPPER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\clipping.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define GET_NEW_CLIP_VERTEX \
&m_clipping.clip_vertices[m_clipping.clip_vertices_used++];


//---------------------------------------------------------------------
inline void
InterpolateColor(RRCLIPVTX *out,
                 RRCLIPVTX *p1,
                 RRCLIPVTX *p2,
                 D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->color);
    g1 = RGBA_GETGREEN(p1->color);
    b1 = RGBA_GETBLUE(p1->color);
    a1 = RGBA_GETALPHA(p1->color);
    r2 = RGBA_GETRED(p2->color);
    g2 = RGBA_GETGREEN(p2->color);
    b2 = RGBA_GETBLUE(p2->color);
    a2 = RGBA_GETALPHA(p2->color);
    out->color = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                           (WORD)(g1 + (g2 - g1) * num_denom),
                           (WORD)(b1 + (b2 - b1) * num_denom),
                           (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
inline void
InterpolateSpecular(RRCLIPVTX *out,
                    RRCLIPVTX *p1,
                    RRCLIPVTX *p2,
                    D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->specular);
    g1 = RGBA_GETGREEN(p1->specular);
    b1 = RGBA_GETBLUE(p1->specular);
    a1 = RGBA_GETALPHA(p1->specular);
    r2 = RGBA_GETRED(p2->specular);
    g2 = RGBA_GETGREEN(p2->specular);
    b2 = RGBA_GETBLUE(p2->specular);
    a2 = RGBA_GETALPHA(p2->specular);
    out->specular = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                              (WORD)(g1 + (g2 - g1) * num_denom),
                              (WORD)(b1 + (b2 - b1) * num_denom),
                              (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
// Inline texture coordinate difference.
__inline FLOAT
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

//---------------------------------------------------------------------
inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
    {
        return ((t2 - t1) * num_denom + t1);
    }
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f) t -= 1.0f;
        return t;
    }
}
//
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//
int
RRProcessVertices::ClipByPlane( RRCLIPVTX **inv,
                                RRCLIPVTX **outv,
                                RRVECTOR4 *plane,
                                DWORD dwClipFlag,
                                int count )
{
    int i;
    int out_count = 0;
    RRCLIPVTX *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->hx*plane->x + prev->hy*plane->y +
                  prev->hz*plane->z + prev->hw*plane->w;
    for (i = count; i; i--)
    {
        curr_inside = curr->hx*plane->x + curr->hy*plane->y +
                      curr->hz*plane->z + curr->hw*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside))
        { // first point is outside
            if (FLOAT_GEZ(curr_inside))
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate( outv[out_count],
                             curr, prev,
                             (prev->clip & CLIPPED_ENABLE) | dwClipFlag,
                             curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside))
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate( outv[out_count],
                             prev, curr,
                             dwClipFlag,
                             prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int
RRProcessVertices::ClipLineByPlane(RRCLIPTRIANGLE *line,
                                   RRVECTOR4 *plane,
                                   DWORD dwClipBit)
{
    D3DVALUE in1, in2;
    RRCLIPVTX outv;
    in1 = line->v[0]->hx * plane->x +
          line->v[0]->hy * plane->y +
          line->v[0]->hz * plane->z +
          line->v[0]->hw * plane->w;
    in2 = line->v[1]->hx * plane->x +
          line->v[1]->hy * plane->y +
          line->v[1]->hz * plane->z +
          line->v[1]->hw * plane->w;
    if (in1 < 0)
    {
        if (in2 < 0)
            return 1;
        Interpolate( &outv, line->v[0], line->v[1],
                     dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    }
    else
    {
        if (in2 < 0)
        {
            Interpolate( &outv, line->v[0], line->v[1],
                         dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void
ComputeScreenCoordinates(const RRVIEWPORTDATA& VData,
                         RRCLIPVTX **inv, int count)
{
    int i;

    for (i = 0; i < count; i++)
    {
        RRCLIPVTX *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         *      1) Vertices generated during interpolation
         *      2) Vertices marked for clipping by the transform but
         *              not clipped here due to the finite precision
         *              of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE)
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->sx = VData.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VData.maxXgb; break;
            default:
                p->sx = p->hx * VData.scaleX * w + VData.offsetX;
                                if (p->sx < VData.minXgb)
                                        p->sx = VData.minXgb;
                                if (p->sx > VData.maxXgb)
                                        p->sx = VData.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->sy = VData.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VData.minYgb; break;
            default:
                p->sy = p->hy * VData.scaleY * w + VData.offsetY;
                                if (p->sy < VData.minYgb)
                                        p->sy = VData.minYgb;
                                if (p->sy > VData.maxYgb)
                                        p->sy = VData.maxYgb;
            }
            p->sz = p->hz * VData.scaleZ * w + VData.offsetZ;
            p->rhw = w;
        }
    }
}
//---------------------------------------------------------------------
void
RRProcessVertices::Interpolate(RRCLIPVTX *out,
                               RRCLIPVTX *p1,
                               RRCLIPVTX *p2,
                               int code,
                               D3DVALUE num,
                               D3DVALUE denom)
{
    DWORD dwInterpolate = m_clipping.dwInterpolate;
    D3DVALUE num_denom = num / denom;

    out->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    out->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    out->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    out->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    out->hw = p1->hw + (p2->hw - p1->hw) * num_denom;
    out->color = m_clipping.clip_color;
    out->specular = m_clipping.clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if (dwInterpolate & RRCLIP_INTERPOLATE_COLOR)
    {
        InterpolateColor(out, p1, p2, num_denom);
    }

    if (dwInterpolate & RRCLIP_INTERPOLATE_SPECULAR)
    {
        InterpolateSpecular(out, p1, p2, num_denom);
    }

    if (dwInterpolate & RRCLIP_INTERPOLATE_TEXTURE)
    {
        // Assume that D3DRENDERSTATE_WRAPi are sequential
        D3DVALUE *pTexture1 = p1->tex;
        D3DVALUE *pTexture2 = p2->tex;
        D3DVALUE *pTexture = out->tex;
        for (DWORD i = 0; i < m_dwNumTexCoords; i++)
        {
            DWORD wrapState = ((ReferenceRasterizer *)this)->GetRenderState()[D3DRENDERSTATE_WRAP0 + i];
            DWORD n = (DWORD)(m_dwTexCoordSize[i] >> 2);
            DWORD dwWrapBit = 1;
            for (DWORD j=0; j < n; j++)
            {
                *pTexture = InterpolateTexture(*pTexture1, *pTexture2,
                                               num_denom,
                                               wrapState & dwWrapBit);
                dwWrapBit <<= 1;
                pTexture ++;
                pTexture1++;
                pTexture2++;
            }
        }
    }
    if (dwInterpolate & RRCLIP_INTERPOLATE_S)
    {
        out->s = p1->s + (p2->s - p1->s) * num_denom;
    }
    if (dwInterpolate & RRCLIP_INTERPOLATE_EYENORMAL)
    {
        out->eyenx = p1->eyenx + (p2->eyenx - p1->eyenx) * num_denom;
        out->eyeny = p1->eyeny + (p2->eyeny - p1->eyeny) * num_denom;
        out->eyenz = p1->eyenz + (p2->eyenz - p1->eyenz) * num_denom;
    }
    if (dwInterpolate & RRCLIP_INTERPOLATE_EYEXYZ)
    {
        out->eyex = p1->eyex + (p2->eyex - p1->eyex) * num_denom;
        out->eyey = p1->eyey + (p2->eyey - p1->eyey) * num_denom;
        out->eyez = p1->eyez + (p2->eyez - p1->eyez) * num_denom;
    }
}

//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND

//---------------------------------------------------------------------
inline DWORD ComputeClipCodeUserPlanes( RRUSERCLIPPLANE *UserPlanes,
                                        RRCLIPVTX *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = RRCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if( UserPlanes[j].bActive )
        {
            RRVECTOR4& plane = UserPlanes[j].plane;
            if( (p->hx*plane.x +
                 p->hy*plane.y +
                 p->hz*plane.z +
                 p->hw*plane.w) < 0 )
            {
                clip |= dwClipBit;
            }
        }
        dwClipBit <<= 1;
    }
    return clip;
}

//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(const RRVIEWPORTDATA& VData, 
                               RRUSERCLIPPLANE *UserPlanes, RRCLIPVTX *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * VData.Kgbx1)
        clip |= RRCLIPGB_LEFT;
    if (p->hx > p->hw * VData.Kgbx2)
        clip |= RRCLIPGB_RIGHT;
    if (p->hy < p->hw * VData.Kgby1)
        clip |= RRCLIPGB_BOTTOM;
    if (p->hy > p->hw * VData.Kgby2)
        clip |= RRCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= RRCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(UserPlanes, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(RRUSERCLIPPLANE *UserPlanes, RRCLIPVTX *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= RRCLIP_LEFT;
    if (p->hx > p->hw)
        clip |= RRCLIP_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= RRCLIP_BOTTOM;
    if (p->hy > p->hw)
        clip |= RRCLIP_TOP;
    if (p->hz > p->hw)
        clip |= RRCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes(UserPlanes, p);
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}

//---------------------------------------------------------------------
// RRProcessVertices::UpdateClippingData
//             Updates clipping data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateClippingData( DWORD dwClipPlanesEnable )
{
    HRESULT hr = D3D_OK;

    // Update the user defined clip plane data
    for( DWORD i=0; i<RRMAX_USER_CLIPPLANES; i++ )
    {
        // Figure out if it is active
        m_xfmUserClipPlanes[i].bActive = (BOOL)(dwClipPlanesEnable & 0x1);
        dwClipPlanesEnable >>= 1;

        // If it is active, transform it into eye-space using the
        // view transform. The clip planes are defined in the
        // world space.
        if( m_xfmUserClipPlanes[i].bActive )
        {
            XformPlaneBy4x4Transposed( &m_userClipPlanes[i],
                                       &m_TransformData.m_VPSInv,
                                       &m_xfmUserClipPlanes[i].plane );
        }
    }
    m_dwDirtyFlags &= ~(RRPV_DIRTY_CLIPPLANES);
    return hr;
}

//----------------------------------------------------------------------------
//
// DrawOneClippedPrimitive
//
// Draw one clipped primitive.
//
//----------------------------------------------------------------------------
HRESULT
RRProcessVertices::DrawOneClippedPrimitive()
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;
    PUINT8 pVtx = (PUINT8) m_pvOut;
    RRCLIPCODE *pClip = m_pClipBuf;
    RRCLIPCODE c0, c1, c2;

    switch (m_primType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)m_dwNumVertices; i > 0; i--)
        {
            c0 = *pClip++;
            ((ReferenceRasterizer *)this)->DrawClippedPoint(pVtx, c0);
            pVtx += m_dwOutputVtxSize;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)m_dwNumVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c0 = *pClip++;
            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;
            ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                           pV1, c1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;
            c1 = *pClip;

            // Disable last-pixel setting for shared verties and store prestate.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)m_dwNumVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                c0 = c1;
                pVtx += m_dwOutputVtxSize;
                pV1 = pVtx;
                c1 = *(++pClip);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                               pV1, c1);
            }

            // Restore last-pixel setting.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + m_dwOutputVtxSize;
                c0 = *(++pClip);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV1, c1,
                                                               pV0, c0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)m_dwNumVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c0 = *pClip++;

            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;

            pV2 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c2 = *pClip++;

            ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                               pV1, c1,
                                                               pV2, c2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;
            pV2 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c2 = *pClip++;

            for (i = (INT)m_dwNumVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1; c0 = c1;
                pV1 = pV2; c1 = c2;
                pV2 = pVtx;
                pVtx += m_dwOutputVtxSize;
                c2 = *pClip++;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);

                pV0 = pV1; c0 = c1;
                pV1 = pV2; c1 = c2;
                pV2 = pVtx;
                pVtx += m_dwOutputVtxSize;
                c2 = *pClip++;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV2, c2,
                                                                   pV1, c1);
            }

            if (i > 0)
            {
                pV0 = pV1; c0 = c1;
                pV1 = pV2; c1 = c2;
                pV2 = pVtx; c2 = *pClip;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            RRCLIPCODE c0, c1, c2;

            pV2 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c2 = *pClip++;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += m_dwOutputVtxSize;
            c1 = *pClip++;
            for (i = (INT)m_dwNumVertices - 2; i > 0; i--)
            {
                pV0 = pV1; c0 = c1;
                pV1 = pVtx;
                pVtx += m_dwOutputVtxSize;
                c1 = *pClip++;
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DrawOneClippedIndexedPrimitive
//
// Draw one list of clipped indexed primitives.
//
//----------------------------------------------------------------------------
HRESULT
RRProcessVertices::DrawOneClippedIndexedPrimitive()
{
    INT i;
    PUINT8 pVtx = (PUINT8) m_pvOut;
    LPWORD puIndices = m_pIndices;
    PUINT8 pV0, pV1, pV2;
    RRCLIPCODE *pClip = m_pClipBuf;
    RRCLIPCODE c0, c1, c2;
    HRESULT hr;

    switch(m_primType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)m_dwNumIndices; i > 0; i--)
        {
            c0 = pClip[*puIndices];
            pV0 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            ((ReferenceRasterizer *)this)->DrawClippedPoint(pV0, c0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)m_dwNumIndices / 2; i > 0; i--)
        {
            c0 = pClip[*puIndices];
            pV0 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                           pV1, c1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(TRUE);
            // Initial pV1.
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            for (i = (INT)m_dwNumIndices - 1; i > 1; i--)
            {
                c0 = c1;
                pV0 = pV1;
                c1 = pClip[*puIndices];
                pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV0, c0,
                                                               pV1, c1);
            }
            // Restore last-pixel setting.
            ((ReferenceRasterizer *)this)->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                c0 = pClip[*puIndices];
                pV0 = pVtx + m_dwOutputVtxSize * (*puIndices);
                ((ReferenceRasterizer *)this)->DrawClippedLine(pV1, c1,
                                                               pV0, c0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)m_dwNumIndices; i > 0; i -= 3)
        {
            c0 = pClip[*puIndices];
            pV0 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c2 = pClip[*puIndices];
            pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                               pV1, c1,
                                                               pV2, c2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            c2 = pClip[*puIndices];
            pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);

            for (i = (INT)m_dwNumIndices - 2; i > 1; i -= 2)
            {
                c0 = c1; pV0 = pV1;
                c1 = c2; pV1 = pV2;
                c2 = pClip[*puIndices];
                pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);

                c0 = c1; pV0 = pV1;
                c1 = c2; pV1 = pV2;
                c2 = pClip[*puIndices];
                pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV2, c2,
                                                                   pV1, c1);
            }

            if (i > 0)
            {
                c0 = c1; pV0 = pV1;
                c1 = c2; pV1 = pV2;
                c2 = pClip[*puIndices];
                pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            c2 = pClip[*puIndices];
            pV2 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            // Preload initial pV0.
            c1 = pClip[*puIndices];
            pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
            for (i = (INT)m_dwNumIndices - 2; i > 0; i--)
            {
                c0 = c1; pV0 = pV1;
                c1 = pClip[*puIndices];
                pV1 = pVtx + m_dwOutputVtxSize * (*puIndices++);
                ((ReferenceRasterizer *)this)->DrawClippedTriangle(pV0, c0,
                                                                   pV1, c1,
                                                                   pV2, c2);
            }
        }
        break;

    default:
        DPFM(0, DRV, ("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOneClippedIndexedPrimitive"));
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

void
ReferenceRasterizer::DrawClippedTriangle( void* pvV0, RRCLIPCODE c0,
                                          void* pvV1, RRCLIPCODE c1,
                                          void* pvV2, RRCLIPCODE c2,
                                          WORD wFlags )
{
    DWORD dwInter = (c0 & c1 & c2);
    DWORD dwUnion = (c0 | c1 | c2);
    DWORD dwMask = (m_dwTLState & RRPV_GUARDBAND) ? RRCLIPGB_ALL : RRCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if (dwInter)
    {
        return;
    }

    // If all the vertices are in, draw and return
    if ((dwUnion & dwMask) == 0)
    {
        DrawTriangle( pvV0, pvV1, pvV2, wFlags );
        return;
    }

    // Do Clipping
    RRCLIPTRIANGLE newtri;
    RRCLIPVTX cv[3];

    MakeClipVertexFromFVF( cv[0], pvV0, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c0,
                           dwMask);
    MakeClipVertexFromFVF( cv[1], pvV1, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c1,
                           dwMask);
    MakeClipVertexFromFVF( cv[2], pvV2, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c2,
                           dwMask);

    newtri.v[0] = &cv[0]; cv[0].next = &cv[1];
    newtri.v[1] = &cv[1]; cv[1].next = &cv[2];
    newtri.v[2] = &cv[2]; cv[2].next = NULL;

    int count;
    RRCLIPVTX **ver;
    cv[0].clip |= CLIPPED_ENABLE;
    cv[1].clip |= CLIPPED_ENABLE;
    cv[2].clip |= CLIPPED_ENABLE;

    if (count = ClipSingleTriangle( &newtri, &ver ))
    {
        int i;

        // Temporary Byte Array
        if (m_clipping.ClipBuf.GetSize() < m_dwOutputVtxSize*count)
        {
            m_clipping.ClipBuf.Grow( m_dwOutputVtxSize*count );
        }
        LPBYTE pTLV = (LPBYTE)m_clipping.ClipBuf.GetAddress();
        LPBYTE p = pTLV;

        for (i = 0; i < count; i++)
        {
            MakeFVFVertexFromClip( p, ver[i], m_qwFVFOut,
                                   m_dwTextureCoordSizeTotal);
            p += m_dwOutputVtxSize;
        }

        // If it is in wireframe mode, convert the clipper output to
        // a line list.
        if (!m_bPointSprite && (GetRenderState()[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME))
        {
            DWORD dwEdgeFlags = 0;
            for (i = 0; i < count; i++)
            {
                if (ver[i]->clip & CLIPPED_ENABLE) dwEdgeFlags |= (1 << i);
                p += m_dwOutputVtxSize;
            }

            DoDrawOneEdgeFlagTriangleFan( this, m_dwOutputVtxSize,
                                          (PUINT8) pTLV, count,
                                          dwEdgeFlags );
        }
        else
        {
            DoDrawOnePrimitive( this, m_dwOutputVtxSize, (PUINT8) pTLV,
                                D3DPT_TRIANGLEFAN, count);
        }
    }
}

void
ReferenceRasterizer::DrawClippedLine( void* pvV0, RRCLIPCODE c0,
                                      void* pvV1, RRCLIPCODE c1,
                                      void* pvVFlat )
{
    DWORD dwInter = (c0 & c1);
    DWORD dwUnion = (c0 | c1);
    DWORD dwMask = (m_dwTLState & RRPV_GUARDBAND) ? RRCLIPGB_ALL : RRCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if (dwInter)
    {
        return;
    }

    // If all the vertices are in, draw and return
    if ((dwUnion & dwMask) == 0)
    {
        DrawLine( pvV0, pvV1, pvVFlat );
        return;
    }

    RRCLIPTRIANGLE newline;
    RRCLIPVTX cv[2];

    MakeClipVertexFromFVF( cv[0], pvV0, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c0,
                           dwMask);
    MakeClipVertexFromFVF( cv[1], pvV1, m_ViewData,
                           m_dwTextureCoordSizeTotal, m_qwFVFOut, c1,
                           dwMask);

    newline.v[0] = &cv[0];
    newline.v[1] = &cv[1];

    if (ClipSingleLine( &newline ))
    {
        // Temporary Byte Array
        if (m_clipping.ClipBuf.GetSize() < m_dwOutputVtxSize*2)
        {
            m_clipping.ClipBuf.Grow( m_dwOutputVtxSize*3 );
        }

        LPBYTE pTLV = (LPBYTE)m_clipping.ClipBuf.GetAddress();
        LPBYTE p = pTLV;
        MakeFVFVertexFromClip( p, newline.v[0], m_qwFVFOut,
                               m_dwTextureCoordSizeTotal);
        p += m_dwOutputVtxSize;
        MakeFVFVertexFromClip( p, newline.v[1], m_qwFVFOut,
                               m_dwTextureCoordSizeTotal);

        DrawLine( pTLV, p, pvVFlat );
    }
}

void
ReferenceRasterizer::DrawClippedPoint( void* pvV0, RRCLIPCODE c0,
                                       void* pvVFlat )
{
    // if definitely out
    if (c0 & (RRCLIP_FRONT | RRCLIP_BACK | (1<<RRCLIPGB_LEFTBIT) | (1<<RRCLIPGB_RIGHTBIT) |
        (1<<RRCLIPGB_TOPBIT) | (1<<RRCLIPGB_BOTTOMBIT)))
        return;

    // otherwise, could be in
    if (c0 == 0)
    {
        // is completely in, just draw it
        DrawPoint( pvV0, pvVFlat );
    }
    else
    {
        // use per vertex S if it exists, otherwise use D3DRENDERSTATE_POINTSIZE
        BOOL bAlreadyXfmd = FVF_TRANSFORMED( m_dwFVFIn );
        RRFVFExtractor Vtx0( pvV0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );

        FLOAT fS = 1.0f;
#ifdef __POINTSPRITES
        if (m_qwFVFControl & D3DFVF_S)
        {
            fS = Vtx0.GetS();
        }
        else if( m_dwDriverType > RRTYPE_DP2HAL )
        {
            fS = m_fRenderState[D3DRENDERSTATE_POINTSIZE];
        }
#endif

        if (fS <= 1.0f)
        {
            // too small and out
            return;
        }

#ifdef __POINTSPRITES
        if (c0 & (RRCLIP_USERCLIPPLANE0 | RRCLIP_USERCLIPPLANE1 | RRCLIP_USERCLIPPLANE2 |
            RRCLIP_USERCLIPPLANE3 | RRCLIP_USERCLIPPLANE4 | RRCLIP_USERCLIPPLANE5))
        {
            // large and potentially clipped, expand point sprite to quad and clip traditionally
            fS *= 0.5f;      // turn size into screen space offset to quad points from center
            FLOAT w_clip = Vtx0.GetRHW();   // not really the reciprocal
            FLOAT x_clip_size = fS*w_clip/m_ViewData.scaleX;
            FLOAT y_clip_size = fS*w_clip/m_ViewData.scaleY;

            UINT64 qwFVFControlSave = m_qwFVFControl;
            UINT64 qwFVFOutSave = m_qwFVFOut;
            DWORD dwOutputVtxSizeSave = m_dwOutputVtxSize;
            DWORD dwTextureCoordSizeTotalSave = m_dwTextureCoordSizeTotal;
            DWORD dwTexCoordSizeSave[D3DDP_MAXTEXCOORD];
            memcpy(dwTexCoordSizeSave, m_dwTexCoordSize, sizeof(DWORD)*D3DDP_MAXTEXCOORD);
            DWORD dwInterpolateSave = m_clipping.dwInterpolate;
            DWORD dwNumTexCoordsSave = m_dwNumTexCoords;

            INT32 iTexCount = 0;
            if (m_dwRenderState[D3DRENDERSTATE_POINTSPRITEENABLE] && m_cActiveTextureStages)
            {
                // look through texture stages to see how many texture indices are needed
                // since for POINTSPRITE mode, the input vertices don't even have to have any
                // texture coordinates.  Since this is an important advantage of using point
                // sprites, we have to deal with it.
                for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
                {
                    if (m_pTexture[iStage])
                    {
                        INT32 iCoordSet = m_pTexture[iStage]->m_pStageState[iStage].m_dwVal[D3DTSS_TEXCOORDINDEX];
                        iCoordSet &= 0xffff;
                        iTexCount = max(iCoordSet+1, iTexCount);
                        m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_TEXTURE;
                    }
                }
            }
            m_qwFVFOut &= ~(D3DFVF_TEXCOUNT_MASK | 0xffff0000);
            m_qwFVFOut |= (iTexCount << D3DFVF_TEXCOUNT_SHIFT) & D3DFVF_TEXCOUNT_MASK;
            m_qwFVFControl = m_qwFVFOut;
            m_dwNumTexCoords = FVF_TEXCOORD_NUMBER((DWORD)m_qwFVFOut);
            m_dwOutputVtxSize   = GetFVFVertexSize( m_qwFVFOut );
            m_dwTextureCoordSizeTotal = 0;
            ComputeTextureCoordSize((DWORD)m_qwFVFOut, m_dwTexCoordSize,
                                    &m_dwTextureCoordSizeTotal);

            void *pvVT0, *pvVT1, *pvVT2, *pvVT3;
            {
                pvVT0 = MEMALLOC( m_dwOutputVtxSize );
                pvVT1 = MEMALLOC( m_dwOutputVtxSize );
                pvVT2 = MEMALLOC( m_dwOutputVtxSize );
                pvVT3 = MEMALLOC( m_dwOutputVtxSize );

                _ASSERTa( ( NULL != pvVT0 ) && ( NULL != pvVT1 ) && ( NULL != pvVT2) && (NULL != pvVT2),
                    "malloc failure on ReferenceRasterizer::DrawClippedPoint", return; );

                // only copy as much data as we have
                DWORD dwStride = GetFVFVertexSize(qwFVFControlSave);
                memcpy(pvVT0, pvV0, dwStride);
                memcpy(pvVT1, pvV0, dwStride);
                memcpy(pvVT2, pvV0, dwStride);
                memcpy(pvVT3, pvV0, dwStride);
            }

            // encase FVF vertex pointer and control in class to extract fields
            RRFVFExtractor VtxT0( pvVT0, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
            RRFVFExtractor VtxT1( pvVT1, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
            RRFVFExtractor VtxT2( pvVT2, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );
            RRFVFExtractor VtxT3( pvVT3, m_qwFVFControl, m_dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] );


            FLOAT *pXY = VtxT0.GetPtrXYZ();
            pXY[0] += -x_clip_size;
            pXY[1] += -y_clip_size;

            pXY = VtxT1.GetPtrXYZ();
            pXY[0] +=  x_clip_size;
            pXY[1] += -y_clip_size;

            pXY = VtxT2.GetPtrXYZ();
            pXY[0] += -x_clip_size;
            pXY[1] +=  y_clip_size;

            pXY = VtxT3.GetPtrXYZ();
            pXY[0] +=  x_clip_size;
            pXY[1] +=  y_clip_size;

            if (m_dwRenderState[D3DRENDERSTATE_POINTSPRITEENABLE] && m_cActiveTextureStages)
            {
                // compute functions for texture coordinates
                if (m_cActiveTextureStages)
                {
                    for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
                    {
                        if (m_pTexture[iStage])
                        {
                            INT32 iCoordSet = m_pTexture[iStage]->m_pStageState[iStage].m_dwVal[D3DTSS_TEXCOORDINDEX];
                            iCoordSet &= 0xffff;
                            FLOAT *pUV = VtxT0.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = 0.0f;
                            pUV[1] = 0.0f;
                            pUV = VtxT1.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = SPRITETEXCOORDMAX;
                            pUV[1] = 0.0f;
                            pUV = VtxT2.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = 0.0f;
                            pUV[1] = SPRITETEXCOORDMAX;
                            pUV = VtxT3.GetPtrTexCrd(0, iCoordSet);
                            pUV[0] = SPRITETEXCOORDMAX;
                            pUV[1] = SPRITETEXCOORDMAX;
                        }
                    }
                }
            }
            RRCLIPCODE clipIntersection, clipUnion;
            RRCLIPCODE c[4];
            RRFVFExtractor* pVtxTs[4] = {&VtxT0, &VtxT1, &VtxT2, &VtxT3};
            for ( INT32 i= 0; i < 4; i++)
            {
                FLOAT x_clip = pVtxTs[i]->GetX();
                FLOAT y_clip = pVtxTs[i]->GetY();
                FLOAT z_clip = pVtxTs[i]->GetZ();
                FLOAT w_clip = pVtxTs[i]->GetRHW();
                c[i] = ComputeClipCodes(&clipIntersection, &clipUnion, x_clip, y_clip,
                                        z_clip, w_clip, 0.0f);
                if (c[i] == 0 || ((m_dwTLState & RRPV_GUARDBAND) && ((c[i] & ~RRCLIP_INGUARDBAND) == 0)))
                {
                    // need to compute screen coordinates
                    FLOAT inv_w_clip = 1.0f/w_clip;
                    FLOAT *pXYZW = pVtxTs[i]->GetPtrXYZ();
                    pXYZW[0] = x_clip * inv_w_clip * m_ViewData.scaleX +
                        m_ViewData.offsetX;
                    pXYZW[1] = y_clip * inv_w_clip * m_ViewData.scaleY +
                        m_ViewData.offsetY;
                    pXYZW[2] = z_clip * inv_w_clip * m_ViewData.scaleZ +
                        m_ViewData.offsetZ;
                    pXYZW[3] = inv_w_clip;
                }
            }
            // set point sprite mode in rasterizer
            m_bPointSprite = TRUE;

            DrawClippedTriangle(pvVT0, c[0], pvVT1, c[1], pvVT2, c[2], 0);
            DrawClippedTriangle(pvVT1, c[1], pvVT3, c[3], pvVT2, c[2], 0);

            // clear point sprite mode in rasterizer
            m_bPointSprite = FALSE;

            m_qwFVFControl = qwFVFControlSave;
            m_dwOutputVtxSize = dwOutputVtxSizeSave;
            m_qwFVFOut = qwFVFOutSave;
            m_dwTextureCoordSizeTotal = dwTextureCoordSizeTotalSave;
            memcpy(m_dwTexCoordSize, dwTexCoordSizeSave, sizeof(DWORD)*D3DDP_MAXTEXCOORD);
            m_clipping.dwInterpolate = dwInterpolateSave;
            m_dwNumTexCoords = dwNumTexCoordsSave;

            MEMFREE( pvVT0 );
            MEMFREE( pvVT1 );
            MEMFREE( pvVT2 );
            MEMFREE( pvVT3 );
        }
        else
        {
            // Just x y clipped.  Let bounding box handle it
            DrawPoint( pvV0, pvVFlat );
        }
#endif
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
////////////////////////////////////////////////////////////////////////////
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int
ReferenceRasterizer::ClipSingleTriangle(RRCLIPTRIANGLE *tri,
                                        RRCLIPVTX ***clipVertexPointer)
{
    int accept;
    int i, j;
    int count;
    RRCLIPVTX **inv;
    RRCLIPVTX **outv;
    RRCLIPVTX *p;
    ULONG_PTR swapv;
    D3DCOLOR diffuse1;          // Original colors
    D3DCOLOR specular1;
    D3DCOLOR diffuse2;
    D3DCOLOR specular2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    if (GetRenderState()[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = tri->v[0]->color;
        D3DCOLOR specular = tri->v[0]->specular;

        //Save original colors
        diffuse1  = tri->v[1]->color;
        specular1 = tri->v[1]->specular;
        diffuse2  = tri->v[2]->color;
        specular2 = tri->v[2]->specular;

        // copy all but fog intensity
        tri->v[1]->color= diffuse;
        tri->v[1]->specular &= 0xFF000000; tri->v[1]->specular |= (0x00FFFFFF & specular);
        tri->v[2]->color = diffuse;
        tri->v[2]->specular &= 0xFF000000; tri->v[2]->specular |= (0x00FFFFFF & specular);
    }
    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;
    count = 3;
    outv = m_clipping.clip_vbuf1;
    m_clipping.clip_color = tri->v[0]->color;
    m_clipping.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)m_clipping.clip_vbuf1;
        tmp2 = (ULONG_PTR)m_clipping.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    m_clipping.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (RRCLIPVTX**) (swapv - (ULONG_PTR) outv)

    if (accept & RRCLIP_FRONT)
    {
        count = ClipFront( inv, outv, count );
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (m_dwTLState & RRPV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & RRCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RRCLIPVTX *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(m_ViewData, 
                                                m_xfmUserClipPlanes, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & RRCLIP_BACK)
        {
            count = ClipBack( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_LEFT)
        {
            count = ClipLeftGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_RIGHT)
        {
            count = ClipRightGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_BOTTOM)
        {
            count = ClipBottomGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIPGB_TOP)
        {
            count = ClipTopGB( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & RRCLIP_FRONT)
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RRCLIPVTX *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode( m_xfmUserClipPlanes, p );
                else
                    accept |= p->clip;
            }
        }
        if (accept & RRCLIP_BACK)
        {
            count = ClipBack( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_LEFT)
        {
            count = ClipLeft( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_RIGHT)
        {
            count = ClipRight( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_BOTTOM)
        {
            count = ClipBottom( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & RRCLIP_TOP)
        {
            count = ClipTop( inv, outv, count );
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }

    dwClipBit = RRCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    // User Clip Planes
    for( j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if (accept & dwClipBit)
        {
            count = ClipByPlane( inv, outv, &m_xfmUserClipPlanes[j].plane,
                                 dwClippedBit, count);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

#undef SWAP

    ComputeScreenCoordinates( m_ViewData, inv, count );

    *clipVertexPointer = inv;
    m_clipping.current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}

//-----------------------------------------------------------------------
//
int
ReferenceRasterizer::ClipSingleLine( RRCLIPTRIANGLE *line )
{
    int         accept;
    int         j;
    D3DVALUE    in1, in2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    accept = (line->v[0]->clip | line->v[1]->clip);

    m_clipping.clip_color = line->v[0]->color;
    m_clipping.clip_specular = line->v[0]->specular;

    if (accept & D3DCLIP_FRONT)
        if (ClipLineFront(line))
            goto out_of_here;
    if (m_dwTLState & RRPV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            RRCLIPVTX * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(m_ViewData, m_xfmUserClipPlanes, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(m_ViewData, m_xfmUserClipPlanes, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_LEFT)
            if (ClipLineLeftGB( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_RIGHT)
            if (ClipLineRightGB( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_TOP)
            if (ClipLineTopGB( line ))
                goto out_of_here;
        if (accept & RRCLIPGB_BOTTOM)
            if (ClipLineBottomGB( line ))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT)
        {
            RRCLIPVTX * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode( m_xfmUserClipPlanes, p );
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode( m_xfmUserClipPlanes, p );
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK)
            if (ClipLineBack( line ))
                goto out_of_here;
        if (accept & D3DCLIP_LEFT)
            if (ClipLineLeft( line ))
                goto out_of_here;
        if (accept & D3DCLIP_RIGHT)
            if (ClipLineRight( line ))
                goto out_of_here;
        if (accept & D3DCLIP_TOP)
            if (ClipLineTop( line ))
                goto out_of_here;
        if (accept & D3DCLIP_BOTTOM)
            if (ClipLineBottom( line ))
                goto out_of_here;
    }

    // User Clip Planes
    dwClipBit = RRCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    for( j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if (accept & dwClipBit)
        {
            if( ClipLineByPlane( line, &m_xfmUserClipPlanes[j].plane,
                                 dwClippedBit ))
                goto out_of_here;
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

    ComputeScreenCoordinates(m_ViewData, line->v, 2);

    return 1;
out_of_here:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\texture.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texture.cpp
//
// Direct3D Reference Rasterizer - Texture Map Sampling & Filtering Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// overload new & delete so that it can be allocated from caller-controlled
// pool
//
//-----------------------------------------------------------------------------
void*
RRTexture::operator new(size_t)
{
    void* pMem = (void*)MEMALLOC( sizeof(RRTexture) );
    _ASSERTa( NULL != pMem, "malloc failure on Tex object", return NULL; );
    return pMem;
}
//-----------------------------------------------------------------------------
void
RRTexture::operator delete(void* pv,size_t)
{
    MEMFREE( pv );
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RRTexture::RRTexture( void )
{
    memset( this, 0, sizeof(*this) );
}
//-----------------------------------------------------------------------------
RRTexture::~RRTexture( void )
{
}


//-----------------------------------------------------------------------------
//
// Validate - Updates private data.  Must be called anytime public data is
// altered.
//
//-----------------------------------------------------------------------------
BOOL
RRTexture::Validate( void )
{
    // validate inputs
    BOOL bFail0 = ( m_cLOD >= RRTEX_MAXCLOD );  // too many LODs
    BOOL bFail1 = !( IsPowerOf2( m_iWidth ) );  // gotta be power of two
    BOOL bFail2 = !( IsPowerOf2( m_iHeight ) );
    if ( bFail0 || bFail1 || bFail2 )
    {
        DPFRR(1,"RRTexture::Validate failed (%d,%d,%d)", bFail0, bFail1, bFail2);
        return FALSE;
    }

    // set internal size reps
    m_iTexSize[0] = (INT16)m_iWidth;
    m_iTexSize[1] = (INT16)m_iHeight;

    // mask is size-1 because these have to be power-of-two
    m_uTexMask[0] = (UINT16)m_iTexSize[0]-1;
    m_uTexMask[1] = (UINT16)m_iTexSize[1]-1;
    // shift is log2 of size
    m_iTexShift[0] = (INT16)FindFirstSetBit( m_iTexSize[0], 16 );
    m_iTexShift[1] = (INT16)FindFirstSetBit( m_iTexSize[1], 16 );

    // compute the 'has alpha' flag
    m_bHasAlpha = FALSE;
    switch ( m_SurfType )
    {
    case RR_STYPE_B8G8R8A8:
    case RR_STYPE_B5G5R5A1:
    case RR_STYPE_B4G4R4A4:
    case RR_STYPE_L8A8:
    case RR_STYPE_L4A4:
    case RR_STYPE_B2G3R3A8:
    case RR_STYPE_DXT1:
    case RR_STYPE_DXT2:
    case RR_STYPE_DXT3:
    case RR_STYPE_DXT4:
    case RR_STYPE_DXT5:
        m_bHasAlpha = TRUE;
        break;
    case RR_STYPE_PALETTE4:
    case RR_STYPE_PALETTE8:
        m_bHasAlpha = ( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) ? TRUE : FALSE;
        break;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoLookupAndFilter - Called once per active texture stage to compute
// coverage (level-of-detail) and invoke texel read and filtering routines.
// Returns filtered texel.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoLookupAndFilter(
    INT32 iStage,
    RRTextureCoord TCoord,      // local copy
    RRColor& TextureColor)
{
    // check for potential mip mapping
    BOOL bDoMipMap = ( m_cLOD > 0 ) && ( m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] > D3DTFP_NONE );

    // check for requirement to do level-of-detail (coverage) computation - either
    // for mipmap or per-pixel filter selection
    BOOL bComputeLOD = bDoMipMap ||
        ( m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] != m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER] );

    // check for anisotropic filtering in either mag filter or in min filter
    BOOL bDoAniso =
        ( D3DTFG_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] ) ||
        ( bComputeLOD && (D3DTFN_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]) );

    if ( bDoMipMap || bDoAniso || bComputeLOD )
    {
        // here if doing mipmapping or anisotropic filtering, or just have a mismatch
        // between the min and mag filters, so compute level of detail (and maybe aniso
        // coverage)

        // scale gradients to texture LOD 0 size
        TCoord.fDUDX *= (FLOAT)m_iTexSize[0];
        TCoord.fDUDY *= (FLOAT)m_iTexSize[0];
        TCoord.fDVDX *= (FLOAT)m_iTexSize[1];
        TCoord.fDVDY *= (FLOAT)m_iTexSize[1];

        // compute level of detail (and maybe anisotropic controls)
        FLOAT fLOD, fAnisoRatio, fAnisoDelta[2];
        (bDoAniso)
            ? ComputeAnisotropicLevelOfDetail( TCoord, (FLOAT)m_pStageState[iStage].m_dwVal[D3DTSS_MAXANISOTROPY],
                                                       fLOD, fAnisoRatio,fAnisoDelta )
            : ComputeSimpleLevelOfDetail     ( TCoord, fLOD );

// Uncomment the line below to see the anisotropy by color.  White is 1:1, darker is more
// anisotropy.
//#define COLOR_BY_ANISOTROPY 1
#ifdef COLOR_BY_ANISOTROPY
static RRColor PseudoColors[16] =
{
    0xffffffff,
    0xffffff00,
    0xffff00ff,
    0xff00ffff,

    0xff888888,
    0xff0000ff,
    0xff00ff00,
    0xffff0000,

    0xff444444,
    0xff888800,
    0xff880088,
    0xff008888,

    0xff222222,
    0xff000088,
    0xff008800,
    0xff880000,
};
        INT32 iPseudoColor = (INT32)(fAnisoRatio - .5);     // round, and make 1.0F == index 0
        iPseudoColor = min(max(iPseudoColor, 0), 15);

        TextureColor = PseudoColors[iPseudoColor];
        return;
#endif

        // apply bias and compute integer (n.5) LOD
        INT16 iLOD = 0;
        if ( bComputeLOD )
        {
            // apply LOD offset
            fLOD += m_pStageState[iStage].m_fVal[D3DTSS_MIPMAPLODBIAS];
            // convert LOD to n.5 fixed point integer
            iLOD = AS_INT16( fLOD + FLOAT_5_SNAP );
        }

        // determine if magnifying or minifying
        BOOL bMagnify = ( iLOD <= 0 );

        // zero out LOD if not mipmapping
        if ( !bDoMipMap ) { iLOD = 0; }

        // do different filtering for magnify vs. minify
        if ( bMagnify )
        {
            // here for magnify - do either (non-anisotropic) magnify or
            // anisotropic filter
            if ( D3DTFG_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] )
            {
                DoAniso( iStage, TCoord, iLOD,fAnisoRatio,fAnisoDelta, TextureColor );
            }
            else
            {
                DoMagnify( iStage, TCoord, TextureColor );
            }
        }
        else
        {
            // here for minify -  do either simple minify, trilerp,
            // or anisotropic filter
            if ( D3DTFN_ANISOTROPIC == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER] )
            {
                DoAniso( iStage, TCoord, iLOD,fAnisoRatio,fAnisoDelta, TextureColor );
            }
            else
            {
                if ( !bDoMipMap ||
                    ( bDoMipMap && ( D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] ) ) )
                {
                    DoMinify( iStage, TCoord, iLOD, TextureColor );
                }
                else
                {
                    DoTrilerp( iStage, TCoord, iLOD, TextureColor );
                }
            }
        }
    }
    else
    {
        // here for no mipmaps and matching (and non-aniso) min and mag filters,
        // so just apply mag filter
        DoMagnify( iStage, TCoord, TextureColor );
    }
}

//-----------------------------------------------------------------------------
//
// DoMapLookupLerp - Performs texture index ADDRESS processing followed by
// a lookup within a single DD surface (a single LOD within a chain of DD
// surfaces).  Dies BILINEAR filter operation for lookup.
//
// This is called once per pixel for BILINEAR, twice per pixel when
// doing mipmap trilinear interpolation.
//
// * texture index inputs are n.5 fixed point
// * LOD input is 0..n count where 0 indicates the largest LOD
//
//-----------------------------------------------------------------------------

RRColor RRTexture::DoMapLookupLerp(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD)
{
    // extract fraction bits
    UINT8 uUFrac = iU&0x1f;
    UINT8 uVFrac = iV&0x1f;

    // take floor for (0,0) sample coords
    INT16 iU0 = iU>>5;
    INT16 iV0 = iV>>5;
    // take ceiling for (1,1) sample coords
    INT16 iU1 = iU0+1;
    INT16 iV1 = iV0+1;

    BOOL bColorKeyMatched00 = FALSE;
    BOOL bColorKeyMatched01 = FALSE;
    BOOL bColorKeyMatched10 = FALSE;
    BOOL bColorKeyMatched11 = FALSE;

    // grab four adjacent samples (or border color)
    RRColor Texel00 = DoMapLookupNearest( iStage, iU0, iV0, iLOD, bColorKeyMatched00);
    RRColor Texel01 = DoMapLookupNearest( iStage, iU1, iV0, iLOD, bColorKeyMatched01);
    RRColor Texel10 = DoMapLookupNearest( iStage, iU0, iV1, iLOD, bColorKeyMatched10);
    RRColor Texel11 = DoMapLookupNearest( iStage, iU1, iV1, iLOD, bColorKeyMatched11);

    // only set 'colorkey matched' if at least one matched value has
    // a non-zero contribution (note that it is not possible for 00
    // to have no contribution)
    if (uUFrac == 0x00) {
        // 01 and 11 have zero weight if U fraction is zero
        bColorKeyMatched01 = bColorKeyMatched11 = FALSE;
    }
    if (uVFrac == 0x00) {
        // 10 and 11 have zero weight if V fraction is zero
        bColorKeyMatched10 = bColorKeyMatched11 = FALSE;
    }

    // merge colorkey match info from previous invocation
    m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched00 || bColorKeyMatched01 ||
        bColorKeyMatched10 || bColorKeyMatched11;

    // do bilinear filter
    RRColor Texel;
    BiLerpColor( Texel, Texel00,Texel01, Texel10,Texel11, uUFrac,uVFrac);
    return Texel;
}

//-----------------------------------------------------------------------------
//
// DoMapLookupNearest - Performs texture index ADDRESS processing followed by
// a lookup within a single DD surface (a single LOD within a chain of DD
// surfaces).  Does NEAREST operation for lookup.
//
// This is called once per pixel for NEAREST , twice per pixel when
// doing mipmap trilinear interpolation
//
// * texture index inputs are n.0 fixed point
// * LOD input is 0..n count where 0 indicates the largest LOD
// * texture index extend mode processing is also performed here - this works
//   for power-of-two texture sizes only.
//
//-----------------------------------------------------------------------------
RRColor RRTexture::DoMapLookupNearest(INT32 iStage, INT32 iU, INT32 iV, INT16 iLOD, BOOL &bColorKeyMatched)
{
    // LSB-aligned masks of index bits within current LOD
    INT16 iUMask = m_uTexMask[0] >> iLOD;
    INT16 iVMask = m_uTexMask[1] >> iLOD;

    // boolean for BORDER - if true then use border color for corresponding sample
    BOOL bUseBorder = FALSE;

    // not matched by default
    bColorKeyMatched = FALSE;

    // do texture ADDRESS processing for U axis
    switch ( m_pStageState[iStage].m_dwVal[D3DTSS_ADDRESSU] )
    {
    case D3DTADDRESS_WRAP:
        // just lop off non-fractional bits
        iU &= iUMask;
        break;
    case D3DTADDRESS_MIRROR:
        // lop off non-fractional bits + flip index if LSB (non-fraction) is set
        BOOL bFlip;
        bFlip = iU & (iUMask+1); iU &= iUMask; if (bFlip) {iU = iUMask - iU;}
        break;

    case D3DTADDRESS_BORDER:
        // compute booleans for which of 4 samples should use border color
        if ((iU < 0) || (iU > iUMask)) { bUseBorder = TRUE;}
        break;

    case D3DTADDRESS_CLAMP:
        // use texels on texture map edge
        iU = MAX( 0, MIN( iU, iUMask ) );
        break;
    }

    // do texture ADDRESS processing for V axis
    switch ( m_pStageState[iStage].m_dwVal[D3DTSS_ADDRESSV] )
    {
    case D3DTADDRESS_WRAP:
        iV &= iVMask;
        break;
    case D3DTADDRESS_MIRROR:
        BOOL bFlip;
        bFlip = iV & (iVMask+1); iV &= iVMask; if (bFlip) {iV = iVMask - iV;}
        break;

    case D3DTADDRESS_BORDER:
        if ((iV < 0) || (iV > iVMask)) { bUseBorder = TRUE; }
        break;

    case D3DTADDRESS_CLAMP:
        iV = MAX( 0, MIN( iV, iVMask ) );
        break;
    }

     // just lookup and return texel at (iU0,iV0)
    RRColor Texel;
    (bUseBorder)
            ? Texel = m_pStageState[iStage].m_dwVal[D3DTSS_BORDERCOLOR]
            : ReadColor( iU, iV, iLOD, Texel, bColorKeyMatched );
    return Texel;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Texture Filtering Routines                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//-----------------------------------------------------------------------------
//
// DoLookup - Does a full lookup given floating point U, V and handles all
// nearest vs bilinear and LOD issues.
//
//-----------------------------------------------------------------------------

RRColor RRTexture::DoLookup(INT32 iStage, float U, float V, INT16 iLOD, BOOL bNearest)
{
    INT32 cUPixels = 1 << MAX(m_iTexShift[0]-iLOD,0);
    INT32 cVPixels = 1 << MAX(m_iTexShift[1]-iLOD,0);
    FLOAT fScaledU = ( U * (FLOAT)cUPixels ) -.5f;
    FLOAT fScaledV = ( V * (FLOAT)cVPixels ) -.5f;
    if(bNearest)
    {
        INT32 iU, iV;
        // truncate to -infinity to be compatible with ANDing off low order
        // bits of a fixed point fScaledCoord.  This makes the generation of
        // iCoord more hardware like, and does not make a glitch at 0 for
        // a wrapped texture.
        if (U >= 0.0f)
        {
            iU = fScaledU + .5f;
        }
        else
        {
            iU = fScaledU - .5f;
        }
        if (V >= 0.0f)
        {
            iV = fScaledV + .5f;
        }
        else
        {
            iV = fScaledV - .5f;
        }
        BOOL bColorKeyMatched = FALSE;
        RRColor Texel = DoMapLookupNearest(iStage,iU,iV,iLOD,bColorKeyMatched);
        // merge colorkey match info from previous invocation
        m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched;
        return Texel;
    }
    else
    {
        INT32 iU = AS_INT32( (DOUBLE)fScaledU + DOUBLE_5_SNAP );// or:   iU = fScaledU*32. + .5;
        INT32 iV = AS_INT32( (DOUBLE)fScaledV + DOUBLE_5_SNAP );
        return DoMapLookupLerp(iStage,iU,iV,iLOD);
    }
}


//-----------------------------------------------------------------------------
//
// DoMagnify - This is used for all magnification filter modes except
// anisotropic.
//
// Currently only POINT and BILINEAR are supported.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoMagnify(INT32 iStage, RRTextureCoord& TCoord, RRColor& Texel )
{
    // do lookup, applying MAG filter
    Texel = DoLookup( iStage, TCoord.fU, TCoord.fV, 0,
                      (D3DTFG_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER]) );
}


//-----------------------------------------------------------------------------
//
// DoMinify - This is used for POINT and BILINEAR modes (non-trilinear)
// for minification, and also handles POINT mip filter (nearest LOD).
//
// iLOD is n.5 fixed point
//
//-----------------------------------------------------------------------------
void
RRTexture::DoMinify(INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel )
{
    // round and drop fraction from LOD (is n.5 fixed point)
    iLOD += 0x10; iLOD &= ~(0x1f);
    // convert to n.0
    iLOD >>= 5;
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, m_cLOD );

    // do lookup, applying MIN filter
    Texel = DoLookup( iStage, TCoord.fU, TCoord.fV, iLOD,
                      (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]) );
}

//-----------------------------------------------------------------------------
//
// DoTrilerp - Computes level of detail and invokes either: single-map
// lookup & filter for magnify; or trilinear lookup and filter for minify
//
//-----------------------------------------------------------------------------
void
RRTexture::DoTrilerp(INT32 iStage, RRTextureCoord& TCoord, INT16 iLOD, RRColor& Texel)
{
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, (m_cLOD)<<5 );
    // compute index for two adjacent LODs (with clamp)
    INT16 iLODHi = iLOD>>5;  // floor
    INT16 iLODLo = MIN(iLODHi+1,m_cLOD);

    // check for filter type for within LOD map
    BOOL bNearest = (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]);

    // trilerp - look up each map then lerp between them
    // important for colorkey to not include texels with no contribution
    if (0x00 != (iLOD&0x1f))
    {
    RRColor Texel0 = DoLookup(iStage, TCoord.fU, TCoord.fV, iLODHi, bNearest);
    RRColor Texel1 = DoLookup(iStage, TCoord.fU, TCoord.fV, iLODLo, bNearest);
    LerpColor( Texel, Texel0, Texel1, iLOD&0x1f );
    }
    else
    {
        Texel = DoLookup(iStage, TCoord.fU, TCoord.fV, iLODHi, bNearest);
    }
}

//-----------------------------------------------------------------------------
//
// DoAniso - Handles anisotropic filtering of either magnified (single
// map lookup) or minified (two adjacent map lookup) samples.  The computation
// of level of detail and anisotropic coverage information (fRatio,fDelta[]) is
// done prior to this function.
//
// This performs only anisotropic filtering, and is called only for minification
// when the MINFILTER is set to ANISOTROPIC or for magnification when the
// MAGFILTER is set to ANISOTROPIC.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoAniso(INT32 iStage, RRTextureCoord& TCoord,
    INT16 iLOD, FLOAT fRatio, FLOAT fDelta[],
    RRColor& Texel)
{
    // set boolean if magnifying
    BOOL bMagnify = (iLOD <= 0);
    // clamp LOD to number of available levels
    iLOD = MIN( MAX( iLOD, 0 ), (m_cLOD)<<5 );

    // compute index for two adjacent LODs (with clamp)
    // 0 is the larger LOD, 1 is the smaller LOD
    INT16 iLODHi, iLODLo;
    if ( D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] )
    {
        // here for nearest MIP filter
        // round and drop fraction from LOD (is n.5 fixed point)
        iLOD += 0x10; iLOD &= ~(0x1f);
        // convert to n.0
        iLODHi = iLOD >> 5;
    }
    else
    {
        // here for linear MIP filter
        iLODHi = iLOD >> 5;  // floor for larger LOD
        if ( !bMagnify )
        {
            // ceiling+clamp for smaller LOD
            iLODLo = MIN( iLODHi+1, m_cLOD );
        }
    }

    // compute boolean true if only sampling one map - this is the case if
    // we are magnifying or if the MIPFILTER is set to NEAREST or if the
    // LOD fraction is zero
    BOOL bSingleMap =
        bMagnify ||
        (D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER]) ||
        (0x00 == (iLOD&0x1f));

    // working copy of texture coordinates
    FLOAT fU = TCoord.fU;
    FLOAT fV = TCoord.fV;

    // fDelta is in texels.  Compute correction factor for each LOD we care about
    FLOAT fUStepScaleHi = 1.0F/(FLOAT)MAX(m_iWidth >> iLODHi, 1);
    FLOAT fVStepScaleHi = 1.0F/(FLOAT)MAX(m_iHeight >> iLODHi, 1);
    FLOAT fUStepScaleLo = 0.F;
    FLOAT fVStepScaleLo = 0.F;

    if ( !bSingleMap )
    {
        fUStepScaleLo = 1.0F/(FLOAT)MAX(m_iWidth >> iLODLo, 1);
        fVStepScaleLo = 1.0F/(FLOAT)MAX(m_iHeight >> iLODLo, 1);
    }

    // colors for holding partial results during filtering
    RRColor TexelP, TexelP0, TexelP1;   // Plus side texels
    RRColor TexelM, TexelM0, TexelM1;   // Minus side texels

    //
    // key on ratio to either do single lookup, <2:1 processing (two lookups),
    // or full aniso walk
    //
    if (fRatio == 1.)
    {
        // here for no anisotropy - do single trilerp
        if ( bSingleMap )
        {
            // single map lookup for magnify
            Texel = DoLookup( iStage, fU, fV, iLODHi, FALSE);
        }
        else
        {
            // trilerp for minify
            TexelP0 = DoLookup( iStage, fU, fV, iLODHi, FALSE);
            TexelP1 = DoLookup( iStage, fU, fV, iLODLo, FALSE);
            LerpColor( Texel, TexelP0, TexelP1, iLOD&0x1f );
        }
    }
    else if (fRatio <= 2.)
    {
        // here for 2:1 or less - do two lookups and average them

        // compute x,y steps from sample center
        FLOAT fStep = .5*(fRatio-1.);
        FLOAT fUStep = fDelta[0]*fStep;
        FLOAT fVStep = fDelta[1]*fStep;

        // do + side lookup
        if ( bSingleMap )
        {
            // single map lookup for magnify
            TexelP = DoLookup( iStage, fU+fUStep*fUStepScaleHi, fV+fVStep*fVStepScaleHi, iLODHi, FALSE);
        }
        else
        {
            // trilerp for minify
            TexelP0 = DoLookup( iStage, fU+fUStep*fUStepScaleHi, fV+fVStep*fVStepScaleHi, iLODHi, FALSE);
            TexelP1 = DoLookup( iStage, fU+fUStep*fUStepScaleLo, fV+fVStep*fVStepScaleLo, iLODLo, FALSE);
            LerpColor( TexelP, TexelP0, TexelP1, iLOD&0x1f );
        }

        // do - side lookup
        if ( bSingleMap )
        {
            // single map lookup for magnify
            TexelM = DoLookup( iStage, fU-fUStep*fUStepScaleHi, fV-fVStep*fVStepScaleHi, iLODHi, FALSE);
        }
        else
        {
            // trilerp for minify
            TexelM0 = DoLookup( iStage, fU-fUStep*fUStepScaleHi, fV-fVStep*fVStepScaleHi, iLODHi, FALSE);
            TexelM1 = DoLookup( iStage, fU-fUStep*fUStepScaleLo, fV-fVStep*fVStepScaleLo, iLODLo, FALSE);
            LerpColor( TexelM, TexelM0, TexelM1, iLOD&0x1f );
        }

        // take average for final texel
        LerpColor( Texel, TexelP, TexelM, 0x10 );
    }
    else
    {
        // here for > 2:1 - walk line of anisotropy; walks out from the center
        // sample point taking two sets of samples (outriggers) per loop, one
        // sample at a positive offset from the center (along the aniso line)
        // and the other at a negative offset from the center

        // this section does stepping for both LODs even though LOD[1] axis
        // is not used for magnify case (only the lookup and lerp(s) are skipped)

        // n.5 fixed point versions of step values
        FLOAT fUStep = fDelta[0];
        FLOAT fVStep = fDelta[1];

        // initialize + and - step parameters - first step is half distance
        FLOAT fUHiP = fU + fUStep*fUStepScaleHi*0.5F;
        FLOAT fVHiP = fV + fVStep*fVStepScaleHi*0.5F;
        FLOAT fULoP = fU + fUStep*fUStepScaleLo*0.5F;
        FLOAT fVLoP = fV + fVStep*fVStepScaleLo*0.5F;
        FLOAT fUHiM = fU - fUStep*fUStepScaleHi*0.5F;
        FLOAT fVHiM = fV - fVStep*fVStepScaleHi*0.5F;
        FLOAT fULoM = fU - fUStep*fUStepScaleLo*0.5F;
        FLOAT fVLoM = fV - fVStep*fVStepScaleLo*0.5F;

        // step and accumulate color channels
        FLOAT fTexelAcc[4] = { 0.f, 0.f, 0.f, 0.f };    // fp accumulation of texel color
        FLOAT fRatioRem = fRatio;
        FLOAT fInvRatio = 1./fRatio;
        BOOL  bDone = FALSE;
        while (1)
        {
            // do + side lookup
            if ( bSingleMap )
            {
                // single map lookup for magnify
                TexelP = DoLookup( iStage, fUHiP, fVHiP, iLODHi, FALSE );
            }
            else
            {
                // trilerp for minify
                TexelP0 = DoLookup( iStage, fUHiP, fVHiP, iLODHi, FALSE );
                TexelP1 = DoLookup( iStage, fULoP, fVLoP, iLODLo, FALSE );
                LerpColor( TexelP, TexelP0, TexelP1, iLOD&0x1f );
            }

            // do - side lookup
            if ( bSingleMap )
            {
                // single map lookup for magnify
                TexelM = DoLookup( iStage, fUHiM, fVHiM, iLODHi, FALSE );
            }
            else
            {
                // trilerp for minify
                TexelM0 = DoLookup( iStage, fUHiM, fVHiM, iLODHi, FALSE );
                TexelM1 = DoLookup( iStage, fULoM, fVLoM, iLODLo, FALSE );
                LerpColor( TexelM, TexelM0, TexelM1, iLOD&0x1f );
            }

            // compute scaling for these samples
            FLOAT fAccScale = fInvRatio;
            if ( fRatioRem < 2.f )
            {
                // scale for last outriggers is half of remainder (each)
                fAccScale = fRatioRem*.5f*fInvRatio;
                bDone = TRUE;
            }

            // do accumulations
            fTexelAcc[0] += fAccScale * FLOAT(TexelP.A);
            fTexelAcc[1] += fAccScale * FLOAT(TexelP.R);
            fTexelAcc[2] += fAccScale * FLOAT(TexelP.G);
            fTexelAcc[3] += fAccScale * FLOAT(TexelP.B);

            fTexelAcc[0] += fAccScale * FLOAT(TexelM.A);
            fTexelAcc[1] += fAccScale * FLOAT(TexelM.R);
            fTexelAcc[2] += fAccScale * FLOAT(TexelM.G);
            fTexelAcc[3] += fAccScale * FLOAT(TexelM.B);

            // bail from here if last outrigger
            if (bDone) { break; }

            // advance to next outriggers
            fUHiP += fUStep*fUStepScaleHi;
            fVHiP += fVStep*fVStepScaleHi;
            fULoP += fUStep*fUStepScaleLo;
            fVLoP += fVStep*fVStepScaleLo;
            fUHiM -= fUStep*fUStepScaleHi;
            fVHiM -= fVStep*fVStepScaleHi;
            fULoM -= fUStep*fUStepScaleLo;
            fVLoM -= fVStep*fVStepScaleLo;
            fRatioRem -= 2.f;
        }

        // clamp accumulator and copy into RRColor for return
        Texel.A = MIN( 1.f, fTexelAcc[0] );
        Texel.R = MIN( 1.f, fTexelAcc[1] );
        Texel.G = MIN( 1.f, fTexelAcc[2] );
        Texel.B = MIN( 1.f, fTexelAcc[3] );
    }
}

//-----------------------------------------------------------------------------
//
// DoBumpMapping - Called once per buxel to compute the bump map delta's
// and the bump map modulate factor to be used in the next texturing stage.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoBumpMapping(
    INT32 iStage,
    RRTextureCoord TCoord,
    FLOAT& fBumpMapUDelta, FLOAT& fBumpMapVDelta, RRColor& BumpMapModulate)
{
    // do full lookup using enabled filtering
    RRColor Buxel;
    DoLookupAndFilter(iStage, TCoord, Buxel);

    FLOAT fDU = Buxel.R;    // follows convention from read color routine
    FLOAT fDV = Buxel.G;
    FLOAT fL  = Buxel.B;

    // grab transform from renderstate
    FLOAT fM00    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT00];
    FLOAT fM01    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT01];
    FLOAT fM10    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT10];
    FLOAT fM11    = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVMAT11];

    // apply transforms to deltas from map to form delta return values
    fBumpMapUDelta = fM00 * fDU + fM10 * fDV;
    fBumpMapVDelta = fM01 * fDU + fM11 * fDV;

    // apply scale/bias/clamp to luminance and form RRColor for return
    if (m_pStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE)
    {
        FLOAT fLScale = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVLSCALE];
        FLOAT fLOff   = m_pStageState[iStage].m_fVal[D3DTSS_BUMPENVLOFFSET];
        fL = fL * fLScale + fLOff;
        fL = min(max(fL, 0.0f), 1.0F);
        BumpMapModulate.R = fL;
        BumpMapModulate.G = fL;
        BumpMapModulate.B = fL;
    }
    else
    {
        // if not BUMPENVMAPLUMINANCE, always return full intensity white
        BumpMapModulate.R = 1.0F;
        BumpMapModulate.G = 1.0F;
        BumpMapModulate.B = 1.0F;
    }
    BumpMapModulate.A = 1.0F;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Texture Mapping Utility Functions                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// various approximations and tricks to speed up the texture map coverage
// computations
//
// these have not been really thoroughly tested, so use at your own risk...
//

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
#define FLOAT_OOEXPSCALE        ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

static inline FLOAT
RR_LOG2(FLOAT f)
{
    return (FLOAT)(AS_INT32(f) - INT32_FLOAT_ONE) * FLOAT_OOEXPSCALE;
}

static inline FLOAT
RR_ALOG2(FLOAT f)
{
    INT32 i = (INT32)(f * FLOAT_EXPSCALE) + INT32_FLOAT_ONE;
    return AS_FLOAT((long int)i);
}

static inline FLOAT
RR_ABSF(FLOAT f)
{
    UINT32 i = AS_UINT32(f) & 0x7fffffff;
    return AS_FLOAT((unsigned long int)i);
}

static inline FLOAT
RR_SQRT(FLOAT f)
{
    INT32 i = (AS_INT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return AS_FLOAT((long int)i);
}

//
// Steve Gabriel's version of an octagonal approximation euclidian distance -
// return is approximating sqrt(fX*fX + fY*fY)
//
static inline FLOAT
RR_LENGTH(FLOAT fX, FLOAT fY)
{
    fX = RR_ABSF(fX);
    fY = RR_ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for standard trilinear mipmapping, in which
// the four texture index gradients are consolidated into a single number
// to select level of detail.
//
// The basic approach is to compute the lengths of the pixel coverage for
// the X and Y extent of the approximate pixel coverage area.  These two
// lengths are then combined in one of several possible methods for the
// single LOD result.
//
// There are several other ways of doing this which are less computationally
// expensive but also produce less desirable results...
//
//-----------------------------------------------------------------------------
void
ComputeSimpleLevelOfDetail( const RRTextureCoord& TCoord, FLOAT& fLOD )
{
    // compute length of coverage in U and V axis
    FLOAT fLenX = RR_LENGTH( TCoord.fDUDX, TCoord.fDVDX );
    FLOAT fLenY = RR_LENGTH( TCoord.fDUDY, TCoord.fDVDY );
    FLOAT fCoverage;

    switch ( 3 /* LOD computation type */ )
    {

    // this is probably the best of the lot
    case 1 /* AREA    */ : fCoverage = RR_SQRT(fLenX*fLenY); break;

    // we have not actually tried this one yet, but think it might
    // be pretty good
    case 2 /* AVERAGE */ : fCoverage = (fLenX+fLenY)/2; break;

    // these are fairly inexpensive, but MAX is a bit too fuzzy
    // and MIN is a bit too sharp
    case 3 /* MAX     */ : fCoverage = MAX( fLenX, fLenY ); break;
    case 4 /* MIN     */ : fCoverage = MIN( fLenX, fLenY ); break;

    // these are really inexpensive, but look terrible - you might as
    // well just point sample...
    case 5 /* MINGRAD */ : fCoverage = MIN( MIN( MIN( TCoord.fDUDX,
                                                      TCoord.fDVDX ),
                                                 TCoord.fDUDY ),
                                            TCoord.fDVDY ); break;
    case 6 /* MAXGRAD */ : fCoverage = MAX( MAX( MAX( TCoord.fDUDX,
                                                      TCoord.fDVDX ),
                                                 TCoord.fDUDY ),
                                            TCoord.fDVDY ); break;
    }

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}

//-----------------------------------------------------------------------------
//
// Computes level of detail and other factors in preparation for anisotropic
// filtering.
//
//-----------------------------------------------------------------------------
void
ComputeAnisotropicLevelOfDetail(
    const RRTextureCoord& TCoord, FLOAT fMaxAniso, // inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] )   // outputs
{
    // compute axis lengths and determinant
    FLOAT fLenX2 = (TCoord.fDUDX*TCoord.fDUDX)+(TCoord.fDVDX*TCoord.fDVDX);
    FLOAT fLenY2 = (TCoord.fDUDY*TCoord.fDUDY)+(TCoord.fDVDY*TCoord.fDVDY);
    FLOAT fDet = RR_ABSF((TCoord.fDUDX*TCoord.fDVDY)-(TCoord.fDUDY*TCoord.fDVDX));

    // select major axis
    BOOL bXMajor = (fLenX2 > fLenY2);

    // TODO: can and probably should do this part in log2 domain

    // select and normalize steps; compute aniso ratio
    FLOAT fMaj2 = (bXMajor) ? (fLenX2) : (fLenY2);
    FLOAT fMaj = RR_SQRT(fMaj2);
    FLOAT fMajNorm = 1./fMaj;
    fDelta[0] = ( bXMajor ? TCoord.fDUDX : TCoord.fDUDY ) * fMajNorm;
    fDelta[1] = ( bXMajor ? TCoord.fDVDX : TCoord.fDVDY ) * fMajNorm;
    fRatio = (fDet != 0.F) ? (fMaj2/fDet) : (FLT_MAX);

    // clamp ratio and compute LOD
    FLOAT fMin;
    if ( fRatio > fMaxAniso )
    {
        // ratio is clamped - LOD is based on ratio (preserves area)
        fRatio = fMaxAniso;
        fMin = fMaj/fRatio;
    }
    else
    {
        // ratio not clamped - LOD is based on area
        fMin = fDet/fMaj;
    }

    // clamp to top LOD
    if (fMin < 1.0)
    {
        fRatio = MAX( 1.0, fRatio*fMin );
        fMin = 1.0;
    }

    // take log2 of minor for LOD
    fLOD = RR_LOG2(fMin);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Environment mapping routines                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Processes the environment mapping normal and converts to a standard
// U, V coord range for subsequent routines.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvProcessNormal(INT32 iStage,
                              RREnvTextureCoord ECoord,     // local copy
                              RRColor& TextureColor)
{
#define ENV_RIGHT   0
#define ENV_LEFT    1
#define ENV_TOP     2
#define ENV_BOTTOM  3
#define ENV_FRONT   4
#define ENV_BACK    5

#define POS_NX 1
#define POS_NY 2
#define POS_NZ 3
#define NEG_NORM 4
#define NEG_NX (NEG_NORM | POS_NX)
#define NEG_NY (NEG_NORM | POS_NY)
#define NEG_NZ (NEG_NORM | POS_NZ)

    // If we add per pixel normal reflection
//    FLOAT fENX = ECoord.fENX;
//    FLOAT fENY = ECoord.fENY;
//    FLOAT fENZ = ECoord.fENZ;
//
//    FLOAT fNDotE = ECoord.fNX*fENX + ECoord.fNY*fENY + ECoord.fNZ*fENZ;
//    FLOAT fNDotN = ECoord.fNX*ECoord.fNX + ECoord.fNY*ECoord.fNY + ECoord.fNZ*ECoord.fNZ;
//    fNDotE *= 2.0F;
//    ECoord.fNX = ECoord.fNX*fNDotE - fENX*fNDotN;
//    ECoord.fNY = ECoord.fNY*fNDotE - fENY*fNDotN;
//    ECoord.fNZ = ECoord.fNZ*fNDotE - fENZ*fNDotN;

    // determine which is the dominant normal
    UINT32 uMap;
    FLOAT fAbsNX = fabs(ECoord.fNX);
    FLOAT fAbsNY = fabs(ECoord.fNY);
    FLOAT fAbsNZ = fabs(ECoord.fNZ);

    if (fAbsNX > fAbsNY) {
        if (fAbsNX > fAbsNZ)
            // fNX
            uMap = POS_NX | ((ECoord.fNX < 0.0) ? (NEG_NORM) : 0);
        else
            // fNZ
            uMap = POS_NZ | ((ECoord.fNZ < 0.0) ? (NEG_NORM) : 0);
    } else {
        if (fAbsNY > fAbsNZ)
            // fNY
            uMap = POS_NY | ((ECoord.fNY < 0.0) ? (NEG_NORM) : 0);
        else
            // fNZ
            uMap = POS_NZ | ((ECoord.fNZ < 0.0) ? (NEG_NORM) : 0);
    }

    RRTextureCoord TCoord;

    switch (uMap) {
    case POS_NX:
        TCoord.fDUDX = -ECoord.fDNZDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY = -ECoord.fDNZDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU = -ECoord.fNZ;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_RIGHT, ECoord.fNX, ECoord.fDNXDX, ECoord.fDNXDY, TCoord, TextureColor);
        break;

    case POS_NY:
        TCoord.fDUDX =  ECoord.fDNXDX;
        TCoord.fDVDX =  ECoord.fDNZDX;
        TCoord.fDUDY =  ECoord.fDNXDY;
        TCoord.fDVDY =  ECoord.fDNZDY;
        TCoord.fU =  ECoord.fNX;
        TCoord.fV =  ECoord.fNZ;
        DoEnvLookupAndFilter(iStage, ENV_TOP, ECoord.fNY, ECoord.fDNYDX, ECoord.fDNYDY, TCoord, TextureColor);
        break;

    case POS_NZ:
        TCoord.fDUDX =  ECoord.fDNXDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY =  ECoord.fDNXDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU =  ECoord.fNX;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_FRONT, ECoord.fNZ, ECoord.fDNZDX, ECoord.fDNZDY, TCoord, TextureColor);
        break;

    case NEG_NX:
        TCoord.fDUDX =  ECoord.fDNZDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY =  ECoord.fDNZDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU =  ECoord.fNZ;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_LEFT, -ECoord.fNX, -ECoord.fDNXDX, -ECoord.fDNXDY, TCoord, TextureColor);
        break;

    case NEG_NY:
        TCoord.fDUDX =  ECoord.fDNXDX;
        TCoord.fDVDX = -ECoord.fDNZDX;
        TCoord.fDUDY =  ECoord.fDNXDY;
        TCoord.fDVDY = -ECoord.fDNZDY;
        TCoord.fU =  ECoord.fNX;
        TCoord.fV = -ECoord.fNZ;
        DoEnvLookupAndFilter(iStage, ENV_BOTTOM, -ECoord.fNY, -ECoord.fDNYDX, -ECoord.fDNYDY, TCoord, TextureColor);
        break;

    case NEG_NZ:
        TCoord.fDUDX = -ECoord.fDNXDX;
        TCoord.fDVDX = -ECoord.fDNYDX;
        TCoord.fDUDY = -ECoord.fDNXDY;
        TCoord.fDVDY = -ECoord.fDNYDY;
        TCoord.fU = -ECoord.fNX;
        TCoord.fV = -ECoord.fNY;
        DoEnvLookupAndFilter(iStage, ENV_BACK, -ECoord.fNZ, -ECoord.fDNZDX, -ECoord.fDNZDY, TCoord, TextureColor);
        break;
    }
}

//-----------------------------------------------------------------------------
//
// DoEnvLookupAndFilter - Environment mapped version.
// Called once per active texture stage to compute
// coverage (level-of-detail) and invoke texel read and filtering routines.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvLookupAndFilter(INT32 iStage, INT16 iFace, FLOAT fMajor, FLOAT fDMDX, FLOAT fDMDY,
                                RRTextureCoord TCoord,      // local copy
                                RRColor& TextureColor)
{
    if (m_pDDSLcl[iFace])
    {
        // faces exist
        FLOAT fInvMajor = 1.0/fMajor;

        // compute d(U/Major)/dx, etc. using rule for differentiating quotients
        TCoord.fDUDX = (fMajor*TCoord.fDUDX - TCoord.fU*fDMDX)*fInvMajor*fInvMajor;
        TCoord.fDUDY = (fMajor*TCoord.fDUDY - TCoord.fU*fDMDY)*fInvMajor*fInvMajor;
        TCoord.fDVDX = (fMajor*TCoord.fDVDX - TCoord.fV*fDMDX)*fInvMajor*fInvMajor;
        TCoord.fDVDY = (fMajor*TCoord.fDVDY - TCoord.fV*fDMDY)*fInvMajor*fInvMajor;

        // convert to -1 to 1 range
        TCoord.fU *= fInvMajor;
        TCoord.fV *= fInvMajor;

        // convert to 0.0 to 1.0
        TCoord.fU = (TCoord.fU*.5 + .5);
        TCoord.fV = (TCoord.fV*.5 + .5);

        // check for potential mip mapping
        BOOL bDoMipMap = ( m_cLOD > 0 ) && ( m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] > D3DTFP_NONE );

        // check for requirement to do level-of-detail (coverage) computation - either
        // for mipmap or per-pixel filter selection
        BOOL bComputeLOD = bDoMipMap ||
            ( m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] != m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER] );

        if ( bDoMipMap || bComputeLOD )
        {
            // here if doing mipmapping or anisotropic filtering, or just have a mismatch
            // between the min and mag filters, so compute level of detail (and maybe aniso
            // coverage)

            // scale gradients to texture LOD 0 size
            TCoord.fDUDX *= (FLOAT)m_iTexSize[0]*.5F;
            TCoord.fDUDY *= (FLOAT)m_iTexSize[0]*.5F;
            TCoord.fDVDX *= (FLOAT)m_iTexSize[1]*.5F;
            TCoord.fDVDY *= (FLOAT)m_iTexSize[1]*.5F;

            FLOAT fLOD;
            ComputeEnvMapLevelOfDetail(TCoord, fLOD);

            // apply bias and compute integer (n.5) LOD
            INT16 iLOD = 0;
            if ( bComputeLOD )
            {
                // apply LOD offset
                fLOD += m_pStageState[iStage].m_fVal[D3DTSS_MIPMAPLODBIAS];
                // convert LOD to n.5 fixed point integer
                iLOD = AS_INT16( fLOD + FLOAT_5_SNAP );
            }

            // determine if magnifying or minifying
            BOOL bMagnify = ( iLOD <= 0 );

            // zero out LOD if not mipmapping
            if ( !bDoMipMap ) { iLOD = 0; }

            // do different filtering for magnify vs. minify
            if ( bMagnify )
            {
                DoEnvMagnify( iStage, TCoord, iFace, TextureColor );
            }
            else
            {
                if ( !bDoMipMap ||
                    ( bDoMipMap && ( D3DTFP_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MIPFILTER] ) ) )
                {
                    DoEnvMinify( iStage, TCoord, iFace, iLOD, TextureColor );
                }
                else
                {
                    DoEnvTrilerp( iStage, TCoord, iFace, iLOD, TextureColor );
                }
            }
        }
        else
        {
            // here for no mipmaps and matching (and non-aniso) min and mag filters,
            // so just apply mag filter
            DoEnvMagnify( iStage, TCoord, iFace, TextureColor );
        }
    }
    else
    {
        // face doesn't exit, return empty face color
        TextureColor = m_dwEmptyFaceColor;
    }
}

//-----------------------------------------------------------------------------
//
// TexelAvg4 - Averages 4 source texels into 1 destination texel for A, R, G,
// and B.
//
//-----------------------------------------------------------------------------
static void TexelAvg4(RRColor& Texel, RRColor Texel0, RRColor Texel1, RRColor Texel2, RRColor Texel3)
{
    Texel.A = Texel0.A + Texel1.A + Texel2.A + Texel3.A;
    Texel.R = Texel0.R + Texel1.R + Texel2.R + Texel3.R;
    Texel.G = Texel0.G + Texel1.G + Texel2.G + Texel3.G;
    Texel.B = Texel0.B + Texel1.B + Texel2.B + Texel3.B;
    Texel.A = Texel.A * 0.25f;
    Texel.R = Texel.R * 0.25f;
    Texel.G = Texel.G * 0.25f;
    Texel.B = Texel.B * 0.25f;
}

//-----------------------------------------------------------------------------
//
// DoEnvLookup - Does a full lookup given floating point U, V and handles all
// nearest vs bilinear and LOD issues.
//
//-----------------------------------------------------------------------------
RRColor RRTexture::DoEnvLookup(INT32 iStage, RRTextureCoord TCoord, INT16 iFace, INT16 iLOD, BOOL bNearest)
{
    FLOAT U = TCoord.fU;
    FLOAT V = TCoord.fV;
    RRColor Texel;
    INT32 cUPixels = 1 << MAX(m_iTexShift[0]-iLOD,0);
    INT32 cVPixels = 1 << MAX(m_iTexShift[1]-iLOD,0);
    FLOAT fScaledU = ( U * (FLOAT)cUPixels ) -.5f;
    FLOAT fScaledV = ( V * (FLOAT)cVPixels ) -.5f;

    // LSB-aligned masks of index bits within current LOD
    INT16 iUMask = m_uTexMask[0] >> iLOD;
    INT16 iVMask = m_uTexMask[1] >> iLOD;

    if(bNearest)
    {
        INT32 iU, iV;
        // truncate to -infinity to be compatible with ANDing off low order
        // bits of a fixed point fScaledCoord.  This makes the generation of
        // iCoord more hardware like, and does not make a glitch at 0 for
        // a wrapped texture.
        if (U >= 0.0f)
        {
            iU = fScaledU + .5f;
        }
        else
        {
            iU = fScaledU - .5f;
        }
        if (V >= 0.0f)
        {
            iV = fScaledV + .5f;
        }
        else
        {
            iV = fScaledV - .5f;
        }

        // clamp
        iU = MAX( 0, MIN( iU, iUMask ) );
        iV = MAX( 0, MIN( iV, iVMask ) );

        BOOL bColorKeyMatched = FALSE;

        // "LOD" just used to access correct map
        ReadColor(iU, iV, iFace + iLOD*6, Texel, bColorKeyMatched);

        // merge colorkey match info from previous invocation
        m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched;
    }
    else
    {
        if ((m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] == D3DTFG_FLATCUBIC) ||
            (m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER] == D3DTFG_GAUSSIANCUBIC))
        {
            // use wider 3x3 trapezoid filter

            //
            // For the top LOD, if we are interpolating beyond the edge of the
            // texture, correct the interpolation to minimize the artifacts seen in
            // small, diffuse environment maps which tend to emphasize the edges
            // of the cubemap.
            //
            if (iLOD == 0)
            {
                FLOAT fFracU = 0.0f;
                FLOAT fCorrectionU = 0.0f;
                FLOAT fCorrectionV = 0.0f;
                if ((fScaledU < 0.5f) || (fScaledU > ((FLOAT)iUMask-0.5f)))
                {
                    // U crosses a boundary, clamp fScaledV
                    if (fScaledU < 0.5f)
                    {
                        // make fFrac always positive
                        fFracU = 0.5f-fScaledU;
                    }
                    else
                    {
                        fFracU = fScaledU - ((FLOAT)iUMask-0.5f);
                    }
                    // 2.0/2.0 = 1.0 provides the perfect correction at the cube corner.
                    // This can be seen be looking at the derivative of the intersection
                    // of a cone and a cube at the cube corner.
                    //
                    // correction must be corrected for the filter width (hence the *0.5f)
                    fCorrectionV = -fFracU*(TCoord.fV-.5f)*0.5f;
                }
                if ((fScaledV < 0.5f) || (fScaledV > ((FLOAT)iVMask-0.5f)))
                {
                    // V crosses a boundary, clamp fScaledU
                    FLOAT fFracV;
                    if (fScaledV < 0.5f)
                    {
                        // make fFrac always positive
                        fFracV = 0.5f-fScaledV;
                    }
                    else
                    {
                        fFracV = fScaledV - ((FLOAT)iVMask-0.5f);
                    }
                    fCorrectionU = -fFracV*(TCoord.fU-.5f)*0.5f;
                    if (fFracU != 0.0f)
                    {
                        // At the corners of the cube, we need to blend away the
                        // edge correction so that it is 0 at exactly the corner
                        // center.  This linear function does fine.
                        fCorrectionU *= (1.0f - fFracU);
                        fCorrectionV *= (1.0f - fFracV);
                    }
                }
                fScaledU += fCorrectionU;
                fScaledV += fCorrectionV;
            }

            INT32 iU = AS_INT32( (DOUBLE)fScaledU + DOUBLE_5_SNAP );// or:   iU = fScaledU*32. + .5;
            INT32 iV = AS_INT32( (DOUBLE)fScaledV + DOUBLE_5_SNAP );

            // extract fraction bits
            UINT8 uUFrac = iU&0x1f;
            UINT8 uVFrac = iV&0x1f;

            // take floor
            INT16 iU0 = iU>>5;
            INT16 iV0 = iV>>5;

            // average to find the center texel
            INT32 iUC = (uUFrac >= 0x10) ? (iU0 + 1) : (iU0);
            INT32 iVC = (uVFrac >= 0x10) ? (iV0 + 1) : (iV0);

            // get 9 surrounding samples
            //           VU       VU       VU
            RRColor Texel00, Texel01, Texel02;
            RRColor Texel10, Texel11, Texel12;
            RRColor Texel20, Texel21, Texel22;
            BOOL bColorKeyMatchedT = FALSE;
            DoEnvReMap(iUC-1, iVC-1, iUMask, iVMask, iFace, iLOD, Texel00, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC-0, iVC-1, iUMask, iVMask, iFace, iLOD, Texel01, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC+1, iVC-1, iUMask, iVMask, iFace, iLOD, Texel02, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;

            DoEnvReMap(iUC-1, iVC+0, iUMask, iVMask, iFace, iLOD, Texel10, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC-0, iVC+0, iUMask, iVMask, iFace, iLOD, Texel11, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC+1, iVC+0, iUMask, iVMask, iFace, iLOD, Texel12, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;

            DoEnvReMap(iUC-1, iVC+1, iUMask, iVMask, iFace, iLOD, Texel20, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC-0, iVC+1, iUMask, iVMask, iFace, iLOD, Texel21, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;
            DoEnvReMap(iUC+1, iVC+1, iUMask, iVMask, iFace, iLOD, Texel22, bColorKeyMatchedT);
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatchedT;

            // sum the samples into 4 areas
            RRColor TexelT00, TexelT01, TexelT10, TexelT11;
            TexelAvg4(TexelT00, Texel00, Texel01, Texel10, Texel11);
            TexelAvg4(TexelT01, Texel01, Texel02, Texel11, Texel12);
            TexelAvg4(TexelT10, Texel10, Texel11, Texel20, Texel21);
            TexelAvg4(TexelT11, Texel11, Texel12, Texel21, Texel22);

            // correct the fraction to be around the center sample
            uUFrac = (uUFrac + 0x10) & 0x1f;
            uVFrac = (uVFrac + 0x10) & 0x1f;

            // use a bilerp to get the final sample
            BiLerpColor( Texel, TexelT00,TexelT01, TexelT10,TexelT11, uUFrac,uVFrac);
        }
        else
        {
            // bilinear

            //
            // For the top LOD, if we are interpolating beyond the edge of the
            // texture, correct the interpolation to minimize the artifacts seen in
            // small, diffuse environment maps which tend to emphasize the edges
            // of the cubemap.
            //
            if (iLOD == 0)
            {
                FLOAT fFracU = 0.0f;
                FLOAT fCorrectionU = 0.0f;
                FLOAT fCorrectionV = 0.0f;
                if ((fScaledU < 0.0f) || (fScaledU > (FLOAT)iUMask))
                {
                    // U crosses a boundary, clamp fScaledV
                    if (fScaledU < 0.0f)
                    {
                        // make fFrac always positive
                        fFracU = -fScaledU;
                    }
                    else
                    {
                        fFracU = fScaledU - (FLOAT)iUMask;
                    }
                    // 2.0/2.0 = 1.0 provides the perfect correction at the cube corner.
                    // This can be seen be looking at the derivative of the intersection
                    // of a cone and a cube at the cube corner.
                    fCorrectionV = -fFracU*(TCoord.fV-.5f);
                }
                if ((fScaledV < 0.0f) || (fScaledV > (FLOAT)iVMask))
                {
                    // V crosses a boundary, clamp fScaledU
                    FLOAT fFracV;
                    if (fScaledV < 0.0f)
                    {
                        // make fFrac always positive
                        fFracV = -fScaledV;
                    }
                    else
                    {
                        fFracV = fScaledV - (FLOAT)iVMask;
                    }
                    fCorrectionU = -fFracV*(TCoord.fU-.5f);
                    if (fFracU != 0.0f)
                    {
                        // At the corners of the cube, we need to blend away the
                        // edge correction so that it is 0 at exactly the corner
                        // center.  This linear function does fine.
                        fCorrectionU *= 2.0f*(.5f - fFracU);
                        fCorrectionV *= 2.0f*(.5f - fFracV);
                    }
                }
                fScaledU += fCorrectionU;
                fScaledV += fCorrectionV;
            }

            INT32 iU = AS_INT32( (DOUBLE)fScaledU + DOUBLE_5_SNAP );// or:   iU = fScaledU*32. + .5;
            INT32 iV = AS_INT32( (DOUBLE)fScaledV + DOUBLE_5_SNAP );

            // extract fraction bits
            UINT8 uUFrac = iU&0x1f;
            UINT8 uVFrac = iV&0x1f;

            // take floor for (0,0) sample coords
            INT16 iU0 = iU>>5;
            INT16 iV0 = iV>>5;
            // take ceiling for (1,1) sample coords
            INT16 iU1 = iU0+1;
            INT16 iV1 = iV0+1;

            // grab four adjacent samples
            RRColor Texel00, Texel01, Texel10, Texel11;
            BOOL bColorKeyMatched00 = FALSE;
            BOOL bColorKeyMatched01 = FALSE;
            BOOL bColorKeyMatched10 = FALSE;
            BOOL bColorKeyMatched11 = FALSE;

            DoEnvReMap(iU0, iV0, iUMask, iVMask, iFace, iLOD, Texel00, bColorKeyMatched00);
            DoEnvReMap(iU1, iV0, iUMask, iVMask, iFace, iLOD, Texel01, bColorKeyMatched01);
            DoEnvReMap(iU0, iV1, iUMask, iVMask, iFace, iLOD, Texel10, bColorKeyMatched10);
            DoEnvReMap(iU1, iV1, iUMask, iVMask, iFace, iLOD, Texel11, bColorKeyMatched11);

            // only set 'colorkey matched' if at least one matched value has
            // a non-zero contribution (note that it is not possible for 00
            // to have no contribution)
            if (uUFrac == 0x00) {
                // 01 and 11 have zero weight if U fraction is zero
                bColorKeyMatched01 = bColorKeyMatched11 = FALSE;
            }
            if (uVFrac == 0x00) {
                // 10 and 11 have zero weight if V fraction is zero
                bColorKeyMatched10 = bColorKeyMatched11 = FALSE;
            }

            // merge colorkey match info from previous invocation
            m_bColorKeyMatched = m_bColorKeyMatched || bColorKeyMatched00 || bColorKeyMatched01 ||
                bColorKeyMatched10 || bColorKeyMatched11;

            // do bilinear filter
            BiLerpColor( Texel, Texel00,Texel01, Texel10,Texel11, uUFrac,uVFrac);
        }
    }
    return Texel;
}

//-----------------------------------------------------------------------------
//
// DoEnvMagnify - This is used for all magnification filter modes except
// anisotropic.
//
// Currently only POINT and BILINEAR are supported.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvMagnify(INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, RRColor& Texel )
{
    // do lookup, applying MAG filter
    Texel = DoEnvLookup( iStage, TCoord, iFace, 0,
                      (D3DTFG_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MAGFILTER]) );
}


//-----------------------------------------------------------------------------
//
// DoEnvMinify - This is used for POINT and BILINEAR modes (non-trilinear)
// for minification, and also handles POINT mip filter (nearest LOD).
//
// iLOD is n.5 fixed point
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvMinify(INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel )
{
    // round and drop fraction from LOD (is n.5 fixed point)
    iLOD += 0x10; iLOD &= ~(0x1f);
    // convert to n.0
    iLOD >>= 5;
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, m_cLOD );

    // do lookup, applying MIN filter
    Texel = DoEnvLookup( iStage, TCoord, iFace, iLOD,
                      (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]) );
}

//-----------------------------------------------------------------------------
//
// DoEnvTrilerp - Does trilinear environment map filtering.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvTrilerp(INT32 iStage, RRTextureCoord& TCoord, INT16 iFace, INT16 iLOD, RRColor& Texel)
{
    // clamp LOD to number of available levels
    iLOD = MIN( iLOD, (m_cLOD)<<5 );
    // compute index for two adjacent LODs (with clamp)
    INT16 iLODHi = iLOD>>5;  // floor
    INT16 iLODLo = MIN(iLODHi+1,m_cLOD);

    // check for filter type for within LOD map
    BOOL bNearest = (D3DTFN_POINT == m_pStageState[iStage].m_dwVal[D3DTSS_MINFILTER]);

    // trilerp - look up each map then lerp between them
    // important for colorkey to not include texels with no contribution
    if (0x00 != (iLOD&0x1f))
    {
        // trilerp - look up each map then lerp between them
    RRColor Texel0 = DoEnvLookup(iStage, TCoord, iFace, iLODHi, bNearest);
    RRColor Texel1 = DoEnvLookup(iStage, TCoord, iFace, iLODLo, bNearest);
    LerpColor( Texel, Texel0, Texel1, iLOD&0x1f );
}
    else
    {
        Texel = DoEnvLookup(iStage, TCoord, iFace, iLODHi, bNearest);
    }
}

//
// uEnvEdgeTable
//
// This table looks up how to map a given U and V that are out of range
// on their primary face.  The first index to the table is the current
// face.  The second index is 0 if V is in range, 1 if V is negative
// and 2 if V is larger than the texture.  Likewise, the last index is 0
// if U is in range, 1 if U is negative, and 2 if U is larger than
// than the texture.
//
// For the underdefined cases where 2 coordinates are out at the same time,
// we do the U wrap but not V.

//
// defines for the actions returned by the uEnvEdgeTable
//
#define EET_FACEMASK 0x07    // new face
#define EET_FU       0x10    // flip U on the texture map
#define EET_FV       0x20    // flip V on the texture map
#define EET_SUV      0x40    // swap U and V

//
// When both U and V are out, it is arbitrary which other
// face you pick.  However, picking any one face other than the base
// face biases the result in visually disturbing ways.  Therefore,
// take them both and average them.
//
static UINT8 uEnvEdgeTable[6][3][3] =
{
    {   // U0 NU PU                             // face 0
        {0xff, 4, 5},                           // V in range
        {EET_FU|EET_SUV|2,  0xff, 0xff},        // V Neg
        {EET_FV|EET_SUV|3,  0xff, 0xff},        // V too large
    },
    {                                           // face 1
        {0xff, 5, 4},
        {EET_FV|EET_SUV|2,  0xff, 0xff},
        {EET_FU|EET_SUV|3,  0xff, 0xff},
    },
    {                                           // face 2
        {0xff, EET_FU|EET_SUV|1, EET_FV|EET_SUV|0},
        {EET_FU|EET_FV|5,   0xff, 0xff},
        {4,                 0xff, 0xff},
    },
    {                                           // face 3
        {0xff, EET_FV|EET_SUV|1, EET_FU|EET_SUV|0},
        {4,                 0xff, 0xff},
        {EET_FU|EET_FV|5,   0xff, 0xff},
    },
    {                                           // face 4
        {0xff, 1, 0},
        {2,                 0xff, 0xff},
        {3,                 0xff, 0xff},
    },
    {                                           // face 5
        {0xff, 0, 1},
        {EET_FU|EET_FV|2,   0xff, 0xff},
        {EET_FU|EET_FV|3,   0xff, 0xff},
    },
};

//-----------------------------------------------------------------------------
//
// DoTableInterp - Environment mapping utility.
// Interprets the edge table and does a lookup
//
//-----------------------------------------------------------------------------
void
RRTexture::DoTableInterp(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD,
                         UINT8 uUSign, UINT8 uVSign, RRColor &Texel, BOOL &bColorKeyMatched)
{
    UINT8 uTable = uEnvEdgeTable[iFace][uVSign][uUSign];
    _ASSERT( uTable != 0xff, "Illegal environment map lookup" );
    if (uTable & EET_FU)
    {
        iU = iUMask - iU;
    }
    if (uTable & EET_FV)
    {
        iV = iVMask - iV;
    }
    if (uTable & EET_SUV)
    {
        INT16 iT = iU;
        iU = iV;
        iV = iT;
    }
    iFace = uTable & EET_FACEMASK;
    ReadColor(iU, iV, iFace + iLOD*6, Texel, bColorKeyMatched);
}

//-----------------------------------------------------------------------------
//
// DoEnvReMap - Environment mapping utility.
// Determines if either of the texture coordinates are out of range, and
// remaps the coordinate to the correct coordinate on the proper face of the
// environment cube.
//
//-----------------------------------------------------------------------------
void
RRTexture::DoEnvReMap(INT16 iU, INT16 iV, INT16 iUMask, INT16 iVMask, INT16 iFace, INT16 iLOD, RRColor &Texel,
                      BOOL &bColorKeyMatched)
{
    UINT8 iUNeg = (UINT8)(iU < 0);
    UINT8 iUPos = (UINT8)(iU > iUMask);
    UINT8 iVNeg = (UINT8)(iV < 0);
    UINT8 iVPos = (UINT8)(iV > iVMask);

    if (!(iUNeg || iUPos || iVNeg || iVPos))
    {
        ReadColor(iU, iV, iFace + iLOD*6, Texel, bColorKeyMatched);
    }
    else
    {
        // put all U,V's in range with wrap function
        INT16 iUMasked = iU & iUMask;
        INT16 iVMasked = iV & iVMask;
        INT16 iUClampd = min(max(iU, 0), iUMask);
        INT16 iVClampd = min(max(iV, 0), iVMask);
        UINT8 uUSign = (iUNeg) | (iUPos<<1);
        UINT8 uVSign = (iVNeg) | (iVPos<<1);
        if ((uVSign != 0) && (uUSign != 0))
        {
            // off the edge of the map in two directions.  Go off each direction individually,
            // and average the result.
            RRColor Texel0, Texel1;
            DoTableInterp(iUClampd, iVMasked, iUMask, iVMask, iFace, iLOD, 0, uVSign, Texel0, bColorKeyMatched);
            DoTableInterp(iUMasked, iVClampd, iUMask, iVMask, iFace, iLOD, uUSign, 0, Texel1, bColorKeyMatched);
            LerpColor( Texel, Texel0, Texel1, 0x10 );
        }
        else
        {
            DoTableInterp(iUMasked, iVMasked, iUMask, iVMask, iFace, iLOD, uUSign, uVSign, Texel, bColorKeyMatched);
        }
    }
}

//-----------------------------------------------------------------------------
//
// RRTexture::Initialize()
//
//-----------------------------------------------------------------------------
HRESULT
RRTexture::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    HRESULT hr = D3D_OK;
    RRSurfaceType SurfType;
    DDSCAPS2 ddscaps;
    memset(&ddscaps, 0, sizeof(ddscaps));

    m_iWidth = DDSurf_Width(pLcl);
    m_iHeight = DDSurf_Height(pLcl);
    m_cLOD = 0;
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &SurfType));

    if ((SurfType == RR_STYPE_DXT1) ||
        (SurfType == RR_STYPE_DXT2) ||
        (SurfType == RR_STYPE_DXT3) ||
        (SurfType == RR_STYPE_DXT4) ||
        (SurfType == RR_STYPE_DXT5))
    {
        // Note, here is the assumption that:
        // 1) width and height are reported correctly by the driver that
        //    created the surface
        // 2) The allocation of the memory is contiguous (as done by hel)
        m_iPitch[0] = ((m_iWidth+3)>>2) *
            g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
    }
    else
    {
        m_iPitch[0] = DDSurf_Pitch(pLcl);
    }
    m_SurfType = SurfType;

    if (SurfType == RR_STYPE_PALETTE8 ||
        SurfType == RR_STYPE_PALETTE4)
    {
        if (pLcl->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
            m_pPalette = (DWORD*)pPal->lpColorTable;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
            }
            else
            {
                m_uFlags &= ~RR_TEXTURE_ALPHAINPALETTE;
            }
        }
    }

    if (!ValidTextureSize((INT16)m_iWidth, (INT16)IntLog2(m_iWidth),
                          (INT16)m_iHeight, (INT16)IntLog2(m_iHeight)))
    {
        return DDERR_INVALIDPARAMS;
    }

    if (pLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
    {
        m_uFlags |= RR_TEXTURE_ENVMAP;

        LPDDRAWI_DDRAWSURFACE_LCL pDDSNextLcl;
        ddscaps.dwCaps = DDSCAPS_TEXTURE;

        if (!(pLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX))
        {
            ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP|DDSCAPS2_CUBEMAP_POSITIVEX;

            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pDDSNextLcl);

            if ((hr != D3D_OK) && (hr != DDERR_NOTFOUND))
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                m_pDDSLcl[0] = NULL;
            }
            else
            {
                // use POSITIVEX surface to query others, if it exists
                pLcl = pDDSNextLcl;
                m_pDDSLcl[0] = pLcl;
            }
        }
        else
        {
            m_pDDSLcl[0] = pLcl;
        }

        // get rest of top level surfaces, in order
        for (INT i = 1; i < 6; i++)
        {
            switch(i)
            {
            case 1: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEX; break;
            case 2: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEY; break;
            case 3: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEY; break;
            case 4: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEZ; break;
            case 5: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEZ; break;
            }
            ddscaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pDDSNextLcl);
            if ((hr != D3D_OK) && (hr != DDERR_NOTFOUND))
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                m_pDDSLcl[i] = NULL;
            }
            else
            {
                m_pDDSLcl[i] = pDDSNextLcl;
            }
        }

        for (i = 0; i < 6; i++)
        {
            pLcl = m_pDDSLcl[i];
            m_cLOD = 0;

            if (pLcl)
            {
                // Check for mipmap if any.
                LPDDRAWI_DDRAWSURFACE_LCL  pTmpSLcl;

                // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
                // mipmap. They are init'ed with the first texture size.
                INT16 iPreSizeU = (INT16)m_iWidth, iPreSizeV = (INT16)m_iHeight;
                for (;;)
                {
                    ddscaps.dwCaps = DDSCAPS_TEXTURE;
                    ddscaps.dwCaps2 = DDSCAPS2_MIPMAPSUBLEVEL;
                    hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
                    if (hr != D3D_OK && hr != DDERR_NOTFOUND)
                    {
                        return hr;
                    }
                    if (hr == DDERR_NOTFOUND)
                    {
                        break;
                    }
                    m_cLOD ++;
                    pLcl = pTmpSLcl;
                    m_pDDSLcl[m_cLOD*6 + i] = pLcl;
                    if ((SurfType == RR_STYPE_DXT1) ||
                        (SurfType == RR_STYPE_DXT2) ||
                        (SurfType == RR_STYPE_DXT3) ||
                        (SurfType == RR_STYPE_DXT4) ||
                        (SurfType == RR_STYPE_DXT5))
                    {
                        // Note, here is the assumption that:
                        // 1) width and height are reported correctly by the driver that
                        //    created the surface
                        // 2) The allocation of the memory is contiguous (as done by ddhel)
                        m_iPitch[m_cLOD] = (((m_iWidth>>m_cLOD)+3)>>2) *
                            g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
                    }
                    else
                    {
                        m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
                    }
                    m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
                    // Check for invalid mipmap texture size
                    if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                        !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
                    {
                        return DDERR_INVALIDPARAMS;
                    }
                    iPreSizeU = (INT16)DDSurf_Width(pLcl);
                    iPreSizeV = (INT16)DDSurf_Height(pLcl);
                }
            }
        }
    }
    else
    {
        if (pLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
        {
            m_uFlags |= RR_TEXTURE_SHADOWMAP;
        }

        m_pDDSLcl[0] = pLcl;
        // Check for mipmap if any.
        LPDDRAWI_DDRAWSURFACE_LCL pTmpSLcl;
        // iPreSizeU and iPreSizeV store the size(u and v) of the previous
        // level mipmap. They are init'ed with the first texture size.
        INT16 iPreSizeU = (INT16)m_iWidth, iPreSizeV = (INT16)m_iHeight;
        for (;;)
        {
            ddscaps.dwCaps = DDSCAPS_TEXTURE;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
            if (hr != D3D_OK && hr != DDERR_NOTFOUND)
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                break;
            }
            m_cLOD ++;
            pLcl = pTmpSLcl;
            m_pDDSLcl[m_cLOD] = pLcl;
            if ((SurfType == RR_STYPE_DXT1) ||
                (SurfType == RR_STYPE_DXT2) ||
                (SurfType == RR_STYPE_DXT3) ||
                (SurfType == RR_STYPE_DXT4) ||
                (SurfType == RR_STYPE_DXT5))
            {
                // Note, here is the assumption that:
                // 1) width and height are reported correctly by the driver that
                //    created the surface
                // 2) The allocation of the memory is contiguous (as done by ddhel)
                m_iPitch[m_cLOD] = (((m_iWidth>>m_cLOD)+3)>>2) *
                    g_DXTBlkSize[(int)SurfType - (int)RR_STYPE_DXT1];
            }
            else
            {
                m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
            }
            m_iPitch[m_cLOD] = DDSurf_Pitch(pLcl);
                // Check for invalid mipmap texture size
                if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                    !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
                {
                    return DDERR_INVALIDPARAMS;
            }
            iPreSizeU = (INT16)DDSurf_Width(pLcl);
            iPreSizeV = (INT16)DDSurf_Height(pLcl);
        }
    }

    m_cLODDDS = m_cLOD;

    if ( !(Validate()) )
    {
        return DDERR_GENERIC;
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for environment mapping, looks better if
// we err on the side of fuzziness.
//
//-----------------------------------------------------------------------------
void
ComputeEnvMapLevelOfDetail( const RRTextureCoord& TCoord, FLOAT& fLOD )
{
    // compute length of coverage in U and V axis
    FLOAT fLenX = RR_LENGTH( TCoord.fDUDX, TCoord.fDVDX );
    FLOAT fLenY = RR_LENGTH( TCoord.fDUDY, TCoord.fDVDY );

    // take max
    FLOAT fCoverage = MAX(fLenX, fLenY);

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}

//-----------------------------------------------------------------------------
//
// RRTexture::DoTextureTransform - Performs the homogeneous texture transform.
//
//-----------------------------------------------------------------------------
void RRTexture::DoTextureTransform( INT32 iStage, BOOL bAlreadyXfmd,
                                    FLOAT* pfC, FLOAT* pfO, FLOAT* pfQ )
{
    LPD3DMATRIX pM = (LPD3DMATRIX)&m_pStageState[iStage].m_dwVal[D3DTSSI_MATRIX];
    DWORD dwFlags = m_pStageState[iStage].m_dwVal[D3DTSS_TEXTURETRANSFORMFLAGS];
    DWORD dwCount = dwFlags & (D3DTTFF_PROJECTED-1);
    pfO[0] = pfC[0];
    pfO[1] = pfC[1];
    pfO[2] = pfC[2];
    pfO[3] = pfC[3];
    *pfQ = 1.0f;
    if (dwCount != D3DTTFF_DISABLE)
    {
        if( bAlreadyXfmd == FALSE )
        {
            FLOAT x = pfC[0];
            FLOAT y = pfC[1];
            FLOAT z = pfC[2];
            FLOAT w = pfC[3];

            pfO[0] = x*pM->_11 + y*pM->_21 + z*pM->_31 + w*pM->_41;
            pfO[1] = x*pM->_12 + y*pM->_22 + z*pM->_32 + w*pM->_42;
            pfO[2] = x*pM->_13 + y*pM->_23 + z*pM->_33 + w*pM->_43;
            pfO[3] = x*pM->_14 + y*pM->_24 + z*pM->_34 + w*pM->_44;
        }

        if (dwFlags & D3DTTFF_PROJECTED)
        {
            DWORD dwQI = dwCount - 1;

            _ASSERT((dwQI >= 1)&&(dwQI <= 3), "Illegal D3DTTFF_COUNT with D3DTTFF_PROJECTED");

            *pfQ = pfO[dwQI];
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\rast\texstage.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texstage.cpp
//
// Direct3D Reference Rasterizer - Texture Processing Stage Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// DoTexture - Does texture lookup, filter, and blend for a pixel.
//
// The basic sequence for texture mapping is to step through active texture
// stages and do the lookup and filtering of that stage's texel contribution
// followed by the blending.
//
// Bump map textures result in computing a set of coordinate deltas which are
// applied to the texture coordinates of the subsequent stage, and a set of
// modulation factors which are applied to the texel color of the subsequent
// stage prior to that stages' blend.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoTexture(
    const RRPixel& Pixel, RRColor& ResultColor)
{
    DPFM(5, TEX, ("DoTexture\n"));

    // TRUE if previous stage was a bump map, meaning that the current
    // stage has to apply U,V deltas and color modulation
    BOOL bPrevStageBump = FALSE;

    // Bump information must be remembered between iterations of the for loop
    // below.
    FLOAT   fBumpMapUVDelta[2] = { 0., 0. };
    RRColor BumpMapModulate;

    //
    // step through the set of active texture stages (must be contiguous
    // starting at stage 0)
    //

    // color after each blend stage, defaults to diffuse color for
    // first stage
    RRColor LastStageColor( Pixel.Color );
    for ( INT32 iStage=0; iStage<m_cActiveTextureStages; iStage++ )
    {
        RRTextureCoord  TCoord;
        RREnvTextureCoord ECoord;
        FLOAT fShadCoord[4];

        // clear this at the beginning of processing for each pixel
        if (m_pTexture[iStage])
        {
            m_pTexture[iStage]->m_bColorKeyMatched = FALSE;
        }

        // check if stage is disabled - if so then texture mapping is done
        // and result of previous stage is returned
        if ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            ResultColor = LastStageColor; // pass result of previous stage
            break;
        }


        BOOL bTextureIsBumpMap = FALSE;
        BOOL bTextureIsEnvMap  = FALSE;
        BOOL bTextureIsShadMap = FALSE;
        RRColor TextureColor = (UINT32)0x0;     // default value if no texture is read

        // compute texture coordinates (if necessary) - check renderstate to
        // see if texture map is attached to stage, then determine which
        // coordinate set from that texture's state
        //
        // note that it is possible for there to not be a texture map
        // associated with a stage (but blending still occurs)
        if ( m_pTexture[iStage] )
        {
            // need to know if this is a bump map texture
            bTextureIsBumpMap =
                ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP ) ||
                ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE );

            // need to know if this is an environment map texture
            bTextureIsEnvMap = m_pTexture[iStage]->m_uFlags & RR_TEXTURE_ENVMAP;

            // see if this is a shadow map texture
            bTextureIsShadMap = m_pTexture[iStage]->m_uFlags & RR_TEXTURE_SHADOWMAP;

            if (bTextureIsEnvMap)
            {
                // normal is always required
                ECoord.fNX = ComputePixelAttribTex( iStage, TEXFUNC_0 );
                ECoord.fNY = ComputePixelAttribTex( iStage, TEXFUNC_1 );
                ECoord.fNZ = ComputePixelAttribTex( iStage, TEXFUNC_2 );
//              if we add the eye normal iteration
//                if (m_dwFVFControl & D3DFVF_ENV_EYE_NORMAL)
//                {
//                    ECoord.fENX = ComputePixelAttribTex( iCoordSet, TEXFUNC_ENX );
//                    ECoord.fENY = ComputePixelAttribTex( iCoordSet, TEXFUNC_ENY );
//                    ECoord.fENZ = ComputePixelAttribTex( iCoordSet, TEXFUNC_ENZ );
//                }
                FLOAT fW = m_pSCS->AttribFuncStatic.GetPixelQW(iStage);
                ECoord.fDNXDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetXGradient() -
                           ( ECoord.fNX * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                ECoord.fDNXDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetYGradient() -
                           ( ECoord.fNX * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
                ECoord.fDNYDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetXGradient() -
                           ( ECoord.fNY * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                ECoord.fDNYDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetYGradient() -
                           ( ECoord.fNY * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
                ECoord.fDNZDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_2].GetXGradient() -
                           ( ECoord.fNZ * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                ECoord.fDNZDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_2].GetYGradient() -
                           ( ECoord.fNZ * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
            }
            else if (bTextureIsShadMap)
            {
                fShadCoord[0] = ComputePixelAttribTex( iStage, TEXFUNC_0 );
                fShadCoord[1] = ComputePixelAttribTex( iStage, TEXFUNC_1 );
                fShadCoord[2] = ComputePixelAttribTex( iStage, TEXFUNC_2 );
                fShadCoord[3] = m_pSCS->AttribFuncStatic.GetPixelQW(iStage);
            }
            else
            {
                // compute coordinate and gradient data for texture index pair
                TCoord.fU = ComputePixelAttribTex( iStage, TEXFUNC_0 );
                TCoord.fV = ComputePixelAttribTex( iStage, TEXFUNC_1 );
                FLOAT fW = m_pSCS->AttribFuncStatic.GetPixelQW(iStage);
                TCoord.fDUDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetXGradient() -
                           ( TCoord.fU * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                TCoord.fDUDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_0].GetYGradient() -
                           ( TCoord.fU * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
                TCoord.fDVDX =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetXGradient() -
                           ( TCoord.fV * m_pSCS->AttribFuncStatic.GetRhqwXGradient(iStage) ) );
                TCoord.fDVDY =
                    fW * ( m_pSCS->TextureFuncs[iStage][TEXFUNC_1].GetYGradient() -
                           ( TCoord.fV * m_pSCS->AttribFuncStatic.GetRhqwYGradient(iStage) ) );
            }

            // apply perturbation to texture coords (computed in previous stage)
            if ( bPrevStageBump )
            {
                TCoord.fU += fBumpMapUVDelta[0];
                TCoord.fV += fBumpMapUVDelta[1];
            }

            // do lookup and filtering of texture map to produce either texture
            // color or bump map delta&modulation
            if ( bTextureIsBumpMap)
            {
                // texture is bump map, so compute U,V deltas and color
                // modulation for next stage
                m_pTexture[iStage]->DoBumpMapping( iStage, TCoord,
                    fBumpMapUVDelta[0], fBumpMapUVDelta[1], BumpMapModulate);
                bPrevStageBump = TRUE;
            }
            else if (bTextureIsEnvMap)
            {
                // texture is environment map, pass normal to lookup
                m_pTexture[iStage]->DoEnvProcessNormal( iStage, ECoord, TextureColor );
            }
            else if (bTextureIsShadMap)
            {
                m_pTexture[iStage]->DoShadow( iStage, fShadCoord, TextureColor );
            }
            else
            {
                // normal texture
                m_pTexture[iStage]->DoLookupAndFilter( iStage, TCoord, TextureColor );
            }
        }

        // do per-stage blend (only if not bump map)
        if ( !bTextureIsBumpMap )
        {
            if ( bPrevStageBump )
            {
                // apply color modulation to texture color prior to this
                // stage's blending
                TextureColor.R *= BumpMapModulate.R;
                TextureColor.G *= BumpMapModulate.G;
                TextureColor.B *= BumpMapModulate.B;
            }

            DoTextureBlendStage( iStage, Pixel.Color, Pixel.Specular,
                LastStageColor, TextureColor, ResultColor );

            // set color for next stage
            LastStageColor = ResultColor;

            // this is not a bump map stage, so clear this for next time
            bPrevStageBump = FALSE;
        }
    }
}

//-----------------------------------------------------------------------------
//
// ComputeTextureBlendArg - Computes texture argument for blending, using the
// specified argument control (D3DTA_* fields).  This is called 4 times per
// texture processing stage: 2 arguments for color and 2 arguments for alpha.
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::ComputeTextureBlendArg(
    DWORD dwArgCtl, BOOL bAlphaOnly,
    const RRColor& DiffuseColor,
    const RRColor& SpecularColor,
    const RRColor& CurrentColor,
    const RRColor& TextureColor,
    RRColor& BlendArg)
{
    // argument MUX
    switch ( dwArgCtl & D3DTA_SELECTMASK )
    {
    case D3DTA_DIFFUSE:  BlendArg = DiffuseColor; break;
    case D3DTA_CURRENT:  BlendArg = CurrentColor; break;
    case D3DTA_SPECULAR: BlendArg = SpecularColor; break;
    case D3DTA_TEXTURE:  BlendArg = TextureColor; break;
    case D3DTA_TFACTOR:
        BlendArg = m_dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]; break;
    }

    // take compliment of all channels
    if ( dwArgCtl & D3DTA_COMPLEMENT )
    {
        BlendArg.A = ~BlendArg.A;
        if ( !bAlphaOnly )
        {
            BlendArg.R = ~BlendArg.R;
            BlendArg.G = ~BlendArg.G;
            BlendArg.B = ~BlendArg.B;
        }
    }

    // replicate alpha to color (after compliment)
    if ( !bAlphaOnly && ( dwArgCtl & D3DTA_ALPHAREPLICATE ) )
    {
        BlendArg.R =
        BlendArg.G =
        BlendArg.B = BlendArg.A;
    }
}

//-----------------------------------------------------------------------------
//
// DoTextureBlendStage - Does texture blend for one texture processing stage,
// combining results from the texture processing with the interpolated color(s)
// and previous stage's color.
//
// Note: All color channel multiplies should be done in such a way that a unit
// value on one side passes the value on the other side.  Thus for 8 bit color
// channels, '0xff * value' should return value, and 0xff * 0xff = 0xff,
// not 0xfe(01).
//
// RRColorChannel performs these operations with floating point. 8 bit color
// values of 0x00 to 0xff are mapped into the 0. to 1. range.  Performing these
// multiplies in fixed point requires an adjustment to adhere to this rule.
//
//
//-----------------------------------------------------------------------------
void
ReferenceRasterizer::DoTextureBlendStage(
    int iStage,
    const RRColor& DiffuseColor,
    const RRColor& SpecularColor,
    const RRColor& CurrentColor,
    const RRColor& TextureColor,
    RRColor& OutputColor)
{
    DPFM(5, TEX, ("DoTextureBlend\n"));

    if (iStage >= 1)
    {
        if (m_TextureStageState[iStage-1].m_dwVal[D3DTSS_COLOROP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            // cast away the const'ness, just for PREMODULATE
            ((RRColor&)CurrentColor).R = CurrentColor.R * TextureColor.R;
            ((RRColor&)CurrentColor).G = CurrentColor.G * TextureColor.G;
            ((RRColor&)CurrentColor).B = CurrentColor.B * TextureColor.B;
        }
        if (m_TextureStageState[iStage-1].m_dwVal[D3DTSS_ALPHAOP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            ((RRColor&)CurrentColor).A *= CurrentColor.A * TextureColor.A;
        }
    }

    // compute arg1,2 for color channel blend
    RRColor ColorArg1, ColorArg2;
    RRColor AlphaArg1, AlphaArg2;
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG1], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, ColorArg1 );
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG2], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, ColorArg2 );

    // do color channel blend
    FLOAT fModulateScale;
    RRColorComp BlendFactor;
    switch ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] )
    {

    case D3DTOP_SELECTARG1:
        OutputColor.R = ColorArg1.R;
        OutputColor.G = ColorArg1.G;
        OutputColor.B = ColorArg1.B;
        break;
    case D3DTOP_SELECTARG2:
        OutputColor.R = ColorArg2.R;
        OutputColor.G = ColorArg2.G;
        OutputColor.B = ColorArg2.B;
        break;

    case D3DTOP_ADD:
        OutputColor.R = ColorArg1.R + ColorArg2.R;
        OutputColor.G = ColorArg1.G + ColorArg2.G;
        OutputColor.B = ColorArg1.B + ColorArg2.B;
        break;
    case D3DTOP_ADDSIGNED:
        OutputColor.R = ColorArg1.R + ColorArg2.R - .5f;
        OutputColor.G = ColorArg1.G + ColorArg2.G - .5f;
        OutputColor.B = ColorArg1.B + ColorArg2.B - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        OutputColor.R = (ColorArg1.R + ColorArg2.R - .5f)*2.0f;
        OutputColor.G = (ColorArg1.G + ColorArg2.G - .5f)*2.0f;
        OutputColor.B = (ColorArg1.B + ColorArg2.B - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        OutputColor.R = ~((~ColorArg1.R) + ColorArg2.R);
        OutputColor.G = ~((~ColorArg1.G) + ColorArg2.G);
        OutputColor.B = ~((~ColorArg1.B) + ColorArg2.B);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        OutputColor.R = ColorArg1.R + (~ColorArg1.R)*ColorArg2.R;
        OutputColor.G = ColorArg1.G + (~ColorArg1.G)*ColorArg2.G;
        OutputColor.B = ColorArg1.B + (~ColorArg1.B)*ColorArg2.B;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateC;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateC;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateC;
_DoModulateC:
        OutputColor.R = ColorArg1.R * ColorArg2.R * fModulateScale;
        OutputColor.G = ColorArg1.G * ColorArg2.G * fModulateScale;
        OutputColor.B = ColorArg1.B * ColorArg2.B * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: BlendFactor = DiffuseColor.A; goto _DoBlendC;
    case D3DTOP_BLENDTEXTUREALPHA: BlendFactor = TextureColor.A; goto _DoBlendC;
    case D3DTOP_BLENDCURRENTALPHA: BlendFactor = CurrentColor.A; goto _DoBlendC;
    case D3DTOP_BLENDFACTORALPHA:
        BlendFactor = (UINT8)RGBA_GETALPHA( m_dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR] );
        goto _DoBlendC;
_DoBlendC:
        OutputColor.R = BlendFactor * (ColorArg1.R - ColorArg2.R) + ColorArg2.R;
        OutputColor.G = BlendFactor * (ColorArg1.G - ColorArg2.G) + ColorArg2.G;
        OutputColor.B = BlendFactor * (ColorArg1.B - ColorArg2.B) + ColorArg2.B;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        OutputColor.R = ColorArg1.R + ( (~TextureColor.A) * ColorArg2.R );
        OutputColor.G = ColorArg1.G + ( (~TextureColor.A) * ColorArg2.G );
        OutputColor.B = ColorArg1.B + ( (~TextureColor.A) * ColorArg2.B );
        break;

    case D3DTOP_PREMODULATE:
        // just copy ColorArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        OutputColor.R = ColorArg1.R;
        OutputColor.G = ColorArg1.G;
        OutputColor.B = ColorArg1.B;
        break;
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
        OutputColor.R = ColorArg1.R + ColorArg1.A*ColorArg2.R;
        OutputColor.G = ColorArg1.G + ColorArg1.A*ColorArg2.G;
        OutputColor.B = ColorArg1.B + ColorArg1.A*ColorArg2.B;
        break;
    case D3DTOP_MODULATECOLOR_ADDALPHA:
        OutputColor.R = ColorArg1.R*ColorArg2.R + ColorArg1.A;
        OutputColor.G = ColorArg1.G*ColorArg2.G + ColorArg1.A;
        OutputColor.B = ColorArg1.B*ColorArg2.B + ColorArg1.A;
        break;
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
        OutputColor.R = (~ColorArg1.A)*ColorArg2.R + ColorArg1.R;
        OutputColor.G = (~ColorArg1.A)*ColorArg2.G + ColorArg1.G;
        OutputColor.B = (~ColorArg1.A)*ColorArg2.B + ColorArg1.B;
        break;
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        OutputColor.R = (~ColorArg1.R)*ColorArg2.R + ColorArg1.A;
        OutputColor.G = (~ColorArg1.G)*ColorArg2.G + ColorArg1.A;
        OutputColor.B = (~ColorArg1.B)*ColorArg2.B + ColorArg1.A;
        break;

    case D3DTOP_DOTPRODUCT3:
        OutputColor.R = ((ColorArg1.R-0.5f)*2.0f*(ColorArg2.R-0.5f)*2.0f +
             (ColorArg1.G-0.5f)*2.0f*(ColorArg2.G-0.5f)*2.0f +
             (ColorArg1.B-0.5f)*2.0f*(ColorArg2.B-0.5f)*2.0f);
        OutputColor.G = OutputColor.R;
        OutputColor.B = OutputColor.R;
        OutputColor.A = OutputColor.R;
        goto _SkipAlphaChannelBlend;
        break;
    }


    // compute arg1,2 for alpha channel blend
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_ALPHAARG1], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, AlphaArg1 );
    ComputeTextureBlendArg( m_TextureStageState[iStage].m_dwVal[D3DTSS_ALPHAARG2], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, AlphaArg2 );

    // do alpha channel blend
    switch ( m_TextureStageState[iStage].m_dwVal[D3DTSS_ALPHAOP] )
    {
    case D3DTOP_LEGACY_ALPHAOVR:
        if (m_pTexture[0])
        {
            OutputColor.A = ( m_pTexture[0]->m_bHasAlpha ) ? AlphaArg1.A : AlphaArg2.A;
        }
        else
        {
            OutputColor.A = AlphaArg1.A;
        }
        break;

    case D3DTOP_SELECTARG1:
        OutputColor.A = AlphaArg1.A;
        break;
    case D3DTOP_SELECTARG2:
        OutputColor.A = AlphaArg2.A;
        break;

    case D3DTOP_ADD:
        OutputColor.A = AlphaArg1.A + AlphaArg2.A;
        break;
    case D3DTOP_ADDSIGNED:
        OutputColor.A = AlphaArg1.A + AlphaArg2.A - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        OutputColor.A = (AlphaArg1.A + AlphaArg2.A - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        OutputColor.A = ~((~AlphaArg1.A) + AlphaArg2.A);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        OutputColor.A = AlphaArg1.A + (~AlphaArg1.A)*AlphaArg2.A;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateA;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateA;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateA;
_DoModulateA:
        OutputColor.A = AlphaArg1.A * AlphaArg2.A * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: BlendFactor = DiffuseColor.A; goto _DoBlendA;
    case D3DTOP_BLENDTEXTUREALPHA: BlendFactor = TextureColor.A; goto _DoBlendA;
    case D3DTOP_BLENDCURRENTALPHA: BlendFactor = CurrentColor.A; goto _DoBlendA;
    case D3DTOP_BLENDFACTORALPHA:
        BlendFactor = (UINT8)RGBA_GETALPHA( m_dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR] );
        goto _DoBlendA;
_DoBlendA:
        OutputColor.A = BlendFactor * (AlphaArg1.A - AlphaArg2.A) + AlphaArg2.A;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        OutputColor.A = AlphaArg1.A + ( (~TextureColor.A) * AlphaArg2.A );
        break;

    case D3DTOP_PREMODULATE:
        // just copy AlphaArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        OutputColor.A = AlphaArg1.A;
        break;

    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
    case D3DTOP_DOTPRODUCT3:
        // does nothing, not valid alpha op's
        break;
    }

_SkipAlphaChannelBlend:
    // clamp output color after each blend stage
    OutputColor.R = minimum( 1.f, maximum( 0.f, OutputColor.R ) );
    OutputColor.G = minimum( 1.f, maximum( 0.f, OutputColor.G ) );
    OutputColor.B = minimum( 1.f, maximum( 0.f, OutputColor.B ) );
    OutputColor.A = minimum( 1.f, maximum( 0.f, OutputColor.A ) );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\lighting.cpp ===
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
// Vertex Lighting function implementations
///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
void
RRLV_Directional(
    RRLIGHTING& LData,
    D3DLIGHT7 *pLight,
    RRLIGHTI *pLightI,
    D3DLIGHTINGELEMENT *in,
    DWORD dwFlags,
    DWORD dwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RRPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RRPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RRPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RRPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RRPV_COLORVERTEXSPEC;

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += pLightI->Ma_La.r;
        LData.diffuse.g += pLightI->Ma_La.g;
        LData.diffuse.b += pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += pLightI->La.b * LData.pAmbientSrc->b;
    }

    //
    // If no normals are present, bail out since we cannot perform the
    // normal-dependent computations
    //
    if( (dwFVFIn & D3DFVF_NORMAL) == 0 )
    {
        return;
    }

    D3DVALUE dot = DotProduct( pLightI->direction_in_eye, in->dvNormal );
    if (FLOAT_GTZ(dot))
    {
        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            D3DVECTOR h;      // halfway vector
            D3DVECTOR eye;    // incident vector ie vector from eye

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( pLightI->direction_in_eye, eye, h );

            // normalize
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_GTZ(dot))
            {
                if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
                {
                    D3DVALUE coeff = pow( dot, LData.material.power );
                    if (!bDoColVertexSpecular)
                    {
                        LData.specular.r += pLightI->Ms_Ls.r * coeff;
                        LData.specular.g += pLightI->Ms_Ls.g * coeff;
                        LData.specular.b += pLightI->Ms_Ls.b * coeff;
                    }
                    else
                    {
                        LData.specular.r += (pLightI->Ls.r *
                                             LData.pSpecularSrc->r * coeff);
                        LData.specular.g += (pLightI->Ls.g *
                                             LData.pSpecularSrc->g * coeff);
                        LData.specular.b += (pLightI->Ls.b *
                                             LData.pSpecularSrc->b * coeff);
                    }
                }
            }
        }
    }
    return;
}

void
RRLV_PointAndSpot(
    RRLIGHTING &LData,
    D3DLIGHT7 *pLight,
    RRLIGHTI *pLightI,
    D3DLIGHTINGELEMENT *in,
    DWORD dwFlags,
    DWORD dwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RRPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RRPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RRPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RRPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RRPV_COLORVERTEXSPEC;
    D3DVECTOR d;    // Direction to light
    D3DVALUE att;
    D3DVALUE dist;
    D3DVALUE dot;

    SubtractVector( pLightI->position_in_eye, in->dvPosition, d );

    // early out if out of range or exactly on the vertex
    D3DVALUE distSquared = SquareMagnitude( d );
    if (FLOAT_CMP_POS(distSquared, >=, pLightI->range_squared) ||
        FLOAT_EQZ(distSquared))
    {
        return;
    }

    //
    // Compute the attenuation
    //
    dist = SQRTF( distSquared );
    att = pLight->dvAttenuation0 + pLight->dvAttenuation1 * dist +
        pLight->dvAttenuation2 * distSquared;

    if (FLOAT_EQZ(att))
        att = FLT_MAX;
    else
        att = (D3DVALUE)1.0/att;

    dist = D3DVAL(1)/dist;

    //
    // If the light is a spotlight compute the spot-light factor
    //
    if (pLight->dltType == D3DLIGHT_SPOT)
    {
        // Calc dot product of direction to light with light direction to
        // be compared anganst the cone angles to see if we are in the
        // light.
        // Note that cone_dot is still scaled by dist
        D3DVALUE cone_dot = DotProduct(d, pLightI->direction_in_eye) * dist;

        if (FLOAT_CMP_POS(cone_dot, <=, pLightI->cos_phi_by_2))
        {
            return;
        }

        // modify att if in the region between phi and theta
        if (FLOAT_CMP_POS(cone_dot, <, pLightI->cos_theta_by_2))
        {
            D3DVALUE val = (cone_dot - pLightI->cos_phi_by_2) *
                pLightI->inv_theta_minus_phi;

            if (!FLOAT_EQZ( pLight->dvFalloff - 1.0 ))
            {
                val = POWF( val, pLight->dvFalloff );
            }
            att *= val;
        }
    }

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += att*pLightI->Ma_La.r;
        LData.diffuse.g += att*pLightI->Ma_La.g;
        LData.diffuse.b += att*pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += att*pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += att*pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += att*pLightI->La.b * LData.pAmbientSrc->b;
    }

    // Calc dot product of light dir with normal.  Note that since we
    // didn't normalize the direction the result is scaled by the distance.
    if( (dwFVFIn & D3DFVF_NORMAL) == 0)
    {
        // If no normals are present, bail out since we cannot perform the
        // normal-dependent computations
        return;
    }
    else
    {
        dot = DotProduct( d, in->dvNormal );
    }

    if (FLOAT_GTZ( dot ))
    {
        dot *= dist*att;

        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            D3DVECTOR h;      // halfway vector
            D3DVECTOR eye;    // incident vector ie vector from eye

            // normalize light direction
            d.x *= dist;
            d.y *= dist;
            d.z *= dist;

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( d, eye, h );
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
            {
                D3DVALUE coeff = pow( dot, LData.material.power ) * att;
                if (!bDoColVertexSpecular)
                {
                    LData.specular.r += pLightI->Ms_Ls.r * coeff;
                    LData.specular.g += pLightI->Ms_Ls.g * coeff;
                    LData.specular.b += pLightI->Ms_Ls.b * coeff;
                }
                else
                {
                    LData.specular.r += (pLightI->Ls.r *
                                         LData.pSpecularSrc->r * coeff);
                    LData.specular.g += (pLightI->Ls.g *
                                         LData.pSpecularSrc->g * coeff);
                    LData.specular.b += (pLightI->Ls.b *
                                         LData.pSpecularSrc->b * coeff);
                }
            }
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
// RRLight
///////////////////////////////////////////////////////////////////////////////
RRLight::RRLight()
{
    m_dwFlags = RRLIGHT_NEEDSPROCESSING;
    m_Next = NULL;

    ZeroMemory(&m_Light, sizeof(m_Light));
    ZeroMemory(&m_LightI, sizeof(m_LightI));

    // Initialize the light to some default values
    m_Light.dltType        = D3DLIGHT_DIRECTIONAL;

    m_Light.dcvDiffuse.r   = 1;
    m_Light.dcvDiffuse.g   = 1;
    m_Light.dcvDiffuse.b   = 1;
    m_Light.dcvDiffuse.a   = 0;

    m_Light.dvDirection.x  = 0;
    m_Light.dvDirection.y  = 0;
    m_Light.dvDirection.z  = 1;

    // m_Light.dcvSpecular = {0,0,0,0};
    // m_Light.dcvAmbient  = {0,0,0,0};
    // m_Light.dvPosition  = {0,0,0};

    // m_Light.dvRange        = 0;
    // m_Light.dvFalloff      = 0;
    // m_Light.dvAttenuation0 = 0;
    // m_Light.dvAttenuation1 = 0;
    // m_Light.dvAttenuation2 = 0;
    // m_Light.dvTheta        = 0;
    // m_Light.dvPhi          = 0;

    return;
}


HRESULT
RRLight::SetLight(LPD3DLIGHT7 pLight)
{

    // Validate the parameters passed
    switch (pLight->dltType)
    {
    case D3DLIGHT_POINT:
    case D3DLIGHT_SPOT:
    case D3DLIGHT_DIRECTIONAL:
        break;
    default:
        // No other light types are allowed
        DPFRR(0, "Invalid light type passed");
        return DDERR_INVALIDPARAMS;
    }
    if (pLight)
        m_Light = *pLight;

    // Mark it for processing later
    m_dwFlags |= RRLIGHT_NEEDSPROCESSING;
    return DD_OK;
}

HRESULT
RRLight::GetLight(LPD3DLIGHT7 pLight)
{
    if (pLight == NULL) return DDERR_GENERIC;
    *pLight = m_Light;
    return D3D_OK;
}

void
RRLight::ProcessLight(D3DMATERIAL7 *mat, RRLIGHTVERTEX_FUNC_TABLE *pTbl)
{
    //
    // If it is already processed, return
    //
    if (!NeedsProcessing()) return;

    //
    // Save the ambient light  (0-1)
    //
    m_LightI.La.r  = m_Light.dcvAmbient.r;
    m_LightI.La.g  = m_Light.dcvAmbient.g;
    m_LightI.La.b  = m_Light.dcvAmbient.b;

    //
    // Save the diffuse light  (0-1)
    //
    m_LightI.Ld.r  = m_Light.dcvDiffuse.r;
    m_LightI.Ld.g  = m_Light.dcvDiffuse.g;
    m_LightI.Ld.b  = m_Light.dcvDiffuse.b;

    //
    // Save the specular light (0-1)
    //
    m_LightI.Ls.r  = m_Light.dcvSpecular.r;
    m_LightI.Ls.g  = m_Light.dcvSpecular.g;
    m_LightI.Ls.b  = m_Light.dcvSpecular.b;

    //
    // Material Ambient times Light Ambient
    //
    m_LightI.Ma_La.r = m_LightI.La.r * mat->ambient.r * D3DVALUE(255.0);
    m_LightI.Ma_La.g = m_LightI.La.g * mat->ambient.g * D3DVALUE(255.0);
    m_LightI.Ma_La.b = m_LightI.La.b * mat->ambient.b * D3DVALUE(255.0);

    //
    // Material Diffuse times Light Diffuse
    //
    m_LightI.Md_Ld.r = m_LightI.Ld.r * mat->diffuse.r * D3DVALUE(255.0);
    m_LightI.Md_Ld.g = m_LightI.Ld.g * mat->diffuse.g * D3DVALUE(255.0);
    m_LightI.Md_Ld.b = m_LightI.Ld.b * mat->diffuse.b * D3DVALUE(255.0);

    //
    // Material Specular times Light Specular
    //
    m_LightI.Ms_Ls.r = m_LightI.Ls.r * mat->specular.r * D3DVALUE(255.0);
    m_LightI.Ms_Ls.g = m_LightI.Ls.g * mat->specular.g * D3DVALUE(255.0);
    m_LightI.Ms_Ls.b = m_LightI.Ls.b * mat->specular.b * D3DVALUE(255.0);


    //
    // Assign the actual lighting function pointer, in addition to
    // performing some precomputation of light-type specific data
    //
    m_pfnLightVertex = NULL;
    switch (m_Light.dltType)
    {
    case D3DLIGHT_DIRECTIONAL:
        m_pfnLightVertex = pTbl->pfnDirectional;
        break;
    case D3DLIGHT_POINT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.inv_theta_minus_phi = 1.0f;
        m_pfnLightVertex = pTbl->pfnPoint;
        break;
    case D3DLIGHT_SPOT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.dvTheta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.dvPhi / 2.0);
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
        m_pfnLightVertex = pTbl->pfnSpot;
        break;
    default:
        DPFRR( 0, "Cannot process light of unknown type" );
        break;
    }

    // Mark it as been processed
    m_dwFlags &= ~RRLIGHT_NEEDSPROCESSING;
    return;
}

void
RRLight::Enable(RRLight **ppRoot)
{
    // Assert that it is not already enabled
    if (IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RRLight *pTmp = *ppRoot;
    *ppRoot = this;
    m_Next = pTmp;
    m_dwFlags |= RRLIGHT_ENABLED;

    return;
}

void
RRLight::Disable(RRLight **ppRoot)
{
    // Assert that the light is enabled
    if (!IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RRLight *pLightPrev = *ppRoot;

    // If this is the first light in the active list
    if (pLightPrev == this)
    {
        *ppRoot = m_Next;
        m_dwFlags &= ~RRLIGHT_ENABLED;
        return;
    }

    while (pLightPrev->m_Next != this)
    {
        // Though this light was marked as enabled, it is not on
        // the active list. Assert this.
        if (pLightPrev->m_Next == NULL)
        {
            m_dwFlags &= ~RRLIGHT_ENABLED;
            return;
        }

        // Else get the next pointer
        pLightPrev = pLightPrev->m_Next;
    }

    pLightPrev->m_Next = m_Next;
    m_dwFlags &= ~RRLIGHT_ENABLED;
    return;
}

void
RRLight::XformLight( RRMATRIX *mView )
{
    // If the light is not a directional light,
    // tranform its position to camera space
    if (m_Light.dltType != D3DLIGHT_DIRECTIONAL)
    {
        XformBy4x3(&m_Light.dvPosition, mView, &m_LightI.position_in_eye);
    }

    if (m_Light.dltType != D3DLIGHT_POINT)
    {
        // Transform light direction to the eye space
        Xform3VecBy3x3( &m_Light.dvDirection, mView,
                        &m_LightI.direction_in_eye );
        // Normalize it
        Normalize( m_LightI.direction_in_eye );

        // Reverse it such that the direction is to the light
        ReverseVector( m_LightI.direction_in_eye, m_LightI.direction_in_eye );
    }

    return;
}

//---------------------------------------------------------------------
// ScaleRGBColorTo255: Scales colors from 0-1 range to 0-255 range
//---------------------------------------------------------------------
void
ScaleRGBColorTo255( const D3DCOLORVALUE& src, RRCOLOR& dest )
{
    dest.r = D3DVALUE(255.0) * src.r;
    dest.g = D3DVALUE(255.0) * src.g;
    dest.b = D3DVALUE(255.0) * src.b;
}


//---------------------------------------------------------------------
// RRProcessVertices::UpdateLightingData
//             Updates lighting data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateLightingData()
{
    HRESULT hr = D3D_OK;
    RRLIGHTING& LData = m_lighting;
    RRLight *pLight = m_lighting.pActiveLights;
    D3DVECTOR   t;
    D3DMATERIAL7 *mat = &m_Material;

    //
    // Eye in eye space
    //
    LData.eye_in_eye.x = (D3DVALUE)0;
    LData.eye_in_eye.y = (D3DVALUE)0;
    LData.eye_in_eye.z = (D3DVALUE)0;

    // ATTENTION: Colorvertex may have changed the values of the
    // material alphas
    if (m_dwDirtyFlags & RRPV_DIRTY_MATERIAL)
    {
        //
        // Save the material to be used to light vertices
        //
        LData.material = *mat;
        ScaleRGBColorTo255( mat->ambient, LData.matAmb );
        ScaleRGBColorTo255( mat->diffuse, LData.matDiff );
        ScaleRGBColorTo255( mat->specular, LData.matSpec );
        ScaleRGBColorTo255( mat->emissive, LData.matEmis );

        //
        // Compute the Material Diffuse Alpha
        //
        LData.materialDiffAlpha = mat->diffuse.a * D3DVALUE(255);
        if (mat->diffuse.a < 0)
            LData.materialDiffAlpha = 0;
        else if (LData.materialDiffAlpha > 255)
            LData.materialDiffAlpha = 255 << 24;
        else LData.materialDiffAlpha <<= 24;

        //
        // Compute the Material Specular Alpha
        //
        LData.materialSpecAlpha = mat->specular.a * D3DVALUE(255);
        if (mat->specular.a < 0)
            LData.materialSpecAlpha = 0;
        else if (LData.materialSpecAlpha > 255)
            LData.materialSpecAlpha = 255 << 24;
        else LData.materialSpecAlpha <<= 24;

        //
        // Precompute the ambient and emissive components that are
        // not dependent on any contribution by the lights themselves
        //
        LData.ambEmiss.r = LData.ambient_red   * LData.matAmb.r +
            LData.matEmis.r;
        LData.ambEmiss.g = LData.ambient_green * LData.matAmb.g +
            LData.matEmis.g;
        LData.ambEmiss.b = LData.ambient_blue  * LData.matAmb.b +
            LData.matEmis.b;

        //
        // If the dot product is less than this
        // value, specular factor is zero
        //
        if (mat->power > D3DVAL(0.001))
        {
            LData.specThreshold = D3DVAL(pow(0.001, 1.0/mat->power));
        }
    }

    while (pLight)
    {
        if ((m_dwDirtyFlags & RRPV_DIRTY_MATERIAL) ||
            pLight->NeedsProcessing())
        {
            // If the material is dirty, light needs processing, regardless
            if (m_dwDirtyFlags & RRPV_DIRTY_MATERIAL)
            {
                pLight->m_dwFlags |= RRLIGHT_NEEDSPROCESSING;
            }

            // If the light has been set, or some material paramenters
            // changed, re-process the light.
            pLight->ProcessLight( &m_Material, &m_LightVertexTable );

            // Transform the light to Eye space
            // Lights are defined in world space, so simply apply the
            // Viewing transform
            pLight->XformLight( &m_xfmView );

        }
        else if (m_dwDirtyFlags & RRPV_DIRTY_NEEDXFMLIGHT)
        {
            pLight->XformLight( &m_xfmView );
        }

        pLight = pLight->m_Next;
    }

    // Clear Lighting dirty flags
    m_dwDirtyFlags &= ~RRPV_DIRTY_LIGHTING;
    return hr;
}


//---------------------------------------------------------------------
// RRProcessVertices::UpdateFogData
//             Updates Fog data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateFogData()
{
    HRESULT hr = D3D_OK;

    if (m_lighting.fog_end == m_lighting.fog_start)
        m_lighting.fog_factor = D3DVAL(0.0);
    else
        m_lighting.fog_factor = D3DVAL(255) / (m_lighting.fog_end -
                                               m_lighting.fog_start);

    // Clear Fog dirty flags
    m_dwDirtyFlags &= ~RRPV_DIRTY_FOG;
    return hr;
}

//---------------------------------------------------------------------
// RRProcessVertices::LightVertex
//           Actual lighting computation takes place here
//---------------------------------------------------------------------
void
RRProcessVertices::LightVertex(D3DLIGHTINGELEMENT *pLE)
{
    RRLIGHTING &LData = m_lighting;
    RRLight  *pLight;

    //
    // Initialize Diffuse color with the Ambient and Emissive component
    // independent of the light (Ma*La + Me)
    //

    if (m_dwTLState & (RRPV_COLORVERTEXEMIS | RRPV_COLORVERTEXAMB))
    {
        // If the material values need to be replaced, compute

        LData.diffuse.r = LData.ambient_red * LData.pAmbientSrc->r +
            LData.pEmissiveSrc->r;
        LData.diffuse.g = LData.ambient_green * LData.pAmbientSrc->g +
            LData.pEmissiveSrc->g;
        LData.diffuse.b = LData.ambient_blue  * LData.pAmbientSrc->b +
            LData.pEmissiveSrc->b;
    }
    else
    {
        // If none of the material values needs to be replaced

        LData.diffuse = LData.ambEmiss;
    }


    //
    // Initialize the Specular to Zero
    //
    LData.specular.r = D3DVAL(0);
    LData.specular.g = D3DVAL(0);
    LData.specular.b = D3DVAL(0);

    //
    // In a loop accumulate color from the activated lights
    //
    pLight = LData.pActiveLights;
    while (pLight)
    {
        if (pLight->m_pfnLightVertex)
            (*pLight->m_pfnLightVertex)(m_lighting,
                                        &pLight->m_Light,
                                        &pLight->m_LightI,
                                        pLE,
                                        m_dwTLState,
                                        m_dwFVFIn);
        pLight = pLight->m_Next;
    }

    //
    // Compute the diffuse color of the vertex
    //
    int r = FTOI(LData.diffuse.r);
    int g = FTOI(LData.diffuse.g);
    int b = FTOI(LData.diffuse.b);
    DWORD a = *LData.pDiffuseAlphaSrc;

    //
    // Clamp the r, g, b, components
    //
    if (r < 0) r = 0; else if (r > 255) r = 255;
    if (g < 0) g = 0; else if (g > 255) g = 255;
    if (b < 0) b = 0; else if (b > 255) b = 255;

    LData.outDiffuse =  a + (r<<16) + (g<<8) + b;


    //
    // Obtain the specular Alpha
    //
    a = *(LData.pSpecularAlphaSrc);

    //
    // Compute the RGB part of the specular color
    //
    if (m_dwTLState & RRPV_DOSPECULAR)
    {
        r = FTOI(LData.specular.r);
        g = FTOI(LData.specular.g);
        b = FTOI(LData.specular.b);

        //
        // Clamp the r, g, b, components
        //
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

    }
    //
    // If SPECULAR is not enabled but the specular color
    // had been provided in the input vertex, simply copy.
    //
    else if ( m_qwFVFOut & D3DFVF_SPECULAR )
    {
        r = FTOI(LData.vertexSpecular.r);
        g = FTOI(LData.vertexSpecular.g);
        b = FTOI(LData.vertexSpecular.b);
        a = LData.vertexSpecAlpha;
    }
    //
    // If SpecularColor is not enabled
    //
    else
    {
        r = g = b = 0;
    }

    LData.outSpecular =  a + (r<<16) + (g<<8) + b;

    return;
}

//---------------------------------------------------------------------
// RRProcessVertices::FogVertex
//           Vertex Fog computation
// Input:
//      v    - input vertex in the model space
//      le   - vertex, transformed to the camera space
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//---------------------------------------------------------------------
#define RRPV_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
void
RRProcessVertices::FogVertex(D3DVECTOR &v,
                             D3DLIGHTINGELEMENT *pLE,
                             int numVertexBlends,
                             float *pBlendFactors,
                             BOOL bVertexInEyeSpace)
{
    D3DVALUE dist = 0.0f;

    //
    // Calculate the distance
    //
    if (bVertexInEyeSpace)
    {
        // Vertex is already transformed to the camera space
        if (m_dwTLState & RRPV_RANGEFOG)
        {
            dist = SQRTF(pLE->dvPosition.x*pLE->dvPosition.x +
                         pLE->dvPosition.y*pLE->dvPosition.y +
                         pLE->dvPosition.z*pLE->dvPosition.z);
        }
        else
        {
            dist = pLE->dvPosition.z;
        }
    }
    else if (m_dwTLState & RRPV_RANGEFOG)
    {
        D3DVALUE x = 0, y = 0, z = 0;
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
            }

            cumulBlend += pBlendFactors[j];

            x += (v.x*m_xfmToEye[j]._11 +
                  v.y*m_xfmToEye[j]._21 +
                  v.z*m_xfmToEye[j]._31 +
                  m_xfmToEye[j]._41) * blend;
            y += (v.x*m_xfmToEye[j]._12 +
                  v.y*m_xfmToEye[j]._22 +
                  v.z*m_xfmToEye[j]._32 +
                  m_xfmToEye[j]._42) * blend;
            z += (v.x*m_xfmToEye[j]._13 +
                  v.y*m_xfmToEye[j]._23 +
                  v.z*m_xfmToEye[j]._33 +
                  m_xfmToEye[j]._43) * blend;
        }

        dist = SQRTF(x*x + y*y + z*z);
    }
    else
    {
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
            }

            cumulBlend += pBlendFactors[j];

            dist += (v.x*m_xfmToEye[j]._13 +
                  v.y*m_xfmToEye[j]._23 +
                  v.z*m_xfmToEye[j]._33 +
                  m_xfmToEye[j]._43) * blend;
        }
    }

    if (m_lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < m_lighting.fog_start)
        {
            RRPV_SET_ALPHA(m_lighting.outSpecular, 255);
        }
        else if (dist >= m_lighting.fog_end)
        {
            RRPV_SET_ALPHA(m_lighting.outSpecular, 0);
        }
        else
        {
            D3DVALUE v = (m_lighting.fog_end - dist) * m_lighting.fog_factor;
            int f = FTOI(v);
            RRPV_SET_ALPHA(m_lighting.outSpecular, f);
        }
    }
    else
    {
        D3DVALUE tmp = dist * m_lighting.fog_density;
        if (m_lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        tmp = (D3DVALUE)exp(-tmp) * 255.0f;
        int f = FTOI(tmp);
        RRPV_SET_ALPHA( m_lighting.outSpecular, f )
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
RRProcessVertices::__CLIP_NAME(RRCLIPVTX **inv, 
                               RRCLIPVTX **outv,
                               int count)
{
    int i;
    int out_count = 0;
    RRCLIPVTX *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * m_ViewData.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * m_ViewData.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } 
        else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int 
RRProcessVertices::__CLIP_LINE_NAME(RRCLIPTRIANGLE *line) 
{
    D3DVALUE in1, in2;
    RRCLIPVTX outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * m_ViewData.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * m_ViewData.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(&outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(&outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include <d3d.h>
#include <d3dhal.h>

#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT

#include "refrast.hpp"      // public interfaces
#include "clipping.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\procprim.cpp ===
#include "pch.cpp"
#pragma hdrstop

const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//---------------------------------------------------------------------
// This function should be called every time FVF ID is changed
// All pv flags, input and output FVF id should be set before calling the
// function.
//---------------------------------------------------------------------
void UpdateComponentOffsets (DWORD dwFVFIn,
                             LPDWORD pNormalOffset,
                             LPDWORD pDiffOffset,
                             LPDWORD pSpecOffset,
                             LPDWORD pTexOffset)
{
    DWORD dwOffset = 0;

    switch( dwFVFIn & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZ:
        dwOffset = sizeof(D3DVECTOR);
        break;
    case D3DFVF_XYZB1:
        dwOffset = sizeof(D3DVECTOR) + sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB2:
        dwOffset = sizeof(D3DVECTOR) + 2*sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB3:
        dwOffset = sizeof(D3DVECTOR) + 3*sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB4:
        dwOffset = sizeof(D3DVECTOR) + 4*sizeof(D3DVALUE);
        break;
    case D3DFVF_XYZB5:
        dwOffset = sizeof(D3DVECTOR) + 5*sizeof(D3DVALUE);
        break;
    default:
        DPFM(0,TNL,("Unable to compute offsets, strange FVF bits set"));
    }

    *pNormalOffset = dwOffset;

    if (dwFVFIn & D3DFVF_NORMAL)
        dwOffset += sizeof(D3DVECTOR);
    if (dwFVFIn & D3DFVF_RESERVED1)
        dwOffset += sizeof(D3DVALUE);

    // Offset to the diffuse color
    *pDiffOffset = dwOffset;

    if (dwFVFIn & D3DFVF_DIFFUSE)
        dwOffset += sizeof(DWORD);

    // Offset to the specular color
    *pSpecOffset = dwOffset;

    if (dwFVFIn & D3DFVF_SPECULAR)
        dwOffset += sizeof(DWORD);

    // Offset to the texture data
    *pTexOffset = dwOffset;
}

//---------------------------------------------------------------------
// SetupFVFData:
//             Compute Output FVF and the size of output vertices
//---------------------------------------------------------------------
void
RRProcessVertices::SetupFVFData(BOOL bFogEnabled, BOOL bSpecularEnabled)
{

    // Compute number of texture coordinates
    m_dwNumTexCoords = FVF_TEXCOORD_NUMBER(m_dwFVFIn);

    // Compute output FVF
    m_qwFVFOut = D3DFVF_XYZRHW;

    // If normal is present we have to compute specular and diffuse
    // Otherwise set these bits the same as input.
    // Not that normal should not be present for XYZRHW position type
    if (m_dwTLState & RRPV_DOLIGHTING)
    {
        m_qwFVFOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        m_qwFVFOut |= (m_dwFVFIn & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR));
    }

    // Always set specular flag if fog is enabled
    // if (this->rstates[D3DRENDERSTATE_FOGENABLE])
    if (bFogEnabled)
    {
        m_qwFVFOut |= D3DFVF_SPECULAR;
    }
    // Clear specular flag if specular disabled
    // else if (!this->rstates[D3DRENDERSTATE_SPECULARENABLE])
    else if (!bSpecularEnabled && !(m_dwFVFIn & D3DFVF_SPECULAR))
    {
        m_qwFVFOut &= ~D3DFVF_SPECULAR;
    }

#ifdef __POINTSPRITES
    // Reserve space for point size, if needed
    if (m_dwTLState & RRPV_DOCOMPUTEPOINTSIZE)
    {
        m_qwFVFOut |= D3DFVF_S;
    }
#endif

    // Reserve space for eye space info, if needed
    if (m_dwTLState & RRPV_DOPASSEYENORMAL)
    {
        m_qwFVFOut |= D3DFVFP_EYENORMAL;
    }
    if (m_dwTLState & RRPV_DOPASSEYEXYZ)
    {
        m_qwFVFOut |= D3DFVFP_EYEXYZ;
    }

    // Set up number of texture coordinates and copy texture formats
    m_qwFVFOut |= (m_dwNumTexCoords << D3DFVF_TEXCOUNT_SHIFT) |
                   (m_dwFVFIn & 0xFFFF0000);

    // Compute size of texture coordinates
    // This size is the same for input and output FVFs,
    // because for DX7 drivers they have number of texture and texture formats
    m_dwTextureCoordSizeTotal = 0;
    ComputeTextureCoordSize(m_dwFVFIn, m_dwTexCoordSize,
                            &m_dwTextureCoordSizeTotal);

    //  Compute output size
    m_dwOutputVtxSize   = GetFVFVertexSize( m_qwFVFOut );
    m_position.dwStride = GetFVFVertexSize( m_dwFVFIn );

    // Now compute the input FVF dependent offsets used by the Geometry loop
    UpdateComponentOffsets (m_dwFVFIn, &m_dwNormalOffset,
                            &m_dwDiffuseOffset, &m_dwSpecularOffset,
                            &m_dwTexOffset);
    return;
}

///////////////////////////////////////////////////////////////////////////////
// SavePrimitiveData
///////////////////////////////////////////////////////////////////////////////
void
ReferenceRasterizer::SavePrimitiveData(
    DWORD dwFVFIn,
    LPVOID pVtx,
    UINT cVertices,
    D3DPRIMITIVETYPE PrimType
    )
{
    //
    // 1) Save the incoming information
    //
    m_primType = PrimType;
    m_position.lpvData = pVtx;

    // Force some state changes if the FVF is different
    if( dwFVFIn != m_dwFVFIn )
    {
        m_dwDirtyFlags |= RRPV_DIRTY_COLORVTX;
    }

    m_dwFVFIn = dwFVFIn;
    m_dwNumVertices = cVertices;

    // No indices to work with
    m_dwNumIndices = 0;
    m_pIndices = NULL;
}

void
ReferenceRasterizer::SavePrimitiveData(
    DWORD dwFVFIn,
    LPVOID pVtx,
    UINT cVertices,
    D3DPRIMITIVETYPE PrimType,
    LPWORD pIndices,
    UINT cIndices
    )
{
    //
    // 1) Save the incoming information
    //
    m_primType = PrimType;
    m_position.lpvData = pVtx;

    // Force some state changes if the FVF is different
    if( dwFVFIn != m_dwFVFIn )
    {
        m_dwDirtyFlags |= RRPV_DIRTY_COLORVTX;
    }

    m_dwFVFIn = dwFVFIn;
    m_dwNumVertices = cVertices;

    m_dwNumIndices = cIndices;
    m_pIndices = pIndices;
}

///////////////////////////////////////////////////////////////////////////////
// Process primitives implementation:
// 1) Compute FVF info
// 2) Grow buffers to the requisite size
// 3) Initialize clipping state
// 4) Update T&L state
// 5) Transform, Light and compute clipping for vertices
// 6) Clip and Draw the primitives
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
ReferenceRasterizer::ProcessPrimitive(
    BOOL bIndexedPrim
    )
{
    HRESULT ret = D3D_OK;
    DWORD dwVertexPoolSize = 0;

    //
    // Update T&L state (must be before FVFData is set up)
    //

    // Update Lighting and related state and flags
    if ((ret = UpdateTLState()) != D3D_OK)
        return ret;

    //
    // Compute Output FVF and the size of output vertices
    //
    SetupFVFData(GetRenderState()[D3DRENDERSTATE_FOGENABLE],
                 GetRenderState()[D3DRENDERSTATE_SPECULARENABLE]);

    //
    // Clipping information depends both on the output FVF computation
    // and the other State, so do it here after both have been computed
    //
    if (m_dwTLState & RRPV_DOCLIPPING)
    {
        // Figure out which pieces need to be interpolated in new vertices.
        m_clipping.dwInterpolate = 0;
        if (GetRenderState()[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_COLOR;
            
            if (m_qwFVFOut & D3DFVF_SPECULAR)
            {
                m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_SPECULAR;
            }
        }
        if (GetRenderState()[D3DRENDERSTATE_FOGENABLE])
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_SPECULAR;
        }

        if (FVF_TEXCOORD_NUMBER(m_dwFVFIn) != 0)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_TEXTURE;
        }

        if (m_dwTLState & RRPV_DOCOMPUTEPOINTSIZE)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_S;
        }

        if (m_dwTLState & RRPV_DOPASSEYENORMAL)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_EYENORMAL;
        }

        if (m_dwTLState & RRPV_DOPASSEYEXYZ)
        {
            m_clipping.dwInterpolate |= RRCLIP_INTERPOLATE_EYEXYZ;
        }

        // Clear clip union and intersection flags
        m_clipIntersection = 0;
        m_clipUnion = 0;

        HRESULT hr = S_OK;
        HR_RET( UpdateClippingData( GetRenderState()[D3DRENDERSTATE_CLIPPLANEENABLE] ));
    }

    // This needs to be updated bbecause the rasterizer part of
    // the Reference Driver uses it.
    m_qwFVFControl = m_qwFVFOut;

    //
    // Grow buffers to the requisite size
    //

    // Size of the buffer required to transform into
    dwVertexPoolSize = m_dwNumVertices * m_dwOutputVtxSize;

    // Grow TLVBuf if required
    if (dwVertexPoolSize > this->m_TLVBuf.GetSize())
    {
        if (this->m_TLVBuf.Grow(dwVertexPoolSize) != D3D_OK)
        {
            DPFM(0,TNL,("Could not grow TL vertex buffer"));
            ret = DDERR_OUTOFMEMORY;
            return ret;
        }
    }
    this->m_pvOut = this->m_TLVBuf.GetAddress();

    // Grow ClipFlagBuf if required
    if (GetRenderState()[D3DRENDERSTATE_CLIPPING])
    {
        DWORD size = m_dwNumVertices * sizeof(RRCLIPCODE);
        if (size > this->m_ClipFlagBuf.GetSize())
        {
            if (this->m_ClipFlagBuf.Grow(size) != D3D_OK)
            {
                DPFM(0,TNL,("Could not grow clip buffer"));
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->m_pClipBuf = (RRCLIPCODE *)this->m_ClipFlagBuf.GetAddress();
    }

    //
    // Transform, Light and compute clipping for vertices
    //
    if (ProcessVertices())
    {
        // If the entire primitive lies outside the view frustum, quit
        // without drawing
        return D3D_OK;
    }

    //
    // Clip and Draw the primitives
    //

    if (bIndexedPrim)
    {
        if (!NeedClipping((m_dwTLState & RRPV_GUARDBAND), m_clipUnion))
        {
            ret = DoDrawOneIndexedPrimitive( this,
                                             m_dwOutputVtxSize,
                                             (PUINT8) m_pvOut,
                                             m_pIndices,
                                             m_primType,
                                             m_dwNumIndices
                                             );
        }
        else
        {
            ret = DrawOneClippedIndexedPrimitive();
        }
    }
    else
    {
        if (!NeedClipping((m_dwTLState & RRPV_GUARDBAND), m_clipUnion))
        {
            ret = DoDrawOnePrimitive( this,
                                      m_dwOutputVtxSize,
                                      (PUINT8) m_pvOut,
                                      m_primType,
                                      m_dwNumVertices
                                      );
        }
        else
        {
            ret = DrawOneClippedPrimitive();
        }
    }

#if 0
    D3DFE_UpdateClipStatus(this);
#endif //0
    return ret;
}



//---------------------------------------------------------------------
// ReferenceRasterizer::UpdateTLState
//             Updates transform and lighting related state
//---------------------------------------------------------------------
HRESULT
ReferenceRasterizer::UpdateTLState()
{
    HRESULT hr = D3D_OK;

    //
    // Update Geometry Loop flags based on the current state set
    //

    // Need to compute the Min of what is in the FVF and the renderstate.
    m_numVertexBlends = min( GetRenderState()[D3DRENDERSTATE_VERTEXBLEND],
                             ((m_dwFVFIn & D3DFVF_POSITION_MASK) >> 1) - 2 );

#ifdef __POINTSPRITES
    //
    // Check prim type to see if point size computation is needed
    // Need to set this before the transform state is set
    //
    m_dwTLState &= ~RRPV_DOCOMPUTEPOINTSIZE;
    switch(m_primType)
    {
    case D3DPT_POINTLIST:
        m_dwTLState |= RRPV_DOCOMPUTEPOINTSIZE;
        break;
    }
#endif

    m_dwTLState &= ~(RRPV_DOPASSEYENORMAL|RRPV_DOPASSEYEXYZ);
    for ( DWORD dwStage=0; dwStage<D3DHAL_TSS_MAXSTAGES; dwStage++ )
    {
        // check for disabled stage (subsequent are thus inactive)
        if ( GetTextureStageState(dwStage)[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }

        switch ( GetTextureStageState(dwStage)[D3DTSS_TEXCOORDINDEX] & 0xffff0000)
        {
        case D3DTSS_TCI_CAMERASPACENORMAL:
            m_dwTLState |= RRPV_DOPASSEYENORMAL;
            break;
        case D3DTSS_TCI_CAMERASPACEPOSITION:
            m_dwTLState |= RRPV_DOPASSEYEXYZ;
            break;
        case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
            m_dwTLState |= (RRPV_DOPASSEYENORMAL|RRPV_DOPASSEYEXYZ);
            break;
        }
    }

    // Fog or not:
    // Compute fog if: 1) Fogging is enabled
    //                 2) VertexFog mode is not FOG_NONE
    //                 3) TableFog mode is FOG_NONE
    // If both table and vertex fog are not FOG_NONE, table fog
    // is applied.
    if (GetRenderState()[D3DRENDERSTATE_FOGENABLE] &&
        GetRenderState()[D3DRENDERSTATE_FOGVERTEXMODE] &&
        !GetRenderState()[D3DRENDERSTATE_FOGTABLEMODE])
    {
        m_dwTLState |= RRPV_DOFOG;
        // Range Fog
        if (GetRenderState()[D3DRENDERSTATE_RANGEFOGENABLE])
        {
            m_dwTLState |= RRPV_RANGEFOG;
        }
        else
        {
            m_dwTLState &= ~RRPV_RANGEFOG;
        }
    }
    else
    {
        m_dwTLState &= ~(RRPV_DOFOG | RRPV_RANGEFOG);
    }

    // Something changed in the transformation state
    // Recompute digested transform state
    HR_RET(UpdateXformData());

    // Something changed in the lighting state
    if ((m_dwTLState & RRPV_DOLIGHTING) &&
        (m_dwDirtyFlags & RRPV_DIRTY_LIGHTING))
    {
        //
        // Compute Colorvertex flags only if the lighting is enabled
        //
        m_dwTLState &= ~RRPV_COLORVERTEXFLAGS;
        m_lighting.pAmbientSrc = &m_lighting.matAmb;
        m_lighting.pDiffuseSrc = &m_lighting.matDiff;
        m_lighting.pSpecularSrc = &m_lighting.matSpec;
        m_lighting.pEmissiveSrc = &m_lighting.matEmis;
        m_lighting.pDiffuseAlphaSrc = &m_lighting.materialDiffAlpha;
        m_lighting.pSpecularAlphaSrc = &m_lighting.materialSpecAlpha;
        if (GetRenderState()[D3DRENDERSTATE_COLORVERTEX])
        {
            switch( GetRenderState()[D3DRENDERSTATE_AMBIENTMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXAMB);
                        m_lighting.pAmbientSrc = &m_lighting.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXAMB);
                        m_lighting.pAmbientSrc = &m_lighting.vertexSpecular;
                    }
                }
                break;
            }

            switch( GetRenderState()[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXDIFF);
                        m_lighting.pDiffuseSrc = &m_lighting.vertexDiffuse;
                        m_lighting.pDiffuseAlphaSrc =
                            &m_lighting.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXDIFF);
                        m_lighting.pDiffuseSrc = &m_lighting.vertexSpecular;
                        m_lighting.pDiffuseAlphaSrc =
                            &m_lighting.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRenderState()[D3DRENDERSTATE_SPECULARMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXSPEC);
                        m_lighting.pSpecularSrc = &m_lighting.vertexDiffuse;
                        m_lighting.pSpecularAlphaSrc =
                            &m_lighting.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXSPEC);
                        m_lighting.pSpecularSrc = &m_lighting.vertexSpecular;
                        m_lighting.pSpecularAlphaSrc =
                            &m_lighting.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRenderState()[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if (m_dwFVFIn & D3DFVF_DIFFUSE)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXDIFFUSENEEDED | RRPV_COLORVERTEXEMIS);
                        m_lighting.pEmissiveSrc = &m_lighting.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if (m_dwFVFIn & D3DFVF_SPECULAR)
                    {
                        m_dwTLState |=
                            (RRPV_VERTEXSPECULARNEEDED | RRPV_COLORVERTEXEMIS);
                        m_lighting.pEmissiveSrc = &m_lighting.vertexSpecular;
                    }
                }
                break;
            }
        }

        // If specular is needed in the output and has been provided
        // in the input, force the copy of specular data
        if ((m_dwFVFIn & D3DFVF_SPECULAR) && 
            (GetRenderState()[D3DRENDERSTATE_SPECULARENABLE] == FALSE))
        {
            m_dwTLState |= RRPV_VERTEXSPECULARNEEDED;
        }

        //
        // Update the remaining light state
        //
        HR_RET(UpdateLightingData());
    }

    if ((m_dwTLState & RRPV_DOFOG) &&
        (m_dwDirtyFlags & RRPV_DIRTY_FOG))
    {
        HR_RET(UpdateFogData());
    }



    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// RRProcessVertices method implementations
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
inline void MakeRRCOLOR( RRCOLOR *out, DWORD inputColor )
{
    out->r = (D3DVALUE)RGBA_GETRED( inputColor );
    out->g = (D3DVALUE)RGBA_GETGREEN( inputColor );
    out->b = (D3DVALUE)RGBA_GETBLUE( inputColor );
}

//---------------------------------------------------------------------
// RRProcessVertices::ComputeClipCodes
//---------------------------------------------------------------------
RRCLIPCODE
RRProcessVertices::ComputeClipCodes(RRCLIPCODE* pclipIntersection, RRCLIPCODE* pclipUnion,
        FLOAT x_clip, FLOAT y_clip, FLOAT z_clip, FLOAT w_clip, FLOAT fPointSize)
{
    // if true, need to deal with point size for clipping
    BOOL bPointSize = (fPointSize > 1.0f);
    D3DVALUE xx = w_clip - x_clip;
    D3DVALUE yy = w_clip - y_clip;
    D3DVALUE zz = w_clip - z_clip;

    // if (x < 0)  clip |= RRCLIP_LEFTBIT;
    // if (x >= we) clip |= RRCLIP_RIGHTBIT;
    // if (y < 0)  clip |= RRCLIP_BOTTOMBIT;
    // if (y >= we) clip |= RRCLIP_TOPBIT;
    // if (z < 0)    clip |= RRCLIP_FRONTBIT;
    // if (z >= we) clip |= RRCLIP_BACKBIT;
    RRCLIPCODE clip = ((AS_INT32(x_clip)  & 0x80000000) >>  (32-RRCLIP_LEFTBIT))  |
           ((AS_INT32(y_clip)  & 0x80000000) >>  (32-RRCLIP_BOTTOMBIT))|
           ((AS_INT32(z_clip)  & 0x80000000) >>  (32-RRCLIP_FRONTBIT)) |
           ((AS_INT32(xx) & 0x80000000) >>  (32-RRCLIP_RIGHTBIT))  |
           ((AS_INT32(yy) & 0x80000000) >>  (32-RRCLIP_TOPBIT))    |
           ((AS_INT32(zz) & 0x80000000) >>  (32-RRCLIP_BACKBIT));

    RRCLIPCODE clipBit = RRCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RRMAX_USER_CLIPPLANES; j++)
    {
        if( m_xfmUserClipPlanes[j].bActive )
        {
            RRVECTOR4& plane = m_xfmUserClipPlanes[j].plane;
            FLOAT fComp = 0.0f;
            if (bPointSize)
            {
                // if clipping point sprites, take the sprite size into account
                // and set the user clip bit if the sprite might be clipped
                FLOAT x_clip_size = fPointSize*0.5f*w_clip/m_ViewData.scaleX;
                FLOAT y_clip_size = fPointSize*0.5f*w_clip/m_ViewData.scaleY;
                fComp = (FLOAT)sqrt(x_clip_size*x_clip_size + y_clip_size*y_clip_size);
            }
            if( (x_clip*plane.x +
                 y_clip*plane.y +
                 z_clip*plane.z +
                 w_clip*plane.w) < fComp )
            {
                clip |= clipBit;
            }
        }
        clipBit <<= 1;
    }

    if (clip == 0)
    {
        *pclipIntersection = 0;
        return clip;
    }
    else
    {
        if (m_dwTLState & RRPV_GUARDBAND)
        {
            // We do guardband check in the projection space, so
            // we transform X and Y of the vertex there
            D3DVALUE xnew = x_clip * m_ViewData.gb11 +
                            w_clip * m_ViewData.gb41;
            D3DVALUE ynew = y_clip * m_ViewData.gb22 +
                            w_clip * m_ViewData.gb42;
            D3DVALUE xx = w_clip - xnew;
            D3DVALUE yy = w_clip - ynew;
            clip |= ((AS_INT32(xnew) & 0x80000000) >> (32-RRCLIPGB_LEFTBIT))   |
                    ((AS_INT32(ynew) & 0x80000000) >> (32-RRCLIPGB_BOTTOMBIT)) |
                    ((AS_INT32(xx)   & 0x80000000) >> (32-RRCLIPGB_RIGHTBIT))  |
                    ((AS_INT32(yy)   & 0x80000000) >> (32-RRCLIPGB_TOPBIT));
        }
        if (bPointSize)
        {
            // point sprite could still be visible
            *pclipIntersection &= (clip & ~(RRCLIP_LEFT | RRCLIP_RIGHT | RRCLIP_TOP | RRCLIP_BOTTOM |
                                   RRCLIP_USERCLIPPLANE0 | RRCLIP_USERCLIPPLANE1 | RRCLIP_USERCLIPPLANE2 |
                                   RRCLIP_USERCLIPPLANE3 | RRCLIP_USERCLIPPLANE4 | RRCLIP_USERCLIPPLANE5));
        }
        else
        {
            *pclipIntersection &= clip;
        }
        *pclipUnion |= clip;
        return clip;
    }
}

//---------------------------------------------------------------------
// RRProcessVertices::ProcessVertices
//---------------------------------------------------------------------
RRCLIPCODE
RRProcessVertices::ProcessVertices()
{
    D3DVERTEX   *pin  = (D3DVERTEX*)m_position.lpvData;
    DWORD       in_size = m_position.dwStride;
    DWORD       inFVF = m_dwFVFIn;

    D3DTLVERTEX *pout  = (D3DTLVERTEX*)m_pvOut;
    DWORD       out_size =  m_dwOutputVtxSize;
    UINT64       outFVF = m_qwFVFOut;

    RRCLIPCODE *pclip = m_pClipBuf;
    DWORD       flags = m_dwTLState;
    RRCLIPCODE  clipIntersection = ~0;
    RRCLIPCODE  clipUnion = 0;
    DWORD       count = m_dwNumVertices;
    D3DLIGHTINGELEMENT le;
    BOOL bVertexInEyeSpace = FALSE;

    //
    // Number of vertices to blend. i.e number of blend-matrices to
    // use is numVertexBlends+1.
    //
    int numVertexBlends = m_numVertexBlends;
    m_lighting.outDiffuse = RR_DEFAULT_DIFFUSE;
    m_lighting.outSpecular = RR_DEFAULT_SPECULAR;

    //
    // The main transform loop
    //
    for (DWORD i = count; i; i--)
    {
        const D3DVECTOR *pNormal = (D3DVECTOR *)((LPBYTE)pin +
                                                 m_dwNormalOffset);

        float x_clip=0.0f, y_clip=0.0f, z_clip=0.0f, w_clip=0.0f;
        float inv_w_clip=0.0f;
        float *pBlendFactors = (float *)((LPBYTE)pin + sizeof( D3DVALUE )*3);
        float cumulBlend = 0; // Blend accumulated so far
        ZeroMemory( &le, sizeof(D3DLIGHTINGELEMENT) );

        //
        // Transform vertex to the clipping space, and position and normal
        // into eye space, if needed.
        //

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }

            if (m_dwTLState & (RRPV_DOCOMPUTEPOINTSIZE|RRPV_DOPASSEYEXYZ|RRPV_DOLIGHTING))
            {
                le.dvPosition.x += (pin->x*m_xfmToEye[j]._11 +
                                    pin->y*m_xfmToEye[j]._21 +
                                    pin->z*m_xfmToEye[j]._31 +
                                    m_xfmToEye[j]._41) * blend;
                le.dvPosition.y += (pin->x*m_xfmToEye[j]._12 +
                                    pin->y*m_xfmToEye[j]._22 +
                                    pin->z*m_xfmToEye[j]._32 +
                                    m_xfmToEye[j]._42) * blend;
                le.dvPosition.z += (pin->x*m_xfmToEye[j]._13 +
                                    pin->y*m_xfmToEye[j]._23 +
                                    pin->z*m_xfmToEye[j]._33 +
                                    m_xfmToEye[j]._43) * blend;
            }

            if (m_dwTLState & (RRPV_DOPASSEYENORMAL|RRPV_DOLIGHTING))
            {
                // Transform vertex normal to the eye space
                // We use inverse transposed matrix
                le.dvNormal.x += (pNormal->x*m_xfmToEyeInv[j]._11 +
                                  pNormal->y*m_xfmToEyeInv[j]._12 +
                                  pNormal->z*m_xfmToEyeInv[j]._13) * blend;
                le.dvNormal.y += (pNormal->x*m_xfmToEyeInv[j]._21 +
                                  pNormal->y*m_xfmToEyeInv[j]._22 +
                                  pNormal->z*m_xfmToEyeInv[j]._23) * blend;
                le.dvNormal.z += (pNormal->x*m_xfmToEyeInv[j]._31 +
                                  pNormal->y*m_xfmToEyeInv[j]._32 +
                                  pNormal->z*m_xfmToEyeInv[j]._33) * blend;
            }

            // Apply WORLDj
            x_clip += (pin->x*m_xfmCurrent[j]._11 +
                pin->y*m_xfmCurrent[j]._21 +
                pin->z*m_xfmCurrent[j]._31 +
                m_xfmCurrent[j]._41) * blend;
            y_clip += (pin->x*m_xfmCurrent[j]._12 +
                pin->y*m_xfmCurrent[j]._22 +
                pin->z*m_xfmCurrent[j]._32 +
                m_xfmCurrent[j]._42) * blend;
            z_clip += (pin->x*m_xfmCurrent[j]._13 +
                pin->y*m_xfmCurrent[j]._23 +
                pin->z*m_xfmCurrent[j]._33 +
                m_xfmCurrent[j]._43) * blend;
            w_clip += (pin->x*m_xfmCurrent[j]._14 +
                pin->y*m_xfmCurrent[j]._24 +
                pin->z*m_xfmCurrent[j]._34 +
                m_xfmCurrent[j]._44) * blend;
        }

        if ((flags & RRPV_NORMALIZENORMALS) && (m_dwTLState & (RRPV_DOPASSEYENORMAL|RRPV_DOLIGHTING)))
            Normalize(le.dvNormal);

        RRFVFExtractor VtxOut( pout, outFVF, FALSE );

        FLOAT fPointSize = 0.0f;
#ifdef __POINTSPRITES
        if (m_dwTLState & RRPV_DOCOMPUTEPOINTSIZE)
        {
            FLOAT fDist = (FLOAT)sqrt(le.dvPosition.x*le.dvPosition.x + le.dvPosition.y*le.dvPosition.y +
                                      le.dvPosition.z*le.dvPosition.z);
            if (inFVF & D3DFVF_S)
            {
                RRFVFExtractor VtxIn( pin, inFVF, FALSE );
                fPointSize = VtxIn.GetS();
            }
            else
            {
                // from D3DRENDERSTATE_POINTSIZE
                fPointSize = m_fPointSize;
            }
            fPointSize = fPointSize*(FLOAT)sqrt(1.0f/
                       (m_fPointAttA + m_fPointAttB*fDist + m_fPointAttC*fDist*fDist));
            fPointSize = max(m_fPointSizeMin, fPointSize);
            fPointSize = min(RRMAX_POINT_SIZE, fPointSize);
            FLOAT *pfSOut = VtxOut.GetPtrS();
            *pfSOut = fPointSize;
        }
#endif

        if (m_dwTLState & RRPV_DOPASSEYENORMAL)
        {
            FLOAT *pfEye = VtxOut.GetPtrEyeNormal();
            pfEye[0] = le.dvNormal.x;
            pfEye[1] = le.dvNormal.y;
            pfEye[2] = le.dvNormal.z;
        }

        if (m_dwTLState & RRPV_DOPASSEYEXYZ)
        {
            FLOAT *pfEye = VtxOut.GetPtrEyeXYZ();
            pfEye[0] = le.dvPosition.x;
            pfEye[1] = le.dvPosition.y;
            pfEye[2] = le.dvPosition.z;
        }

        //
        // Compute clip codes if needed
        //
        if (m_dwTLState & RRPV_DOCLIPPING)
        {
            RRCLIPCODE clip = ComputeClipCodes(&clipIntersection, &clipUnion,
                                               x_clip, y_clip, z_clip, w_clip, fPointSize);
            if (clip == 0)
            {
                *pclip++ = 0;
                inv_w_clip = D3DVAL(1)/w_clip;
            }
            else
            {
                if (m_dwTLState & RRPV_GUARDBAND)
                {
                    if ((clip & ~RRCLIP_INGUARDBAND) == 0)
                    {
                        // If vertex is inside the guardband we have to compute
                        // screen coordinates
                        inv_w_clip = D3DVAL(1)/w_clip;
                        *pclip++ = (RRCLIPCODE)clip;
                        goto l_DoScreenCoord;
                    }
                }
                *pclip++ = (RRCLIPCODE)clip;
                // If vertex is outside the frustum we can not compute screen
                // coordinates, hence store the clip coordinates
                pout->sx = x_clip;
                pout->sy = y_clip;
                pout->sz = z_clip;
                pout->rhw = w_clip;
                goto l_DoLighting;
            }
        }
        else
        {
            // We have to check this only for DONOTCLIP case, because otherwise
            // the vertex with "we = 0" will be clipped and screen coordinates
            // will not be computed
            // "clip" is not zero, if "we" is zero.
            if (!FLOAT_EQZ(w_clip))
                inv_w_clip = D3DVAL(1)/w_clip;
            else
                inv_w_clip = __HUGE_PWR2;
        }

l_DoScreenCoord:

        pout->sx = x_clip * inv_w_clip * m_ViewData.scaleX +
            m_ViewData.offsetX;
        pout->sy = y_clip * inv_w_clip * m_ViewData.scaleY +
            m_ViewData.offsetY;
        pout->sz = z_clip * inv_w_clip * m_ViewData.scaleZ +
            m_ViewData.offsetZ;
        pout->rhw = inv_w_clip;

l_DoLighting:

        DWORD *pOut = (DWORD*)((char*)pout + 4*sizeof(D3DVALUE));


        if (flags & RRPV_DOLIGHTING)
        {
            bVertexInEyeSpace = TRUE;

            //
            // If Diffuse color is needed, extract it for color vertex.
            //
            if (flags & RRPV_VERTEXDIFFUSENEEDED)
            {
                const DWORD color = *(DWORD*)((char*)pin + m_dwDiffuseOffset);
                MakeRRCOLOR(&m_lighting.vertexDiffuse, color);
                m_lighting.vertexDiffAlpha = color & 0xff000000;
            }

            //
            // If Specular color is needed and provided
            // , extract it for color vertex.
            //
            if (flags & RRPV_VERTEXSPECULARNEEDED)
            {
                const DWORD color = *(DWORD*)((char*)pin + m_dwSpecularOffset);
                MakeRRCOLOR(&m_lighting.vertexSpecular, color);
                m_lighting.vertexSpecAlpha = color & 0xff000000;
            }

            //
            // Light the vertex
            //
            LightVertex( &le );
        }
        else if (inFVF & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR))
        {
            if (inFVF & D3DFVF_DIFFUSE)
                m_lighting.outDiffuse = *(DWORD*)((char*)pin + m_dwDiffuseOffset);
            if (inFVF & D3DFVF_SPECULAR)
                m_lighting.outSpecular = *(DWORD*)((char*)pin + m_dwSpecularOffset);
        }

        //
        // Compute Vertex Fog if needed
        //
        if (flags & RRPV_DOFOG)
        {
            FogVertex( *(D3DVECTOR*)(pin), &le,  numVertexBlends,
                       pBlendFactors, bVertexInEyeSpace );
        }

        if (outFVF & D3DFVF_DIFFUSE)
            *pOut++ = m_lighting.outDiffuse;
        if (outFVF & D3DFVF_SPECULAR)
            *pOut++ = m_lighting.outSpecular;;

        {
            memcpy(pOut, (char*)pin + m_dwTexOffset, m_dwTextureCoordSizeTotal);
        }
        pin = (D3DVERTEX*) ((char*) pin + in_size);
        pout = (D3DTLVERTEX*) ((char*) pout + out_size);
    }

    if (flags & RRPV_DOCLIPPING)
    {
        m_clipIntersection = clipIntersection;
        m_clipUnion = clipUnion;
    }
    else
    {
        m_clipIntersection = 0;
        m_clipUnion = 0;
    }

    // Returns whether all the vertices were off screen
    return m_clipIntersection;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\sources.inc ===
TARGETNAME = reftnl
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\xform.cpp    \
        ..\lighting.cpp \
        ..\clipping.cpp \
        ..\reftnl.cpp   \
        ..\procprim.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\bldlink.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8

TARGETPATH=obj
TARGETNAME=d3d8

TARGETTYPE=DYNLINK

!IF (!$(FREEBUILD))
PSGPSUFFIX=d
!ENDIF

!IFDEF D3DBBT
X3DLIB=x3dbbt.lib
KINTELLIB=ikpsgp8bbt.lib
WINTELLIB=iwpsgp8bbt.lib
!ELSE
X3DLIB=x3d$(PSGPSUFFIX).lib
KINTELLIB=ikpsgp800$(PSGPSUFFIX).lib
WINTELLIB=iwpsgp800$(PSGPSUFFIX).lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib\
        $(BASEDIR)\public\sdk\lib\*\version.lib

!IFNDEF USE_ICECAP4
!IFNDEF USE_ICECAP4_ICEPICK
!if !($(AMD64) || $(IA64))
TARGETLIBS=$(TARGETLIBS) \
           ..\..\lib\$(PLAT_DIR)\*\$(KINTELLIB) \
           ..\..\lib\$(PLAT_DIR)\*\$(WINTELLIB) \
           ..\..\lib\$(PLAT_DIR)\*\$(X3DLIB)
!endif
!ENDIF
!ENDIF

LINKER_FLAGS = $(LINKER_FLAGS) /IGNORE:4088

!ifdef DIRECTX_REDIST
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS)
!endif

LINKLIBS = \
        ..\..\util\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib           \
        ..\..\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dtnl.lib             \
        ..\..\fe\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dfe.lib               \
        ..\..\fw\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dfw.lib               \
        ..\..\shval\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dsv.lib            \
        ..\..\ref\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dref.lib             

NO_NTDLL = 1

DLLENTRY = _DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\reftnl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.cpp
//
// Direct3D Reference Transformation and Lighting  - public interface
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// RefAlignedBuffer32
///////////////////////////////////////////////////////////////////////////////
HRESULT RefAlignedBuffer32::Grow(DWORD growSize)
{
    if (m_allocatedBuf)
        free(m_allocatedBuf);
    m_size = growSize;
    if ((m_allocatedBuf = malloc(m_size + 31)) == NULL)
    {
        m_allocatedBuf = 0;
        m_alignedBuf = 0;
        m_size = 0;
        return DDERR_OUTOFMEMORY;
    }
    m_alignedBuf = (LPVOID)(((ULONG_PTR)m_allocatedBuf + 31 ) & ~31);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// RRProcessVertices::InitTL()
///////////////////////////////////////////////////////////////////////////////
void 
RRProcessVertices::InitTLData()
{
    m_LightVertexTable.pfnDirectional = RRLV_Directional;
    m_LightVertexTable.pfnParallelPoint = RRLV_Directional;
    m_LightVertexTable.pfnSpot = RRLV_PointAndSpot;
    m_LightVertexTable.pfnPoint = RRLV_PointAndSpot;
    
    //
    // Guardband parameters
    //

    // By default enable Guardband and set the extents equal 
    // to the default RefRast parameters
    m_dwTLState |= RRPV_GUARDBAND;
    m_ViewData.minXgb = (REF_GB_LEFT);
    m_ViewData.maxXgb = REF_GB_RIGHT;
    m_ViewData.minYgb = (REF_GB_TOP);
    m_ViewData.maxYgb = REF_GB_BOTTOM;
    
#if DBG
    DWORD v = 0;
    // Guardband parameters
    if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
        v != 0)
    {
        m_dwTLState &= ~RRPV_GUARDBAND;
    }
    // Try to get test values for the guard band
    char value[80];
    if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.minXgb);
    if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.maxXgb);
    if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.minYgb);
    if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
        value[0] != 0)
        sscanf(value, "%f", &m_ViewData.maxYgb);
#endif // DBG
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\ref\tnl\xform.cpp ===
#include "pch.cpp"
#pragma hdrstop


//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RRProcessVertices::UpdateXformData
//             Updates transform data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RRProcessVertices::UpdateXformData()
{
    HRESULT hr = D3D_OK;
    RRVIEWPORTDATA&  VData = m_ViewData;
    RRTRANSFORMDATA& TData = m_TransformData;


    // Update viewport information
    if (m_dwDirtyFlags & RRPV_DIRTY_ZRANGE)
    {
        VData.scaleZ  = m_Viewport.dvMaxZ - m_Viewport.dvMinZ;
        VData.offsetZ = m_Viewport.dvMinZ;
        // ATTENTION: This could be a Divide by Zero here if
        // the dvMaxZ == dvMinZ. Fix it later.
        VData.scaleZi = D3DVAL(1) / VData.scaleZ;
    }

    if (m_dwDirtyFlags & RRPV_DIRTY_VIEWRECT)
    {
        // Bail if we are going to cause any divide by zero exceptions.
        // The likely reason is that we have a bogus viewport set by
        // TLVertex execute buffer app.
        if(m_Viewport.dwWidth == 0 || m_Viewport.dwHeight == 0 )
            return DDERR_GENERIC;

        VData.dvX = D3DVAL(m_Viewport.dwX);
        VData.dvY = D3DVAL(m_Viewport.dwY);
        VData.dvWidth = D3DVAL(m_Viewport.dwWidth);
        VData.dvHeight = D3DVAL(m_Viewport.dwHeight);

        // Coefficients to compute screen coordinates from normalized window
        // coordinates
        VData.scaleX  = VData.dvWidth;
        VData.scaleY  = - VData.dvHeight;
        VData.offsetX = VData.dvX;
        VData.offsetY = VData.dvY + VData.dvHeight;

#if 0
        // Small offset is added to prevent generation of negative screen
        // coordinates (this could happen because of precision errors).
        // Not needed (or wanted) for devices which do guardband.
        VData.offsetX += SMALL_NUMBER;
        VData.offsetY += SMALL_NUMBER;
#endif

        VData.scaleXi = D3DVAL(1) / VData.scaleX;
        VData.scaleYi = D3DVAL(1) / VData.scaleY;

        VData.minX = VData.dvX;
        VData.maxX = VData.dvX + VData.dvWidth;
        VData.minY = VData.dvY;
        VData.maxY = VData.dvY + VData.dvHeight;

        if (m_dwTLState & RRPV_GUARDBAND)
        {
            // Because we clip by guard band window we have to use its extents
            D3DVALUE w = 2.0f / VData.dvWidth;
            D3DVALUE h = 2.0f / VData.dvHeight;
            D3DVALUE ax1 = -(VData.minXgb - VData.dvX) * w + 1.0f;
            D3DVALUE ax2 =  (VData.maxXgb - VData.dvX) * w - 1.0f;
            D3DVALUE ay1 =  (VData.maxYgb - VData.dvY) * h - 1.0f;
            D3DVALUE ay2 = -(VData.minYgb - VData.dvY) * h + 1.0f;
            VData.gb11 = 2.0f / (ax1 + ax2);
            VData.gb41 = VData.gb11 * (ax1 - 1.0f) * 0.5f;
            VData.gb22 = 2.0f / (ay1 + ay2);
            VData.gb42 = VData.gb22 * (ay1 - 1.0f) * 0.5f;

            VData.Kgbx1 = 0.5f * (1.0f - ax1);
            VData.Kgbx2 = 0.5f * (1.0f + ax2);
            VData.Kgby1 = 0.5f * (1.0f - ay1);
            VData.Kgby2 = 0.5f * (1.0f + ay2);
        }
        else
        {
            VData.minXgb = VData.minX;
            VData.maxXgb = VData.maxX;
            VData.minYgb = VData.minY;
            VData.maxYgb = VData.maxY;
        }
    }

    // Update Mproj*Mclip
    if( m_dwDirtyFlags &  RRPV_DIRTY_PROJXFM )
    {
        D3DMATRIX MShift;
        ZeroMemory (&MShift, sizeof(D3DMATRIX));
        MShift._11 = 0.5f;
        MShift._22 = 0.5f;
        MShift._41 = 0.5f;
        MShift._42 = 0.5f;
        MShift._44 = 1.0f;
        MShift._33 = 1.0f;

        MatrixProduct(&TData.m_PS, &m_xfmProj, &MShift);
    }

    // Update Mview*Mproj*Mclip
    if( m_dwDirtyFlags & (RRPV_DIRTY_VIEWXFM | RRPV_DIRTY_PROJXFM) )
    {
        MatrixProduct(&TData.m_VPS, &m_xfmView, &TData.m_PS);
        Inverse4x4( (D3DMATRIX *)&TData.m_VPS, (D3DMATRIX *)&TData.m_VPSInv );
    }

    for( DWORD i=0; i< RRMAX_WORLD_MATRICES; i++)
    {
        MatrixProduct(&m_xfmCurrent[i], &m_xfmWorld[i],   &TData.m_VPS);
    }

    // Compute xfmToEye (world*view) matrix (needed for lighting and fog)
    // if needed
    if (m_dwDirtyFlags & (RRPV_DIRTY_VIEWXFM  |
                          RRPV_DIRTY_WORLDXFM |
                          RRPV_DIRTY_WORLD1XFM |
                          RRPV_DIRTY_WORLD2XFM |
                          RRPV_DIRTY_WORLD3XFM ))
    {
        m_dwDirtyFlags |= RRPV_DIRTY_INVERSEWORLDVIEW;
    }
        
    if (m_dwTLState & (RRPV_DOLIGHTING | RRPV_DOFOG | RRPV_DOCOMPUTEPOINTSIZE |
                       RRPV_DOPASSEYENORMAL | RRPV_DOPASSEYEXYZ) &&
        (m_dwDirtyFlags & RRPV_DIRTY_INVERSEWORLDVIEW))
    {
        for( i=0; i< RRMAX_WORLD_MATRICES; i++)
        {
            MatrixProduct(&m_xfmToEye[i], &m_xfmWorld[i], &m_xfmView);
            Inverse4x4((D3DMATRIX *)&m_xfmToEye[i],
                       (D3DMATRIX *)&m_xfmToEyeInv[i]);
            m_dwDirtyFlags |= RRPV_DIRTY_NEEDXFMLIGHT;
        }
        m_dwDirtyFlags &= ~RRPV_DIRTY_INVERSEWORLDVIEW;
    }

    // Clear the dirty transform flags
    m_dwDirtyFlags &= ~RRPV_DIRTY_XFORM;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\d3dbase.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dbase.cpp
 *  Content:    Direct3D base device implementation
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "drawprim.hpp"
#include "vvm.h"
#include "ddi.h"

#if defined(PROFILE4)
#include <icecap.h>
#elif defined(PROFILE)
#include <icapexp.h>
#endif

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR(ptr) \
(!IsBadCodePtr((FARPROC) ptr))

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DBase                                                                //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
CD3DBase::CD3DBase()
{
    // Shaders are not re-created inside Init()
    m_pVShaderArray = NULL;
    m_pPShaderArray = NULL;

    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // DO NOT PUT INITIALIZATION IN THE CONSTRUCTOR.
    // Put it in Init() instead. This is because the device can be
    // "Destroy()ed" and "Init()ed" anytime via Reset. In this
    // situation, the constructor is never called. (snene 01/00)
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    m_qwBatch = 1; // this is ok to put here because we DONT WANT
                   // it to be reinitialized upon Reset() (snene 02/00)

#ifdef FAST_PATH
    m_pOrigVtbl = 0; // This is ok to put here since we DONT want it to
                     // be touched at Destroy()
#endif
}
//---------------------------------------------------------------------
HRESULT CD3DBase::ResetShaders()
{
    try
    {
        // Re-create vertex shaders for after DX8.0 apps only
        UINT size = m_pVShaderArray->GetSize();
        for (UINT i=0; i < size; i++)
        {
            UINT Handle = m_pVShaderArray->HandleFromIndex(i);
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(Handle);
            if (pShader)
            {
                if (Enum()->GetAppSdkVersion() != D3D_SDK_VERSION_DX8)
                {
                    CreateVertexShaderI(pShader->m_pOrgDeclaration,
                                        pShader->m_OrgDeclSize,
                                        pShader->m_pOrgFuncCode,
                                        pShader->m_OrgFuncCodeSize, 
                                        Handle);
                }
            }
        }
        
        // Re-create pixel shaders for after DX8.0 apps only
        size = m_pPShaderArray->GetSize();
        for (i=0; i < size; i++)
        {
            UINT Handle = m_pPShaderArray->HandleFromIndex(i);
            CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(Handle);
            if (pShader)
            {
                if (Enum()->GetAppSdkVersion() != D3D_SDK_VERSION_DX8)
                {
                    m_pDDI->CreatePixelShader(pShader->m_pCode, 
                                              pShader->m_dwCodeSize, Handle);
                }
            }
        }
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when resetting shaders");
        return ret;
    }
    return S_OK;
}
//---------------------------------------------------------------------

CD3DBase::~CD3DBase()
{
    // Destroy() is called during Reset() and we do not want to delete
    // shaders there

    try
    {
        delete m_pPShaderArray;
        m_pPShaderArray = NULL;
        delete m_pVShaderArray;
        m_pVShaderArray = NULL;
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when destroying device");
    }

    Destroy();
}

//---------------------------------------------------------------------
// This function can be called TWICE, so it is ESSENTIAL that all
// pointers be NULLED out and pointer dereferences be protected.
// This function is capable of cleaning up partial initialization.
void
CD3DBase::Destroy()
{
    try // Since Destroy() can be called directly by fw
    {
        // The DDI layer is about to be be deleted; so
        // we need to make sure that if Sync is called for
        // any object, we don't try to use the DDI.
        //
        // So we increment our sync counter
        // CONSIDER: should we NULL m_pDDI instead and check
        // for that in various places?
        DDASSERT(m_qwBatch > 0);
        m_qwBatch++;

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // MUST CLEANUP AND RELEASE CURRENTLY SET TEXTURES BEFORE
        // DOING ANY OTHER WORK, else we will get into situations
        // where we are calling FlushStates or batching DDI tokens.
        CleanupTextures();
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        delete m_pCreatedLights;
        m_pCreatedLights = NULL;

        // Delete state sets
        if (0 != m_pStateSets)
        {
            delete m_pStateSets;
            m_pStateSets = 0;
        }

#if DBG
        delete m_pRTPatchValidationInfo;
        m_pRTPatchValidationInfo = NULL;
#endif

        delete m_pPaletteArray;
        m_pPaletteArray = NULL;

        delete [] m_pStream;
        m_pStream = NULL; // Must NULL out
        delete m_pIndexStream;
        m_pIndexStream = NULL; // Must NULL out

        // NOTE: we must free the DDI last; because releasing Driver
        // allocated VBs causes an intrinsic call to Unlock through
        // the DDI.

        delete m_pDDI;
        m_pDDI = NULL; // Must NULL out
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when Reset()ing the device; as a result some resources may not be freed.");
    }
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CleanupTextures"

void __declspec(nothrow) CD3DBase::CleanupTextures()
{
    if(GetDDIType() < D3DDDITYPE_DX8)
    {
        // We need to unset currently set textures on DX8 drives since we have
        // seen these drivers do bad things when the TextureDestroy DDI is called.
        BOOL bNeedFlush = FALSE;
        for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
        {
            if(m_dwDDITexHandle[dwStage] != 0)
            {
                try
                {
                    m_pDDI->SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                }
                catch(HRESULT ret)
                {
                }
                m_dwDDITexHandle[dwStage] = 0;
                bNeedFlush = TRUE;
            }
        }
        // Since flush-states (or any command stream thing) can throw
        // we need to catch an error (so we can cleanup
        // properly.) This flush here is a best-effort
        // attempt for old-drivers; we don't want new drivers to rely on
        // it since it can fail for lots of reasons.
        try
        {
            if(bNeedFlush)
            {
                m_pDDI->FlushStates();
            }
        }
        catch(HRESULT ret)
        {
        }
    }

    /*
     * We need to do this backwards because we cannot have a texture bound to
     * stage i + 1 when there is a texture bound to stage i.
     */
    for (int i = D3DHAL_TSS_MAXSTAGES - 1; i >= 0; --i)
    {
        if (m_lpD3DMappedTexI[i])
        {
            m_lpD3DMappedTexI[i]->DecrementUseCount();
            m_lpD3DMappedTexI[i] = NULL; // Must NULL out
        }
    }

}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::Init"

HRESULT __declspec(nothrow)
CD3DBase::Init()
{
    HRESULT ret = S_OK;

    //
    // FE's Init
    //
    ret = InitDevice();
    if (ret!=D3D_OK)
    {
        D3D_ERR("Failed to initialize D3DDevice");
        Destroy();
        return ret;
    }

    //
    // Initialize states
    //
    try
    {
        StateInitialize(ZBuffer() != 0);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("Failed to initialize device state");
        Destroy();
        return ret;
    }
    return ret;
}

//------------------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::InitDevice"

HRESULT
CD3DBase::InitDevice()
{
    HRESULT               ret = D3D_OK;
    HKEY                  hKey = (HKEY) NULL;

    m_dwRuntimeFlags = 0;
    m_dwHintFlags = 0;
    m_pDDI = NULL;
    m_dwMaxTextureBlendStages = 0;
    m_dwStageDirty = 0;
    m_dwStreamDirty = 0;
    m_pStateSets = NULL;

    m_dwCurrentShaderHandle = 0;
    m_dwCurrentPixelShaderHandle = 0;
    m_dwNumStreams = 0;
    m_dwMaxUserClipPlanes = 0;
    m_pStream = NULL;
    m_pIndexStream = NULL;
    m_dwPalette = __INVALIDPALETTE;
    m_pPaletteArray = NULL;
#if DBG
    m_pRTPatchValidationInfo = NULL;
    m_SceneStamp = 0;
#endif
    m_pCreatedLights = NULL;

    m_pCreatedLights = new CPackedBitArray;
    if( m_pCreatedLights == NULL )
    {
        D3D_ERR("Could not allocate internal light array m_pCreatedLights");
        return E_OUTOFMEMORY;
    }

    if (FAILED(m_pCreatedLights->Init(64)))
    {
        D3D_ERR("Could not allocate internal bit vector for m_pCreatedLights");
        return E_OUTOFMEMORY;
    }
    if (m_pVShaderArray == NULL)
        m_pVShaderArray = new CVShaderHandleFactory;
    if (m_pVShaderArray == NULL)
    {
        D3D_ERR("Could not allocate internal handle factory m_pVShaderArray");
        return E_OUTOFMEMORY;
    }
    // Allocate the zero'th handle. We use the handle as a flag that no
    // shader set.
    if (__INVALIDHANDLE == m_pVShaderArray->CreateNewHandle(NULL))
    {
        D3D_ERR("Vertex shader Zero'th handle allocation failed");
        return E_OUTOFMEMORY;
    }

    if (m_pPShaderArray == NULL)
        m_pPShaderArray = new CHandleFactory;
    if (m_pPShaderArray == NULL)
    {
        D3D_ERR("Could not allocate internal handle factory m_pPShaderArray");
        return E_OUTOFMEMORY;
    }
    // Allocate the zero'th handle. We use the handle as a flag that no
    // shader set.
    if (__INVALIDHANDLE == m_pPShaderArray->CreateNewHandle(NULL))
    {
        D3D_ERR("Pixel shader Zero'th handle allocation failed");
        return E_OUTOFMEMORY;
    }

    m_pPaletteArray = new CHandleArray;
    if (m_pPaletteArray == NULL)
    {
        D3D_ERR("Could not allocate internal handle array m_pPaletteArray");
        return E_OUTOFMEMORY;
    }

#if DBG
    m_pRTPatchValidationInfo = new CHandleArray;
    if (m_pRTPatchValidationInfo == NULL)
    {
        D3D_ERR("Could not allocate internal handle array m_pRTPatchValidationInfo");
        return E_OUTOFMEMORY;
    }
#endif

    m_MaxVertexShaderConst = GetD3DCaps()->MaxVertexShaderConst;

    DWORD value;
    if ((GetD3DRegValue(REG_DWORD, "DisableNVPS", &value, 4) &&
        value != 0))
    {
        m_dwRuntimeFlags |= D3DRT_DISALLOWNVPSHADERS;
    }

    // Figure out the DDI type of the underlying driver

    //---------------------------------------------------------------------
    // HKEY_LOCAL_MACHINE\Software\Microsoft\Direct3D\DriverStyle
    // In DX7 this registry key replaces the host of keys we had before like
    // DisableDP, DisableDP2 etc. This stuff is for testing purpose only.
    // It is more like a hint, in that, if the requested driver type is
    // available, it is used otherwise the latest available driver is used
    // The following is the meanings for this dword:
    //
    // Value:                    Driver-type:
    //       0x0                           Latest available
    //       0x3                           (DX6)
    //       0x4                           (DX7)
    //       0x5                           (DX7+TL)
    //       0x6                           (DX8)
    //       0x7                           (DX8+TL)
    //
    // The following are the various cases we need to consider:
    // 1) NT Hardware: 4 and above are legal
    // 2) W9x Hardware: 3 and above are legal
    // 3) Reference: 4 and above
    //---------------------------------------------------------------------

    WORD wDriverCaps = 0;
    D3DDDITYPE LatestDDI = D3DDDITYPE_NULL;
    //
    // 1) Determine what styles of DDIs the driver is capable of
    //

    // DX6 ?
    if (GetHalCallbacks()->DrawPrimitives2 != 0)
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX6);
        LatestDDI = D3DDDITYPE_DX6;
    }

    // DX7 ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX6)) &&
        (GetHalCallbacks()->GetDriverState != 0))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX7);
        LatestDDI = D3DDDITYPE_DX7;
    }

    // DX7&TL ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX7)) &&
        (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX7TL);
        LatestDDI = D3DDDITYPE_DX7TL;
    }

    // DX8 ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX7)) &&
        (GetD3DCaps()->MaxStreams != 0))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX8);
        LatestDDI = D3DDDITYPE_DX8;
    }

    // DX8&TL ?
    if ((wDriverCaps & (1 << D3DDDITYPE_DX8)) &&
         (GetD3DCaps()->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT))
    {
        wDriverCaps |= (1 << D3DDDITYPE_DX8TL);
        LatestDDI = D3DDDITYPE_DX8TL;
    }

    //
    // 2) Verify if the requested driver is supported
    //
    if (wDriverCaps == 0)
    {
        m_ddiType = D3DDDITYPE_NULL;   // nothing supported so fail
    }
    else
    {
        // use the latest available if not specified or
        // incorrectly specified or specified but not available
        m_ddiType = LatestDDI;
    }
    D3D_INFO(1,"HalDevice Driver Style %x", GetDDIType());

    // Pure device is available only for DX8+ drivers only (check for cap)
    if ( (BehaviorFlags() & D3DCREATE_PUREDEVICE) &&
         !(GetD3DCaps()->DevCaps & D3DDEVCAPS_PUREDEVICE) )
    {
        DPF_ERR("No PUREDEVICE support available on this driver");
        return E_NOTIMPL;
    }

#ifdef _IA64_
    if (GetDDIType() < D3DDDITYPE_DX8)
    {
        D3D_ERR( "Pre-DX8 drivers are not supported in IA64" );
        return E_FAIL;
    }
#endif // _IA64_

    // Now create the DDI object
    // Note: If m_dwDriverStyle == 0x0 here, driver creation will fail
    // Something must have been chosen by now
    switch (GetDDIType())
    {
    case D3DDDITYPE_DX6:
        m_pDDI = new CD3DDDIDX6();
        break;
    case D3DDDITYPE_DX7:
        m_pDDI = new CD3DDDIDX7();
        break;
    case D3DDDITYPE_DX7TL:
        m_pDDI = new CD3DDDITL();
        break;
    case D3DDDITYPE_DX8:
        m_pDDI = new CD3DDDIDX8();
        break;
    case D3DDDITYPE_DX8TL:
        m_pDDI = new CD3DDDIDX8TL();
        break;
    default:
        D3D_ERR("The currently requested/installed driver is not supported.");
        // Change this return value ?
        return (E_OUTOFMEMORY);
    }

    if( m_pDDI == NULL )
    {
        D3D_ERR( "Could not allocate internal driver interface object" );
        return E_OUTOFMEMORY;
    }

    // Now try to initialize the ddi object
    try
    {
        m_pDDI->Init(this);
        m_pfnDrawPrim = m_pDDI->GetDrawPrimFunction();
        m_pfnDrawIndexedPrim = m_pDDI->GetDrawIndexedPrimFunction();
        m_pfnDrawPrimFromNPatch = m_pDDI->GetDrawPrimFunction();
        m_pfnDrawIndexedPrimFromNPatch = m_pDDI->GetDrawIndexedPrimFunction();
    }
    catch(HRESULT hr)
    {
        return hr;
    }

    // Initialize some caps for the Software Vertex Processing
    m_dwNumStreams = max(1, GetD3DCaps()->MaxStreams);
    m_dwMaxUserClipPlanes = GetD3DCaps()->MaxUserClipPlanes;

#ifdef _X86_
    if (!(BehaviorFlags() & D3DCREATE_FPU_PRESERVE))
    {
        m_dwHintFlags |= D3DDEVBOOL_HINTFLAGS_FPUSETUP;
        WORD wSave, wTemp;
        __asm {
            fstcw wSave
            mov ax, wSave
            and ax, not 300h    ;; single mode
            or  ax, 3fh         ;; disable all exceptions
            and ax, not 0C00h   ;; round to nearest mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#endif

#ifdef FAST_PATH
    if(m_pOrigVtbl == 0)
    {
        m_pOrigVtbl = *((VOID***)this);
        memcpy(m_pVtbl, m_pOrigVtbl, sizeof(VOID*) * NUMVTBLENTRIES);
        *((VOID***)this) = m_pVtbl;
    }

    FastPathSetRenderStateExecute();
    FastPathSetTextureStageStateExecute();
    FastPathApplyStateBlockExecute();
    FastPathSetTextureExecute();
    FastPathSetMaterialExecute();
    FastPathSetVertexShaderFast();
    FastPathSetStreamSourceFast();
    FastPathSetIndicesFast();
    FastPathSetTransformExecute();
    FastPathMultiplyTransformExecute();
    FastPathSetPixelShaderExecute();
    FastPathSetPixelShaderConstantExecute();
    FastPathSetVertexShaderConstantExecute();
#endif

    // Setup the viewport
    D3DSURFACE_DESC d3ddesc = RenderTarget()->InternalGetDesc();
    D3DVIEWPORT8 Viewport;
    Viewport.X = 0;
    Viewport.Y = 0;
    Viewport.Width  = d3ddesc.Width;
    Viewport.Height = d3ddesc.Height;
    Viewport.MinZ = (D3DVALUE)0;
    Viewport.MaxZ = (D3DVALUE)1;
    if (FAILED(ret = this->SetViewport(&Viewport)))
    {
        return ret;
    }

    m_pStream = new CVStream[__NUMSTREAMS];
    if( m_pStream == NULL )
    {
        return E_OUTOFMEMORY;
    }

    for (UINT i=0; i < __NUMSTREAMS; i++)
    {
        m_pStream[i].m_dwIndex = i;
    }
    m_pIndexStream = new CVIndexStream;
    if( m_pIndexStream == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Initialize the caps
    //
    const D3DCAPS8 *pCaps = GetD3DCaps();
    DDASSERT( pCaps );

    if (pCaps && pCaps->FVFCaps)
    {
        m_dwMaxTextureBlendStages = pCaps->MaxTextureBlendStages;
    }

    // Setup Statesets
    m_pStateSets = new CStateSets;
    if (m_pStateSets == NULL)
    {
        return E_OUTOFMEMORY;
    }
    m_pStateSets->Init(this);

#if defined(PROFILE4) || defined(PROFILE)
    m_dwProfStart = m_dwProfStop = 0;
    GetD3DRegValue(REG_DWORD, "ProfileStartFrame", &m_dwProfStart, 4);
    GetD3DRegValue(REG_DWORD, "ProfileStopFrame", &m_dwProfStop, 4);
#endif

    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::TextureManagerDiscardBytes"

HRESULT D3DAPI
CD3DBase::ResourceManagerDiscardBytes(DWORD cbBytes)
{
    API_ENTER(this);

    // For driver-management we pass the number of
    // bytes needed down through this renderstate. For DX7
    // we passed the value "1" which mean EvictAll. Now
    // if the app specifices 0 for cbBytes, that means EvictAll.
    // So this should make it easy for drivers to support both
    // dx7 and dx8+ uses of this renderstate.
    if (CanDriverManageResource())
    {
        try
        {
            m_pDDI->SetRenderState((D3DRENDERSTATETYPE)D3DRENDERSTATE_EVICTMANAGEDTEXTURES,
                                   cbBytes + 1);
            m_pDDI->FlushStates();
        }
        catch (HRESULT ret)
        {
            DPF_ERR("ResourceManagerDiscardBytes failed.");
            return ret;
        }
    }
    else
    {
        ResourceManager()->DiscardBytes(cbBytes);
    }

    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ValidateDevice"

HRESULT D3DAPI
CD3DBase::ValidateDevice(LPDWORD lpdwNumPasses)
{
    API_ENTER(this); // Takes D3D Lock if necessary
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(lpdwNumPasses, sizeof(DWORD)))
    {
        D3D_ERR("Invalid NumPasses pointer passed. ValidateDevice failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    try
    {
        m_pDDI->ValidateDevice(lpdwNumPasses);
    }
    catch(HRESULT hr)
    {
        D3D_INFO(0, "ValidateDevice failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::BeginScene"

HRESULT D3DAPI
CD3DBase::BeginScene()
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if defined(PROFILE4) || defined(PROFILE)
    static DWORD dwFrameCount = 0;
#endif
    try
    {
        if (m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
        {
            D3D_ERR("BeginScene, already in scene. BeginScene failed.");
            return (D3DERR_INVALIDCALL);
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot be recording state macros when calling BeginScene. BeginScene failed.");
            throw (D3DERR_INVALIDCALL);
        }

        m_pDDI->BeginScene();

#if defined(PROFILE4)
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 8.0: Started Profiling...\n");
            StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
            OutputDebugString("Direct3D IM 8.0: Stopped Profiling.\n");
        }
#elif defined(PROFILE)
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 8.0: Started Profiling...\n");
            StartCAP();
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopCAP();
            OutputDebugString("Direct3D IM 8.0: Stopped Profiling.\n");
        }
#endif

        // So that currently bound textures get scene stamped
        m_dwStageDirty = (1ul << m_dwMaxTextureBlendStages) - 1ul;
        m_dwStreamDirty = (((1ul << m_dwNumStreams) - 1ul) | (1 << __NUMSTREAMS));
        m_dwRuntimeFlags |= (D3DRT_NEED_TEXTURE_UPDATE | D3DRT_NEED_VB_UPDATE);
        m_dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INSCENE;
        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        DPF_ERR("BeginScene failed.");
        return ret;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::EndScene"

HRESULT D3DAPI
CD3DBase::EndScene()
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (!(m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
        {
            D3D_ERR("EndScene, not in scene. EndScene failed.");
            return (D3DERR_INVALIDCALL);
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot be recording state macros when calling EndScene. EndScene failed.");
            throw (D3DERR_INVALIDCALL);
        }

        m_dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INSCENE;

        m_pDDI->EndScene();

        // Update the scene count in texman
        ResourceManager()->SceneStamp();

#if DBG
        ++m_SceneStamp;
#endif

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        DPF_ERR("EndScene failed.");
        return ret;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::MultiplyTransformI"

void
CD3DBase::MultiplyTransformI(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    m_pDDI->MultiplyTransform(state, lpMat);
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::MultiplyTransformFast"

HRESULT D3DAPI
CD3DBase::MultiplyTransformFast(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to MultiplyTransform. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DXGASSERT((m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE) == 0 &&
              (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
              (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0);
    try
    {
        m_pDDI->MultiplyTransform(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("MultiplyTransform failed.");
        return ret;
    }

    return D3D_OK;
}
#endif
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::MultiplyTransform"

HRESULT D3DAPI
CD3DBase::MultiplyTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    API_ENTER(this);
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to MultiplyTransform. MultiplyTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        MultiplyTransformI(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("MultiplyTransform failed.");
        return ret;
    }
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTransformI"

void CD3DBase::SetTransformI(D3DTRANSFORMSTATETYPE state,
                             CONST D3DMATRIX* lpMat)
{
    if( state == D3DTS_PROJECTION )
        m_pDDI->UpdateWInfo( lpMat );
    m_pDDI->SetTransform(state, lpMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTransform"

HRESULT D3DAPI
CD3DBase::SetTransform(D3DTRANSFORMSTATETYPE state,
                       CONST D3DMATRIX* lpMat)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to SetTransform. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertTransform(state, lpMat);
        else
            SetTransformI(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTransform failed.");
        return ret;
    }
    return D3D_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTransformFast"

HRESULT D3DAPI
CD3DBase::SetTransformFast(D3DTRANSFORMSTATETYPE state,
                           CONST D3DMATRIX* lpMat)
{
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR("Invalid matrix pointer. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
    {
    }
    else
    switch (state)
    {
    case D3DTS_VIEW :
    case D3DTS_PROJECTION :
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        break;
    default :
        D3D_ERR("Invalid state value passed to SetTransform. SetTransform failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DXGASSERT((m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE) == 0 &&
              (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
              (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0);
    try
    {
        m_pDDI->SetTransform(state, lpMat);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTransform failed.");
        return ret;
    }
    return S_OK;
}
#endif // FAST_PATH
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderTarget"

HRESULT D3DAPI
CD3DBase::SetRenderTarget(IDirect3DSurface8 *pRenderTarget,
                          IDirect3DSurface8 *pZStencil)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        CBaseSurface *pTarget;
        CBaseSurface *pZ;

        if (pRenderTarget != NULL)
        {
            if (!VALID_D3D_DIRECTDRAWSURFACE8_PTR(pRenderTarget))
            {
                D3D_ERR("Invalid IDirect3DSurface8 pointer passed for RenderTarget. SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }
            pTarget = static_cast<CBaseSurface*>(pRenderTarget);
            if (pTarget->InternalGetDevice() != this)
            {
                D3D_ERR("Render Target wasn't created with this Device. SetRenderTarget fails");
                return D3DERR_INVALIDCALL;
            }

            D3DSURFACE_DESC desc = pTarget->InternalGetDesc();

            if ((desc.Usage & D3DUSAGE_RENDERTARGET) == 0)
            {
                D3D_ERR("**** The D3DUSAGE_RENDERTARGET is not set on this surface.");
                D3D_ERR("**** You need to add D3DUSAGE_RENDERTARGET to the Usage parameter");
                D3D_ERR("**** when creating the surface. SetRenderTarget failed.");
                return (D3DERR_INVALIDCALL);
            }

        }
        else
        {
            pTarget = RenderTarget();
        }

        if (pZStencil != NULL)
        {
            if (!VALID_D3D_DIRECTDRAWSURFACE8_PTR(pZStencil))
            {
                D3D_ERR("Invalid IDirect3DSurface8 pointer passed for ZStencil.  SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }
            pZ = static_cast<CBaseSurface*>(pZStencil);
            if (pZ->InternalGetDevice() != this)
            {
                D3D_ERR("Zbuffer wasn't created with this Device. SetRenderTarget fails");
                return D3DERR_INVALIDCALL;
            }

            // We call the external interface because
            // we need to get the Z format that the user
            // specified NOT our internal mapping.
            D3DSURFACE_DESC descZ;
            pZ->GetDesc(&descZ);

            if ((descZ.Usage & D3DUSAGE_DEPTHSTENCIL) == 0)
            {
                D3D_ERR("**** The D3DUSAGE_DEPTHSTENCIL is not set on this surface.");
                D3D_ERR("**** You need to add D3DUSAGE_DEPTHSTENCIL to the Usage parameter");
                D3D_ERR("**** when creating the surface. SetRenderTarget failed.");
                return (D3DERR_INVALIDCALL);
            }

            // Check that RT and Z have matching Multi-Sampleness

            DXGASSERT(pTarget != NULL);
            D3DSURFACE_DESC descTarget = pTarget->InternalGetDesc();

            if (descZ.MultiSampleType != descTarget.MultiSampleType)
            {
                DPF_ERR("MultiSampleType between DepthStencil Buffer and RenderTarget must match. SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }

            // Ensure that the ZBuffer that is being set is atleast as big as the RenderTarget
            if ((descZ.Width < descTarget.Width) ||
                (descZ.Height < descTarget.Height))
            {
                DPF_ERR("DepthStencil Buffer must be atleast as big as the RenderTarget. SetRenderTarget failed.");
                return D3DERR_INVALIDCALL;
            }

            // Need to check whether formats are compatible if
            // the format is the lockable D16 or has Stencil
            if (descZ.Format == D3DFMT_D16_LOCKABLE ||
                CPixel::HasStencilBits(descZ.Format))
            {
                HRESULT hr = CheckDepthStencilMatch(descTarget.Format, descZ.Format);
                if (FAILED(hr))
                {
                    DPF_ERR("SetRenderTarget failed; Z Buffer is incompatible with Render Target. See CheckDepthStencilMatch documentation.");
                    if (descZ.Format == D3DFMT_D16_LOCKABLE)
                    {
                        DPF_ERR("If you don't need to lock the z-buffer, then you should use D3DFMT_D16 instead of D3DFMT_D16_LOCKABLE");
                    }

                    return D3DERR_INVALIDCALL;
                }
            }

        }
        else
        {
            pZ = NULL;
        }

        HRESULT hr = SetRenderTargetI(pTarget, pZ);
        if( FAILED(hr) )
        {
            DPF_ERR("SetRenderTargetI failed because the driver failed a command a batch");
            return hr;
        }

        // Set the viewport to default to the whole render-target
        D3DVIEWPORT8 vp;
        D3DSURFACE_DESC desc = pTarget->InternalGetDesc();
        vp.X      = 0;
        vp.Y      = 0;
        vp.Width  = desc.Width;
        vp.Height = desc.Height;
        vp.MinZ   = 0.0f;
        vp.MaxZ   = 1.0f;
        SetViewportI( &vp );
    }
    catch (HRESULT ret)
    {
        DPF_ERR("SetRenderTarget failed.");
        return ret;
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderTargetI"

HRESULT __declspec(nothrow)
CD3DBase::SetRenderTargetI( CBaseSurface* pTarget,
                            CBaseSurface* pZ )
{
    try
    {
        m_pDDI->SetRenderTarget(pTarget, pZ);
        UpdateRenderTarget(pTarget, pZ);

        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetRenderTarget"

HRESULT D3DAPI
CD3DBase::GetRenderTarget(LPDIRECT3DSURFACE8* lplpDDS)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_OUTPTR(lplpDDS))
    {
        D3D_ERR("Invalid ptr to IDirect3DSurface8*. GetRenderTarget failed.");
        return D3DERR_INVALIDCALL;
    }

    *lplpDDS = this->RenderTarget();

    this->RenderTarget()->AddRef();
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetZStencilSurface"

HRESULT D3DAPI
CD3DBase::GetDepthStencilSurface(LPDIRECT3DSURFACE8* lplpDDS)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_OUTPTR(lplpDDS))
    {
        D3D_ERR("Invalid ptr to IDirect3DSurface8*. GetDepthStencilSurface failed.");
        return D3DERR_INVALIDCALL;
    }

    *lplpDDS = this->ZBuffer();

    if (*lplpDDS)
    {
        (*lplpDDS)->AddRef();
        return S_OK;
    }
    else
    {
        D3D_INFO(0, "Device doesn't have a Z Buffer.");
        return D3DERR_NOTFOUND;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetViewport"

HRESULT D3DAPI
CD3DBase::SetViewport(CONST D3DVIEWPORT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid viewport pointer. SetViewport failed.");
        return D3DERR_INVALIDCALL;
    }
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertViewport(lpData);
        else
            SetViewportI(lpData);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetViewport failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetViewportI"

void CD3DBase::SetViewportI(CONST D3DVIEWPORT8* lpData)
{
#if DBG
    CheckViewport(lpData);
#endif
    m_pDDI->SetViewport(lpData);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetMaterial"

HRESULT D3DAPI
CD3DBase::SetMaterial(CONST D3DMATERIAL8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid D3DMATERIAL pointer. SetMaterial failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertMaterial(lpData);
        else
            this->SetMaterialFast(lpData);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetMaterial failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetMaterialFast"

HRESULT D3DAPI
CD3DBase::SetMaterialFast(CONST D3DMATERIAL8* lpData)
{
#if DBG
    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid D3DMATERIAL pointer. SetMaterial failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        m_pDDI->SetMaterial(lpData);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetMaterial failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetLight"

extern void CheckLightParams(CONST D3DLIGHT8* lpData);

HRESULT D3DAPI
CD3DBase::SetLight(DWORD dwLightIndex,
                   CONST D3DLIGHT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer. SetLight failed." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
#if DBG
        CheckLightParams(lpData);
#endif // DBG

        // If new index greater than allocated array - re-allocate the array
        if (dwLightIndex >= m_pCreatedLights->GetSize())
            m_pCreatedLights->Init(dwLightIndex + 32);

        // If the light if not already created, send command to the DDI to
        // create it.
        if (!m_pCreatedLights->IsBitSet(dwLightIndex))
        {
            m_pDDI->CreateLight(dwLightIndex);
            m_pCreatedLights->SetBit(dwLightIndex);

            // If we are in the record mode, we need to create the light object.
            // Otherwise, if we access the light during capture, we will have
            // access violation.
            if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            {
                // Set default value to the light
                D3DLIGHT8 light;
                memset(&light, 0, sizeof(light));
                light.Type = D3DLIGHT_DIRECTIONAL;
                light.Direction.x = D3DVAL(0);
                light.Direction.y = D3DVAL(0);
                light.Direction.z = D3DVAL(1);
                light.Diffuse.r = D3DVAL(1);
                light.Diffuse.g = D3DVAL(1);
                light.Diffuse.b = D3DVAL(1);

                this->SetLightI(dwLightIndex, &light);
            }
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertLight(dwLightIndex, lpData);
        else
            this->SetLightI(dwLightIndex, lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("SetLight failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetLightI"

void
CD3DBase::SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8* lpData)
{
    m_pDDI->SetLight(dwLightIndex, lpData);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::LightEnableI"

void
CD3DBase::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    m_pDDI->LightEnable(dwLightIndex, bEnable);
}
//---------------------------------------------------------------------
BOOL ValidateRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0)
    {
        D3D_ERR("Invalid render state type. SetRenderState failed.");
        return FALSE;
    }
    switch (dwState)
    {
    case D3DRS_POSITIONORDER:
        if (!((value == D3DORDER_LINEAR) || (value == D3DORDER_CUBIC)))
        {
            D3D_ERR("D3DRS_POSITIONORDER should be D3DORDER_LINEAR or D3DORDER_CUBIC");
            return FALSE;
        }
        break;
    case D3DRS_NORMALORDER:
        if (!((value == D3DORDER_LINEAR) || (value == D3DORDER_QUADRATIC)))
        {
            D3D_ERR("D3DRS_NORMALORDER should be D3DORDER_LINEAR or D3DORDER_QUADRATIC");
            return FALSE;
        }
        break;
    }
    return TRUE;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderState"

HRESULT D3DAPI
CD3DBase::SetRenderState(D3DRENDERSTATETYPE dwState,
                         DWORD value)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!ValidateRenderState(dwState, value))
        return D3DERR_INVALIDCALL;
#endif

    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertRenderState(dwState, value,
                                            CanHandleRenderState(dwState));
        else
            m_pDDI->SetRenderState(dwState, value);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetRenderState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderStateFast"

HRESULT D3DAPI CD3DBase::SetRenderStateFast(D3DRENDERSTATETYPE dwState,
                                            DWORD value)
{

#if DBG
    if (!ValidateRenderState(dwState, value))
        return D3DERR_INVALIDCALL;
#endif

    DXGASSERT((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    try
    {
        m_pDDI->SetRenderState(dwState, value);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetRenderState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetClipStatus"

HRESULT D3DAPI
CD3DBase::SetClipStatus(CONST D3DCLIPSTATUS8* lpStatus)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    D3D_ERR("SetClipStatus is not available for D3DCREATE_PUREDEVICE. SetClipStatus failed.");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetClipStatus"

HRESULT D3DAPI
CD3DBase::GetClipStatus(D3DCLIPSTATUS8* lpStatus)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    D3D_ERR("GetClipStatus is not available for D3DCREATE_PUREDEVICE. GetClipStatus failed.");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ProcessVertices"

HRESULT D3DAPI
CD3DBase::ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount,
                          IDirect3DVertexBuffer8 *pDestBuffer,
                          DWORD Flags)
{
    API_ENTER(this); // Takes D3D Lock if necessary
    if (pDestBuffer == NULL)
    {
        D3D_ERR("Invalid vertex buffer pointer. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pDestBuffer);
    if (pVB->Device() != this)
    {
        D3D_ERR("VertexBuffer not created with this device. Process Vertices failed.");
        return D3DERR_INVALIDCALL;
    }

    D3D_ERR("ProcessVertices is not available for a PUREDEVICE. ProcessVertices failed.");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTexture"

HRESULT D3DAPI
CD3DBase::SetTexture(DWORD                  dwStage,
                     IDirect3DBaseTexture8 *lpTex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {

#if DBG
        HRESULT ret = VerifyTexture(dwStage, lpTex);
        if (ret != D3D_OK)
            return ret;
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTexture(dwStage, lpTex);
            return D3D_OK;
        }

        return SetTextureFast(dwStage, lpTex);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTexture failed.");
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::VerifyTexture"
HRESULT
CD3DBase::VerifyTexture(DWORD                    dwStage,
                        IDirect3DBaseTexture8   *lpTex)
{
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR("Invalid texture stage or state index. SetTexture failed.");
        return D3DERR_INVALIDCALL;
    }

    if (lpTex)
    {
        if (!VALID_DIRECT3DBASETEXTURE8_PTR(lpTex))
        {
            D3D_ERR("Invalid texture pointer. SetTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        CBaseTexture *pTex = CBaseTexture::SafeCast(lpTex);
        if (pTex->Device() != this)
        {
            D3D_ERR("Texture not created with this device. SetTexture failed.");
            return D3DERR_INVALIDCALL;
        }

        if (pTex->GetUserPool() == D3DPOOL_SYSTEMMEM)
        {
            if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY) == 0)
            {
                D3D_ERR("Device cannot render using texture surface from system memory. SetTexture failed.");
                return D3DERR_INVALIDCALL;
            }
        }
        if (pTex->GetUserPool() == D3DPOOL_SCRATCH)
        {
            D3D_ERR("D3DPOOL_SCRATCH resources cannot be passed to SetTexture. SetTexture fails.");
            return D3DERR_INVALIDCALL;
        }

    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTextureFast"

HRESULT D3DAPI
CD3DBase::SetTextureFast(DWORD                   dwStage,
                         IDirect3DBaseTexture8  *lpTex)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
#if DBG
    HRESULT ret = VerifyTexture(dwStage, lpTex);
    if (ret != D3D_OK)
        return ret;
#endif

    CBaseTexture *lpTexI = CBaseTexture::SafeCast(lpTex);

    if (m_lpD3DMappedTexI[dwStage] == lpTexI)
    {
        return  D3D_OK;
    }

    if (m_lpD3DMappedTexI[dwStage])
    {
        m_lpD3DMappedTexI[dwStage]->DecrementUseCount();
    }

    m_lpD3DMappedTexI[dwStage] = lpTexI;

    if (lpTexI)
    {
        lpTexI->IncrementUseCount();
    }

    m_dwStageDirty |= (1 << dwStage);

    // Need to call UpdateTextures()
    m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;

    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetTexture"

HRESULT D3DAPI
CD3DBase::GetTexture(DWORD dwStage,
                     IDirect3DBaseTexture8 **lplpTex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR("Invalid texture stage or state index. GetTexture failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    if (!VALID_WRITEPTR(lplpTex, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid pointer to IDirect3DBaseTexture8*. GetTexture failed.");
        return D3DERR_INVALIDCALL;
    }

    if (m_lpD3DMappedTexI[dwStage])
    {
        switch(m_lpD3DMappedTexI[dwStage]->GetBufferDesc()->Type)
        {
        case D3DRTYPE_TEXTURE:
            *lplpTex = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(m_lpD3DMappedTexI[dwStage]));
            break;
        case D3DRTYPE_CUBETEXTURE:
            *lplpTex = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(m_lpD3DMappedTexI[dwStage]));
            break;
        case D3DRTYPE_VOLUMETEXTURE:
            *lplpTex = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(m_lpD3DMappedTexI[dwStage]));
            break;
        }
        (*lplpTex)->AddRef();
    }
    else
    {
        *lplpTex = NULL;
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTextureStageState"

HRESULT D3DAPI
CD3DBase::SetTextureStageState(DWORD dwStage,
                               D3DTEXTURESTAGESTATETYPE dwState,
                               DWORD dwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR("Invalid texture stage or state index. SetTextureStageState failed.");
        return D3DERR_INVALIDCALL;
    }
#endif //DBG
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertTextureStageState(dwStage, dwState, dwValue);
        else
            m_pDDI->SetTSS(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTextureStageState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTextureStageStateFast"

HRESULT D3DAPI
CD3DBase::SetTextureStageStateFast(DWORD dwStage,
                                   D3DTEXTURESTAGESTATETYPE dwState,
                                   DWORD dwValue)
{
#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR("Invalid texture stage or state index. SetTextureStageState failed.");
        return D3DERR_INVALIDCALL;
    }
#endif //DBG

    DXGASSERT((BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    try
    {
        m_pDDI->SetTSS(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetTextureStageState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::LightEnable"

HRESULT D3DAPI
CD3DBase::LightEnable(DWORD dwLightIndex,
                      BOOL bEnable)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        // If light was never created, we create a default light
        if (dwLightIndex >= m_pCreatedLights->GetSize() ||
            !m_pCreatedLights->IsBitSet(dwLightIndex))
        {
            // Set default value to the light
            D3DLIGHT8 light;
            memset(&light, 0, sizeof(light));
            light.Type = D3DLIGHT_DIRECTIONAL;
            light.Direction.x = D3DVAL(0);
            light.Direction.y = D3DVAL(0);
            light.Direction.z = D3DVAL(1);
            light.Diffuse.r = D3DVAL(1);
            light.Diffuse.g = D3DVAL(1);
            light.Diffuse.b = D3DVAL(1);

            // When a new light is created we need to actually create it even
            // in the record mode. So we clear record flag, create light and
            // restore the flag.
            DWORD OldBit = m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE;
            m_dwRuntimeFlags &= ~D3DRT_RECORDSTATEMODE;

            HRESULT ret = SetLight(dwLightIndex, &light);

            m_dwRuntimeFlags |= OldBit;

            if (ret != S_OK)
                return ret;
        }

        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertLightEnable(dwLightIndex, bEnable);
        else
            LightEnableI(dwLightIndex, bEnable);
    }
    catch (HRESULT ret)
    {
        DPF_ERR("LightEnable failed.");
        return ret;
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetInfo"

HRESULT D3DAPI
CD3DBase::GetInfo(DWORD dwDevInfoID,
                  LPVOID pDevInfoStruct,
                  DWORD dwSize)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (dwSize == 0 || !VALID_D3DDEVINFOSTRUCT_PTR(pDevInfoStruct, dwSize))
    {
        D3D_ERR("Invalid structure pointer or size. GetInfo failed.");
        return D3DERR_INVALIDCALL;
    }
    memset(pDevInfoStruct, 0, dwSize);
    if (dwDevInfoID < D3DDEVINFOID_VCACHE)
    {
        D3D_ERR("DX7 DevInfo IDs not supported in DX8. GetInfo failed.");
        return E_FAIL;
    }
#if DBG
    if (m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        DPF(2, "GetInfo called within a scene");
    }
#endif
    try
    {
        if( !IS_DX7HAL_DEVICE(this) )  // must be at least DX7
        {
            DPF( 1, "Device information query unsupported" );
            return E_FAIL;
        }

        m_pDDI->FlushStates();
    }
    catch(HRESULT hr)
    {
        DPF_ERR("GetInfo failed.");
        return hr;
    }

    D3D8_GETDRIVERSTATEDATA dsd;
    dsd.dwFlags = dwDevInfoID;
    dsd.dwhContext = m_pDDI->GetDeviceContext();
    dsd.lpdwStates = (LPDWORD)pDevInfoStruct;
    dsd.dwLength = dwSize;

    HRESULT hr;
    hr = GetHalCallbacks()->GetDriverState(&dsd);
    if (hr != DDHAL_DRIVER_HANDLED)
    {
        DPF( 1, "Device information query unsupported" );
        memset(pDevInfoStruct, 0, dwSize);
        return S_FALSE;
    }
    else if (dsd.ddRVal != DD_OK)
    {
        D3D_ERR("Driver failed query. GetInfo failed.");
        memset(pDevInfoStruct, 0, dwSize);
        return E_FAIL;
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetCurrentTexturePalette"

HRESULT D3DAPI
CD3DBase::SetCurrentTexturePalette(UINT PaletteNumber)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertCurrentTexturePalette(PaletteNumber);
        }
        else
        {
#if DBG
            if (PaletteNumber >= m_pPaletteArray->GetSize())
            {
                D3D_ERR("Palette not defined. SetCurrentTexturePalette failed.");
                return D3DERR_INVALIDCALL;
            }
#endif
            if(PaletteNumber != m_dwPalette)
            {
                m_dwPalette = PaletteNumber;

                // Need to call UpdateTextures()
                m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;
            }
        }
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetCurrentTexturePalette failed.");
        return ret;
    }

    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetCurrentTexturePalette"

HRESULT D3DAPI
CD3DBase::GetCurrentTexturePalette(UINT *PaletteNumber)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(PaletteNumber, sizeof(UINT)))
    {
        D3D_ERR("Invalid PaletteNumber pointer. GetCurrentTexturePalette failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    *PaletteNumber = m_dwPalette;

    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPaletteEntries"

HRESULT D3DAPI
CD3DBase::SetPaletteEntries(UINT PaletteNumber, CONST PALETTEENTRY *pEntries)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(pEntries, sizeof(PALETTEENTRY) * 256))
    {
        D3D_ERR("Invalid Entries pointer. SetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
    if (PaletteNumber > 0xffff)
    {
        D3D_ERR("Illegal PaletteNumber value. SetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    if (Enum()->GetAppSdkVersion() > D3D_SDK_VERSION_DX8)
    {
        bool bAlpha=false;
#if DBG
        bool bAllTransparent = true;
#endif
        for (int i=0;i<256;i++)
        {
            if (pEntries[i].peFlags != 0xff)
            {
                bAlpha = true;
            }
#if DBG
            if (pEntries[i].peFlags != 0)
            {
                bAllTransparent = false;
            }
#endif
        }
#if DBG
        if (bAllTransparent)
        {
            D3D_WARN(0,"Every entry in palette has alpha (peFlags) == 0. Texture may not appear.");
        }
#endif
        if (bAlpha && (0 == (GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE)) )
        {
            D3D_ERR("Application cannot set a non-opaque palette alpha value (peFlags other than 0xFF) unless the device exposes D3DPTEXTURECAPS_ALPHAPALETTE. SetPaletteEntries failed.");
            return D3DERR_INVALIDCALL;
        }
    }


    HRESULT hr = m_pPaletteArray->Grow(PaletteNumber);
    if(FAILED(hr))
    {
        D3D_ERR("Failed to set palette entries. SetPaletteEntries failed.");
        return hr;
    }

    CPalette *pal = static_cast<CPalette*>((*m_pPaletteArray)[PaletteNumber].m_pObj);
    if(pal == 0)
    {
        pal = new CPalette;
        (*m_pPaletteArray)[PaletteNumber].m_pObj = pal;
        if(pal == 0)
        {
            D3D_ERR("Could not allocate space to hold palette. SetPaletteEntries failed.");
            return E_OUTOFMEMORY;
        }
    }
    memcpy(pal->m_pEntries, pEntries, sizeof(PALETTEENTRY) * 256);

    pal->m_dirty = TRUE;

    if(m_dwPalette == PaletteNumber)
    {
        // Need to call UpdateTextures()
        m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;
    }

    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPaletteEntries"

HRESULT D3DAPI
CD3DBase::GetPaletteEntries(UINT PaletteNumber, PALETTEENTRY *pEntries)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_WRITEPTR(pEntries, sizeof(PALETTEENTRY) * 256))
    {
        D3D_ERR("Invalid ppEntries pointer. GetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
    if (PaletteNumber >= m_pPaletteArray->GetSize())
    {
        D3D_ERR("Palette not defined. GetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    CPalette *pal = static_cast<CPalette*>((*m_pPaletteArray)[PaletteNumber].m_pObj);

#if DBG
    if(pal == 0)
    {
        D3D_ERR("Palette not defined.  GetPaletteEntries failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    memcpy(pEntries, pal->m_pEntries, sizeof(PALETTEENTRY) * 256);

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetClipPlaneI"

void CD3DBase::SetClipPlaneI(DWORD dwPlaneIndex,
                             CONST D3DVALUE* pPlaneEquation)
{
    m_pDDI->SetClipPlane(dwPlaneIndex, pPlaneEquation);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetClipPlane"

HRESULT D3DAPI
CD3DBase::SetClipPlane(DWORD dwPlaneIndex,
                       CONST D3DVALUE* pPlaneEquation)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwPlaneIndex >= m_dwMaxUserClipPlanes)
    {
        D3D_ERR("Plane index is too big. SetClipPlane failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_PTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR("Invalid plane pointer. SetClipPlane failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertClipPlane(dwPlaneIndex, pPlaneEquation);
        else
            SetClipPlaneI(dwPlaneIndex, pPlaneEquation);
    }
    catch(HRESULT ret)
    {
        DPF_ERR("SetClipPlane failed.");
        return ret;
    }
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetStreamSource"

HRESULT D3DAPI
CD3DBase::SetStreamSource(UINT StreamNumber,
                          IDirect3DVertexBuffer8 *pStreamData,
                          UINT Stride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (StreamNumber >= m_dwNumStreams)
    {
        D3D_ERR("Stream number should be less than %d. SetStreamSource failed.", m_dwNumStreams);
        return D3DERR_INVALIDCALL;
    }
    if (Stride > this->GetD3DCaps()->MaxStreamStride)
    {
        D3D_ERR("Stream stride is too big. Check device caps. SetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
    // NULL is allowed to be passed
    if (pStreamData)
    {
        CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pStreamData);
        if (pVB->Device() != this)
        {
            D3D_ERR("VertexBuffer not created with this Device. SetStreamSource fails.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
    {
        try
        {
            m_pStateSets->InsertStreamSource(StreamNumber, static_cast<CVertexBuffer *>(pStreamData), Stride);
        }
        catch(HRESULT hr)
        {
            DPF_ERR("SetStreamSource failed.");
            return hr;
        }
        return S_OK;
    }

    CVStream* pStream = &m_pStream[StreamNumber];

    if (pStream->m_pVB == static_cast<CVertexBuffer *>(pStreamData) &&
        Stride == pStream->m_dwStride)
        return D3D_OK;

    // Release previously set vertex buffer
    if (pStream->m_pVB)
    {
        m_pDDI->VBReleased(pStream->m_pVB);
        pStream->m_pVB->DecrementUseCount();
        pStream->m_pVB = NULL;
    }
    pStream->m_pData = NULL;
    pStream->m_pVB = static_cast<CVertexBuffer *>(pStreamData);
    if (pStreamData)
    {
        pStream->m_pVB->IncrementUseCount();
        pStream->m_dwStride = Stride;
#if DBG
        pStream->m_dwSize = pStream->m_pVB->GetBufferDesc()->Size;
#endif // DBG
        m_dwStreamDirty |= (1 << StreamNumber);
        m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
#if DBG
        if (Stride == 0)
            pStream->m_dwNumVertices = 1;
        else
            pStream->m_dwNumVertices = pStream->m_dwSize / Stride;
#endif
        try
        {
            SetStreamSourceI(pStream);
        }
        catch(HRESULT hr)
        {
            DPF_ERR("SetStreamSource failed.");
            return hr;
        }
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetStreamSourceI"

void
CD3DBase::SetStreamSourceI(CVStream* pStream)
{
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetStreamSourceFast"

HRESULT D3DAPI
CD3DBase::SetStreamSourceFast(UINT StreamNumber,
                              IDirect3DVertexBuffer8 *pStreamData,
                              UINT Stride)
{
#if DBG
    // Validate Parameters
    if (StreamNumber >= m_dwNumStreams)
    {
        D3D_ERR("Stream number should be less than %d. SetStreamSource failed.", m_dwNumStreams);
        return D3DERR_INVALIDCALL;
    }
    if (Stride > this->GetD3DCaps()->MaxStreamStride)
    {
        D3D_ERR("Stream stride is too big. Check device caps. SetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
    // NULL is allowed to be passed
    if (pStreamData)
    {
        CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pStreamData);
        if (pVB->Device() != this)
        {
            D3D_ERR("VertexBuffer not created with this Device. SetStreamSource fails.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    CVStream* pStream = &m_pStream[StreamNumber];

    if (pStream->m_pVB == static_cast<CVertexBuffer *>(pStreamData) &&
        Stride == pStream->m_dwStride)
        return D3D_OK;

    // Release previously set vertex buffer
    if (pStream->m_pVB)
    {
        // We don't call VBReleased() here because there is no need to update the DDI object since
        // the fe/PSGP never does the redundant stream set check. This check is done in DrawPrim,
        // DrawIndexPrim and DrawClippedPrim. It is important to call VBReleased whenever fe/PSGP
        // is being used because it is possible that the user freed and recreated the same VB with
        // the same address and then the redundant set check will not work.
        pStream->m_pVB->DecrementUseCount();
        pStream->m_pVB = NULL;
    }
    pStream->m_pData = NULL;
    pStream->m_pVB = static_cast<CVertexBuffer *>(pStreamData);
    if (pStreamData)
    {
        pStream->m_pVB->IncrementUseCount();
        pStream->m_dwStride = Stride;
#if DBG
        pStream->m_dwSize = pStream->m_pVB->GetBufferDesc()->Size;
#endif // DBG
        m_dwStreamDirty |= (1 << StreamNumber);
        m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
#if DBG
        if (Stride == 0)
            pStream->m_dwNumVertices = 1;
        else
            pStream->m_dwNumVertices = pStream->m_dwSize / Stride;
#endif
    }
    if (!IS_DX8HAL_DEVICE(this))
    {
        PickDrawPrimFn();
    }
    return S_OK;
}
#endif // FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetStreamSource"

HRESULT
CD3DBase::GetStreamSource(UINT StreamNumber, IDirect3DVertexBuffer8 **ppStreamData,
                          UINT* pStride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (StreamNumber >= m_dwNumStreams)
    {
        D3D_ERR("Stream number should be less than %d. GetStreamSource failed.", m_dwNumStreams);
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(ppStreamData, sizeof(IDirect3DVertexBuffer8*)))
    {
        D3D_ERR("Invalid stream data pointer. GetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pStride, sizeof(UINT*)))
    {
        D3D_ERR("Invalid stride pointer. GetStreamSource failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    CVStream* pStream = &m_pStream[StreamNumber];
    *ppStreamData = (pStream) ? (pStream->m_pVB) : (NULL);
    if (pStream->m_pVB)
        pStream->m_pVB->AddRef();
    *pStride = (pStream) ? (pStream->m_dwStride) : (0);
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetIndices"

HRESULT D3DAPI
CD3DBase::SetIndices(IDirect3DIndexBuffer8 *pIndexData, UINT BaseVertexIndex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        CIndexBuffer * pVB = static_cast<CIndexBuffer*>(pIndexData);
#if DBG
        if (pVB && pVB->Device() != this)
        {
            D3D_ERR("IndexBuffer not created with this Device. SetIndices fails.");
            return D3DERR_INVALIDCALL;
        }
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertIndices(pVB, BaseVertexIndex);
            return S_OK;
        }

        if (m_pIndexStream->m_pVBI == static_cast<CIndexBuffer *>(pIndexData))
        {
            m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
            return D3D_OK;
        }

       // Release previously set vertex buffer
        if (m_pIndexStream->m_pVBI)
        {
            m_pDDI->VBIReleased(m_pIndexStream->m_pVBI);
            m_pIndexStream->m_pVBI->DecrementUseCount();
            m_pIndexStream->m_pVBI = NULL;
        }
        m_pIndexStream->m_pVBI = static_cast<CIndexBuffer *>(pIndexData);
        if (pVB)
        {
            switch (pVB->GetBufferDesc()->Format)
            {
            case D3DFMT_INDEX16:
                m_pIndexStream->m_dwStride = 2;
                break;
            case D3DFMT_INDEX32:
#if DBG
                if (GetD3DCaps()->MaxVertexIndex <= 0xFFFF)
                    D3D_THROW(D3DERR_INVALIDCALL, "Device does not support 32-bit indices");
#endif
                m_pIndexStream->m_dwStride = 4;
                break;
            default:
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid index buffer format");
            }
#if DBG
            m_pIndexStream->m_dwSize = pVB->GetBufferDesc()->Size;
#endif
            m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
            m_pIndexStream->m_pData = NULL;
#if DBG
            m_pIndexStream->m_dwNumVertices = m_pIndexStream->m_dwSize /
                                            m_pIndexStream->m_dwStride;
#endif
            m_pIndexStream->m_pVBI->IncrementUseCount();
            m_dwStreamDirty |= (1 << __NUMSTREAMS);
            m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()

            SetIndicesI(m_pIndexStream);
        }
    }
    catch(HRESULT hr)
    {
        DPF_ERR("SetIndices failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetIndicesI"

void
CD3DBase::SetIndicesI(CVIndexStream* pStream)
{
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetIndices"

HRESULT D3DAPI
CD3DBase::GetIndices(IDirect3DIndexBuffer8 **ppIndexData, UINT* pBaseVertexIndex)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_WRITEPTR(ppIndexData, sizeof(IDirect3DIndexBuffer8*)))
    {
        D3D_ERR("Invalid index data pointer. GetIndices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pBaseVertexIndex, sizeof(UINT*)))
    {
        D3D_ERR("Invalid base index pointer. GetIndices failed.");
        return D3DERR_INVALIDCALL;
    }
#endif //DBG
    *ppIndexData = m_pIndexStream->m_pVBI;
    if (m_pIndexStream->m_pVBI)
        m_pIndexStream->m_pVBI->AddRef();
    *pBaseVertexIndex = m_pIndexStream->m_dwBaseIndex;
    return S_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetIndicesFast"

HRESULT D3DAPI
CD3DBase::SetIndicesFast(IDirect3DIndexBuffer8 *pIndexData, UINT BaseVertexIndex)
{
    CIndexBuffer * pVB = static_cast<CIndexBuffer*>(pIndexData);
#if DBG
    if (pVB && pVB->Device() != this)
    {
        D3D_ERR("IndexBuffer not created with this device. SetIndices fails.");
        return D3DERR_INVALIDCALL;
    }
#endif

    DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

    if (m_pIndexStream->m_pVBI == pVB)
    {
        m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
        return D3D_OK;
    }

    // Release previously set index buffer
    if (m_pIndexStream->m_pVBI)
    {
        // We don't call VBReleased() here because there is no need to update the DDI object since
        // the fe/PSGP never does the redundant stream set check. This check is done in DrawPrim,
        // DrawIndexPrim and DrawClippedPrim. It is important to call VBReleased whenever fe/PSGP
        // is being used because it is possible that the user freed and recreated the same VB with
        // the same address and then the redundant set check will not work.
        m_pIndexStream->m_pVBI->DecrementUseCount();
        m_pIndexStream->m_pVBI = NULL;
    }
    m_pIndexStream->m_pVBI = static_cast<CIndexBuffer *>(pIndexData);
    if (pVB)
    {
        switch (pVB->GetBufferDesc()->Format)
        {
        case D3DFMT_INDEX16:
            m_pIndexStream->m_dwStride = 2;
            break;
        case D3DFMT_INDEX32:
#if DBG
            if (GetD3DCaps()->MaxVertexIndex <= 0xFFFF)
            {
                DPF_ERR("Device does not support 32-bit indices. SetIndices failed.");
                return D3DERR_INVALIDCALL;
            }
#endif
            m_pIndexStream->m_dwStride = 4;
            break;
        default:
            DPF_ERR("Invalid index buffer format. SetIndices failed.");
            return D3DERR_INVALIDCALL;
        }
#if DBG
        m_pIndexStream->m_dwSize = pVB->GetBufferDesc()->Size;
#endif
        m_pIndexStream->m_dwBaseIndex = BaseVertexIndex;
        m_pIndexStream->m_pData = NULL;
#if DBG
        m_pIndexStream->m_dwNumVertices = m_pIndexStream->m_dwSize /
                                        m_pIndexStream->m_dwStride;
#endif
        m_pIndexStream->m_pVBI->IncrementUseCount();
        m_dwStreamDirty |= (1 << __NUMSTREAMS);
        m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
    }
    return S_OK;
}
#endif // FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreateVertexShader"

HRESULT D3DAPI
CD3DBase::CreateVertexShader(CONST DWORD* pdwDeclaration,
                             CONST DWORD* pdwFunction,
                             LPDWORD pdwHandle, DWORD Usage)
{
    API_ENTER(this); // Takes D3D Lock if necessary
#if DBG
    // Validate Parameters
    // WARNING!! sizeof(LPVOID) is not good enough
    if (!VALID_PTR(pdwDeclaration, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid shader declaration pointer. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    // WARNING!! sizeof(LPVOID) is not good enough
    if (pdwFunction && !VALID_PTR(pdwFunction, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid shader function pointer. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pdwHandle && !VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid shader handle pointer. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (Usage & ~D3DUSAGE_SOFTWAREPROCESSING)
    {
        D3D_ERR("Illegal usage value. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pdwHandle == NULL)
    {
        // Temporary vertex shaders are disabled
        D3D_ERR("Output handle pointer cannot be NULL. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((pdwFunction != NULL) &&
        (GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) &&
        (BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
    {
        D3D_ERR("No programmable vertex shaders are supported by this device. CreateVertexShader failed.");
        return D3DERR_INVALIDCALL;
    }

#endif // DBG
    DWORD dwHandle = m_pVShaderArray->CreateNewHandle(NULL);
    HRESULT ret = S_OK;
    if (dwHandle == __INVALIDHANDLE)
    {
        D3D_ERR("Error in creating shader handle. CreateVertexShader failed.");
        return E_OUTOFMEMORY;
    }
    CVShader *pShader = new CVShader(m_dwNumStreams);
    if (pShader == NULL)
    {
        D3D_ERR("Cannot allocate memory for internal shader object. CreateVertexShader failed.");
        return E_OUTOFMEMORY;
    }
    if (Usage & D3DUSAGE_SOFTWAREPROCESSING ||
        BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
    {
        pShader->m_dwFlags |= CVShader::SOFTWARE;
        Usage |= D3DUSAGE_SOFTWAREPROCESSING;
    }

    try
    {
        D3DCAPS8 Caps, *pCaps = NULL;
        const D3DCAPS8 *pConstCaps = GetD3DCaps();
        if( pConstCaps )
        {
            pCaps = &Caps;
            memcpy(pCaps,pConstCaps,sizeof(D3DCAPS8));
            pCaps->MaxStreams = m_dwNumStreams;
            if( pShader->m_dwFlags & CVShader::SOFTWARE )
            {
                pCaps->VertexShaderVersion = D3DVS_VERSION(1, 1); // Version 1.1
                pCaps->MaxVertexShaderConst = D3DVS_CONSTREG_MAX_V1_1;
            }
        }
        if( !ValidateVertexShaderInternal(pdwFunction, pdwDeclaration, pCaps) )
        {
            ret = D3DERR_INVALIDCALL;
            goto error;
        }

        // Even for the D3DCREATE_PUREDEVICE we create a shader object for
        // validation
        DWORD dwCodeOnlySize = 0;
        DWORD dwCodeAndCommentSize = 0;
        DWORD dwDeclSize = 0;
        if (pdwFunction == NULL)
        {
            pShader->m_dwFlags |= CVShader::FIXEDFUNCTION;
            pShader->m_Declaration.Parse(this, pdwDeclaration, TRUE, &dwDeclSize, Usage);
        }
        else
        {
            pShader->m_Declaration.Parse(this, pdwDeclaration, FALSE, &dwDeclSize, Usage);
            HRESULT hr = ComputeShaderCodeSize(pdwFunction,
                                               &dwCodeOnlySize,
                                               &dwCodeAndCommentSize,
                                               NULL);
            if (hr != S_OK)
            {
                D3D_THROW(hr, "Unable to compute shader code size.");
            }
            pShader->m_pOrgFuncCode = new DWORD[dwCodeAndCommentSize];
            pShader->m_pStrippedFuncCode = new DWORD[dwCodeOnlySize];
            if (pShader->m_pOrgFuncCode == NULL ||
                pShader->m_pStrippedFuncCode == NULL)
            {
                D3D_THROW(E_OUTOFMEMORY, "Could not allocate space for holding vertex shader");
            }

            pShader->m_OrgFuncCodeSize = dwCodeAndCommentSize;
            memcpy(pShader->m_pOrgFuncCode, pdwFunction, dwCodeAndCommentSize);

            pShader->m_StrippedFuncCodeSize = dwCodeOnlySize;
            // copy and strip comments (instead of memcpy)
            DWORD* pDst = pShader->m_pStrippedFuncCode;
            CONST DWORD* pSrc = pdwFunction;
            *pDst++ = *pSrc++; // copy version
            while (*pSrc != 0x0000FFFF)
            {
                if(IsInstructionToken(*pSrc))
                {
                    DWORD opCode = (*pSrc) & D3DSI_OPCODE_MASK;
                    if ( opCode == D3DSIO_COMMENT )
                    {
                        UINT DWordSize = ((*pSrc)&D3DSI_COMMENTSIZE_MASK)>>D3DSI_COMMENTSIZE_SHIFT;
                        pSrc += (DWordSize + 1);  // comment + instruction token
                    }
                    else
                    {
                        *pDst++ = *pSrc++;
                    }
                }
                else
                {
                    *pDst++ = *pSrc++;
                }
            }
            *pDst++ = *pSrc++; // copy END
        }

        // ALways save the original declaration
        pShader->m_pOrgDeclaration = new DWORD[dwDeclSize];
        if (pShader->m_pOrgDeclaration == NULL)
        {
            D3D_THROW(E_OUTOFMEMORY, "Could not allocate space for holding vertex shader");
        }
        pShader->m_OrgDeclSize = dwDeclSize;
        memcpy(pShader->m_pOrgDeclaration, pdwDeclaration, dwDeclSize);

        m_pVShaderArray->SetObject(dwHandle, pShader);

        CreateVertexShaderI(pdwDeclaration,
                            dwDeclSize,
                            pdwFunction,
                            dwCodeAndCommentSize, dwHandle);
    }
    catch(HRESULT hr)
    {
        ret = hr;
        goto error;
    }

    *pdwHandle = dwHandle;
    return S_OK;

error:
    D3D_ERR("CreateVertexShader failed.");
    delete pShader;
    m_pVShaderArray->ReleaseHandle(dwHandle, FALSE);
    return ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckVertexShaderHandle"

void CD3DBase::CheckVertexShaderHandle(DWORD dwHandle)
{
    if (dwHandle == 0)
    {
        D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
    }
    if (D3DVSD_ISLEGACY(dwHandle))
    {
        if (((GetD3DCaps()->DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0) &&
            !FVF_TRANSFORMED(dwHandle) &&
            (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) == 0)
        {
            D3D_THROW(D3DERR_INVALIDCALL,
                      "Untransformed data cannot be handles by this device");
        }

        if (FAILED(ValidateFVF(dwHandle)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid FVF (or legacy vertex shader handle)");
        }
    }
    else
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
        }
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
        {
            if (!(pShader->m_dwFlags & CVShader::SOFTWARE))
            {
                D3D_THROW_FAIL("Vertex shader created in hardware mode cannot be used in software mode");
            }
        }
        else
        {
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                D3D_THROW_FAIL("Vertex shader created in software mode cannot be used in hardware mode");
            }
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckPixelShaderHandle"

void CD3DBase::CheckPixelShaderHandle(DWORD dwHandle)
{
    if (dwHandle != 0)
    {
        CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid pixel shader handle");
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShader"

HRESULT D3DAPI
CD3DBase::SetVertexShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
#if DBG
        CheckVertexShaderHandle(dwHandle);
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            if (D3DVSD_ISLEGACY(dwHandle))
            {
                m_pStateSets->InsertVertexShader(dwHandle, TRUE);
            }
            else
            {
                CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
                if (pShader->m_dwFlags & CVShader::SOFTWARE)
                    m_pStateSets->InsertVertexShader(dwHandle, FALSE);
                else
                    m_pStateSets->InsertVertexShader(dwHandle, TRUE);
            }
        }
        else
        {
            SetVertexShaderI(dwHandle);
        }
    }
    catch(HRESULT hr)
    {
        DPF_ERR("SetVertexShader failed.");
        ClearVertexShaderHandle();
        return hr;
    }
   return S_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderFast"

HRESULT D3DAPI
CD3DBase::SetVertexShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckVertexShaderHandle(dwHandle);
        if (!D3DVSD_ISLEGACY(dwHandle))
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                D3D_THROW_FAIL("Vertex shader created in software mode cannot be used in hardware mode");
            }
        }
#endif
        DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

        m_pDDI->SetVertexShaderHW(dwHandle);
    }
    catch(HRESULT hr)
    {
        DPF_ERR("SetVertexShader failed.");
        ClearVertexShaderHandle();
        return hr;
    }
   return S_OK;
}
#endif // FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShader"

HRESULT D3DAPI
CD3DBase::GetVertexShader(LPDWORD pdwHandle)
{
    API_ENTER(this);
    D3D_ERR("GetVertexShader does not work in pure-device. GetVertexShader failed.");
    return D3DERR_INVALIDCALL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeleteVertexShader"

HRESULT D3DAPI
CD3DBase::DeleteVertexShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (dwHandle == 0)
    {
        DPF_ERR( "Cannot delete a NULL vertex shader handle." );
        return D3DERR_INVALIDCALL;
    }
    if (D3DVSD_ISLEGACY(dwHandle))
    {
        DPF_ERR( "Cannot delete a legacy vertex shader handle (FVF ?)." );
        return D3DERR_INVALIDCALL;
    }
#endif
    if( m_pVShaderArray->GetObject(dwHandle) == NULL )
    {
        DPF_ERR( "Cannot delete a vertex shader handle that does not exist." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
        DeleteVertexShaderI(dwHandle);

        // Release handle and delete shader object
        m_pVShaderArray->ReleaseHandle(dwHandle, TRUE);
    }
    catch(HRESULT hr)
    {
        DPF_ERR("DeleteVertexShader failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderConstant"

HRESULT D3DAPI
CD3DBase::SetVertexShaderConstant(DWORD Register,
                                  CONST VOID* pData,
                                  DWORD count)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, 4* sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) &&
        (BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
    {
        D3D_ERR("No programmable vertex shaders are supported by this device. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    UINT ValidationCount;
    if (BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)
        ValidationCount = max(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    else
    if (BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
    else
        ValidationCount = m_MaxVertexShaderConst;
    if((Register + count) > ValidationCount)
    {
        D3D_ERR("Not that many constant registers in the vertex machine. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertVertexShaderConstant(Register,
                                                     pData,
                                                     count);
        else
            SetVertexShaderConstantI(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetVertexShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderConstantFast"

HRESULT D3DAPI
CD3DBase::SetVertexShaderConstantFast(DWORD Register,
                                      CONST VOID* pData,
                                      DWORD count)
{

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, 4* sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((GetD3DCaps()->VertexShaderVersion == D3DVS_VERSION(0,0)) &&
        (BehaviorFlags() & (D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE)))
    {
        D3D_ERR("No programmable vertex shaders are supported by this device. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    UINT ValidationCount;
    if (BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING)
        ValidationCount = max(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    else
    if (BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        ValidationCount = D3DVS_CONSTREG_MAX_V1_1;
    else
        ValidationCount = m_MaxVertexShaderConst;
    if((Register + count) > ValidationCount)
    {
        D3D_ERR("Not that many constant registers in the vertex machine. SetVertexShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DXGASSERT((m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE) == 0 &&
              (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0 &&
              (BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0);
    try
    {
        m_pDDI->SetVertexShaderConstant(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetVertexShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderConstantI"

void
CD3DBase::SetVertexShaderConstantI(DWORD dwRegister, CONST VOID* pData, DWORD count)
{
    m_pDDI->SetVertexShaderConstant(dwRegister, pData, count);
}
//-----------------------------------------------------------------------------
//
// Pixel Shaders
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreatePixelShader"

HRESULT D3DAPI
CD3DBase::CreatePixelShader(CONST DWORD* pdwFunction, LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    // WARNING!! sizeof(LPVOID) is not good enough
    if (!VALID_PTR(pdwFunction, sizeof(LPVOID)))
    {
        D3D_ERR("Invalid shader function pointer. CreatePixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR("Invalid handle pointer. CreatePixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    DWORD dwHandle = m_pPShaderArray->CreateNewHandle(NULL);
    HRESULT ret = S_OK;
    if (dwHandle == __INVALIDHANDLE)
    {
        D3D_ERR("Error in creating shader handle. CreatePixelShader failed.");
        return E_OUTOFMEMORY;
    }
    CPShader *pShader = new CPShader();
    if (pShader == NULL)
    {
        D3D_ERR("Cannot allocate memory for internal pixel shader object. CreatePixelShader failed.");
        return E_OUTOFMEMORY;
    }
    try
    {
        if( !ValidatePixelShaderInternal(pdwFunction, GetD3DCaps()) )
        {
            ret = D3DERR_INVALIDCALL;
            goto error;
        }
        DWORD dwVersion = *pdwFunction;

        if ( (0xff == D3DSHADER_VERSION_MAJOR(dwVersion) )
            && (m_dwRuntimeFlags & D3DRT_DISALLOWNVPSHADERS) )
        {
            D3D_ERR("Disallowing non-versioned pixel shader.");
            ret = D3DERR_INVALIDCALL;
            goto error;
        }

        // Even for the D3DCREATE_PUREDEVICE we create a shader object for validation
        pShader->Initialize(pdwFunction, GetDeviceType());
        m_pPShaderArray->SetObject(dwHandle, pShader);

        try
        {
            m_pDDI->CreatePixelShader(pShader->m_pCode,
                                      pShader->m_dwCodeSize, dwHandle);
        }

        catch(HRESULT hr)
        {
            if( 0xff == D3DSHADER_VERSION_MAJOR(dwVersion) )
            {
                // This is a ff.ff shader. The driver is allowed to fail this.
                D3D_INFO(0, "Driver failed the creation of this non-versioned pixel "
                         "shader");
                throw D3DERR_DRIVERINVALIDCALL;
            }
            else
            {
                OutputDebugString( "Driver failed to create the requested "
                                   "pixel shader. Please contact your "
                                   "friendly video card manufacturer "
                                   "to inquire why this problem was "
                                   "encountered.\n" );
                OutputDebugString( "\n" );

                // NOTE! Prefix will catch this as a bug, but it is entirely
                // intentional
                *(DWORD *)0 = 0;
            }
        }
    }
    catch(HRESULT hr)
    {
        ret = hr;
        goto error;
    }

    *pdwHandle = dwHandle;
    return S_OK;

error:

    D3D_ERR("CreatePixelShader failed.");
    delete pShader;
    m_pPShaderArray->ReleaseHandle(dwHandle, FALSE);
    return ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShader"

HRESULT D3DAPI
CD3DBase::SetPixelShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary
    try
    {
#if DBG
        CheckPixelShaderHandle(dwHandle);
#endif
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertPixelShader(dwHandle);
        else
            SetPixelShaderFast(dwHandle);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShader failed.");
        m_dwCurrentPixelShaderHandle = 0;
        return hr;
    }
   return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShaderFast"

HRESULT D3DAPI
CD3DBase::SetPixelShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckPixelShaderHandle(dwHandle);
#endif
        // m_dwCurrentPixelShaderHandle is not defined for pure device
        m_pDDI->SetPixelShader(dwHandle);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShader failed.");
        m_dwCurrentPixelShaderHandle = 0;
        return hr;
    }
   return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShader"

HRESULT D3DAPI
CD3DBase::GetPixelShader(LPDWORD pdwHandle)
{
    API_ENTER(this);
    D3D_ERR("GetPixelShader is not available for PUREDEVICE. GetPixelShader failed.");
    return D3DERR_INVALIDCALL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeletePixelShader"

HRESULT D3DAPI
CD3DBase::DeletePixelShader(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
    if (pShader == NULL)
    {
        D3D_ERR("Invalid pixel shader handle. DeletePixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        m_pDDI->DeletePixelShader(dwHandle);

        // Release handle and delete shader object
        m_pPShaderArray->ReleaseHandle(dwHandle, TRUE);

        // If the pixel shader is current, set an invalid shader as current
        // This is needed only for non-pure device.
        if (dwHandle == m_dwCurrentPixelShaderHandle)
        {
            m_dwCurrentPixelShaderHandle = 0x0;
        }
    }
    catch(HRESULT hr)
    {
        D3D_ERR("DeletePixelShader failed.");
        return hr;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShaderConstant"

HRESULT D3DAPI
CD3DBase::SetPixelShaderConstant(DWORD Register, CONST VOID* pData,
                                 DWORD count)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if(Register >= D3DPS_CONSTREG_MAX_DX8)
    {
        D3D_ERR("Invalid Constant Register number. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if( (Register + count) > D3DPS_CONSTREG_MAX_DX8 )
    {
        D3D_ERR("Not that many constant registers in the pixel machine. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        if (m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
            m_pStateSets->InsertPixelShaderConstant(Register,
                                                    pData,
                                                    count);
        else
            SetPixelShaderConstantFast(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPixelShaderConstantFast"

HRESULT D3DAPI
CD3DBase::SetPixelShaderConstantFast(DWORD Register, CONST VOID* pData,
                                     DWORD count)
{

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if(Register >= D3DPS_CONSTREG_MAX_DX8)
    {
        D3D_ERR("Invalid Constant Register number. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
    if( (Register + count) > D3DPS_CONSTREG_MAX_DX8 )
    {
        D3D_ERR("Not that many constant registers in the pixel machine. SetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        m_pDDI->SetPixelShaderConstant(Register, pData, count);
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShaderConstant failed.");
        return hr;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShaderConstantI"

void
CD3DBase::GetPixelShaderConstantI(DWORD dwRegister, DWORD count, LPVOID pData)
{
    // Should never be called.
    DDASSERT( FALSE );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ValidateDraw"

void CD3DBase::ValidateDraw(D3DPRIMITIVETYPE primType,
                            UINT StartVertex,
                            UINT PrimitiveCount,
                            UINT NumVertices,
                            BOOL bIndexPrimitive,
                            BOOL bUserMemPrimitive)
{
#if DBG
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0)
    {
        D3D_THROW_FAIL("Need to call BeginScene before rendering.");
    }
    if (primType < D3DPT_POINTLIST || primType > D3DPT_TRIANGLEFAN)
    {
        D3D_THROW_FAIL("Invalid primitive type");
    }
    if (primType == D3DPT_POINTLIST && bIndexPrimitive)
    {
        D3D_THROW_FAIL("Indexed point lists are not supported");
    }
    if (PrimitiveCount == 0)
    {
        D3D_THROW_FAIL("Invalid primitive count");
    }
    // Number of vertices is always greater than or equal number of primitives
    if (max(NumVertices, PrimitiveCount) > this->GetD3DCaps()->MaxPrimitiveCount)
    {
        D3D_THROW_FAIL("Primitive count or vertex count is too big. Check device caps.");
    }
    for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
    {
        if (m_lpD3DMappedTexI[dwStage] != 0)
        {
            if (m_lpD3DMappedTexI[dwStage]->IsTextureLocked())
            {
                D3D_THROW_FAIL("Cannot render when currently set textures are locked.");
            }
        }
    }
#endif //DBG
}
//-----------------------------------------------------------------------------
// Check if indices are within the range. We do it only for software
// processing because we do not want to read video memory
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckIndices"

void CD3DBase::CheckIndices(CONST BYTE* pIndices, UINT NumIndices,
                            UINT StartIndex,
                            UINT MinIndex, UINT NumVertices, UINT IndexStride)
{
    // Check if indices are within the range. We do it only for software
    // processing because we do not want to read video memory
    if (pIndices == NULL)
    {
        D3D_THROW_FAIL("Invalid index data pointer");
    }
    UINT MaxIndex = MinIndex + NumVertices - 1;
    pIndices += IndexStride * StartIndex;
    for (DWORD i = 0; i < NumIndices; i++)
    {
        DWORD dwIndex = IndexStride == 4?
                        *(DWORD*)pIndices : *(WORD*)pIndices;
        pIndices += IndexStride;
        if (dwIndex < MinIndex || dwIndex > MaxIndex)
        {
            D3D_ERR("Invalid index in the index stream: %d", dwIndex);
            D3D_THROW_FAIL("");
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPrimitive"

HRESULT D3DAPI
CD3DBase::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                        UINT StartVertex,
                        UINT PrimitiveCount)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
#if DBG
        UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        try
        {
            ValidateDraw(PrimitiveType, StartVertex, PrimitiveCount, nVer,
                         FALSE, FALSE);
        }
        catch (HRESULT ret)
        {
            D3D_ERR("DrawPrimitive failed.");
            return ret;
        }

#endif // DBG
        if (PrimitiveType != D3DPT_POINTLIST)
        {
            (*m_pfnDrawPrim)(this, PrimitiveType, StartVertex, PrimitiveCount);
        }
        else
            DrawPointsI(PrimitiveType, StartVertex, PrimitiveCount);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawPrimitive failed.");
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawIndexedPrimitive"

HRESULT D3DAPI
CD3DBase::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                     UINT MinIndex, UINT NumVertices, UINT StartIndex,
                     UINT PrimitiveCount)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    try
    {
        if (NumVertices == 0)
        {
            D3D_ERR("Invalid number of vertices. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }

        DWORD dwNumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        if (dwNumIndices + StartIndex > m_pIndexStream->m_dwNumVertices)
        {
            D3D_ERR("Index stream does not have required number of indices. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }
        if (m_pIndexStream == NULL)
        {
            D3D_ERR("No index stream object. Perhaps something went wrong at a mode-change. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }
        if (m_pIndexStream->m_pVBI == NULL)
        {
            D3D_ERR("No valid index stream currently set. DrawIndexedPrimitive failed.");
            return D3DERR_INVALIDCALL;
        }
        ValidateDraw(PrimitiveType, MinIndex + m_pIndexStream->m_dwBaseIndex,
                     PrimitiveCount, NumVertices, TRUE, FALSE);
        if (m_pIndexStream->m_pVBI->GetBufferDesc()->Pool == D3DPOOL_SYSTEMMEM &&
            (m_pIndexStream->m_pVBI->GetBufferDesc()->Usage & D3DUSAGE_SOFTWAREPROCESSING) != 0)
        {
            CheckIndices((BYTE*)m_pIndexStream->m_pVBI->Data(),
                         dwNumIndices,
                         StartIndex, MinIndex, NumVertices,
                         m_pIndexStream->m_dwStride);
        }
    }
    catch(HRESULT hr)
    {
        D3D_ERR("DrawIndexedPrimitive failed.");
        return hr;
    }
#endif //DBG
    try
    {
        (*m_pfnDrawIndexedPrim)(this, PrimitiveType,
                                m_pIndexStream->m_dwBaseIndex,
                                MinIndex, NumVertices, StartIndex,
                                PrimitiveCount);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawIndexedPrimitive failed.");
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawRectPatch"

HRESULT D3DAPI CD3DBase::DrawRectPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                       CONST D3DRECTPATCH_INFO *pSurf)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0)
    {
        D3D_ERR("Need to call BeginScene before rendering.");
        return (D3DERR_INVALIDCALL);
    }
    if ((m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0)
    {
        D3D_ERR("There is no emulation support for RT patches, hence only hardware device or hardware mode is legal. DrawRectPatch failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
    {
        CD3DHal* pDevice = static_cast<CD3DHal*>(this);
        if (!D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
        {
            if (pDevice->m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
            {
                for (DWORD i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
                {
                    if (pDevice->tsstates[i][D3DTSS_TEXCOORDINDEX] != i)
                    {
                        D3D_ERR("Stage %d - Texture coordinate index in the stage "
                                "must be equal to the stage index when programmable"
                                " vertex pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                    DWORD TexTransformFlags = pDevice->tsstates[i][D3DTSS_TEXTURETRANSFORMFLAGS];
                    if ((TexTransformFlags & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE)
                    {
                        D3D_ERR("Stage %d - Count in D3DTSS_TEXTURETRANSFORMFLAGS "
                                "must be 0 when programmable pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                }
            }
        }
    }

    if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_RTPATCHES) == 0)
    {
        D3D_ERR("RT patches unsupported on current device. DrawRectPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (Handle == 0 && pSurf == 0)
    {
        D3D_ERR("Handle and patch specification cannot be both zero. DrawRectPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (pSurf != 0)
    {
        if (!VALID_PTR(pSurf, sizeof(D3DRECTPATCH_INFO)))
        {
            D3D_ERR("Invalid patch information pointer. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order != D3DORDER_LINEAR &&
            pSurf->Order != D3DORDER_CUBIC &&
            pSurf->Order != D3DORDER_QUINTIC)
        {
            D3D_ERR("Order not supported. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order == D3DORDER_QUINTIC && (GetD3DCaps()->DevCaps & D3DDEVCAPS_QUINTICRTPATCHES) == 0)
        {
            D3D_ERR("Quintic patches not supported on this device. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Basis != D3DBASIS_BEZIER &&
            pSurf->Basis != D3DBASIS_BSPLINE &&
            pSurf->Basis != D3DBASIS_INTERPOLATE)
        {
            D3D_ERR("Basis not supported. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Basis == D3DBASIS_BEZIER)
        {
            if (pSurf->Width != (DWORD)pSurf->Order + 1 ||
                pSurf->Height != (DWORD)pSurf->Order + 1)
            {
                D3D_ERR("Bezier patch must have correct dimensions to match order. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            if (pSurf->Width <= (DWORD)pSurf->Order ||
                pSurf->Height <= (DWORD)pSurf->Order)
            {
                D3D_ERR("Patch dimensions too small for the order. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if (pSurf->Basis == D3DBASIS_INTERPOLATE && pSurf->Order != D3DORDER_CUBIC)
            {
                D3D_ERR("Only bicubic interpolating splines supported. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }

        if (pSurf->Stride == 0)
        {
            D3D_ERR("Stride cannot be zero. DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }

        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        {
            try
            {
                static_cast<CD3DHal*>(this)->ValidateRTPatch();
            }
            catch(HRESULT ret)
            {
                D3D_ERR("DrawRectPatch failed.");
                return ret;
            }
        }

        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            // Need to snapshot current Vshader in the Handle table
            HRESULT hr = m_pRTPatchValidationInfo->Grow(Handle);
            if (FAILED(hr))
            {
                D3D_ERR("Could not grow handle table. DrawRectPatch failed.");
                return hr;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                (*m_pRTPatchValidationInfo)[Handle].m_pObj = new CRTPatchValidationInfo;
                if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
                {
                    D3D_ERR("Out of memory growing handle table. DrawRectPatch failed.");
                    return E_OUTOFMEMORY;
                }
            }
            static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle = m_dwCurrentShaderHandle;
        }
    }
    else
    {
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            if (Handle >= m_pRTPatchValidationInfo->GetSize())
            {
                D3D_ERR("Cannot draw a patch without any information. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                D3D_ERR("Cannot draw a patch without any information. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if (static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle != m_dwCurrentShaderHandle)
            {
                D3D_ERR("Cannot set a vertex shader different from the one set when the patch was first created. DrawRectPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }
    }
    if (pNumSegs != 0)
    {
        if (!VALID_PTR(pNumSegs, sizeof(FLOAT) * 4))
        {
            D3D_ERR("Invalid pointer to array of 4 floats (NumSegs). DrawRectPatch failed.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    try
    {
        m_pDDI->DrawRectPatch(Handle, pSurf, pNumSegs);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DrawRectPatch failed.");
        return ret;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawTriPatch"

HRESULT D3DAPI CD3DBase::DrawTriPatch(UINT Handle, CONST FLOAT *pNumSegs,
                                      CONST D3DTRIPATCH_INFO *pSurf)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0)
    {
        D3D_ERR("Need to call BeginScene before rendering.");
        return (D3DERR_INVALIDCALL);
    }
    if ((m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0)
    {
        D3D_ERR("There is no emulation support for RT patches, hence only hardware device or hardware mode is legal. DrawTriPatch failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
    {
        CD3DHal* pDevice = static_cast<CD3DHal*>(this);
        if (!D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
        {
            if (pDevice->m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
            {
                for (DWORD i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
                {
                    if (pDevice->tsstates[i][D3DTSS_TEXCOORDINDEX] != i)
                    {
                        D3D_ERR("Stage %d - Texture coordinate index in the stage "
                                "must be equal to the stage index when programmable"
                                " vertex pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                    DWORD TexTransformFlags = pDevice->tsstates[i][D3DTSS_TEXTURETRANSFORMFLAGS];
                    if ((TexTransformFlags & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE)
                    {
                        D3D_ERR("Stage %d - Count in D3DTSS_TEXTURETRANSFORMFLAGS "
                                "must be 0 when programmable pipeline is used", i);
                        return D3DERR_INVALIDCALL;
                    }
                }
            }
        }
    }


    if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_RTPATCHES) == 0)
    {
        D3D_ERR("RT patches unsupported on current device. DrawTriPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (Handle == 0 && pSurf == 0)
    {
        D3D_ERR("Handle and patch specification cannot be both zero. DrawTriPatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (pSurf != 0)
    {
        if (!VALID_PTR(pSurf, sizeof(D3DTRIPATCH_INFO)))
        {
            D3D_ERR("Invalid patch information pointer. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order != D3DORDER_LINEAR &&
            pSurf->Order != D3DORDER_CUBIC &&
            pSurf->Order != D3DORDER_QUINTIC)
        {
            D3D_ERR("Order not supported. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order == D3DORDER_QUINTIC && (GetD3DCaps()->DevCaps & D3DDEVCAPS_QUINTICRTPATCHES) == 0)
        {
            D3D_ERR("Quintic patches not supported on this device. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Basis != D3DBASIS_BEZIER)
        {
            D3D_ERR("Only Bezier basis is supported. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pSurf->Order == D3DORDER_LINEAR && pSurf->NumVertices != 3)
        {
            D3D_ERR("Only three vertices supported with linear order. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        else if (pSurf->Order == D3DORDER_CUBIC && pSurf->NumVertices != 10)
        {
            D3D_ERR("Only ten vertices supported with cubic order. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        else if (pSurf->Order == D3DORDER_QUINTIC && pSurf->NumVertices != 21)
        {
            D3D_ERR("Only 21 vertices supported with quintic order. DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
        {
            try
            {
                static_cast<CD3DHal*>(this)->ValidateRTPatch();
            }
            catch(HRESULT ret)
            {
                D3D_ERR("DrawTriPatch failed.");
                return ret;
            }
        }
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            // Need to snapshot current Vshader in the Handle table
            HRESULT hr = m_pRTPatchValidationInfo->Grow(Handle);
            if (FAILED(hr))
            {
                D3D_ERR("Could not grow handle table. DrawTriPatch failed.");
                return hr;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                (*m_pRTPatchValidationInfo)[Handle].m_pObj = new CRTPatchValidationInfo;
                if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
                {
                    D3D_ERR("Out of memory growing handle table. DrawTriPatch failed.");
                    return E_OUTOFMEMORY;
                }
            }
            static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle = m_dwCurrentShaderHandle;
        }
    }
    else
    {
        if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0 && Handle != 0)
        {
            if (Handle >= m_pRTPatchValidationInfo->GetSize())
            {
                D3D_ERR("Cannot draw a patch without any information. DrawTriPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
            {
                D3D_ERR("Cannot draw a patch without any information. DrawTriPatch failed.");
                return D3DERR_INVALIDCALL;
            }
            if (static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle != m_dwCurrentShaderHandle)
            {
                D3D_ERR("Cannot set a vertex shader different from the one set when the patch was first created. DrawTriPatch failed.");
                return D3DERR_INVALIDCALL;
            }
        }
    }
    if (pNumSegs != 0)
    {
        if (!VALID_PTR(pNumSegs, sizeof(FLOAT) * 3))
        {
            D3D_ERR("Invalid pointer to array of 3 floats (NumSegs). DrawTriPatch failed.");
            return D3DERR_INVALIDCALL;
        }
    }
#endif

    try
    {
        m_pDDI->DrawTriPatch(Handle, pSurf, pNumSegs);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DrawTriPatch failed.");
        return ret;
    }

    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeletePatch"

HRESULT D3DAPI CD3DBase::DeletePatch(UINT Handle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if ((GetD3DCaps()->DevCaps & D3DDEVCAPS_RTPATCHES) == 0)
    {
        D3D_ERR("High order surfaces unsupported on current device. DeletePatch failed.");
        return D3DERR_INVALIDCALL;
    }

    if (Handle == 0)
    {
        return S_OK;
    }

#if DBG
    if ((BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0)
    {
        if (Handle >= m_pRTPatchValidationInfo->GetSize())
        {
            D3D_ERR("Attempt to delete non-existent patch. DeletePatch failed.");
            return D3DERR_INVALIDCALL;
        }
        if ((*m_pRTPatchValidationInfo)[Handle].m_pObj == 0)
        {
            D3D_ERR("Attempt to delete non-existent patch. DeletePatch failed.");
            return D3DERR_INVALIDCALL;
        }
        delete (*m_pRTPatchValidationInfo)[Handle].m_pObj;
        (*m_pRTPatchValidationInfo)[Handle].m_pObj = 0;
    }
#endif // DBG

    try
    {
        m_pDDI->SetRenderState((D3DRENDERSTATETYPE)D3DRS_DELETERTPATCH, Handle);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DeletePatch failed.");
        return ret;
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPrimitiveUP"

HRESULT D3DAPI
CD3DBase::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                          UINT PrimitiveCount,
                          CONST VOID *pVertexStreamZeroData,
                          UINT VertexStreamZeroStride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    m_dwRuntimeFlags |= D3DRT_USERMEMPRIMITIVE;
    try
    {
        if (m_pStream[0].m_pVB)
        {
            m_pDDI->VBReleased(m_pStream[0].m_pVB);
            m_pStream[0].m_pVB->DecrementUseCount();
            m_pStream[0].m_pVB = NULL;
        }
        m_pStream[0].m_pData = (BYTE*)pVertexStreamZeroData;
        m_pStream[0].m_dwStride = VertexStreamZeroStride;
#if DBG
        UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        if (!VALID_PTR(pVertexStreamZeroData, nVer*VertexStreamZeroStride))
        {
            D3D_THROW_FAIL("Invalid input vertex stream pointer");
        }
        m_pStream[0].m_dwSize = nVer * VertexStreamZeroStride;
        m_pStream[0].m_dwNumVertices = nVer;
        try
        {
            ValidateDraw(PrimitiveType, 0, PrimitiveCount, nVer, FALSE, TRUE);
        }
        catch (HRESULT ret)
        {
            m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
            return ret;
        }
#endif // DBG
        DrawPrimitiveUPI(PrimitiveType, PrimitiveCount);
        // Invalidate stream zero
        m_pStream[0].m_pData = NULL;
#if DBG
        m_pStream[0].m_dwSize = 0;
#endif
        m_pStream[0].m_dwStride = 0;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawPrimitiveUP failed.");
#if DBG
        m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
#endif
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPrimitiveUPI"

void CD3DBase::DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimType, UINT PrimCount)
{
    m_pDDI->DrawPrimitiveUP(PrimType, PrimCount);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawIndexedPrimitiveUPI"

void
CD3DBase::DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimitiveType,
                                  UINT MinVertexIndex,
                                  UINT NumVertices,
                                  UINT PrimitiveCount)
{
    m_pDDI->DrawIndexedPrimitiveUP(PrimitiveType, MinVertexIndex, NumVertices,
                                   PrimitiveCount);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawIndexedPrimitiveUP"

HRESULT D3DAPI
CD3DBase::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                 UINT MinIndex, UINT NumVertices,
                                 UINT PrimitiveCount,
                                 CONST VOID *pIndexData, D3DFORMAT IndexDataFormat,
                                 CONST VOID *pVertexStreamZeroData,
                                 UINT VertexStreamZeroStride)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    m_dwRuntimeFlags |= D3DRT_USERMEMPRIMITIVE;

    try
    {
        if (m_pStream[0].m_pVB)
        {
            m_pDDI->VBReleased(m_pStream[0].m_pVB);
            m_pStream[0].m_pVB->DecrementUseCount();
            m_pStream[0].m_pVB = NULL;
        }
        if (m_pIndexStream->m_pVBI)
        {
            m_pDDI->VBIReleased(m_pIndexStream->m_pVBI);
            m_pIndexStream->m_pVBI->DecrementUseCount();
            m_pIndexStream->m_pVBI = NULL;
        }
        m_pStream[0].m_pData = (BYTE*)pVertexStreamZeroData;
        m_pStream[0].m_dwStride = VertexStreamZeroStride;

        m_pIndexStream->m_pData = (BYTE*)pIndexData;
        m_pIndexStream->m_dwBaseIndex = 0;
        if (IndexDataFormat == D3DFMT_INDEX16)
            m_pIndexStream->m_dwStride = 2;
        else
        if (IndexDataFormat == D3DFMT_INDEX32)
        {
#if DBG
            if (GetD3DCaps()->MaxVertexIndex <= 0xFFFF)
                D3D_THROW(D3DERR_INVALIDCALL, "Device does not support 32-bit indices");
#endif
            m_pIndexStream->m_dwStride = 4;
        }
        else
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid index data format");
        }
#if DBG
        try
        {
            if (pVertexStreamZeroData == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex stream pointer");
            }
            if (pIndexData == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid index data pointer");
            }
            if (NumVertices == 0)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid number of vertices");
            }
            m_pStream[0].m_dwSize = NumVertices * VertexStreamZeroStride;
            m_pStream[0].m_dwNumVertices = NumVertices;

            UINT NumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
            m_pIndexStream[0].m_dwSize = NumIndices * m_pIndexStream[0].m_dwStride;
            m_pIndexStream[0].m_dwNumVertices = NumIndices;
            if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            {
                CheckIndices((BYTE*)pIndexData, NumIndices, 0, MinIndex,
                             NumVertices, m_pIndexStream->m_dwStride);
            }
            ValidateDraw(PrimitiveType, MinIndex, PrimitiveCount, NumVertices,
                         TRUE, TRUE);
        }
        catch (HRESULT ret)
        {
            D3D_ERR("DrawIndexedPrimitiveUP failed.");
            m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
            return ret;
        }
#endif // DBG

        DrawIndexedPrimitiveUPI(PrimitiveType, MinIndex, NumVertices, PrimitiveCount);

        // Invalidate stream zero
        m_pStream[0].m_pData = NULL;
#if DBG
        m_pStream[0].m_dwSize = 0;
#endif
        m_pStream[0].m_dwStride = 0;
        //Invalidate index stream
        m_pIndexStream[0].m_pData = NULL;
#if DBG
        m_pIndexStream[0].m_dwSize = 0;
#endif
        m_pIndexStream[0].m_dwStride = 0;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("DrawIndexedPrimitiveUP failed.");
        m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
        m_pDDI->ClearBatch(FALSE);
        return ret;
    }
    m_dwRuntimeFlags &= ~D3DRT_USERMEMPRIMITIVE;
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DrawPointsI"

void
CD3DBase::DrawPointsI(D3DPRIMITIVETYPE PrimitiveType,
                         UINT StartVertex,
                         UINT PrimitiveCount)
{
    (*m_pfnDrawPrim)(this, PrimitiveType, StartVertex, PrimitiveCount);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreateVertexShaderI"

void
CD3DBase::CreateVertexShaderI(CONST DWORD* pdwDeclaration, DWORD dwDeclSize,
                              CONST DWORD* pdwFunction, DWORD dwCodeSize,
                              DWORD dwHandle)
{
    CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
#if DBG
    if (pShader->m_dwFlags & CVShader::SOFTWARE)
    {
        D3D_THROW_FAIL("Software vertex shader cannot be created with a PUREDEVICE");
    }

#endif // DBG
    // always pass stripped version for pure hal
    m_pDDI->CreateVertexShader(pdwDeclaration, dwDeclSize,
                               pShader->m_pStrippedFuncCode,
                               pShader->m_StrippedFuncCodeSize, dwHandle,
                               pShader->m_Declaration.m_bLegacyFVF);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetVertexShaderI"

void CD3DBase::SetVertexShaderI(DWORD dwHandle)
{
#if DBG
    CheckVertexShaderHandle(dwHandle);
    if (!D3DVSD_ISLEGACY(dwHandle))
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
        if (pShader->m_dwFlags & CVShader::SOFTWARE)
        {
            D3D_THROW_FAIL("Vertex shader created in software mode cannot be used in hardware mode");
        }
    }
#endif // DBG
    m_pDDI->SetVertexShaderHW(dwHandle);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeleteVertexShaderI"

void CD3DBase::DeleteVertexShaderI(DWORD dwHandle)
{
    m_pDDI->DeleteVertexShader(dwHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::Clear"

#define bDoRGBClear ((dwFlags & D3DCLEAR_TARGET)!=0)
#define bDoZClear   ((dwFlags & D3DCLEAR_ZBUFFER)!=0)
#define bDoStencilClear ((dwFlags & D3DCLEAR_STENCIL)!=0)

// Maximum number of clear rectangles considered legal.
// This limit is set by NT kernel for Clear2 callback
const DWORD MAX_CLEAR_RECTS  = 0x1000;

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ClearI"

void
CD3DBase::ClearI(DWORD dwCount,
                 CONST D3DRECT* rects,
                 DWORD dwFlags,
                 D3DCOLOR dwColor,
                 D3DVALUE dvZ,
                 DWORD dwStencil)
{
    if (rects == NULL)
        dwCount = 0;

    // We do not cull rects against viewport, so let the driver do it
    dwFlags |= D3DCLEAR_COMPUTERECTS;
    m_pDDI->Clear(dwFlags, dwCount, (LPD3DRECT)rects, dwColor, dvZ, dwStencil);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::Clear"

HRESULT D3DAPI
CD3DBase::Clear(DWORD dwCount,
                 CONST D3DRECT* rects,
                 DWORD dwFlags,
                 D3DCOLOR dwColor,
                 D3DVALUE dvZ,
                 DWORD dwStencil)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (IsBadReadPtr(rects, dwCount * sizeof(D3DRECT)))
    {
        D3D_ERR("Invalid rects pointer. Clear failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        HRESULT err;
        LPDDPIXELFORMAT pZPixFmt=NULL;

        if (dwCount > MAX_CLEAR_RECTS)
        {
            D3D_ERR("Cannot support more than 64K rectangles. Clear failed.");
            return D3DERR_INVALIDCALL;
        }
        if (!(GetD3DCaps()->RasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
        {
            if (bDoStencilClear||bDoZClear)
            {
                if (this->ZBuffer()==NULL)
                {
                    // unlike Clear(), specifying a Zbuffer-clearing flag without a zbuffer will
                    // be considered an error
#if DBG
                    if (bDoZClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_ZBUFFER: no zbuffer is associated with device. Clear failed.");
                    }
                    if (bDoStencilClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL: no zbuffer is associated with device. Clear failed.");
                    }
#endif
                    return D3DERR_INVALIDCALL;
                }
                if (bDoStencilClear)
                {
                    D3DSURFACE_DESC desc = (this->ZBuffer())->InternalGetDesc();
                    if (!CPixel::IsIHVFormat(desc.Format) &&
                        !CPixel::HasStencilBits(desc.Format))
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL; current zbuffer's pixel format doesnt support stencil bits. Clear failed.");
                        return D3DERR_INVALIDCALL;
                    }
                }
            }
        }
        if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)))
        {
            D3D_ERR("Flags not valid. Clear failed.");
            return D3DERR_INVALIDCALL;
        }

        // bad clear values just cause wacky results but no crashes, so OK to allow in retail bld

        DDASSERT(!bDoZClear || ((dvZ>=0.0) && (dvZ<=1.0)));
        DDASSERT(!bDoStencilClear || !pZPixFmt || (dwStencil <= (DWORD)((1<<pZPixFmt->dwStencilBitDepth)-1)));

        ClearI(dwCount, rects, dwFlags, dwColor, dvZ, dwStencil);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("Clear failed.");
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::FlushStatesNoThrow"
void __declspec(nothrow) CD3DBase::FlushStatesNoThrow()
{
    try
    {
        DXGASSERT(m_pDDI);
        m_pDDI->FlushStates();
    }
    catch(HRESULT hr)
    {
        DPF_ERR("Driver failed a command batch will synchronizing a synchronous call with the command stream. (No error will be returned to the app)");
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::TexBlt"
HRESULT __declspec(nothrow) CD3DBase::TexBlt(CBaseTexture *pDst,
                                             CBaseTexture *pSrc,
                                             POINT        *pPoint,
                                             RECTL        *pRect)
{
    // Get the draw prim handles
    DWORD dwSrc = pSrc->BaseDrawPrimHandle();

    DWORD dwDst = 0;
    if (pDst)
    {
        dwDst = pDst->DriverAccessibleDrawPrimHandle();
    }

    // Insert the tokens now
    try
    {
        m_pDDI->TexBlt(dwDst, dwSrc, pPoint, pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }

    // If successful, batch the source and dest
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    pSrc->BatchBase();
    if (pDst != NULL)
    {
        pDst->Batch();
    }

    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CubeTexBlt"

// Very similar function to TexBlt except that
// this is done for cube-maps which are special since we
// need to send different handles for each face
HRESULT __declspec(nothrow) CD3DBase::CubeTexBlt(CBaseTexture *pDstParent,
                                                 CBaseTexture *pSrcParent,
                                                 DWORD         dwDestFaceHandle,
                                                 DWORD         dwSrcFaceHandle,
                                                 POINT        *pPoint,
                                                 RECTL        *pRect)
{
    // CubeTexBlt is not overloaded for use with PreLoad semantics
    // so we should always have a source and a dest
    DXGASSERT(pDstParent);
    DXGASSERT(pSrcParent);

    // Insert the tokens now
    try
    {
        m_pDDI->TexBlt(dwDestFaceHandle, dwSrcFaceHandle, pPoint, pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }

    // If successful, batch the parents of the source and dest
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    pSrcParent->BatchBase();
    pDstParent->Batch();

    return D3D_OK;
}


//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::VolBlt"
HRESULT __declspec(nothrow)
CD3DBase::VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                 DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox)
{
    try
    {
        m_pDDI->VolBlt(lpDst, lpSrc, dwDestX, dwDestY, dwDestZ, pBox);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::BufBlt"
HRESULT __declspec(nothrow)
CD3DBase::BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                 D3DRANGE* pRange)
{
    try
    {
        m_pDDI->BufBlt(lpDst, lpSrc, dwOffset, pRange);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetPriority"

HRESULT __declspec(nothrow) CD3DBase::SetPriority(CResource *pRes, DWORD dwPriority)
{
    try
    {
        m_pDDI->SetPriority(pRes, dwPriority);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetTexLOD"

HRESULT __declspec(nothrow) CD3DBase::SetTexLOD(CBaseTexture *pTex, DWORD dwLOD)
{
    try
    {
        m_pDDI->SetTexLOD(pTex, dwLOD);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::AddDirtyRect"

HRESULT __declspec(nothrow) CD3DBase::AddDirtyRect(CBaseTexture *pTex, CONST RECTL *pRect)
{
    DXGASSERT(pTex->IsD3DManaged() == 0);
    DXGASSERT(pTex->GetBufferDesc()->Pool == D3DPOOL_MANAGED);
    DXGASSERT((GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
    try
    {
        m_pDDI->AddDirtyRect(pTex->BaseDrawPrimHandle(), pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
    pTex->BatchBase();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::AddCubeDirtyRect"

HRESULT __declspec(nothrow) CD3DBase::AddCubeDirtyRect(CBaseTexture *pTex, DWORD dwFaceHandle, CONST RECTL *pRect)
{
    DXGASSERT(pTex->IsD3DManaged() == 0);
    DXGASSERT(pTex->GetBufferDesc()->Pool == D3DPOOL_MANAGED);
    DXGASSERT((GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
    try
    {
        m_pDDI->AddDirtyRect(dwFaceHandle, pRect);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
    pTex->BatchBase();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::AddDirtyBox"

HRESULT __declspec(nothrow) CD3DBase::AddDirtyBox(CBaseTexture *pTex, CONST D3DBOX *pBox)
{
    DXGASSERT(pTex->IsD3DManaged() == 0);
    DXGASSERT(pTex->GetBufferDesc()->Pool == D3DPOOL_MANAGED);
    DXGASSERT((GetD3DCaps()->Caps2 & DDCAPS2_CANMANAGERESOURCE) != 0);
    try
    {
        m_pDDI->AddDirtyBox(pTex->BaseDrawPrimHandle(), pBox);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
    pTex->BatchBase();
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::OnTextureDestroy"

void __declspec(nothrow) CD3DBase::OnTextureDestroy(CBaseTexture *pTex)
{
    // On a pre-DX8 driver, the code will ensure that if any
    // texture got unset by an API call, the driver will be
    // informed. This needs to be done before calling the
    // driver to destroy a texture handle as we have seen
    // instances of drivers crashing. (snene - 4/24/00)
    if(GetDDIType() < D3DDDITYPE_DX8)
    {
        D3DTEXTUREHANDLE dwDDIHandle = pTex->DriverAccessibleDrawPrimHandle();
        if(dwDDIHandle != 0)
        {
            try
            {
                BOOL bNeedFlush = FALSE;
                for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
                {
                    if(dwDDIHandle == m_dwDDITexHandle[dwStage])
                    {
                        m_pDDI->SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                        m_dwDDITexHandle[dwStage] = 0;
                        bNeedFlush = TRUE;
                    }
                }
                if(bNeedFlush)
                {
                    m_pDDI->FlushStates();
                }
            }
            catch(HRESULT ret)
            {
            }
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::SetRenderStateInternal"

void
CD3DBase::SetRenderStateInternal(D3DRENDERSTATETYPE dwState, DWORD dwValue)
{
    if (CanHandleRenderState(dwState))
        m_pDDI->SetRenderState(dwState, dwValue);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::StateInitialize"

void
CD3DBase::StateInitialize(BOOL bZEnable)
{
    m_rsMax  = m_pDDI->GetMaxRenderState();
    m_tssMax = m_pDDI->GetMaxTSS();

    D3DLINEPATTERN defLPat;
    SetRenderStateInternal(D3DRENDERSTATE_ZENABLE, bZEnable);
    SetRenderStateInternal(D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    SetRenderStateInternal(D3DRENDERSTATE_SHADEMODE, D3DSHADE_GOURAUD);

    defLPat.wRepeatFactor = 0;
    defLPat.wLinePattern = 0;

    SetRenderStateInternal(D3DRENDERSTATE_LINEPATTERN, *((LPDWORD)&defLPat)); /* 10 */

    float tmpval;
    /*
      ((LPD3DSTATE)lpPointer)->drstRenderStateType =
      (D3DRENDERSTATETYPE)D3DRENDERSTATE_LINEPATTERN;
      memcpy(&(((LPD3DSTATE)lpPointer)->dwArg[0]), &defLPat, sizeof(DWORD));
      lpPointer = (void *)(((LPD3DSTATE)lpPointer) + 1);*/

    SetRenderStateInternal(D3DRENDERSTATE_ZWRITEENABLE, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHATESTENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_LASTPIXEL, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE);
    SetRenderStateInternal(D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO);
    SetRenderStateInternal(D3DRENDERSTATE_CULLMODE, D3DCULL_CCW); /* 21 */
    SetRenderStateInternal(D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHAREF, 0);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHAFUNC, D3DCMP_ALWAYS);
    SetRenderStateInternal(D3DRENDERSTATE_DITHERENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_FOGENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_SPECULARENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_ZVISIBLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_FOGCOLOR, 0);
    SetRenderStateInternal(D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    tmpval = 0.0f;
    SetRenderStateInternal(D3DRENDERSTATE_FOGSTART, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal(D3DRENDERSTATE_FOGEND, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal(D3DRENDERSTATE_FOGDENSITY, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRENDERSTATE_EDGEANTIALIAS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_ZBIAS, 0);
    SetRenderStateInternal(D3DRENDERSTATE_RANGEFOGENABLE, FALSE);

    // init stencil states to something reasonable
    // stencil enable is OFF by default since stenciling rasterizers will be
    // faster with it disabled, even if stencil states are benign
    SetRenderStateInternal(D3DRENDERSTATE_STENCILENABLE,   FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILFAIL,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILZFAIL,    D3DSTENCILOP_KEEP);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILPASS,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILFUNC,     D3DCMP_ALWAYS);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILREF,      0);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILMASK,     0xFFFFFFFF);
    SetRenderStateInternal(D3DRENDERSTATE_STENCILWRITEMASK,0xFFFFFFFF);

    // don't forget about texturefactor (like we did in DX6.0...)
    SetRenderStateInternal(D3DRENDERSTATE_TEXTUREFACTOR,   0xFFFFFFFF);

    for (DWORD i = 0; i < 8; i++)
    {
        SetRenderStateInternal((D3DRENDERSTATETYPE)
                        (D3DRENDERSTATE_WRAPBIAS + i), FALSE);
    }
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        m_lpD3DMappedTexI[i] = NULL;
        m_dwDDITexHandle[i] = 0;
    }
    m_dwStageDirty = 0;

    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        SetTexture(i, NULL);
        if (i == 0)
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_MODULATE);
        else
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_COLORARG2, D3DTA_CURRENT);
        if (i == 0)
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        else
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT00, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT01, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT10, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT11, 0);
        SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, i);
        SetTextureStageState(i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_BORDERCOLOR, 0x00000000);
        SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_POINT);
        SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_NONE);
        SetTextureStageState(i, D3DTSS_MIPMAPLODBIAS, 0);
        SetTextureStageState(i, D3DTSS_MAXMIPLEVEL, 0);
        SetTextureStageState(i, D3DTSS_MAXANISOTROPY, 1);
        SetTextureStageState(i, D3DTSS_BUMPENVLSCALE, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVLOFFSET, 0);
        SetTextureStageState(i, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        SetTextureStageState(i, D3DTSS_ADDRESSW, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_COLORARG0, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_ALPHAARG0, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_RESULTARG, D3DTA_CURRENT);
    }

    SetRenderStateInternal(D3DRENDERSTATE_CLIPPING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_LIGHTING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_AMBIENT, 0);
    SetRenderStateInternal(D3DRENDERSTATE_FOGVERTEXMODE, D3DFOG_NONE);
    SetRenderStateInternal(D3DRENDERSTATE_COLORVERTEX, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_LOCALVIEWER, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_NORMALIZENORMALS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,  D3DMCS_COLOR1);
    SetRenderStateInternal(D3DRENDERSTATE_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
    SetRenderStateInternal(D3DRENDERSTATE_AMBIENTMATERIALSOURCE,  D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_VERTEXBLEND, D3DVBF_DISABLE);
    SetRenderStateInternal(D3DRENDERSTATE_CLIPPLANEENABLE, 0);

    //
    // new for DX8
    //
    SetRenderStateInternal(D3DRS_SOFTWAREVERTEXPROCESSING, 0);

    tmpval = GetD3DCaps()->MaxPointSize;
    if (tmpval == 0)
        tmpval = __MAX_POINT_SIZE;
    SetRenderStateInternal(D3DRS_POINTSIZE_MAX, *((DWORD *)&tmpval));

    tmpval = 1.F;
    SetRenderStateInternal(D3DRS_POINTSIZE, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRS_POINTSIZE_MIN, 0);
    SetRenderStateInternal(D3DRS_POINTSPRITEENABLE, 0);
    SetRenderStateInternal(D3DRS_POINTSCALEENABLE , 0);
    SetRenderStateInternal(D3DRS_POINTSCALE_A, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRS_POINTSCALE_B, 0);
    SetRenderStateInternal(D3DRS_POINTSCALE_C, 0);

    SetRenderStateInternal(D3DRS_MULTISAMPLEMASK, 0xffffffff);
    SetRenderStateInternal(D3DRS_MULTISAMPLEANTIALIAS, TRUE);

    SetRenderStateInternal(D3DRS_PATCHEDGESTYLE, D3DPATCHEDGE_DISCRETE);
    tmpval = 1.F;
    SetRenderStateInternal(D3DRS_PATCHSEGMENTS, *((DWORD *)&tmpval));
    SetRenderStateInternal(D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);

    SetRenderStateInternal(D3DRS_COLORWRITEENABLE, 0xF);

    tmpval = 0.F;
    SetRenderStateInternal(D3DRS_TWEENFACTOR, *((DWORD *)&tmpval));

    SetRenderStateInternal(D3DRS_BLENDOP, D3DBLENDOP_ADD);

    // New for DX8.1

    SetRenderStateInternal(D3DRS_POSITIONORDER, D3DORDER_CUBIC);
    SetRenderStateInternal(D3DRS_NORMALORDER, D3DORDER_LINEAR);

    // Initialize the transform state
    D3DMATRIXI m;
    setIdentity(&m);
    this->SetTransform(D3DTS_VIEW, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_PROJECTION, (D3DMATRIX*)&m);
    {
        for (UINT i=0; i < __MAXWORLDMATRICES; i++)
            this->SetTransform(D3DTS_WORLDMATRIX(i),  (D3DMATRIX*)&m);
    }
    this->SetTransform(D3DTS_TEXTURE0, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE1, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE2, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE3, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE4, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE5, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE6, (D3DMATRIX*)&m);
    this->SetTransform(D3DTS_TEXTURE7, (D3DMATRIX*)&m);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::UpdatePalette"

void CD3DBase::UpdatePalette(CBaseTexture *pTex, DWORD Palette, DWORD dwStage, BOOL bSavedWithinPrimitive)
{
    try
    {
        if(Palette == __INVALIDPALETTE)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Current palette not set");
        }
        if(pTex->GetPalette() != Palette)
        {
            DWORD dwFlags = DDRAWIPAL_256 | DDRAWIPAL_ALLOW256;
            if (Enum()->GetAppSdkVersion() > D3D_SDK_VERSION_DX8)
            {
                if ((GetD3DCaps()->TextureCaps & D3DPTEXTURECAPS_ALPHAPALETTE) &&
                   (pTex->GetBufferDesc()->Format != D3DFMT_A8P8) )
                {
                    dwFlags |= DDRAWIPAL_ALPHA;
                }
            }
            else
            {
                //This odd selection of formats to receive the palette flag
                //is inherited from DX8. It is wrong, but left in for app-compat reasons.
                if (pTex->GetBufferDesc()->Format != D3DFMT_A8P8)
                {
                    dwFlags |= DDRAWIPAL_ALPHA;
                }
            }
            m_pDDI->SetPalette(Palette,
                               dwFlags,
                               pTex);
        }
        CPalette *pal = static_cast<CPalette*>((*m_pPaletteArray)[Palette].m_pObj);
        if(pal->m_dirty)
        {
            m_pDDI->UpdatePalette(Palette, 0, 256, pal->m_pEntries);
            pal->m_dirty = FALSE;
        }
    }
    catch(HRESULT ret)
    {
        try
        {
            m_pDDI->SetTSS(dwStage,
                           (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP,
                           0);
        }
        catch(HRESULT ret)
        {
            m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
            D3D_THROW(ret, "");
        }
        m_dwDDITexHandle[dwStage] = 0;
        m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
        D3D_THROW(ret, "");
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::UpdateTextures"

void CD3DBase::UpdateTextures()
{
    BOOL bSavedWithinPrimitive = m_pDDI->GetWithinPrimitive();
    m_pDDI->SetWithinPrimitive(TRUE);
    for (DWORD dwStage = 0, StageMask = 1; dwStage < m_dwMaxTextureBlendStages; dwStage++, StageMask <<= 1)
    {
        D3DTEXTUREHANDLE dwDDIHandle;
        BOOL bDirty = (m_dwStageDirty & StageMask) != 0;
        m_dwStageDirty &= ~StageMask; // reset stage dirty
        CBaseTexture *lpTexI = m_lpD3DMappedTexI[dwStage];
        if(lpTexI)
        {
#if DBG
            if (lpTexI->IsTextureLocked())
            {
                DPF_ERR("Cannot update a locked texture. Texture will be disabled.");
                dwDDIHandle = 0; //tell driver to disable this texture
            }
            else
            {
#endif // DBG
            if (lpTexI->IsD3DManaged())
            {
                HRESULT hr = ResourceManager()->UpdateVideo(lpTexI->RMHandle(), &bDirty);
                if (FAILED(hr))
                {
                    DPF_ERR("The resource manager failed to promote or update a dirty texture. The texture will be disabled.");
                    dwDDIHandle = 0; //tell driver to disable this texture
                }
                else
                {
                    if (lpTexI->IsPaletted())
                    {
                        // UpdatePalette can THROW but it safely handles bSavedWithinPrimitive
                        UpdatePalette(lpTexI, m_dwPalette, dwStage, bSavedWithinPrimitive);
                    }
                    if (!bDirty)
                    {
                        continue; // Ok, then nothing needs to be done further
                    }
                    dwDDIHandle = static_cast<CMgmtInfo*>(lpTexI->RMHandle())->m_pRes->BaseDrawPrimHandle();
                }
            }
            else
            {
                if (lpTexI->IsPaletted())
                {
                    // UpdatePalette can THROW but it safely handles bSavedWithinPrimitive
                    UpdatePalette(lpTexI, m_dwPalette, dwStage, bSavedWithinPrimitive);
                }
                if (!bDirty)
                {
                    continue; // Ok, then nothing needs to be done further
                }
                dwDDIHandle = lpTexI->BaseDrawPrimHandle();
            }
#if DBG
            }
#endif // DBG
        }
        else if (bDirty)
        {
            dwDDIHandle = 0; //tell driver to disable this texture
        }
        else
        {
            continue;
        }

        try
        {
            m_pDDI->SetTSS(dwStage,
                           (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP,
                           dwDDIHandle);
        }
        catch (HRESULT ret)
        {
            m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
            D3D_THROW(ret, "");
        }

        m_dwDDITexHandle[dwStage] = dwDDIHandle;
        if (lpTexI != 0)
        {
            lpTexI->Batch();
        }
    }
    m_pDDI->SetWithinPrimitive( bSavedWithinPrimitive );
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::IncrementBatch"

void CD3DBase::IncrementBatchCount()
{
    DXGASSERT(m_qwBatch > 0);
    m_qwBatch++;

    // Also we need to update the
    // batch counts of our currently set
    // render target and z

    // Batch the current RT
    // RT could be gone during Reset()
    if (RenderTarget() != 0)
    {
        RenderTarget()->Batch();
    }

    if (ZBuffer() != 0)
    {
        // Update the batch count for the current Zbuffer
        ZBuffer()->Batch();
    }

    // So that currently bound textures get rebatched
    for (DWORD dwStage = 0; dwStage < m_dwMaxTextureBlendStages; dwStage++)
    {
        CBaseTexture *lpTexI = m_lpD3DMappedTexI[dwStage];
        if (NULL != lpTexI)
        {
            lpTexI->Batch();
        }
    }

} // IncrementBatch
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetMaterial"

HRESULT D3DAPI
CD3DBase::GetMaterial(D3DMATERIAL8*)
{
    API_ENTER(this);
    D3D_ERR("GetMaterial does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetTransform"

HRESULT D3DAPI
CD3DBase::GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX)
{
    API_ENTER(this);
    D3D_ERR("GetTransform does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetLight"

HRESULT D3DAPI
CD3DBase::GetLight(DWORD, D3DLIGHT8*)
{
    API_ENTER(this);
    D3D_ERR("GetLight does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetLightEnable"

HRESULT D3DAPI
CD3DBase::GetLightEnable(DWORD dwLightIndex, BOOL*)
{
    API_ENTER(this);
    D3D_ERR("GetLightEnable does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetClipPlane"

HRESULT D3DAPI
CD3DBase::GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    API_ENTER(this);
    D3D_ERR("GetClipPlane does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetTextureStageState"

HRESULT D3DAPI
CD3DBase::GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, LPDWORD)
{
    API_ENTER(this);
    D3D_ERR("GetTextureStageState does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetViewport"

HRESULT D3DAPI
CD3DBase::GetViewport(D3DVIEWPORT8*)
{
    API_ENTER(this);
    D3D_ERR("GetViewport does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetRenderState"

HRESULT D3DAPI
CD3DBase::GetRenderState(D3DRENDERSTATETYPE, LPDWORD)
{
    API_ENTER(this);
    D3D_ERR("GetRenderState does not work in pure-device");
    return D3DERR_INVALIDCALL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShaderConstant"

HRESULT D3DAPI
CD3DBase::GetPixelShaderConstant(DWORD dwRegisterAddress,
                                 LPVOID lpvConstantData,
                                 DWORD dwConstantCount)
{
    API_ENTER(this);
    D3D_ERR("GetPixelShaderConstant does not work in pure-device");
    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShaderConstant"

HRESULT D3DAPI
CD3DBase::GetVertexShaderConstant(DWORD dwRegisterAddress,
                                   LPVOID lpvConstantData,
                                   DWORD dwConstantCount)
{
    API_ENTER(this);
    D3D_ERR("GetVertexShaderConstant does not work in pure-device");
    return E_NOTIMPL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShaderDeclaration"

HRESULT D3DAPI
CD3DBase::GetVertexShaderDeclaration(DWORD dwHandle, void *pData,
                                     DWORD *pSizeOfData)
{
    API_ENTER(this);
    try
    {
#if DBG
        if (!(VALID_WRITEPTR(pSizeOfData, sizeof(*pSizeOfData))))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data size pointer");
        }
        if (pData && !(VALID_WRITEPTR(pData, *pSizeOfData)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
        }
#endif
        if (D3DVSD_ISLEGACY(dwHandle))
        {
            *pSizeOfData = 0;
            D3D_THROW(D3DERR_INVALIDCALL, "Legacy vertex shaders do not have declaration");
        }
        else
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if (pShader == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
            }
            if (pData)
            {
                if (*pSizeOfData < pShader->m_OrgDeclSize)
                {
                    D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
                }
                memcpy(pData, pShader->m_pOrgDeclaration, pShader->m_OrgDeclSize);
            }
            *pSizeOfData = pShader->m_OrgDeclSize;
        }
    }
    catch (HRESULT ret)
    {
        DPF_ERR("GetVertexShaderDeclaration failed.");
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetVertexShaderFunction"

HRESULT D3DAPI
CD3DBase::GetVertexShaderFunction(DWORD dwHandle, void *pData,
                                  DWORD *pSizeOfData)
{
    API_ENTER(this);
    try
    {
#if DBG
        if (!(VALID_WRITEPTR(pSizeOfData, sizeof(*pSizeOfData))))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data size pointer");
        }
        if (pData && !(VALID_WRITEPTR(pData, *pSizeOfData)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
        }
#endif
        if (D3DVSD_ISLEGACY(dwHandle))
        {
            *pSizeOfData = 0;
            D3D_THROW(D3DERR_INVALIDCALL, "Legacy vertex shaders do not have function code");
        }
        else
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if (pShader == NULL)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
            }
            if (pData)
            {
                if (*pSizeOfData < pShader->m_OrgFuncCodeSize)
                {
                    D3D_THROW(D3DERR_INVALIDCALL, "Invalid data buffer size");
                }
                memcpy(pData, pShader->m_pOrgFuncCode, pShader->m_OrgFuncCodeSize);
            }
            *pSizeOfData = pShader->m_OrgFuncCodeSize;
        }
    }
    catch (HRESULT ret)
    {
        DPF_ERR("GetVertexShaderFunction failed.");
        return ret;
    }
    return S_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::GetPixelShaderFunction"

HRESULT D3DAPI
CD3DBase::GetPixelShaderFunction(DWORD dwHandle, void *pData,
                                 DWORD *pSizeOfData)
{
    API_ENTER(this);
    try
    {
#if DBG
        if (!(VALID_WRITEPTR(pSizeOfData, sizeof(*pSizeOfData))))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data size pointer");
        }
        if (pData && !(VALID_WRITEPTR(pData, *pSizeOfData)))
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid data pointer");
        }
#endif
        CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid pixel shader handle");
        }
        if (pData)
        {
            if (*pSizeOfData < pShader->m_dwCodeSizeOrig)
            {
                D3D_THROW(D3DERR_INVALIDCALL, "Invalid data buffer size");
            }
            memcpy(pData, pShader->m_pCodeOrig, pShader->m_dwCodeSizeOrig);
        }
        *pSizeOfData = pShader->m_dwCodeSizeOrig;
    }
    catch (HRESULT ret)
    {
        DPF_ERR("GetPixelShaderFunction failed");
        return ret;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3ddev.cpp
 *  Content:    Direct3D device implementation
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: device.c,v 1.26 1995/12/04 11:29:47 sjl Exp $
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "drawprim.hpp"
#include "fe.h"
#include "enum.hpp"

//#define APIPROF
#ifdef APIPROF
#include "apiprof.cpp"
#endif //APIPROF

#if defined(PROFILE4)
#include <icecap.h>
#elif defined(PROFILE)
#include <icapexp.h>
#endif

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

extern void setIdentity(D3DMATRIXI * m);

#ifndef PROFILE4
#ifdef _X86_
extern HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI wlmt_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI x3DContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
#endif
#endif

#ifdef _X86_
extern BOOL IsWin95();
#endif

extern HINSTANCE hMsGeometryDLL;

// This is a list of all rstates that UpdateInternalState does some
// work other than updating this->rstates[] array. This is used to
// do a quick bitwise check to see if this rstate is trivial or not.

const D3DRENDERSTATETYPE rsList[] = {

    // renderstates that either need runtime attention or that cannot be sent
    // to legacy drivers
    D3DRENDERSTATE_FOGENABLE,
    D3DRENDERSTATE_SPECULARENABLE,
    D3DRENDERSTATE_RANGEFOGENABLE,
    D3DRENDERSTATE_FOGDENSITY,
    D3DRENDERSTATE_FOGSTART,
    D3DRENDERSTATE_FOGEND,
    D3DRENDERSTATE_WRAP0,
    D3DRENDERSTATE_WRAP1,
    D3DRENDERSTATE_WRAP2,
    D3DRENDERSTATE_WRAP3,
    D3DRENDERSTATE_WRAP4,
    D3DRENDERSTATE_WRAP5,
    D3DRENDERSTATE_WRAP6,
    D3DRENDERSTATE_WRAP7,
    D3DRENDERSTATE_CLIPPING,
    D3DRENDERSTATE_LIGHTING,
    D3DRENDERSTATE_AMBIENT,
    D3DRENDERSTATE_FOGVERTEXMODE,
    D3DRENDERSTATE_COLORVERTEX,
    D3DRENDERSTATE_LOCALVIEWER,
    D3DRENDERSTATE_NORMALIZENORMALS,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
    D3DRENDERSTATE_VERTEXBLEND,
    D3DRENDERSTATE_CLIPPLANEENABLE,
    D3DRENDERSTATE_SHADEMODE,
    D3DRS_SOFTWAREVERTEXPROCESSING,
    D3DRS_POINTSIZE,
    D3DRS_POINTSIZE_MIN,
    D3DRS_POINTSPRITEENABLE,
    D3DRS_POINTSCALEENABLE,
    D3DRS_POINTSCALE_A,
    D3DRS_POINTSCALE_B,
    D3DRS_POINTSCALE_C,
    D3DRS_MULTISAMPLEANTIALIAS,
    D3DRS_MULTISAMPLEMASK,
    D3DRS_PATCHEDGESTYLE,
    D3DRS_PATCHSEGMENTS,
    D3DRS_DEBUGMONITORTOKEN,
    D3DRS_POINTSIZE_MAX,
    D3DRS_INDEXEDVERTEXBLENDENABLE,
    D3DRS_COLORWRITEENABLE,
    D3DRS_TWEENFACTOR,
    D3DRS_DEBUGMONITORTOKEN,
    D3DRS_BLENDOP,
    D3DRS_PATCHSEGMENTS,

    // Retired renderstates to be filtered with DPF error and INVALID return
    // NOTE: everything listed here is also assumed to appear in rsListRetired
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
    // newly retired for DX8
    D3DRENDERSTATE_ANTIALIAS,
    D3DRENDERSTATE_TEXTUREPERSPECTIVE,
    D3DRENDERSTATE_COLORKEYENABLE,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_STIPPLEDALPHA,

};

// list of retired renderstates - need to make sure these are
// filtered and never get from app directly to driver
const D3DRENDERSTATETYPE rsListRetired[] = {
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
    // newly retired for DX8
    D3DRENDERSTATE_ANTIALIAS,
    D3DRENDERSTATE_TEXTUREPERSPECTIVE,
    D3DRENDERSTATE_COLORKEYENABLE,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_STIPPLEDALPHA,
};

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DHal                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
CD3DHal::CD3DHal()
{
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // DO NOT PUT INITIALIZATION IN THE CONSTRUCTOR.
    // Put it in Init() instead. This is because the device can be
    // "Destroy()ed" and "Init()ed" anytime via Reset. In this
    // situation, the constructor is never called. (snene 01/00)
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::StateInitialize"

void CD3DHal::StateInitialize(BOOL bZEnable)
{
    DWORD i,j;

    // Initialize the bit array indicating the rstates needing non-trivial
    // work.
    for (i=0; i < sizeof(rsList) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVec.SetBit(rsList[i]);
    // Initialize the bit array indicating the retired rstates
    for (i=0; i < sizeof(rsListRetired) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVecRetired.SetBit(rsListRetired[i]);
    // Initialize the bit array indicating the vertex processing only rstates
    for (i=0; i < sizeof(rsVertexProcessingList) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVertexProcessingOnly.SetBit(rsVertexProcessingList[i]);

    // Obviate Set(Render;TextureStage)State filtering 'redundant' device state settings
    // since this is the init step.
//    memset( this->rstates, 0xff, sizeof(DWORD)*D3D_MAXRENDERSTATES);
    for (i=0; i<D3D_MAXRENDERSTATES; i++)
        this->rstates[i] = 0xbaadcafe;
//    memset( this->tsstates, 0xff, sizeof(DWORD)*D3DHAL_TSS_MAXSTAGES*D3DHAL_TSS_STATESPERSTAGE );
    for (j=0; j<D3DHAL_TSS_MAXSTAGES; j++)
        for (i=0; i<D3DHAL_TSS_STATESPERSTAGE; i++)
            this->tsstates[j][i] = 0xbaadcafe;

    CD3DBase::StateInitialize(bZEnable);

    if (GetDDIType() < D3DDDITYPE_DX8)
    {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREPERSPECTIVE, TRUE);
        SetRenderStateInternal(D3DRENDERSTATE_COLORKEYENABLE, FALSE);
        SetRenderStateInternal(D3DRENDERSTATE_COLORKEYBLENDENABLE, FALSE);
        SetRenderStateInternal(D3DRENDERSTATE_STIPPLEDALPHA, FALSE);
    }

    if (GetDDIType() < D3DDDITYPE_DX7)
    {
        // send retired renderstate init's to pre-DX7 HALs only
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_MONOENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ROP2, R2_COPYPEN);
        SetRenderStateInternal( D3DRENDERSTATE_PLANEMASK, (DWORD)~0);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPU, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPV, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ANTIALIAS, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXEL, FALSE); /* 30 */
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXELX, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN00, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN01, 0); /* 40 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN02, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN03, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN04, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN05, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN06, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN07, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN08, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN09, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN10, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN11, 0); /* 50 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN12, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN13, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN14, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN15, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN16, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN17, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN18, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN19, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN20, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN21, 0); /* 60 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN22, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN23, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN24, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN25, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN26, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN27, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN28, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN29, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN30, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN31, 0); /* 70 */
    }

    if( BehaviorFlags() & D3DCREATE_SOFTWARE_VERTEXPROCESSING )
    {
        SwitchVertexProcessingMode(TRUE);
        rstates[D3DRS_SOFTWAREVERTEXPROCESSING] = TRUE;
    }
    else if( BehaviorFlags() & D3DCREATE_HARDWARE_VERTEXPROCESSING )
    {
        SwitchVertexProcessingMode(FALSE);
        rstates[D3DRS_SOFTWAREVERTEXPROCESSING] = FALSE;
    }
    else if( BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING )
    {
        SetRenderStateInternal( D3DRS_SOFTWAREVERTEXPROCESSING, 0);
    }
    else
    {
        D3D_INFO( 0, "No Vertex Processing behavior specified, assuming software" );
        SwitchVertexProcessingMode(TRUE);
        rstates[D3DRS_SOFTWAREVERTEXPROCESSING] = TRUE;
    }
}

/*
 * Initialisation - class part and device part
 */

//---------------------------------------------------------------------
HRESULT CD3DHal::D3DFE_Create()
{
    DDSURFACEDESC ddsd;
    HRESULT hr;
    const D3DCAPS8 *pCaps = GetD3DCaps();

    if (m_pDDI->GetDDIType() < D3DDDITYPE_DX7)
    {
        m_dwRuntimeFlags |= D3DRT_ONLY2FLOATSPERTEXTURE;
    }
    else
    if (m_pDDI->GetDDIType() < D3DDDITYPE_DX8)
    {
        // Some drivers (G200, G400) cannot handle more than 2 floats in
        // texture coordinates, even they are supposed to. We set the
        // runtime bit to mark such drivers and compute output FVF for vertex
        // shaders accordingly
        if (!(pCaps->TextureCaps & D3DPTEXTURECAPS_PROJECTED ||
              pCaps->TextureCaps & D3DPTEXTURECAPS_CUBEMAP))
        {
            m_dwRuntimeFlags |= D3DRT_ONLY2FLOATSPERTEXTURE;
        }
    }
    if (!(pCaps->TextureCaps & D3DPTEXTURECAPS_PROJECTED))
        m_dwRuntimeFlags |= D3DRT_EMULATEPROJECTEDTEXTURE;

    if (pCaps && pCaps->FVFCaps)
    {
        this->m_pv->dwMaxTextureIndices =
            pCaps->FVFCaps & D3DFVFCAPS_TEXCOORDCOUNTMASK;
        if (pCaps->FVFCaps & D3DFVFCAPS_DONOTSTRIPELEMENTS)
            this->m_pv->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;

        DWORD value;
        if ((GetD3DRegValue(REG_DWORD, "DisableStripFVF", &value, 4) &&
            value != 0))
        {
            this->m_pv->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;
        }
    }
    else
    {
        this->m_pv->dwMaxTextureIndices = 1;
    }

    this->dwFEFlags |= D3DFE_FRONTEND_DIRTY;

#if DBG
    this->dwCaller=0;
    memset(this->dwPrimitiveType,0,sizeof(this->dwPrimitiveType));
    memset(this->dwVertexType1,0,sizeof(this->dwVertexType1));
    memset(this->dwVertexType2,0,sizeof(this->dwVertexType2));
#endif

    // True for software rendering
    m_dwNumStreams = __NUMSTREAMS;
    m_dwMaxUserClipPlanes = __MAXUSERCLIPPLANES;

    this->m_pv->dwClipMaskOffScreen = 0xFFFFFFFF;
    if (pCaps != NULL)
    {
        if (pCaps->GuardBandLeft   != 0.0f ||
            pCaps->GuardBandRight  != 0.0f ||
            pCaps->GuardBandTop    != 0.0f ||
            pCaps->GuardBandBottom != 0.0f)
        {
            this->m_pv->dwDeviceFlags |= D3DDEV_GUARDBAND;
            this->m_pv->dwClipMaskOffScreen = ~__D3DCS_INGUARDBAND;
            DWORD v;
            if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
                v != 0)
            {
                this->m_pv->dwDeviceFlags &= ~D3DDEV_GUARDBAND;
                this->m_pv->dwClipMaskOffScreen = 0xFFFFFFFF;
            }
#if DBG
            // Try to get test values for the guard band
            char value[80];
            if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandLeft);
            if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandRight);
            if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandTop);
            if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &pCaps->GuardBandBottom);
#endif // DBG
        }
    }

    LIST_INITIALIZE(&this->specular_tables);
    this->specular_table = NULL;

    this->lightVertexFuncTable = &lightVertexTable;
    m_pv->lighting.activeLights = NULL;

    this->m_ClipStatus.ClipUnion = 0;
    this->m_ClipStatus.ClipIntersection = ~0;

    m_pv->pDDI = m_pDDI;

    return S_OK;
}

void CD3DHal::D3DFE_Destroy()
{
// Destroy lighting data

    SpecularTable *spec;
    SpecularTable *spec_next;

    for (spec = LIST_FIRST(&this->specular_tables); spec; spec = spec_next)
    {
        spec_next = LIST_NEXT(spec,list);
        D3DFree(spec);
    }
    LIST_INITIALIZE(&specular_tables);

    delete m_pLightArray;
    m_pLightArray = NULL;

    delete m_pv;
    m_pv = NULL;

    delete m_pConvObj;
    m_pConvObj = NULL;

    if (m_clrRects)
    {
        D3DFree(m_clrRects);
        m_clrRects = NULL;
    }
}

/*
 * Generic device part destroy
 */
CD3DHal::~CD3DHal()
{
    Destroy();
}

void
CD3DHal::Destroy()
{
    try // Since Destroy() can be called directly by fw
    {
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // MUST CLEANUP AND RELEASE CURRENTLY SET TEXTURES BEFORE
        // DOING ANY OTHER WORK, else we will get into situations
        // where we are calling FlushStates or batching DDI tokens.
        CleanupTextures();
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        /* Clear flags that could prohibit cleanup */
        m_dwHintFlags &=  ~(D3DDEVBOOL_HINTFLAGS_INSCENE);

        // Destroy vertex shaders. We need to delete vertex shaders completely
        // to preserve behavior for DX8.0 apps. For DX8.1 apps we delete only
        // PSGP part of a vertex shader. The rest will be used to re-create 
        // the shader during Reset()
        if (m_pVShaderArray != NULL)
        {
            UINT size = m_pVShaderArray->GetSize();
            for (UINT i=0; i < size; i++)
            {
                UINT Handle = m_pVShaderArray->HandleFromIndex(i);
                CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(Handle);
                if (pShader)
                {
                    if (Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8)
                    {
                        m_pVShaderArray->ReleaseHandle(Handle, TRUE);
                    }
                    else
                    {
                        // We need to delete PSGP shader object before deleting
                        // D3DFE_PROCESSVERTICES object, because AMD has keeps a 
                        // pointer to it inside the code object
                        if (pShader->m_dwFlags & CVShader::SOFTWARE)
                        {
                            delete pShader->m_pCode;
                            pShader->m_pCode = NULL;
                        }
                    }
                }
            }
        }
        
        // Destroy pixel shaders for DX8.0 apps to preserve trhe original behavior
        if (m_pPShaderArray != NULL)
        {
            UINT size = m_pPShaderArray->GetSize();
            for (UINT i=0; i < size; i++)
            {
                UINT Handle = m_pPShaderArray->HandleFromIndex(i);
                CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(Handle);
                if (pShader)
                {
                    if (Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8)
                    {
                        m_pPShaderArray->ReleaseHandle(Handle, TRUE);
                    }
                }
            }
        }

        if (m_pv)
        {
            if ( 0 != m_pv->pGeometryFuncs &&
                (LPVOID)m_pv->pGeometryFuncs != (LPVOID)GeometryFuncsGuaranteed)
            {
                delete m_pv->pGeometryFuncs;
                m_pv->pGeometryFuncs = 0;
            }

            if ( 0 != GeometryFuncsGuaranteed)
            {
                delete GeometryFuncsGuaranteed;
                GeometryFuncsGuaranteed = 0;
                m_pv->pGeometryFuncs = 0;
            }
        }

        this->D3DFE_Destroy();

        if ( 0 != rstates)
        {
            delete[] rstates;
            rstates = 0;
        }

        delete pMatrixDirtyForDDI;
        pMatrixDirtyForDDI = NULL;

        CD3DBase::Destroy();
    }
    catch(HRESULT ret)
    {
        DPF_ERR("There was some error when Reset()ing the device; as a result some resources may not be freed.");
    }
}

/*
 * Create a device.
 *
 * This method
 * implements the CreateDevice method of the CEnum object. (The CEnum
 * object exposes the IDirect3D8 interface which supports enumeration
 * etc.)
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME "CEnum::CreateDevice"

STDMETHODIMP CEnum::CreateDevice(
        UINT                    iAdapter,
        D3DDEVTYPE              DeviceType,
        HWND                    hwndFocusWindow,
        DWORD                   dwFlags,
        D3DPRESENT_PARAMETERS  *pPresentationParams,
        IDirect3DDevice8      **ppNewInterface)
{
    API_ENTER(this);

    PD3D8_DEVICEDATA pDD;
    LPD3DBASE        pd3ddev;
    HRESULT          ret = D3D_OK;
    VOID*            pInit = NULL;

    if (!VALID_PTR_PTR(ppNewInterface))
    {
        DPF_ERR("Invalid IDirect3DDevice8* pointer, CreateDevice fails");
        return D3DERR_INVALIDCALL;
    }

    // Zero out out parameters
    *ppNewInterface = NULL;

    if (!VALID_PTR(pPresentationParams, sizeof(D3DPRESENT_PARAMETERS)))
    {
        DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer, CreateDevice fails");
        return D3DERR_INVALIDCALL;
    }

    // Check that fullscreen parameters are correct
    if (pPresentationParams->Windowed)
    {
        if (pPresentationParams->FullScreen_RefreshRateInHz != 0)
        {
            DPF_ERR("FullScreen_RefreshRateInHz must be zero for windowed mode. CreateDevice fails.");
            return D3DERR_INVALIDCALL;
        }
        if (pPresentationParams->FullScreen_PresentationInterval != 0)
        {
            DPF_ERR("FullScreen_PresentationInterval must be zero for windowed mode. CreateDevice fails.");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        DWORD interval = pPresentationParams->FullScreen_PresentationInterval;
        switch (interval)
        {
        case D3DPRESENT_INTERVAL_DEFAULT:
        case D3DPRESENT_INTERVAL_ONE:
        case D3DPRESENT_INTERVAL_TWO:
        case D3DPRESENT_INTERVAL_THREE:
        case D3DPRESENT_INTERVAL_FOUR:
        case D3DPRESENT_INTERVAL_IMMEDIATE:
            break;
        default:
            DPF_ERR("Invalid value for FullScreen_PresentationInterval. CreateDevice Fails.");
            return D3DERR_INVALIDCALL;
        }
    }
    if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
    {
        DPF_ERR("Invalid backbuffer format specified. CreateDevice fails.");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParams->Flags & ~D3DPRESENTFLAG_LOCKABLE_BACKBUFFER)
    {
        DPF_ERR("Invalid flag for Flags. CreateDevice fails.");
        return D3DERR_INVALIDCALL;
    }

    // Validate the HWNDs that we are given
    if (hwndFocusWindow && !IsWindow(hwndFocusWindow))
    {
        DPF_ERR("Invalid HWND specified for hwndFocusWindow, CreateDevice fails");
        return D3DERR_INVALIDCALL;
    }
    if (pPresentationParams->hDeviceWindow && !IsWindow(pPresentationParams->hDeviceWindow))
    {
        DPF_ERR("Invalid HWND specified for PresentationParams.hDeviceWindow. CreateDevice fails.");
        return D3DERR_INVALIDCALL;
    }

    // Make sure that we are given a focus window or a device window
    if (NULL == hwndFocusWindow)
    {
        if (!pPresentationParams->Windowed)
        {
            DPF_ERR("Fullscreen CreateDevice must specify Focus window");
            return D3DERR_INVALIDCALL;
        }
        else
        if (NULL == pPresentationParams->hDeviceWindow)
        {
            DPF_ERR("Neither hDeviceWindow nor Focus window specified. CreateDevice Failed.");
            return D3DERR_INVALIDCALL;
        }
    }

    if (iAdapter >= m_cAdapter)
    {
        DPF_ERR("Invalid iAdapter parameter passed to CreateDevice");
        return D3DERR_INVALIDCALL;
    }

    if (dwFlags & ~VALID_D3DCREATE_FLAGS)
    {
        DPF_ERR("Invalid BehaviorFlags passed to CreateDevice");
        return D3DERR_INVALIDCALL;
    }

    // Check that exactly one of the vertex processing flags is set
    DWORD dwVertexProcessingFlags = dwFlags & (D3DCREATE_HARDWARE_VERTEXPROCESSING |
                                               D3DCREATE_SOFTWARE_VERTEXPROCESSING |
                                               D3DCREATE_MIXED_VERTEXPROCESSING);

    if (dwVertexProcessingFlags != D3DCREATE_HARDWARE_VERTEXPROCESSING &&
        dwVertexProcessingFlags != D3DCREATE_SOFTWARE_VERTEXPROCESSING &&
        dwVertexProcessingFlags != D3DCREATE_MIXED_VERTEXPROCESSING)
    {
        DPF_ERR("Invalid Flags parameter to CreateDevice: Exactly One of the"
                " following must be set: D3DCREATE_HARDWARE_VERTEXPROCESSING,"
                " D3DCREATE_SOFTWARE_VERTEXPROCESSING or"
                " D3DCREATE_MIXED_VERTEXPROCESSING");
        return D3DERR_INVALIDCALL;
    }


    if (DeviceType == D3DDEVTYPE_SW)
    {
        pInit = m_pSwInitFunction;
        if (pInit == NULL)
        {
            D3D_ERR("App specified D3DDEVTYPE_SW without first registering a software device. CreateDevice Failed.");
            return D3DERR_INVALIDCALL;
        }
        GetSwCaps(iAdapter);
    }
    else if (DeviceType == D3DDEVTYPE_REF)
    {
        GetRefCaps(iAdapter);
    }

    ret = InternalDirectDrawCreate(&pDD,
                                   &m_AdapterInfo[iAdapter],
                                   DeviceType,
                                   pInit,
                                   GetUnknown16(iAdapter),
                                   m_AdapterInfo[iAdapter].HALCaps.pGDD8SupportedFormatOps,
                                   m_AdapterInfo[iAdapter].HALCaps.GDD8NumSupportedFormatOps);
    if( FAILED(ret) )
    {
        D3D_ERR("Failed to create DirectDraw. CreateDevice Failed.");
        return ret;
    }

    if((dwFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING) != 0)
    {
        if((dwFlags & D3DCREATE_PUREDEVICE) != 0)
        {
            D3D_ERR("Pure device cannot perform software processing. CreateDevice Failed.");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }
    else if((dwFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING) != 0)
    {
        if((pDD->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) 
           == 0)
        {
            D3D_ERR("Device cannot perform hardware processing");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }
    else if((dwFlags & D3DCREATE_MIXED_VERTEXPROCESSING) != 0)
    {
        if((pDD->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0 ||
           (dwFlags & D3DCREATE_PUREDEVICE) != 0)
        {
            D3D_ERR("Device cannot perform mixed processing because driver cannot do hardware T&L. CreateDevice Failed.");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        if((dwFlags & D3DCREATE_PUREDEVICE) != 0)
        {
            if((pDD->DriverData.D3DCaps.DevCaps & D3DDEVCAPS_PUREDEVICE) == 0)
            {
                D3D_ERR("Hardware should be capable of creating a pure device");
                InternalDirectDrawRelease(pDD);
                return D3DERR_INVALIDCALL;
            }
        }
        else
        {
            D3D_ERR("Must specify software, hardware or mixed vertex processing");
            InternalDirectDrawRelease(pDD);
            return D3DERR_INVALIDCALL;
        }
    }

    switch (DeviceType)
    {
    case D3DDEVTYPE_SW:
    case D3DDEVTYPE_REF:
    case D3DDEVTYPE_HAL:
        if (dwFlags & D3DCREATE_PUREDEVICE)
        {
            pd3ddev = new CD3DBase();
        }
        else
        {
            pd3ddev = static_cast<LPD3DBASE>(new CD3DHal());
        }
        break;
    default:
        D3D_ERR("Unrecognized or unsupported DeviceType. CreateDevice Failed.");
        InternalDirectDrawRelease(pDD);
        return D3DERR_INVALIDCALL;
    }

    if (!pd3ddev)
    {
        D3D_ERR("Failed to allocate space for the device object. CreateDevice Failed.");
        InternalDirectDrawRelease(pDD);
        return (E_OUTOFMEMORY);
    }

#if DBG
    {
        char DevTypeMsg[256];
        _snprintf( DevTypeMsg, 256, "=======================" );
        switch( DeviceType )
        {
        case D3DDEVTYPE_HAL:
            _snprintf( DevTypeMsg, 256, "%s Hal", DevTypeMsg );
            break;
        case D3DDEVTYPE_SW:
            _snprintf( DevTypeMsg, 256, "%s Pluggable SW", DevTypeMsg );
            break;
        case D3DDEVTYPE_REF:
            _snprintf( DevTypeMsg, 256, "%s Reference", DevTypeMsg );
            break;
        default:
            _snprintf( DevTypeMsg, 256, "%s Unknown", DevTypeMsg );
            break;
        }
        if (dwFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING)
        {
            _snprintf( DevTypeMsg, 256, "%s HWVP", DevTypeMsg );
        }
        else if (dwFlags & D3DCREATE_MIXED_VERTEXPROCESSING)
        {
            _snprintf( DevTypeMsg, 256, "%s MixedVP", DevTypeMsg );
        }
        else if (dwFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING)
        {
            _snprintf( DevTypeMsg, 256, "%s SWVP", DevTypeMsg );
        }
        if (dwFlags & D3DCREATE_PUREDEVICE)
        {
            _snprintf( DevTypeMsg, 256, "%s Pure", DevTypeMsg );
        }
        _snprintf( DevTypeMsg, 256, "%s device selected", DevTypeMsg );
        D3D_INFO( 0, DevTypeMsg );
    }
#endif

    //
    // FW's Init
    //
    ret = static_cast<CBaseDevice*>(pd3ddev)->Init(
        pDD,
        DeviceType,
        hwndFocusWindow,
        dwFlags,
        pPresentationParams,
        iAdapter,
        this);
    if (FAILED(ret))
    {
        D3D_ERR("Failed to initialize Framework Device. CreateDevice Failed.");
        delete pd3ddev;
        return ret;
    }

    // We try and create a dummy vidmem vertexbuffer. If this doesn't
    // succeed, we just turn off vidmem VBs. This is to work around
    // the Rage 128 driver that reports DDERR_OUTOFVIDEOMEMORY even
    // though it simply doesn't support vidmem VBs
    if(!IS_DX8HAL_DEVICE(pd3ddev))
    {
#ifdef WIN95
        //ON 9x we probe to see if the driver can do vidmem VBs...
        CVertexBuffer *pVertexBuffer;
        ret = CVertexBuffer::CreateDriverVertexBuffer(pd3ddev,
                                                      1024,
                                                      D3DFVF_TLVERTEX,
                                                      D3DUSAGE_WRITEONLY | D3DUSAGE_DONOTCLIP,
                                                      D3DUSAGE_WRITEONLY | D3DUSAGE_DONOTCLIP | D3DUSAGE_LOCK,
                                                      D3DPOOL_DEFAULT,
                                                      D3DPOOL_DEFAULT,
                                                      REF_INTERNAL,
                                                      &pVertexBuffer);
        if(FAILED(ret))
        {
            if(pd3ddev->VBFailOversDisabled())
            {
                DPF_ERR("Cannot create Vidmem vertex buffer. Will ***NOT*** failover to Sysmem.");
                return ret;
            }
            DPF(1,"Driver doesnt support VidMemVBs which is fine");
        }
        else
        {
            // Get rid of the vb
            pVertexBuffer->DecrementUseCount();
            pd3ddev->EnableVidmemVBs();
        }
#else //WIN95
        //On NT we require the drivers to tell us (by setting D3DDEVCAPS_HWVERTEXBUFFER)

        //Turn off DX7 driver VBs on NT if asked to do so...
        DWORD value;
        if ((GetD3DRegValue(REG_DWORD, "DisableVidMemVBs", &value, 4) != 0) &&
            (value != 0))
        {
            pd3ddev->DisableVidmemVBs();
        }
#endif //!WIN95
    }

    ret = pd3ddev->Init();
    if (ret != D3D_OK)
    {
        delete pd3ddev;
        D3D_ERR("Failed to initialize D3DDevice. CreateDevice Failed.");
        return ret;
    }

    // Looks like everything is in order
    *ppNewInterface = static_cast<IDirect3DDevice8*>(pd3ddev);

#ifdef APIPROF
    CApiProfileDevice* profile = new CApiProfileDevice;
    if (profile)
    {
        if (profile->Init() == D3D_OK)
        {
            profile->SetDevice(*ppNewInterface);
            *ppNewInterface = static_cast<IDirect3DDevice8*>(profile);
        }
        else
        {
            delete profile;
        }
    }
#endif // APIPROF

    return S_OK;
}

#ifdef _X86_

// --------------------------------------------------------------------------
// Detect 3D extensions
// --------------------------------------------------------------------------
BOOL _asm_isX3D()
{
    DWORD retval = 0;
    _asm
        {
            pushad                      ; CPUID trashes lots - save everything
            mov     eax,80000000h       ; Check for extended CPUID support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            cmp     eax,80000001h       ; Jump if no extended CPUID
            jb      short done          ;

            mov     eax,80000001h       ; Check for feature
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            xor     eax,eax             ;
            test    edx,80000000h       ;
            setnz   al                  ;
            mov     retval,eax          ;

done:
            popad               ; Restore everything
        };
    return retval;
}

static BOOL isX3Dprocessor(void)
{
    __try
    {
            if( _asm_isX3D() )
            {
            return TRUE;
            }
    }
    __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
    }
    return FALSE;
}
//---------------------------------------------------------------------
// Detects Intel SSE processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

#define SSE_PRESENT 0x02000000                  // bit number 25
#define WNI_PRESENT 0x04000000                  // bit number 26

DWORD IsIntelSSEProcessor(void)
{
        DWORD retval = 0;
        DWORD RegisterEAX;
        DWORD RegisterEDX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return retval;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return retval;

        // this CPUID can't fail if the above test passed
        __asm {
                mov eax,1
                CPUID
                mov RegisterEAX,eax
                mov RegisterEDX,edx
        }

        if (RegisterEDX  & SSE_PRESENT) {
                retval |= D3DCPU_SSE;
        }

        if (RegisterEDX  & WNI_PRESENT) {
                retval |= D3DCPU_WLMT;
        }

        return retval;
}
#pragma optimize("", on)

// IsProcessorFeatureAvailable() is supported only by WINNT. For other OS
// we emulate it
#ifdef WINNT

static BOOL D3DIsProcessorFeaturePresent(UINT feature)
{
    switch (feature)
    {
    // WINNT does not recognize Willamette processor when we use
    // PF_XMMI64_INSTRUCTIONS_AVAILABLE, so use our detection instead
    case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
        {
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_WLMT;
        }
    default: return IsProcessorFeaturePresent(feature);
    }
}

#else

#define PF_XMMI_INSTRUCTIONS_AVAILABLE      6
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE     7
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE   10

static BOOL D3DIsProcessorFeaturePresent(UINT feature)
{
    switch (feature)
    {
    case PF_XMMI_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_SSE;
        }
    case PF_3DNOW_INSTRUCTIONS_AVAILABLE: return isX3Dprocessor();
    case PF_XMMI64_INSTRUCTIONS_AVAILABLE:
        {
            if (IsWin95())
                return FALSE;
            DWORD flags = IsIntelSSEProcessor();
            return flags & D3DCPU_WLMT;
        }
    default: return FALSE;
    }
}
#endif // WINNT

#endif // _X86_
//------------------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DHal::InitDevice"

HRESULT
CD3DHal::InitDevice()
{
    HRESULT       ret;

    // Initialize values so we don't crash at shutdown
    this->GeometryFuncsGuaranteed = NULL;
    this->rstates = NULL;
    m_pLightArray = NULL;
    m_pv = NULL;
    m_pCurrentShader = NULL;
    m_pConvObj = NULL;
    pMatrixDirtyForDDI = NULL;
    m_clrRects = NULL;
    m_clrCount = 0;
    m_pv = new D3DFE_PROCESSVERTICES;
    if (m_pv == NULL)
    {
        D3D_ERR("Could not allocate the FE/PSGP data structure (D3DFE_PROCESSVERTICES).");
        return E_OUTOFMEMORY;
    }
    m_pv->pGeometryFuncs = NULL;

    ret = CD3DBase::InitDevice();
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to initialize CD3DBase.");
        return(ret);
    }

    pMatrixDirtyForDDI = new CPackedBitArray;
    if( pMatrixDirtyForDDI == NULL )
    {
        D3D_ERR("Could not allocate memory for internal data structure pMatrixDirtyForDDI.");
        return E_OUTOFMEMORY;
    }

    if (FAILED(rsVec.Init(D3D_MAXRENDERSTATES)) ||
        FAILED(rsVecRetired.Init(D3D_MAXRENDERSTATES)) ||
        FAILED(rsVertexProcessingOnly.Init(D3D_MAXRENDERSTATES)) ||
        FAILED(pMatrixDirtyForDDI->Init(D3D_MAXTRANSFORMSTATES)))
    {
        D3D_ERR("Could not allocate memory for renderstate processing bit vectors");
        return E_OUTOFMEMORY;
    }

    m_pLightArray = new CHandleArray;
    if (m_pLightArray == NULL)
    {
        D3D_ERR("Could not allocate memory for internal data structure m_pLightArray");
        return E_OUTOFMEMORY;
    }

    dwFEFlags = 0;

    // Initialize FEFlags content that depends on DDI type
    if ( (GetDDIType() == D3DDDITYPE_DX7TL) ||
         (GetDDIType() == D3DDDITYPE_DX8TL) )
        dwFEFlags |= D3DFE_TLHAL;

    // Since this is HAL, initialize it to use the software pipeline
    // this will be turned off when the SW/HW renderstate is set.
    m_pv->dwVIDIn = 0;

    m_pv->pD3DMappedTexI = (LPVOID*)(m_lpD3DMappedTexI);

    /*-------------------------------------------------------------------------
     * Up till now we have done the easy part of the initialization. This is
     * the stuff that cannot fail. It initializes the object so that the
     * destructor can be safely called if any of the further initialization
     * does not succeed.
     *-----------------------------------------------------------------------*/

    this->GeometryFuncsGuaranteed = new D3DFE_PVFUNCSI;
    if (this->GeometryFuncsGuaranteed == NULL)
    {
        D3D_ERR("Could not allocate memory for internal data structure GeometryFuncsGuaranteed");
        return E_OUTOFMEMORY;
    }
    // Software constant register buffer must handle all constants, provided by
    // hardware, to make Set/Get constants possible
    this->GeometryFuncsGuaranteed->m_VertexVM.Init(GetD3DCaps()->MaxVertexShaderConst);

    m_pv->pGeometryFuncs = (LPD3DFE_PVFUNCS)GeometryFuncsGuaranteed;

    if (this->GeometryFuncsGuaranteed == NULL)
    {
        D3D_ERR("Could not allocate memory for FE/PSGP function table.");
        return D3DERR_INVALIDCALL;
    }
    // set up flag to use MMX when requested RGB
    BOOL bUseMMXAsRGBDevice = FALSE;

    D3DSURFACE_DESC desc = this->RenderTarget()->InternalGetDesc();

    /*
     * Check if the 3D cap is set on the surface.
     */
    if ((desc.Usage & D3DUSAGE_RENDERTARGET) == 0)
    {
        D3D_ERR("**** The D3DUSAGE_RENDERTARGET is not set on this surface.");
        D3D_ERR("**** You need to add D3DUSAGE_RENDERTARGET to the Usage parameter");
        D3D_ERR("**** when creating the surface.");
        return (D3DERR_INVALIDCALL);
    }

    // Create front-end support structures.
    ret = this->D3DFE_Create();
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to create front-end data-structures.");
        goto handle_err;
    }

    // In all other cases we simply allocate memory for rstates
    rstates = new DWORD[D3D_MAXRENDERSTATES];

    m_pv->lpdwRStates = this->rstates;

#ifndef PROFILE4
#ifdef _X86_
    if ((ULONG_PTR)&m_pv->view & 0xF)
    {
        char s[256];
        sprintf(s, "0%xh \n", (ULONG_PTR)&m_pv->view);
        OutputDebugString("INTERNAL ERROR:View matrix in D3DFE_PROCESSVERTICES structure must be aligned to 16 bytes\n");
        OutputDebugString(s);
        ret = D3DERR_INVALIDCALL;
        goto handle_err;
    }
    // Check if we have a processor specific implementation available
    //  only use if DisablePSGP is not in registry or set to zero
    DWORD value;
    if (!GetD3DRegValue(REG_DWORD, "DisablePSGP", &value, sizeof(DWORD)))
    {
        value = 0;
    }
    // value =
    //      0   - PSGP enabled
    //      1   - PSGP disabled
    //      2   - X3D PSGP disabled
    if (value != 1)
    {
        // Ask the PV implementation to create a device specific "context"
        LPD3DFE_PVFUNCS pOptGeoFuncs = m_pv->pGeometryFuncs;

        // TODO (bug 40438): Remove DLL interface for final
        // Try to use PSGP DLL first
        if (pfnFEContextCreate)
        {
            ret = pfnFEContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if ((ret == D3D_OK) && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using PSGP DLL");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }

        if (D3DIsProcessorFeaturePresent(PF_3DNOW_INSTRUCTIONS_AVAILABLE) &&
            value != 2)
        {
            ret = x3DContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if (ret == S_OK && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using X3D PSGP");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }
        if (D3DIsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE))
        {
            ret = wlmt_FEContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if (ret == S_OK && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using WLMT PSGP");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }
        if (D3DIsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE))
        {
            ret = katmai_FEContextCreate(m_pv->dwDeviceFlags, &pOptGeoFuncs);
            if (ret == S_OK && pOptGeoFuncs)
            {
                D3D_INFO(0, "Using P3 PSGP");
                m_pv->pGeometryFuncs = pOptGeoFuncs;
                goto l_chosen;
            }
        }
l_chosen:;
    }

#endif // _X86_
#endif // PROFILE4

    {
        if (HVbuf.Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DFE_CLIPCODE)) != DD_OK)
        {
            D3D_ERR( "Could not allocate memory for internal buffer HVBuf" );
            ret = E_OUTOFMEMORY;
            goto handle_err;
        }
    }

    // Setup lights
    if( FAILED( m_pLightArray->Grow( 8 ) ) )
    {
        D3D_ERR( "Could not allocate memory for the light array" );
        ret = E_OUTOFMEMORY;
        goto handle_err;
    }
    LIST_INITIALIZE(&m_ActiveLights);

    // Setup material
    memset(&m_pv->lighting.material, 0, sizeof(m_pv->lighting.material));

    // Set viewport to update front-end data
    SetViewportI(&m_Viewport);

    m_pv->PointSizeMax = GetD3DCaps()->MaxPointSize;
    {
        DWORD EmulatePointSprites = 1;
        GetD3DRegValue(REG_DWORD, "EmulatePointSprites", &EmulatePointSprites, sizeof(DWORD));
        if ((m_pv->PointSizeMax == 0 || !(GetD3DCaps()->FVFCaps & D3DFVFCAPS_PSIZE)) &&
            EmulatePointSprites)
        {
            m_dwRuntimeFlags |= D3DRT_DOPOINTSPRITEEMULATION;
            if (m_pv->PointSizeMax == 0)
                m_pv->PointSizeMax = __MAX_POINT_SIZE;
            else
                m_dwRuntimeFlags |= D3DRT_SUPPORTSPOINTSPRITES;
        }
    }
    m_pfnPrepareToDraw = NULL;

    return (D3D_OK);

handle_err:
    return(ret);
}
//---------------------------------------------------------------------
DWORD
ProcessRects(CD3DHal* pDevI, DWORD dwCount, CONST D3DRECT* rects)
{
    RECT vwport;
    DWORD i,j;

    /*
     * Rip through the rects and validate that they
     * are within the viewport.
     */

    if (dwCount == 0 && rects == NULL)
    {
        dwCount = 1;
    }
#if DBG
    else if (rects == NULL)
    {
        D3D_ERR("The rects parameter is NULL.");
        throw D3DERR_INVALIDCALL;
    }
#endif

    if (dwCount > pDevI->m_clrCount)
    {
        LPD3DRECT       newRects;
        if (D3D_OK == D3DMalloc((void**)&newRects, dwCount * sizeof(D3DRECT)))
        {
            memcpy((void*)newRects,(void*)pDevI->m_clrRects,
                pDevI->m_clrCount* sizeof(D3DRECT));
            D3DFree((LPVOID)pDevI->m_clrRects);
            pDevI->m_clrRects = newRects;
        }
        else
        {
            pDevI->m_clrCount = 0;
            D3DFree((LPVOID)pDevI->m_clrRects);
            pDevI->m_clrRects = NULL;
            D3D_ERR("failed to allocate space for rects");
            throw E_OUTOFMEMORY;
        }
    }
    pDevI->m_clrCount = dwCount;

    // If nothing is specified, assume the viewport needs to be cleared
    if (!rects)
    {
        pDevI->m_clrRects[0].x1 = pDevI->m_Viewport.X;
        pDevI->m_clrRects[0].y1 = pDevI->m_Viewport.Y;
        pDevI->m_clrRects[0].x2 = pDevI->m_Viewport.X + pDevI->m_Viewport.Width;
        pDevI->m_clrRects[0].y2 = pDevI->m_Viewport.Y + pDevI->m_Viewport.Height;
        return 1;
    }
    else
    {
        vwport.left   = pDevI->m_Viewport.X;
        vwport.top    = pDevI->m_Viewport.Y;
        vwport.right  = pDevI->m_Viewport.X + pDevI->m_Viewport.Width;
        vwport.bottom = pDevI->m_Viewport.Y + pDevI->m_Viewport.Height;

        j=0;
        for (i = 0; i < dwCount; i++)
        {
            if (IntersectRect((LPRECT)(pDevI->m_clrRects + j), &vwport, (LPRECT)(rects + i)))
                j++;
        }
        return j;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ClearI"

void
CD3DHal::ClearI(DWORD dwCount,
                 CONST D3DRECT* rects,
                 DWORD dwFlags,
                 D3DCOLOR dwColor,
                 D3DVALUE dvZ,
                 DWORD dwStencil)
{
    dwCount = ProcessRects(this, dwCount, rects);
    // Device should never receive 0 count, because for Pure device this
    // means "clear whole viewport"
    if (dwCount != 0)
    {
        // Call DDI specific Clear routine
        m_pDDI->Clear(dwFlags, dwCount, m_clrRects, dwColor, dvZ, dwStencil);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\d3dpr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dpr.h
 *  Content:    Direct3D private include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   23/11/95   colinmc Made various Direct3D interfaces queryable off
 *                      DirectDraw.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef _D3DPR_H_
#define _D3DPR_H_
#include "d3di.hpp"
#include "dpf.h"

#if 0
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
};
#endif

/*
 * Macros for validating parameters.
 * Only implement those not available in ddrawpr.h.
 */

#define VALID_OUTPTR(x) ((x) && VALID_PTR_PTR(x))

// FAST_CHECKING macro is defined in ddrawpr.h
// so in make sure that ddrawpr.h is always included
// before this header.

#ifndef FAST_CHECKING

#define VALID_DIRECT3DBASETEXTURE8_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( LPVOID )))
#define VALID_DDSURF_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )))
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( CDirect3DVertexBuffer )))

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVERTEXBUFFERDESC8 ) ))
#define VALID_D3DCAPS8_PTR( ptr ) \
    (! IsBadWritePtr(ptr, sizeof( D3DCAPS8)) )
#define VALID_D3DRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DRECT ) ))
#define VALID_GDIRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( RECT ) ))
#define VALID_GDIPOINT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( POINT ) ))
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTEXTUREHANDLE ) ) )
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) \
    (!IsBadWritePtr( ptr, size ) )

// Note: these macros are replacements for the VALID_DIRECTDRAWSURFACE_PTR ddraw macros
// because those macros need access to the ddCallbacks ddraw globals.
// At some point these could be replaced with a ddraw exported fn that actually
// verifies the callback table type

#define VALID_D3D_DIRECTDRAWSURFACE8_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(VOID*)))

#else /* !FAST_CHECKING */

#define VALID_DIRECT3DBASETEXTURE8_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE_PTR( ptr ) (ptr)
#define VALID_DDSURF_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) (ptr)

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) (ptr)
#define VALID_D3DCAPS8_PTR( ptr ) (ptr)
#define VALID_D3DRECT_PTR( ptr ) (ptr)
#define VALID_GDIRECT_PTR( ptr ) (ptr)
#define VALID_GDIPOINT_PTR( ptr ) (ptr)
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) (ptr)

#define VALID_D3D_DIRECTDRAWSURFACE8_PTR(ptr) (ptr)
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) (ptr)

#endif /* !FAST_CHECKING */


#endif /* _D3DPR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\ddi.inl ===
#ifndef __DDI_INL__
#define __DDI_INL__

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddi.inl
 *  Content:    Contains inlines from CD3DDDI to avoid them being included
 *              by the fw directory (which doesn't like try-catch)
 *
 ***************************************************************************/

//-----------------------------------------------------------------------------
// Initializes command header in the DP2 command buffer,
// reserves space for the command data and returns pointer to the command
// data
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::GetHalBufferPointer"

inline LPVOID
CD3DDDIDX6::GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + dwDataSize;

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        FlushStatesCmdBufReq(dwCommandSize);
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = op;
    bDP2CurrCmdOP = op;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

    dwDP2CommandLength += dwCommandSize;
    return (LPVOID)(lpDP2CurrCommand + 1);
}

#endif //__RESOURCE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\ddi.cpp ===
#include "pch.cpp"
#pragma hdrstop
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddi.cpp
 *  Content:    Direct3D DDI encapsulation implementations
 *
 ***************************************************************************/
#include "d3d8p.h"
#include "ddi.h"
#include "ddrawint.h"
#include "fe.h"
#include "pvvid.h"
#include "ddi.inl"

#ifndef WIN95
extern BOOL bVBSwapEnabled, bVBSwapWorkaround;
#endif // WIN95

extern HRESULT ProcessClippedPointSprites(D3DFE_PROCESSVERTICES *pv);
extern DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);
extern DWORD g_DebugFlags;
HRESULT ValidateCommandBuffer(LPBYTE pBuffer, DWORD dwCommandLength, DWORD dwStride);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDI                                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
CD3DDDI::CD3DDDI()
{
    m_StartIndex = 0;
    m_MinVertexIndex = 0;
    m_NumVertices = 0;
    m_BaseVertexIndex = 0;
}

//---------------------------------------------------------------------------
CD3DDDI::~CD3DDDI()
{
    return;
}
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX6                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// Command buffer size tuned to 16K to minimize flushes in Unreal
// * 1 = 16K bytes
const DWORD CD3DDDIDX6::dwD3DDefaultCommandBatchSize = 16384;

CD3DDDIDX6::CD3DDDIDX6() : CD3DDDI()
{
    m_ddiType = D3DDDITYPE_DX6;
    m_pDevice = NULL;
    m_bWithinPrimitive = FALSE;
    m_dwhContext = 0;
    m_pfnProcessPrimitive = NULL;
    m_pfnProcessIndexedPrimitive = NULL;
    m_dwInterfaceNumber = 3;

    lpDP2CurrBatchVBI = NULL;
    TLVbuf_size = 0;
    TLVbuf_base = 0;
    dwDP2CommandBufSize = 0;
    dwDP2CommandLength  = 0;
    lpvDP2Commands = NULL;
    lpDP2CurrCommand = NULL;
    wDP2CurrCmdCnt = 0;
    bDP2CurrCmdOP  = 0;
    bDummy         = 0;
    memset(&dp2data, 0x00, sizeof(dp2data) ) ;
    dwDP2VertexCount = 0;
    dwVertexBase     = 0;
    lpDDSCB1        = NULL;
    allocatedBuf    = NULL;
    alignedBuf      = NULL;
    dwTLVbufChanges = 0;
    dwDP2Flags      = 0;
    m_pPointStream = NULL;
    // For the legacy DDI, we say we are DX7
    m_dwInterfaceNumber = 3;
    lpwDPBuffer = NULL;
    dwDPBufferSize  = 0;
    m_pNullVB = 0;
#if DBG
    m_bValidateCommands = FALSE;
#endif
}
//---------------------------------------------------------------------
CD3DDDIDX6::~CD3DDDIDX6()
{
    delete m_pPointStream;
    m_pPointStream = NULL;
    if (m_pNullVB)
        m_pNullVB->DecrementUseCount();
    if (allocatedBuf)
        allocatedBuf->DecrementUseCount();
    allocatedBuf = NULL;
    if (lpDP2CurrBatchVBI)
        lpDP2CurrBatchVBI->DecrementUseCount();
    lpDP2CurrBatchVBI = NULL;
    if (lpDDSCB1)
        lpDDSCB1->DecrementUseCount();
    lpDDSCB1 = NULL;
    DestroyContext();
}
//---------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::NotSupported"

void
CD3DDDIDX6::NotSupported(char* msg)
{
    D3D_ERR("%s is not supported by the current DDI", msg);
    throw D3DERR_INVALIDCALL;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SceneCapture"

void
CD3DDDIDX6::SceneCapture(BOOL bState)
{
    D3D8_SCENECAPTUREDATA data;

    if (m_pDevice->GetHalCallbacks()->SceneCapture == 0)
        return;

    D3D_INFO(6, "SceneCapture, setting %d dwhContext = %d",
             bState, m_dwhContext);

    memset(&data, 0, sizeof(D3DHAL_SCENECAPTUREDATA));
    data.dwhContext = m_dwhContext;
    data.dwFlag = bState ? D3DHAL_SCENE_CAPTURE_START : D3DHAL_SCENE_CAPTURE_END;

    HRESULT ret = m_pDevice->GetHalCallbacks()->SceneCapture(&data);

    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR("Driver failed to handle SceneCapture");
        throw (data.ddrval);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ClearBatch"

void
CD3DDDIDX6::ClearBatch(BOOL bWithinPrimitive)
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
    // Reset vertex buffer
    if (!bWithinPrimitive)
    {
        dp2data.dwVertexOffset = 0;
        this->dwDP2VertexCount = 0;
        this->dwVertexBase = 0;
        TLVbuf_Base() = 0;
        if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            // We are flushing a user mem primitive.
            // We need to clear dp2data.lpUMVertices
            // since we are done with it. We replace
            // it with TLVbuf.
            DDASSERT(lpDP2CurrBatchVBI == NULL);
            dp2data.hDDVertex = TLVbuf_GetVBI()->DriverAccessibleKernelHandle();
            lpDP2CurrBatchVBI = TLVbuf_GetVBI();
            lpDP2CurrBatchVBI->IncrementUseCount();
            dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::Init"

void
CD3DDDIDX6::Init( LPD3DBASE pDevice )
{
    m_pDevice = pDevice;
    CreateContext();
    GrowCommandBuffer(dwD3DDefaultCommandBatchSize);
    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = D3DFVF_TLVERTEX; // Initial assumption
    dp2data.dwVertexSize = sizeof(D3DTLVERTEX); // Initial assumption
    ClearBatch(FALSE);

    // Since we plan to call TLV_Grow for the first time with "TRUE"
    dwDP2Flags |= D3DDDI_TLVBUFWRITEONLY;
    GrowTLVbuf((__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX), TRUE);

    // Create a dummy sysmem VB to be used as a backup for lowmem situations
    LPDIRECT3DVERTEXBUFFER8 t;
    HRESULT ret = CVertexBuffer::Create(pDevice,
                                        sizeof(D3DTLVERTEX),
                                        D3DUSAGE_INTERNALBUFFER | D3DUSAGE_DYNAMIC,
                                        D3DFVF_TLVERTEX,
                                        D3DPOOL_SYSTEMMEM,
                                        REF_INTERNAL,
                                        &t);
    if (ret != D3D_OK)
    {
        D3D_THROW(ret, "Cannot allocate internal backup TLVBuf");
    }
    m_pNullVB = static_cast<CVertexBuffer*>(t);

    m_pPointStream  = new CTLStream(FALSE);
    if (m_pPointStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal data structure CTLStream");

    m_pStream0 = NULL;
    m_CurrentVertexShader = 0;
#if DBG
    m_VertexSizeFromShader = 0;
#endif
    m_pIStream = NULL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::CreateContext"

void
CD3DDDIDX6::CreateContext()
{
    D3D8_CONTEXTCREATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "in CreateContext. Creating Context for driver = %08lx",
             this);

    memset(&data, 0, sizeof(data));

    data.hDD = m_pDevice->GetHandle();
    data.hSurface = m_pDevice->RenderTarget()->KernelHandle();
    if(m_pDevice->ZBuffer() != 0)
        data.hDDSZ = m_pDevice->ZBuffer()->KernelHandle();
    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    data.dwhContext = m_dwInterfaceNumber;
    data.dwPID  = GetCurrentProcessId();
    // Hack Alert!! ddrval is used to inform the driver which driver type
    // the runtime thinks it is (DriverStyle registry setting)
    data.ddrval = m_ddiType;

    data.cjBuffer = dwDPBufferSize;
    data.pvBuffer = NULL;

    ret = m_pDevice->GetHalCallbacks()->CreateContext(&data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR( "Driver did not handle ContextCreate" );
        throw D3DERR_INVALIDCALL;
    }
    m_dwhContext = data.dwhContext;

#if 0 //def WIN95
    LPWORD lpwDPBufferAlloced = NULL;
    if (D3DMalloc((void**)&lpwDPBufferAlloced, dwDPBufferSize) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate" );
        throw E_OUTOFMEMORY;
    }
    lpwDPBuffer = (LPWORD)(((DWORD) lpwDPBufferAlloced+31) & (~31));

#else
    if( dwDPBufferSize && (data.cjBuffer < dwDPBufferSize) )
    {
        D3D_ERR( "Driver did not correctly allocate DrawPrim buffer");
        throw D3DERR_INVALIDCALL;
    }

    // Need to save the buffer space provided and its size
    dwDPBufferSize = data.cjBuffer;
    lpwDPBuffer = (LPWORD)data.pvBuffer;
#endif
    D3D_INFO(6, "in CreateContext. Succeeded. dwhContext = %d",
             data.dwhContext);

}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DestroyContext"

void
CD3DDDIDX6::DestroyContext()
{
    D3D8_CONTEXTDESTROYDATA data;
    HRESULT ret;

    D3D_INFO(6, "Destroying Context for driver = %08lx", this);
    D3D_INFO(6, "dwhContext = %d", m_dwhContext);

    if( m_dwhContext )
    {
        memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        data.dwhContext = m_dwhContext;
        ret = m_pDevice->GetHalCallbacks()->ContextDestroy(&data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
        {
            D3D_WARN(0,"Failed ContextDestroy HAL call");
            return;
        }
    }
}
//-----------------------------------------------------------------------------
// This code may be needed when we debug some problems
#if 0
void PrintBuffer(LPBYTE alignedBuf, D3D8_DRAWPRIMITIVES2DATA* dp2data, LPBYTE lpvDP2Commands)
{
    FILE* f = fopen("\\ddi.log", "a+");
    if (f == NULL)
        return;
    fprintf(f,  "-----------\n");
    fprintf(f, "dwFlags: %d, dwVertexType: 0x%xh, CommandOffset: %d, CommandLength: %d, VertexOffset: %d, VertexLength: %d\n",
            dp2data->dwFlags,
            dp2data->dwVertexType,
            dp2data->dwCommandOffset,
            dp2data->dwCommandLength,
            dp2data->dwVertexOffset,
            dp2data->dwVertexLength,
            dp2data->dwVertexSize);
    float* p = (float*)alignedBuf;
    UINT nTex = FVF_TEXCOORD_NUMBER(dp2data->dwVertexType);
    for (UINT i=0; i < dp2data->dwVertexLength; i++)
    {
        fprintf(f, "%4d %10.5f %10.5f %10.5f %10.5f ", i, p[0], p[1], p[2], p[3]);
        UINT index = 4;
        if (dp2data->dwVertexType & D3DFVF_DIFFUSE)
        {
//            fprintf(f, "0x%6x ", *(DWORD*)&p[index]);
            index++;
        }
        if (dp2data->dwVertexType & D3DFVF_SPECULAR)
        {
//            fprintf(f, "0x%6x ", *(DWORD*)&p[index]);
            index++;
        }
        for (UINT j=0; j < nTex; j++)
        {
            fprintf(f, "%10.5f %10.5f ", p[index], p[index+1]);
            index += 2;
        }
        fprintf(f, "\n");
        p = (float*)((BYTE*)p + dp2data->dwVertexSize);
    }
    fclose(f);
}
#endif // 0
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::FlushStates"

void
CD3DDDIDX6::FlushStates(BOOL bReturnDriverError, BOOL bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (m_bWithinPrimitive)
        bWithinPrimitive = TRUE;
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        m_pDevice->IncrementBatchCount();

        if (lpDP2CurrBatchVBI)
            lpDP2CurrBatchVBI->Batch();
        // Check if render target and / or z buffer is lost
        // Save since it will get overwritten by ddrval after DDI call
        DWORD dwVertexSize = dp2data.dwVertexSize;

        dp2data.dwVertexLength = dwDP2VertexCount;
        dp2data.dwCommandLength = dwDP2CommandLength;
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        dwDP2CommandLength = 0;
        // Try and set these 2 values only once during initialization
        dp2data.dwhContext = m_dwhContext;
        dp2data.lpdwRStates = (LPDWORD)lpwDPBuffer;
        DDASSERT(dp2data.dwVertexSize != 0);
        D3D_INFO(6, "FVF passed to the driver via DrawPrimitives2 = 0x%08x", dp2data.dwVertexType);

            // If we need the same TLVbuf next time do not swap buffers.
            // Save and restore this bit
        BOOL bSwapVB = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) != 0;
#ifndef WIN95
        BOOL bDidWorkAround = FALSE;
#endif // WIN95
        if (bWithinPrimitive)
        {
            dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        }
        // At the end of the DP2 call we expect the VB to be unlocked if
        // 1. We cannot allow the driver to swap the VB
        // 2. We are using a VB (not USERMEMVERTICES)
        // 3. It is not TLVbuf
        // In this case we might as well tell the driver that it is unlocked.
        // More importantly, we need to let DDraw know that the VB is unlocked.
        if (!(dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER))
        {
            if ((lpDP2CurrBatchVBI) && (lpDP2CurrBatchVBI != TLVbuf_GetVBI()))
            {
                // This seems contradictory, but IsLocked() checks whether
                // the app is holding a Lock.
                if(!lpDP2CurrBatchVBI->IsLocked())
                {
                    lpDP2CurrBatchVBI->UnlockI();
                }
            }
        }
#ifndef WIN95
        else if (bVBSwapWorkaround && lpDP2CurrBatchVBI != 0 && lpDP2CurrBatchVBI == TLVbuf_GetVBI() && 
                 lpDP2CurrBatchVBI->GetBufferDesc()->Pool == D3DPOOL_DEFAULT)
        {
            static_cast<CDriverVertexBuffer*>(lpDP2CurrBatchVBI)->UnlockI();
            bDidWorkAround = TRUE;
        }
        if (!bVBSwapEnabled)  // Note: bVBSwapEnabled not the same as bSwapVB above.
                              // bVBSwapEnabled is a global to indicate whether VB
                              // VB swapping should be turned off due to broken
                              // Win2K kernel implementation
        {
            dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        }
#endif // WIN95

        // Spin waiting on the driver if wait requested
        do {
            // Need to set this since the driver may have overwrote it by
            // setting ddrval = DDERR_WASSTILLDRAWING
            dp2data.dwVertexSize = dwVertexSize;
            dwRet = m_pDevice->GetHalCallbacks()->DrawPrimitives2(&dp2data);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }

        } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);

        dwRet = dp2data.ddrval;
        // update command buffer pointer
        if ((dwRet == D3D_OK) &&
            (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
        {
            // Implement VidMem command buffer and
            // command buffer swapping.
        }
        // update vertex buffer pointer
        if ((dwRet == D3D_OK) &&
            (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) &&
            dp2data.lpVertices)
        {
#if DBG
            if (this->lpDP2CurrBatchVBI->GetBufferDesc()->Pool == D3DPOOL_DEFAULT)
            {
                if ((VOID*)static_cast<CDriverVertexBuffer*>(this->lpDP2CurrBatchVBI)->GetCachedDataPointer() != (VOID*)dp2data.fpVidMem_VB)
                {
                    DPF(2, "Driver swapped VB pointer in FlushStates");
                }
            }
#endif // DBG

            if (lpDP2CurrBatchVBI == TLVbuf_GetVBI())
            {
                this->alignedBuf = (LPVOID)dp2data.fpVidMem_VB;
                this->TLVbuf_size = dp2data.dwLinearSize_VB;
            }

            this->lpDP2CurrBatchVBI->SetCachedDataPointer(
                (BYTE*)dp2data.fpVidMem_VB);
        }
#ifndef WIN95
        if (bDidWorkAround)
        {
            CDriverVertexBuffer *pVB = static_cast<CDriverVertexBuffer*>(lpDP2CurrBatchVBI);

            // Prepare a LockData structure for the HAL call
            D3D8_LOCKDATA lockData;
            ZeroMemory(&lockData, sizeof lockData);

            lockData.hDD = m_pDevice->GetHandle();
            lockData.hSurface = pVB->BaseKernelHandle();
            lockData.bHasRange = FALSE;
            lockData.dwFlags = D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK;

            HRESULT hr = m_pDevice->GetHalCallbacks()->Lock(&lockData);
            if (FAILED(hr))
            {
                D3D_ERR("Driver failed Lock in FlushStates");
                if (SUCCEEDED(dwRet))
                {
                    dwRet = hr;
                }
                this->alignedBuf = 0;
            }
            else
            {
#if DBG
                if (this->alignedBuf != lockData.lpSurfData)
                {
                    DPF(2, "Driver swapped VB pointer at Lock in FlushStates");
                }
#endif // DBG
                pVB->SetCachedDataPointer((BYTE*)lockData.lpSurfData);
                this->alignedBuf = lockData.lpSurfData;
            }
        }
#endif // WIN95
        // Restore flag if necessary
        if (bSwapVB)
            dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        // Restore to value before the DDI call
        dp2data.dwVertexSize = dwVertexSize;
        ClearBatch(bWithinPrimitive);
    }
    // There are situations when the command stream has no data,
    // but there is data in the vertex pool. This could happen, for instance
    // if every triangle got rejected while clipping. In this case we still
    // need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch(bWithinPrimitive);
    }

    if( FAILED( dwRet ) )
    {
        ClearBatch(FALSE);
        if( !bReturnDriverError )
        {
            switch( dwRet )
            {
            case D3DERR_OUTOFVIDEOMEMORY:
                D3D_ERR("Driver out of video memory!");
                break;
            case D3DERR_COMMAND_UNPARSED:
                D3D_ERR("Driver could not parse this batch!");
                break;
            default:
                D3D_ERR("Driver returned error: %s", HrToStr(dwRet));
                break;
            }
            DPF_ERR("Driver failed command batch. Attempting to reset device"
                    " state. The device may now be in an unstable state and"
                    " the application may experience an access violation.");
        }
        else
        {
            throw dwRet;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::FlushstatesReq"

void
CD3DDDIDX6::FlushStatesReq(DWORD dwReqSize)
{
    DWORD sav = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER);
    dp2data.dwReqVertexBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE;
    try
    {
        FlushStates();
    }
    catch( HRESULT hr )
    {
        dp2data.dwFlags &= ~(D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE);
        dp2data.dwFlags |= sav;
        throw hr;
    }

    dp2data.dwFlags &= ~(D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE);
    dp2data.dwFlags |= sav;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::FlushStatesCmdBufReq"

void
CD3DDDIDX6::FlushStatesCmdBufReq(DWORD dwReqSize)
{
    dp2data.dwReqCommandBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
    try
    {
        FlushStates();
    }
    catch( HRESULT hr )
    {
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        throw hr;
    }
    dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ValidateDevice"

void
CD3DDDIDX6::ValidateDevice(LPDWORD lpdwNumPasses)
{
    HRESULT ret;
    D3D8_VALIDATETEXTURESTAGESTATEDATA vd;
    memset( &vd, 0, sizeof( vd ) );
    vd.dwhContext = m_dwhContext;

    // First, Update textures since drivers pass /fail this call based
    // on the current texture handles
    m_pDevice->UpdateTextures();

    // Flush states, so we can validate the current state
    FlushStates();

    // Now ask the driver!
    ret = m_pDevice->GetHalCallbacks()->ValidateTextureStageState(&vd);
    *lpdwNumPasses = vd.dwNumPasses;

    if (ret != DDHAL_DRIVER_HANDLED) 
        throw E_NOTIMPL;
    else if (FAILED(vd.ddrval))
        throw vd.ddrval;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ReserveSpaceInCommandBuffer"

LPVOID CD3DDDIDX6::ReserveSpaceInCommandBuffer(UINT ByteCount)
{
    if (dwDP2CommandLength + ByteCount > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        FlushStatesCmdBufReq(ByteCount);
        // Check if the driver did give us what we need or do it ourselves
        GrowCommandBuffer(ByteCount);
    }
    return (BYTE*)lpvDP2Commands + dwDP2CommandLength + dp2data.dwCommandOffset;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetRenderTarget"

void
CD3DDDIDX6::SetRenderTarget(CBaseSurface *pTarget, CBaseSurface *pZ)
{
    HRESULT ret;

    // We are going to destroy all texture handles, so we need to unset
    // all currently bound textures, because we have seen DX6 drivers
    // crash when called to destroy a texture handle of a currently set
    // texture - snene (4/24/00)
    m_pDevice->m_dwStageDirty = (1ul << m_pDevice->m_dwMaxTextureBlendStages) - 1ul; // set dirty so that UpdateTextures() is called next time around
    m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_TEXTURE_UPDATE;
    for (DWORD dwStage = 0; dwStage < m_pDevice->m_dwMaxTextureBlendStages; dwStage++)
    {
        SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
        m_pDevice->m_dwDDITexHandle[dwStage] = 0;
    }

    // Flush before switching RenderTarget..
    FlushStates();

    D3D8_SETRENDERTARGETDATA rtData;
    memset( &rtData, 0, sizeof( rtData ) );
    rtData.dwhContext = m_dwhContext;
    rtData.hDDS       = pTarget->KernelHandle();
    if( pZ )
        rtData.hDDSZ  = pZ->KernelHandle();

    ret = m_pDevice->GetHalCallbacks()->SetRenderTarget( &rtData );
    if ((ret != DDHAL_DRIVER_HANDLED) || (rtData.ddrval != DD_OK))
    {
        D3D_ERR( "Driver failed SetRenderTarget call" );
        // Need sensible return value in this case,
        // currently we return whatever the driver stuck in here.
        ret = rtData.ddrval;
        throw ret;
    }
    if( rtData.bNeedUpdate )
    {
        m_pDevice->UpdateDriverStates();
    }
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetRenderState"

void
CD3DDDIDX6::SetRenderState(D3DRENDERSTATETYPE dwStateType, DWORD value)
{
    if (bDP2CurrCmdOP == D3DDP2OP_RENDERSTATE)
    { // Last instruction is a renderstate, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2RENDERSTATE) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)
                ((LPBYTE)lpvDP2Commands + dwDP2CommandLength +
                 dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;

            *((UNALIGNED DWORD *)&(lpRState->RenderState)) = dwStateType;
            *((UNALIGNED DWORD *)&(lpRState->dwState)) = value;
            dwDP2CommandLength += sizeof(D3DHAL_DP2RENDERSTATE);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2RENDERSTATE) > dwDP2CommandBufSize)
    {
            FlushStates();

            // Since we ran out of space, we were not able to put
            // (dwStateType, value) into the batch so rstates will reflect only
            // the last batched renderstate (since the driver updates rstates
            // from the batch). To fix this, we simply put the current
            // (dwStateType, value) into rstates.
            m_pDevice->UpdateRenderState(dwStateType, value);
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_RENDERSTATE;
    bDP2CurrCmdOP = D3DDP2OP_RENDERSTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add renderstate data
    LPD3DHAL_DP2RENDERSTATE lpRState;
    lpRState = (LPD3DHAL_DP2RENDERSTATE)(lpDP2CurrCommand + 1);
    *((UNALIGNED DWORD *)&(lpRState->RenderState)) = dwStateType;
    *((UNALIGNED DWORD *)&(lpRState->dwState)) = value;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2RENDERSTATE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::UpdateWInfo"

void
CD3DDDIDX6::UpdateWInfo(CONST D3DMATRIX* lpMat)
{
    LPD3DHAL_DP2WINFO pData;
    pData = (LPD3DHAL_DP2WINFO)
            GetHalBufferPointer(D3DDP2OP_WINFO, sizeof(*pData));
    D3DMATRIX m = *lpMat;
    if( (m._33 == m._34) || (m._33 == 0.0f) )
    {
        D3D_WARN(1, "Cannot compute WNear and WFar from the supplied projection matrix");
        D3D_WARN(1, "Setting wNear to 0.0 and wFar to 1.0");
        pData->dvWNear = 0.0f;
        pData->dvWFar  = 1.0f;
        return;
    }
    pData->dvWNear = m._44 - m._43/m._33*m._34;
    pData->dvWFar  = (m._44 - m._43)/(m._33 - m._34)*m._34 + m._44;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetViewport"

void
CD3DDDIDX6::SetViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    LPD3DHAL_DP2VIEWPORTINFO pData;
    pData = (LPD3DHAL_DP2VIEWPORTINFO)GetHalBufferPointer(D3DDP2OP_VIEWPORTINFO, sizeof(*pData));
    pData->dwX = lpVwpData->X;
    pData->dwY = lpVwpData->Y;
    pData->dwWidth = lpVwpData->Width;
    pData->dwHeight = lpVwpData->Height;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetTSS"

void
CD3DDDIDX6::SetTSS(DWORD dwStage,
                   D3DTEXTURESTAGESTATETYPE dwState,
                   DWORD dwValue)
{
    // Filter unsupported states
    if (dwState >= m_pDevice->m_tssMax)
        return;

    // Map DX8 filter enums to DX6/7 enums
    switch (dwState)
    {
    case D3DTSS_MAGFILTER: dwValue = texf2texfg[min(D3DTEXF_GAUSSIANCUBIC,dwValue)]; break;
    case D3DTSS_MINFILTER: dwValue = texf2texfn[min(D3DTEXF_GAUSSIANCUBIC,dwValue)]; break;
    case D3DTSS_MIPFILTER: dwValue = texf2texfp[min(D3DTEXF_GAUSSIANCUBIC,dwValue)]; break;
    }

    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
                (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            *((UNALIGNED DWORD *)&(lpRState->dwValue)) = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
        (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    *((UNALIGNED DWORD *)&(lpRState->dwValue)) = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
}
//---------------------------------------------------------------------
// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION for indexed primitives
const WORD iprim2cmdop[] = {
    0, // Invalid
    0, // Points are invalid too
    D3DDP2OP_INDEXEDLINELIST2,
    D3DDP2OP_INDEXEDLINESTRIP,
    D3DDP2OP_INDEXEDTRIANGLELIST2,
    D3DDP2OP_INDEXEDTRIANGLESTRIP,
    D3DDP2OP_INDEXEDTRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const WORD prim2cmdop[] = {
    0, // Invalid
    D3DDP2OP_POINTS,
    D3DDP2OP_LINELIST,
    D3DDP2OP_LINESTRIP,
    D3DDP2OP_TRIANGLELIST,
    D3DDP2OP_TRIANGLESTRIP,
    D3DDP2OP_TRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to bytes needed in command stream
const WORD prim2cmdsz[] = {
    0, // Invalid
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2POINTS),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLEFAN)
};
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetVertexShader"

void CD3DDDIDX6::SetVertexShader(DWORD dwHandle)
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));
    DXGASSERT( (dwHandle == 0) || FVF_TRANSFORMED(dwHandle) );
    m_CurrentVertexShader = dwHandle;
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(dwHandle);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetVertexShaderHW"

void CD3DDDIDX6::SetVertexShaderHW(DWORD dwHandle)
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));
    DXGASSERT( (dwHandle == 0) || FVF_TRANSFORMED(dwHandle) );
    m_CurrentVertexShader = dwHandle;
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(dwHandle);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetStreamSource"

void CD3DDDIDX6::SetStreamSource(UINT StreamIndex, CVStream* pStream)
{
    DXGASSERT(StreamIndex == 0);
    m_pStream0 = pStream;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetIndices"

void CD3DDDIDX6::SetIndices(CVIndexStream* pStream)
{
    m_pIStream = pStream;
}
//-----------------------------------------------------------------------------
// Assumes that VB has not been changed between DrawPrimitive calss
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_DrawPrimitiveFast"

void CD3DDDIDX6_DrawPrimitiveFast(CD3DBase* pDevice,
                                  D3DPRIMITIVETYPE primType,
                                  UINT StartVertex,
                                  UINT PrimitiveCount)
{
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);

    UINT NumVertices = GETVERTEXCOUNT(primType, PrimitiveCount);
    pDDI->SetWithinPrimitive(TRUE);

    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }

    pDDI->dwDP2VertexCount = max(pDDI->dwDP2VertexCount,
                                 StartVertex + NumVertices);

    // Check for space in the command buffer for new command.
    // The vertices are already in the vertex buffer.
    if (pDDI->dwDP2CommandLength + prim2cmdsz[primType] > pDDI->dwDP2CommandBufSize)
    {
        pDDI->FlushStates(FALSE, TRUE);
    }

    // Insert non indexed primitive instruction

    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)pDDI->lpvDP2Commands +
                        pDDI->dwDP2CommandLength + pDDI->dp2data.dwCommandOffset);
    pDDI->bDP2CurrCmdOP = (BYTE)prim2cmdop[primType];
    // This will initialize bCommand and bReserved
    *(WORD*)&lpDP2CurrCommand->bCommand = prim2cmdop[primType];
    if (pDDI->bDP2CurrCmdOP != D3DDP2OP_POINTS)
    {
        // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
        pDDI->wDP2CurrCmdCnt = (WORD)PrimitiveCount;
        lpDP2CurrCommand->wPrimitiveCount = (WORD)PrimitiveCount;
        LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
        lpStrip->wVStart = (WORD)StartVertex;
    }
    else
    {
        pDDI->wDP2CurrCmdCnt = 1;
        lpDP2CurrCommand->wPrimitiveCount = 1;
        LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
        lpPoints->wCount = (WORD)NumVertices;
        lpPoints->wVStart = (WORD)StartVertex;
    }
    pDDI->dwDP2CommandLength += prim2cmdsz[primType];

#if DBG
    if (pDDI->m_bValidateCommands)
        pDDI->ValidateCommand(lpDP2CurrCommand);
#endif
    pDDI->SetWithinPrimitive(FALSE);

}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_DrawPrimitive"

void CD3DDDIDX6_DrawPrimitive(CD3DBase* pDevice,
                              D3DPRIMITIVETYPE primType,
                              UINT StartVertex,
                              UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        UINT nVer = GETVERTEXCOUNT(primType, PrimitiveCount);
        pDev->ValidateDraw2(primType, StartVertex, PrimitiveCount, 
                            nVer, FALSE);
    }
#endif // DBG
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);
    CVStream* pStream0 = &pDevice->m_pStream[0];
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(pDevice)->m_pv;

    pv->dwNumVertices = GETVERTEXCOUNT(primType, PrimitiveCount);
    pv->dwVIDOut = pDDI->m_CurrentVertexShader;
    pv->dwOutputSize = pStream0->m_dwStride;
    DXGASSERT(pStream0->m_pVB != NULL);
#if DBG
    if (pStream0->m_dwStride != pDDI->m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif
    if(pStream0->m_pVB->IsD3DManaged())
    {
        BOOL bDirty = FALSE;
        HRESULT result = pDevice->ResourceManager()->UpdateVideo(pStream0->m_pVB->RMHandle(), &bDirty);
        if(result != D3D_OK)
        {
            D3D_THROW(result, "Resource manager failed to create or update video memory VB");
        }
    }

    pDDI->StartPrimVB(pv, pStream0, StartVertex);

    CD3DDDIDX6_DrawPrimitiveFast(pDevice, primType, StartVertex, PrimitiveCount);
    pDevice->m_pfnDrawPrim = CD3DDDIDX6_DrawPrimitiveFast;
}
//-----------------------------------------------------------------------------
// Assumes that VB has not been changed between DrawIndexedPrimitive calls
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_IndexedDrawPrimitiveFast"

void CD3DDDIDX6_DrawIndexedPrimitiveFast(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT BaseVertexIndex,
                                     UINT MinIndex, UINT NumVertices,
                                     UINT StartIndex, UINT PrimitiveCount)
{
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);
    CVIndexStream* pIStream = pDevice->m_pIndexStream;

    UINT  NumIndices = GETVERTEXCOUNT(primType, PrimitiveCount);
    WORD* lpwIndices = (WORD*)(pIStream->Data() + StartIndex * pIStream->m_dwStride);
    pDDI->SetWithinPrimitive(TRUE);

#if DBG
    // DP2 HAL supports 16 bit indices only
    if (pIStream->m_dwStride != 2)
    {
        D3D_THROW_FAIL("Device does not support 32-bit indices");
    }
    DXGASSERT(BaseVertexIndex <= 0xFFFF &&
              NumVertices <= 0xFFFF &&
              PrimitiveCount <= 0xFFFF);
#endif

    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    dwIndicesByteCount = NumIndices << 1;
    dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                  sizeof(D3DHAL_DP2STARTVERTEX);

    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)
                       pDDI->ReserveSpaceInCommandBuffer(dwByteCount);
    pDDI->bDP2CurrCmdOP = (BYTE)iprim2cmdop[primType];
    // This will initialize bCommand and bReserved
    *(WORD*)&lpDP2CurrCommand->bCommand = iprim2cmdop[primType];
    lpDP2CurrCommand->wPrimitiveCount = (WORD)PrimitiveCount;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    WORD* pStartVertex = &((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart;
    pIndices += sizeof(D3DHAL_DP2STARTVERTEX);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_THROW_FAIL("Illegal primitive type");
    }
#endif
    *pStartVertex = (WORD)BaseVertexIndex;
    memcpy(pIndices, lpwIndices, dwIndicesByteCount);

    pDDI->wDP2CurrCmdCnt = (WORD)PrimitiveCount;
    pDDI->dwDP2CommandLength += dwByteCount;

#if DBG
    if (pDDI->m_bValidateCommands)
        pDDI->ValidateCommand(lpDP2CurrCommand);
#endif
    pDDI->dwDP2VertexCount = max(pDDI->dwDP2VertexCount, MinIndex + NumVertices);

    // End of the primitive
    pDDI->SetWithinPrimitive(FALSE);

}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6_IndexedDrawPrimitive"

void CD3DDDIDX6_DrawIndexedPrimitive(CD3DBase* pDevice,
                                     D3DPRIMITIVETYPE primType,
                                     UINT BaseVertexIndex,
                                     UINT MinIndex, UINT NumVertices,
                                     UINT StartIndex, UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        pDev->ValidateDraw2(primType, MinIndex + BaseVertexIndex,
                            PrimitiveCount, NumVertices, TRUE, StartIndex);
    }
#endif // DBG
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(pDevice)->m_pv;
    CD3DDDIDX6* pDDI = static_cast<CD3DDDIDX6*>(pDevice->m_pDDI);
    CVIndexStream* pIStream = pDevice->m_pIndexStream;
    CVStream* pStream0 = &pDevice->m_pStream[0];

    DXGASSERT(pStream0->m_pVB != NULL);
    if(pStream0->m_pVB->IsD3DManaged())
    {
        BOOL bDirty = FALSE;
        HRESULT result = pDevice->ResourceManager()->UpdateVideo(pStream0->m_pVB->RMHandle(), &bDirty);
        if(result != D3D_OK)
        {
            D3D_THROW(result, "Resource manager failed to create or update video memory VB");
        }
    }

    // Parameters needed for StartPrimVB
    pv->dwNumVertices = NumVertices + MinIndex;
    pv->dwVIDOut = pDDI->m_CurrentVertexShader;
    pv->dwOutputSize = pStream0->m_dwStride;
#if DBG
    if (pStream0->m_dwStride != pDDI->m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif

    pDDI->StartPrimVB(pv, pStream0, BaseVertexIndex);

    CD3DDDIDX6_DrawIndexedPrimitiveFast(pDevice, primType, BaseVertexIndex,
                                        MinIndex, NumVertices,
                                        StartIndex, PrimitiveCount);
    pDevice->m_pfnDrawIndexedPrim = CD3DDDIDX6_DrawIndexedPrimitiveFast;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawPrimitiveUP"

void
CD3DDDIDX6::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                            UINT PrimitiveCount)
{
#if DBG
    if (m_pDevice->m_pStream[0].m_dwStride != m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif
    UINT NumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    if (NumVertices > LOWVERTICESNUMBER)
    {
        this->FlushStates();
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
            lpDP2CurrBatchVBI = NULL;
        }
        this->dwDP2VertexCount = NumVertices;
#if DBG
        DXGASSERT(PrimitiveCount <= 0xFFFF && this->dwDP2VertexCount <= 0xFFFF);
#endif
        dp2data.dwVertexType = m_CurrentVertexShader;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
        {
            m_pDevice->UpdateTextures();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
        }
        // Insert non indexed primitive instruction
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                            dwDP2CommandLength + dp2data.dwCommandOffset);
        bDP2CurrCmdOP = (BYTE)prim2cmdop[PrimitiveType];
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpDP2CurrCommand->bReserved = 0;
        if (bDP2CurrCmdOP == D3DDP2OP_POINTS)
        {
            wDP2CurrCmdCnt = 1;
            LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
            lpPoints->wCount = (WORD)this->dwDP2VertexCount;
            lpPoints->wVStart = 0;
        }
        else
        {
            // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
            wDP2CurrCmdCnt = (WORD)PrimitiveCount;
            LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
            lpStrip->wVStart = 0;
        }
        lpDP2CurrCommand->wPrimitiveCount = wDP2CurrCmdCnt;
        dwDP2CommandLength += prim2cmdsz[PrimitiveType];

        this->FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
    }
    else
    {
        // There is no PURE HAL device for pre-DX8 HALs, so this cast is safe
        CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
        D3DFE_PROCESSVERTICES& pv = *pDevice->m_pv;
        // Copy vertices to the internal TL buffer and insert a new 
        // DrawPrimitive command
        UINT VertexPoolSize = m_pDevice->m_pStream[0].m_dwStride * NumVertices;
        pv.dwNumVertices = NumVertices;
        pv.dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;
        pv.primType = PrimitiveType;
        pv.dwNumPrimitives = PrimitiveCount;
        pv.dwVIDOut = m_CurrentVertexShader;
        pv.lpvOut = StartPrimTL(&pv, VertexPoolSize, TRUE);
        memcpy(pv.lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
        DrawPrim(&pv);
        EndPrim(pv.dwOutputSize);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawIndexedPrimitiveUP"

void
CD3DDDIDX6::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                  UINT MinVertexIndex,
                                  UINT NumVertexIndices,
                                  UINT PrimitiveCount)
{
#if DBG
    if (m_pDevice->m_pStream[0].m_dwStride != m_VertexSizeFromShader)
    {
        D3D_THROW_FAIL("Device requires stream stride and vertex size,"
                       "computed from vertex shader, to be the same");
    }
#endif
    if (NumVertexIndices > LOWVERTICESNUMBER)
    {
        this->FlushStates();
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
            lpDP2CurrBatchVBI = NULL;
        }
        this->dwDP2VertexCount = NumVertexIndices + MinVertexIndex;
#if DBG
        DXGASSERT(PrimitiveCount <= 0xFFFF && this->dwDP2VertexCount <= 0xFFFF);
#endif
        dp2data.dwVertexType = m_CurrentVertexShader;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        DWORD dwByteCount;          // Command length plus indices
        DWORD dwIndicesByteCount;   // Indices only
        if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
        {
            m_pDevice->UpdateTextures();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
        }
        dwIndicesByteCount = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount) << 1;
        dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                      sizeof(D3DHAL_DP2STARTVERTEX);

        if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
        {
            // Request the driver to grow the command buffer upon flush
            dp2data.dwReqCommandBufSize = dwByteCount;
            dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
            try
            {
                FlushStates(FALSE,TRUE);
                dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
            }
            catch (HRESULT ret)
            {
                dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
                throw ret;
            }
            // Check if the driver did give us what we need or do it ourselves
            GrowCommandBuffer(dwByteCount);
        }
        // Insert indexed primitive instruction
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                           dwDP2CommandLength + dp2data.dwCommandOffset);
        lpDP2CurrCommand->bReserved = 0;
        lpDP2CurrCommand->wPrimitiveCount = (WORD)PrimitiveCount;

        LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
        lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[PrimitiveType];
        WORD* pStartVertex = &((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart;
        pIndices += sizeof(D3DHAL_DP2STARTVERTEX);
        *pStartVertex = 0;

        bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

        memcpy(pIndices, m_pDevice->m_pIndexStream->m_pData, dwIndicesByteCount);

        wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
        dwDP2CommandLength += dwByteCount;

        this->FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
    }
    else
    {
        // There is no PURE HAL device for pre-DX8 HALs, so this cast is safe
        CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
        D3DFE_PROCESSVERTICES& pv = *pDevice->m_pv;

        m_MinVertexIndex = MinVertexIndex;
        // Copy vertices to the internal TL buffer and insert a new 
        // DrawIndexedPrimitive command
        UINT VertexPoolSize = m_pDevice->m_pStream[0].m_dwStride * NumVertexIndices;
        pv.dwNumVertices = NumVertexIndices;
        pv.dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;
        pv.primType = PrimitiveType;
        pv.dwNumPrimitives = PrimitiveCount;
        pv.dwVIDOut = m_CurrentVertexShader;

        // Copy vertices
        UINT FirstVertexOffset = MinVertexIndex * pv.dwOutputSize;
        pv.lpvOut = StartPrimTL(&pv, VertexPoolSize, TRUE);
        memcpy(pv.lpvOut, m_pDevice->m_pStream[0].m_pData + FirstVertexOffset,
               VertexPoolSize);

        pv.dwNumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        pv.dwIndexSize = m_pDevice->m_pIndexStream->m_dwStride;
        pv.lpwIndices = (WORD*)(m_pDevice->m_pIndexStream->Data());

        m_dwIndexOffset = MinVertexIndex;
        AddVertices(pv.dwNumVertices);

        DrawIndexPrim(&pv);

        MovePrimitiveBase(NumVertexIndices);
        EndPrim(pv.dwOutputSize);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawPrimPS"

void
CD3DDDIDX6::DrawPrimPS(D3DFE_PROCESSVERTICES* pv)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    BYTE* p = (BYTE*)pv->lpvOut;
    float PointSize = *(float*)&pv->lpdwRStates[D3DRS_POINTSIZE];
    float PointSizeMin = *(float*)&pv->lpdwRStates[D3DRS_POINTSIZE_MIN];
    if (PointSize < PointSizeMin)
        PointSize = PointSizeMin;
    if (PointSize > pv->PointSizeMax)
        PointSize = pv->PointSizeMax;

    for (UINT i=0; i < pv->dwNumVertices; i++)
    {
        if (pv->dwVIDOut & D3DFVF_PSIZE)
        {
            PointSize = *(float*)(p + pv->pointSizeOffsetOut);
            if (PointSize < PointSizeMin)
                PointSize = PointSizeMin;
            if (PointSize > pv->PointSizeMax)
                PointSize = pv->PointSizeMax;
        }
        DWORD diffuse = 0;
        DWORD specular = 0;
        if (pv->dwVIDOut & D3DFVF_DIFFUSE)
            diffuse = *(DWORD*)(p + pv->diffuseOffsetOut);
        if (pv->dwVIDOut & D3DFVF_SPECULAR)
            specular = *(DWORD*)(p + pv->specularOffsetOut);
        NextSprite(((float*)p)[0], ((float*)p)[1],   // x, y
                   ((float*)p)[2], ((float*)p)[3],   // z, w
                   diffuse, specular,
                   (float*)(p + pv->texOffsetOut),
                   pv->dwTextureCoordSizeTotal,
                   PointSize);
        p += pv->dwOutputSize;
    }
}
//---------------------------------------------------------------------
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawPrim"

void
CD3DDDIDX6::DrawPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif

    D3DPRIMITIVETYPE primType = pv->primType;
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (pv->primType == D3DPT_POINTLIST &&
        pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        DrawPrimPS(pv);
        return;
    }
    // Check for space in the command buffer for new command.
    // The vertices are already in the vertex buffer.
    if (dwDP2CommandLength + prim2cmdsz[primType] > dwDP2CommandBufSize)
    {
        FlushStates(FALSE,TRUE);
    }
    this->AddVertices(pv->dwNumVertices);
    // Insert non indexed primitive instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = (BYTE)prim2cmdop[primType];
    lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
    lpDP2CurrCommand->bReserved = 0;
    if (bDP2CurrCmdOP == D3DDP2OP_POINTS)
    {
        wDP2CurrCmdCnt = 1;
        LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
        lpPoints->wCount = (WORD)pv->dwNumVertices;
        lpPoints->wVStart = (WORD)this->dwVertexBase;
    }
    else
    {
        // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
        wDP2CurrCmdCnt = (WORD)pv->dwNumPrimitives;
        LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
        lpStrip->wVStart = (WORD)this->dwVertexBase;
    }
    lpDP2CurrCommand->wPrimitiveCount = wDP2CurrCmdCnt;
    dwDP2CommandLength += prim2cmdsz[primType];

    this->MovePrimitiveBase(pv->dwNumVertices);
#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif
}
//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwNumIndices
//      dwIndexOffset
//      dwIndexSize
//      lpwIndices
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDDIDX6::DrawIndexPrim"

void
CD3DDDIDX6::DrawIndexPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
#if DBG
    // DP2 HAL supports 16 bit indices only
    if (pv->dwIndexSize != 2)
    {
        D3D_THROW_FAIL("Device does not support 32-bit indices");
    }
#endif
    this->dwDP2Flags |= D3DDDI_INDEXEDPRIMDRAWN;
    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    dwIndicesByteCount = pv->dwNumIndices << 1;
    dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                  sizeof(D3DHAL_DP2STARTVERTEX);

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)
                       ReserveSpaceInCommandBuffer(dwByteCount);
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wPrimitiveCount = (WORD)pv->dwNumPrimitives;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[pv->primType];
    WORD* pStartVertex = &((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart;
    pIndices += sizeof(D3DHAL_DP2STARTVERTEX);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_THROW_FAIL("Illegal primitive type");
    }
#endif
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

    // We have to handle the case when we copied vertices into our
    // TL buffer, so MinVertexIndex corresponds to 0.
    *pStartVertex = (WORD)this->dwVertexBase;
    if (m_dwIndexOffset == 0)
    {
        memcpy(pIndices, pv->lpwIndices, dwIndicesByteCount);
    }
    else
    if ((WORD)dwVertexBase > (WORD)m_dwIndexOffset)
    {
        // We can modify StartVertex by setting it outside vertex range
        *pStartVertex = (WORD)dwVertexBase - (WORD)m_dwIndexOffset;
        memcpy(pIndices, pv->lpwIndices, dwIndicesByteCount);
    }
    else
    {
        WORD* pout = (WORD*)pIndices;
        WORD* pin  = (WORD*)pv->lpwIndices;
        for (UINT i=0; i < pv->dwNumIndices; i++)
        {
            pout[i] = (WORD)pin[i] - (WORD)m_dwIndexOffset;
        }
    }

    wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
    dwDP2CommandLength += dwByteCount;

#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif

}
//-----------------------------------------------------------------------------
// This primitive is generated by the clipper.
// The vertices of this primitive are pointed to by the
// lpvOut member, which need to be copied into the
// command stream immediately after the command itself.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwOutputSize
//      dwFlags (D3DPV_NONCLIPPED)
//      lpdwRStates (FILLMODE)
//      lpvOut
//      ClipperState.current_vbuf
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::DrawClippedPrim"

void
CD3DDDIDX6::DrawClippedPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    DWORD dwExtra = 0;
    LPVOID lpvVerticesImm;  // Place for vertices
    DWORD dwVertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    if (pv->primType == D3DPT_TRIANGLEFAN)
    {
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
            pv->dwFlags & D3DPV_NONCLIPPED)
        {
            // For unclipped (but pretended to be clipped) tri fans in
            // wireframe mode we generate 3-vertex tri fans to enable drawing
            // of interior edges
            BYTE vertices[__MAX_VERTEX_SIZE*3];
            BYTE *pV1 = vertices + pv->dwOutputSize;
            BYTE *pV2 = pV1 + pv->dwOutputSize;
            BYTE *pInput = (BYTE*)pv->lpvOut;
            memcpy(vertices, pInput, pv->dwOutputSize);
            pInput += pv->dwOutputSize;
            const DWORD nTriangles = pv->dwNumVertices - 2;
            pv->dwNumVertices = 3;
            pv->dwNumPrimitives = 1;
            pv->lpvOut = vertices;
            // Remove this flag for recursive call
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
            for (DWORD i = nTriangles; i; i--)
            {
                memcpy(pV1, pInput, pv->dwOutputSize);
                memcpy(pV2, pInput + pv->dwOutputSize, pv->dwOutputSize);
                pInput += pv->dwOutputSize;
                // To enable all edge flag we set the fill mode to SOLID.
                // This will prevent checking the clip flags in the clipper
                // state
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                DrawClippedPrim(pv);
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
            }
            return;
        }
        dwExtra = sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
    }
    DWORD dwPad;
    dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwDP2CommandLength + dwExtra) & 3;
    DWORD dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwPad + dwExtra +
                        dwVertexPoolSize;

    // Check for space in the command buffer for commands & vertices
    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Flush the current batch but hold on to the vertices
        FlushStates(FALSE,TRUE);
        if (dwByteCount > dwDP2CommandBufSize)
        {
            GrowCommandBuffer(dwByteCount);
        }

        dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwExtra) & 3;
        dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwExtra + dwPad +
                      dwVertexPoolSize;
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->wPrimitiveCount = (WORD)pv->dwNumPrimitives;
    lpDP2CurrCommand->bReserved = 0;
    if (pv->primType == D3DPT_TRIANGLEFAN)
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_TRIANGLEFAN_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        LPD3DHAL_DP2TRIANGLEFAN_IMM lpTriFanImm;
        lpTriFanImm = (LPD3DHAL_DP2TRIANGLEFAN_IMM)(lpDP2CurrCommand + 1);
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
        {
            lpTriFanImm->dwEdgeFlags = 0;
            ClipVertex **clip = pv->ClipperState.current_vbuf;
            // Look at the exterior edges and mark the visible ones
            for(DWORD i = 0; i < pv->dwNumVertices; ++i)
            {
                if (clip[i]->clip & CLIPPED_ENABLE)
                    lpTriFanImm->dwEdgeFlags |= (1 << i);
            }
        }
        else
        {
            // Mark all exterior edges visible
            *((UNALIGNED DWORD *)&(lpTriFanImm->dwEdgeFlags)) = 0xFFFFFFFF;
        }
        lpvVerticesImm = (LPBYTE)(lpTriFanImm + 1) + dwPad;
    }
    else
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_LINELIST_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpvVerticesImm = (LPBYTE)(lpDP2CurrCommand + 1) + dwPad;
    }
    memcpy(lpvVerticesImm, pv->lpvOut, dwVertexPoolSize);
    dwDP2CommandLength += dwByteCount;
#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif

}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::PickProcessPrimitive"

void CD3DDDIDX6::PickProcessPrimitive()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    if (pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        m_pfnProcessPrimitive = ProcessPointSprites;
    }
    else
    if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
    {
        // Transformed vertices should not be processed using
        // m_pfnProcessPrimitive. They should go directly to the DDI using
        // pDevice->m_pfnDrawPrim
        m_pfnProcessPrimitive = ProcessPrimitive;
        m_pfnProcessIndexedPrimitive = ProcessIndexedPrimitive;
    }
    else
    {
        if (pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF)
        {
            m_pfnProcessPrimitive = ProcessPrimitiveTC;
            m_pfnProcessIndexedPrimitive = ProcessIndexedPrimitiveTC;
        }
        else
        {
            m_pfnProcessPrimitive = ProcessPrimitiveC;
            m_pfnProcessIndexedPrimitive = ProcessIndexedPrimitiveC;
        }
    }
}
//-----------------------------------------------------------------------------
// The function does the point sprite expansion
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPointSprites"

void
CD3DDDIDX6::ProcessPointSprites(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    DWORD dwOldCullMode = D3DCULL_NONE;   
    DWORD dwOldFillMode = D3DFILL_SOLID;
    // Point spritest should not be culled. They are generated assuming that 
    // D3DCULL_CCW is set
    if (pDevice->rstates[D3DRS_CULLMODE] == D3DCULL_CW)
    {
        dwOldCullMode = D3DCULL_CW;
        SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    }

    // In case of multitexture we need to re-program texture stages to use
    // texture coordonate set 0, because we generate only one set during
    // emulation
    DWORD TexCoordIndex[D3DDP_MAXTEXCOORD];
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevice->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;
        if (pDevice->m_lpD3DMappedTexI[i])
        {
            DWORD dwIndex = pDevice->tsstates[i][D3DTSS_TEXCOORDINDEX];
            if (dwIndex != 0)
            {
                TexCoordIndex[i] = dwIndex;
                SetTSS(i, D3DTSS_TEXCOORDINDEX, 0);
            }
            else
            {
                // Mark stage to not restore
                TexCoordIndex[i] = 0xFFFFFFFF;
            }
        }
    }

    // Fill mode should be SOLID for point sprites
    if (pDevice->rstates[D3DRS_FILLMODE] != D3DFILL_SOLID)
    {
        dwOldFillMode = pDevice->rstates[D3DRS_FILLMODE];
        SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    }
    // Compute new output FVF
    m_dwVIDOutPS = pv->dwVIDOut;
    m_dwVIDOutPS &= ~D3DFVF_PSIZE;
    if (pv->lpdwRStates[D3DRS_POINTSPRITEENABLE])
    {
        // Generate two floats for texture coord set
        m_dwVIDOutPS &= 0xFF;
        m_dwVIDOutPS |= D3DFVF_TEX1;
    }
    m_dwOutputSizePS = ComputeVertexSizeFVF(m_dwVIDOutPS);

    StartPointSprites();

    UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;

    if (pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF)
    {
        // In case of transformed vertices, input is user memory (or vertex 
        // buffer) and the output is internal TL buffer
        pv->dwOutputSize = pv->position.dwStride;
        if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            pv->lpvOut = (BYTE*)pv->position.lpvData;
            DrawPrim(pv);
        }
        else
        {
            if (!(pv->dwDeviceFlags & D3DDEV_DONOTCOMPUTECLIPCODES))
                PrepareForClipping(pv, StartVertex);

            pv->lpvOut = (BYTE*)pv->position.lpvData;
            HRESULT ret = D3D_OK;
            if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
            {
                // Compute clip codes, because there was no ProcessVertices
                DWORD clip_intersect = D3DFE_GenClipFlags(pv);
                UpdateClipStatus(pDevice);
                if (clip_intersect)
                {
                    goto l_exit;
                }
                // There are some vertices inside the screen
                if ( CheckIfNeedClipping(pv))
                    ret = ProcessClippedPointSprites(pv);
                else
                    DrawPrim(pv);
                }
            else
            {
                // With the result of ProcessVertices as input we do not know
                // clip union, so we need always do clipping
                ret = ProcessClippedPointSprites(pv);
            }

            if (ret != D3D_OK)
            {
                EndPointSprites();
                throw ret;
            }
        }
    }
    else
    {
        if (!(pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
            PrepareForClipping(pv, 0);

        // Update lighting and related flags
        if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
            DoUpdateState(pDevice);

        UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
        pv->lpvOut = m_pPointStream->Lock(VertexPoolSize, this);

        // We call ProcessVertices instead of DrawPrimitive, because we want to
        // process sprites which are clippied by X or Y planes
        DWORD clipIntersection = pv->pGeometryFuncs->ProcessVertices(pv);

        HRESULT ret = D3D_OK;
        if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            DrawPrim(pv);
        }
        else
        {
            // We throw away points which are clipped by Z or by user planes.
            // Otherwise a point sprite could be partially visible
            clipIntersection &= ~(D3DCS_LEFT | D3DCS_RIGHT | 
                                  D3DCS_TOP | D3DCS_BOTTOM |
                                  __D3DCLIPGB_ALL);
            if (!clipIntersection)
            {
                // There are some vertices inside the screen
                if (!CheckIfNeedClipping(pv))
                    DrawPrim(pv);
                else
                    ret = ProcessClippedPointSprites(pv);
            }
        }

        m_pPointStream->Unlock();
        m_pPointStream->Reset();
        
        if (ret != D3D_OK)
            D3D_THROW(ret, "Error in PSGP");

        if (!(pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
            UpdateClipStatus(pDevice);
    }
l_exit:
    EndPointSprites();
    // Restore fill mode and cull mode if needed
    if (dwOldCullMode != D3DCULL_NONE)
    {
        SetRenderState(D3DRS_CULLMODE, dwOldCullMode);
    }
    if (dwOldFillMode != D3DFILL_SOLID)
    {
        SetRenderState(D3DRS_FILLMODE, dwOldFillMode);
    }
    // We need to re-send API vertex shader to the driver next time 
    // SetVertexShader is called. If we do not call the function then next 
    // the same SetVertexShader call will be ignored and driver vertex shader
    // will not be updated
    static_cast<CD3DHal*>(m_pDevice)->ForceFVFRecompute();

    // Now we need to restore re-programmed stages
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevice->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;
        if (pDevice->m_lpD3DMappedTexI[i] && TexCoordIndex[i] != 0xFFFFFFFF)
        {
            this->SetTSS(i, D3DTSS_TEXCOORDINDEX, TexCoordIndex[i]);
        }
    }
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with transformed vertices and with
// clipping
//
// Only transformed vertices generated by ProcessVertices call are allowed here
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPrimitiveTC"

void
CD3DDDIDX6::ProcessPrimitiveTC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    CVStream* pStream = &m_pDevice->m_pStream[0];

    PrepareForClipping(pv, StartVertex);

    pv->dwOutputSize = pStream->m_dwStride;
    pv->lpvOut = pv->position.lpvData;

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        DXGASSERT(StartVertex == 0);
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
    }
    else
        StartPrimVB(pv, pStream, StartVertex);
    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pDevice->m_pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    HRESULT ret = pDevice->GeometryFuncsGuaranteed->DoDrawPrimitive(pv);
    if (ret != D3D_OK)
    {
        EndPrim(pv->dwOutputSize);
        throw ret;
    }
l_exit:
    EndPrim(pv->dwOutputSize);
    pv->dwFlags &= ~D3DPV_TLVCLIP;
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and with
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPrimitiveC"

void
CD3DDDIDX6::ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    PrepareForClipping(pv, 0);
    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);
    // When a triangle strip is clipped, we draw indexed primitives
    // sometimes. So we set m_dwIndexOffset to zero.
    m_dwIndexOffset = 0;
    UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    pv->lpvOut = StartPrimTL(pv, VertexPoolSize, TRUE);

    HRESULT ret = pv->pGeometryFuncs->ProcessPrimitive(pv);
    if (ret != D3D_OK)
    {
        EndPrim(pv->dwOutputSize);
        D3D_THROW(ret, "Error in PSGP");
    }
    EndPrim(pv->dwOutputSize);
    UpdateClipStatus(pDevice);
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and without
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessPrimitive"

void
CD3DDDIDX6::ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    UINT VertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    pv->lpvOut = StartPrimTL(pv, VertexPoolSize, NeverReadFromTLBuffer(pv));

    HRESULT ret = pv->pGeometryFuncs->ProcessPrimitive(pv);
    if (ret != D3D_OK)
    {
        EndPrim(pv->dwOutputSize);
        D3D_THROW(ret, "Error in PSGP");
    }
    EndPrim(pv->dwOutputSize);
}
//-----------------------------------------------------------------------------
// Processes indexed primitive with untransformed vertices and without clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessIndexedPrimitive"

void
CD3DDDIDX6::ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    m_dwIndexOffset = m_MinVertexIndex;
    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, TRUE);
    AddVertices(pv->dwNumVertices);

    HRESULT ret = pv->pGeometryFuncs->ProcessIndexedPrimitive(pv);

    MovePrimitiveBase(pv->dwNumVertices);
    EndPrim(pv->dwOutputSize);

    if (ret != D3D_OK)
        D3D_THROW(ret, "Error in PSGP");
}
//-----------------------------------------------------------------------------
// Processes indexed primitive with untransformed vertices and witht clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessIndexedPrimitiveC"

void
CD3DDDIDX6::ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    PrepareForClipping(pv, 0);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->dwIndexOffset = m_MinVertexIndex;   // For clipping
    m_dwIndexOffset = m_MinVertexIndex;     // For DrawIndexPrim
    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, FALSE);
    DWORD dwNumVertices = pv->dwNumVertices;
    AddVertices(pv->dwNumVertices);

    this->dwDP2Flags &= ~D3DDDI_INDEXEDPRIMDRAWN;

    HRESULT ret = pv->pGeometryFuncs->ProcessIndexedPrimitive(pv);

    if (this->dwDP2Flags & D3DDDI_INDEXEDPRIMDRAWN)
    {
        // There was a indexed primitive drawn
        MovePrimitiveBase(dwNumVertices);
    }
    else
    {
        // All triangle were clipped. Remove vertices from TL buffer
        SubVertices(dwNumVertices);
    }
    EndPrim(pv->dwOutputSize);
    UpdateClipStatus(pDevice);

    if (ret != D3D_OK)
        D3D_THROW(ret, "Error in PSGP");
}
//-----------------------------------------------------------------------------
// Processes indexed primitive with transformed vertices and with clipping
//
// Only transformed vertices generated by ProcessVertices call are allowed here
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ProcessIndexedPrimitiveTC"

void
CD3DDDIDX6::ProcessIndexedPrimitiveTC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    HRESULT ret = S_OK;
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    CVStream* pStream = &m_pDevice->m_pStream[0];
    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    PrepareForClipping(pv, StartVertex);

    pv->dwOutputSize = pStream->m_dwStride;
    pv->lpvOut = pv->position.lpvData;
    pv->dwNumVertices = m_MinVertexIndex + m_NumVertices;

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        // We copy user vertices, starting from MinVertexIndex, to the internal
        // TL buffer and do the clipping. Vertex base changes in the process.

        // m_NumVertices has been computed as MinVertexIndex + NumVertices, so 
        // it needs to be adjusted, because vertex base has benn changed
        m_NumVertices -= m_MinVertexIndex;
        pv->dwNumVertices = m_NumVertices;
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, 
               m_pDevice->m_pStream[0].m_pData + m_MinVertexIndex * pv->dwOutputSize, 
               VertexPoolSize);
        // Pre-DX8 DDI does not have BaseVertexIndex parameter, so we need to 
        // re-compute indices before passing them to the driver to reflect
        // the changed vertex base
        m_dwIndexOffset = m_MinVertexIndex ;
    }
    else
    {
        StartPrimVB(pv, pStream, m_BaseVertexIndex);
        m_dwIndexOffset = 0;                    // For DrawIndexPrim
    }

    pv->dwNumVertices = m_NumVertices;

    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    
    pv->dwIndexOffset = m_MinVertexIndex ;    // For clipping
    this->dwDP2Flags &= ~D3DDDI_INDEXEDPRIMDRAWN;
    DWORD dwNumVertices = pv->dwNumVertices;
    AddVertices(pv->dwNumVertices);

    ret = pDevice->GeometryFuncsGuaranteed->DoDrawIndexedPrimitive(pv);

    if (this->dwDP2Flags & D3DDDI_INDEXEDPRIMDRAWN)
    {
        // There was an indexed primitive drawn
        MovePrimitiveBase(dwNumVertices);
    }
    else
    {
        // All triangles were clipped. Remove vertices from TL buffer
        SubVertices(dwNumVertices);
    }
l_exit:
    pv->dwFlags &= ~D3DPV_TLVCLIP;
    EndPrim(pv->dwOutputSize);
    UpdateClipStatus(pDevice);
    if (ret != D3D_OK)
        throw ret;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::GrowCommandBuffer"

// Check and grow command buffer
void CD3DDDIDX6::GrowCommandBuffer(DWORD dwSize)
{
    HRESULT ret;
    if (dwSize > dwDP2CommandBufSize)
    {
        if (lpDDSCB1)
        {
            lpDDSCB1->DecrementUseCount();
            lpDDSCB1 = NULL;
        }
        // Create command buffer through Framework.
        // NOTE: Command buffers are always REF_INTERNAL
        // objects and must be released through
        // DecrementUseCount
        //
        ret = CCommandBuffer::Create(m_pDevice,
                                     dwSize,
                                     D3DPOOL_SYSTEMMEM,
                                     &lpDDSCB1);
        if (ret != DD_OK)
        {
            dwDP2CommandBufSize = 0;
            D3D_THROW(ret, "Failed to allocate Command Buffer");
        }
        // Lock command buffer
        ret = lpDDSCB1->Lock(0, dwSize, (BYTE**)&lpvDP2Commands, NULL);
        if (ret != DD_OK)
        {
            lpDDSCB1->DecrementUseCount();
            lpDDSCB1 = NULL;
            dwDP2CommandBufSize = 0;
            D3D_THROW(ret, "Could not lock command buffer");
        }
        // lpDDCommands will be filled in by the thunk layer
        dp2data.hDDCommands = lpDDSCB1->DriverAccessibleKernelHandle();
        dwDP2CommandBufSize = dwSize;
    }
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called if vertices from user memory are used for rendering
//
// If bWriteOnly is set to TRUE, then there will be no read from the vertex
// processing output (no clipping or TL HAL).
//
// Expects the following members of D3DFE_PROCESSVERTICES to be initialized
//      dwNumVertices
//      lpvOut
//      dwOutputSize
//      dwVIDOut
//
// We fail vid mem VB for clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPrimUserMem"

void
CD3DDDIDX6::StartPrimUserMem(D3DFE_PROCESSVERTICES* pv, UINT VertexPoolSize)
{
    // If the primitive is small, we copy vertices into the TL buffer
    if (pv->dwNumVertices < LOWVERTICESNUMBER)
    {
        LPVOID tmp = StartPrimTL(pv, VertexPoolSize, TRUE);
        memcpy(tmp, pv->lpvOut, VertexPoolSize);
        this->dwDP2VertexCount += pv->dwNumVertices;
    }
    else
    {
        // We can not mix user memory primitive with other primitives, so
        // flush the batch.
        // Do not forget to flush the batch after rendering this primitive
        this->FlushStates();

        SetWithinPrimitive( TRUE );
        // Release previously used vertex buffer (if any), because we do not
        // it any more
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
            lpDP2CurrBatchVBI = NULL;
        }
        dp2data.dwVertexType = pv->dwVIDOut;
        dp2data.dwVertexSize = pv->dwOutputSize;
        dp2data.lpVertices = pv->lpvOut;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2Flags |= D3DDDI_USERMEMVERTICES;
        this->dwDP2VertexCount = pv->dwNumVertices;
        this->dwDP2VertexCountMask = 0;
    }
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
// Uses the following data from D3DFE_PROCESSVERTICES:
//      pv->dwVIDOut
//      pv->dwOutputSize
//      pv->dwNumVertices
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPrimVB"

void
CD3DDDIDX6::StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                        DWORD dwStartVertex)
{
    CVertexBuffer * lpVBI = pStream->m_pVB;
    // If VID has been changed or new vertex buffer is used we flush the batch
    if (pv->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI)
    {
        this->FlushStates();
        dp2data.dwVertexType = pv->dwVIDOut;
        dp2data.dwVertexSize = pv->dwOutputSize;
        dp2data.hDDVertex = lpVBI->DriverAccessibleKernelHandle();
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did IncrementUseCount() to TL buffer,
        // so it is safe.
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
        }
        // If a vertex buffer is used for rendering, make sure that it is no
        // released by user. So do IncrementUseCount().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->IncrementUseCount();
    }
    DXGASSERT(dp2data.hDDVertex == lpVBI->DriverAccessibleKernelHandle());
    lpDP2CurrBatchVBI->Batch();
    SetWithinPrimitive( TRUE );
    this->dwVertexBase = dwStartVertex;
    dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
    this->dwDP2VertexCount = max(this->dwDP2VertexCount,
                                 this->dwVertexBase + pv->dwNumVertices);
    // Prevent modification of dwDP2VertexCount during DrawPrim
    this->dwDP2VertexCountMask = 0;
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called when the runtime needs to output vertices to a TL buffer
// TL buffer grows if necessary
//
// Uses the following global variables:
//      pv->dwVIDOut
//      pv->dwNumVertices
//      this->dp2data
//      this->dwDP2VertexCount;
//      this->lpDP2CurrBatchVBI
//      this->dwDP2Flags
//      pv->dwOutputSize
// Updates the following variables:
//      this->dwVertexBase
//      this->dwDP2VertexCount;
//      this->lpDP2CurrBatchVBI
//      dp2data.dwFlags
 //     Sets "within primitive" to TRUE
// Returns:
//      TL buffer address
//
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPrimTL"

LPVOID
CD3DDDIDX6::StartPrimTL(D3DFE_PROCESSVERTICES * pv, DWORD dwVertexPoolSize,
                        BOOL bWriteOnly)
{
    if (bWriteOnly)
    {
        if (dwVertexPoolSize > this->GetTLVbufSize())
        {
            this->GrowTLVbuf(dwVertexPoolSize, TRUE);
        }
    }
    else
    {
        if (this->dwDP2Flags & D3DDDI_TLVBUFWRITEONLY ||
            dwVertexPoolSize > this->GetTLVbufSize())
        {
            this->GrowTLVbuf(dwVertexPoolSize, FALSE);
        }
    }

    CVertexBuffer * lpVBI = this->TLVbuf_GetVBI();

    // If VID has been changed or new vertex buffer is used we flush the batch
    if (pv->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI ||
        dp2data.hDDVertex != lpVBI->DriverAccessibleKernelHandle())
    {
        this->FlushStates();
        dp2data.dwVertexType = pv->dwVIDOut;
        dp2data.dwVertexSize = pv->dwOutputSize;
        dp2data.hDDVertex = lpVBI->DriverAccessibleKernelHandle();
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did IncrementUseCount() to TL buffer,
        // so it is safe.
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->DecrementUseCount();
        }
        // If a vertex buffer is used for rendering, make sure that it is not
        // released by user. So do IncrementUseCount().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->IncrementUseCount();
    }
    SetWithinPrimitive( TRUE );
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
    this->dwDP2VertexCountMask = 0xFFFFFFFF;

    return this->TLVbuf_GetAddress();
}
//---------------------------------------------------------------------
// This function should not be called from DrawVertexBufferVB
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::EndPrim"

void
CD3DDDIDX6::EndPrim(UINT vertexSize)
{
    // Should be called before the FlushStates
    SetWithinPrimitive(FALSE);
    if (this->dwDP2Flags & D3DDDI_USERMEMVERTICES)
        // We can not mix user memory primitive, so flush it.
    {
        FlushStates();
        this->dwDP2Flags &= ~D3DDDI_USERMEMVERTICES;
    }
    else
    if (lpDP2CurrBatchVBI == this->TLVbuf_GetVBI())
    {
        // If TL buffer was used, we have to move its internal base pointer
        this->TLVbuf_Base() = this->dwDP2VertexCount * vertexSize;
#if DBG
        if (this->TLVbuf_base > this->TLVbuf_size)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Internal error: TL buffer error");
        }
#endif
    }
}
//----------------------------------------------------------------------
// Growing aligned vertex buffer implementation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::GrowTLVbuf"

void
CD3DDDIDX6::GrowTLVbuf(DWORD growSize, BOOL bWriteOnly)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    DWORD dwRefCnt = 1;
    // Is ref cnt of TLVbuf 1 or 2 ?
    DWORD bTLVbufIsCurr = this->allocatedBuf == this->lpDP2CurrBatchVBI;

    BOOL bDP2WriteOnly = (dwDP2Flags & D3DDDI_TLVBUFWRITEONLY) != 0;
    // Avoid to many changes. Restrict TLVbuf to sys mem if too many changes
    if (this->dwTLVbufChanges >= D3D_MAX_TLVBUF_CHANGES)
    {
#if DBG
        if (this->dwTLVbufChanges == D3D_MAX_TLVBUF_CHANGES)
            DPF(1, "Too many changes: Limiting internal VB to sys mem.");
#endif
        bWriteOnly = FALSE;
    }
    if (this->TLVbuf_base || (bWriteOnly != bDP2WriteOnly))
    {
        FlushStatesReq(growSize);
        this->TLVbuf_base = 0;
    }
    if (growSize <= this->TLVbuf_size)
    {
        if (bWriteOnly == bDP2WriteOnly)
            return;
        else
            this->dwTLVbufChanges++;
    }
    if (this->allocatedBuf)
    {
        this->allocatedBuf->DecrementUseCount();
        this->allocatedBuf = NULL;
    }
    if (bTLVbufIsCurr)
    {
        if (this->lpDP2CurrBatchVBI)
            this->lpDP2CurrBatchVBI->DecrementUseCount();
        this->lpDP2CurrBatchVBI = NULL;
        this->dp2data.lpVertices = NULL;
    }
    DWORD dwNumVerts = (max(growSize, TLVbuf_size) + 31) / sizeof(D3DTLVERTEX);
    this->TLVbuf_size = dwNumVerts * sizeof(D3DTLVERTEX);
    D3DPOOL Pool = D3DPOOL_DEFAULT;
    DWORD dwUsage = D3DUSAGE_INTERNALBUFFER | D3DUSAGE_DYNAMIC;
    if (bWriteOnly)
    {
        dwUsage |= D3DUSAGE_WRITEONLY;
        dwDP2Flags |= D3DDDI_TLVBUFWRITEONLY;
    }
    else
    {
        dwDP2Flags &= ~D3DDDI_TLVBUFWRITEONLY;
    }
    LPDIRECT3DVERTEXBUFFER8 t;
    HRESULT ret = CVertexBuffer::Create(pDevice,
                                        this->TLVbuf_size,
                                        dwUsage,
                                        D3DFVF_TLVERTEX,
                                        Pool,
                                        REF_INTERNAL,
                                        &t); // This should fail duirng ulta-low memory situations. 
    if (ret != DD_OK)
    {
        // We set allocatedBuf to a valid VB object since it gets dereferenced many places without
        // checking for it being NULL. WE use the special "NULL" VB created at init time for just 
        // this purpose
        allocatedBuf = m_pNullVB;
        if (m_pNullVB) // We do this check because GrowTLVbuf will be called before m_pNullVB is set first time round.
        {
            allocatedBuf->IncrementUseCount();
            // Update lpDP2CurrentBatchVBI if necessary
            if (bTLVbufIsCurr)
            {
                lpDP2CurrBatchVBI = allocatedBuf;
                lpDP2CurrBatchVBI->IncrementUseCount();
                dp2data.hDDVertex = lpDP2CurrBatchVBI->DriverAccessibleKernelHandle();
            }
        }
        this->TLVbuf_size = 0;
        this->alignedBuf = NULL; // Lets see if some one tries to use this...
        D3D_THROW(ret, "Could not allocate internal vertex buffer");
    }
    allocatedBuf = static_cast<CVertexBuffer*>(t);
    ret = allocatedBuf->Lock(0, this->TLVbuf_size, (BYTE**)&alignedBuf, 0);
    if (ret != DD_OK)
    {
        TLVbuf_size = 0;
        alignedBuf = NULL; // Lets see if some one tries to use this...
        D3D_THROW(ret, "Could not lock internal vertex buffer");
    }
    // Update lpDP2CurrentBatchVBI if necessary
    if (bTLVbufIsCurr)
    {
        lpDP2CurrBatchVBI = allocatedBuf;
        lpDP2CurrBatchVBI->IncrementUseCount();
        dp2data.hDDVertex = lpDP2CurrBatchVBI->DriverAccessibleKernelHandle();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::Clear"

void
CD3DDDIDX6::Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
                  D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    HRESULT err;
    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known
    // state for Clears that don't use tris (i.e. HAL Clears and Blts).
    // Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later


    FlushStates();

    // Clear2 HAL Callback exists
    D3D8_CLEAR2DATA Clear2Data;
    Clear2Data.dwhContext   = m_dwhContext;
    Clear2Data.dwFlags      = dwFlags;
    // Here I will follow the ClearData.dwFillColor convention that
    // color word is raw 32bit ARGB, unadjusted for surface bit depth
    Clear2Data.dwFillColor  = dwColor;
    // depth/stencil values both passed straight from user args
    Clear2Data.dvFillDepth  = dvZ;
    Clear2Data.dwFillStencil= dwStencil;
    Clear2Data.lpRects      = clrRects;
    Clear2Data.dwNumRects   = clrCount;
    Clear2Data.ddrval       = D3D_OK;
    Clear2Data.hDDS         = m_pDevice->RenderTarget()->KernelHandle();
    if(m_pDevice->ZBuffer() != 0)
    {
        Clear2Data.hDDSZ    = m_pDevice->ZBuffer()->KernelHandle();
    }
    else
    {
        Clear2Data.hDDSZ    = NULL;
    }
    err = m_pDevice->GetHalCallbacks()->Clear2(&Clear2Data);
    if (err != DDHAL_DRIVER_HANDLED)
    {
        D3D_THROW(E_NOTIMPL, "Driver does not support Clear");
    }
    else if (Clear2Data.ddrval != DD_OK)
    {
        D3D_THROW(Clear2Data.ddrval, "Error in Clear");
    }
    else
        return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::LockVB"

HRESULT __declspec(nothrow) CD3DDDIDX6::LockVB(CDriverVertexBuffer *pVB, DWORD dwFlags)
{
    if(pVB->GetCachedDataPointer() == 0)
    {
        HRESULT hr = pVB->LockI((dwFlags & D3DLOCK_DISCARD) | D3DLOCK_NOSYSLOCK);
        if(FAILED(hr))
        {
            DPF_ERR("Driver failed to lock a vertex buffer" 
                    " when attempting to cache the lock.");
            return hr;
        }
        DXGASSERT(pVB->GetCachedDataPointer() != 0);
    }
    else
    {
        DXGASSERT((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0);
        // We CANNOT use the usual Sync check here (ie Device->BatchNumber <= pVB->BatchNumber)
        // since there are situations in which this condition is true, but the VB is not really
        // batched at all! This is the case for instance, when StartPrimVB calls FlushStates.
        // FlushStates rebatches the current VB but StartPrimVB then switches to a new one. So 
        // both new and old "appear" batched, but only one of them is. This would be harmless 
        // (as it is for textures), were it not for the fact that we call FlushStatesReq to 
        // swap the pointer. When we call FlushStatesReq on an unbatched VB, we pretty much 
        // swap a random pointer with very bad effects. This repros in the Unreal driver. (snene)
        if(static_cast<CVertexBuffer*>(pVB) == lpDP2CurrBatchVBI)
        {
            try
            {
                if((dwFlags & D3DLOCK_DISCARD) != 0)
                {
                    FlushStatesReq(pVB->GetBufferDesc()->Size);
                }
                else
                {
                    FlushStates();
                }
            }
            catch(HRESULT hr)
            {
                DPF_ERR("Driver failed the command batch submitted to it" 
                        " when attempting to swap the current pointer"
                        " in response to D3DLOCK_DISCARDCONTENTS.");
                pVB->SetCachedDataPointer(0);
                return hr;
            }
            DXGASSERT(pVB->GetCachedDataPointer() != 0);
        }
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::UnlockVB"

HRESULT __declspec(nothrow) CD3DDDIDX6::UnlockVB(CDriverVertexBuffer *pVB)
{
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::EndScene"
void
CD3DDDIDX6::EndScene()
{
    this->dwTLVbufChanges = 0; // reset this every frame
    SceneCapture(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX7                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
CD3DDDIDX7::CD3DDDIDX7() : CD3DDDIDX6()
{
    m_ddiType = D3DDDITYPE_DX7;
}
//-----------------------------------------------------------------------------
CD3DDDIDX7::~CD3DDDIDX7()
{
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetRenderTarget"

void
CD3DDDIDX7::SetRenderTarget(CBaseSurface *pTarget, CBaseSurface* pZBuffer)
{
    LPD3DHAL_DP2SETRENDERTARGET pData;
    pData = (LPD3DHAL_DP2SETRENDERTARGET)
             GetHalBufferPointer(D3DDP2OP_SETRENDERTARGET, sizeof(*pData));
    pData->hRenderTarget = pTarget->DrawPrimHandle();
    if (pZBuffer)
        pData->hZBuffer = pZBuffer->DrawPrimHandle();
    else
        pData->hZBuffer = 0;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::TexBlt"

void
CD3DDDIDX7::TexBlt(DWORD dwDst, DWORD dwSrc,
                   LPPOINT p, RECTL *r)
{
    if (bDP2CurrCmdOP == D3DDP2OP_TEXBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXBLT) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpTexBlt->dwDDDestSurface   = dwDst;
            lpTexBlt->dwDDSrcSurface    = dwSrc;
            lpTexBlt->pDest             = *p;
            lpTexBlt->rSrc              = *r;
            lpTexBlt->dwFlags           = 0;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXBLT);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXBLT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXBLT;
    bDP2CurrCmdOP = D3DDP2OP_TEXBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)(lpDP2CurrCommand + 1);
    ((UNALIGNED D3DHAL_DP2TEXBLT *)lpTexBlt)->dwDDDestSurface   = dwDst;
    ((UNALIGNED D3DHAL_DP2TEXBLT *)lpTexBlt)->dwDDSrcSurface    = dwSrc;
    ((UNALIGNED D3DHAL_DP2TEXBLT *)lpTexBlt)->pDest             = *p;
    ((UNALIGNED D3DHAL_DP2TEXBLT *)lpTexBlt)->rSrc              = *r;
    ((UNALIGNED D3DHAL_DP2TEXBLT *)lpTexBlt)->dwFlags           = 0;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXBLT);

    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::InsertStateSetOp"

void
CD3DDDIDX7::InsertStateSetOp(DWORD dwOperation, DWORD dwParam,
                             D3DSTATEBLOCKTYPE sbt)
{
    LPD3DHAL_DP2STATESET pData;
    pData = (LPD3DHAL_DP2STATESET)GetHalBufferPointer(D3DDP2OP_STATESET,
                                                      sizeof(*pData));
    pData->dwOperation = dwOperation;
    pData->dwParam = dwParam;
    pData->sbType = sbt;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SceneCapture"

void
CD3DDDIDX7::SceneCapture(BOOL bState)
{
    SetRenderState((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, bState);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetPriority"

void
CD3DDDIDX7::SetPriority(CResource *pRes, DWORD dwPriority)
{
    DXGASSERT(pRes->BaseDrawPrimHandle() == pRes->DriverAccessibleDrawPrimHandle());

    if (bDP2CurrCmdOP == D3DDP2OP_SETPRIORITY)
    { // Last instruction is a set priority, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETPRIORITY) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetPriority->dwDDSurface    = pRes->BaseDrawPrimHandle();
            lpSetPriority->dwPriority     = dwPriority;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETPRIORITY);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

            pRes->BatchBase();
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPRIORITY) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new setpriority instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPRIORITY;
    bDP2CurrCmdOP = D3DDP2OP_SETPRIORITY;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)(lpDP2CurrCommand + 1);
    lpSetPriority->dwDDSurface = pRes->BaseDrawPrimHandle();
    lpSetPriority->dwPriority  = dwPriority;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPRIORITY);

    pRes->BatchBase();
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetTexLOD"

void
CD3DDDIDX7::SetTexLOD(CBaseTexture *pTex, DWORD dwLOD)
{
    DXGASSERT(pTex->BaseDrawPrimHandle() == pTex->DriverAccessibleDrawPrimHandle());

    if (bDP2CurrCmdOP == D3DDP2OP_SETTEXLOD)
    { // Last instruction is a set LOD, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETTEXLOD) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetTexLOD->dwDDSurface      = pTex->BaseDrawPrimHandle();
            lpSetTexLOD->dwLOD            = dwLOD;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETTEXLOD);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

            pTex->BatchBase();
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETTEXLOD) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new set LOD instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETTEXLOD;
    bDP2CurrCmdOP = D3DDP2OP_SETTEXLOD;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)(lpDP2CurrCommand + 1);
    lpSetTexLOD->dwDDSurface = pTex->BaseDrawPrimHandle();
    lpSetTexLOD->dwLOD       = dwLOD;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETTEXLOD);

    pTex->BatchBase();
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::AddDirtyRect"

void
CD3DDDIDX7::AddDirtyRect(DWORD dwHandle, CONST RECTL *pRect)
{
    if (bDP2CurrCmdOP == D3DDP2OP_ADDDIRTYRECT)
    { // Last instruction is a adddirtyrect, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2ADDDIRTYRECT) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2ADDDIRTYRECT lpDirtyRect = (LPD3DHAL_DP2ADDDIRTYRECT)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpDirtyRect->dwSurface  = dwHandle;
            lpDirtyRect->rDirtyArea = *pRect;
            dwDP2CommandLength += sizeof(D3DHAL_DP2ADDDIRTYRECT);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2ADDDIRTYRECT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_ADDDIRTYRECT;
    bDP2CurrCmdOP = D3DDP2OP_ADDDIRTYRECT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add adddirtyrect data
    LPD3DHAL_DP2ADDDIRTYRECT lpDirtyRect = (LPD3DHAL_DP2ADDDIRTYRECT)(lpDP2CurrCommand + 1);
    lpDirtyRect->dwSurface  = dwHandle;
    lpDirtyRect->rDirtyArea = *pRect;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ADDDIRTYRECT);

    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::AddDirtyBox"

void
CD3DDDIDX7::AddDirtyBox(DWORD dwHandle, CONST D3DBOX *pBox)
{
    if (bDP2CurrCmdOP == D3DDP2OP_ADDDIRTYBOX)
    { // Last instruction is a adddirtybox, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2ADDDIRTYBOX) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2ADDDIRTYBOX lpDirtyBox = (LPD3DHAL_DP2ADDDIRTYBOX)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpDirtyBox->dwSurface = dwHandle;
            lpDirtyBox->DirtyBox  = *pBox;
            dwDP2CommandLength += sizeof(D3DHAL_DP2ADDDIRTYBOX);
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2ADDDIRTYBOX) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_ADDDIRTYBOX;
    bDP2CurrCmdOP = D3DDP2OP_ADDDIRTYBOX;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add adddirtybox data
    LPD3DHAL_DP2ADDDIRTYBOX lpDirtyBox = (LPD3DHAL_DP2ADDDIRTYBOX)(lpDP2CurrCommand + 1);
    lpDirtyBox->dwSurface = dwHandle;
    lpDirtyBox->DirtyBox  = *pBox;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ADDDIRTYBOX);

    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::Clear"

void
CD3DDDIDX7::Clear(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects,
                  D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2CLEAR) + sizeof(RECT) * (clrCount - 1);

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_CLEAR;
    bDP2CurrCmdOP = D3DDP2OP_CLEAR;
    lpDP2CurrCommand->bReserved = 0;
    wDP2CurrCmdCnt = (WORD)clrCount;
    lpDP2CurrCommand->wStateCount = wDP2CurrCmdCnt;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    dwDP2CommandLength += dwCommandSize;

    // Write data
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(lpDP2CurrCommand + 1);
    pData->dwFlags = dwFlags;
    pData->dwFillColor = dwColor;
    pData->dvFillDepth = dvZ;
    pData->dwFillStencil = dwStencil;
    memcpy(pData->Rects, clrRects, clrCount * sizeof(D3DRECT));
}

//-----------------------------------------------------------------------------
// This function should be called from PaletteUpdateNotify
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::UpdatePalette"

void
CD3DDDIDX7::UpdatePalette(DWORD dwPaletteHandle,
                          DWORD dwStartIndex,
                          DWORD dwNumberOfIndices,
                          PALETTEENTRY *pFirstIndex)
{
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2UPDATEPALETTE) + dwNumberOfIndices*sizeof(PALETTEENTRY);
    if (bDP2CurrCmdOP == D3DDP2OP_UPDATEPALETTE)
    { // Last instruction is same, append this one to it
        if (dwDP2CommandLength + dwSizeChange <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)((LPBYTE)lpvDP2Commands +
                    dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpUpdatePal->dwPaletteHandle=dwPaletteHandle + 1;
            lpUpdatePal->wStartIndex=(WORD)dwStartIndex;
            lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
            memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
                dwNumberOfIndices*sizeof(PALETTEENTRY));
            dwDP2CommandLength += dwSizeChange;
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_UPDATEPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    // Add texture blt data
    LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)(lpDP2CurrCommand + 1);
    lpUpdatePal->dwPaletteHandle=dwPaletteHandle + 1;
    lpUpdatePal->wStartIndex=(WORD)dwStartIndex;
    lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
    memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
        dwNumberOfIndices*sizeof(PALETTEENTRY));
    dwDP2CommandLength += dwSizeChange;
}

//-----------------------------------------------------------------------------
// This function should be called from PaletteAssociateNotify
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::SetPalette"

void
CD3DDDIDX7::SetPalette(DWORD dwPaletteHandle,
                       DWORD dwPaletteFlags,
                       CBaseTexture *pTex )
{
    if (pTex->IsD3DManaged())
    {
        if (!m_pDevice->ResourceManager()->InVidmem(pTex->RMHandle()))
        {
            // We will hit this return ONLY
            // when for some reason promoting
            // pTex to vidmem failed.
            return;
        }
    }
    pTex->SetPalette(dwPaletteHandle);
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPALETTE);
    if (bDP2CurrCmdOP == D3DDP2OP_SETPALETTE)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + dwSizeChange <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)((LPBYTE)lpvDP2Commands +
                    dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetPal->dwPaletteHandle=dwPaletteHandle + 1;
            lpSetPal->dwPaletteFlags=dwPaletteFlags;
            lpSetPal->dwSurfaceHandle=pTex->DriverAccessibleDrawPrimHandle();
            dwDP2CommandLength += dwSizeChange;
#ifndef _IA64_
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

            pTex->Batch();
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_SETPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif
    LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)(lpDP2CurrCommand + 1);
    lpSetPal->dwPaletteHandle=dwPaletteHandle + 1;
    lpSetPal->dwPaletteFlags=dwPaletteFlags;
    lpSetPal->dwSurfaceHandle=pTex->DriverAccessibleDrawPrimHandle();
    dwDP2CommandLength += dwSizeChange;

    pTex->Batch();
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX7::WriteStateSetToDevice"

void
CD3DDDIDX7::WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt)
{
    DWORD  dwDeviceHandle;
    LPVOID pBuffer;
    DWORD  dwBufferSize;

    m_pDevice->m_pStateSets->GetDeviceBufferInfo(&dwDeviceHandle, &pBuffer,
                                                 &dwBufferSize);

    // If device buffer is empty we do not create the set state macro in the device
    if (dwBufferSize == 0)
        return;

    DWORD dwByteCount = dwBufferSize + (sizeof(D3DHAL_DP2STATESET) +
                        sizeof(D3DHAL_DP2COMMAND)) * 2;

    // Check to see if there is space to add a new command for space
    if (dwByteCount + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        FlushStatesCmdBufReq(dwByteCount);
        // Check if the driver did give us what we need or do it ourselves
        GrowCommandBuffer(dwByteCount);
    }

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    LPD3DHAL_DP2STATESET pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETBEGIN;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

    // Copy the entire state macro to the DP2 buffer
    memcpy(pData + 1, pBuffer, dwBufferSize);
    if (m_ddiType < D3DDDITYPE_DX8)
    {
        // Translate buffer content to DX7 DDI
        m_pDevice->m_pStateSets->TranslateDeviceBufferToDX7DDI( (DWORD*)(pData + 1), dwBufferSize );
    }

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pData + 1) + dwBufferSize);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETEND;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
#ifndef _IA64_
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
#endif

    dwDP2CommandLength += dwByteCount;

    FlushStates();
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDITL                                                               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

CD3DDDITL::CD3DDDITL() : CD3DDDIDX7()
{
    m_ddiType = D3DDDITYPE_DX7TL;
}

CD3DDDITL::~CD3DDDITL()
{
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetTransform"

void
CD3DDDITL::SetTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    // Do mapping between new world matrix states and the old ones
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        switch (index)
        {
        case 0  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD_DX7;   break;
        case 1  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD1_DX7;  break;
        case 2  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD2_DX7;  break;
        case 3  : state = (D3DTRANSFORMSTATETYPE)D3DTRANSFORMSTATE_WORLD3_DX7;  break;
        default : return; // State is not supported
        }
    }
    // Send down the state and the matrix
    LPD3DHAL_DP2SETTRANSFORM pData;
    pData = (LPD3DHAL_DP2SETTRANSFORM)
            GetHalBufferPointer(D3DDP2OP_SETTRANSFORM, sizeof(*pData));
    pData->xfrmType = state;
    pData->matrix = *lpMat;
    // Update W info in case of projection matrix
    if (state == D3DTRANSFORMSTATE_PROJECTION)
        CD3DDDIDX6::SetTransform(state, lpMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetViewport"

void
CD3DDDITL::SetViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    // Update viewport size
    CD3DDDIDX6::SetViewport(lpVwpData);

    // Update Z range
    LPD3DHAL_DP2ZRANGE pData;
    pData = (LPD3DHAL_DP2ZRANGE)GetHalBufferPointer(D3DDP2OP_ZRANGE, sizeof(*pData));
    pData->dvMinZ = lpVwpData->MinZ;
    pData->dvMaxZ = lpVwpData->MaxZ;
}
//-----------------------------------------------------------------------------
// This function is called whe software vertex processing is used
// Handle should be always legacy
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetVertexShader"

void CD3DDDITL::SetVertexShader(DWORD dwHandle)
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));
    // Pre-DX8 drivers should not recieve D3DFVF_LASTBETA_UBYTE4 bit
    m_CurrentVertexShader = dwHandle & ~D3DFVF_LASTBETA_UBYTE4;
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(dwHandle);
#endif
}
//-----------------------------------------------------------------------------
// This function is called whe hardware vertex processing is used
// Redundant shader check has been done at the API level
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetVertexShaderHW"

void CD3DDDITL::SetVertexShaderHW(DWORD dwHandle)
{
    if( D3DVSD_ISLEGACY(dwHandle) )
    {
        // Pre-DX8 drivers should not recieve D3DFVF_LASTBETA_UBYTE4 bit
        m_CurrentVertexShader = dwHandle & ~D3DFVF_LASTBETA_UBYTE4;
    }
    else
    {
        CVShader* pShader =
            (CVShader*)m_pDevice->m_pVShaderArray->GetObject(dwHandle);
        if( pShader == NULL )
        {
            D3D_THROW( D3DERR_INVALIDCALL,
                       "Bad handle passed to SetVertexShader DDI" )
        }
        if( pShader->m_Declaration.m_bLegacyFVF == FALSE )
        {
            D3D_THROW( D3DERR_INVALIDCALL, "Declaration is too complex for "
                       "the Driver to handle." );
        }
        else
        {
            m_CurrentVertexShader = pShader->m_Declaration.m_dwInputFVF;
        }
    }
#if DBG
    m_VertexSizeFromShader = ComputeVertexSizeFVF(m_CurrentVertexShader);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetMaterial"

void
CD3DDDITL::SetMaterial(CONST D3DMATERIAL8* pMat)
{
    LPD3DHAL_DP2SETMATERIAL pData;
    pData = (LPD3DHAL_DP2SETMATERIAL)GetHalBufferPointer(D3DDP2OP_SETMATERIAL, sizeof(*pData));
    *pData = *((LPD3DHAL_DP2SETMATERIAL)pMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetLight"

void
CD3DDDITL::SetLight(DWORD dwLightIndex, CONST D3DLIGHT8* pLight)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)
            GetHalBufferPointer(D3DDP2OP_SETLIGHT,
                                sizeof(*pData) + sizeof(D3DLIGHT8));
    pData->dwIndex = dwLightIndex;
    pData->dwDataType = D3DHAL_SETLIGHT_DATA;
    D3DLIGHT8* p = (D3DLIGHT8*)((LPBYTE)pData + sizeof(D3DHAL_DP2SETLIGHT));
    *p = *pLight;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::CreateLight"

void
CD3DDDITL::CreateLight(DWORD dwLightIndex)
{
    LPD3DHAL_DP2CREATELIGHT pData;
    pData = (LPD3DHAL_DP2CREATELIGHT)GetHalBufferPointer(D3DDP2OP_CREATELIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::LightEnable"

void
CD3DDDITL::LightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
    if (bEnable)
        pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::SetClipPlane"

void
CD3DDDITL::SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation)
{
    LPD3DHAL_DP2SETCLIPPLANE pData;
    pData = (LPD3DHAL_DP2SETCLIPPLANE)
            GetHalBufferPointer(D3DDP2OP_SETCLIPPLANE, sizeof(*pData));
    pData->dwIndex = dwPlaneIndex;
    pData->plane[0] = pPlaneEquation[0];
    pData->plane[1] = pPlaneEquation[1];
    pData->plane[2] = pPlaneEquation[2];
    pData->plane[3] = pPlaneEquation[3];
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDITL::CreateVertexShader"

void
CD3DDDITL::CreateVertexShader(CONST DWORD* pdwDeclaration,
                              DWORD dwDeclarationSize,
                              CONST DWORD* pdwFunction,
                              DWORD dwFunctionSize,
                              DWORD dwHandle,
                              BOOL bLegacyFVF)
{
    if( bLegacyFVF == FALSE )
    {
        D3D_THROW(D3DERR_INVALIDCALL,
                  "The declaration is too complex for the driver to handle");
    }
}
//-----------------------------------------------------------------------------
// Allocates space for the internal clip buffer and sets lpClipFlags pointer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::PrepareForClipping"

void
CD3DDDIDX6::PrepareForClipping(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        // Grow clip flags buffer if we need clipping
        DWORD size = pv->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > pDevice->HVbuf.GetSize())
        {
            if (pDevice->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_THROW(E_OUTOFMEMORY, "Could not grow clip buffer" );
            }
        }
        pv->lpClipFlags = (D3DFE_CLIPCODE*)pDevice->HVbuf.GetAddress();
    }
    else
    {
        // For vertex buffers, which are destination for ProcessVertices
        // clip buffer is already computed
        pv->lpClipFlags = pDevice->m_pStream[0].m_pVB->GetClipCodes();
#if DBG
        if (pv->lpClipFlags == NULL)
        {
            D3D_THROW_FAIL("Clip codes are not computed for the vertex buffer");
        }
#endif
        pv->dwClipUnion = 0xFFFFFFFF;  // Force clipping
        pv->lpClipFlags += StartVertex;
    }
}
//-----------------------------------------------------------------------------
// Point sprites are drawn as indexed triangle list
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::StartPointSprites"

void CD3DDDIDX6::StartPointSprites()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    // Reserve place for the output vertices
    const UINT size = NUM_SPRITES_IN_BATCH * 4 * m_dwOutputSizePS;

    // We may have a different vertex type for point sprites
    DWORD tmpFVF = pv->dwVIDOut;
    pv->dwVIDOut = m_dwVIDOutPS;

    // For StartPrimTL we should use vertex size, which will go to the driver
    DWORD tmpVertexSize = pv->dwOutputSize;
    pv->dwOutputSize = m_dwOutputSizePS;

    m_pCurSpriteVertex = (BYTE*)StartPrimTL(pv, size, TRUE);

    // Restore vertex size, which is size before point sprite emulation
    pv->dwOutputSize = tmpVertexSize;

    // Vertex base and vertex count could be changed during clipping
    // So we save them here and use in the EndPointSprites
    m_dwVertexBasePS = this->dwVertexBase;
    m_dwVertexCountPS = this->dwDP2VertexCount;

    // Continue processing with the original FVF
    pv->dwVIDOut = tmpFVF;
    // Reserve place for indices
    UINT count = NUM_SPRITES_IN_BATCH * 2 * 6;

    // We change lpDP2CurrCommand here, so to prevent combining multiple driver
    // calls to one token in case when all points are off screen, we clear 
    // bDP2CurrCmdOP.
    bDP2CurrCmdOP = 0;

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)ReserveSpaceInCommandBuffer(count);
    m_pCurPointSpriteIndex = (WORD*)((BYTE*)(lpDP2CurrCommand + 1) +
                                    sizeof(D3DHAL_DP2STARTVERTEX));
    m_CurNumberOfSprites = 0;
    ((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart = (WORD)this->dwVertexBase;

    SetWithinPrimitive(TRUE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::NextSprite"

void CD3DDDIDX6::NextSprite(float x, float y, float z, float w, DWORD diffuse,
                            DWORD specular, float* pTexture, UINT TextureSize,
                            float PointSize)
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;

    BOOL bTexGen = pv->lpdwRStates[D3DRS_POINTSPRITEENABLE] != 0;

    if (m_CurNumberOfSprites >= NUM_SPRITES_IN_BATCH)
    {
        EndPointSprites();
        StartPointSprites();
    }
    // Compute point size
    PointSize = PointSize * 0.5f;

    // Build sprite vertices
    BYTE* v1 = m_pCurSpriteVertex;
    BYTE* v2 = m_pCurSpriteVertex + m_dwOutputSizePS;
    BYTE* v3 = m_pCurSpriteVertex + m_dwOutputSizePS * 2;
    BYTE* v4 = m_pCurSpriteVertex + m_dwOutputSizePS * 3;
    float x1, y1, x2, y2, x3, y3, x4, y4;
    x1 = x - PointSize;
    y1 = y - PointSize;
    x2 = x + PointSize;
    y2 = y + PointSize;
    float tx1 = 0;  // Interpolation coefficient at left plane
    float tx2 = 1;  // Interpolation coefficient at right plane
    float ty1 = 0;  // Interpolation coefficient at top plane
    float ty2 = 1;  // Interpolation coefficient at bottom plane
    if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
    {
        ((D3DVECTORH*)v1)->x = x1;
        ((D3DVECTORH*)v1)->y = y1;
        ((D3DVECTORH*)v1)->z = z;
        ((D3DVECTORH*)v1)->w = w;
        ((D3DVECTORH*)v2)->x = x2;
        ((D3DVECTORH*)v2)->y = y1;
        ((D3DVECTORH*)v2)->z = z;
        ((D3DVECTORH*)v2)->w = w;
        ((D3DVECTORH*)v3)->x = x2;
        ((D3DVECTORH*)v3)->y = y2;
        ((D3DVECTORH*)v3)->z = z;
        ((D3DVECTORH*)v3)->w = w;
        ((D3DVECTORH*)v4)->x = x1;
        ((D3DVECTORH*)v4)->y = y2;
        ((D3DVECTORH*)v4)->z = z;
        ((D3DVECTORH*)v4)->w = w;
    }
    else
    {// Do clipping
        // new x and y
        float xnew1 = x1, xnew2 = x2;
        float ynew1 = y1, ynew2 = y2;
        if (x1 < pv->vcache.minX)
            if (x2 < pv->vcache.minX)
                return;
            else
            {
                xnew1 = pv->vcache.minX;
                if (bTexGen)
                    tx1 = (xnew1 - x1) / (x2 - x1);
            }
        else
        if (x2 > pv->vcache.maxX)
            if (x1 > pv->vcache.maxX)
                return;
            else
            {
                xnew2 = pv->vcache.maxX;
                if (bTexGen)
                    tx2 = (xnew2 - x1) / (x2 - x1);
            }
        if (y1 < pv->vcache.minY)
            if (y2 < pv->vcache.minY)
                return;
            else
            {
                ynew1 = pv->vcache.minY;
                if (bTexGen)
                    ty1 = (ynew1 - y1) / (y2 - y1);
            }
        else
        if (y2 > pv->vcache.maxY)
            if (y1 > pv->vcache.maxY)
                return;
            else
            {
                ynew2 = pv->vcache.maxY;
                if (bTexGen)
                    ty2 = (ynew2 - y1) / (y2 - y1);
            }
        ((D3DVECTORH*)v1)->x = xnew1;
        ((D3DVECTORH*)v1)->y = ynew1;
        ((D3DVECTORH*)v1)->z = z;
        ((D3DVECTORH*)v1)->w = w;
        ((D3DVECTORH*)v2)->x = xnew2;
        ((D3DVECTORH*)v2)->y = ynew1;
        ((D3DVECTORH*)v2)->z = z;
        ((D3DVECTORH*)v2)->w = w;
        ((D3DVECTORH*)v3)->x = xnew2;
        ((D3DVECTORH*)v3)->y = ynew2;
        ((D3DVECTORH*)v3)->z = z;
        ((D3DVECTORH*)v3)->w = w;
        ((D3DVECTORH*)v4)->x = xnew1;
        ((D3DVECTORH*)v4)->y = ynew2;
        ((D3DVECTORH*)v4)->z = z;
        ((D3DVECTORH*)v4)->w = w;
    }
    UINT offset = 4*4;
    if (m_dwVIDOutPS & D3DFVF_DIFFUSE)
    {
        *(DWORD*)(v1 + offset) = diffuse;
        *(DWORD*)(v2 + offset) = diffuse;
        *(DWORD*)(v3 + offset) = diffuse;
        *(DWORD*)(v4 + offset) = diffuse;
        offset += 4;
    }
    if (m_dwVIDOutPS & D3DFVF_SPECULAR)
    {
        *(DWORD*)(v1 + offset) = specular;
        *(DWORD*)(v2 + offset) = specular;
        *(DWORD*)(v3 + offset) = specular;
        *(DWORD*)(v4 + offset) = specular;
        offset += 4;
    }
    if (bTexGen)
    {
        ((float*)(v1 + offset))[0] = tx1;
        ((float*)(v1 + offset))[1] = ty1;
        ((float*)(v2 + offset))[0] = tx2;
        ((float*)(v2 + offset))[1] = ty1;
        ((float*)(v3 + offset))[0] = tx2;
        ((float*)(v3 + offset))[1] = ty2;
        ((float*)(v4 + offset))[0] = tx1;
        ((float*)(v4 + offset))[1] = ty2;
    }
    else
    {
        // Copy input texture coordinates
        memcpy(v1 + offset, pTexture, TextureSize);
        memcpy(v2 + offset, pTexture, TextureSize);
        memcpy(v3 + offset, pTexture, TextureSize);
        memcpy(v4 + offset, pTexture, TextureSize);
    }
    m_pCurSpriteVertex = v4 + m_dwOutputSizePS;

    // Output indices for 2 triangles
    WORD index = m_CurNumberOfSprites << 2;
    m_pCurPointSpriteIndex[0] = index;
    m_pCurPointSpriteIndex[1] = index + 1;
    m_pCurPointSpriteIndex[2] = index + 2;
    m_pCurPointSpriteIndex[3] = index;
    m_pCurPointSpriteIndex[4] = index + 2;
    m_pCurPointSpriteIndex[5] = index + 3;
    m_pCurPointSpriteIndex += 6;

    m_CurNumberOfSprites++;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::EndPointSprites"

void CD3DDDIDX6::EndPointSprites()
{
    if (m_CurNumberOfSprites)
    {
        dwDP2CommandLength += (DWORD) ((BYTE*)this->m_pCurPointSpriteIndex -
                                       (BYTE*)this->lpDP2CurrCommand);
        this->lpDP2CurrCommand->bCommand = D3DDP2OP_INDEXEDTRIANGLELIST2;
        this->bDP2CurrCmdOP = D3DDP2OP_INDEXEDTRIANGLELIST2;
        this->lpDP2CurrCommand->bReserved = 0;
        this->lpDP2CurrCommand->wPrimitiveCount = m_CurNumberOfSprites * 2;
#if DBG
        if (m_bValidateCommands)
            ValidateCommand(this->lpDP2CurrCommand);
#endif
        UINT vertexCount = m_CurNumberOfSprites << 2;
        this->dwVertexBase = m_dwVertexBasePS + vertexCount;
        this->dwDP2VertexCount = m_dwVertexCountPS + vertexCount;
        EndPrim(m_dwOutputSizePS);
        m_CurNumberOfSprites = 0;
    }
    else
    {
        // We need to restore dwVertexBase and dwDP2VertexCount, because
        // they could be changed during clipping of transformed vertices.
        // But they should reflect position in TL buffer, not in user buffer
        this->dwVertexBase = m_dwVertexBasePS;
        this->dwDP2VertexCount = m_dwVertexCountPS;
        EndPrim(m_dwOutputSizePS);
    }
    SetWithinPrimitive(FALSE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::UpdatePalette"

void CD3DDDIDX6::UpdatePalette(DWORD dwPaletteHandle,
                               DWORD dwStartIndex,
                               DWORD dwNumberOfIndices,
                               PALETTEENTRY *pFirstIndex)
{
    D3D8_UPDATEPALETTEDATA Data;
    Data.hDD = m_pDevice->GetHandle();
    Data.Palette = dwPaletteHandle;
    Data.ColorTable = pFirstIndex;
    Data.ddRVal = S_OK;
    HRESULT ret = m_pDevice->GetHalCallbacks()->UpdatePalette(&Data);
    if (ret != DDHAL_DRIVER_HANDLED || Data.ddRVal != S_OK)
    {
        D3D_ERR( "Driver failed UpdatePalette call" );
        throw D3DERR_INVALIDCALL;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::SetPalette"

void CD3DDDIDX6::SetPalette(DWORD dwPaletteHandle,
                            DWORD dwPaletteFlags,
                            CBaseTexture *pTex)
{
    if (pTex->IsD3DManaged())
    {
        if (!m_pDevice->ResourceManager()->InVidmem(pTex->RMHandle()))
        {
            // We will hit this return ONLY
            // when for some reason promoting
            // pTex to vidmem failed.
            return;
        }
    }
    D3D8_SETPALETTEDATA Data;
    Data.hDD = m_pDevice->GetHandle();
    Data.hSurface = pTex->DriverAccessibleKernelHandle();
    Data.Palette = dwPaletteHandle;
    Data.ddRVal = S_OK;
    HRESULT ret = m_pDevice->GetHalCallbacks()->SetPalette(&Data);
    if (ret != DDHAL_DRIVER_HANDLED || Data.ddRVal != S_OK)
    {
        D3D_ERR( "Driver failed SetPalette call" );
        throw D3DERR_INVALIDCALL;
    }
    pTex->SetPalette(dwPaletteHandle);
}
//-----------------------------------------------------------------------------
#if DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ValidateVertex"

void CD3DDDIDX6::ValidateVertex(LPDWORD lpdwVertex)
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    DWORD dwFVF = pv->dwVIDOut;
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    if (FVF_TRANSFORMED(dwFVF))
    {
        float left, right, top, bottom;
        if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
        {
            left   = pv->vcache.minXgb;
            right  = pv->vcache.maxXgb;
            top    = pv->vcache.minYgb;
            bottom = pv->vcache.maxYgb;
        }
        else
        {
            left   = (float)pDevice->m_Viewport.X;
            top    = (float)pDevice->m_Viewport.Y;
            right  = (float)pDevice->m_Viewport.X + pDevice->m_Viewport.Width;
            bottom = (float)pDevice->m_Viewport.Y + pDevice->m_Viewport.Height;
        }
        float x = ((float*)lpdwVertex)[0];
        float y = ((float*)lpdwVertex)[1];
        float z = ((float*)lpdwVertex)[2];
        float w = ((float*)lpdwVertex)[3];

        if (x < left || x > right)
        {
            D3D_THROW_FAIL("X coordinate out of range!");
        }

        if (y < top || y > bottom)
        {
            D3D_THROW_FAIL("Y coordinate out of range!");
        }

        if (pv->lpdwRStates[D3DRS_ZENABLE] ||
            pv->lpdwRStates[D3DRS_ZWRITEENABLE])
        {
            // Allow a little slack for those generating triangles exactly on the
            // depth limit.  Needed for Quake.
            if (z < -0.00015f || z > 1.00015f)
            {
                D3D_THROW_FAIL("Z coordinate out of range!");
            }
        }
        UINT index = 4;

        if (dwFVF & D3DFVF_DIFFUSE)
            index++;

        if (dwFVF & D3DFVF_SPECULAR)
            index++;

        UINT nTex = FVF_TEXCOORD_NUMBER(dwFVF);
        if (nTex > 0)
        {
            if (w <= 0 )
            {
                D3D_THROW_FAIL("RHW out of range!");
            }
            for (UINT i=0; i < nTex; i++)
            {
                float u = ((float*)lpdwVertex)[index];
                float v = ((float*)lpdwVertex)[index+1];
                if (u < -100 || u > 100 || v < -100 || v > 100)
                {
                    D3D_THROW_FAIL("Texture coordinate out of range!");
                }
                index += 2;
            }
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX6::ValidateCommand"

void CD3DDDIDX6::ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd)
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;

    BYTE* pVertices;
    if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        pVertices = (LPBYTE)(dp2data.lpVertices);
    else
        if (!lpDP2CurrBatchVBI->IsLocked())
        {
            lpDP2CurrBatchVBI->Lock(dp2data.dwVertexOffset,
                                    this->dwDP2VertexCount,
                                    &pVertices, DDLOCK_READONLY);
        }
        else
        {
            pVertices = lpDP2CurrBatchVBI->Data();
        }

    DWORD dwVertexSize = pv->dwOutputSize;
    WORD wStart, wCount;
    switch (lpCmd->bCommand)
    {
    case D3DDP2OP_TRIANGLELIST:
        {
            LPD3DHAL_DP2TRIANGLELIST pTri = (LPD3DHAL_DP2TRIANGLELIST)(lpCmd + 1);
            wStart = pTri->wVStart;
            wCount =lpCmd->wPrimitiveCount * 3;
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
        {
            LPD3DHAL_DP2TRIANGLEFAN pFan = (LPD3DHAL_DP2TRIANGLEFAN)(lpCmd + 1);
            wStart = pFan->wVStart;
            wCount = lpCmd->wPrimitiveCount + 2;
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            wCount = lpCmd->wPrimitiveCount + 2;
            BYTE* pVertices = (BYTE*)(lpCmd + 1) + sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
            pVertices = (BYTE*)(((ULONG_PTR)pVertices + 3) & ~3);
            for (WORD i=0; i < wCount; ++i)
            {
                ValidateVertex((DWORD*)(pVertices + i * dwVertexSize));
            }
            goto l_exit;
        }
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            wCount = lpCmd->wPrimitiveCount * 3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(lpCmd + 1);
            WORD* pIndices = (WORD*)(lpStartVertex + 1);
                        wStart = lpStartVertex->wVStart;
            pVertices += wStart * dwVertexSize;
            DWORD dwNumVertices = this->dwDP2VertexCount - wStart;
            for (WORD i = 0; i < wCount; ++i)
            {
                if (pIndices[i] >= dwNumVertices)
                {
                    D3D_THROW_FAIL("Invalid index in ValidateCommand");
                }
                ValidateVertex((LPDWORD)(pVertices + pIndices[i] * dwVertexSize));
            }
        }
        goto l_exit;
        // Fall through
    default:
        goto l_exit;
    }

    {
        for (WORD i = wStart; i < wStart + wCount; ++i)
        {
            ValidateVertex((LPDWORD)(pVertices + i * dwVertexSize));
        }
    }
l_exit:
    if (!(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        lpDP2CurrBatchVBI->Unlock();
}
//-----------------------------------------------------------------------------
// This function could be used to go through all commands in the command buffer
// and find failed command at a particular offset
//
#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommandBuffer"

HRESULT ValidateCommandBuffer(LPBYTE pBuffer, DWORD dwCommandLength, DWORD dwStride)
{
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)pBuffer;
    LPBYTE CmdEnd = pBuffer + dwCommandLength;
loop:
    UINT CommandOffset = (UINT)((LPBYTE)pCmd - pBuffer);
    switch(pCmd->bCommand)
    {
    case D3DDP2OP_STATESET:
        {
            LPD3DHAL_DP2STATESET pStateSetOp = 
                (LPD3DHAL_DP2STATESET)(pCmd + 1);

            switch (pStateSetOp->dwOperation)
            {
            case D3DHAL_STATESETBEGIN  :
                break;
            case D3DHAL_STATESETEND    :
                break;
            case D3DHAL_STATESETDELETE :
                break;
            case D3DHAL_STATESETEXECUTE:
                break;
            case D3DHAL_STATESETCAPTURE:
                break;
            case D3DHAL_STATESETCREATE:
                break;
            default :
                return DDERR_INVALIDPARAMS;
            }
            pCmd = (LPD3DHAL_DP2COMMAND)(pStateSetOp + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_VIEWPORTINFO:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                   ((D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_WINFO:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                   ((D3DHAL_DP2WINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_RENDERSTATE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                   ((D3DHAL_DP2RENDERSTATE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
               ((LPD3DHAL_DP2TEXTURESTAGESTATE)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        {
            WORD cPrims = pCmd->wPrimitiveCount;
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                         sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST) * cPrims);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        {
            // Update the command buffer pointer
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_POINTS:
        {
            D3DHAL_DP2POINTS *pPt = (D3DHAL_DP2POINTS *)(pCmd + 1);
            pPt += pCmd->wPrimitiveCount;
            pCmd = (LPD3DHAL_DP2COMMAND)pPt;
        }
        break;
    case D3DDP2OP_LINELIST:
        {
            D3DHAL_DP2LINELIST *pLine = (D3DHAL_DP2LINELIST *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        {
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_LINESTRIP:
        {
            D3DHAL_DP2LINESTRIP *pLine = (D3DHAL_DP2LINESTRIP *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 1;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLELIST:
        {
            D3DHAL_DP2TRIANGLELIST *pTri = (D3DHAL_DP2TRIANGLELIST *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        {
            D3DHAL_DP2TRIANGLESTRIP *pTri = (D3DHAL_DP2TRIANGLESTRIP *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount+2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN:
        {
            D3DHAL_DP2TRIANGLEFAN *pTri = (D3DHAL_DP2TRIANGLEFAN *)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount + 2;
            // Make sure the pFanVtx pointer is DWORD aligned: (pFanVtx +3) % 4
            PUINT8 pFanVtx = (PUINT8)
                (((ULONG_PTR)(pCmd + 1) + 
                  sizeof(D3DHAL_DP2TRIANGLEFAN_IMM) + 3) & ~3);

            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pFanVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_LINELIST_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount * 2;
            // Make sure the pLineVtx pointer is DWORD aligned:
            // (pLineVtx +3) % 4
            PUINT8 pLineVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) + 3) & ~3);
            pCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pLineVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE2:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE2 *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWRECTPATCH:
        {
            LPD3DHAL_DP2DRAWRECTPATCH pDP = 
                (LPD3DHAL_DP2DRAWRECTPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 4);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)pDP + sizeof(D3DRECTPATCH_INFO));
                }
            }
            pCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWTRIPATCH:
        {
            LPD3DHAL_DP2DRAWTRIPATCH pDP = 
                (LPD3DHAL_DP2DRAWTRIPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 3);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)pDP + sizeof(D3DTRIPATCH_INFO));
                }
            }
            pCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE2 *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_CLIPPEDTRIANGLEFAN*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_ZRANGE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2ZRANGE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETMATERIAL:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETLIGHT:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1)  + sizeof(D3DHAL_DP2SETLIGHT));
        }
        break;
    case D3DDP2OP_CREATELIGHT:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2CREATELIGHT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETTRANSFORM:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_MULTIPLYTRANSFORM:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2MULTIPLYTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_EXT:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2EXT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETRENDERTARGET:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLEAR:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                sizeof(D3DHAL_DP2CLEAR) + (pCmd->wStateCount - 1) * sizeof(RECT));
        }
        break;
    case D3DDP2OP_SETCLIPPLANE:
        {
            pCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2SETCLIPPLANE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DOP_SPAN:
        // Skip over
        pCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                  pCmd->wPrimitiveCount * pCmd->bReserved );
        break;
    case D3DDP2OP_CREATEVERTEXSHADER:
    {
        LPD3DHAL_DP2CREATEVERTEXSHADER pCVS =
            (LPD3DHAL_DP2CREATEVERTEXSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pDecl = (LPDWORD)(pCVS + 1);
            LPDWORD pCode = (LPDWORD)((LPBYTE)pDecl + pCVS->dwDeclSize);
            pCVS = (LPD3DHAL_DP2CREATEVERTEXSHADER)((LPBYTE)pCode +
                                                    pCVS->dwCodeSize);
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pCVS;
        break;
    }
    case D3DDP2OP_DELETEVERTEXSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADERCONST:
    {
        LPD3DHAL_DP2SETVERTEXSHADERCONST pSVC =
            (LPD3DHAL_DP2SETVERTEXSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            pSVC = (LPD3DHAL_DP2SETVERTEXSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        break;
    }
    case D3DDP2OP_SETSTREAMSOURCE:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETSTREAMSOURCEUM:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCEUM *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETINDICES:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETINDICES *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_CREATEPIXELSHADER:
    {
        LPD3DHAL_DP2CREATEPIXELSHADER pCPS =
            (LPD3DHAL_DP2CREATEPIXELSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pCode = (LPDWORD)(pCPS + 1);
            pCPS = (LPD3DHAL_DP2CREATEPIXELSHADER)((LPBYTE)pCode +
                                                    pCPS->dwCodeSize);
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pCPS;
        break;
    }
    case D3DDP2OP_DELETEPIXELSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADER:
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADERCONST:
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST pSVC =
            (LPD3DHAL_DP2SETPIXELSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            pSVC = (LPD3DHAL_DP2SETPIXELSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        break;
    }
    case D3DDP2OP_SETPALETTE:
    {
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPALETTE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_UPDATEPALETTE:
    {
        LPD3DHAL_DP2UPDATEPALETTE pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            PALETTEENTRY* pEntries = (PALETTEENTRY *)(pUP + 1);
            pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pEntries + pUP->wNumEntries);
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pUP;
        break;
    }
    case D3DDP2OP_SETTEXLOD:
    {
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETTEXLOD *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_SETPRIORITY:
    {
        pCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPRIORITY *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_TEXBLT:
    {
        LPD3DHAL_DP2TEXBLT pTB = (LPD3DHAL_DP2TEXBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            pTB++;
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pTB;
        break;
    }
    case D3DDP2OP_BUFFERBLT:
    {
        LPD3DHAL_DP2BUFFERBLT pBB = (LPD3DHAL_DP2BUFFERBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            pBB++;
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pBB;
        break;
    }
    case D3DDP2OP_VOLUMEBLT:
    {
        LPD3DHAL_DP2VOLUMEBLT pVB = (LPD3DHAL_DP2VOLUMEBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            pVB++;
        }
        pCmd = (LPD3DHAL_DP2COMMAND)pVB;
        break;
    }
    case D3DOP_MATRIXLOAD:
    case D3DOP_MATRIXMULTIPLY:
    case D3DOP_STATETRANSFORM:
    case D3DOP_STATELIGHT:
    case D3DOP_TEXTURELOAD:
    case D3DOP_BRANCHFORWARD:
    case D3DOP_SETSTATUS:
    case D3DOP_EXIT:
    case D3DOP_PROCESSVERTICES:
    {
        D3D_ERR( "Command is not supported\n" );
        return E_FAIL;
        break;
    }
    default:
        D3D_ERR( "Unknown command encountered" );
        return E_FAIL;
    }
    if ((LPBYTE)pCmd < CmdEnd)
        goto loop;

    return S_OK;    
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifndef _DRAWPRIM_H_
#define _DRAWPRIM_H_

#define MAX_DX6_VERTICES    ((1<<16) - 1)
#ifdef WIN95
#define LOWVERTICESNUMBER 128
#else
#define LOWVERTICESNUMBER 96
#endif
#define D3D_MAX_TLVBUF_CHANGES 5

// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
//---------------------------------------------------------------------
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
//---------------------------------------------------------------------
// Computes size in bytes of the position component of a vertex
//
__inline DWORD GetPositionSizeFVF(DWORD fvf)
{
    DWORD size = 3 << 2;
    switch (fvf & D3DFVF_POSITION_MASK)
    {
    case D3DFVF_XYZRHW: size += 4;      break;
    case D3DFVF_XYZB1:  size += 1*4;    break;
    case D3DFVF_XYZB2:  size += 2*4;    break;
    case D3DFVF_XYZB3:  size += 3*4;    break;
    case D3DFVF_XYZB4:  size += 4*4;    break;
    case D3DFVF_XYZB5:  size += 5*4;    break;
    }
    return size;
}
//---------------------------------------------------------------------
// Computes vertex size in bytes for a the vertex ID excluding size of
// texture oordinates
//
__inline DWORD GetVertexSizeFVF(DWORD fvf)
{
    DWORD size = GetPositionSizeFVF(fvf);
    if (fvf & D3DFVF_NORMAL)
        size += 3*4;
    if (fvf & D3DFVF_PSIZE)
        size += 4;

    if (fvf & D3DFVF_DIFFUSE)
        size+= 4;
    if (fvf & D3DFVF_SPECULAR)
        size += 4;

    if (fvf & D3DFVF_FOG)
        size += 4;

    return size;
}
//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};
//---------------------------------------------------------------------
// Computes vertex size in bytes from the vertex ID
//
// Texture formats size        00   01   10   11
const BYTE g_TextureSize[4] = {2*4, 3*4, 4*4, 4};

//---------------------------------------------------------------------
// Index is number of floats in a texture coordinate set.
// Value is texture format bits
//
const DWORD g_dwTextureFormat[5] = {0, 3, 0, 1, 2};

//---------------------------------------------------------------------
// Returns total size of texture coordinates
// Computes dwTextureCoordSize[] array - size of every texture coordinate set
//
inline DWORD ComputeTextureCoordSize(DWORD dwFVF, DWORD *dwTextureCoordSize)
{
    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD dwTextureCoordSizeTotal;

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwTextureCoordSizeTotal = (BYTE)dwNumTexCoord * 2 * 4;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            dwTextureCoordSize[i] = 4*2;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        dwTextureCoordSizeTotal = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = g_TextureSize[dwTextureFormats & 3];
            dwTextureCoordSize[i] = dwSize;
            dwTextureCoordSizeTotal += dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return dwTextureCoordSizeTotal;
}
//---------------------------------------------------------------------
// Computes vertex in bytes for the given FVF
//
inline DWORD ComputeVertexSizeFVF(DWORD dwFVF)
{
    DWORD dwTextureFormats = dwFVF >> 16;
    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD size = GetVertexSizeFVF(dwFVF);
    if (dwTextureFormats == 0)
    {
        size += (BYTE)dwNumTexCoord * 2 * 4;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            size += g_TextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }
    return size;
}
//---------------------------------------------------------------------
// Computes the number of primtives and also updates the stats accordingly
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         return value = dwNumPrimitives
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrim"

inline __declspec(nothrow) void GetNumPrim(LPD3DHAL lpDevI, DWORD dwNumVertices)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    pv->dwNumPrimitives = 0;
    switch (pv->primType)
    {
    case D3DPT_POINTLIST:
        pv->dwNumPrimitives = dwNumVertices;
        break;
    case D3DPT_LINELIST:
        pv->dwNumPrimitives = dwNumVertices >> 1;
        break;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return;
        pv->dwNumPrimitives = dwNumVertices - 1;
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return;
        pv->dwNumPrimitives = dwNumVertices - 2;
        break;
    case D3DPT_TRIANGLELIST:
#ifdef _X86_
        {
            DWORD tmp;
            __asm
            {
                mov  eax, 0x55555555    // fractional part of 1.0/3.0
                mul  dwNumVertices
                add  eax, 0x80000000    // Rounding
                adc  edx, 0
                mov  tmp, edx
            }
            pv->dwNumPrimitives = tmp;
        }
#else
        pv->dwNumPrimitives = dwNumVertices / 3;
#endif
        break;
    }
}
//---------------------------------------------------------------------
// Sets front-end flags every time fog state is changed
//
inline void CD3DHal::SetFogFlags(void)
{
    // Call ForceFVFRecompute only if fog enable state has been changed
    BOOL bFogWasEnabled = m_pv->dwDeviceFlags & D3DDEV_FOG;
    if (m_pv->lighting.fog_mode != D3DFOG_NONE &&
        this->rstates[D3DRENDERSTATE_FOGENABLE])
    {
        m_pv->dwDeviceFlags |= D3DDEV_FOG;
        if (!bFogWasEnabled)
            ForceFVFRecompute();
    }
    else
    {
        m_pv->dwDeviceFlags &= ~D3DDEV_FOG;
        if (bFogWasEnabled)
            ForceFVFRecompute();
    }
}
//-----------------------------------------------------------------------------
// Computes dwFlags bits which depend on the output FVF
//
inline void UpdateFlagsForOutputFVF(D3DFE_PROCESSVERTICES* lpDevI)
{
    if (lpDevI->dwDeviceFlags & D3DDEV_LIGHTING &&
        lpDevI->dwVIDOut & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR))
    {
        lpDevI->dwFlags |= D3DPV_LIGHTING;
    }
    if (lpDevI->dwDeviceFlags & D3DDEV_FOG && lpDevI->dwVIDOut & D3DFVF_SPECULAR)
    {
        lpDevI->dwFlags |= D3DPV_FOG;
    }
    if (!(lpDevI->dwVIDOut & D3DFVF_DIFFUSE))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYDIFFUSE;
    if (!(lpDevI->dwVIDOut & D3DFVF_SPECULAR))
        lpDevI->dwFlags |= D3DPV_DONOTCOPYSPECULAR;
}

//---------------------------------------------------------------------
// Restore indices in the texture stages which were re-mapped for texture
// transforms
// We have to do restore if
//  - Set or Get render state is issued with _WRAP parameter
//  - Set or Get texture stage is issued with TEXCOORDINDEX as a parameter
//
extern void RestoreTextureStages(LPD3DHAL pDevI);
//---------------------------------------------------------------------
// the function works when there are texture transforms.
// It computes number of output texture coordinates, texture coordinate size and format.
// It prepares texture stages to re-map texture coordinates
//
void EvalTextureTransforms(LPD3DHAL pDevI, DWORD dwTexTransform,
                           DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat);
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPD3DHAL pDevI);
//----------------------------------------------------------------------
inline BOOL TextureTransformEnabled(LPD3DHAL pDevI)
{
    return __TEXTURETRANSFORMENABLED(pDevI->m_pv);
}
//-----------------------------------------------------------------------------
// Having primitive type as index, this array returns two coefficients("a" and
// "b") to compute number of vertices as NumPrimitives*a + b
//
extern DWORD g_PrimToVerCount[7][2];
//-----------------------------------------------------------------------------
inline UINT GETVERTEXCOUNT(D3DPRIMITIVETYPE primType, UINT dwNumPrimitives)
{
    return g_PrimToVerCount[primType][0] * dwNumPrimitives +
           g_PrimToVerCount[primType][1];
}
extern void setIdentity(D3DMATRIXI * m);
extern void MatrixProduct(D3DMATRIXI *d, D3DMATRIXI *a, D3DMATRIXI *b);
extern LIGHT_VERTEX_FUNC_TABLE lightVertexTable;
extern void MatrixProduct(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);
void D3DFE_UpdateLights(LPD3DHAL lpDevI);
//---------------------------------------------------------------------
// Updates lighting and computes process vertices flags
//
extern void DoUpdateState(LPD3DHAL lpDevI);
//----------------------------------------------------------------------
inline void UpdateClipStatus(CD3DHal* pDev)
{
    pDev->m_ClipStatus.ClipUnion |= pDev->m_pv->dwClipUnion;
    pDev->m_ClipStatus.ClipIntersection &= pDev->m_pv->dwClipIntersection;
}
//----------------------------------------------------------------------
// This is a list of all rstates that which are for the vertex processing only.
// In the software vertex processing mode these render states are not passed
// to the driver. The are passed when we switch to the hardware vertex processing mode
//
const D3DRENDERSTATETYPE rsVertexProcessingList[] = {
    D3DRS_RANGEFOGENABLE,
    D3DRS_LIGHTING,
    D3DRS_AMBIENT,
    D3DRS_FOGVERTEXMODE,
    D3DRS_COLORVERTEX,
    D3DRS_LOCALVIEWER,
    D3DRS_NORMALIZENORMALS,
    D3DRS_DIFFUSEMATERIALSOURCE,
    D3DRS_SPECULARMATERIALSOURCE,
    D3DRS_AMBIENTMATERIALSOURCE,
    D3DRS_EMISSIVEMATERIALSOURCE,
    D3DRS_VERTEXBLEND,
    D3DRS_CLIPPLANEENABLE,
    D3DRS_SOFTWAREVERTEXPROCESSING,
    D3DRS_POINTSCALEENABLE,
    D3DRS_POINTSCALE_A,
    D3DRS_POINTSCALE_B,
    D3DRS_POINTSCALE_C,
    D3DRS_INDEXEDVERTEXBLENDENABLE,
    D3DRS_TWEENFACTOR
};

#endif _DRAWPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\drawprim.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ProcessVertices"

HRESULT D3DAPI
CD3DHal::ProcessVertices(UINT SrcStartIndex, UINT DestIndex, UINT VertexCount,
                         IDirect3DVertexBuffer8 *DestBuffer,
                         DWORD dwFlags)
{
    API_ENTER(this); // Takes D3D Lock if necessary
    HRESULT hr = D3D_OK;
    CVertexBuffer* pVB = static_cast<CVertexBuffer*>(DestBuffer);
    const D3DBUFFER_DESC* pDesc = pVB->GetBufferDesc();
    UINT vbVertexSize = pVB->GetVertexSize();
    UINT vbNumVertices = pVB->GetNumVertices();
#if DBG
    if (pVB->Device() != this)
    {
        D3D_ERR("VertexBuffer not created with this device. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (m_dwCurrentShaderHandle == 0)
    {
        D3D_ERR("Current vertex shader is not set. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle) &&
        FVF_TRANSFORMED(m_dwCurrentShaderHandle))
    {
        D3D_ERR("Invalid vertex shader for ProcessVertices. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        D3D_ERR("D3D Device should be in software mode for ProcessVertices. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (dwFlags & ~D3DPV_DONOTCOPYDATA)
    {
        D3D_ERR( "Invalid dwFlags set. ProcessVertices failed." );
        return D3DERR_INVALIDCALL;
    }

    if (pDesc->Usage & D3DUSAGE_DONOTCLIP &&
        !(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
    {
        D3D_ERR("Vertex buffer has D3D_DONOTCLIP usage, but clipping is enabled. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (pVB->GetFVF() == 0)
    {
        D3D_ERR("Destination buffer has no FVF associated with it. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if ((pVB->GetFVF() & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW)
    {
        D3D_ERR("Destination vertex buffer should have D3DFVF_XYZRHW position. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
    if (VertexCount + DestIndex > vbNumVertices)
    {
        D3D_ERR("Destination vertex buffer has not enough space. ProcessVertices failed.");
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        DWORD vbFVF = pVB->GetFVF();
        m_pv->dwNumVertices = VertexCount;
        m_pv->dwFlags = D3DPV_VBCALL;
#if DBG
        ValidateDraw2(D3DPT_TRIANGLELIST, SrcStartIndex, 1, VertexCount, FALSE);
#endif
        // Internal flags and output vertex offsets could be different for
        // ProcessVertices
        ForceFVFRecompute();

        (this->*m_pfnPrepareToDraw)(SrcStartIndex);

        if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
        {
            if (pVB->GetClipCodes() == NULL)
            {
                pVB->AllocateClipCodes();
            }
            m_pv->lpClipFlags = pVB->GetClipCodes();
#if DBG
            if (m_pv->lpClipFlags == NULL)
            {
                D3D_THROW_FAIL("Failed to allocate clip code for the dest VB");
            }
#endif
            m_pv->lpClipFlags += DestIndex;
        }

        // Check number of texture coordinates and texture formats in the
        // destination VB are the same as in the computed FVF
        DWORD dwComputedTexFormats = m_pv->dwVIDOut & 0xFFFF0000;
        DWORD dwNumTexCoordVB = FVF_TEXCOORD_NUMBER(vbFVF);
        if (m_pv->nOutTexCoord > dwNumTexCoordVB ||
            ((vbFVF & dwComputedTexFormats) != dwComputedTexFormats))
        {
            D3D_ERR("Number of output texture coordinates and their format should be");
            D3D_ERR("the same in the destination vertex buffer and as computed for current D3D settings.");
            D3D_ERR("Computed output FVF is 0x%08X", m_pv->dwVIDOut);
            D3D_THROW_FAIL("");
        }
        // Check if the computed output FVF is a subset of the VB's FVF.
        // Number of texture coordinates should be cleared.
        DWORD dwComputedFVF = m_pv->dwVIDOut & 0x000000FF;
        // Specularand diffuse colors could be omitted, as well as psize
        dwComputedFVF &= ~(D3DFVF_PSIZE | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_FOG);
        if((dwComputedFVF & vbFVF) != dwComputedFVF)
        {
            D3D_ERR("Dest vertex buffer's FVF should be a superset of the FVF, computed for");
            D3D_ERR("the current D3D settings");
            D3D_ERR("Computed output FVF is 0x%08X", m_pv->dwVIDOut);
            D3D_THROW_FAIL("");
        }

        BYTE* p;
        hr = pVB->Lock(0, pDesc->Size, &p, D3DLOCK_NOSYSLOCK);
        if (FAILED(hr))
        {
            D3D_THROW_FAIL("Cannot lock destination buffer");
        }

        if (this->dwFEFlags & D3DFE_FRONTEND_DIRTY)
            DoUpdateState(this);

        // Replace output FVF and vertex size
        m_pv->dwOutputSize = vbVertexSize;
        m_pv->dwVIDOut = vbFVF;
        m_pv->lpvOut = p + DestIndex * vbVertexSize;

        // Vertex shaders don't write to the output unless shader writes to it
        // explicitely. So we do not bother setting any flags
        if (dwFlags & D3DPV_DONOTCOPYDATA)
        {
            if (m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
            {
                m_pv->dwFlags |= D3DPV_DONOTCOPYDIFFUSE |
                                 D3DPV_DONOTCOPYSPECULAR |
                                 D3DPV_DONOTCOPYTEXTURE;
            }
            else
            {
                m_pv->dwFlags |= D3DPV_DONOTCOPYDIFFUSE |
                                 D3DPV_DONOTCOPYSPECULAR |
                                 D3DPV_DONOTCOPYTEXTURE;
                // If D3DIM generates colors or texture, we should clear
                // DONOTCOPY bits
                if (m_pv->dwFlags & D3DPV_LIGHTING)
                {
                    m_pv->dwFlags &= ~D3DPV_DONOTCOPYDIFFUSE;
                    if (m_pv->dwDeviceFlags & D3DDEV_SPECULARENABLE)
                        m_pv->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
                }
                if (m_pv->dwFlags & D3DPV_FOG)
                    m_pv->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
                // If front-end is asked to do something with texture
                // coordinates  we disable DONOTCOPYTEXTURE
                if (__TEXTURETRANSFORMENABLED(m_pv) ||
                    m_pv->dwFlags2 & __FLAGS2_TEXGEN)
                {
                    m_pv->dwFlags &= ~D3DPV_DONOTCOPYTEXTURE;
                }
            }
        }

        // Compute flags based on the vertex buffer FVF
        UpdateFlagsForOutputFVF(m_pv);

        // Update output vertex offsets for the new FVF
        ComputeOutputVertexOffsets(m_pv);

        m_pv->pGeometryFuncs->ProcessVertices(m_pv);

        if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP))
            UpdateClipStatus(this);

        // When ProcessVertices is used, user must re-program texture
        // stage indices and wrap modes himself
        m_pv->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("ProcessVertices failed.");
        hr = ret;
    }
    ForceFVFRecompute();
    pVB->Unlock();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\helxfrm.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helxfrm.c
 *  Content:    Direct3D front-end transform and process vertices
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "fe.h"

void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);

//---------------------------------------------------------------------
void CheckWorldViewMatrix(LPD3DFE_PROCESSVERTICES pv)
{
    D3DMATRIXI *m = &pv->mWV[0];
    D3DMATRIXI res;
    res._11 = m->_11*m->_11 + m->_12*m->_12 + m->_13*m->_13;
    res._12 = m->_11*m->_21 + m->_12*m->_22 + m->_13*m->_23;
    res._13 = m->_11*m->_31 + m->_12*m->_32 + m->_13*m->_33;

    res._21 = m->_21*m->_11 + m->_22*m->_12 + m->_23*m->_13;
    res._22 = m->_21*m->_21 + m->_22*m->_22 + m->_23*m->_23;
    res._23 = m->_21*m->_31 + m->_22*m->_32 + m->_23*m->_33;

    res._31 = m->_31*m->_11 + m->_32*m->_12 + m->_33*m->_13;
    res._32 = m->_31*m->_21 + m->_32*m->_22 + m->_33*m->_23;
    res._33 = m->_31*m->_31 + m->_32*m->_32 + m->_33*m->_33;

    const D3DVALUE eps = 0.0001f;
    if (m->_14 == 0.0f && 
        m->_24 == 0.0f && 
        m->_34 == 0.0f && 
        m->_44 == 1.0f && 
        ABSF(res._12) < eps && 
        ABSF(res._13) < eps &&
        ABSF(res._21) < eps && 
        ABSF(res._23) < eps &&
        ABSF(res._31) < eps && 
        ABSF(res._32) < eps &&
        ABSF(1.0f - res._11) < eps && 
        ABSF(1.0f - res._22) < eps && 
        ABSF(1.0f - res._33) < eps)
    {
        pv->dwDeviceFlags |= D3DDEV_MODELSPACELIGHTING;
    }
    else
    {
        pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
    }
}
//---------------------------------------------------------------------
void setIdentity(D3DMATRIXI * m)
{
    m->_11 = D3DVAL(1.0); m->_12 = D3DVAL(0.0); m->_13 = D3DVAL(0.0); m->_14 = D3DVAL(0.0);
    m->_21 = D3DVAL(0.0); m->_22 = D3DVAL(1.0); m->_23 = D3DVAL(0.0); m->_24 = D3DVAL(0.0);
    m->_31 = D3DVAL(0.0); m->_32 = D3DVAL(0.0); m->_33 = D3DVAL(1.0); m->_34 = D3DVAL(0.0);
    m->_41 = D3DVAL(0.0); m->_42 = D3DVAL(0.0); m->_43 = D3DVAL(0.0); m->_44 = D3DVAL(1.0);
}
//---------------------------------------------------------------------
/*
 * Combine all matrices.
 */
const DWORD __VPC_DIRTY = D3DFE_VIEWMATRIX_DIRTY |
                          D3DFE_PROJMATRIX_DIRTY;

void updateTransform(LPD3DHAL lpDevI)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    if (lpDevI->dwFEFlags & D3DFE_PROJMATRIX_DIRTY)
    { 
      // We modify the projection matrix to make the clipping rules to be
      // 0 < x,y,z < w
        TRANSFORM.mPC._11 = (TRANSFORM.proj._11 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._12 = (TRANSFORM.proj._12 + TRANSFORM.proj._14) * D3DVAL(0.5);
        TRANSFORM.mPC._13 = TRANSFORM.proj._13;
        TRANSFORM.mPC._14 = TRANSFORM.proj._14;
        TRANSFORM.mPC._21 = (TRANSFORM.proj._21 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._22 = (TRANSFORM.proj._22 + TRANSFORM.proj._24) * D3DVAL(0.5);
        TRANSFORM.mPC._23 = TRANSFORM.proj._23;
        TRANSFORM.mPC._24 = TRANSFORM.proj._24;
        TRANSFORM.mPC._31 = (TRANSFORM.proj._31 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._32 = (TRANSFORM.proj._32 + TRANSFORM.proj._34) * D3DVAL(0.5);
        TRANSFORM.mPC._33 = TRANSFORM.proj._33;
        TRANSFORM.mPC._34 = TRANSFORM.proj._34;
        TRANSFORM.mPC._41 = (TRANSFORM.proj._41 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._42 = (TRANSFORM.proj._42 + TRANSFORM.proj._44) * D3DVAL(0.5);
        TRANSFORM.mPC._43 = TRANSFORM.proj._43;
        TRANSFORM.mPC._44 = TRANSFORM.proj._44;
    }
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_PROJMATRIX_DIRTY))
    { // Update Mview*Mproj*Mclip
        MatrixProduct(&pv->mVPC, &pv->view, &TRANSFORM.mPC);
        lpDevI->dwFEFlags |= D3DFE_CLIPMATRIX_DIRTY | D3DFE_CLIPPLANES_DIRTY;
    }

    MatrixProduct(&pv->mCTM[0], &pv->world[0], &pv->mVPC);

    // Set dirty bit for world*view matrix (needed for fog and lighting)
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX_DIRTY))
    {
        lpDevI->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY | 
                             D3DFE_INVWORLDVIEWMATRIX_DIRTY |
                             D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
    }

    // All matrices are set up
    lpDevI->dwFEFlags &= ~D3DFE_TRANSFORM_DIRTY;

    // Set dirty bit for lighting
    lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS |
                         D3DFE_FRUSTUMPLANES_DIRTY;

    pv->dwDeviceFlags |= D3DDEV_TRANSFORMDIRTY;
    
    // Set this to not to re-compute the matrices
    pv->WVCount[0] = pv->MatrixStateCount;
    pv->CTMCount[0] = pv->MatrixStateCount;
}
//----------------------------------------------------------------------------
#ifdef DEBUG_PIPELINE

extern DWORD g_DebugFlags;

#endif
//-----------------------------------------------------------------------------
// DoUpdateState should be called for every DrawPrimitive call in the slow path,
// because it sets some internal pipeline flags. These flags are persistent for the
// fast path
//
void DoUpdateState(LPD3DHAL lpDevI)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    pv->dwFlags = 0;
    
    if (lpDevI->m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
    {
        // For vertex shaders we need update clip planes only 
        if (lpDevI->dwFEFlags & D3DFE_CLIPPLANES_DIRTY)
        {
            DWORD dwMaxUserClipPlanes = 0;
            DWORD dwPlanes = lpDevI->rstates[D3DRENDERSTATE_CLIPPLANEENABLE];
            for (DWORD i=0; i < __MAXUSERCLIPPLANES; i++)
            {
                if (dwPlanes & (1 << i))
                {
                    // Clipping planes are transformed by inverse transposed
                    // view-projection-clip matrix
                    // For vertex shaders view-projection matrix is identity.
                    // Inverse transposed clip matrix is 
                    //      2 0 0 -1
                    //      0 2 0 -1
                    //      0 0 1  0
                    //      0 0 0  1
                    //
                    float* pOut = (float*)&pv->userClipPlane[dwMaxUserClipPlanes];
                    float* pIn = (float*)&lpDevI->transform.userClipPlane[i];
                    pOut[0] = pIn[0]*2;
                    pOut[1] = pIn[1]*2;
                    pOut[2] = pIn[2];
                    pOut[3] = pIn[3] - pIn[0] - pIn[1];
                    dwMaxUserClipPlanes++;
                }
            }
            pv->dwMaxUserClipPlanes = dwMaxUserClipPlanes;
            lpDevI->dwFEFlags &= ~D3DFE_CLIPPLANES_DIRTY;
        }
        // For PSGP we need to set DONOTCOPY bits
        if (!(pv->dwVIDOut & D3DFVF_DIFFUSE))
            pv->dwFlags |= D3DPV_DONOTCOPYDIFFUSE;
        if (!(pv->dwVIDOut & D3DFVF_SPECULAR))
            pv->dwFlags |= D3DPV_DONOTCOPYSPECULAR;
        return;
    }

    UpdateFlagsForOutputFVF(pv);

    // only set up lights if something has changed
    if (lpDevI->dwFEFlags & D3DFE_LIGHTS_DIRTY) 
    {
        lpDevI->m_dwRuntimeFlags &= ~(D3DRT_DIRECTIONALIGHTPRESENT | 
                                      D3DRT_POINTLIGHTPRESENT);
        LPDIRECT3DLIGHTI    lpD3DLightI;
        lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_FIRST(&lpDevI->m_ActiveLights);
        pv->lighting.activeLights = NULL;

        // Set lights in the device
        while (lpD3DLightI)
        {
            if (lpD3DLightI->m_Light.Type == D3DLIGHT_DIRECTIONAL)
                lpDevI->m_dwRuntimeFlags |= D3DRT_DIRECTIONALIGHTPRESENT;
            else
                lpDevI->m_dwRuntimeFlags |= D3DRT_POINTLIGHTPRESENT;

            if (lpD3DLightI->m_LightI.flags & D3DLIGHTI_DIRTY)
                lpD3DLightI->SetInternalData();
            lpD3DLightI->m_LightI.next = pv->lighting.activeLights;
            pv->lighting.activeLights = &lpD3DLightI->m_LightI;
            lpD3DLightI = (LPDIRECT3DLIGHTI)LIST_NEXT(lpD3DLightI, m_List);
        }
    }

// Process vertex blending and tweening settings

    if (lpDevI->dwFEFlags & D3DFE_VERTEXBLEND_DIRTY)
    {
        pv->dwNumVerBlends = lpDevI->rstates[D3DRS_VERTEXBLEND];
        pv->dwNumWeights = 0;
        if (pv->dwNumVerBlends && (pv->dwNumVerBlends != D3DVBF_TWEENING))
        {
            if (pv->dwNumVerBlends == D3DVBF_0WEIGHTS)
                pv->dwNumVerBlends = 1;
            else
                pv->dwNumVerBlends++;
            // Compute number of floats in a vertex
            int nFloats = ((pv->dwVIDIn & D3DFVF_POSITION_MASK) >> 1) - 2;
            // Compute number of needed floats 
            int nFloatsNeeded;
            if (pv->dwDeviceFlags & D3DDEV_INDEXEDVERTEXBLENDENABLE)
            {
#if DBG
                if (D3DVSD_ISLEGACY(lpDevI->m_dwCurrentShaderHandle) &&
                    ((pv->dwVIDIn & D3DFVF_LASTBETA_UBYTE4) == 0))
                {
                    D3D_THROW_FAIL("D3DFVF_LASTBETA_UBYTE4 must be set for index vertex blending");
                }
#endif // DBG
                nFloatsNeeded = pv->dwNumVerBlends;
            }
            else
            {
                nFloatsNeeded = pv->dwNumVerBlends - 1;
            }
            if (nFloats < nFloatsNeeded)
            {
                D3D_THROW_FAIL("Vertex does not have enough data for vertex blending");
            }
            pv->dwNumWeights = pv->dwNumVerBlends - 1; 
            // Lighting is done in the camera space when there is vertex blending
            if (pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                pv->dwDeviceFlags &= ~(D3DDEV_MODELSPACELIGHTING | D3DFE_NEEDCHECKWORLDVIEWVMATRIX);
                // We have to transform lights to the camera space
                lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
            }
        }
        else
        {
            // Vertex blending is disabled, so we may be able to do lighting 
            // in model space. We need to to re-check matrices
            if (!(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                lpDevI->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
        }
        lpDevI->dwFEFlags &= ~D3DFE_VERTEXBLEND_DIRTY;
    }

    if (lpDevI->rstates[D3DRS_VERTEXBLEND] == D3DVBF_TWEENING)
    {
        if (pv->position2.lpvData)
            pv->dwFlags |= D3DPV_POSITION_TWEENING;
        if (pv->normal2.lpvData)
            pv->dwFlags |= D3DPV_NORMAL_TWEENING;
        pv->dwNumVerBlends = 0;     // Disable vertex blending when tweening
#if DBG
        if (!(pv->dwFlags & (D3DPV_POSITION_TWEENING | D3DPV_NORMAL_TWEENING)))
        {
            D3D_THROW_FAIL("Position2 or Normal2 must be set when tweening is enabled");
        }
#endif
    }

#if DBG
    if (!(pv->dwDeviceFlags & D3DDEV_INDEXEDVERTEXBLENDENABLE))
    {
        if (D3DVSD_ISLEGACY(lpDevI->m_dwCurrentShaderHandle) &&
            ((pv->dwVIDIn & D3DFVF_LASTBETA_UBYTE4) != 0))
        {
            D3D_THROW_FAIL("D3DFVF_LASTBETA_UBYTE4 must be set only when index vertex blending is used");
        }
    }
#endif // DBG

    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
    {
        updateTransform(lpDevI);
    }
    // We need World-View matrix for lighting, fog, point sprites and when 
    // texture coordinates are taken from the vertex data in the camera space
    if (lpDevI->dwFEFlags & D3DFE_WORLDVIEWMATRIX_DIRTY &&
        (pv->dwDeviceFlags & (D3DDEV_LIGHTING | D3DDEV_FOG) ||
        lpDevI->rstates[D3DRS_POINTSCALEENABLE] ||
        pv->dwDeviceFlags & (D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE)))
    {
        MatrixProduct(&pv->mWV[0], &pv->world[0],
                                    &pv->view);
        lpDevI->dwFEFlags &= ~D3DFE_WORLDVIEWMATRIX_DIRTY;
    }
// Detect where to do lighting: in model or eye space 
    if (lpDevI->dwFEFlags & D3DFE_NEEDCHECKWORLDVIEWVMATRIX &&
        pv->dwDeviceFlags & D3DDEV_LIGHTING)
    {
        // We try to do lighting in the model space if
        // 1. we do not have to normalize normals 
        // 2. we do not need to do vertex blending
        pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
        if (pv->dwNumVerBlends == 0 &&
            !(pv->dwDeviceFlags & D3DDEV_NORMALIZENORMALS))
        {
#ifdef DEBUG_PIPELINE
            if (!(g_DebugFlags & __DEBUG_MODELSPACE))
#endif
            {
                CheckWorldViewMatrix(pv);
                lpDevI->dwFEFlags &= ~D3DFE_NEEDCHECKWORLDVIEWVMATRIX;
            }
        }
        // If D3DDEV_MODELSPACELIGHTING has been changed we need to re-transform lights
        lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS;
    }
    
    // Updating inverse World-View matrix.
    // It is needed when we do lighting in the model space or we need normals
    // in the camera space
    if (lpDevI->dwFEFlags & D3DFE_INVWORLDVIEWMATRIX_DIRTY &&
        ((pv->dwDeviceFlags & D3DDEV_LIGHTING && 
          !(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)) || 
         pv->dwDeviceFlags & D3DDEV_NORMALINCAMERASPACE))
    {
        Inverse4x4((D3DMATRIX*)&pv->mWV[0], (D3DMATRIX*)&pv->mWVI);
        lpDevI->dwFEFlags &= ~D3DFE_INVWORLDVIEWMATRIX_DIRTY;
        pv->WVICount[0] = pv->MatrixStateCount;
    }

    // Update clipping planes if there are any
    if (lpDevI->dwFEFlags & D3DFE_CLIPPLANES_DIRTY)
    {
        if (lpDevI->dwFEFlags & D3DFE_CLIPMATRIX_DIRTY)
        {
            // View and projection matrix are inversed separately, because it 
            // is possible that combined matrix cannot be inverted. This could happend
            // when the view matrix has huge _43 value (> 10^7). Floating point precision
            // is not enough in this case
            D3DMATRIXI mPCInverse;
            if (Inverse4x4((D3DMATRIX*)&lpDevI->transform.mPC, (D3DMATRIX*)&mPCInverse))
            {
                D3D_ERR("Cannot invert projection matrix");
                setIdentity((D3DMATRIXI*)&mPCInverse);
            }
            D3DMATRIXI mViewInverse;
            if (Inverse4x4((D3DMATRIX*)&pv->view, (D3DMATRIX*)&mViewInverse))
            {
                D3D_ERR("Cannot invert view matrix");
                setIdentity((D3DMATRIXI*)&mViewInverse);
            }
            MatrixProduct(&lpDevI->transform.mVPCI, &mPCInverse, &mViewInverse);
            lpDevI->dwFEFlags &= ~D3DFE_CLIPMATRIX_DIRTY;
        }
        DWORD dwMaxUserClipPlanes = 0;
        DWORD dwPlanes = lpDevI->rstates[D3DRENDERSTATE_CLIPPLANEENABLE];
        for (DWORD i=0; i < __MAXUSERCLIPPLANES; i++)
        {
            if (dwPlanes & (1 << i))
            {
                // Clipping planes are transformed by inverse transposed
                // view-projection-clip matrix
                VecMatMul4HT(&lpDevI->transform.userClipPlane[i], 
                             (D3DMATRIX*)&lpDevI->transform.mVPCI, 
                             &pv->userClipPlane[dwMaxUserClipPlanes]);
                dwMaxUserClipPlanes++;
            }
        }
        pv->dwMaxUserClipPlanes = dwMaxUserClipPlanes;
        lpDevI->dwFEFlags &= ~D3DFE_CLIPPLANES_DIRTY;
    }

    if (lpDevI->dwFEFlags & (D3DFE_NEED_TRANSFORM_LIGHTS |
                             D3DFE_LIGHTS_DIRTY |
                             D3DFE_MATERIAL_DIRTY))
    {
        D3DFE_UpdateLights(lpDevI);
        // Set a flag for PSGP
        pv->dwDeviceFlags |= D3DDEV_LIGHTSDIRTY;
    }

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden 
    // by vertex alpha
    pv->lighting.alpha = (DWORD)pv->lighting.materialAlpha;
    pv->lighting.alphaSpecular = (DWORD)pv->lighting.materialAlphaS;

    // This is a hint that only the inPosition pointer needs to be updated
    // for speed reasons.
    if (((pv->dwVIDIn & ( D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_NORMAL)) == 0) && 
        (pv->nTexCoord == 0))
        pv->dwFlags |= D3DPV_TRANSFORMONLY;

    if (pv->nOutTexCoord == 0)
        pv->dwFlags |= D3DPV_DONOTCOPYTEXTURE;

    lpDevI->dwFEFlags &= ~D3DFE_FRONTEND_DIRTY;

    // Decide whether we always need position and normal in the camera space

    if (!(pv->dwFlags2 & __FLAGS2_TEXGEN))
    {
        // When texture generation is disabled we can recompute NORMAL and 
        // POSITION flags
        pv->dwDeviceFlags &= ~(D3DDEV_NORMALINCAMERASPACE |
                               D3DDEV_POSITIONINCAMERASPACE);
    }
    if ((pv->dwDeviceFlags & (D3DDEV_LIGHTING | D3DDEV_MODELSPACELIGHTING)) == D3DDEV_LIGHTING)
    {
        // We do lighting in camera space
        if (lpDevI->m_dwRuntimeFlags & D3DRT_DIRECTIONALIGHTPRESENT &&
            lpDevI->m_pv->dwVIDIn & D3DFVF_NORMAL)
            pv->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;

        if (lpDevI->m_dwRuntimeFlags & D3DRT_POINTLIGHTPRESENT)
            pv->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
    }
    if (pv->dwFlags & D3DPV_FOG)
    {
        pv->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\ddidx8.cpp ===
#include "pch.cpp"
#pragma hdrstop
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddidx8.cpp
 *  Content:    Direct3D Dx8 DDI encapsulation implementations
 *
 ***************************************************************************/
#include "d3d8p.h"
#include "ddi.h"
#include "fe.h"
#include "ddi.inl"

extern DWORD g_DebugFlags;
extern HRESULT ProcessClippedPointSprites(D3DFE_PROCESSVERTICES *pv);
extern DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);
//-----------------------------------------------------------------------------
// TL stream which is read-only
//
class CTLStreamRO: public CTLStream
{
public:
    CTLStreamRO(): CTLStream(TRUE) {m_dwIndex = 0; m_bUserMemStream = FALSE;}
    void Init(CVertexBuffer* pVB, UINT primitiveBase);
    BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    void Unlock() {}
    BOOL IsUserMemStream() {return m_bUserMemStream;}
    void AddVertices(UINT NumVertices) {}
    void SubVertices(UINT NumVertices) {}
    void MovePrimitiveBase(int NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
    void SkipVertices(DWORD NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
protected:
    BOOL m_bUserMemStream;
};
//-----------------------------------------------------------------------------
void CTLStreamRO::Init(CVertexBuffer* pVB, UINT primitiveBase)
{
    if (m_pVB)
    {
        m_pVB->DecrementUseCount();
        m_pVB = NULL;
    }
    m_pVB = pVB;
    if (pVB)
    {
        m_bUserMemStream = FALSE;
        m_pVB->IncrementUseCount();
    }
    else
    {
        m_bUserMemStream = TRUE;
    }
    m_dwPrimitiveBase = primitiveBase;
}
//-----------------------------------------------------------------------------
// Index stream which is read-only
//
class CTLIndexStreamRO: public CTLIndexStream
{
public:
    CTLIndexStreamRO() {m_dwIndex = __NUMSTREAMS;}
    void Init(CIndexBuffer* pVB, UINT primitiveBase);
    BYTE* Lock(UINT NeededSize, CD3DDDIDX6* pDDI);
    void Unlock() {}
    void AddVertices(UINT NumVertices) {}
    void SubVertices(UINT NumVertices) {}
    void MovePrimitiveBase(int NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
    void SkipVertices(DWORD NumVertices)
        {
            m_dwPrimitiveBase += NumVertices * m_dwStride;
        }
};
//-----------------------------------------------------------------------------
void CTLIndexStreamRO::Init(CIndexBuffer* pVB, UINT primitiveBase)
{
    if (m_pVBI)
    {
        m_pVBI->DecrementUseCount();
        m_pVBI = NULL;
    }
    m_pVBI = pVB;
    if (m_pVBI)
        m_pVBI->IncrementUseCount();
    m_dwPrimitiveBase = primitiveBase;
}
//-----------------------------------------------------------------------------
CTLStream::CTLStream(BOOL bWriteOnly)
{
    m_bWriteOnly = bWriteOnly;
    m_dwSize = 0;
    m_dwPrimitiveBase = 0;
    m_dwUsedSize = 0;
    m_dwIndex = 0;
    m_Usage = 0;
}
//-----------------------------------------------------------------------------
CTLStream::CTLStream(BOOL bWriteOnly, UINT Usage)
{
    m_bWriteOnly = bWriteOnly;
    m_dwSize = 0;
    m_dwPrimitiveBase = 0;
    m_dwUsedSize = 0;
    m_dwIndex = 0;
    m_Usage = Usage;
}
//-----------------------------------------------------------------------------
void CTLStream::Grow(UINT RequiredSize, CD3DDDIDX6* pDDI)
{
    if (RequiredSize > m_dwSize)
    {
        // We create the new vertex buffer before releasing the old one to
        // prevent creating the buffer on the same place in memory
        DWORD dwUsage = D3DUSAGE_INTERNALBUFFER | D3DUSAGE_DYNAMIC | m_Usage;
        if (m_bWriteOnly)
            dwUsage |= D3DUSAGE_WRITEONLY;
        IDirect3DVertexBuffer8 * pVB;
        HRESULT ret = CVertexBuffer::Create(pDDI->GetDevice(),
                                            RequiredSize,
                                            dwUsage,
                                            0,
                                            D3DPOOL_DEFAULT,
                                            REF_INTERNAL,
                                            &pVB);
        if (ret != DD_OK)
        {
            D3D_THROW(ret, "Could not allocate internal vertex buffer");
        }
        if (m_pVB)
            m_pVB->DecrementUseCount();
        m_pVB = static_cast<CVertexBuffer*>(pVB);
        m_dwSize = RequiredSize;
    }
}
//-----------------------------------------------------------------------------
BYTE* CTLStream::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    HRESULT ret;
    DXGASSERT(m_dwSize >= m_dwUsedSize);
    if (NeededSize > m_dwSize - m_dwUsedSize || m_dwUsedSize == 0)
    {
        Grow(NeededSize, pDDI);
        ret = m_pVB->Lock(0, m_dwSize, &m_pData, D3DLOCK_DISCARD |
                                                 D3DLOCK_NOSYSLOCK);
        this->Reset();
    }
    else
    {
        ret = m_pVB->Lock(0, m_dwSize, &m_pData, D3DLOCK_NOOVERWRITE |
                                                 D3DLOCK_NOSYSLOCK);
    }
    if (ret != DD_OK)
    {
        D3D_THROW(ret, "Could not lock internal vertex buffer");
    }
    // m_dwPrimitiveBase could be out of sync with m_dwUsedSize, because
    // sometimes we re-use vertices (like when clipping line strips). Make
    // sure that they are in sync.
    m_dwPrimitiveBase = m_dwUsedSize;
    return m_pData + m_dwUsedSize;
}
//-----------------------------------------------------------------------------
void CTLStream::Unlock()
{
    m_pVB->Unlock();
}
//-----------------------------------------------------------------------------
CTLIndexStream::CTLIndexStream()
{
    m_dwSize = 0;
    m_dwPrimitiveBase = 0;
    m_dwUsedSize = 0;
    m_dwIndex = 0;
}
//-----------------------------------------------------------------------------
void CTLIndexStream::Grow(UINT RequiredSize, CD3DDDIDX6* pDDI)
{
    if (RequiredSize > m_dwSize)
    {
        // We create the new vertex buffer before releasing the old one to
        // prevent creating the buffer on the same place in memory
        DWORD dwUsage = D3DUSAGE_INTERNALBUFFER | D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC;
        IDirect3DIndexBuffer8 * pVB;
        HRESULT ret = CIndexBuffer::Create(pDDI->GetDevice(),
                                           RequiredSize,
                                           dwUsage,
                                           D3DFMT_INDEX16,
                                           D3DPOOL_DEFAULT,
                                           REF_INTERNAL,
                                           &pVB);
        if (ret != DD_OK)
        {
            D3D_THROW(ret, "Could not allocate internal index buffer");
        }
        if (m_pVBI)
            m_pVBI->DecrementUseCount();
        m_pVBI = static_cast<CIndexBuffer*>(pVB);
        m_dwSize = RequiredSize;
    }
}
//-----------------------------------------------------------------------------
BYTE* CTLIndexStream::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    HRESULT ret;
    DXGASSERT(m_dwSize >= m_dwUsedSize);
    if (NeededSize > m_dwSize - m_dwUsedSize || m_dwUsedSize == 0)
    {
        Grow(NeededSize, pDDI);
        ret = m_pVBI->Lock(0, m_dwSize, &m_pData, D3DLOCK_DISCARD |
                                                  D3DLOCK_NOSYSLOCK);
        this->Reset();
    }
    else
    {
        ret = m_pVBI->Lock(0, m_dwSize, &m_pData, D3DLOCK_NOOVERWRITE |
                                                  D3DLOCK_NOSYSLOCK);
    }
    if (ret != DD_OK)
    {
        D3D_THROW(ret, "Could not lock internal index buffer");
    }
    // m_dwPrimitiveBase could be out of sync with m_dwUsedSize, because
    // sometimes we re-use vertices (like when clipping line strips). Make
    // sure that they are in sync.
    m_dwPrimitiveBase = m_dwUsedSize;
    return m_pData + m_dwUsedSize;
}
//-----------------------------------------------------------------------------
BYTE* CTLIndexStream::LockDiscard(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    HRESULT ret;
    DXGASSERT(m_dwSize >= m_dwUsedSize);
    Grow(NeededSize, pDDI);
    ret = m_pVBI->Lock(0, m_dwSize, &m_pData, D3DLOCK_DISCARD |
                                              D3DLOCK_NOSYSLOCK);
    this->Reset();
    if (ret != DD_OK)
    {
        D3D_THROW(ret, "Could not lock internal index buffer");
    }
    // We have called Reset() so no need to set PrimitiveBase
    return m_pData;
}
//-----------------------------------------------------------------------------
void CTLIndexStream::Unlock()
{
    m_pVBI->Unlock();
}
//-----------------------------------------------------------------------------
BYTE* CTLStreamRO::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    return m_pVB->Data();
}
//-----------------------------------------------------------------------------
BYTE* CTLIndexStreamRO::Lock(UINT NeededSize, CD3DDDIDX6* pDDI)
{
    return m_pVBI->Data();
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8                                                              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

const DWORD CD3DDDIDX8::m_dwDummyVertexLength = 10;
const DWORD CD3DDDIDX8::m_dwDummyVertexSize   = sizeof(D3DVERTEX);

CD3DDDIDX8::CD3DDDIDX8()
{
    m_ddiType = D3DDDITYPE_DX8;
    m_pTLStream = NULL;
    m_pTLStreamRO = NULL;
    m_pTLStreamW = NULL;
    m_pCurrentTLStream = NULL;
    m_pIndexStream = NULL;
    m_pTLStreamClip = NULL;
    m_pCurrentIndexStream = NULL;
    m_pTLIndexStreamRO = NULL;
    m_dwInterfaceNumber = 4;
    m_pvDummyArray = NULL;
}

//-----------------------------------------------------------------------------
CD3DDDIDX8::~CD3DDDIDX8()
{
    // During deletion of the objects below, the Flush could happen.
    // We have to assing pointers to NULL to prevent accessing objects
    // during the Flush.
    m_pCurrentTLStream = NULL;

    delete m_pTLStreamW;
    m_pTLStreamW = NULL;
    delete m_pTLStream;
    m_pTLStream = NULL;
    delete m_pTLStreamRO;
    m_pTLStreamRO = NULL;
    delete m_pTLIndexStreamRO;
    m_pTLIndexStreamRO = NULL;
    delete m_pIndexStream;
    m_pIndexStream = NULL;
    delete m_pTLStreamClip;
    m_pTLStreamClip = NULL;
    if (m_pvDummyArray)
    {
        delete [] m_pvDummyArray;
        m_pvDummyArray = NULL;
    }
    delete m_pPointStream;
    m_pPointStream = NULL;
    return;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::Init"

void
CD3DDDIDX8::Init(CD3DBase* pDevice)
{
    // CD3DDDIDX6::Init( pDevice );
    m_pDevice = pDevice;
    CreateContext();
    GrowCommandBuffer(dwD3DDefaultCommandBatchSize);

    m_pvDummyArray =
        (VOID *)new BYTE[m_dwDummyVertexSize*m_dwDummyVertexLength];
    if( m_pvDummyArray == NULL )
    {
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate dummy array");
    }

    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = 0; // Initial assumption
    // We always pass this flag to prevent NT kernel from validation of vertex
    // buffer pointer
    dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
    SetDummyData();
    ClearBatch(FALSE);

    m_pTLStream = new CTLStream(FALSE);
    if (m_pTLStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStream");
    m_pTLStreamW = new CTLStream(TRUE);
    if (m_pTLStreamW == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStreamW");
    m_pTLStreamClip = new CTLStream(TRUE);
    if (m_pTLStreamClip == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStreamClip");
    m_pIndexStream = new CTLIndexStream();
    if (m_pIndexStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pIndexStream");
    m_pTLStreamRO = new CTLStreamRO();
    if (m_pTLStreamRO == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLStreamRO");
    m_pTLIndexStreamRO = new CTLIndexStreamRO();
    if (m_pTLIndexStreamRO == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal stream m_pTLIndexStreamRO");

    m_pTLStream->Grow(__INIT_VERTEX_NUMBER*2*sizeof(D3DTLVERTEX), this);
    m_pTLStreamW->Grow(__INIT_VERTEX_NUMBER*2*sizeof(D3DTLVERTEX), this);
    m_pTLStreamClip->Grow(__INIT_VERTEX_NUMBER*2*sizeof(D3DTLVERTEX), this);
    m_pIndexStream->Grow(__INIT_VERTEX_NUMBER*4, this);

    m_CurrentVertexShader = 0;

    m_pPointStream  = new CTLStream(FALSE);
    if (m_pPointStream == NULL)
        D3D_THROW(E_OUTOFMEMORY, "Cannot allocate internal data structure CTLStream");

#if DBG
    m_bValidateCommands = FALSE;
#endif
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ValidateDevice"

void
CD3DDDIDX8::ValidateDevice(LPDWORD lpdwNumPasses)
{
    HRESULT ret;
    D3D8_VALIDATETEXTURESTAGESTATEDATA vd;
    memset( &vd, 0, sizeof( vd ) );
    vd.dwhContext = m_dwhContext;

    // First, Update textures since drivers pass /fail this call based
    // on the current texture handles
    m_pDevice->UpdateTextures();

    UpdateDirtyStreams();

    // Flush states, so we can validate the current state
    FlushStates();

    // Now ask the driver!
    ret = m_pDevice->GetHalCallbacks()->ValidateTextureStageState(&vd);
    *lpdwNumPasses = vd.dwNumPasses;

    if (ret != DDHAL_DRIVER_HANDLED)
        throw E_NOTIMPL;
    else if (FAILED(vd.ddrval))
        throw vd.ddrval;
}


//-----------------------------------------------------------------------------
// Sends "dirty" streams to the command buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::UpdateDirtyStreams"

void CD3DDDIDX8::UpdateDirtyStreams()
{
    DWORD dwNumStreams = m_pDevice->m_dwNumStreams;
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
    {
        // For software vertex processing we should update only stream 0 
        // and index stream
        dwNumStreams = 1;
    }
    for(unsigned dwStream = 0, StreamMask = 1; dwStream <= dwNumStreams; dwStream++, StreamMask <<= 1)
    {
        // When max number of vertex stream is reached, process index stream
        if (dwStream == dwNumStreams)
        {
            dwStream = __NUMSTREAMS;
            StreamMask = (1 << __NUMSTREAMS);
        }

        BOOL bDirty = (m_pDevice->m_dwStreamDirty & StreamMask) != 0;
        m_pDevice->m_dwStreamDirty &= ~StreamMask; // reset stage dirty
        CBuffer *pBuf;
        if(dwStream < dwNumStreams)
        {
            pBuf = m_pDevice->m_pStream[dwStream].m_pVB;
        }
        else
        {
            pBuf = m_pDevice->m_pIndexStream->m_pVBI;
        }
        if(pBuf != 0)
        {
            if(pBuf->IsD3DManaged())
            {
                HRESULT result;
                result = m_pDevice->ResourceManager()->UpdateVideo(pBuf->RMHandle(), &bDirty);
                if(result != D3D_OK)
                {
                    D3D_THROW(result, "Resource manager failed to create or update video memory VB/IB");
                }
            }
        }
        if (!bDirty)
        {
            continue;
        }
        if(dwStream < dwNumStreams)
        {
            InsertStreamSource(&m_pDevice->m_pStream[dwStream]);
            CDDIStream &Stream = m_pDDIStream[dwStream];
            Stream.m_pStream = &m_pDevice->m_pStream[dwStream];
            Stream.m_pBuf = pBuf;
            Stream.m_dwStride = m_pDevice->m_pStream[dwStream].m_dwStride;
        }
        else
        {
            DXGASSERT(dwStream == __NUMSTREAMS);
            InsertIndices(m_pDevice->m_pIndexStream);
            CDDIStream &Stream = m_pDDIStream[dwStream];
            Stream.m_pStream = m_pDevice->m_pIndexStream;
            Stream.m_pBuf = pBuf;
            Stream.m_dwStride = m_pDevice->m_pIndexStream->m_dwStride;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::LockVB"

HRESULT __declspec(nothrow) CD3DDDIDX8::LockVB(CDriverVertexBuffer *pVB, DWORD dwFlags)
{
    HRESULT hr;
    if (pVB->GetCachedDataPointer() != 0) // if lock was cached
    {
        DXGASSERT((dwFlags & (D3DLOCK_READONLY | D3DLOCK_NOOVERWRITE)) == 0);
        DXGASSERT((pVB->GetBufferDesc()->Usage & D3DUSAGE_DYNAMIC) != 0);
        hr = pVB->UnlockI();
        if(FAILED(hr))
        {
            DPF_ERR("Driver failed to unlock a vertex buffer"
                    " when attempting to re-cache the lock.");
            pVB->SetCachedDataPointer(0);
            return hr;
        }
    }
    hr = pVB->LockI(dwFlags | D3DLOCK_NOSYSLOCK);
    if (FAILED(hr))
    {
        DPF_ERR("Driver failed to lock a vertex buffer" 
                " when attempting to cache the lock.");
        pVB->SetCachedDataPointer(0);
        return hr;
    }
    return D3D_OK;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::UnlockVB"

HRESULT __declspec(nothrow) CD3DDDIDX8::UnlockVB(CDriverVertexBuffer *pVB)
{
    return pVB->UnlockI();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetTSS"

void
CD3DDDIDX8::SetTSS(DWORD dwStage,
                   D3DTEXTURESTAGESTATETYPE dwState,
                   DWORD dwValue)
{
    // Filter unsupported states
    if (dwState >= m_pDevice->m_tssMax)
        return;

    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
                (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            FlushStates();
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState =
        (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::CreatePixelShader"

void
CD3DDDIDX8::CreatePixelShader(CONST DWORD* pdwFunction,
                              DWORD dwCodeSize,
                              DWORD dwHandle)
{
    FlushStates();
    LPD3DHAL_DP2CREATEPIXELSHADER pData;
    pData = (LPD3DHAL_DP2CREATEPIXELSHADER)
            GetHalBufferPointer(D3DDP2OP_CREATEPIXELSHADER,
                                sizeof(*pData) + dwCodeSize);
    pData->dwHandle = dwHandle;
    pData->dwCodeSize = dwCodeSize;
    LPBYTE p = (LPBYTE)&pData[1];
    memcpy(p, pdwFunction, dwCodeSize);
    FlushStates(TRUE,FALSE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetPixelShader"

void
CD3DDDIDX8::SetPixelShader( DWORD dwHandle )
{
    LPD3DHAL_DP2PIXELSHADER pData;
    pData = (LPD3DHAL_DP2PIXELSHADER)
            GetHalBufferPointer(D3DDP2OP_SETPIXELSHADER, sizeof(*pData));
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DeletePixelShader"

void
CD3DDDIDX8::DeletePixelShader(DWORD dwHandle)
{
    LPD3DHAL_DP2PIXELSHADER pData;
    pData = (LPD3DHAL_DP2PIXELSHADER)
            GetHalBufferPointer(D3DDP2OP_DELETEPIXELSHADER, sizeof(*pData));
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetPixelShaderConstant"

void
CD3DDDIDX8::SetPixelShaderConstant(DWORD dwRegister, CONST VOID* data, 
                                   DWORD count)
{
    const DWORD size = count << 4;
    LPD3DHAL_DP2SETPIXELSHADERCONST pData;
    pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)
            GetHalBufferPointer(D3DDP2OP_SETPIXELSHADERCONST,
                                sizeof(*pData) + size);
    pData->dwRegister = dwRegister;
    pData->dwCount = count;
    memcpy(pData+1, data, size);
}
//-----------------------------------------------------------------------------
// Inserts SetStreamSource command into the command buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::InsertStreamSource"

void
CD3DDDIDX8::InsertStreamSource(CVStream* pStream)
{
    if (pStream->IsUserMemStream())
    {
        InsertStreamSourceUP(pStream->m_dwStride);
        return;
    }
    LPD3DHAL_DP2SETSTREAMSOURCE pData;
    pData = (LPD3DHAL_DP2SETSTREAMSOURCE)
        GetHalBufferPointer(D3DDP2OP_SETSTREAMSOURCE, sizeof(*pData));
    pData->dwStream   = pStream->m_dwIndex;
    pData->dwVBHandle = pStream->m_pVB != 0 ? pStream->m_pVB->DriverAccessibleDrawPrimHandle() : 0;
    pData->dwStride   = pStream->m_dwStride;
    CDDIStream* pDDIStream = &m_pDDIStream[pStream->m_dwIndex];
    pDDIStream->m_dwStride = pStream->m_dwStride;
    pDDIStream->m_pStream = pStream;
    pDDIStream->m_pBuf = pStream->m_pVB;
    if (pStream->m_pVB != 0)
    {
        pStream->m_pVB->Batch();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::InsertStreamSourceUP"

void
CD3DDDIDX8::InsertStreamSourceUP(DWORD dwStride)
{
    // User memory source
    LPD3DHAL_DP2SETSTREAMSOURCEUM pData;
    pData = (LPD3DHAL_DP2SETSTREAMSOURCEUM)
        GetHalBufferPointer(D3DDP2OP_SETSTREAMSOURCEUM, sizeof(*pData));
    pData->dwStream   = 0;
    pData->dwStride   = dwStride;
    CDDIStream* pDDIStream = &m_pDDIStream[0];
    pDDIStream->m_dwStride = dwStride;
    pDDIStream->m_pStream = NULL;
    pDDIStream->m_pBuf = NULL;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::InsertIndices"

void
CD3DDDIDX8::InsertIndices(CVIndexStream* pStream)
{
    LPD3DHAL_DP2SETINDICES pData;
    pData = (LPD3DHAL_DP2SETINDICES)
            GetHalBufferPointer(D3DDP2OP_SETINDICES, sizeof(*pData));
    pData->dwVBHandle = pStream->m_pVBI != 0 ? pStream->m_pVBI->DriverAccessibleDrawPrimHandle() : 0;
    pData->dwStride = pStream->m_dwStride;
    m_pDDIStream[__NUMSTREAMS].m_dwStride = pStream->m_dwStride;
    m_pDDIStream[__NUMSTREAMS].m_pStream = pStream;
    m_pDDIStream[__NUMSTREAMS].m_pBuf = pStream->m_pVBI;
    if(pStream->m_pVBI != 0)
    {
        pStream->m_pVBI->Batch();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8_DrawPrimitive"

void
CD3DDDIDX8_DrawPrimitive(CD3DBase* pDevice, D3DPRIMITIVETYPE PrimitiveType,
                         UINT StartVertex, UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        pDev->ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, 
                            nVer, FALSE);
    }
#endif // DBG
    CD3DDDIDX8* pDDI = static_cast<CD3DDDIDX8*>(pDevice->m_pDDI);
    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        pDDI->UpdateDirtyStreams();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    if (pDDI->bDP2CurrCmdOP == D3DDP2OP_DRAWPRIMITIVE)
    { // Last instruction is a DrawPrimitive, append this one to it
        //
        // First check if the new instruction is a TRIANGLELIST. If it is,
        // AND if the new StartVertex = prev StartVertex + prev PrimitiveCount * 3
        // then we can simply bump up the prev primitive count. This makes
        // drivers go a LOT faster. (snene - 12/00)
        //
        
        //!!!!!!!!!!!!!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // The following code READS BACK from the batched command. This is
        // NOT a problem for sysmem command buffers in DX8. However, going
        // forward, if we ever implement vidmem command buffers, we need
        // to FIX this code to not read back. (snene - 12/00)
        LPD3DHAL_DP2DRAWPRIMITIVE pData = (LPD3DHAL_DP2DRAWPRIMITIVE)
            ((LPBYTE)pDDI->lpvDP2Commands + pDDI->dwDP2CommandLength - sizeof(D3DHAL_DP2DRAWPRIMITIVE) +
            pDDI->dp2data.dwCommandOffset);
        if(pData->primType == D3DPT_TRIANGLELIST && 
           pData->primType == PrimitiveType && 
           pData->VStart + pData->PrimitiveCount * 3 == StartVertex &&
           pData->PrimitiveCount + PrimitiveCount >= pData->PrimitiveCount) // overflow
        {
            pData->PrimitiveCount += PrimitiveCount;
            return;
        }                
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2DRAWPRIMITIVE) <=
            pDDI->dwDP2CommandBufSize)
        {
            ++pData;
            pDDI->lpDP2CurrCommand->wStateCount = ++pDDI->wDP2CurrCmdCnt;
            pData->primType = PrimitiveType;
            pData->VStart = StartVertex;
            pData->PrimitiveCount = PrimitiveCount;
            pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2DRAWPRIMITIVE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
            return;
        }
    }
    // Check for space
    if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2DRAWPRIMITIVE) > pDDI->dwDP2CommandBufSize)
    {
        pDDI->FlushStates();
    }
    // Add new DrawPrimitive instruction
    pDDI->lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)pDDI->lpvDP2Commands +
        pDDI->dwDP2CommandLength + pDDI->dp2data.dwCommandOffset);
    pDDI->lpDP2CurrCommand->bCommand = D3DDP2OP_DRAWPRIMITIVE;
    pDDI->bDP2CurrCmdOP = D3DDP2OP_DRAWPRIMITIVE;
    pDDI->lpDP2CurrCommand->bReserved = 0;
    pDDI->lpDP2CurrCommand->wStateCount = 1;
    pDDI->wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
    // Add DrawPrimitive data
    LPD3DHAL_DP2DRAWPRIMITIVE pData;
    pData = (LPD3DHAL_DP2DRAWPRIMITIVE)(pDDI->lpDP2CurrCommand + 1);
    pData->primType = PrimitiveType;
    pData->VStart = StartVertex;
    pData->PrimitiveCount = PrimitiveCount;
    pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                                sizeof(D3DHAL_DP2DRAWPRIMITIVE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetDummyData"

void
CD3DDDIDX8::SetDummyData()
{
    dp2data.dwVertexSize   = m_dwDummyVertexSize;
    dp2data.lpVertices     = m_pvDummyArray;
    dp2data.dwVertexLength = m_dwDummyVertexLength;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8_DrawIndexedPrimitive"

void
CD3DDDIDX8_DrawIndexedPrimitive(CD3DBase* pDevice,
                                D3DPRIMITIVETYPE PrimitiveType,
                                UINT BaseVertexIndex,
                                UINT MinIndex, UINT NumVertices,
                                UINT StartIndex, UINT PrimitiveCount)
{
#if DBG
    if (!(pDevice->BehaviorFlags() & D3DCREATE_PUREDEVICE))
    {
        CD3DHal* pDev = static_cast<CD3DHal*>(pDevice);
        pDev->ValidateDraw2(PrimitiveType, MinIndex + BaseVertexIndex,
                            PrimitiveCount, NumVertices, TRUE, StartIndex);
    }
#endif // DBG
    CD3DDDIDX8* pDDI = static_cast<CD3DDDIDX8*>(pDevice->m_pDDI);
    if(pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        pDevice->UpdateTextures();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        pDDI->UpdateDirtyStreams();
        pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    if (pDDI->bDP2CurrCmdOP == D3DDP2OP_DRAWINDEXEDPRIMITIVE)
    { // Last instruction is a DrawIndexedPrimitive, append this one to it
        //
        // First check if the new instruction is a TRIANGLELIST. If it is,
        // AND if the new StartIndex = prev StartIndex + prev PrimitiveCount * 3
        // AND if the new BaseVertexIndex = prev BaseVertexIndex
        // then we can simply bump up the prev primitive count. This makes
        // drivers go a LOT faster. (snene - 12/00)
        //
        
        //!!!!!!!!!!!!!!!!!!!!!!!!!!ALERT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // The following code READS BACK from the batched command. This is
        // NOT a problem for sysmem command buffers in DX8. However, going
        // forward, if we ever implement vidmem command buffers, we need
        // to FIX this code to not read back. (snene - 12/00)
        LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)
            ((LPBYTE)pDDI->lpvDP2Commands + pDDI->dwDP2CommandLength - sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE) +
            pDDI->dp2data.dwCommandOffset);
        if(pData->primType == D3DPT_TRIANGLELIST && 
           pData->primType == PrimitiveType && 
           pData->BaseVertexIndex == BaseVertexIndex &&
           pData->StartIndex + pData->PrimitiveCount * 3 == StartIndex &&
           pData->PrimitiveCount + PrimitiveCount >= pData->PrimitiveCount) // overflow
        {
            UINT mnidx = min(pData->MinIndex, MinIndex);
            UINT mxidx = max(pData->MinIndex + pData->NumVertices, MinIndex + NumVertices);
            if(mxidx - mnidx <= pData->NumVertices + NumVertices)
            {
                pData->NumVertices = mxidx - mnidx;
                pData->MinIndex = mnidx;
                pData->PrimitiveCount += PrimitiveCount;
                return;
            }
        }                
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE) <=
            pDDI->dwDP2CommandBufSize)
        {
            ++pData;
            pDDI->lpDP2CurrCommand->wStateCount = ++pDDI->wDP2CurrCmdCnt;
            pData->BaseVertexIndex = BaseVertexIndex;
            pData->primType = PrimitiveType;
            pData->PrimitiveCount = PrimitiveCount;
            pData->MinIndex = MinIndex;
            pData->NumVertices = NumVertices;
            pData->StartIndex = StartIndex;
            pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
            return;
        }
    }
    // Check for space
    if (pDDI->dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE) > pDDI->dwDP2CommandBufSize)
    {
        pDDI->FlushStates();
    }
    // Add new DrawIndexedPrimitive instruction
    pDDI->lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)pDDI->lpvDP2Commands +
        pDDI->dwDP2CommandLength + pDDI->dp2data.dwCommandOffset);
    pDDI->lpDP2CurrCommand->bCommand = D3DDP2OP_DRAWINDEXEDPRIMITIVE;
    pDDI->bDP2CurrCmdOP = D3DDP2OP_DRAWINDEXEDPRIMITIVE;
    pDDI->lpDP2CurrCommand->bReserved = 0;
    pDDI->lpDP2CurrCommand->wStateCount = 1;
    pDDI->wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)pDDI->lpDP2CurrCommand);
    // Add DrawIndexedPrimitive data
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pData;
    pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(pDDI->lpDP2CurrCommand + 1);
    pData->BaseVertexIndex = BaseVertexIndex;
    pData->primType = PrimitiveType;
    pData->PrimitiveCount = PrimitiveCount;
    pData->MinIndex = MinIndex;
    pData->NumVertices = NumVertices;
    pData->StartIndex = StartIndex;
    pDDI->dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
                                sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE);

#if DBG
//    if (m_bValidateCommands)
//        ValidateCommand(lpDP2CurrCommand);
#endif
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawPrimitiveUP"

void
CD3DDDIDX8::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount)
{
    UINT NumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    if (NumVertices > LOWVERTICESNUMBER)
    {
        if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
        {
            UpdateDirtyStreams();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        }
        this->FlushStates();
        dp2data.dwVertexType = 0;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwVertexLength = NumVertices;
        try
        {
            InsertStreamSourceUP(m_pDevice->m_pStream[0].m_dwStride);
            CD3DDDIDX8_DrawPrimitive(m_pDevice, PrimitiveType, 0, PrimitiveCount);
            this->FlushStates();
        }
        catch( HRESULT hr )
        {
            SetDummyData();
            throw hr;
        }
        SetDummyData();
    }
    else
    {
        // Copy vertices to the internal TL buffer

        UINT VertexSize = m_pDevice->m_pStream[0].m_dwStride;
        // When vertex size has been changed we need to start from the 
        // beginning of the vertex buffer to correctly handle vertex offsets
        if (m_pTLStreamW->GetPrimitiveBase() % VertexSize)
        {
            this->FlushStates();
            m_pTLStreamW->Reset();
        }

        // Copy vertices into the internal write only buffer
        m_pTLStreamW->SetVertexSize(VertexSize);
        UINT VertexPoolSize = VertexSize * NumVertices;
        LPVOID lpvOut = m_pTLStreamW->Lock(VertexPoolSize, this);
        UINT StartVertex = m_pTLStreamW->GetPrimitiveBase() / VertexSize;
        memcpy(lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
        m_pTLStreamW->Unlock();
        m_pTLStreamW->SkipVertices(NumVertices);

        // To prevent overriding of stream 0 we clear D3DRT_NEED_VB_UPDATE and
        // stream dirty bit. We need to clear the stream dirty bit, because during
        // UpdateTextures D3DRT_NEED_VB_UPDATE could be set again
        DWORD dwRuntimeFlags = m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwStreamDirty &= ~1;

        if (m_pDDIStream[0].m_pBuf != m_pTLStreamW->m_pVB || 
            m_pDDIStream[0].m_dwStride != m_pTLStreamW->m_dwStride)
        {
            InsertStreamSource(m_pTLStreamW);
        }

#if DBG
        // Need this to pass validation
        m_pDevice->m_pStream[0].m_dwNumVertices = StartVertex + NumVertices;
#endif
        // Insert drawing command
        CD3DDDIDX8_DrawPrimitive(m_pDevice, PrimitiveType, StartVertex, PrimitiveCount);

        m_pDevice->m_dwRuntimeFlags |= dwRuntimeFlags;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawIndexedPrimitiveUP"

void
CD3DDDIDX8::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType,
                                  UINT MinVertexIndex,
                                  UINT NumVertices,
                                  UINT PrimitiveCount)
{
    if (NumVertices > LOWVERTICESNUMBER)
    {
        if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
        {
            UpdateDirtyStreams();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        }
        this->FlushStates();
        dp2data.dwVertexType = 0;
        dp2data.dwVertexSize = m_pDevice->m_pStream[0].m_dwStride;
        dp2data.lpVertices = m_pDevice->m_pStream[0].m_pData;
        dp2data.dwVertexLength = NumVertices;
        try
        {
            InsertStreamSourceUP(m_pDevice->m_pStream[0].m_dwStride);

            UINT NumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
            m_pIndexStream->SetVertexSize(m_pDevice->m_pIndexStream->m_dwStride);
            // Always start from the beginning of the index stream
            // Copy indices into the internal stream
            DWORD dwIndicesByteCount = NumIndices * m_pIndexStream->m_dwStride;
            BYTE* pIndexData = m_pIndexStream->LockDiscard(dwIndicesByteCount, this);
            memcpy(pIndexData, m_pDevice->m_pIndexStream->m_pData, dwIndicesByteCount);
            m_pIndexStream->Unlock();

            InsertIndices(m_pIndexStream);

            CD3DDDIDX8_DrawIndexedPrimitive(m_pDevice, PrimitiveType, 0,
                                            MinVertexIndex, NumVertices, 0,
                                            PrimitiveCount);
            this->FlushStates();
        }
        catch( HRESULT hr )
        {
            SetDummyData();
            throw hr;
        }
        SetDummyData();
    }
    else
    {
        // Copy user data into internal buffers
        
        UINT VertexSize = m_pDevice->m_pStream[0].m_dwStride;
        UINT IndexSize = m_pDevice->m_pIndexStream->m_dwStride;
        if ((m_pTLStreamW->GetPrimitiveBase() % VertexSize) ||
            (m_pIndexStream->GetPrimitiveBase() % IndexSize))
        {
            this->FlushStates();
            m_pTLStreamW->Reset();
            m_pIndexStream->Reset();
        }

        // Copy vertices into the internal write only buffer
        m_pTLStreamW->SetVertexSize(VertexSize);
        UINT VertexPoolSize = VertexSize * NumVertices;
        LPVOID lpvOut = m_pTLStreamW->Lock(VertexPoolSize, this);
        UINT StartVertex = m_pTLStreamW->GetPrimitiveBase() / VertexSize;
        UINT FirstVertexOffset = MinVertexIndex * VertexSize;
        memcpy(lpvOut, m_pDevice->m_pStream[0].m_pData + FirstVertexOffset, 
               VertexPoolSize);
        m_pTLStreamW->Unlock();
        m_pTLStreamW->SkipVertices(NumVertices);

        // To prevent overriding of stream 0 we clear D3DRT_NEED_VB_UPDATE and
        // stream dirty bit. We need to clear the stream dirty bit, because during
        // UpdateTextures D3DRT_NEED_VB_UPDATE could be set again
        DWORD dwRuntimeFlags = m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        m_pDevice->m_dwStreamDirty &= ~(1 | (1 << __NUMSTREAMS));

        if (m_pDDIStream[0].m_pBuf != m_pTLStreamW->m_pVB || 
            m_pDDIStream[0].m_dwStride != m_pTLStreamW->m_dwStride)
        {
            InsertStreamSource(m_pTLStreamW);
        }

        // Copy indices into the internal buffer. Re-base indices if necessery.
        m_pIndexStream->SetVertexSize(IndexSize);
        UINT NumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        UINT IndexPoolSize = IndexSize * NumIndices;
        lpvOut = m_pIndexStream->Lock(IndexPoolSize, this);
        UINT StartIndex = m_pIndexStream->GetPrimitiveBase() / IndexSize;
        memcpy(lpvOut, m_pDevice->m_pIndexStream->m_pData, IndexPoolSize);
        m_pIndexStream->Unlock();
        m_pIndexStream->SkipVertices(NumIndices);

        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != m_pIndexStream->m_pVBI || 
            m_pDDIStream[__NUMSTREAMS].m_dwStride != m_pIndexStream->m_dwStride)
        {
            InsertIndices(m_pIndexStream);
        }

#if DBG
        // Need this to pass validation
        m_pDevice->m_pStream[0].m_dwNumVertices = StartVertex + NumVertices;
        m_pDevice->m_pIndexStream->m_dwNumVertices = StartIndex + NumIndices;
#endif
        // Draw primitive
        CD3DDDIDX8_DrawIndexedPrimitive(m_pDevice, PrimitiveType, 
                                        StartVertex - MinVertexIndex,
                                        MinVertexIndex, NumVertices, StartIndex, 
                                        PrimitiveCount);

        m_pDevice->m_dwRuntimeFlags |= dwRuntimeFlags;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawRectPatch"

void
CD3DDDIDX8::DrawRectPatch(UINT Handle, CONST D3DRECTPATCH_INFO *pSurf, 
                          CONST FLOAT *pNumSegs)
{
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        UpdateDirtyStreams();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    LPD3DHAL_DP2DRAWRECTPATCH pData;
    pData = (LPD3DHAL_DP2DRAWRECTPATCH)
            GetHalBufferPointer(D3DDP2OP_DRAWRECTPATCH,
                                sizeof(*pData) + (pSurf != 0 ? sizeof(D3DRECTPATCH_INFO) : 0) + (pNumSegs != 0 ? sizeof(FLOAT) * 4 : 0));
    pData->Handle = Handle;
    DWORD offset;
    if(pNumSegs != 0)
    {
        offset = sizeof(FLOAT) * 4;
        memcpy(pData + 1, pNumSegs, offset);
        pData->Flags = RTPATCHFLAG_HASSEGS;
    }
    else
    {
        pData->Flags = 0;
        offset = 0;
    }
    if(pSurf != 0)
    {
        memcpy((BYTE*)(pData + 1) + offset, pSurf, sizeof(D3DRECTPATCH_INFO));
        pData->Flags |= RTPATCHFLAG_HASINFO;
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawTriSurface"

void
CD3DDDIDX8::DrawTriPatch(UINT Handle, CONST D3DTRIPATCH_INFO *pSurf, 
                         CONST FLOAT *pNumSegs)
{
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
    {
        UpdateDirtyStreams();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
    }
    LPD3DHAL_DP2DRAWTRIPATCH pData;
    pData = (LPD3DHAL_DP2DRAWTRIPATCH)
            GetHalBufferPointer(D3DDP2OP_DRAWTRIPATCH,
                                sizeof(*pData) + (pSurf != 0 ? sizeof(D3DTRIPATCH_INFO) : 0) + (pNumSegs != 0 ? sizeof(FLOAT) * 3 : 0));
    pData->Handle = Handle;
    DWORD offset;
    if(pNumSegs != 0)
    {
        offset = sizeof(FLOAT) * 3;
        memcpy(pData + 1, pNumSegs, offset);
        pData->Flags = RTPATCHFLAG_HASSEGS;
    }
    else
    {
        pData->Flags = 0;
        offset = 0;
    }
    if(pSurf != 0)
    {
        memcpy((BYTE*)(pData + 1) + offset, pSurf, sizeof(D3DTRIPATCH_INFO));
        pData->Flags |= RTPATCHFLAG_HASINFO;
    }
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartPrimVB"

void
CD3DDDIDX8::StartPrimVB(D3DFE_PROCESSVERTICES * pv, CVStream* pStream,
                        DWORD dwStartVertex)
{
    SetWithinPrimitive(TRUE);
    UINT size = dwStartVertex * pv->dwOutputSize;
    if (pStream)
        m_pTLStreamRO->Init(pStream->m_pVB, size);
    else
        m_pTLStreamRO->Init(NULL, size);
    m_pTLStreamRO->SetVertexSize(pv->dwOutputSize);
    m_pCurrentTLStream = m_pTLStreamRO;
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartIndexPrimVB"

void
CD3DDDIDX8::StartIndexPrimVB(CVIndexStream* pStream, UINT StartIndex,
                             UINT IndexSize)
{
    m_pTLIndexStreamRO->Init(pStream->m_pVBI, StartIndex * IndexSize);
    m_pTLIndexStreamRO->SetVertexSize(IndexSize);
    m_pCurrentIndexStream = m_pTLIndexStreamRO;
}
//-----------------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called when the runtime needs to output vertices to a TL buffer
// TL buffer grows if necessary
//
// Uses the following global variables:
//      pv->dwOutputSize
//     Sets "within primitive" to TRUE
// Returns:
//      TL buffer address
//
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartPrimTL"

LPVOID
CD3DDDIDX8::StartPrimTL(D3DFE_PROCESSVERTICES * pv, DWORD dwVertexPoolSize,
                        BOOL bWriteOnly)
{
    CTLStream* pStream = bWriteOnly? m_pTLStreamW : m_pTLStream;
    LPVOID p = pStream->Lock(dwVertexPoolSize, this);
    pStream->SetVertexSize(pv->dwOutputSize);
    m_pCurrentTLStream = pStream;
    SetWithinPrimitive(TRUE);
    return p;
}
//---------------------------------------------------------------------
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawPrim"

void
CD3DDDIDX8::DrawPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif

    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pCurrentTLStream->m_pVB) ||
        pv->dwOutputSize != m_pDDIStream[0].m_dwStride)
    {
        InsertStreamSource(m_pCurrentTLStream);
        // API stream should be set dirty, in case it is later passed to DDI directly
        m_pDevice->m_dwStreamDirty |= 1;
        m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;
    }
    if (pv->primType == D3DPT_POINTLIST &&
        pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        DrawPrimPS(pv);
        return;
    }
    LPD3DHAL_DP2DRAWPRIMITIVE2 pData;
    pData = (LPD3DHAL_DP2DRAWPRIMITIVE2)
            GetHalBufferPointer(D3DDP2OP_DRAWPRIMITIVE2, sizeof(*pData));
    pData->primType = pv->primType;
    pData->FirstVertexOffset = m_pCurrentTLStream->GetPrimitiveBase();
    pData->PrimitiveCount = pv->dwNumPrimitives;

    m_pCurrentTLStream->SkipVertices(pv->dwNumVertices);

#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif
}
//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwNumIndices
//      dwIndexSize
//      lpwIndices
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawIndexPrim"

void
CD3DDDIDX8::DrawIndexPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
    this->dwDP2Flags |= D3DDDI_INDEXEDPRIMDRAWN;
    if (m_pCurrentIndexStream == m_pIndexStream)
    {
        // We always copy user provided indices to the internal index stream.
        // Therefore we have to check the available stream size and do Lock/Unlock
        DWORD dwIndicesByteCount = pv->dwNumIndices * pv->dwIndexSize;
        // We cannot mix DWORD and WORD indices because of alignment issues 
        // on ia64
        if (m_pIndexStream->GetVertexSize() != pv->dwIndexSize)
        {
            this->FlushStates();
            m_pIndexStream->Reset();
            m_pIndexStream->SetVertexSize(pv->dwIndexSize);
        }
        BYTE* pIndexData = m_pIndexStream->Lock(dwIndicesByteCount, this);
        memcpy(pIndexData, pv->lpwIndices, dwIndicesByteCount);
        m_pIndexStream->Unlock();
    }
    if (m_pCurrentIndexStream->m_pVBI->IsD3DManaged())
    {
        if (m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_VB_UPDATE)
        {
            BOOL bDirty = FALSE;
            HRESULT result = m_pDevice->ResourceManager()->UpdateVideo(m_pCurrentIndexStream->m_pVBI->RMHandle(), &bDirty);
            if(result != D3D_OK)
            {
                D3D_THROW(result, "Resource manager failed to create or update video memory IB");
            }
            if((m_pDevice->m_dwStreamDirty & (1 << __NUMSTREAMS)) != 0 || bDirty)
            {
                InsertIndices(m_pCurrentIndexStream);
                CDDIStream &Stream = m_pDDIStream[__NUMSTREAMS];
                Stream.m_pStream = m_pCurrentIndexStream;
                Stream.m_pBuf = m_pCurrentIndexStream->m_pVBI;
                Stream.m_dwStride = m_pCurrentIndexStream->m_dwStride;
                m_pDevice->m_dwStreamDirty &= ~(1 << __NUMSTREAMS); // reset stage dirty
            }
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_VB_UPDATE;
        }
    }
    else
    {
        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != static_cast<CBuffer*>(m_pCurrentIndexStream->m_pVBI) ||
            pv->dwIndexSize != m_pDDIStream[__NUMSTREAMS].m_dwStride)
        {
            m_pCurrentIndexStream->SetVertexSize(pv->dwIndexSize);
            InsertIndices(m_pCurrentIndexStream);
            // API stream should be set dirty, in case it is later passed to DDI directly
            m_pDevice->m_dwStreamDirty |= (1 << __NUMSTREAMS);
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
    }
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }

    if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pCurrentTLStream->m_pVB) ||
        pv->dwOutputSize != m_pDDIStream[0].m_dwStride)
    {
        m_pDDIStream[0].m_dwStride = pv->dwOutputSize;
        InsertStreamSource(m_pCurrentTLStream);
        // API stream should be set dirty, in case it is later passed to DDI directly
        m_pDevice->m_dwStreamDirty |= 1;
        m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
    }

    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pData;
    pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)
            GetHalBufferPointer(D3DDP2OP_DRAWINDEXEDPRIMITIVE2, sizeof(*pData));
    pData->primType = pv->primType;
    pData->BaseVertexOffset = m_BaseVertexIndex;
    pData->MinIndex = m_MinVertexIndex;
    pData->NumVertices = m_NumVertices;
    pData->StartIndexOffset = m_pCurrentIndexStream->GetPrimitiveBase();
    pData->PrimitiveCount = pv->dwNumPrimitives;

    m_pCurrentIndexStream->SkipVertices(pv->dwNumIndices);

}
//-----------------------------------------------------------------------------
// This primitive is generated by the clipper.
// The vertices of this primitive are pointed to by the
// lpvOut member, which need to be copied into the
// command stream immediately after the command itself.
//
// Uses the following members of D3DFE_PROCESSVERTICES:
//      primType
//      dwNumVertices
//      dwNumPrimitives
//      dwOutputSize
//      dwFlags (D3DPV_NONCLIPPED)
//      lpdwRStates (FILLMODE)
//      lpvOut
//      ClipperState.current_vbuf
//

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::DrawClippedPrim"

void
CD3DDDIDX8::DrawClippedPrim(D3DFE_PROCESSVERTICES* pv)
{
#ifdef DEBUG_PIPELINE
    if (g_DebugFlags & __DEBUG_NORENDERING)
        return;
#endif
    if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pTLStreamClip->m_pVB) ||
        pv->dwOutputSize != m_pDDIStream[0].m_dwStride)
    {
        m_pTLStreamClip->SetVertexSize(pv->dwOutputSize);
        InsertStreamSource(m_pTLStreamClip);
        // API stream should be set dirty, in case it is later passed to DDI directly
        m_pDevice->m_dwStreamDirty |= 1;
        m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
    }
    if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
    {
        m_pDevice->UpdateTextures();
        m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
    }
    DWORD dwVertexPoolSize = pv->dwNumVertices * pv->dwOutputSize;
    LPVOID pVertices;
    if (pv->primType == D3DPT_TRIANGLEFAN)
    {
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
            pv->dwFlags & D3DPV_NONCLIPPED)
        {
            // For unclipped (but pretended to be clipped) tri fans in
            // wireframe mode we generate 3-vertex tri fans to enable drawing
            // of interior edges
            BYTE vertices[__MAX_VERTEX_SIZE*3];
            BYTE *pV1 = vertices + pv->dwOutputSize;
            BYTE *pV2 = pV1 + pv->dwOutputSize;
            BYTE *pInput = (BYTE*)pv->lpvOut;
            memcpy(vertices, pInput, pv->dwOutputSize);
            pInput += pv->dwOutputSize;
            const DWORD nTriangles = pv->dwNumVertices - 2;
            pv->dwNumVertices = 3;
            pv->dwNumPrimitives = 1;
            pv->lpvOut = vertices;
            // Remove this flag for recursive call
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
            for (DWORD i = nTriangles; i; i--)
            {
                memcpy(pV1, pInput, pv->dwOutputSize);
                memcpy(pV2, pInput + pv->dwOutputSize, pv->dwOutputSize);
                pInput += pv->dwOutputSize;
                // To enable all edge flag we set the fill mode to SOLID.
                // This will prevent checking the clip flags in the clipper
                // state
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                DrawClippedPrim(pv);
                pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
            }
            return;
        }
        // Lock should be before GetPrimitiveBase(), because the primitive
        // base could be changed during Lock()
        pVertices = m_pTLStreamClip->Lock(dwVertexPoolSize, this);
        LPD3DHAL_CLIPPEDTRIANGLEFAN pData;
        pData = (LPD3DHAL_CLIPPEDTRIANGLEFAN)
                GetHalBufferPointer(D3DDP2OP_CLIPPEDTRIANGLEFAN, sizeof(*pData));
        pData->FirstVertexOffset = m_pTLStreamClip->GetPrimitiveBase();
        pData->PrimitiveCount = pv->dwNumPrimitives;
        if (pv->lpdwRStates[D3DRENDERSTATE_FILLMODE] != D3DFILL_WIREFRAME)
        {
            // Mark all exterior edges visible
            pData->dwEdgeFlags = 0xFFFFFFFF;
        }
        else
        {
            pData->dwEdgeFlags = 0;
            ClipVertex **clip = pv->ClipperState.current_vbuf;
            // Look at the exterior edges and mark the visible ones
            for(DWORD i = 0; i < pv->dwNumVertices; ++i)
            {
                if (clip[i]->clip & CLIPPED_ENABLE)
                    pData->dwEdgeFlags |= (1 << i);
            }
        }
    }
    else
    {
        // Lock should be before GetPrimitiveBase(), because the primitive
        // base could be changed during Lock()
        pVertices = m_pTLStreamClip->Lock(dwVertexPoolSize, this);
#if DBG
        if (pv->primType != D3DPT_LINELIST)
        {
            D3D_THROW_FAIL("Internal error - invalid primitive type");
        }
#endif
        LPD3DHAL_DP2DRAWPRIMITIVE2 pData;
        pData = (LPD3DHAL_DP2DRAWPRIMITIVE2)
                GetHalBufferPointer(D3DDP2OP_DRAWPRIMITIVE2, sizeof(*pData));
        pData->primType = D3DPT_LINELIST;
        pData->FirstVertexOffset = m_pTLStreamClip->GetPrimitiveBase();
        pData->PrimitiveCount = pv->dwNumPrimitives;
    }

    // Copy vertices to the clipped stream
    memcpy(pVertices, pv->lpvOut, dwVertexPoolSize);
    m_pTLStreamClip->Unlock();
    m_pTLStreamClip->SkipVertices(pv->dwNumVertices);

#if DBG
    if (m_bValidateCommands)
        ValidateCommand(lpDP2CurrCommand);
#endif
}
//-----------------------------------------------------------------------------
// This function is called whe software vertex processing is used
// Handle should be always legacy
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetVertexShader"

void
CD3DDDIDX8::SetVertexShader( DWORD dwHandle )
{
    DXGASSERT(D3DVSD_ISLEGACY(dwHandle));

    if (dwHandle != m_CurrentVertexShader)
    {
        m_CurrentVertexShader = dwHandle;
        LPD3DHAL_DP2VERTEXSHADER pData;
        pData = (LPD3DHAL_DP2VERTEXSHADER)
                GetHalBufferPointer(D3DDP2OP_SETVERTEXSHADER, sizeof(*pData));
        {
            // Drivers do not need to know about D3DFVF_LASTBETA_UBYTE4 bit
            dwHandle &= ~D3DFVF_LASTBETA_UBYTE4;
        }
        pData->dwHandle = dwHandle;
    }
}
//-----------------------------------------------------------------------------
// This function is called whe hardware vertex processing is used
// Redundant shader check has been done at the API level
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::SetVertexShaderHW"

void
CD3DDDIDX8::SetVertexShaderHW( DWORD dwHandle )
{
    m_CurrentVertexShader = dwHandle;
    LPD3DHAL_DP2VERTEXSHADER pData;
    pData = (LPD3DHAL_DP2VERTEXSHADER)
            GetHalBufferPointer(D3DDP2OP_SETVERTEXSHADER, sizeof(*pData));
    if( D3DVSD_ISLEGACY(dwHandle) )
    {
        // Drivers do not need to know about D3DFVF_LASTBETA_UBYTE4 bit
        dwHandle &= ~D3DFVF_LASTBETA_UBYTE4;
    }
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
// Point sprites are drawn as indexed triangle list
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::StartPointSprites"

void CD3DDDIDX8::StartPointSprites()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    
    // For StartPrimTL we should use vertex size, which will go to the driver
    DWORD tmpVertexSize = pv->dwOutputSize;
    pv->dwOutputSize = m_dwOutputSizePS;

    // Set new output vertex shader for the DDI
    SetVertexShader(m_dwVIDOutPS);
    
    // Reserve place for the output vertices
    const UINT size = NUM_SPRITES_IN_BATCH * 4 * pv->dwOutputSize;
    m_pCurSpriteVertex = (BYTE*)StartPrimTL(pv, size, TRUE);

    // Restore vertex size, which is size before point sprite emulation
    pv->dwOutputSize = tmpVertexSize;

    // Index stream used to hold indices
    m_pCurrentIndexStream = m_pIndexStream;
    pv->dwIndexSize = 2;
    // Reserve place for indices
    UINT count = NUM_SPRITES_IN_BATCH * 2 * 6;
    m_pCurPointSpriteIndex = (WORD*)m_pIndexStream->Lock(count, this);

    m_CurNumberOfSprites = 0;
    SetWithinPrimitive(TRUE);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::EndPointSprites"

void CD3DDDIDX8::EndPointSprites()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    m_pCurrentIndexStream->Unlock();
    m_pCurrentTLStream->Unlock();
    if (m_CurNumberOfSprites)
    {
        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != static_cast<CBuffer*>(m_pCurrentIndexStream->m_pVBI) ||
            pv->dwIndexSize != m_pDDIStream[__NUMSTREAMS].m_dwStride)
        {
            m_pCurrentIndexStream->SetVertexSize(pv->dwIndexSize);
            InsertIndices(m_pCurrentIndexStream);
        }
        if (m_pDDIStream[0].m_pBuf != static_cast<CBuffer*>(m_pCurrentTLStream->m_pVB) ||
            m_dwOutputSizePS != m_pDDIStream[0].m_dwStride)
        {
            InsertStreamSource(m_pCurrentTLStream);
        }
        if(m_pDevice->m_dwRuntimeFlags & D3DRT_NEED_TEXTURE_UPDATE)
        {
            m_pDevice->UpdateTextures();
            m_pDevice->m_dwRuntimeFlags &= ~D3DRT_NEED_TEXTURE_UPDATE;
        }
        UINT NumVertices = m_CurNumberOfSprites * 4;
        LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pData;
        pData = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)
                GetHalBufferPointer(D3DDP2OP_DRAWINDEXEDPRIMITIVE2, sizeof(*pData));
        pData->primType = D3DPT_TRIANGLELIST;
        pData->BaseVertexOffset = m_pCurrentTLStream->GetPrimitiveBase();
        pData->MinIndex = 0;
        pData->NumVertices = NumVertices;
        pData->StartIndexOffset = m_pCurrentIndexStream->GetPrimitiveBase();
        pData->PrimitiveCount = m_CurNumberOfSprites * 2;

        m_pCurrentIndexStream->SkipVertices(m_CurNumberOfSprites * 6);
        m_pCurrentTLStream->SkipVertices(NumVertices);

        m_CurNumberOfSprites = 0;
    }
    SetWithinPrimitive(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CD3DDDIDX8TL                                                            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

CD3DDDIDX8TL::CD3DDDIDX8TL()
{
    m_ddiType = D3DDDITYPE_DX8TL;
    m_dwInterfaceNumber = 4;
}

//-----------------------------------------------------------------------------
CD3DDDIDX8TL::~CD3DDDIDX8TL()
{
    return;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::CreateVertexShader"

void
CD3DDDIDX8TL::CreateVertexShader(CONST DWORD* pdwDeclaration,
                                 DWORD dwDeclSize,
                                 CONST DWORD* pdwFunction,
                                 DWORD dwCodeSize,
                                 DWORD dwHandle,
                                 BOOL bLegacyFVF)
{
    FlushStates();
    LPD3DHAL_DP2CREATEVERTEXSHADER pData;
    pData = (LPD3DHAL_DP2CREATEVERTEXSHADER)
            GetHalBufferPointer(D3DDP2OP_CREATEVERTEXSHADER,
                                sizeof(*pData) + dwDeclSize + dwCodeSize);
    pData->dwHandle = dwHandle;
    pData->dwDeclSize = dwDeclSize;
    pData->dwCodeSize = dwCodeSize;
    LPBYTE p = (LPBYTE)&pData[1];
    memcpy(p, pdwDeclaration, dwDeclSize);
    if (pdwFunction)
    {
        p += dwDeclSize;
        memcpy(p, pdwFunction, dwCodeSize);
    }
    FlushStates();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::DeleteVertexShader"

void
CD3DDDIDX8TL::DeleteVertexShader(DWORD dwHandle)
{
    if (dwHandle == m_CurrentVertexShader)
        m_CurrentVertexShader = 0;
    LPD3DHAL_DP2VERTEXSHADER pData;
    pData = (LPD3DHAL_DP2VERTEXSHADER)
            GetHalBufferPointer(D3DDP2OP_DELETEVERTEXSHADER, sizeof(*pData));
    pData->dwHandle = dwHandle;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetVertexShaderConstant"

void
CD3DDDIDX8TL::SetVertexShaderConstant(DWORD dwRegister, CONST VOID* data, DWORD count)
{
    const DWORD size = count << 4;
    LPD3DHAL_DP2SETVERTEXSHADERCONST pData;
    pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)
            GetHalBufferPointer(D3DDP2OP_SETVERTEXSHADERCONST,
                                sizeof(*pData) + size);
    pData->dwRegister = dwRegister;
    pData->dwCount = count;
    memcpy(pData+1, data, size);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::MultiplyTransform"

void
CD3DDDIDX8TL::MultiplyTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    // Send down the state and the matrix
    LPD3DHAL_DP2MULTIPLYTRANSFORM pData;
    pData = (LPD3DHAL_DP2MULTIPLYTRANSFORM)
            GetHalBufferPointer(D3DDP2OP_MULTIPLYTRANSFORM, sizeof(*pData));
    pData->xfrmType = state;
    pData->matrix = *lpMat;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetTransform"

void
CD3DDDIDX8TL::SetTransform(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    // Send down the state and the matrix
    LPD3DHAL_DP2SETTRANSFORM pData;
    pData = (LPD3DHAL_DP2SETTRANSFORM)
            GetHalBufferPointer(D3DDP2OP_SETTRANSFORM, sizeof(*pData));
    pData->xfrmType = state;
    pData->matrix = *lpMat;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetViewport"

void
CD3DDDIDX8TL::SetViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    // Update viewport size
    CD3DDDIDX6::SetViewport(lpVwpData);

    // Update Z range
    LPD3DHAL_DP2ZRANGE pData;
    pData = (LPD3DHAL_DP2ZRANGE)GetHalBufferPointer(D3DDP2OP_ZRANGE, sizeof(*pData));
    pData->dvMinZ = lpVwpData->MinZ;
    pData->dvMaxZ = lpVwpData->MaxZ;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetMaterial"

void
CD3DDDIDX8TL::SetMaterial(CONST D3DMATERIAL8* pMat)
{
    LPD3DHAL_DP2SETMATERIAL pData;
    pData = (LPD3DHAL_DP2SETMATERIAL)GetHalBufferPointer(D3DDP2OP_SETMATERIAL, sizeof(*pData));
    *pData = *((LPD3DHAL_DP2SETMATERIAL)pMat);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetLight"

void
CD3DDDIDX8TL::SetLight(DWORD dwLightIndex, CONST D3DLIGHT8* pLight)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)
            GetHalBufferPointer(D3DDP2OP_SETLIGHT,
                                sizeof(*pData) + sizeof(D3DLIGHT8));
    pData->dwIndex = dwLightIndex;
    pData->dwDataType = D3DHAL_SETLIGHT_DATA;
    D3DLIGHT8 UNALIGNED64 * p = (D3DLIGHT8 UNALIGNED64 *)((LPBYTE)pData + sizeof(D3DHAL_DP2SETLIGHT));
    *p = *pLight;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::CreateLight"

void
CD3DDDIDX8TL::CreateLight(DWORD dwLightIndex)
{
    LPD3DHAL_DP2CREATELIGHT pData;
    pData = (LPD3DHAL_DP2CREATELIGHT)GetHalBufferPointer(D3DDP2OP_CREATELIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::LightEnable"

void
CD3DDDIDX8TL::LightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT, sizeof(*pData));
    pData->dwIndex = dwLightIndex;
    if (bEnable)
        pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8TL::SetClipPlane"

void
CD3DDDIDX8TL::SetClipPlane(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation)
{
    LPD3DHAL_DP2SETCLIPPLANE pData;
    pData = (LPD3DHAL_DP2SETCLIPPLANE)
            GetHalBufferPointer(D3DDP2OP_SETCLIPPLANE, sizeof(*pData));
    pData->dwIndex = dwPlaneIndex;
    pData->plane[0] = pPlaneEquation[0];
    pData->plane[1] = pPlaneEquation[1];
    pData->plane[2] = pPlaneEquation[2];
    pData->plane[3] = pPlaneEquation[3];
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ClearBatch"

void
CD3DDDIDX8::ClearBatch(BOOL bWithinPrimitive)
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::FlushStates"

void
CD3DDDIDX8::FlushStates(BOOL bReturnDriverError, BOOL bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (m_bWithinPrimitive)
        bWithinPrimitive = TRUE;
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        m_pDevice->IncrementBatchCount();

        // Batch currently set VB streams
        CDDIStream* pStream = m_pDDIStream;
        for (UINT i=0; i < __NUMSTREAMS; i++)
        {
            if (pStream->m_pStream)
            {
                CVStream* p = static_cast<CVStream*>(pStream->m_pStream);
                CVertexBuffer* pVB = p->m_pVB;
                if (pVB)
                    pVB->Batch();
            }
            pStream++;
        }
        // Now pStream points to the index stream
        if (pStream->m_pStream)
        {
            CVIndexStream* p = static_cast<CVIndexStream*>(pStream->m_pStream);
            CIndexBuffer* pVB = p->m_pVBI;
            if (pVB)
                pVB->Batch();
        }
        // Save since it will get overwritten by ddrval after DDI call
        DWORD dwVertexSize = dp2data.dwVertexSize;

        dp2data.dwCommandLength = dwDP2CommandLength;
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        dwDP2CommandLength = 0;
        // Try and set these 2 values only once during initialization
        dp2data.dwhContext = m_dwhContext;
        dp2data.lpdwRStates = (LPDWORD)lpwDPBuffer;

        // Spin waiting on the driver if wait requested
        do {
            // Need to set this since the driver may have overwrote it by
            // setting ddrval = DDERR_WASSTILLDRAWING
            dp2data.dwVertexSize = dwVertexSize;
            dwRet = m_pDevice->GetHalCallbacks()->DrawPrimitives2(&dp2data);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }
        } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);

        dwRet= dp2data.ddrval;
        // update command buffer pointer
        if ((dwRet == D3D_OK) &&
            (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
        {
            // Implement VidMem command buffer and
            // command buffer swapping.
        }

        // Restore to value before the DDI call
        dp2data.dwVertexSize = dwVertexSize;
        ClearBatch(bWithinPrimitive);
    }
    // There are situations when the command stream has no data,
    // but there is data in the vertex pool. This could happen, for instance
    // if every triangle got rejected while clipping. In this case we still
    // need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch(bWithinPrimitive);
    }

    if( FAILED( dwRet ) )
    {
        ClearBatch(FALSE);
        if( !bReturnDriverError )
        {
            switch( dwRet )
            {
            case D3DERR_OUTOFVIDEOMEMORY:
                D3D_ERR("Driver out of video memory!");
                break;
            case D3DERR_COMMAND_UNPARSED:
                D3D_ERR("Driver could not parse this batch!");
                break;
            default:
                D3D_ERR("Driver returned error: %s", HrToStr(dwRet));
                break;
            }
            DPF_ERR("Driver failed command batch. Attempting to reset device"
                    " state. The device may now be in an unstable state and"
                    " the application may experience an access violation.");
        }
        else
        {
            throw dwRet;
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPointSprites"

void CD3DDDIDX8::PickProcessPrimitive()
{
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;
    if (pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION)
    {
        m_pfnProcessPrimitive = ProcessPointSprites;
    }
    else
    if (pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF)
    {
        m_pfnProcessPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessPrimitiveT);
        m_pfnProcessIndexedPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessIndexedPrimitiveT);
    }
    else
    if (pv->dwDeviceFlags & D3DDEV_DONOTCLIP)
    {
        m_pfnProcessPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessPrimitive);
        m_pfnProcessIndexedPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessIndexedPrimitive);
    }
    else
    {
        m_pfnProcessPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessPrimitiveC);
        m_pfnProcessIndexedPrimitive =
            static_cast<PFN_PROCESSPRIM>(ProcessIndexedPrimitiveC);
    }
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and without
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPrimitive"

void
CD3DDDIDX8::ProcessPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, TRUE);
    HRESULT ret = pv->pGeometryFuncs->ProcessVertices(pv);
    if (ret != D3D_OK)
    {
        SetWithinPrimitive(FALSE);
        m_pCurrentTLStream->Unlock();
        D3D_THROW(ret, "Error in PSGP");
    }
    DrawPrim(pv);
    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with untransformed vertices and with
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPrimitiveC"

void
CD3DDDIDX8::ProcessPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    PrepareForClipping(pv, 0);
    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, 
                             NeverReadFromTLBuffer(pv));
    // When a triangle strip is clipped, we draw indexed primitives
    // sometimes. This is why we need to initialize the index stream
    m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase();
    m_pCurrentIndexStream = m_pIndexStream;

    HRESULT ret;
    if (pv->primType == D3DPT_POINTLIST)
    {
        // When all points are clipped by X or Y planes we do not throw
        // them away, because they could have point size and be visible
        ret = D3D_OK;
        DWORD clipIntersection = pv->pGeometryFuncs->ProcessVertices(pv);
        clipIntersection &= ~(D3DCS_LEFT | D3DCS_RIGHT | 
                              D3DCS_TOP | D3DCS_BOTTOM |
                              __D3DCLIPGB_ALL);
        if (!clipIntersection)
        {
            // There are some vertices inside the screen
            if (pv->dwClipUnion == 0)
                DrawPrim(pv);
            else
                ret = ProcessClippedPointSprites(pv);
        }
    }
    else
    {
        ret = pv->pGeometryFuncs->ProcessPrimitive(pv);
    }
    if (ret != D3D_OK)
    {
        SetWithinPrimitive(FALSE);
        m_pCurrentTLStream->Unlock();
        D3D_THROW(ret, "Error in PSGP");
    }
    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
    UpdateClipStatus(pDevice);
}
//-----------------------------------------------------------------------------
// Processes non-indexed primitives with transformed vertices with clipping
//
// Only transformed vertices generated by ProcessVertices call are allowed here
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessPrimitiveT"

void
CD3DDDIDX8::ProcessPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW);
    // Clipping must be enabled when we are here
    DXGASSERT((pv->dwDeviceFlags & D3DDEV_DONOTCLIP) == 0);

    BOOL bNoClipping = FALSE;

    pv->dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;

    // We need to do special processing for point sprites - they should not be
    // clipped as points without size.
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_POINTSIZEPRESENT &&
        pv->primType == D3DPT_POINTLIST)
    {
        // This function is called only if a device supports point sprites.
        // Otherwise DrawPoints() function should be called.
        DXGASSERT((pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION) == 0);

        PrepareForClipping(pv, StartVertex);

        if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
        {
            // Set emulation flag, because we want to compute clipping code as
            // for point sprites
            pv->dwDeviceFlags |= D3DDEV_DOPOINTSPRITEEMULATION;
            // Compute clip codes, because there was no ProcessVertices
            DWORD clip_intersect = D3DFE_GenClipFlags(pv);
            UpdateClipStatus(static_cast<CD3DHal*>(m_pDevice));
            pv->dwDeviceFlags &= ~D3DDEV_DOPOINTSPRITEEMULATION;
            if (clip_intersect)
            {
                return;
            }
        }
        // There are some vertices inside the screen. We need to do clipping if
        // a result of ProcessVertices is used as input (clip union is unknown)
        // or clipping is needed based on clip union and guard band flags.
        if (pv->dwDeviceFlags & D3DDEV_VBPROCVER || CheckIfNeedClipping(pv))
        {
            // Set emulation flag, because clipped points should be expanded,
            // not regected. We will clip point sprites by viewport during
            // the expansion.
            pv->dwDeviceFlags |= D3DDEV_DOPOINTSPRITEEMULATION;

            // This will prevent computing clip codes second time.
            pv->dwDeviceFlags |= D3DDEV_VBPROCVER | D3DDEV_DONOTCOMPUTECLIPCODES;

            // Now we can call a function which will take care of point sprite
            // expansion, clipping, culling mode etc.
            ProcessPointSprites(pv, StartVertex);

            pv->dwDeviceFlags &= ~(D3DDEV_DOPOINTSPRITEEMULATION |
                                   D3DDEV_VBPROCVER |
                                   D3DDEV_DONOTCOMPUTECLIPCODES);
            return;
        }
        // We are here when all point centres are inside guard band. We can 
        // draw them as points without clipping, because device supports point
        // sprites.
        bNoClipping = TRUE;
    }

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        DXGASSERT(StartVertex == 0);
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, m_pDevice->m_pStream[0].m_pData, VertexPoolSize);
    }
    else
        StartPrimVB(pv, &m_pDevice->m_pStream[0], StartVertex);

    if (bNoClipping)
    {
        DrawPrim(pv);
        goto l_exit;
    }

    PrepareForClipping(pv, StartVertex);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    pv->dwVIDOut = pv->dwVIDIn;
    pv->dwIndexOffset = 0;
    pv->lpvOut = pv->position.lpvData;

    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    // When a triangle strip is clipped, we draw indexed primitives
    // sometimes.
    m_BaseVertexIndex = 0;
    HRESULT ret = pDevice->GeometryFuncsGuaranteed->DoDrawPrimitive(pv);
    if (ret != D3D_OK)
        throw ret;
l_exit:
    pv->dwFlags &= ~D3DPV_TLVCLIP;
    SetWithinPrimitive(FALSE);
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        m_pCurrentTLStream->Unlock();
    }
    else
    {
        // If DDI vertex stream has been set to the internal stream during 
        // clipping, we need to restore the original stream
        if (m_pDDIStream[0].m_pBuf != m_pDevice->m_pStream[0].m_pVB)
        {
            m_pDevice->m_dwStreamDirty |= 1;
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
    }
    pv->dwFlags &= ~D3DPV_TLVCLIP;
}
//-----------------------------------------------------------------------------
// Processes indexed primitives with untransformed vertices and without
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessIndexedPrimitive"

void
CD3DDDIDX8::ProcessIndexedPrimitive(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, TRUE);

    HRESULT ret = pv->pGeometryFuncs->ProcessVertices(pv);
    if (ret != D3D_OK)
    {
        SetWithinPrimitive(FALSE);
        m_pCurrentTLStream->Unlock();
        D3D_THROW(ret, "Error in PSGP");
    }

    if (pDevice->m_pIndexStream->m_pVBI)
        StartIndexPrimVB(pDevice->m_pIndexStream, m_StartIndex,
                         pv->dwIndexSize);
    else
        m_pCurrentIndexStream = m_pIndexStream;
    // Let the driver map indices to be relative to the start of
    // the processed vertices
    m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase() -
                          m_MinVertexIndex * pv->dwOutputSize;
    DrawIndexPrim(pv);
    m_pCurrentTLStream->SkipVertices(pv->dwNumVertices);
    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
}


//-----------------------------------------------------------------------------
// Processes indexed primitives with untransformed vertices and with
// clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessIndexedPrimitiveC"

void
CD3DDDIDX8::ProcessIndexedPrimitiveC(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    // Update lighting and related flags
    if (pDevice->dwFEFlags & D3DFE_FRONTEND_DIRTY)
        DoUpdateState(pDevice);

    pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                     m_StartIndex * pDevice->m_pIndexStream->m_dwStride);

    PrepareForClipping(pv, 0);

    pv->lpvOut = StartPrimTL(pv, pv->dwNumVertices * pv->dwOutputSize, FALSE);
    m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase() -
                          m_MinVertexIndex * pv->dwOutputSize;

    pv->dwIndexOffset = m_MinVertexIndex;   // Needed for clipping
    m_pCurrentIndexStream = m_pIndexStream;

    this->dwDP2Flags &= ~D3DDDI_INDEXEDPRIMDRAWN;
    m_pCurrentTLStream->AddVertices(pv->dwNumVertices);
    DWORD NumVertices = pv->dwNumVertices;

    HRESULT ret = pv->pGeometryFuncs->ProcessIndexedPrimitive(pv);

    if (this->dwDP2Flags & D3DDDI_INDEXEDPRIMDRAWN)
        m_pCurrentTLStream->MovePrimitiveBase(NumVertices);
    else
        m_pCurrentTLStream->SubVertices(NumVertices);

    SetWithinPrimitive(FALSE);
    m_pCurrentTLStream->Unlock();
    UpdateClipStatus(pDevice);

    if (ret != D3D_OK)
    {
        D3D_THROW(ret, "Error in PSGP");
    }
}
//-----------------------------------------------------------------------------
// Processes indexed primitives with transformed vertices and with clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ProcessIndexedPrimitiveT"

void
CD3DDDIDX8::ProcessIndexedPrimitiveT(D3DFE_PROCESSVERTICES* pv, UINT StartVertex)
{
    DXGASSERT((pv->dwVIDIn & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW);
    // Clipping must be enabled when we are here
    DXGASSERT((pv->dwDeviceFlags & D3DDEV_DONOTCLIP) == 0);

    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);

    pv->dwOutputSize = m_pDevice->m_pStream[0].m_dwStride;

    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        // We copy user vertices, starting from MinVertexIndex, to the internal
        // TL buffer and do the clipping. Vertex base changes in the process.

        // m_NumVertices has been computed as MinVertexIndex + NumVertices, so 
        // it needs to be adjusted, because vertex base has benn changed
        m_NumVertices -= m_MinVertexIndex;
        pv->dwNumVertices = m_NumVertices;
        // Copy vertices to the TL buffer
        UINT VertexPoolSize = pv->dwOutputSize * pv->dwNumVertices;
        pv->lpvOut = (BYTE*)StartPrimTL(pv, VertexPoolSize, FALSE);
        pv->position.lpvData = pv->lpvOut;
        memcpy(pv->lpvOut, 
               m_pDevice->m_pStream[0].m_pData + m_MinVertexIndex * pv->dwOutputSize, 
               VertexPoolSize);
        // We need to adjust m_BaseVertexIndex, bacause we do not want to 
        // re-compute indices for the new vertex base
        m_BaseVertexIndex = m_pCurrentTLStream->GetPrimitiveBase() - 
                            m_MinVertexIndex * pv->dwOutputSize;
        m_pCurrentTLStream->AddVertices(pv->dwNumVertices);        

        // During clipping we need to adjust indices by m_MinVertexIndex
        pv->dwIndexOffset = m_MinVertexIndex;

        pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data());
    }
    else
    {
        StartPrimVB(pv, &m_pDevice->m_pStream[0], StartVertex);
        m_BaseVertexIndex = pDevice->m_pIndexStream->m_dwBaseIndex *
                            pv->dwOutputSize;
        pv->dwIndexOffset = m_MinVertexIndex;   // For clipping
        pv->lpwIndices = (WORD*)(pDevice->m_pIndexStream->Data() +
                         m_StartIndex * pDevice->m_pIndexStream->m_dwStride);
    }

    PrepareForClipping(pv, StartVertex);
    if (!(pv->dwDeviceFlags & D3DDEV_VBPROCVER))
    {
        pv->dwFlags |= D3DPV_TLVCLIP;
        // Compute clip codes, because there was no ProcessVertices
        DWORD clip_intersect = D3DFE_GenClipFlags(pv);
        UpdateClipStatus(pDevice);
        if (clip_intersect)
            goto l_exit;
    }
    pv->dwVIDOut = pv->dwVIDIn;
    pv->lpvOut = pv->position.lpvData;
    m_pCurrentIndexStream = m_pIndexStream;

    HRESULT ret;
    ret = pDevice->GeometryFuncsGuaranteed->DoDrawIndexedPrimitive(pv);
    if (ret != D3D_OK)
        throw ret;
l_exit:
    SetWithinPrimitive(FALSE);
    if (m_pDevice->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE)
    {
        m_pCurrentTLStream->Unlock();
        m_pCurrentTLStream->MovePrimitiveBase(pv->dwNumVertices);        
    }
    else
    {
        // If DDI vertex stream has been set to the internal stream during 
        // clipping, we need to restore the original stream
        if (m_pDDIStream[0].m_pBuf != m_pDevice->m_pStream[0].m_pVB)
        {
            m_pDevice->m_dwStreamDirty |= 1;
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
        // If DDI index stream has been set to the internal stream during 
        // clipping, we need to restore the original stream
        if (m_pDDIStream[__NUMSTREAMS].m_pBuf != m_pDevice->m_pIndexStream->m_pVBI)
        {
            m_pDevice->m_dwStreamDirty |= (1 << __NUMSTREAMS);
            m_pDevice->m_dwRuntimeFlags |= D3DRT_NEED_VB_UPDATE;  // Need to call UpdateDirtyStreams()
        }
    }
    pv->dwFlags &= ~D3DPV_TLVCLIP;
}
//-----------------------------------------------------------------------------
#if DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::ValidateCommand"

void CD3DDDIDX8::ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(m_pDevice);
    D3DFE_PROCESSVERTICES* pv = static_cast<CD3DHal*>(m_pDevice)->m_pv;

    if (!(pDevice->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
        return;

    DWORD dwVertexSize = pv->dwOutputSize;
    BOOL bNeedUnlock = FALSE;
    UINT  count;
    BYTE* pVertices;
    CTLStream* pStream = (CTLStream*)m_pDDIStream[0].m_pStream;
    if (pStream->m_pVB)
        if (pStream->m_pVB->IsLocked())
            pVertices = pStream->m_pData;
        else
        {
            pVertices = pStream->Lock(pStream->m_pVB->GetBufferDesc()->Size, this);
            bNeedUnlock = TRUE;
        }
    else
        // User memory vertices
        pVertices = (LPBYTE)(dp2data.lpVertices);

    switch (lpCmd->bCommand)
    {
    case D3DDP2OP_DRAWPRIMITIVE:
        {
            LPD3DHAL_DP2DRAWPRIMITIVE pData = (LPD3DHAL_DP2DRAWPRIMITIVE)(lpCmd+1);
            count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
            pVertices += pData->VStart * dwVertexSize;
            for (WORD i = 0; i < count; i++)
            {
                ValidateVertex((LPDWORD)(pVertices + i * dwVertexSize));
            }
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE2:
        {
            LPD3DHAL_DP2DRAWPRIMITIVE2 pData = (LPD3DHAL_DP2DRAWPRIMITIVE2)(lpCmd+1);
            count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
            pVertices += pData->FirstVertexOffset;
            for (WORD i = 0; i < count; i++)
            {
                ValidateVertex((LPDWORD)(pVertices + i * dwVertexSize));
            }
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
        {
            BYTE* pIndices;
            BOOL bNeedUnlock = FALSE;
            CTLIndexStream* pStream = (CTLIndexStream*)m_pDDIStream[__NUMSTREAMS].m_pStream;
            if (pStream->m_pVBI->IsLocked())
                pIndices = pStream->m_pData;
            else
            {
                pIndices = pStream->Lock(pStream->m_pVBI->GetBufferDesc()->Size, this);
                bNeedUnlock = TRUE;
            }

            UINT MaxIndex;
            UINT MinIndex;
            if (lpCmd->bCommand == D3DDP2OP_DRAWINDEXEDPRIMITIVE)
            {
                LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pData =
                    (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(lpCmd+1);
                pIndices += pData->StartIndex * pv->dwIndexSize;
                pVertices += pData->BaseVertexIndex * dwVertexSize;
                MaxIndex = pData->MinIndex + pData->NumVertices - 1;
                count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
                MinIndex = pData->MinIndex;
            }
            else
            {
                LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pData =
                    (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)(lpCmd+1);
                pIndices += pData->StartIndexOffset;
                pVertices += pData->BaseVertexOffset;
                MaxIndex = pData->MinIndex + pData->NumVertices - 1;
                count = GETVERTEXCOUNT(pData->primType, pData->PrimitiveCount);
                MinIndex = pData->MinIndex;
            }
            for (WORD i = 0; i < count; i++)
            {
                DWORD index;
                if (pv->dwIndexSize == 4)
                    index = *(DWORD*)(pIndices + i * 4);
                else
                    index = *(WORD*)(pIndices + i * 2);
                if (index  < MinIndex || index  > MaxIndex)
                {
                    D3D_THROW_FAIL("Invalid index in the index stream");
                }
                BYTE* pVertex = &pVertices[index];
                if (pVertex < pVertices ||
                    pVertex > pVertices + dwVertexSize * MaxIndex)
                {
                    D3D_THROW_FAIL("Bad vertex address");
                }
                ValidateVertex((LPDWORD)(pVertices + index * dwVertexSize));
            }
            if (bNeedUnlock)
                pStream->Unlock();
        }
        break;
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
        if (bNeedUnlock)
            pStream->Unlock();
        CD3DDDIDX6::ValidateCommand(lpCmd);
        return;
    case D3DDP2OP_DRAWRECTPATCH:
    case D3DDP2OP_DRAWTRIPATCH:
        return;

    default:
        D3D_THROW_FAIL("Invalid DX8 drawing command in DP2 stream");
    }
    if (bNeedUnlock)
        pStream->Unlock();
}
#endif

//-----------------------------------------------------------------------------
// Volume Blt
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::VolBlt"

void
CD3DDDIDX8::VolBlt(CBaseTexture *lpDst, CBaseTexture* lpSrc, DWORD dwDestX,
                   DWORD dwDestY, DWORD dwDestZ, D3DBOX *pBox)
{
    if (bDP2CurrCmdOP == D3DDP2OP_VOLUMEBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2VOLUMEBLT) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2VOLUMEBLT lpVolBlt =
                (LPD3DHAL_DP2VOLUMEBLT)((LPBYTE)lpvDP2Commands +
                                        dwDP2CommandLength +
                                        dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpVolBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
                lpDst->DriverAccessibleDrawPrimHandle();
            lpVolBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
            lpVolBlt->dwDestX            = dwDestX;
            lpVolBlt->dwDestY            = dwDestY;
            lpVolBlt->dwDestZ            = dwDestZ;
            lpVolBlt->srcBox             = *pBox;
            lpVolBlt->dwFlags            = 0;
            dwDP2CommandLength += sizeof(D3DHAL_DP2VOLUMEBLT);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

            // For the source, we want to call BatchBase since
            // we want to batch the backing (or sysmem) texture
            // rather than the promoted one.
            lpSrc->BatchBase();
            if(lpDst != 0)
            {
                lpDst->Batch();
            }
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2VOLUMEBLT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_VOLUMEBLT;
    bDP2CurrCmdOP = D3DDP2OP_VOLUMEBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2VOLUMEBLT lpVolBlt =
        (LPD3DHAL_DP2VOLUMEBLT)(lpDP2CurrCommand + 1);
    lpVolBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
        lpDst->DriverAccessibleDrawPrimHandle();
    lpVolBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
    lpVolBlt->dwDestX           = dwDestX;
    lpVolBlt->dwDestY           = dwDestY;
    lpVolBlt->dwDestZ           = dwDestZ;
    lpVolBlt->srcBox            = *pBox;
    lpVolBlt->dwFlags           = 0;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2VOLUMEBLT);
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    lpSrc->BatchBase();
    if(lpDst != 0)
    {
        lpDst->Batch();
    }
}

//-----------------------------------------------------------------------------
// Buffer Blt
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::BufBlt"

void
CD3DDDIDX8::BufBlt(CBuffer *lpDst, CBuffer* lpSrc, DWORD dwOffset,
                   D3DRANGE* pRange)
{
    if (bDP2CurrCmdOP == D3DDP2OP_BUFFERBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2BUFFERBLT) <=
            dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2BUFFERBLT lpBufBlt =
                (LPD3DHAL_DP2BUFFERBLT)((LPBYTE)lpvDP2Commands +
                                        dwDP2CommandLength +
                                        dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpBufBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
                lpDst->DriverAccessibleDrawPrimHandle();
            lpBufBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
            lpBufBlt->dwOffset          = dwOffset;
            lpBufBlt->rSrc              = *pRange;
            lpBufBlt->dwFlags           = 0;
            dwDP2CommandLength += sizeof(D3DHAL_DP2BUFFERBLT);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

            // For the source, we want to call BatchBase since
            // we want to batch the backing (or sysmem) texture
            // rather than the promoted one.
            lpSrc->BatchBase();
            if(lpDst != 0)
            {
                lpDst->Batch();
            }
            return;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2BUFFERBLT) > dwDP2CommandBufSize)
    {
        FlushStates();
    }
    // Add new instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_BUFFERBLT;
    bDP2CurrCmdOP = D3DDP2OP_BUFFERBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2BUFFERBLT lpBufBlt =
        (LPD3DHAL_DP2BUFFERBLT)(lpDP2CurrCommand + 1);
    lpBufBlt->dwDDDestSurface   = lpDst == NULL ? 0 :
        lpDst->DriverAccessibleDrawPrimHandle();
    lpBufBlt->dwDDSrcSurface    = lpSrc->BaseDrawPrimHandle();
    lpBufBlt->dwOffset          = dwOffset;
    lpBufBlt->rSrc              = *pRange;
    lpBufBlt->dwFlags           = 0;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2BUFFERBLT);
    // For the source, we want to call BatchBase since
    // we want to batch the backing (or sysmem) texture
    // rather than the promoted one.
    lpSrc->BatchBase();
    if(lpDst != 0)
    {
        lpDst->Batch();
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DDDIDX8::GetMaxRenderState"

// Note: This is a hack for DX8.1 release. The only renderstates that we added 
// in DX8.1 pertain to the NPATCHES features. At the time of DX8.1 release 
// there were no real drivers besides Reference that could support this feature. 
// We also know that the only can driver that does support the NPATCH feature 
// will support these renderstates (i.e. will be a DX8.1 driver. Hence it is 
// safe to assume that if any driver supports the D3DDEVCAPS_NPATCHES cap, then 
// it is a DX8.1 driver and understands the extra renderstates that were added 
// in DX8.1.
D3DRENDERSTATETYPE CD3DDDIDX8::GetMaxRenderState() 
{   
    const D3DCAPS8* pCaps = m_pDevice->GetD3DCaps();
    if (pCaps->DevCaps & D3DDEVCAPS_NPATCHES)
    {
        return D3D_MAXRENDERSTATES;
    }
    else
    {
        return D3DRS_POSITIONORDER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\devstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devstate.c
 *  Content:    device state management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "pvvid.h"
#include "ddibase.h"

//---------------------------------------------------------------------
#if DBG
void CPackedBitArray::CheckIndex(UINT index)
{
    if (index >= m_size)
    {
        D3D_THROW_FAIL("Invalid index");
    }
}
#endif // DBG
//---------------------------------------------------------------------
inline void UpdateFogFactor(D3DFE_PROCESSVERTICES* lpDevI)
{
    if (lpDevI->lighting.fog_end == lpDevI->lighting.fog_start)
        lpDevI->lighting.fog_factor = D3DVAL(0.0);
    else
        lpDevI->lighting.fog_factor = D3DVAL(255) /
                                     (lpDevI->lighting.fog_end - lpDevI->lighting.fog_start);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetRenderState"

HRESULT D3DAPI
CD3DHal::SetRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type. SetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            if(this->CheckForRetiredRenderState(dwState))
            {
                m_pStateSets->InsertRenderState(dwState, value, CanHandleRenderState(dwState));
            }
            else
            {
                D3D_ERR("Invalid renderstate %d. SetRenderState failed.", dwState);
                return D3DERR_INVALIDCALL;
            }
        }
        else
            this->SetRenderStateFast(dwState, value);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("SetRenderState failed.");
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetRenderStateFast"

HRESULT D3DAPI CD3DHal::SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
    // API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type. SetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif

    if (!rsVec.IsBitSet(dwState))
    {   // Fast path. We do not need any processing done in UpdateInternalState
        // other than updating rstates array
        if ( (this->rstates[dwState] == value)
#if DBG
             && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
           )
        {
            D3D_WARN(4,"Ignoring redundant SetRenderState - %d", dwState);
            return D3D_OK;
        }
        this->rstates[dwState] = value;
        // Output state to the device driver
        try
        {
           m_pDDI->SetRenderState(dwState, value);
        }
        catch(HRESULT ret)
        {
            D3D_ERR("SetRenderState failed.");
            return ret;
        }
    }
    else
    {
        try
        {
            // Wrap modes could be re-programmed. We need to restore them before
            // filtering redundant values
            if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
            if ( (this->rstates[dwState] == value)
#if DBG
                 && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
               )
            {
                D3D_WARN(4,"Ignoring redundant SetRenderState - %d", dwState);
                return D3D_OK;
            }

            this->UpdateInternalState(dwState, value);
            // Vertex processing only render states will be passed to the
            // driver when we switch to the hardware vertex processing mode
            if ((!(rsVertexProcessingOnly.IsBitSet(dwState) &&
                   m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)))
            {
                if (CanHandleRenderState(dwState))
                {
#if DBG
                    if(!CheckForRetiredRenderState(dwState))
                    {
                        D3D_ERR("Invalid (old) renderstate %d. SetRenderState failed.", dwState);
                        return D3DERR_INVALIDCALL;
                    }
#endif // DBG
                    m_pDDI->SetRenderState(dwState, value);
                }
            }
        }
        catch(HRESULT ret)
        {
            D3D_ERR("SetRenderState failed.");
            return ret;
        }
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetRenderStateInternal"

void
CD3DHal::SetRenderStateInternal(D3DRENDERSTATETYPE dwState, DWORD dwValue)
{
    if (this->rstates[dwState] == dwValue)
    {
        D3D_WARN(4,"Ignoring redundant SetRenderState - %d", dwState);
        return;
    }
    this->UpdateInternalState(dwState, dwValue);
    if (CanHandleRenderState(dwState))
        m_pDDI->SetRenderState(dwState, dwValue);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderState"

HRESULT D3DAPI
CD3DHal::GetRenderState(D3DRENDERSTATETYPE dwState, LPDWORD lpdwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0)
    {
        D3D_ERR( "Invalid render state value. GetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif

    if (!VALID_WRITEPTR(lpdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. GetRenderState failed." );
        return D3DERR_INVALIDCALL;
    }

    if(!CheckForRetiredRenderState(dwState))
    {
        D3D_ERR("invalid renderstate %d. GetRenderState failed.", dwState);
        return D3DERR_INVALIDCALL;
    }

    // WRAP render states could be re-mapped so we have to return the original
    // value
    if (dwState >= D3DRENDERSTATE_WRAP0 && dwState <= D3DRENDERSTATE_WRAP7)
    {
        if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            DWORD dwTexCoordIndex = dwState - D3DRENDERSTATE_WRAP0;
            for (DWORD i=0; i < this->dwNumTextureStagesToRemap; i++)
            {
                LPD3DFE_TEXTURESTAGE pStage = &this->textureStageToRemap[i];
                if (pStage->dwInpCoordIndex == dwTexCoordIndex)
                {
                    if (pStage->dwInpCoordIndex != pStage->dwOutCoordIndex)
                    {
                        *lpdwValue = pStage->dwOrgWrapMode;
                        return D3D_OK;
                    }
                }
            }
        }
    }
    *lpdwValue = this->rstates[dwState];
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetTextureStageState"

HRESULT D3DAPI
CD3DHal::SetTextureStageState(DWORD dwStage,
                              D3DTEXTURESTAGESTATETYPE dwState,
                              DWORD dwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR( "Invalid texture stage or state index. SetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif //DBG
    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTextureStageState(dwStage, dwState, dwValue);
            return D3D_OK;
        }
        return this->SetTextureStageStateFast(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("SetTextureStageState failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetTextureStageStateFast"

HRESULT D3DAPI
CD3DHal::SetTextureStageStateFast(DWORD dwStage,
                                  D3DTEXTURESTAGESTATETYPE dwState,
                                  DWORD dwValue)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
    // API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR( "Invalid texture stage or state index. SetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif //DBG

    // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
    if (NeedInternalTSSUpdate(dwState))
    {
        // Texture stages could be re-programmed. We need to restore them before
        // filtering  redundant values
        if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            RestoreTextureStages(this);
            ForceFVFRecompute();
        }
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState. Stage: %d, State: %d", dwStage, dwState);
            return D3D_OK;
        }
        if(this->UpdateInternalTextureStageState(dwStage, dwState, &dwValue))
            return D3D_OK;
    }
    else
    {
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState. Stage: %d, State: %d", dwStage, dwState);
            return D3D_OK;
        }
        tsstates[dwStage][dwState] = dwValue;
    }

    if (dwStage >= m_dwMaxTextureBlendStages)
        return D3D_OK;

    try
    {
        m_pDDI->SetTSS(dwStage, dwState, dwValue);
    }
    catch (HRESULT ret)
    {
        D3D_ERR("SetTextureStageState failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTextureStageState"

HRESULT D3DAPI
CD3DHal::GetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      LPDWORD pdwValue)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if ( (dwStage >= D3DHAL_TSS_MAXSTAGES) ||
         (dwState == 0) ||
         (dwState >= D3DTSS_MAX) ||
         (dwState == 12) )  // D3DTSS_ADDRESS no longer valid
    {
        D3D_ERR( "Invalid texture stage or state index. GetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }
#endif  //DBG

    if (!VALID_WRITEPTR(pdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. GetTextureStageState failed." );
        return D3DERR_INVALIDCALL;
    }

    // If texture indices were re-mapped we have to find and return the original value
    if (dwState == D3DTSS_TEXCOORDINDEX && m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
        ForceFVFRecompute();
    }
    // Don't bother to check for DX6 support, just return the
    // cached value.
    *pdwValue = tsstates[dwStage][dwState];
    return D3D_OK;
}
#ifdef FAST_PATH
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetVertexShaderFast"

HRESULT D3DAPI
CD3DHal::SetVertexShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckVertexShaderHandle(dwHandle);
#endif
        DXGASSERT((m_dwRuntimeFlags & (D3DRT_RECORDSTATEMODE | D3DRT_RSSOFTWAREPROCESSING)) == 0 &&
                  (BehaviorFlags() & D3DCREATE_MULTITHREADED) == 0);

        // We need to set m_pCurrentShader becausu we do NPatch emulation in 
        // hardware vertex processing mode

        static_cast<CD3DHal*>(this)->m_pCurrentShader = NULL;
        CVConstantData* pConst = NULL;
#if DBG
        m_pv->dwDeviceFlags &= ~D3DDEV_VERTEXSHADERS;
#endif
        if (!D3DVSD_ISLEGACY(dwHandle))
        {
            static_cast<CD3DHal*>(this)->m_pCurrentShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObjectFast(dwHandle);
            pConst = pShader->m_Declaration.m_pConstants;
#ifdef DBG
            if(!(pShader->m_dwFlags & CVShader::FIXEDFUNCTION))
            {
                // Programmable pipeline is used
                m_pv->dwDeviceFlags |= D3DDEV_VERTEXSHADERS;
            }
#endif
        }

        // We can return earlier when we do not need to update constants
        if (pConst == NULL)
        {
            if (dwHandle == m_dwCurrentShaderHandle)
                return S_OK;
        }
        else
            // Update our copy of constants for Get()
            while (pConst)
            {
                HRESULT hr;
                hr = m_pv->pGeometryFuncs->LoadShaderConstants(pConst->m_dwAddress,
                                                               pConst->m_dwCount,
                                                               pConst->m_pData);
                if (FAILED(hr))
                {
                    D3D_THROW_FAIL("Failed to load vertex shader constants");
                }
                pConst =  (CVConstantData*)pConst->m_pNext;
            }

        m_dwCurrentShaderHandle = dwHandle;
        if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
        {
            m_pDDI->SetVertexShaderHW(dwHandle);
        }
        if (!IS_DX8HAL_DEVICE(this))
        {
            PickDrawPrimFn();
        }
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetVertexShader failed.");
        ClearVertexShaderHandle();
        return hr;
    }
   return S_OK;
}
#endif // FAST_PATH
//----------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetTransformI"

void CD3DHal::SetTransformI(D3DTRANSFORMSTATETYPE state,
                            CONST D3DMATRIX* lpMat)
{
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        *(LPD3DMATRIX)&m_pv->world[index] = *lpMat;
        if (index == 0)
            this->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
    }
    else
    switch (state)
    {
    case D3DTS_VIEW       :
        *(D3DMATRIX*)&m_pv->view = *lpMat;
        this->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_PROJECTION :
        *(D3DMATRIX*)&this->transform.proj = *lpMat;
        this->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        {
            m_pv->dwDeviceFlags |= D3DDEV_TEXTRANSFORMDIRTY;
            DWORD dwIndex = state - D3DTS_TEXTURE0;
            *(D3DMATRIX*)&m_pv->mTexture[dwIndex] = *lpMat;
            break;
        }
    }
    m_pv->MatrixStateCount++;
    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            this->pMatrixDirtyForDDI->SetBit(state);
        else
            m_pDDI->SetTransform(state, lpMat);
        // W range should always be updated
        if (state == D3DTS_PROJECTION)
            m_pDDI->UpdateWInfo(lpMat);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetTransform"

HRESULT D3DAPI
CD3DHal::GetTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    HRESULT ret = D3D_OK;
#if DBG
    if (!VALID_WRITEPTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR( "Invalid matrix pointer. GetTransform failed." );
        return D3DERR_INVALIDCALL;
    }
#endif
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        *lpMat = *(LPD3DMATRIX)&m_pv->world[index];
    }
    else
    switch (state) {
    case D3DTS_VIEW :
        *lpMat = *(LPD3DMATRIX)&m_pv->view._11;
        break;
    case D3DTS_PROJECTION :
        *lpMat = *(LPD3DMATRIX)&this->transform.proj._11;
        break;
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        *lpMat = *(LPD3DMATRIX)&m_pv->mTexture[state-D3DTS_TEXTURE0]._11;
        break;
    default :
        D3D_ERR( "Invalid state value passed to GetTransform. GetTransform failed." );
        ret = D3DERR_INVALIDCALL; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev2_GetTransform()

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::UpdateDriverStates"

void
CD3DHal::UpdateDriverStates()
{
    // note we can't do a loop from 1 to D3DHAL_MAX_RSTATES(256) as some of
    // rstates are not valid states, passin them down to drivers(like
    // voodoo2 DX6 driver) will crash.
    static D3DRENDERSTATETYPE dx6states[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_ZVISIBLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STIPPLEENABLE,
        D3DRENDERSTATE_MONOENABLE,
        D3DRENDERSTATE_ROP2,
        D3DRENDERSTATE_PLANEMASK,
        D3DRENDERSTATE_WRAPU,
        D3DRENDERSTATE_WRAPV,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_SUBPIXEL,
        D3DRENDERSTATE_SUBPIXELX,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_STIPPLEPATTERN00,
        D3DRENDERSTATE_STIPPLEPATTERN01,
        D3DRENDERSTATE_STIPPLEPATTERN02,
        D3DRENDERSTATE_STIPPLEPATTERN03,
        D3DRENDERSTATE_STIPPLEPATTERN04,
        D3DRENDERSTATE_STIPPLEPATTERN05,
        D3DRENDERSTATE_STIPPLEPATTERN06,
        D3DRENDERSTATE_STIPPLEPATTERN07,
        D3DRENDERSTATE_STIPPLEPATTERN08,
        D3DRENDERSTATE_STIPPLEPATTERN09,
        D3DRENDERSTATE_STIPPLEPATTERN10,
        D3DRENDERSTATE_STIPPLEPATTERN11,
        D3DRENDERSTATE_STIPPLEPATTERN12,
        D3DRENDERSTATE_STIPPLEPATTERN13,
        D3DRENDERSTATE_STIPPLEPATTERN14,
        D3DRENDERSTATE_STIPPLEPATTERN15,
        D3DRENDERSTATE_STIPPLEPATTERN16,
        D3DRENDERSTATE_STIPPLEPATTERN17,
        D3DRENDERSTATE_STIPPLEPATTERN18,
        D3DRENDERSTATE_STIPPLEPATTERN19,
        D3DRENDERSTATE_STIPPLEPATTERN20,
        D3DRENDERSTATE_STIPPLEPATTERN21,
        D3DRENDERSTATE_STIPPLEPATTERN22,
        D3DRENDERSTATE_STIPPLEPATTERN23,
        D3DRENDERSTATE_STIPPLEPATTERN24,
        D3DRENDERSTATE_STIPPLEPATTERN25,
        D3DRENDERSTATE_STIPPLEPATTERN26,
        D3DRENDERSTATE_STIPPLEPATTERN27,
        D3DRENDERSTATE_STIPPLEPATTERN28,
        D3DRENDERSTATE_STIPPLEPATTERN29,
        D3DRENDERSTATE_STIPPLEPATTERN30,
        D3DRENDERSTATE_STIPPLEPATTERN31,
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7
    };

    HRESULT ret;
    for (DWORD i=0; i<sizeof(dx6states)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        m_pDDI->SetRenderState( dx6states[i], rstates[dx6states[i]] );
    }

    for( i = 0; i < m_dwMaxTextureBlendStages; i++ )
    {
        for(  DWORD j = D3DTSS_COLOROP ; j < D3DTSS_TEXTURETRANSFORMFLAGS;
              ++j )
        {
            m_pDDI->SetTSS( i, (D3DTEXTURESTAGESTATETYPE)j,
                            this->tsstates[i][j] );
        }
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetClipStatus"

HRESULT D3DAPI CD3DHal::SetClipStatus(CONST D3DCLIPSTATUS8* status)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (!VALID_PTR(status, sizeof(D3DCLIPSTATUS8)) )
    {
        D3D_ERR( "Invalid status pointer. SetClipStatus failed." );
        return D3DERR_INVALIDCALL;
    }

#endif
    m_ClipStatus = * status;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetClipStatus"

HRESULT D3DAPI CD3DHal::GetClipStatus(D3DCLIPSTATUS8* status)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (! VALID_WRITEPTR(status, sizeof(D3DCLIPSTATUS8)) )
    {
        D3D_ERR( "Invalid status pointer. GetClipStatus failed." );
        return D3DERR_INVALIDCALL;
    }
#endif
    *status = m_ClipStatus;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SwitchVertexProcessingMode"

void CD3DHal::SwitchVertexProcessingMode(DWORD SoftwareMode)
{
    m_pDDI->FlushStates(FALSE);	
    // Invalidate all streams
    // What if a vertex buffer is batched?
    CVStream* pStream = m_pStream;
    for (UINT i=0; i < __NUMSTREAMS; i++)
    {
        pStream->m_pData = NULL;
        if (pStream->m_pVB)
        {
            m_pDDI->VBReleased(pStream->m_pVB);
            pStream->m_pVB->DecrementUseCount();
            pStream->m_pVB = NULL;
        }
        pStream++;
    }
    m_pIndexStream->m_pData = NULL;
    if (m_pIndexStream->m_pVBI)
    {
        m_pDDI->VBIReleased(m_pIndexStream->m_pVBI);
        m_pIndexStream->m_pVBI->DecrementUseCount();
        m_pIndexStream->m_pVBI = NULL;
    }
    ClearVertexShaderHandle();
    m_pCurrentShader = NULL;
    // Setup capabilities
    if (SoftwareMode)
    {
        m_MaxVertexShaderConst = D3DVS_CONSTREG_MAX_V1_1;
        m_dwRuntimeFlags |= D3DRT_RSSOFTWAREPROCESSING;
        m_dwNumStreams = __NUMSTREAMS;
        m_dwMaxUserClipPlanes = __MAXUSERCLIPPLANES;
#ifdef FAST_PATH
        FastPathSetVertexShaderSlow();
        FastPathSetStreamSourceSlow();
        FastPathSetIndicesSlow();
#endif // FAST_PATH
    }
    else
    {
        // We are switching from the software to the hardware mode
        m_dwRuntimeFlags &= ~D3DRT_RSSOFTWAREPROCESSING;
#ifdef FAST_PATH
        FastPathSetVertexShaderFast();
        FastPathSetStreamSourceFast();    
        FastPathSetIndicesFast();    
#endif // FAST_PATH

        // Update caps from the hardware
        m_dwNumStreams = max(1, GetD3DCaps()->MaxStreams);
        m_dwMaxUserClipPlanes = GetD3DCaps()->MaxUserClipPlanes;

        // Update vertex processing state in the driver. We did not pass the
        // state when it was changed for performance reasons
        for (UINT i=0; i < sizeof(rsVertexProcessingList) / sizeof(D3DRENDERSTATETYPE); ++i)
        {
            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)rsVertexProcessingList[i];
            if (CanHandleRenderState(dwState))
                m_pDDI->SetRenderState(dwState, this->rstates[dwState]);
        }

        // Update clip planes
        for (i=0; i < m_dwMaxUserClipPlanes; i++)
            m_pDDI->SetClipPlane(i, (float*)&this->transform.userClipPlane[i]);

        // Update lights
        const UINT size = m_pLightArray->GetSize();
        for (i = 0; i < size; i++)
        {
            DIRECT3DLIGHTI* pLight = static_cast<DIRECT3DLIGHTI*>
                                     ((*m_pLightArray)[i].m_pObj);
            if (pLight)
            {
                if (pLight->DirtyForDDI())
                {
                    m_pDDI->SetLight(i, &pLight->m_Light);
                    pLight->ClearDirtyForDDI();
                }
            }
        }
        // Update Enable/Disable light state. This is done separately to combine
        // multiple calls to the driver into one call.
        for (i = 0; i < size; i++)
        {
            DIRECT3DLIGHTI* pLight = static_cast<DIRECT3DLIGHTI*>
                                     ((*m_pLightArray)[i].m_pObj);
            if (pLight)
            {
                if (pLight->EnableDirtyForDDI())
                {
                    m_pDDI->LightEnable(i, pLight->Enabled());
                    pLight->ClearEnableDirtyForDDI();
                }
            }
        }

        // Update transformation matrices
        if (this->pMatrixDirtyForDDI->IsBitSet(D3DTS_VIEW))
        {
            m_pDDI->SetTransform(D3DTS_VIEW, &m_pv->view);
            this->pMatrixDirtyForDDI->ClearBit(D3DTS_VIEW);
        }
        if (this->pMatrixDirtyForDDI->IsBitSet(D3DTS_PROJECTION))
        {
            m_pDDI->SetTransform(D3DTS_PROJECTION, &this->transform.proj);
            this->pMatrixDirtyForDDI->ClearBit(D3DTS_PROJECTION);
        }
        for (i=D3DTS_TEXTURE0; i <= D3DTS_TEXTURE7; i++)
        {
            if (this->pMatrixDirtyForDDI->IsBitSet(i))
            {
                m_pDDI->SetTransform((D3DTRANSFORMSTATETYPE)i, 
                                     &m_pv->mTexture[i - D3DTS_TEXTURE0]);
                this->pMatrixDirtyForDDI->ClearBit(i);
            }
        }
        for (i=0; i < __MAXWORLDMATRICES; i++)
        {
            UINT index = i + __WORLDMATRIXBASE;
            if (this->pMatrixDirtyForDDI->IsBitSet(index))
            {
                m_pDDI->SetTransform((D3DTRANSFORMSTATETYPE)index, &m_pv->world[i]);
                this->pMatrixDirtyForDDI->ClearBit(index);
            }
        }

        // Update material
        m_pDDI->SetMaterial(&m_pv->lighting.material);

        m_MaxVertexShaderConst = GetD3DCaps()->MaxVertexShaderConst;
        // Update vertex shader constants
        if (m_dwRuntimeFlags & D3DRT_NEED_VSCONST_UPDATE)
        {
            VVM_WORD data[D3DVS_CONSTREG_MAX_V1_1];
            UINT count = min(m_MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
            if (count)
            {
                m_pv->pGeometryFuncs->GetShaderConstants(0, count, &data);
                m_pDDI->SetVertexShaderConstant(0, &data, count);
            }
            m_dwRuntimeFlags &= ~D3DRT_NEED_VSCONST_UPDATE;
        }
    }
    PickDrawPrimFn();
}
//---------------------------------------------------------------------
// This function is called from HALEXE.CPP, from device::SetRenderState and
// from device::SetTexture.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::UpdateInternalState"

void CD3DHal::UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value)
{
    switch (type)
    {
    case D3DRENDERSTATE_LIGHTING:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_LIGHTING;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_LIGHTING;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_FOGENABLE:
        rstates[type] = value;      // set rstates BEFORE calling SetFogFlags
        SetFogFlags();
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_SPECULARENABLE;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_SPECULARENABLE;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            const D3DVALUE SCALE = 1.0f/255.0f;
            m_pv->lighting.ambientSceneScaled.r = D3DVAL(RGBA_GETRED(value));
            m_pv->lighting.ambientSceneScaled.g = D3DVAL(RGBA_GETGREEN(value));
            m_pv->lighting.ambientSceneScaled.b = D3DVAL(RGBA_GETBLUE(value));
            m_pv->lighting.ambientScene.r = m_pv->lighting.ambientSceneScaled.r * SCALE;
            m_pv->lighting.ambientScene.g = m_pv->lighting.ambientSceneScaled.g * SCALE;
            m_pv->lighting.ambientScene.b = m_pv->lighting.ambientSceneScaled.b * SCALE;
            m_pv->lighting.ambient_save  = value;
            this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
            break;
        }
    case D3DRENDERSTATE_RANGEFOGENABLE:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_RANGEBASEDFOG;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_RANGEBASEDFOG;
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        m_pv->lighting.fog_mode = (D3DFOGMODE)value;
        SetFogFlags();
        break;
    case D3DRENDERSTATE_COLORVERTEX:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_COLORVERTEX;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_COLORVERTEX;
        // It is faster to initialize these values here, than setting a dirty
        // bit ang going through the slow UpdateState path
        m_pv->lighting.alpha = (DWORD)m_pv->lighting.materialAlpha;
        m_pv->lighting.alphaSpecular = (DWORD)m_pv->lighting.materialAlphaS;
        break;
    case D3DRENDERSTATE_CLIPPING:
        if (!value)
        {
            m_pv->dwDeviceFlags |= D3DDEV_DONOTCLIP;
            // Clear clip union and intersection flags
            m_pv->dwClipIntersection = 0;
            m_pv->dwClipUnion = 0;
        }
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_DONOTCLIP;
        // Change our internal ProcessPrimitive functions which depend on
        // the clipping state
        m_pDDI->PickProcessPrimitive();
        PickDrawPrimFn();
        break;
    case D3DRENDERSTATE_FOGDENSITY:
        m_pv->lighting.fog_density = *(D3DVALUE*)&value;
        break;
    case D3DRENDERSTATE_FOGSTART:
        m_pv->lighting.fog_start = *(D3DVALUE*)&value;
        UpdateFogFactor(this->m_pv);
        break;
    case D3DRENDERSTATE_FOGEND:
        m_pv->lighting.fog_end = *(D3DVALUE*)&value;
        UpdateFogFactor(this->m_pv);
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_LOCALVIEWER;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_LOCALVIEWER;
        this->dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        if (value)
        {
            if (m_pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                m_pv->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
                this->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
            }
            m_pv->dwDeviceFlags |= D3DDEV_NORMALIZENORMALS;
        }
        else
        {
            m_pv->dwDeviceFlags &= ~D3DDEV_NORMALIZENORMALS;
            if (!(m_pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                this->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX | D3DFE_FRONTEND_DIRTY;
        }
        break;
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
        m_pv->lighting.dwEmissiveSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwEmissiveSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwEmissiveSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
        m_pv->lighting.dwDiffuseSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwDiffuseSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwDiffuseSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
        m_pv->lighting.dwAmbientSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwAmbientSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwAmbientSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for AMBIENTMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
        m_pv->lighting.dwSpecularSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            m_pv->lighting.dwSpecularSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            m_pv->lighting.dwSpecularSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for SPECULARMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_VERTEXBLEND:
        {
#if DBG
            switch (value)
            {
            case D3DVBF_DISABLE:
            case D3DVBF_0WEIGHTS:
            case D3DVBF_1WEIGHTS:
            case D3DVBF_2WEIGHTS:
            case D3DVBF_3WEIGHTS:
            case D3DVBF_TWEENING:
                break;
            default:
                D3D_ERR("Illegal value for D3DRENDERSTATE_VERTEXBLEND");
                goto error_exit;
            }
#endif
            this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY | D3DFE_FRONTEND_DIRTY;
            break;
        }
    case D3DRENDERSTATE_CLIPPLANEENABLE:
        {
            this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
            m_pv->dwMaxUserClipPlanes = 0;
            break;
        }
    case D3DRENDERSTATE_SHADEMODE:
        if (value == D3DSHADE_FLAT)
            m_pv->dwDeviceFlags |= D3DDEV_FLATSHADEMODE;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_FLATSHADEMODE;
        break;
    case D3DRS_SOFTWAREVERTEXPROCESSING:
        // If DDI cannot do transformation and lighting,
        // D3DRT_RSSOFTWAREPROCESSING is always set to TRUE
        if( BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING )
        {
            DDASSERT( m_pDDI->CanDoTL() );
            if (value != this->rstates[type])
                SwitchVertexProcessingMode(value);
        }
        break;
    case D3DRS_POINTSCALEENABLE:
        if (value)
        {
            // We need world-view matrix to scale point sprites
            this->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY |
                               D3DFE_FRONTEND_DIRTY;
        }
        break;
    case D3DRS_POINTSIZE:
        if (*(float*)&value != 1.0f)
            m_dwRuntimeFlags |=  D3DRT_POINTSIZEINRS;
        else
            m_dwRuntimeFlags &= ~D3DRT_POINTSIZEINRS;
        break;

    case D3DRS_POINTSIZE_MAX:
        {
            float MaxPointSize = GetD3DCaps()->MaxPointSize;
            if (MaxPointSize == 0)
                MaxPointSize = __MAX_POINT_SIZE;

            if (*(float*)&value <= MaxPointSize)
                m_pv->PointSizeMax = *(float*)&value;
#if DBG
            else
            {
                D3D_ERR("Max point size is greater than supported by the device");
                goto error_exit;
            }
#endif
        }
        break;
    case D3DRS_INDEXEDVERTEXBLENDENABLE:
        if (value)
            m_pv->dwDeviceFlags |= D3DDEV_INDEXEDVERTEXBLENDENABLE;
        else
            m_pv->dwDeviceFlags &= ~D3DDEV_INDEXEDVERTEXBLENDENABLE;
        ForceFVFRecompute();
        break;
    case D3DRS_PATCHSEGMENTS:
        {
            const D3DCAPS8* pCaps = GetD3DCaps();
            if (!(pCaps->DevCaps & D3DDEVCAPS_NPATCHES) &&
                (pCaps->DevCaps & D3DDEVCAPS_RTPATCHES))
            {
                if (*(float*)&value > 1.0f)
                    m_dwRuntimeFlags |= D3DRT_DONPATCHCONVERSION;
                else
                    m_dwRuntimeFlags &= ~D3DRT_DONPATCHCONVERSION;
                rstates[type] = value;  // Must set before Pick
                PickDrawPrimFn();
            }
        }
        break;

    default:
        // WRAP render states could be re-mapped so we have to restore them before
        // setting a new value
        if (type >= D3DRENDERSTATE_WRAP0 &&  type <= D3DRENDERSTATE_WRAP7)
        {
            if (m_pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
        }
        break;
    }
    rstates[type] = value;      // set rstates for all other cases
    return;

#if DBG
error_exit:
    throw D3DERR_INVALIDCALL;
#endif
}
//---------------------------------------------------------------------
#if DBG
static  char ProfileStr[PROF_DRAWINDEXEDPRIMITIVEVB+1][32]=
{
    "Execute",
    "Begin",
    "BeginIndexed",
    "DrawPrimitive(Device2)",
    "DrawIndexedPrimitive(Device2)",
    "DrawPrimitiveStrided",
    "DrawIndexedPrimitiveStrided",
    "DrawPrimitive(Device7)",
    "DrawIndexedPrimitive(Device7)",
    "DrawPrimitiveVB",
    "DrawIndexedPrimitiveVB",
};
static  char PrimitiveStr[D3DPT_TRIANGLEFAN][16]=
{
    "POINTLIST",
    "LINELIST",
    "LINESTRIP",
    "TRIANGLELIST",
    "TRIANGLESTRIP",
    "TRIANGLEFAN",
};
static  char VertexStr[D3DVT_TLVERTEX][16]=
{
    "D3DVERTEX",
    "D3DLVERTEX",
    "D3DTLVERTEX",
};
#define PROFILE_LEVEL 0

void    CD3DHal::Profile(DWORD caller, D3DPRIMITIVETYPE dwPrimitive, DWORD dwVertex)
{
    DWORD   bitwisecaller= 1 << caller;
    DWORD   bitwisePrimitive = 1 << (DWORD)dwPrimitive;
    DWORD   bitwiseVertex1 = 1 << (dwVertex & 0x001F);
    DWORD   bitwiseVertex2 = 1 << ((dwVertex & 0x03E0) >> 5);
    char    str[256];
    DDASSERT(PROF_DRAWINDEXEDPRIMITIVEVB >= caller);
    DDASSERT(D3DPT_TRIANGLEFAN >= dwPrimitive && D3DPT_POINTLIST<= dwPrimitive);
    if (dwCaller & bitwisecaller)
    {
        if (dwPrimitiveType[caller] & bitwisePrimitive)
        {
            if ((dwVertexType1[caller] & bitwiseVertex1) &&
                (dwVertexType2[caller] & bitwiseVertex2))
            {
                return; //matching a previous api call, no spew, could count stat though
            }
            else
            {
                dwVertexType1[caller] |= bitwiseVertex1;
                dwVertexType2[caller] |= bitwiseVertex2;
            }
        }
        else
        {
            dwPrimitiveType[caller] |= bitwisePrimitive;
            dwVertexType1[caller] |= bitwiseVertex1;
            dwVertexType2[caller] |= bitwiseVertex2;
        }
    }
    else
    {
        this->dwCaller |= bitwisecaller;
        dwPrimitiveType[caller] |= bitwisePrimitive;
        dwVertexType1[caller] |= bitwiseVertex1;
        dwVertexType2[caller] |= bitwiseVertex2;
    }
    wsprintf( (LPSTR) str, ProfileStr[caller]);
    strcat(str,":");
    strcat(str,PrimitiveStr[dwPrimitive-1]);
    if (dwVertex > D3DVT_TLVERTEX)
    {
        if (dwVertex == D3DFVF_VERTEX)
        {
            dwVertex = D3DVT_VERTEX;
        }
        else
        if (dwVertex == D3DFVF_TLVERTEX)
        {
            dwVertex = D3DVT_TLVERTEX;
        }
        else
        {
            D3D_INFO(PROFILE_LEVEL,"Profile:%s FVFType=%08lx",str,dwVertex);
            return;
        }
    }
    else
    {
        DDASSERT(dwVertex >= D3DVT_VERTEX);
    }
    strcat(str,":");
    strcat(str,VertexStr[dwVertex-1]);
    D3D_INFO(PROFILE_LEVEL,"Profile:%s",str);
}

#endif // DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::MultiplyTransformI"

//    MultiplyTransform -- this preconcatenates the new matrix to the specified
//    transform matrix
//
//        this really screams for overloaded matrix ops...
//
void
CD3DHal::MultiplyTransformI(D3DTRANSFORMSTATETYPE state, CONST D3DMATRIX* lpMat)
{
    D3DMATRIXI mResult;
    if ((DWORD)state >= __WORLDMATRIXBASE &&
        (DWORD)state < (__WORLDMATRIXBASE + __MAXWORLDMATRICES))
    {
        // World matrix is set
        UINT index = (DWORD)state - __WORLDMATRIXBASE;
        MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &m_pv->world[index]);
        m_pv->world[index] = mResult;
        if (index == 0)
            this->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
    }
    else
    switch (state)
    {
    case D3DTS_VIEW       :
        MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &m_pv->view);
        m_pv->view = mResult;
        this->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_PROJECTION :
        MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.proj);
        this->transform.proj = mResult;
        this->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTS_TEXTURE0:
    case D3DTS_TEXTURE1:
    case D3DTS_TEXTURE2:
    case D3DTS_TEXTURE3:
    case D3DTS_TEXTURE4:
    case D3DTS_TEXTURE5:
    case D3DTS_TEXTURE6:
    case D3DTS_TEXTURE7:
        {
            DWORD dwIndex = state - D3DTS_TEXTURE0;
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &m_pv->mTexture[dwIndex]);
            m_pv->mTexture[dwIndex] = mResult;
            break;
        }
    default :
        D3D_THROW_FAIL("Invalid state value passed to MultiplyTransform");
    }
    m_pv->MatrixStateCount++;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
        this->pMatrixDirtyForDDI->SetBit(state);
    else
        m_pDDI->SetTransform(state, (LPD3DMATRIX)&mResult);
    // W range should always be updated
    if (state == D3DTS_PROJECTION)
        m_pDDI->UpdateWInfo((LPD3DMATRIX)&mResult);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::BeginStateBlock"

HRESULT D3DAPI CD3DBase::BeginStateBlock()
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Already in the state record mode. BeginStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        if (m_pStateSets->StartNewSet() != D3D_OK)
        {
            D3D_ERR("Could not allocate memory for new state block. BeginStateBlock failed.");
            return E_OUTOFMEMORY;
        }

        this->m_dwRuntimeFlags |= D3DRT_RECORDSTATEMODE;
#ifdef FAST_PATH
        FastPathSetRenderStateRecord();
        FastPathSetTextureStageStateRecord();
        FastPathApplyStateBlockRecord();
        FastPathSetTextureRecord();
        FastPathSetVertexShaderSlow();
        FastPathSetStreamSourceSlow();
        FastPathSetIndicesSlow();
        FastPathSetMaterialRecord();
        FastPathMultiplyTransformRecord();
        FastPathSetTransformRecord();
        FastPathSetPixelShaderRecord();
        FastPathSetPixelShaderConstantRecord();
        FastPathSetVertexShaderConstantRecord();
#endif // FAST_PATH
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("BeginStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::EndStateBlock"

HRESULT D3DAPI CD3DBase::EndStateBlock(LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. EndStateBlock failed." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
        if (!(this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE))
        {
            D3D_ERR("Not in state record mode. EndStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        this->m_dwRuntimeFlags &= ~D3DRT_RECORDSTATEMODE;
        m_pStateSets->EndSet();
#ifdef FAST_PATH
        FastPathSetRenderStateExecute();
        FastPathSetTextureStageStateExecute();
        FastPathSetMaterialExecute();
        FastPathSetVertexShaderFast();
        FastPathSetStreamSourceFast();    
        FastPathSetIndicesFast();    
        FastPathApplyStateBlockExecute();
        FastPathSetTextureExecute();
        FastPathSetTransformExecute();
        FastPathMultiplyTransformExecute();
        FastPathSetPixelShaderExecute();
        FastPathSetPixelShaderConstantExecute();
        FastPathSetVertexShaderConstantExecute();
#endif // FAST_PATH
        this->m_pDDI->WriteStateSetToDevice((D3DSTATEBLOCKTYPE)0);
        *pdwHandle = m_pStateSets->GetCurrentHandle();
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("EndStateBlock failed.");
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::DeleteStateBlock"

HRESULT D3DAPI CD3DBase::DeleteStateBlock(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode. DeleteStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        m_pStateSets->DeleteStateSet(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("DeleteStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ApplyStateBlock"

HRESULT D3DAPI CD3DBase::ApplyStateBlock(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode. ApplyStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        return ApplyStateBlockFast(dwHandle);
    }
    catch(HRESULT ret)
    {
        D3D_ERR("ApplyStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ApplyStateBlockFast"

HRESULT D3DAPI CD3DBase::ApplyStateBlockFast(DWORD dwHandle)
{
    // NOTE: This can become a public API through the
    // v-table hack. This should only happen for
    // single-threaded apps; so we don't need
    // to take the critical section.
    // API_ENTER(this); // Takes D3D Lock if necessary
    try
    {
        m_pStateSets->Execute(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        D3D_ERR("ApplyStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CaptureStateBlock"

HRESULT D3DAPI CD3DBase::CaptureStateBlock(DWORD dwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot capture when in the state record mode. CaptureStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        m_pStateSets->Capture(this, dwHandle);
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        D3D_ERR("CaptureStateBlock failed.");
        return ret;
    }
}
//---------------------------------------------------------------------
// Input:
//    type      - FVF control dword
//
// Returns D3D_OK, if the control dword is valid.
// D3DERR_INVALIDCALL otherwise
//
#undef  DPF_MODNAME
#define DPF_MODNAME "CD3DBase::ValidateFVF"

HRESULT __declspec(nothrow) CD3DBase::ValidateFVF(DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if (type & g_TextureFormatMask[dwTexCoord])
    {
        D3D_ERR("FVF Validation error: FVF has incorrect texture format");
        goto error;
    }
    if (type & 0xFFFF0000 && vertexType == D3DFVF_XYZRHW &&
        m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE)
    {
        D3D_ERR("FVF Validation error: The D3D device supports only two floats per texture coordinate set");
        goto error;
    }
    if (type & D3DFVF_RESERVED0)
    {
        D3D_ERR("FVF has reserved bit(s) set");
        goto error;
    }
    if (!(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5))
    {
        D3D_ERR("FVF Validation error: FVF has incorrect position type");
        goto error;
    }

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
    {
        D3D_ERR("FVF Validation error: Normal should not be used with XYZRHW position type");
        goto error;
    }
    return D3D_OK;
error:
    return D3DERR_INVALIDCALL;
}
//---------------------------------------------------------------------
// Returns TRUE, if driver state should not be updated
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::UpdateInternalTextureStageState"

BOOL CD3DHal::UpdateInternalTextureStageState
        (DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD* pValue)
{
    DWORD dwValue = *pValue;
    BOOL ret = FALSE; // return TRUE if TSS should NOT be batched
    if(dwState == D3DTSS_COLOROP)
    {
        if(dwValue == D3DTOP_DISABLE || tsstates[dwStage][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            ForceFVFRecompute();
    }
    else
    if (dwState == D3DTSS_TEXCOORDINDEX)
    {
        if (TextureTransformEnabled(this))
        {
            ForceFVFRecompute();
        }
        DWORD dwTexGenMode = 0;
        if (dwValue >= D3DDP_MAXTEXCOORD)
        {
            dwTexGenMode = dwValue & ~0xFFFF;
            if(!m_pDDI->CanDoTL())
                ret = TRUE;
#if DBG
            DWORD dwTexIndex   = dwValue & 0xFFFF;
            if (!(dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR) ||
                  dwTexIndex > D3DDP_MAXTEXCOORD)
            {
                D3D_ERR("Incorrect texture coordinate set index");
                throw D3DERR_INVALIDCALL;
            }
#endif
        }
        // Now we need to update internal flag (dwFlags2) which says whether
        // texture generation for the stage is enabled
        DWORD dwTexGenBit = __FLAGS2_TEXGEN0 << dwStage;
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            // We need to update internal flags when tex gen mode is changed,
            // so always call ForceFVFRecompute
            ForceFVFRecompute();
            m_pv->dwFlags2 |= dwTexGenBit;
        }
        else
        {
            // As optimization, recompute FVF only if texture generation for 
            // the stage was enabled 
            if (m_pv->dwFlags2 & dwTexGenBit)
            {
                ForceFVFRecompute();
                m_pv->dwFlags2 &= ~dwTexGenBit;
            }
        }
    }
    else
    if (dwState == D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        DWORD dwEnableBit = 1 << dwStage;   // To check internal "enable" dword
        // Force to re-compute FVF only if enable state is changed
        if ((dwValue & ~D3DTTFF_PROJECTED) == D3DTTFF_DISABLE)
        {
            if (m_pv->dwFlags2 & dwEnableBit)
            {
                ForceFVFRecompute();
                m_pv->dwFlags2 &= ~dwEnableBit;
            }
        }
        else
        {
            if (!(m_pv->dwFlags2 & dwEnableBit))
            {
                ForceFVFRecompute();
                m_pv->dwFlags2 |= dwEnableBit;
            }
        }

        // Do not pass texture transform flags to DX6 devices
        if(GetDDIType() == D3DDDITYPE_DX6)
            ret = TRUE;

        // When we need to emulate projected textures we do not pass "projected"
        // bit to the device. We also decrease the float count.
        if (m_dwRuntimeFlags & D3DRT_EMULATEPROJECTEDTEXTURE)
        {
            // Compute projected bit
            DWORD dwEnableBit = __FLAGS2_TEXPROJ0 << dwStage;
            if (dwValue & D3DTTFF_PROJECTED)
            {
                // Remove projected bit. Note that tsstates will keep the
                // original value
                *pValue &= ~D3DTTFF_PROJECTED;
                // Reduce float count
                if (*pValue != D3DTTFF_DISABLE)
                    (*pValue)--;
                if (!(m_pv->dwFlags2 & dwEnableBit))
                {
                    ForceFVFRecompute();
                    m_pv->dwFlags2 |= dwEnableBit;
                }
            }
            else
            {
                // Just clear projection enabled bit and recompute FVF
                if (m_pv->dwFlags2 & dwEnableBit)
                {
                    ForceFVFRecompute();
                    m_pv->dwFlags2 &= ~dwEnableBit;
                }
            }
        }
    }
    else
    if(dwState > D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        if(GetDDIType() == D3DDDITYPE_DX6)
            ret = TRUE;
    }
    // Update runtime copy of state.
    tsstates[dwStage][dwState] = dwValue;
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetClipPlaneI"

void CD3DHal::SetClipPlaneI(DWORD dwPlaneIndex, CONST D3DVALUE* pPlaneEquation)
{
    D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
    p[0] = pPlaneEquation[0];
    p[1] = pPlaneEquation[1];
    p[2] = pPlaneEquation[2];
    p[3] = pPlaneEquation[3];
    this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
    if (!(m_dwRuntimeFlags & (D3DRT_EXECUTESTATEMODE |
                              D3DRT_RSSOFTWAREPROCESSING)))
    {
        m_pDDI->SetClipPlane(dwPlaneIndex,
                             pPlaneEquation);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetClipPlane"

HRESULT D3DAPI
CD3DHal::GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    API_ENTER(this); // Takes D3D Lock if necessary

#if DBG
    if (dwPlaneIndex >= __MAXUSERCLIPPLANES)
    {
        D3D_ERR("Plane index is too big. GetClipPlane failed.");
        return D3DERR_INVALIDCALL;
    }
    if (!VALID_WRITEPTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR( "Invalid plane pointer. GetClipPlane failed." );
        return D3DERR_INVALIDCALL;
    }
#endif
    try
    {
        D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
        pPlaneEquation[0] = p[0];
        pPlaneEquation[1] = p[1];
        pPlaneEquation[2] = p[2];
        pPlaneEquation[3] = p[3];
    }
    catch(HRESULT ret)
    {
        D3D_ERR("GetClipPlane failed.");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CreateStateBlock"

HRESULT D3DAPI
CD3DBase::CreateStateBlock(D3DSTATEBLOCKTYPE sbt,
                           LPDWORD pdwHandle)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer. CreateStateBlock failed." );
        return D3DERR_INVALIDCALL;
    }
    try
    {
        if (this->m_dwRuntimeFlags & D3DRT_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot create state block when in the state record mode. CreateStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }

        m_pStateSets->CreatePredefined(this, sbt);

        *pdwHandle = m_pStateSets->GetCurrentHandle();
    }
    catch (HRESULT ret)
    {
        D3D_ERR("CreateStateBlock failed.");
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Restore indices in the texture stages which were re-mapped for texture
// transforms
// We have to do restore if
//  - Set or Get render state is issued with _WRAP parameter
//  - Set or Get texture stage is issued with TEXCOORDINDEX as a parameter
//
void RestoreTextureStages(LPD3DHAL pDevI)
{
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // dwVIDIn is used to force re-compute FVF in the
    // SetTextureStageState. so we save and restore it.
    DWORD dwVIDInSaved = pv->dwVIDIn;
    pv->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;
    for (DWORD i=0; i < pDevI->dwNumTextureStagesToRemap; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStageToRemap[i];
        // Texture generation mode was stripped out of pStage->dwInpCoordIndex
        DWORD dwInpIndex = pStage->dwInpCoordIndex + pStage->dwTexGenMode;
        if (dwInpIndex != pStage->dwOutCoordIndex)
        {
            // We do not call UpdateInternalTextureStageState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = dwInpIndex;

            // Filter texgen modes for non-TL drivers
            if (pDevI->m_pDDI->CanDoTL() || dwInpIndex < D3DDP_MAXTEXCOORD)
            {
                pDevI->m_pDDI->SetTSS(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwInpIndex);
            }
        }
        DWORD dwState = D3DRENDERSTATE_WRAP0 + pStage->dwOutCoordIndex;
        if (pStage->dwOrgWrapMode != pDevI->rstates[dwState])
        {
            // We do not call UpdateInternaState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->rstates[dwState] = pStage->dwOrgWrapMode;

            pDevI->m_pDDI->SetRenderState((D3DRENDERSTATETYPE)dwState,
                                          pStage->dwOrgWrapMode);
        }
    }
    pv->dwVIDIn = dwVIDInSaved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\dlld3d.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dlld3d.cpp
 *  Content:    Direct3D startup
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
//
// Flags to identify CPUs and CPU features
//
//---------------------------------------------------------------------

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

//#define __D3D_PSGP_DLL__

//---------------------------------------------------------------------
//
// Global variables
//
//---------------------------------------------------------------------

HINSTANCE hGeometryDLL = NULL;
LPD3DFE_CONTEXTCREATE pfnFEContextCreate = NULL;    // Used when PSGP is DLL
char szCPUString[13];

DWORD dwCPUFamily, dwCPUFeatures;

void SetMostRecentApp(void);

#ifdef _X86_
// --------------------------------------------------------------------------
// Here's a routine helps us determine if we should try MMX or not
// --------------------------------------------------------------------------
BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support
            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2
            test    edx,00800000h   ; Set flags before restoring registers
            popad               ; Restore everything
            setnz    al             ; Set return value
            mov     retval, eax
         };
    return retval;
}
#endif

static int isMMX = -1;

BOOL
isMMXprocessor(void)
{
    HKEY hKey;
    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     RESPATH_D3D,
                     &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if ( RegQueryValueEx( hKey, "DisableMMX", NULL, &dwType,
                              (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            RegCloseKey( hKey );
            isMMX = 0;
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    if (isMMX < 0)
    {
        isMMX = FALSE;
#ifdef _X86_
        D3D_WARN(4, "Executing processor detection code (benign first-chance exception possible)" );
#ifndef WIN95
        {
            // GetSystemInfo is not broken on WinNT.
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
                si.wProcessorLevel >= 5)
            {
#endif
                __try
                    {
                        if( _asm_isMMX() )
                        {

                            // Emit an emms instruction.
                            // This file needs to compile for non-Pentium
                            // processors
                            // so we can't use use inline asm since we're in the
                            // wrong
                            // processor mode.
                            __asm __emit 0xf;
                            __asm __emit 0x77;
                            isMMX = TRUE;
                            D3D_INFO(4, "MMX detected");
                        }
                    }
                __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH)
                    {
                    }
#ifndef WIN95
            }
        }
#endif
#endif
    }
    return isMMX;
}

#ifdef _X86_

//---------------------------------------------------------------------
BOOL IsWin95(void)
{
#ifdef WIN95 // and Win98...
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            D3D_INFO(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            D3D_INFO(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        D3D_INFO(2,"Detected WinNT");
        return FALSE;
    }
    D3D_INFO(2,"OS Detection failed");
    return TRUE;
#else
    return FALSE;
#endif  // WIN95
}
//---------------------------------------------------------------------
//
//  void GetProcessorFamily(LPDWORD lpdwFamily);
//
//      Passes back 3, 4, 5, 6 for 386, 486, Pentium, PPro class machines
//
#pragma optimize("", off)
void
GetProcessorFamily(LPDWORD lpdwFamily, LPDWORD lpdwCPUFeatures)
{
    SYSTEM_INFO si;
    __int64     start, end, freq;
    int         flags,family;
    int         time;
    int         clocks;
    DWORD       oldclass;
    HANDLE      hprocess;

    // guilty until proven otherwise
    *lpdwCPUFeatures = D3DCPU_BLOCKINGREAD;

    if ( isMMXprocessor() )
    {
        *lpdwCPUFeatures |= D3DCPU_MMX;
    }

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel)
    {
        *lpdwFamily=si.wProcessorLevel;
    }
    else
    {
        //Ok, we're on Win95
        switch (si.dwProcessorType)
        {
        case PROCESSOR_INTEL_386:
            *lpdwFamily=3;
            break;

        case PROCESSOR_INTEL_486:
            *lpdwFamily=4;
            break;
        default:
            *lpdwFamily=0;
            break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
        {
            _asm
            {
                 xor     eax,eax
                 _emit   00fh    ;; CPUID
                 _emit   0a2h
                 mov     dword ptr szCPUString,ebx
                 mov     dword ptr szCPUString+8,ecx
                 mov     dword ptr szCPUString+4,edx
                 mov     byte ptr szCPUString+12,0
                 mov     eax,1
                 _emit   00Fh     ;; CPUID
                 _emit   0A2h
                 mov     flags,edx
                 mov     family,eax
            }
        }
    __except(1)
        {
            flags = 0;
        }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return;

    // fcomi and FPU features both set
    if ( (flags&(1<<15)) && (flags & (1<<0)) )
    {
        D3D_INFO(2, "Pentium Pro CPU features (fcomi, cmov) detected");
        *lpdwCPUFeatures |= D3DCPU_FCOMICMOV;
    }

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*lpdwFamily))
    {
        *lpdwFamily=(family& 0x0F00) >> 8;
    }
    // not aware of any non-Intel processors w/non blocking reads
    if ( (! strcmp(szCPUString, "GenuineIntel")) &&
         *lpdwFamily > 5)
    {
        *lpdwCPUFeatures &= ~D3DCPU_BLOCKINGREAD;
    }

    return;
}
#pragma optimize("", on)

#endif // _X86_

#ifndef WIN95 // and Win98, WinME
//---------------------------------------------------------------------

BOOL bVBSwapEnabled = TRUE, bVBSwapWorkaround = FALSE;

void SetVBSwapStatus(void)
{
    OSVERSIONINFOEX osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx((LPOSVERSIONINFO)&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) // Check if Win2K Gold (2195)
        {
            if (osvi.wServicePackMajor == 0) // No service pack
            {
                D3D_INFO(1, "Win2K Gold detected - turning off VB swapping");
                bVBSwapEnabled = FALSE;
            }
            else
            {
                D3D_INFO(1, "Win2K SP1 or above detected - enabling VB swap workaround");
                bVBSwapEnabled = FALSE;
                bVBSwapWorkaround = TRUE;
            }
        }
        else // Whistler and above
        {
            /* ASSUMPTION: NO WORKAROUND NEEDED */
        }
    }
    else
    {
        // Should never get here
        DPF_ERR("OS Detection failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }
}
#endif // WIN95

extern "C" BOOL APIENTRY D3DDllMain( HMODULE hModule,
                                     DWORD ul_reason_for_call,
                                     LPVOID lpReserved );

BOOL APIENTRY
D3DDllMain( HMODULE hModule,
            DWORD ul_reason_for_call,
            LPVOID lpReserved )
{
    HKEY hKey;
    LONG lRet;
    DWORD dwType, dwSize;
    char filename[_MAX_PATH];

    switch( ul_reason_for_call )
    {
    case DLL_PROCESS_ATTACH:
#ifdef _X86_
        GetProcessorFamily(&dwCPUFamily, &dwCPUFeatures);
        D3D_INFO(3, "dwCPUFamily = %d, dwCPUFeatures = %d",
                 dwCPUFamily, dwCPUFeatures);
        D3D_INFO(3, "szCPUString = %s", szCPUString);
#endif

    // SSE (aka Katmai) does not work on Win95, so see if we are on
    // Win95 and disable
#ifdef WIN95
    {
        BOOL bIsWin95 = IsWin95();
        if ((dwCPUFeatures & D3DCPU_SSE) && bIsWin95)
        {
            D3D_INFO(1,"Disabling <Streaming SIMD Extension> support on Win95");
            dwCPUFeatures &= ~D3DCPU_SSE;
        }
    }
        // We need to workaround VB problems on Win2K
#else
        SetVBSwapStatus();
#endif

#ifdef __D3D_PSGP_DLL__
    lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
    if ( lRet == ERROR_SUCCESS )
    {
        dwSize = sizeof(filename);
        lRet = RegQueryValueEx(hKey,
                               "GeometryDriver",
                               NULL,
                               &dwType,
                               (LPBYTE) filename,
                               &dwSize);
        if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
        {
            hGeometryDLL = LoadLibrary(filename);
            if (hGeometryDLL)
            {
                pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
            }
        }

        RegCloseKey( hKey );
    }
#endif //__D3D_PSGP_DLL__

    // Set the app name to reg.
    SetMostRecentApp();
    break;
    case DLL_PROCESS_DETACH:
        if (NULL != hGeometryDLL)
            FreeLibrary(hGeometryDLL);
        break;
    default:
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// This function is called at process attach time to put the name of current
// app to registry.
// --------------------------------------------------------------------------
void SetMostRecentApp(void)
{
    char    fname[_MAX_PATH] = "\0";
    char    name[_MAX_PATH] = "\0";
    int     i;
    HKEY    hKey;
    HANDLE  hFile;

    // Find out what process we are dealing with
    hFile =  GetModuleHandle( NULL );
    GetModuleFileName( (HINSTANCE)hFile, fname, sizeof( fname ) );
    //DPF( 3, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
        i--;
    }
    i++;
    strcpy( name, &fname[i] );
    //DPF( 3, "name       = %s", name );

    // Now write the name into some known place
    if( !RegCreateKey( HKEY_LOCAL_MACHINE,
                       RESPATH_D3D "\\" REGSTR_KEY_LASTAPP, &hKey ) )
    {
        RegSetValueEx(hKey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\hmgr.cpp ===
#include "pch.cpp"
#pragma hdrstop


CHandleFactory::CHandleFactory() : m_Handles()
{ 
    m_Free = __INVALIDHANDLE;
}

CHandleFactory::CHandleFactory(DWORD dwGrowSize) : m_Handles()
{
    m_Free = __INVALIDHANDLE;
    m_Handles.SetGrowSize(dwGrowSize);
}


DWORD 
CHandleFactory::CreateNewHandle( LPD3DBASEOBJ pObj )
{
    DWORD handle = m_Free;
    if (m_Free != __INVALIDHANDLE)
    {
        m_Free = m_Handles[m_Free].m_Next;
    }
    else
    {
        handle = m_Handles.GetSize();
        m_Free = handle + 1;
        if( FAILED(m_Handles.Grow( m_Free )) )
            return __INVALIDHANDLE;
        
        DWORD dwSize = m_Handles.GetSize();
        for( DWORD i = handle; i<dwSize; i++ )
        {
            m_Handles[i].m_Next = i+1;
        }
        m_Handles[dwSize-1].m_Next = __INVALIDHANDLE;
        
    }

#if DBG
    DDASSERT(m_Handles[handle].m_tag == 0);
    m_Handles[handle].m_tag = 1;
#endif
    DDASSERT(m_Handles[handle].m_pObj == NULL);
    m_Handles[handle].m_pObj = pObj;
    
    return handle;
}

LPD3DBASEOBJ 
CHandleFactory::GetObject( DWORD dwHandle ) const
{
    if( m_Handles.Check( dwHandle ) )
    {
        return m_Handles[dwHandle].m_pObj;
    }
    else
    {
        // The handle doesnt exist
        return NULL;
    }
}

BOOL
CHandleFactory::SetObject( DWORD dwHandle, LPD3DBASEOBJ pObject)
{
    if( m_Handles.Check( dwHandle ) )
    {
        m_Handles[dwHandle].m_pObj = pObject;
        return TRUE;
    }
    else
    {
        // The handle doesnt exist
        return FALSE;
    }
}

void 
CHandleFactory::ReleaseHandle(DWORD handle, BOOL bDeleteObject)
{
    DDASSERT(handle < m_Handles.GetSize());
#if DBG
    DDASSERT(m_Handles[handle].m_tag != 0);
    m_Handles[handle].m_tag = 0;
#endif

    if( m_Handles[handle].m_pObj)
    {
        if (bDeleteObject)
            delete m_Handles[handle].m_pObj;
        m_Handles[handle].m_pObj = NULL;
    }

    m_Handles[handle].m_Next = m_Free;
    m_Free = handle;
}

//////////////////////////////////////////////////////////////////////////////

DWORD 
CVShaderHandleFactory::CreateNewHandle( LPVSHADER pVShader )
{
    DWORD dwHandle = CHandleFactory::CreateNewHandle( (LPD3DBASEOBJ)pVShader );
    
    // Now munge the handle. The algorithm is to shift left by one and
    // set the LSB to 1.

    dwHandle <<= 1;
    return (dwHandle | 0x1);
}

LPD3DBASEOBJ
CVShaderHandleFactory::GetObject( DWORD dwHandle ) const
{
    DWORD dwIndex = dwHandle >> 1;
    return CHandleFactory::GetObject( dwIndex );
}

BOOL
CVShaderHandleFactory::SetObject( DWORD dwHandle, LPD3DBASEOBJ pObject)
{
    DWORD dwIndex = dwHandle >> 1;
    return CHandleFactory::SetObject( dwIndex, pObject );
}

void 
CVShaderHandleFactory::ReleaseHandle(DWORD dwHandle, BOOL bDeleteObject)
{
    DWORD dwIndex = dwHandle >> 1;
    CHandleFactory::ReleaseHandle( dwIndex, bDeleteObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\sources.inc ===
TARGETPATH=obj
TARGETNAME=d3dfe

TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX8)\tnl
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)

SOURCES=\
    ..\npatch.cpp   \
    ..\d3dbase.cpp  \
    ..\d3ddev.cpp   \
    ..\devstate.cpp \
    ..\ddi.cpp      \
    ..\ddidx8.cpp   \
    ..\dlld3d.cpp   \
    ..\drawprim.cpp \
    ..\hmgr.cpp     \
    ..\helxfrm.cpp  \
    ..\lighting.cpp \
    ..\rgblt.cpp    \
    ..\stateset.cpp \
    ..\vshader.cpp  \
    ..\pshader.cpp  \
    ..\vwport.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\lighting.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        lighting.cpp
 *  Content:     Direct3D material/light management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "ddibase.h"

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckLightParams"

void CheckLightParams(CONST D3DLIGHT8* lpData)
{
    if (lpData->Type != D3DLIGHT_POINT &&
        lpData->Type != D3DLIGHT_SPOT &&
        lpData->Type != D3DLIGHT_DIRECTIONAL)
    {
        D3D_ERR( "Invalid D3DLIGHT type" );
        throw D3DERR_INVALIDCALL;
    }

    if (lpData->Range < 0.0f || lpData->Range > D3DLIGHT_RANGE_MAX)
    {
        D3D_ERR( "Invalid D3DLIGHT range" );
        throw D3DERR_INVALIDCALL;
    }
    if (lpData->Type == D3DLIGHT_SPOT || lpData->Type == D3DLIGHT_DIRECTIONAL)
    {
        float   magnitude;
        magnitude = lpData->Direction.x * lpData->Direction.x +
            lpData->Direction.y * lpData->Direction.y +
            lpData->Direction.z * lpData->Direction.z;
        if (magnitude < 0.00001f)
        {
            D3D_ERR( "Invalid D3DLIGHT direction" );
            throw D3DERR_INVALIDCALL;
        }
        if (lpData->Type == D3DLIGHT_SPOT)
        {
            if (lpData->Phi < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
                throw D3DERR_INVALIDCALL;
            }
            if (lpData->Phi > 3.1415927f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
                throw D3DERR_INVALIDCALL;
            }
            if (lpData->Theta < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
                throw D3DERR_INVALIDCALL;
            }
            if (lpData->Theta > lpData->Phi)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
                throw D3DERR_INVALIDCALL;
            }
        }
    }
    if (lpData->Type != D3DLIGHT_DIRECTIONAL)
    {
        if (lpData->Attenuation0 < 0 ||
            lpData->Attenuation1 < 0 ||
            lpData->Attenuation2 < 0)
        {
            D3D_ERR( "Attenuation factor can not be negative" );
            throw D3DERR_INVALIDCALL;
        }
        if (lpData->Attenuation0 == 0 &&
            lpData->Attenuation1 == 0 &&
            lpData->Attenuation2 == 0)
        {
            D3D_ERR("All attenuation factors are 0 for non-directional light");
            throw D3DERR_INVALIDCALL;
        }
    }
    return;
}
//=====================================================================
//
//         CD3DHal interface
//
//=====================================================================
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetMaterialFast"

HRESULT D3DAPI
CD3DHal::SetMaterialFast(CONST D3DMATERIAL8* lpData)
{
#if DBG
    if (!VALID_PTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR("Invalid D3DMATERIAL pointer. SetMaterial failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    m_pv->lighting.material = *lpData;
    this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
    if (!(m_dwRuntimeFlags & (D3DRT_EXECUTESTATEMODE | 
                              D3DRT_RSSOFTWAREPROCESSING)))
    {
        try
        {
            m_pDDI->SetMaterial(lpData);
        }
        catch(HRESULT ret)
        {
            D3D_ERR("SetMaterial failed.");
            return ret;
        }
    }
    return S_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetMaterial"

HRESULT D3DAPI CD3DHal::GetMaterial(D3DMATERIAL8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid D3DMATERIAL pointer. GetMaterial failed." );
        return D3DERR_INVALIDCALL;
    }

    *lpData = m_pv->lighting.material;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetLightI"

void CD3DHal::SetLightI(DWORD dwLightIndex, CONST D3DLIGHT8* lpData)
{
    if( m_pLightArray->Check( dwLightIndex ) == FALSE )
    {

        if( FAILED( m_pLightArray->Grow( dwLightIndex ) ) )
        {
            D3D_ERR("Not enough memory to grow light array");
            throw E_OUTOFMEMORY;
        }
    
        LIST_INITIALIZE(&m_ActiveLights);       // Clear active light list
        for (DWORD i = 0; i < m_pLightArray->GetSize(); i++)
        {
            if ((*m_pLightArray)[i].m_pObj)
            {
                DIRECT3DLIGHTI* pLight =
                    static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[i].m_pObj);
                if (pLight->Enabled())
                {
                    LIST_INSERT_ROOT(&m_ActiveLights, pLight, m_List);
                }
            }
        }
    }

    if( (*m_pLightArray)[dwLightIndex].m_pObj == NULL )
    {
        // Create light has been already sent to the driver 

        (*m_pLightArray)[dwLightIndex].m_pObj = 
            (CD3DBaseObj *)new DIRECT3DLIGHTI;
        if( (*m_pLightArray)[dwLightIndex].m_pObj == NULL )
        {
            D3D_ERR("Not enough memory to grow light array");
            throw E_OUTOFMEMORY;
        }
    }

    LPDIRECT3DLIGHTI pLight =
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);

    pLight->m_Light = *lpData;
    if (!(this->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            pLight->SetDirtyForDDI();
        else
            m_pDDI->SetLight(dwLightIndex, &pLight->m_Light);
    }

    dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
    pLight->m_LightI.flags |= D3DLIGHTI_DIRTY;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetLight"

HRESULT D3DAPI CD3DHal::GetLight(DWORD dwLightIndex, D3DLIGHT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer. GetLight failed." );
        return D3DERR_INVALIDCALL;
    }

    if (m_pLightArray->Check( dwLightIndex ) == FALSE )
    {
        D3D_ERR( "Invalid light index. GetLight failed." );
        return D3DERR_INVALIDCALL;
    }
    LPDIRECT3DLIGHTI pLight =
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);
    if (pLight == NULL)
    {
        D3D_ERR( "Invalid light index. GetLight failed." );
        return D3DERR_INVALIDCALL;
    }

    *lpData = pLight->m_Light;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::LightEnableI"

void CD3DHal::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    LPDIRECT3DLIGHTI pLight = 
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);
    if (bEnable)
    {
        if (!pLight->Enabled())
        {

            LIST_INSERT_ROOT(&m_ActiveLights, pLight, m_List);
            pLight->m_LightI.flags |= D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
    else
    {
        if (pLight->Enabled())
        {
            LIST_DELETE(pLight, m_List);
            pLight->m_LightI.flags &= ~D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
    // Update driver state
    if (!(this->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (this->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            pLight->SetEnableDirtyForDDI();
        else
            m_pDDI->LightEnable(dwLightIndex, bEnable);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::LightEnable"

HRESULT D3DAPI CD3DHal::GetLightEnable(DWORD dwLightIndex, BOOL *pbEnable)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(pbEnable, sizeof(BOOL)))
    {
        D3D_ERR( "Invalid enable pointer. GetLightEnable failed." );
        throw D3DERR_INVALIDCALL;
    }

    if ((m_pLightArray->Check( dwLightIndex ) == FALSE)
        ||
        ((*m_pLightArray)[dwLightIndex].m_pObj == NULL))
    {
        D3D_ERR("Invalid light index OR light is not initialized. GetLightEnable failed.");
        return D3DERR_INVALIDCALL;
    }
    LPDIRECT3DLIGHTI pLight =
        static_cast<DIRECT3DLIGHTI *>((*m_pLightArray)[dwLightIndex].m_pObj);
    *pbEnable = pLight->Enabled();
    return D3D_OK;
}
//---------------------------------------------------------------------
// Update internal light state
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DLIGHTI::SetInternalData"

HRESULT DIRECT3DLIGHTI::SetInternalData()
{
    m_LightI.type   = m_Light.Type;
    m_LightI.flags &= ~D3DLIGHTI_OPTIMIZATIONFLAGS;

    if (FLOAT_EQZ(m_Light.Specular.r) &&
        FLOAT_EQZ(m_Light.Specular.g) &&
        FLOAT_EQZ(m_Light.Specular.b))
    {
        m_LightI.flags |= D3DLIGHTI_SPECULAR_IS_ZERO;
    }

    if (FLOAT_EQZ(m_Light.Ambient.r) &&
        FLOAT_EQZ(m_Light.Ambient.g) &&
        FLOAT_EQZ(m_Light.Ambient.b))
    {
        m_LightI.flags |= D3DLIGHTI_AMBIENT_IS_ZERO;
    }

    m_LightI.ambient.r = m_Light.Ambient.r;
    m_LightI.ambient.g = m_Light.Ambient.g;
    m_LightI.ambient.b = m_Light.Ambient.b;

    m_LightI.specular.r = m_Light.Specular.r;
    m_LightI.specular.g = m_Light.Specular.g;
    m_LightI.specular.b = m_Light.Specular.b;

    m_LightI.diffuse.r = m_Light.Diffuse.r;
    m_LightI.diffuse.g = m_Light.Diffuse.g;
    m_LightI.diffuse.b = m_Light.Diffuse.b;

    m_LightI.position.x = m_Light.Position.x;
    m_LightI.position.y = m_Light.Position.y;
    m_LightI.position.z = m_Light.Position.z;
    m_LightI.direction.x = m_Light.Direction.x;
    m_LightI.direction.y = m_Light.Direction.y;
    m_LightI.direction.z = m_Light.Direction.z;
    m_LightI.attenuation0 = m_Light.Attenuation0;
    m_LightI.attenuation1 = m_Light.Attenuation1;
    m_LightI.attenuation2 = m_Light.Attenuation2;

    m_LightI.range = m_Light.Range;
    m_LightI.range_squared = m_Light.Range * m_Light.Range;

    if (m_Light.Type == D3DLIGHT_SPOT)
    {
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.Theta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.Phi / 2.0);

        m_LightI.falloff = m_Light.Falloff;
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
    }
    if (m_Light.Type == D3DLIGHT_DIRECTIONAL ||
        m_Light.Type == D3DLIGHT_SPOT)
    {
        VecNormalize(m_LightI.direction);
    }

    // set internal flags
    if (m_LightI.attenuation0 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT0_IS_NONZERO;
    }
    if (m_LightI.attenuation1 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT1_IS_NONZERO;
    }
    if (m_LightI.attenuation2 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT2_IS_NONZERO;
    }
    if (m_LightI.falloff == 1.0)
    {
        m_LightI.flags |= D3DLIGHTI_LINEAR_FALLOFF;
    }
    m_LightI.flags &= ~D3DLIGHTI_DIRTY;
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\pch.cpp ===
#include "ddrawpr.h"
#include "dxgint.h"
#include "resource.hpp"
#include "texture.hpp"
#include "volume.hpp"
#include "mipmap.hpp"
#include "mipvol.hpp"
#include "cubemap.hpp"
#include "surface.hpp"
#include "d3d8ddi.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "ddi.h"
#include "d3dpr.hpp"
#include "ddrawp.h"
#include "memalloc.h"
#include "fltval.h"
#include "stateset.hpp"
#include "hmgr.hpp"
#include "d3dexcept.hpp"
#include "drawprim.hpp"
#include "resource.inl"
#include "pipeln.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\rgblt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   rgblt.cpp
 *  Content:    Direct3D lighting
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"
#include "drawprim.hpp"

// Functions to use when lighting is done in the camera space
LIGHT_VERTEX_FUNC_TABLE lightVertexTable =
{
    Directional7,
    PointSpot7,
    DirectionalFirst,
    DirectionalNext,
    PointSpotFirst,
    PointSpotNext
};

// Functions to use when lighting is done in the model space
static LIGHT_VERTEX_FUNC_TABLE lightVertexTableModel =
{
    Directional7Model,
    PointSpot7Model,
    DirectionalFirstModel,
    DirectionalNextModel,
    PointSpotFirstModel,
    PointSpotNextModel
};
//-------------------------------------------------------------------------
SpecularTable* CreateSpecularTable(D3DVALUE power)
{
    SpecularTable* spec;
    int     i;
    float  delta = 1.0f/255.0f;
    float  v;

    D3DMalloc((void**)&spec, sizeof(SpecularTable));

    if (spec == NULL)
        return NULL;

    spec->power = power;

    v = 0.0;
    for (i = 0; i < 256; i++)
    {
        spec->table[i] = powf(v, power);
        v += delta;
    }

    for (; i < 260; i++)
        spec->table[i] = 1.0f;

    return spec;
}
//-------------------------------------------------------------------------
static void inverseRotateVector(D3DVECTOR* d,
                                D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

static void inverseTransformVector(D3DVECTOR* result,
                                   D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    result->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    result->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    result->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}
//-----------------------------------------------------------------------
// Every time the world matrix is modified or lights data is changed the
// lighting vectors have to change to match the model space of the new data
// to be rendered.
// Every time light data is changed or material data is changed or lighting
// state is changed, some pre-computed lighting values sould be updated
//
void D3DFE_UpdateLights(LPD3DHAL lpDevI)
{
    D3DFE_PROCESSVERTICES* pv = lpDevI->m_pv;
    D3DFE_LIGHTING& LIGHTING = pv->lighting;
    D3DI_LIGHT  *light = LIGHTING.activeLights;
    D3DVECTOR   t;
    BOOL        specular;       // TRUE, if specular component sould be computed
    D3DMATERIAL8 *mat = &LIGHTING.material;

    if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
    {

        SpecularTable* spec;

        for (spec = LIST_FIRST(&lpDevI->specular_tables);
             spec;
             spec = LIST_NEXT(spec,list))
        {
            if (spec->power == pv->lighting.material.Power)
                break;
        }
        if (spec == NULL)
        {
            spec = CreateSpecularTable(pv->lighting.material.Power);
            if (spec == NULL)
            {
                D3D_ERR("Failed to allocate internal specular table");
                throw E_OUTOFMEMORY;
            }
            LIST_INSERT_ROOT(&lpDevI->specular_tables, spec, list);
        }
        lpDevI->specular_table = spec;

        if (pv->lighting.material.Power > D3DVAL(0.001))
            pv->lighting.specThreshold = D3DVAL(pow(0.001, 1.0/pv->lighting.material.Power));
        else
            pv->lighting.specThreshold = 0;

        if (lpDevI->specular_table && pv->dwDeviceFlags & D3DDEV_SPECULARENABLE)
            specular = TRUE;
        else
            specular = FALSE;

        LIGHTING.materialAlpha = FTOI(D3DVAL(255) * mat->Diffuse.a);
        if (LIGHTING.materialAlpha < 0)
            LIGHTING.materialAlpha = 0;
        else
            if (LIGHTING.materialAlpha > 255)
                LIGHTING.materialAlpha = 255 << 24;
            else LIGHTING.materialAlpha <<= 24;

        LIGHTING.materialAlphaS = FTOI(D3DVAL(255) * mat->Specular.a);
        if (LIGHTING.materialAlphaS < 0)
            LIGHTING.materialAlphaS = 0;
        else
            if (LIGHTING.materialAlphaS > 255)
                LIGHTING.materialAlphaS = 255 << 24;
            else LIGHTING.materialAlphaS <<= 24;

        LIGHTING.currentSpecTable = lpDevI->specular_table->table;

        LIGHTING.diffuse0.r = LIGHTING.ambientSceneScaled.r * mat->Ambient.r;
        LIGHTING.diffuse0.g = LIGHTING.ambientSceneScaled.g * mat->Ambient.g;
        LIGHTING.diffuse0.b = LIGHTING.ambientSceneScaled.b * mat->Ambient.b;
        LIGHTING.diffuse0.r += mat->Emissive.r * D3DVAL(255);
        LIGHTING.diffuse0.g += mat->Emissive.g * D3DVAL(255);
        LIGHTING.diffuse0.b += mat->Emissive.b * D3DVAL(255);
        int r,g,b;
        r = (int)FTOI(LIGHTING.diffuse0.r);
        g = (int)FTOI(LIGHTING.diffuse0.g);
        b = (int)FTOI(LIGHTING.diffuse0.b);
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;
        LIGHTING.dwDiffuse0 = (r << 16) + (g << 8) + b;
    }

    pv->lighting.model_eye.x = (D3DVALUE)0;
    pv->lighting.model_eye.y = (D3DVALUE)0;
    pv->lighting.model_eye.z = (D3DVALUE)0;
    pv->lighting.directionToCamera.x =  0;
    pv->lighting.directionToCamera.y =  0;
    pv->lighting.directionToCamera.z = -1;
    if (pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
    {
        inverseTransformVector(&pv->lighting.model_eye,
                               &pv->lighting.model_eye,
                               &pv->mWV[0]);
        lpDevI->lightVertexFuncTable = &lightVertexTableModel;
        inverseRotateVector(&pv->lighting.directionToCamera,
                            &pv->lighting.directionToCamera,
                            &pv->mWV[0]);
    }
    else
    {
        lpDevI->lightVertexFuncTable = &lightVertexTable;
    }
    while (light)
    {
        // Whenever light type is changed the D3DFE_NEED_TRANSFORM_LIGHTS should be set
        if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
        {
            if (light->type != D3DLIGHT_DIRECTIONAL)
            { // Point and Spot lights
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnPointSpot;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnPointSpotFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnPointSpotNext;
                if (!(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light position to the camera space
                    VecMatMul(&light->position,
                              (D3DMATRIX*)&pv->view,
                              &light->model_position);
                }
                else
                {
                    inverseTransformVector(&light->model_position, &light->position,
                                           &pv->world[0]);
                }
            }
            else
            { // Directional light
                light->lightVertexFunc = lpDevI->lightVertexFuncTable->pfnDirectional;
                light->pfnLightFirst = lpDevI->lightVertexFuncTable->pfnDirectionalFirst;
                light->pfnLightNext  = lpDevI->lightVertexFuncTable->pfnDirectionalNext;
            }

            if (light->type != D3DLIGHT_POINT)
            {
                // Light direction is flipped to be the direction TO the light
                if (!(pv->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                {
                    // Transform light direction to the camera space
                    VecMatMul3(&light->direction,
                               (D3DMATRIX*)&pv->view,
                               &light->model_direction);
                    VecNormalizeFast(light->model_direction);
                }
                else
                {
                    inverseRotateVector(&light->model_direction, &light->direction,
                                           &pv->world[0]);
                }
                VecNeg(light->model_direction, light->model_direction);
                // For the infinite viewer the half vector is constant
                if (!(pv->dwDeviceFlags & D3DDEV_LOCALVIEWER))
                {
                    VecAdd(light->model_direction, pv->lighting.directionToCamera,
                           light->halfway);
                    VecNormalizeFast(light->halfway);
                }
            }
        }

        if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
        {
            light->diffuseMat.r = D3DVAL(255) * mat->Diffuse.r * light->diffuse.r;
            light->diffuseMat.g = D3DVAL(255) * mat->Diffuse.g * light->diffuse.g;
            light->diffuseMat.b = D3DVAL(255) * mat->Diffuse.b * light->diffuse.b;


            if (!(light->flags & D3DLIGHTI_AMBIENT_IS_ZERO))
            {
                light->ambientMat.r = D3DVAL(255) * mat->Ambient.r * light->ambient.r;
                light->ambientMat.g = D3DVAL(255) * mat->Ambient.g * light->ambient.g;
                light->ambientMat.b = D3DVAL(255) * mat->Ambient.b * light->ambient.b;
            }

            if (specular && !(light->flags & D3DLIGHTI_SPECULAR_IS_ZERO))
            {
                light->flags |= D3DLIGHTI_COMPUTE_SPECULAR;
                light->specularMat.r = D3DVAL(255) * mat->Specular.r * light->specular.r;
                light->specularMat.g = D3DVAL(255) * mat->Specular.g * light->specular.g;
                light->specularMat.b = D3DVAL(255) * mat->Specular.b * light->specular.b;
            }
            else
                light->flags &= ~D3DLIGHTI_COMPUTE_SPECULAR;
        }
        light = light->next;
    }

    lpDevI->dwFEFlags &= ~(D3DFE_MATERIAL_DIRTY |
                    D3DFE_NEED_TRANSFORM_LIGHTS |
                    D3DFE_LIGHTS_DIRTY);
}   // end of updateLights()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\stateset.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.cpp
 *  Content:    State sets handling
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#include "fe.h"

//=====================================================================
//      CStateSets interface
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CStateSets"

CStateSets::CStateSets(): m_SetHandles(10), m_DeviceHandles(10), m_GrowSize(10)
{
    m_dwMaxSets = 0;
    m_dwCurrentHandle = __INVALIDHANDLE;
    m_pStateSets = NULL;
    // Init handle factory
    // m_SetHandles.Init(m_GrowSize, m_GrowSize);
    m_SetHandles.CreateNewHandle( NULL ); // Reserve handle 0
    // m_DeviceHandles.Init(m_GrowSize, m_GrowSize);
    m_DeviceHandles.CreateNewHandle( NULL ); // Reserve handle 0
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::~CStateSets"

CStateSets::~CStateSets()
{
    delete m_pBufferSet;
    delete [] m_pStateSets;
    m_SetHandles.ReleaseHandle(0);
    m_DeviceHandles.ReleaseHandle(0);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Init"

HRESULT CStateSets::Init(CD3DBase *pDev)
{
    m_bPure = (pDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) != 0;
    m_bTLHal = (pDev->GetDDIType() == D3DDDITYPE_DX7TL) || (pDev->GetDDIType() == D3DDDITYPE_DX8TL);
    m_bDX8Dev = (pDev->GetDDIType() >= D3DDDITYPE_DX8);
    m_bHardwareVP = (pDev->BehaviorFlags() &
                     D3DCREATE_HARDWARE_VERTEXPROCESSING);
    if(pDev->GetDDIType() > D3DDDITYPE_DX7TL)
    {
        DWORD value = 0;
        GetD3DRegValue(REG_DWORD, "EmulateStateBlocks", &value, sizeof(DWORD));
        if(value == 0)
        {
            m_bEmulate = FALSE;
        }
        else
        {
            m_bEmulate = TRUE;
        }
    }
    else
    {
        m_bEmulate = TRUE;
    }
    if(m_bPure)
    {
        m_pBufferSet = new CPureStateSet;
    }
    else
    {
        m_pBufferSet = new CStateSet;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::StartNewSet"

HRESULT CStateSets::StartNewSet()
{
    m_dwCurrentHandle = m_SetHandles.CreateNewHandle( NULL );
    if (m_dwCurrentHandle == __INVALIDHANDLE)
        return E_OUTOFMEMORY;
    if (m_dwCurrentHandle >= m_dwMaxSets)
    {
        // Time to grow the array
        CStateSet *pNew;
        if(m_bPure)
        {
            pNew = new CPureStateSet[m_dwMaxSets + m_GrowSize];
        }
        else
        {
            pNew = new CStateSet[m_dwMaxSets + m_GrowSize];
        }
        if (pNew == NULL)
        {
            m_SetHandles.ReleaseHandle(m_dwCurrentHandle);
            return E_OUTOFMEMORY;
        }
        for (DWORD i=0; i < m_dwMaxSets; i++)
            pNew[i] = m_pStateSets[i];
        delete [] m_pStateSets;
        m_pStateSets = pNew;
        m_dwMaxSets += m_GrowSize;
    }
    m_pBufferSet->m_FEOnlyBuffer.Reset();
    m_pBufferSet->m_DriverBuffer.Reset();
    m_pCurrentStateSet = m_pBufferSet;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::EndSet"

void CStateSets::EndSet()
{
    m_pStateSets[m_dwCurrentHandle] = *m_pCurrentStateSet;
    m_pCurrentStateSet = &m_pStateSets[m_dwCurrentHandle];
    m_pCurrentStateSet->m_dwStateSetFlags |= __STATESET_INITIALIZED;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::DeleteStateSet"

void CStateSets::DeleteStateSet(CD3DBase *pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("State block handle is greater than available number of blocks");
        throw D3DERR_INVALIDCALL;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block is not initialized");
        throw D3DERR_INVALIDCALL;
    }

    // Pass delete instruction to the driver only if there was some data recorded
    if (pStateSet->m_dwDeviceHandle != __INVALIDHANDLE)
        pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETDELETE,
                                        pStateSet->m_dwDeviceHandle,
                                        (D3DSTATEBLOCKTYPE)0);

    Cleanup(dwHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Cleanup"

void CStateSets::Cleanup(DWORD dwHandle)
{
    CStateSet &pStateSet = m_pStateSets[dwHandle];
    m_SetHandles.ReleaseHandle(dwHandle);
    if (pStateSet.m_dwDeviceHandle != __INVALIDHANDLE)
        m_DeviceHandles.ReleaseHandle(pStateSet.m_dwDeviceHandle);
    pStateSet.Release();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Capture"

void CStateSets::Capture(CD3DBase *pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDCALL;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDCALL;
    }
    pStateSet->Capture(pDevI, TRUE);
    if (pStateSet->m_dwDeviceHandle != __INVALIDHANDLE)
    {
        pStateSet->Capture(pDevI, FALSE);
        pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETCAPTURE,
                                        pStateSet->m_dwDeviceHandle,
                                        (D3DSTATEBLOCKTYPE)0);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CreatePredefined"

void CStateSets::CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt)
{
    if (StartNewSet() != D3D_OK)
        throw E_OUTOFMEMORY;
    m_pCurrentStateSet->CreatePredefined(pDevI, sbt);
}
//---------------------------------------------------------------------
// Allocates device handle if necessary
// And returns information of the device buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::GetDeviceBufferInfo"

void CStateSets::GetDeviceBufferInfo(DWORD* dwStateSetHandle,
                                     LPVOID *pBuffer,
                                     DWORD* dwBufferSize)
{
    if (m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize != 0)
    {
        // Allocate  a handle for the device
        m_pCurrentStateSet->m_dwDeviceHandle = m_DeviceHandles.CreateNewHandle( NULL );
        if (m_pCurrentStateSet->m_dwDeviceHandle == __INVALIDHANDLE)
        {
            D3D_ERR("Cannot allocate device handle for a state block");
            throw E_OUTOFMEMORY;
        }
    }
    *dwStateSetHandle = m_pCurrentStateSet->m_dwDeviceHandle;
    *pBuffer = (LPVOID)m_pCurrentStateSet->m_DriverBuffer.m_pBuffer;
    *dwBufferSize = m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::GetDeviceBufferInfo"

void CStateSets::CreateNewDeviceHandle(DWORD* dwStateSetHandle)
{
    // Allocate  a handle for the device
    m_pCurrentStateSet->m_dwDeviceHandle = m_DeviceHandles.CreateNewHandle( NULL );
    if (m_pCurrentStateSet->m_dwDeviceHandle == __INVALIDHANDLE)
    {
        D3D_ERR("Cannot allocate device handle for a state block");
        throw E_OUTOFMEMORY;
    }
        *dwStateSetHandle = m_pCurrentStateSet->m_dwDeviceHandle;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::TranslateDeviceBufferToDX7DDI"

void CStateSets::TranslateDeviceBufferToDX7DDI( DWORD* p, DWORD dwSize )
{
    DWORD* pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                    DWORD dwValue = *p++;
                }
            }
            break;
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                    case D3DHAL_SETLIGHT_DISABLE:
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT8));
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));

                    // Map DX8 filter enums to DX6/7 enums
                    switch (pData->TSState)
                    {
                    case D3DTSS_MAGFILTER: pData->dwValue = texf2texfg[min(D3DTEXF_GAUSSIANCUBIC,pData->dwValue)]; break;
                    case D3DTSS_MINFILTER: pData->dwValue = texf2texfn[min(D3DTEXF_GAUSSIANCUBIC,pData->dwValue)]; break;
                    case D3DTSS_MIPFILTER: pData->dwValue = texf2texfp[min(D3DTEXF_GAUSSIANCUBIC,pData->dwValue)]; break;
                    }
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                    // The next command has to be D3DDP2OP_ZRANGE
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertRenderState"

void CStateSets::InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue,
                                      BOOL bDriverCanHandle)
{
    struct
    {
        D3DRENDERSTATETYPE state;
        DWORD dwValue;
    } data = {state, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_RENDERSTATE,
                                      &data, sizeof(data),
                                      !m_bEmulate && bDriverCanHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLight"

void CStateSets::InsertLight(DWORD dwLightIndex, CONST D3DLIGHT8* pData)
{
    struct
    {
        D3DHAL_DP2SETLIGHT header;
        D3DLIGHT8   light;
    } data;
    data.header.dwIndex = dwLightIndex;
    data.header.dwDataType = D3DHAL_SETLIGHT_DATA;
    data.light= *pData;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLightEnable"

void CStateSets::InsertLightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    D3DHAL_DP2SETLIGHT data;
    data.dwIndex = dwLightIndex;
    if (bEnable)
        data.dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        data.dwDataType = D3DHAL_SETLIGHT_DISABLE;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertViewport"

void CStateSets::InsertViewport(CONST D3DVIEWPORT8* lpVwpData)
{
    D3DHAL_DP2VIEWPORTINFO data2;
    data2.dwX = lpVwpData->X;
    data2.dwY = lpVwpData->Y;
    data2.dwWidth = lpVwpData->Width;
    data2.dwHeight = lpVwpData->Height;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_VIEWPORTINFO, &data2, sizeof(data2),
                                      !m_bEmulate && m_bTLHal);

    D3DHAL_DP2ZRANGE data1;
    data1.dvMinZ = lpVwpData->MinZ;
    data1.dvMaxZ = lpVwpData->MaxZ;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_ZRANGE, &data1, sizeof(data1),
                                      !m_bEmulate && m_bTLHal);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertMaterial"

void CStateSets::InsertMaterial(CONST D3DMATERIAL8* pData)
{
    D3DMATERIAL8 mat = *pData;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETMATERIAL,
                                      &mat,
                                      sizeof(D3DMATERIAL8),
                                      !m_bEmulate && m_bTLHal);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertClipPlane"

void CStateSets::InsertClipPlane(DWORD dwPlaneIndex,
                                 CONST D3DVALUE* pPlaneEquation)
{
    D3DHAL_DP2SETCLIPPLANE data;
    data.dwIndex = dwPlaneIndex;
    data.plane[0] = pPlaneEquation[0];
    data.plane[1] = pPlaneEquation[1];
    data.plane[2] = pPlaneEquation[2];
    data.plane[3] = pPlaneEquation[3];
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETCLIPPLANE,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTransform"

void CStateSets::InsertTransform(D3DTRANSFORMSTATETYPE state,
                                 CONST D3DMATRIX* lpMat)
{
    D3DHAL_DP2SETTRANSFORM data;
    data.xfrmType = state;
    data.matrix = *lpMat;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETTRANSFORM,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bTLHal);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTextureStageState"

void CStateSets::InsertTextureStageState(DWORD dwStage,
                                            D3DTEXTURESTAGESTATETYPE type,
                                            DWORD dwValue)
{
    D3DHAL_DP2TEXTURESTAGESTATE data = {(WORD)dwStage, type, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_TEXTURESTAGESTATE,
                                      &data, sizeof(data),
                                      !m_bEmulate);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTexture"

void CStateSets::InsertTexture(DWORD dwStage, IDirect3DBaseTexture8 *pTex)
{
    D3DHAL_DP2FRONTENDDATA data = {(WORD)dwStage, pTex};

    // Up the internal refcount of this texture.
    CBaseTexture *lpTexI = CBaseTexture::SafeCast(pTex);
    if (lpTexI)
        lpTexI->IncrementUseCount();

    // Only the front-end will parse this instruction
    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FRONTENDDATA, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertCurrentTexturePalette"

void CStateSets::InsertCurrentTexturePalette(DWORD PaletteNumber)
{
    D3DHAL_DP2FESETPAL data = {PaletteNumber};
    // Only the front-end will parse this instruction
    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FESETPAL, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertVertexShader"

void CStateSets::InsertVertexShader(DWORD dwShaderHandle, BOOL bHardware)
{
    D3DHAL_DP2VERTEXSHADER data = {dwShaderHandle};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETVERTEXSHADER,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bHardwareVP &&
                                      m_bDX8Dev && bHardware);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertPixelShader"

void CStateSets::InsertPixelShader(DWORD dwShaderHandle)
{
    D3DHAL_DP2PIXELSHADER data = {dwShaderHandle};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETPIXELSHADER,
                                      &data, sizeof(data),
                                      !m_bEmulate && m_bDX8Dev);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertStreamSource"

void CStateSets::InsertStreamSource(DWORD dwStream, CVertexBuffer *pBuf, DWORD dwStride)
{
    D3DHAL_DP2FESETVB data = {(WORD)dwStream, pBuf, dwStride};
    // Only the front-end will parse this instruction
    CVertexBuffer* pVB = static_cast<CVertexBuffer*>(pBuf);
    if (pVB)
        pVB->IncrementUseCount();

    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FESETVB, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertIndices"

void CStateSets::InsertIndices(CIndexBuffer *pBuf, DWORD dwBaseVertex)
{
    D3DHAL_DP2FESETIB data = {pBuf, dwBaseVertex};
    // Only the front-end will parse this instruction
    CIndexBuffer* pIB = static_cast<CIndexBuffer*>(pBuf);
    if (pIB)
        pIB->IncrementUseCount();

    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FESETIB, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertVertexShaderConstant"

void CStateSets::InsertVertexShaderConstant(DWORD Register, CONST VOID* pConstantData, DWORD ConstantCount)
{
    LPVOID pData = new BYTE[sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + ConstantCount * 16];
    if(pData == 0)
    {
        throw E_OUTOFMEMORY;
    }
    ((LPD3DHAL_DP2SETVERTEXSHADERCONST)pData)->dwRegister = Register;
    ((LPD3DHAL_DP2SETVERTEXSHADERCONST)pData)->dwCount = ConstantCount;
    memcpy((LPD3DHAL_DP2SETVERTEXSHADERCONST)pData + 1, pConstantData, ConstantCount * 16);
    try
    {
        m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETVERTEXSHADERCONST,
                                          pData,
                                          sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + ConstantCount * 16,
                                          !m_bEmulate && m_bDX8Dev && m_bTLHal);
    }
    catch(HRESULT hr)
    {
        delete[] pData;
        throw hr;
    }
    delete[] pData;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertPixelShaderConstant"

void CStateSets::InsertPixelShaderConstant(DWORD Register,
                                           CONST VOID* pConstantData,
                                           DWORD ConstantCount)
{
    LPVOID pData = new BYTE[sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + ConstantCount * 16];
    if(pData == 0)
    {
        throw E_OUTOFMEMORY;
    }
    ((LPD3DHAL_DP2SETPIXELSHADERCONST)pData)->dwRegister = Register;
    ((LPD3DHAL_DP2SETPIXELSHADERCONST)pData)->dwCount = ConstantCount;
    memcpy((LPD3DHAL_DP2SETPIXELSHADERCONST)pData + 1, pConstantData, ConstantCount * 16);
    try
    {
        m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETPIXELSHADERCONST,
                                          pData,
                                          sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + ConstantCount * 16,
                                          !m_bEmulate && m_bDX8Dev);
    }
    catch(HRESULT hr)
    {
        delete[] pData;
        throw hr;
    }
    delete[] pData;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Execute"

void CStateSets::Execute(CD3DBase *pDevI, DWORD dwHandle)
{
#if DBG
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDCALL;
    }
#endif
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
#if DBG
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDCALL;
    }
#endif
    // Parse recorded data first
    pStateSet->Execute(pDevI, TRUE);
    // If the hardware buffer is not empty, we pass recorded data to it
    if (pStateSet->m_dwDeviceHandle != __INVALIDHANDLE)
    {
        pStateSet->Execute(pDevI, FALSE);
        if((pDevI->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) == 0 || (pStateSet->m_dwStateSetFlags & __STATESET_HASONLYVERTEXSTATE) == 0)
        {
            pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETEXECUTE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);
        }
        else
        {
            pStateSet->m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
        }
    }
}
//=====================================================================
//      CStateSet interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Release"

HRESULT CStateSet::Release()
{
     if (!(m_dwStateSetFlags & __STATESET_INITIALIZED))
        return D3DERR_INVALIDCALL;
    m_dwStateSetFlags &= ~__STATESET_INITIALIZED;

    // Parse the FEOnly buffer and release all the VB/IB/Texture handles.
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;

    p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
    dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            p = (DWORD *)((D3DHAL_DP2RENDERSTATE *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETLIGHT:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                switch (pData->dwDataType)
                {
                case D3DHAL_SETLIGHT_ENABLE:
                case D3DHAL_SETLIGHT_DISABLE:
                    break;
                case D3DHAL_SETLIGHT_DATA:
                    p = (DWORD *)((BYTE *)p + sizeof(D3DLIGHT8));
                    break;
                }
            }
            break;
        case D3DDP2OP_SETMATERIAL:
            p = (DWORD *)((D3DHAL_DP2SETMATERIAL *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETTRANSFORM:
            p = (DWORD *)((D3DHAL_DP2SETTRANSFORM *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_TEXTURESTAGESTATE:
            p = (DWORD *)((D3DHAL_DP2TEXTURESTAGESTATE *)p +
                          pCommand->wStateCount);
            break;
        case D3DDP2OP_FRONTENDDATA:
        {
            CBaseTexture* pTexOld = NULL;
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                pTexOld = CBaseTexture::SafeCast(pData->pTexture);
                if( pTexOld )
                    pTexOld->DecrementUseCount();
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
            }
            break;
        }
        case D3DDP2OP_FESETVB:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                if( pData->pBuf )
                    pData->pBuf->DecrementUseCount();
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
            }
            break;
        case D3DDP2OP_FESETIB:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                if( pData->pBuf )
                    pData->pBuf->DecrementUseCount();
                p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
            }
            break;
        case D3DDP2OP_FESETPAL:
            p = (DWORD *)((D3DHAL_DP2FESETPAL *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_VIEWPORTINFO:
            // The next command has to be D3DDP2OP_ZRANGE
            p = (DWORD *)((BYTE *)p +
                          ( sizeof(D3DHAL_DP2VIEWPORTINFO) +
                            sizeof(D3DHAL_DP2COMMAND)      +
                            sizeof(D3DHAL_DP2ZRANGE ) ) *
                          pCommand->wStateCount );
            break;
        case D3DDP2OP_SETCLIPPLANE:
            p = (DWORD *)((D3DHAL_DP2SETCLIPPLANE *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETVERTEXSHADER:
            p = (DWORD *)((D3DHAL_DP2VERTEXSHADER *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETPIXELSHADER:
            p = (DWORD *)((D3DHAL_DP2PIXELSHADER *)p + pCommand->wStateCount);
            break;
        case D3DDP2OP_SETVERTEXSHADERCONST:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETVERTEXSHADERCONST pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                p = (DWORD*)((BYTE*)p +
                             sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) +
                             pData->dwCount * 16);

            }
            break;
        case D3DDP2OP_SETPIXELSHADERCONST:
            for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETPIXELSHADERCONST pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                p = (DWORD*)((BYTE*)p +
                             sizeof(D3DHAL_DP2SETPIXELSHADERCONST) +
                             pData->dwCount * 16);
            }
            break;
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }

    m_FEOnlyBuffer.Reset();
    m_DriverBuffer.Reset();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::InsertCommand"

void CStateSet::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData,
                                 DWORD dwDataSize,
                                 BOOL bDriverCanHandle)
{
    if (op == D3DDP2OP_TEXTURESTAGESTATE ||
        (op == D3DDP2OP_RENDERSTATE &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState >= D3DRENDERSTATE_WRAP0 &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState <= D3DRENDERSTATE_WRAP7))
    {
        m_dwStateSetFlags |= __STATESET_NEEDCHECKREMAPPING;
    }
    if (bDriverCanHandle)
        m_DriverBuffer.InsertCommand(op, pData, dwDataSize);
    else
        m_FEOnlyBuffer.InsertCommand(op, pData, dwDataSize);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Execute"

void CStateSet::Execute(CD3DBase *pBaseDev, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    // The device is not pure, so we can cast
    DXGASSERT((pBaseDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0);
    CD3DHal *pDevI = static_cast<CD3DHal*>(pBaseDev);
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    try
    {
        // Texture stages could be re-mapped during texture transform processing.
        // Before we set new values we have to restore original ones
        if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES &&
            m_dwStateSetFlags & __STATESET_NEEDCHECKREMAPPING)
        {
            RestoreTextureStages(pDevI);
            pDevI->ForceFVFRecompute();
        }

        if (bFrontEndBuffer)
        {
            p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
            dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
        }
        else
        {
            p = (DWORD*)m_DriverBuffer.m_pBuffer;
            dwSize = m_DriverBuffer.m_dwCurrentSize;
            pDevI->m_dwRuntimeFlags |= D3DRT_EXECUTESTATEMODE;
            m_dwStateSetFlags |= __STATESET_HASONLYVERTEXSTATE;
        }
        pEnd = (DWORD*)((BYTE*)p + dwSize);
        while (p < pEnd)
        {
            LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
            switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
            {
            case D3DDP2OP_RENDERSTATE:
                {
                    if(pDevI->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE)
                    {
                        m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if ( (pDevI->rstates[dwState] != dwValue)
#if DBG
                                  && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
                               )
                            {
                                if (!pDevI->rsVec.IsBitSet(dwState))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState %d", dwState);
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if ( (pDevI->rstates[dwState] != dwValue)
#if DBG
                                  && (dwState != D3DRS_DEBUGMONITORTOKEN) // don't filter these
#endif
                               )
                            {
                                if (!pDevI->rsVec.IsBitSet(dwState))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;

                                    pDevI->m_pDDI->SetRenderState(dwState, dwValue);
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                    // Vertex processing only render states will be passed to the
                                    // driver when we switch to the hardware vertex processing mode
                                    if ((!(pDevI->rsVertexProcessingOnly.IsBitSet(dwState) &&
                                           pDevI->m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)))
                                    {
                                        if (pDevI->CanHandleRenderState(dwState))
                                        {
                                            pDevI->m_pDDI->SetRenderState(dwState, dwValue);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState %d", dwState);
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETLIGHT:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                        switch (pData->dwDataType)
                        {
                        case D3DHAL_SETLIGHT_ENABLE:
                            pDevI->LightEnableI( pData->dwIndex, TRUE );
                            break;
                        case D3DHAL_SETLIGHT_DISABLE:
                            pDevI->LightEnableI( pData->dwIndex, FALSE );
                            break;
                        case D3DHAL_SETLIGHT_DATA:
                            pDevI->SetLightI(pData->dwIndex, (D3DLIGHT8 *)p);
                            p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT8));
                            break;
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETMATERIAL:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                        pDevI->SetMaterialFast((D3DMATERIAL8*)pData);
                    }
                    break;
                }
            case D3DDP2OP_SETTRANSFORM:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETTRANSFORM *pData = (D3DHAL_DP2SETTRANSFORM*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                        pDevI->SetTransformI(pData->xfrmType, &pData->matrix);
                    }
                    break;
                }
            case D3DDP2OP_TEXTURESTAGESTATE:
                {
                    if (pDevI->m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE)
                    {
                        m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                {
                                    pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, &dwValue);
                                }
                                else
                                {
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState Stage: %d, State: %d", dwStage, dwState);
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                {
                                    if(pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, &dwValue))
                                        continue;
                                }
                                else
                                {
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                                }
                                if (dwStage >= pDevI->m_dwMaxTextureBlendStages)
                                    continue;
                                pDevI->m_pDDI->SetTSS(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue);
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState Stage: %d, State: %d", dwStage, dwState);
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_FRONTENDDATA:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                        HRESULT ret = pDevI->SetTexture(pData->wStage, pData->pTexture);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_FESETVB:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                        HRESULT ret = pDevI->SetStreamSource(pData->wStream, pData->pBuf, pData->dwStride);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_FESETIB:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                        HRESULT ret = pDevI->SetIndices(pData->pBuf, pData->dwBase);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                    if(  pData->dwPaletteNumber != __INVALIDPALETTE )
                    {
                        HRESULT ret = pDevI->SetCurrentTexturePalette(pData->dwPaletteNumber);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                }
                break;
            }
            case D3DDP2OP_VIEWPORTINFO:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DVIEWPORT8 viewport;
                        LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                        viewport.X      = lpVwpData->dwX;
                        viewport.Y      = lpVwpData->dwY;
                        viewport.Width  = lpVwpData->dwWidth;
                        viewport.Height = lpVwpData->dwHeight;

                        // The next command has to be D3DDP2OP_ZRANGE
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                        LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                        viewport.MinZ      = pData->dvMinZ;
                        viewport.MaxZ      = pData->dvMaxZ;

                        pDevI->SetViewportI(&viewport);
                    }
                    break;
                }
            case D3DDP2OP_SETCLIPPLANE:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETCLIPPLANE *pData = (D3DHAL_DP2SETCLIPPLANE*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                        pDevI->SetClipPlaneI(pData->dwIndex, pData->plane);
                    }
                    break;
                }
            case D3DDP2OP_SETVERTEXSHADER:
                {
                    // Optimization, dont loop, use the last one.
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2VERTEXSHADER pData = (LPD3DHAL_DP2VERTEXSHADER)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VERTEXSHADER));
                        if( pData->dwHandle != 0 )
                        {
                            pDevI->SetVertexShader(pData->dwHandle);
                        }
                        else
                        {
                            pDevI->m_dwCurrentShaderHandle = 0;
                        }
                    }
                    pDevI->m_pDDI->ResetVertexShader();
                    break;
                }
            case D3DDP2OP_SETPIXELSHADER:
                {
                    m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2PIXELSHADER pData = (LPD3DHAL_DP2PIXELSHADER)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2PIXELSHADER));
                        pDevI->SetPixelShaderFast(pData->dwHandle);
                    }
                    break;
                }
            case D3DDP2OP_SETVERTEXSHADERCONST:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETVERTEXSHADERCONST pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + pData->dwCount * 16);
                        pDevI->SetVertexShaderConstantI(pData->dwRegister, pData + 1, pData->dwCount);
                    }
                    break;
                }
            case D3DDP2OP_SETPIXELSHADERCONST:
                {
                    m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETPIXELSHADERCONST pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + pData->dwCount * 16);
                        pDevI->SetPixelShaderConstantFast(pData->dwRegister, pData + 1, pData->dwCount);
                    }
                    break;
                }
#ifdef DBG
            default:
                DXGASSERT(FALSE);
#endif
            }
        }
        pDevI->m_dwRuntimeFlags &= ~D3DRT_EXECUTESTATEMODE;
    }
    catch(HRESULT ret)
    {
        pDevI->m_dwRuntimeFlags &= ~D3DRT_EXECUTESTATEMODE;
        m_dwStateSetFlags &= ~__STATESET_HASONLYVERTEXSTATE;
        throw ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Capture"

void CStateSet::Capture(CD3DBase *pBaseDev, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    // The device is not pure, so we can cast
    DXGASSERT((pBaseDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0);
    CD3DHal *pDevI = static_cast<CD3DHal*>(pBaseDev);
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // Texture coordinate indices must be restored before capturing, because 
    // we do not call GetTextureStageState but access tsstates directly
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(pDevI);
        pDevI->ForceFVFRecompute();
    }
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        p = (DWORD*)m_DriverBuffer.m_pBuffer;
        dwSize = m_DriverBuffer.m_dwCurrentSize;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    const D3DRENDERSTATETYPE state = (D3DRENDERSTATETYPE)*p++;
                    *p++ = pDevI->rstates[state];
                }
                break;
            }
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                    LPDIRECT3DLIGHTI pLight =
                        static_cast<DIRECT3DLIGHTI *>
                        ((*pDevI->m_pLightArray)[pData->dwIndex].m_pObj);
                    if(pData->dwIndex >= pDevI->m_pLightArray->GetSize())
                    {
                        D3D_ERR("Unable to capture light state (light not set?)");
                        throw D3DERR_INVALIDCALL;
                    }
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                        if(!pLight->Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                        break;
                    case D3DHAL_SETLIGHT_DISABLE:
                        if(pLight->Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        *((D3DLIGHT8*)p) = pLight->m_Light;
                        p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT8));
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                    *pData = *((LPD3DHAL_DP2SETMATERIAL)&pv->lighting.material);
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                    DWORD state = pData->xfrmType;
                    if ((DWORD)state >= __WORLDMATRIXBASE &&
                        (DWORD)state < __WORLDMATRIXBASE + __MAXWORLDMATRICES)
                    {
                        UINT index = (DWORD)state - __WORLDMATRIXBASE;
                        pData->matrix = *((LPD3DMATRIX)&pv->world[index]);
                    }
                    else
                    switch(pData->xfrmType)
                    {
                    case D3DTRANSFORMSTATE_VIEW:
                        pData->matrix = *((LPD3DMATRIX)&pv->view);
                        break;
                    case D3DTRANSFORMSTATE_PROJECTION:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.proj);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE0:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[0]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE1:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[1]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE2:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[2]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE3:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[3]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE4:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[4]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE5:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[5]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE6:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[6]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE7:
                        pData->matrix = *((LPD3DMATRIX)&pv->mTexture[7]);
                        break;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    pData->dwValue = pDevI->tsstates[pData->wStage][pData->TSState];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                }
                break;
            }
        case D3DDP2OP_FRONTENDDATA:
            {
                CBaseTexture* pTexOld = NULL;
                CBaseTexture* pTexNew = NULL;

                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    pTexOld = CBaseTexture::SafeCast(pData->pTexture);
                    if( pTexOld )
                        pTexOld->DecrementUseCount();
                    pTexNew = pDevI->m_lpD3DMappedTexI[pData->wStage];
                    if( pTexNew )
                        pTexNew->IncrementUseCount();
                    if (pDevI->m_lpD3DMappedTexI[pData->wStage] != 0)
                    {
                        switch(pDevI->m_lpD3DMappedTexI[pData->wStage]->GetBufferDesc()->Type)
                        {
                        case D3DRTYPE_TEXTURE:
                            pData->pTexture = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pTexNew));
                            break;
                        case D3DRTYPE_CUBETEXTURE:
                            pData->pTexture = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pTexNew));
                            break;
                        case D3DRTYPE_VOLUMETEXTURE:
                            pData->pTexture = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pTexNew));
                            break;
                        }
                    }
                    else
                    {
                        pData->pTexture = 0;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                }
                break;
            }
        case D3DDP2OP_FESETVB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                    if( pData->pBuf )
                        pData->pBuf->DecrementUseCount();
                    pData->pBuf = pDevI->m_pStream[pData->wStream].m_pVB;
                    if( pData->pBuf )
                        pData->pBuf->IncrementUseCount();
                    pData->dwStride = pDevI->m_pStream[pData->wStream].m_dwStride;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                }
                break;
            }
        case D3DDP2OP_FESETIB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                    if( pData->pBuf )
                        pData->pBuf->DecrementUseCount();
                    pData->pBuf = pDevI->m_pIndexStream->m_pVBI;
                    if( pData->pBuf )
                        pData->pBuf->IncrementUseCount();
                    pData->dwBase = pDevI->m_pIndexStream->m_dwBaseIndex;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                }
                break;
            }
        case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    pData->dwPaletteNumber = pDevI->m_dwPalette;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    D3DVIEWPORT8 viewport;
                    LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                    lpVwpData->dwX      = pDevI->m_Viewport.X;
                    lpVwpData->dwY      = pDevI->m_Viewport.Y;
                    lpVwpData->dwWidth  = pDevI->m_Viewport.Width;
                    lpVwpData->dwHeight = pDevI->m_Viewport.Height;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                    // The next command has to be D3DDP2OP_ZRANGE
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                    LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                    pData->dvMinZ = pDevI->m_Viewport.MinZ;
                    pData->dvMaxZ = pDevI->m_Viewport.MaxZ;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                    *((LPD3DVECTORH)pData->plane) = pDevI->transform.userClipPlane[pData->dwIndex];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                }
                break;
            }
        case D3DDP2OP_SETVERTEXSHADER:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2VERTEXSHADER pData = (LPD3DHAL_DP2VERTEXSHADER)p;
                    pData->dwHandle = pDevI->m_dwCurrentShaderHandle;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VERTEXSHADER));
                }
                break;
            }
        case D3DDP2OP_SETPIXELSHADER:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2PIXELSHADER pData = (LPD3DHAL_DP2PIXELSHADER)p;
                    pData->dwHandle = pDevI->m_dwCurrentPixelShaderHandle;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2PIXELSHADER));

                }
                break;
            }
        case D3DDP2OP_SETVERTEXSHADERCONST:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETVERTEXSHADERCONST pData = (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                    pDevI->m_pv->pGeometryFuncs->GetShaderConstants(pData->dwRegister, pData->dwCount, pData + 1);
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + pData->dwCount * 16);

                }
                break;
            }
        case D3DDP2OP_SETPIXELSHADERCONST:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETPIXELSHADERCONST pData = (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                    pDevI->GetPixelShaderConstantI(pData->dwRegister,
                                                   pData->dwCount,
                                                   pData + 1);
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + pData->dwCount * 16);
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::CreatePredefined"

void CStateSet::CreatePredefined(CD3DBase *pBaseDev, D3DSTATEBLOCKTYPE sbt)
{
    static D3DRENDERSTATETYPE ALLrstates[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_COLORWRITEENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_BLENDOP,
        D3DRS_POSITIONORDER,
        D3DRS_NORMALORDER,
    };
    static D3DTEXTURESTAGESTATETYPE ALLtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };
    static D3DRENDERSTATETYPE PIXELrstates[] =
    {
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRS_COLORWRITEENABLE,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE PIXELtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };
    static D3DRENDERSTATETYPE VERTEXrstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_POSITIONORDER,
        D3DRS_NORMALORDER,
    };
    static D3DTEXTURESTAGESTATETYPE VERTEXtsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    DWORD i;
    BOOL  bCapturePixelShaderState = TRUE;

    // The device is not pure, so we can cast
    DXGASSERT((pBaseDev->BehaviorFlags() & D3DCREATE_PUREDEVICE) == 0);
    CD3DHal *pDevI = static_cast<CD3DHal*>(pBaseDev);
    D3DFE_PROCESSVERTICES* pv = pDevI->m_pv;
    // Texture coordinate indices must be restored before capturing, because 
    // we do not call GetTextureStageState but access tsstates directly
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(pDevI);
        pDevI->ForceFVFRecompute();
    }
    switch(sbt)
    {
    case (D3DSTATEBLOCKTYPE)0:
        break;
    case D3DSBT_ALL:
        for(i = 0; i < sizeof(ALLrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            pDevI->m_pStateSets->InsertRenderState(ALLrstates[i], pDevI->rstates[ALLrstates[i]], pDevI->CanHandleRenderState(ALLrstates[i]));

        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(ALLtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                pDevI->m_pStateSets->InsertTextureStageState(i, ALLtsstates[j], pDevI->tsstates[i][ALLtsstates[j]]);

        // Capture textures
        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
        {
            IDirect3DBaseTexture8 *pTex;
            if (pDevI->m_lpD3DMappedTexI[i] != 0)
            {
                switch(pDevI->m_lpD3DMappedTexI[i]->GetBufferDesc()->Type)
                {
                case D3DRTYPE_TEXTURE:
                    pTex = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_CUBETEXTURE:
                    pTex = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_VOLUMETEXTURE:
                    pTex = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                }
            }
            else
            {
                pTex = 0;
            }
            pDevI->m_pStateSets->InsertTexture(i, pTex);
        }

        // Capture current palette
        pDevI->m_pStateSets->InsertCurrentTexturePalette(pDevI->m_dwPalette);

        // Capture streams
        for (i = 0; i < pDevI->m_dwNumStreams; i++)
        {
            pDevI->m_pStateSets->InsertStreamSource(i, pDevI->m_pStream[i].m_pVB, pDevI->m_pStream[i].m_dwStride);
        }
        pDevI->m_pStateSets->InsertIndices(pDevI->m_pIndexStream->m_pVBI, pDevI->m_pIndexStream->m_dwBaseIndex);

        // Capture current viewport
        pDevI->m_pStateSets->InsertViewport(&pDevI->m_Viewport);

        // Capture current transforms
        for (i = 0; i < __MAXWORLDMATRICES; i++)
        {
            pDevI->m_pStateSets->InsertTransform(D3DTS_WORLDMATRIX(i), (LPD3DMATRIX)&pv->world[i]);
        }
        pDevI->m_pStateSets->InsertTransform(D3DTRANSFORMSTATE_VIEW, (LPD3DMATRIX)&pv->view);
        pDevI->m_pStateSets->InsertTransform(D3DTRANSFORMSTATE_PROJECTION, (LPD3DMATRIX)&pDevI->transform.proj);
        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
        {
            pDevI->m_pStateSets->InsertTransform((D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i), (LPD3DMATRIX)&pv->mTexture[i]);
        }

        // Capture current clip-planes
        for (i = 0; i < pDevI->m_dwMaxUserClipPlanes; i++)
        {
            pDevI->m_pStateSets->InsertClipPlane(i, (LPD3DVALUE)&pDevI->transform.userClipPlane[i]);
        }

        // Capture current material
        pDevI->m_pStateSets->InsertMaterial(&pv->lighting.material);

        // Capture current lights
        for (i = 0; i < pDevI->m_pLightArray->GetSize(); i++)
        {
            LPDIRECT3DLIGHTI pLight =
                static_cast<DIRECT3DLIGHTI *>((*pDevI->m_pLightArray)[i].m_pObj);
            if( pLight)
            {
                pDevI->m_pStateSets->InsertLight(i, &pLight->m_Light);
                if(pLight->Enabled())
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, TRUE);
                }
                else
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, FALSE);
                }
            }
        }

        // Capture current shaders
        if (D3DVSD_ISLEGACY(pDevI->m_dwCurrentShaderHandle))
        {
            pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
        }
        else
        {
            CVShader* pShader = (CVShader*)pDevI->m_pVShaderArray->GetObject(pDevI->m_dwCurrentShaderHandle);
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, FALSE);
            }
            else
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
            }
        }

        if( bCapturePixelShaderState )
            pDevI->m_pStateSets->InsertPixelShader(pDevI->m_dwCurrentPixelShaderHandle);

        // Capture shader constants. Use Microsoft's constants as a temp buffer
        {
            const UINT count = pDevI->m_MaxVertexShaderConst;
            pDevI->GetVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
            pDevI->m_pStateSets->InsertVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
        }

        // Capture pixel shader constants
        if( bCapturePixelShaderState )
        {
            // Note this is hardcoded to 8. ff.ff supports 16 but here we capture only 8.
            pDevI->m_pStateSets->InsertPixelShaderConstant(0, pDevI->m_PShaderConstReg, 8 );
        }
        
        break;

    case D3DSBT_PIXELSTATE:
        for(i = 0; i < sizeof(PIXELrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            pDevI->m_pStateSets->InsertRenderState(PIXELrstates[i], pDevI->rstates[PIXELrstates[i]], pDevI->CanHandleRenderState(PIXELrstates[i]));

        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(PIXELtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                pDevI->m_pStateSets->InsertTextureStageState(i, PIXELtsstates[j], pDevI->tsstates[i][PIXELtsstates[j]]);

        // Capture pixel shader constants
        if( bCapturePixelShaderState )
            pDevI->m_pStateSets->InsertPixelShaderConstant(0, pDevI->m_PShaderConstReg,
                                                           D3DPS_CONSTREG_MAX_DX8);

        // Capture current pixel shader
        if( bCapturePixelShaderState )
            pDevI->m_pStateSets->InsertPixelShader(pDevI->m_dwCurrentPixelShaderHandle);
        break;

    case D3DSBT_VERTEXSTATE:
        for(i = 0; i < sizeof(VERTEXrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            pDevI->m_pStateSets->InsertRenderState(VERTEXrstates[i], pDevI->rstates[VERTEXrstates[i]], pDevI->CanHandleRenderState(VERTEXrstates[i]));

        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(VERTEXtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                pDevI->m_pStateSets->InsertTextureStageState(i, VERTEXtsstates[j], pDevI->tsstates[i][VERTEXtsstates[j]]);

        // Capture current light enables
        for (i = 0; i < pDevI->m_pLightArray->GetSize(); i++)
        {
            LPDIRECT3DLIGHTI pLight =
                static_cast<DIRECT3DLIGHTI *>((*pDevI->m_pLightArray)[i].m_pObj);
            if( pLight)
            {
                pDevI->m_pStateSets->InsertLight(i, &pLight->m_Light);
                if(pLight->Enabled())
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, TRUE);
                }
                else
                {
                    pDevI->m_pStateSets->InsertLightEnable(i, FALSE);
                }
            }
        }

        // Capture shader constants. Use Microsoft's constants as a temp buffer
        {
            const UINT count = pDevI->m_MaxVertexShaderConst;
            pDevI->GetVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
            pDevI->m_pStateSets->InsertVertexShaderConstant(0, pDevI->GeometryFuncsGuaranteed->m_VertexVM.GetRegisters()->m_c, count);
        }

        // Capture current vertex shader
        if (D3DVSD_ISLEGACY(pDevI->m_dwCurrentShaderHandle))
        {
            pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
        }
        else
        {
            CVShader* pShader = (CVShader*)pDevI->m_pVShaderArray->GetObject(pDevI->m_dwCurrentShaderHandle);
            if (pShader->m_dwFlags & CVShader::SOFTWARE)
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, FALSE);
            }
            else
            {
                pDevI->m_pStateSets->InsertVertexShader(pDevI->m_dwCurrentShaderHandle, TRUE);
            }
        }

        break;

    default:
        throw D3DERR_INVALIDCALL;
   }
   pDevI->m_pStateSets->EndSet();
   pDevI->m_pDDI->WriteStateSetToDevice(sbt);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::InsertCommand"

void CPureStateSet::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData,
                                  DWORD dwDataSize,
                                  BOOL bDriverCanHandle)
{
    switch(op)
    {
    case D3DDP2OP_FRONTENDDATA:
    case D3DDP2OP_FESETVB:
    case D3DDP2OP_FESETIB:
        m_FEOnlyBuffer.InsertCommand(op, pData, dwDataSize);
        break;
    default:
        m_DriverBuffer.InsertCommand(op, pData, dwDataSize);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::Execute"

void CPureStateSet::Execute(CD3DBase *pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        return;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_FRONTENDDATA:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                    HRESULT ret = pDevI->SetTexture(pData->wStage, pData->pTexture);
                    if (ret != D3D_OK)
                        throw ret;
                }
                break;
            }
        case D3DDP2OP_FESETVB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                    HRESULT ret = pDevI->SetStreamSource(pData->wStream, pData->pBuf, pData->dwStride);
                    if (ret != D3D_OK)
                        throw ret;
                }
                break;
            }
        case D3DDP2OP_FESETIB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                    HRESULT ret = pDevI->SetIndices(pData->pBuf, pData->dwBase);
                    if (ret != D3D_OK)
                        throw ret;
                }
                break;
            }
        case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                    if( pData->dwPaletteNumber != __INVALIDPALETTE )
                    {
                        HRESULT ret = pDevI->SetCurrentTexturePalette(pData->dwPaletteNumber);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::Capture"

void CPureStateSet::Capture(CD3DBase *pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        return;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_FRONTENDDATA:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    CBaseTexture* pTexOld = NULL;
                    CBaseTexture* pTexNew = NULL;
                    pTexOld = CBaseTexture::SafeCast(pData->pTexture);
                    if( pTexOld )
                        pTexOld->DecrementUseCount();
                    pTexNew = pDevI->m_lpD3DMappedTexI[pData->wStage];
                    if( pTexNew )
                        pTexNew->IncrementUseCount();
                    if (pDevI->m_lpD3DMappedTexI[pData->wStage] != 0)
                    {
                        switch(pDevI->m_lpD3DMappedTexI[pData->wStage]->GetBufferDesc()->Type)
                        {
                        case D3DRTYPE_TEXTURE:
                            pData->pTexture = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pTexNew));
                            break;
                        case D3DRTYPE_CUBETEXTURE:
                            pData->pTexture = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pTexNew));
                            break;
                        case D3DRTYPE_VOLUMETEXTURE:
                            pData->pTexture = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pTexNew));
                            break;
                        }
                    }
                    else
                    {
                        pData->pTexture = 0;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                }
                break;
            }
        case D3DDP2OP_FESETVB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETVB pData = (LPD3DHAL_DP2FESETVB)p;
                    if( pData->pBuf )
                    {
                        pData->pBuf->DecrementUseCount();
                    }
                    pData->pBuf = pDevI->m_pStream[pData->wStream].m_pVB;
                    if( pData->pBuf )
                    {
                        pData->pBuf->IncrementUseCount();
                    }
                    pData->dwStride = pDevI->m_pStream[pData->wStream].m_dwStride;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETVB));
                }
                break;
            }
        case D3DDP2OP_FESETIB:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETIB pData = (LPD3DHAL_DP2FESETIB)p;
                    pData->pBuf = pDevI->m_pIndexStream->m_pVBI;
                    if( pData->pBuf )
                    {
                        pData->pBuf->DecrementUseCount();
                    }
                    pData->dwBase = pDevI->m_pIndexStream->m_dwBaseIndex;
                    if( pData->pBuf )
                    {
                        pData->pBuf->IncrementUseCount();
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETIB));
                }
                break;
            }
        case D3DDP2OP_FESETPAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FESETPAL pData = (LPD3DHAL_DP2FESETPAL)p;
                    pData->dwPaletteNumber = pDevI->m_dwPalette;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FESETPAL));
                }
                break;
            }
#ifdef DBG
        default:
            DXGASSERT(FALSE);
#endif
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CPureStateSet::CreatePredefined"

void CPureStateSet::CreatePredefined(CD3DBase *pDevI, D3DSTATEBLOCKTYPE sbt)
{
    DWORD i;
    // The device is not pure, so we can cast
    switch(sbt)
    {
    case (D3DSTATEBLOCKTYPE)0:
        break;
    case D3DSBT_ALL:
        // Capture textures
        for (i = 0; i < pDevI->m_dwMaxTextureBlendStages; i++)
        {
            IDirect3DBaseTexture8 *pTex;
            if (pDevI->m_lpD3DMappedTexI[i] != 0)
            {
                switch(pDevI->m_lpD3DMappedTexI[i]->GetBufferDesc()->Type)
                {
                case D3DRTYPE_TEXTURE:
                    pTex = static_cast<IDirect3DTexture8*>(static_cast<CMipMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_CUBETEXTURE:
                    pTex = static_cast<IDirect3DCubeTexture8*>(static_cast<CCubeMap*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                case D3DRTYPE_VOLUMETEXTURE:
                    pTex = static_cast<IDirect3DVolumeTexture8*>(static_cast<CMipVolume*>(pDevI->m_lpD3DMappedTexI[i]));
                    break;
                }
            }
            else
            {
                pTex = 0;
            }
            pDevI->m_pStateSets->InsertTexture(i, pTex);
        }

        // Capture streams
        for (i = 0; i < pDevI->m_dwNumStreams; i++)
        {
            pDevI->m_pStateSets->InsertStreamSource(i, pDevI->m_pStream[i].m_pVB, pDevI->m_pStream[i].m_dwStride);
        }
        pDevI->m_pStateSets->InsertIndices(pDevI->m_pIndexStream->m_pVBI, pDevI->m_pIndexStream->m_dwBaseIndex);

        break;

    case D3DSBT_PIXELSTATE:
        break;

    case D3DSBT_VERTEXSTATE:
        break;

    default:
        throw D3DERR_INVALIDCALL;
    }
    pDevI->m_pStateSets->EndSet();
        DWORD DeviceHandle;
    pDevI->m_pStateSets->CreateNewDeviceHandle(&DeviceHandle);
    pDevI->m_pDDI->InsertStateSetOp(D3DHAL_STATESETCREATE, DeviceHandle, sbt);
}
//=====================================================================
//      CStateSetBuffer interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSetBuffer::InsertCommand"

void CStateSetBuffer::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData, DWORD dwDataSize)
{
    const DWORD GROWSIZE = 1024;
    if (m_pDP2CurrCommand != 0 && m_pDP2CurrCommand->bCommand == op)
    {
        if (dwDataSize + m_dwCurrentSize <= m_dwBufferSize)
        {
            ++m_pDP2CurrCommand->wStateCount;
            memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
            m_dwCurrentSize += dwDataSize;
            return;
        }
    }
    // Check for space
    if (sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize > m_dwBufferSize)
    {
        // We need to grow the buffer
        DWORD dwNewBufferSize = max(m_dwBufferSize + GROWSIZE, sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize);
        BYTE *pTmp = new BYTE[dwNewBufferSize];
        if (pTmp == NULL)
        {
            D3D_ERR("Not enough memory to create state block buffer");
            throw E_OUTOFMEMORY;
        }
        if (m_pBuffer)
        {
            memcpy(pTmp, m_pBuffer, m_dwCurrentSize);
            delete [] m_pBuffer;
        }
        m_pBuffer = pTmp;
        m_dwBufferSize = dwNewBufferSize;
    }
    // Add new instruction
    m_pDP2CurrCommand = (LPD3DHAL_DP2COMMAND)(m_pBuffer + m_dwCurrentSize);
    m_pDP2CurrCommand->bCommand = op;
    m_pDP2CurrCommand->bReserved = 0;
    m_pDP2CurrCommand->wStateCount = 1;
    m_dwCurrentSize += sizeof(D3DHAL_DP2COMMAND);
    memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
    m_dwCurrentSize += dwDataSize;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\pshader.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pshader.cpp
 *  Content:    pixel shader runtime object init, including basic parsing
 *              of pixel shader instructions
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "fe.h"
#include "ddibase.h"
#include "vvm.h"

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreatePixelShader"

HRESULT
CPShader::Initialize(CONST DWORD* pCode, D3DDEVTYPE DevType)
{
    // get shader code sizes
    DWORD dwCodeAndCommentSize;
    DWORD dwCodeOnlySize;
    HRESULT hr = ComputeShaderCodeSize(pCode, &dwCodeOnlySize, &dwCodeAndCommentSize,
                                        &m_dwNumConstDefs);
    if (hr != S_OK)
        return hr;

    // copy original code
    m_dwCodeSizeOrig = dwCodeAndCommentSize;
    m_pCodeOrig = new DWORD[m_dwCodeSizeOrig >> 2];
    if (NULL == m_pCodeOrig)
    {
        D3D_ERR("Cannot allocate memory for shader");
        return E_OUTOFMEMORY;
    }
    memcpy( m_pCodeOrig, pCode, m_dwCodeSizeOrig );

    if( m_dwNumConstDefs )
    {
        m_pConstDefs = new CONST_DEF[m_dwNumConstDefs];
        if (NULL == m_pConstDefs)
        {
            D3D_ERR("Cannot allocate memory for shader");
            return E_OUTOFMEMORY;
        }
    }

    // strip comments before sending on if (not CHECKED) or HAL.
    // Also, store def declarations in CPShader, and strip them.
    BOOL bIsCheckedBuild =
#if DBG
        TRUE;
#else
        FALSE;
#endif
    BOOL  bStripComments = (!bIsCheckedBuild) || (DevType == D3DDEVTYPE_HAL);
    if ( bStripComments )
    {
        // strip comments from version to pass on to DDI
        m_dwCodeSize = dwCodeOnlySize;
    }
    else
    {
        // pass comments through
        m_dwCodeSize = m_dwCodeSizeOrig;
    }
    m_pCode = new DWORD[m_dwCodeSize >> 2];
    if (NULL == m_pCode)
    {
        D3D_ERR("Cannot allocate memory for shader");
        return E_OUTOFMEMORY;
    }
    DWORD* pDst = m_pCode;
    CONST DWORD* pSrc = pCode;
    DWORD dwCurrConstDef = 0;
    *pDst++ = *pSrc++; // copy version
    while (*pSrc != 0x0000FFFF)
    {
        if(IsInstructionToken(*pSrc))
        {
            DWORD opCode = (*pSrc) & D3DSI_OPCODE_MASK;
            if (opCode == D3DSIO_COMMENT )
            {
                UINT DWordSize = ((*pSrc)&D3DSI_COMMENTSIZE_MASK)>>D3DSI_COMMENTSIZE_SHIFT;
                // strip comments from version to pass on to DDI
                if( !bStripComments )
                {
                    memcpy( pDst, pSrc, (DWordSize + 1)*sizeof(DWORD) );
                    pDst += (DWordSize+1);
                }
                pSrc += (DWordSize+1);  // comment + instruction token
            }
            else if (opCode == D3DSIO_DEF)
            {
                *pDst++ = *pSrc++;
                DXGASSERT(m_pConstDefs && dwCurrConstDef < m_dwNumConstDefs);

                // Store reg. number
                m_pConstDefs[dwCurrConstDef].RegNum = (*pSrc & D3DSP_REGNUM_MASK);
                *pDst++ = *pSrc++;

                // Store the const vector
                memcpy( m_pConstDefs[dwCurrConstDef].f,pSrc,4*sizeof(DWORD) );
                memcpy( pDst,pSrc,4*sizeof(DWORD) );
                pSrc += 4;
                pDst += 4;
                dwCurrConstDef++;
            }
            else
            {
                *pDst++ = *pSrc++;
            }
        }
        else
        {
             *pDst++ = *pSrc++;
        }
    }
    *pDst++ = *pSrc++; // copy END

    DXGASSERT(dwCurrConstDef == m_dwNumConstDefs);

    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetPixelShaderConstant"

HRESULT D3DAPI
CD3DHal::GetPixelShaderConstant(DWORD dwRegisterAddress,
                                LPVOID lpvConstantData,
                                DWORD dwConstantCount)
{
    API_ENTER(this);
#if DBG
    // Validate Parameters
    if (!VALID_WRITEPTR(lpvConstantData, 4*sizeof(D3DVALUE)*dwConstantCount))
    {
        D3D_ERR("Invalid constant data pointer. GetPixelShaderConstant failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    GetPixelShaderConstantI( dwRegisterAddress, dwConstantCount,
                             lpvConstantData );
    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetPixelShaderFast"

HRESULT D3DAPI
CD3DHal::SetPixelShaderFast(DWORD dwHandle)
{
    try
    {
#if DBG
        CheckPixelShaderHandle(dwHandle);
#endif
        // Update constants (if any were defined in the shader code)
        if( dwHandle )
        {
            CPShader* pShader = (CPShader*)m_pPShaderArray->GetObject(dwHandle);
            for(UINT i = 0; i < pShader->m_dwNumConstDefs; i++ )
            {
                CONST_DEF* pConstDef = &pShader->m_pConstDefs[i];
                memcpy(&(m_PShaderConstReg[pConstDef->RegNum]), pConstDef->f, 4*sizeof(D3DVALUE));
            }
        }

        // No redundant handle check because shader may have embedded constant definitions which
        // must always be applied.
        if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
            m_pDDI->SetPixelShader(dwHandle);

        m_dwCurrentPixelShaderHandle = dwHandle;
    }
    catch(HRESULT hr)
    {
        D3D_ERR("SetPixelShader failed.");
        m_dwCurrentPixelShaderHandle = 0;
        return hr;
    }
   return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetPixelShaderConstantFast"

HRESULT D3DAPI
CD3DHal::SetPixelShaderConstantFast(DWORD Register, CONST VOID* pData,
                                    DWORD count)
{

#if DBG
    // Validate Parameters
    if (!VALID_PTR(pData, sizeof(DWORD) * count))
    {
        D3D_ERR("Invalid constant data pointer. SetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if(Register >= D3DPS_CONSTREG_MAX_DX8)
    {
        D3D_ERR("Invalid Constant Register number. SetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
    if( (Register + count) > D3DPS_CONSTREG_MAX_DX8 )
    {
        D3D_ERR("Not that many constant registers in the pixel machine. SetPixelShader failed.");
        return D3DERR_INVALIDCALL;
    }
#endif

    // Cache the constants in the CPShader structure.
    memcpy(&(m_PShaderConstReg[Register]),  pData, count*4*sizeof(D3DVALUE));
    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        try
        {
            m_pDDI->SetPixelShaderConstant(Register, pData, count);
        }
        catch(HRESULT hr)
        {
            D3D_ERR("SetPixelShaderConstant failed.");
            return hr;
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetPixelShaderConstantI"

void
CD3DHal::GetPixelShaderConstantI(DWORD Register, DWORD count, LPVOID pData )
{
    // Cache the constants in the CPShader structure.
    memcpy( pData, &(m_PShaderConstReg[Register]), count*4*sizeof(D3DVALUE) );
}
//-----------------------------------------------------------------------------
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\npatch.cpp ===
/*============================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       npatch.cpp
 *  Content:    Consersion of NPatches to Rect-Patches
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
UINT CVertexPointer::Stride[__NUMELEMENTS];
UINT CVertexPointer::NumUsedElements;
UINT CVertexPointer::DataType[__NUMELEMENTS];
//-----------------------------------------------------------------------------
static const float Tension  = 1.0f/3.0f;
static const float OneOver3 = 1.0f/3.0f;
//-----------------------------------------------------------------------------
struct UVW
{
    float u, v, w, uu, vv, ww, uv, uw, vw;
};
static UVW g_uvw[10];
//-----------------------------------------------------------------------------
CNPatch2TriPatch::CNPatch2TriPatch()
{
    memset(this, 0, sizeof(this));
   // Write only streams with RTPatches usage
    for (int i=0; i < __NUMELEMENTS; i++)
        m_pOutStream[i] = new CTLStream(TRUE, D3DUSAGE_RTPATCHES); 
    int k = 0;
    for(int vv = 3; vv >= 0; --vv)
    for(int uu = 0; uu < 4 - vv; ++uu)
    {
        int ww = 3 - uu - vv;
        float u = uu * OneOver3;
        float v = vv * OneOver3;
        float w = ww * OneOver3;
        g_uvw[k].u = u;
        g_uvw[k].v = v;
        g_uvw[k].w = w;
        g_uvw[k].uu = u*u;
        g_uvw[k].vv = v*v;
        g_uvw[k].ww = w*w;
        g_uvw[k].uv = u*v;
        g_uvw[k].uw = u*w;
        g_uvw[k].vw = v*w;
        k++;
    }
}
//-----------------------------------------------------------------------------
void ComputeNormalControlPoint(D3DVECTOR* cp, 
                               float* pVi, float* pVj, 
                               float* pNi, float* pNj)
{
    D3DVECTOR Pji;
    D3DVECTOR Nij;
    VecSub(*(D3DVECTOR*)pVj, *(D3DVECTOR*)pVi, Pji);
    VecAdd(*(D3DVECTOR*)pNj, *(D3DVECTOR*)pNi, Nij);
    FLOAT v = 2.0f * VecDot(Pji, Nij) / VecDot(Pji, Pji);
    Pji.x *= v;
    Pji.y *= v;
    Pji.z *= v;
    VecSub(Nij, Pji, *cp);

    // Now go from polynomial coefficients to Bezier control points

    cp->x *= 0.5f;
    cp->y *= 0.5f;
    cp->z *= 0.5f;
}
//-----------------------------------------------------------------------------
CNPatch2TriPatch::~CNPatch2TriPatch()
{
    for (int i=0; i < __NUMELEMENTS; i++)
        delete m_pOutStream[i];
}
//-----------------------------------------------------------------------------
// Convert NPatch to Rect-Patch:
// 
void CNPatch2TriPatch::MakeRectPatch(const CVertexPointer& pV0, 
                                     const CVertexPointer& pV2, 
                                     const CVertexPointer& pV1)
{
    float t, Edge[3], B[10][3];
    float n0[3];
    float n1[3];
    float n2[3];

    float *p0 = (float*)pV0.pData[m_PositionIndex];
    float *p1 = (float*)pV1.pData[m_PositionIndex];
    float *p2 = (float*)pV2.pData[m_PositionIndex];
    n0[0] = ((float*)pV0.pData[m_NormalIndex])[0];
    n0[1] = ((float*)pV0.pData[m_NormalIndex])[1];
    n0[2] = ((float*)pV0.pData[m_NormalIndex])[2];
    n1[0] = ((float*)pV1.pData[m_NormalIndex])[0];
    n1[1] = ((float*)pV1.pData[m_NormalIndex])[1];
    n1[2] = ((float*)pV1.pData[m_NormalIndex])[2];
    n2[0] = ((float*)pV2.pData[m_NormalIndex])[0];
    n2[1] = ((float*)pV2.pData[m_NormalIndex])[1];
    n2[2] = ((float*)pV2.pData[m_NormalIndex])[2];
    
    // Coefficients to interpolate quadratic normals
    D3DVECTOR N002;
    D3DVECTOR N020;
    D3DVECTOR N200;
    D3DVECTOR N110;
    D3DVECTOR N101;
    D3DVECTOR N011;

    // Convert NPatch to Tri-Patch first

    if (m_PositionOrder == D3DORDER_CUBIC)
    {
        B[0][0] = p0[0];
        B[0][1] = p0[1];
        B[0][2] = p0[2];
        B[6][0] = p1[0];
        B[6][1] = p1[1];
        B[6][2] = p1[2];
        B[9][0] = p2[0];
        B[9][1] = p2[1];
        B[9][2] = p2[2];
    
        Edge[0] = p1[0] - p0[0];
        Edge[1] = p1[1] - p0[1];
        Edge[2] = p1[2] - p0[2];
        t = Edge[0] * n0[0] + Edge[1] * n0[1] + Edge[2] * n0[2];
        B[1][0] = p0[0] + (Edge[0] - n0[0] * t) * Tension;
        B[1][1] = p0[1] + (Edge[1] - n0[1] * t) * Tension;
        B[1][2] = p0[2] + (Edge[2] - n0[2] * t) * Tension;
        Edge[0] = p0[0] - p1[0];
        Edge[1] = p0[1] - p1[1];
        Edge[2] = p0[2] - p1[2];
        t = Edge[0] * n1[0] + Edge[1] * n1[1] + Edge[2] * n1[2];
        B[3][0] = p1[0] + (Edge[0] - n1[0] * t) * Tension;
        B[3][1] = p1[1] + (Edge[1] - n1[1] * t) * Tension;
        B[3][2] = p1[2] + (Edge[2] - n1[2] * t) * Tension;
        Edge[0] = p2[0] - p1[0];
        Edge[1] = p2[1] - p1[1];
        Edge[2] = p2[2] - p1[2];
        t = Edge[0] * n1[0] + Edge[1] * n1[1] + Edge[2] * n1[2];
        B[7][0] = p1[0] + (Edge[0] - n1[0] * t) * Tension;
        B[7][1] = p1[1] + (Edge[1] - n1[1] * t) * Tension;
        B[7][2] = p1[2] + (Edge[2] - n1[2] * t) * Tension;
        Edge[0] = p1[0] - p2[0];
        Edge[1] = p1[1] - p2[1];
        Edge[2] = p1[2] - p2[2];
        t = Edge[0] * n2[0] + Edge[1] * n2[1] + Edge[2] * n2[2];
        B[8][0] = p2[0] + (Edge[0] - n2[0] * t) * Tension;
        B[8][1] = p2[1] + (Edge[1] - n2[1] * t) * Tension;
        B[8][2] = p2[2] + (Edge[2] - n2[2] * t) * Tension;
        Edge[0] = p2[0] - p0[0];
        Edge[1] = p2[1] - p0[1];
        Edge[2] = p2[2] - p0[2];
        t = Edge[0] * n0[0] + Edge[1] * n0[1] + Edge[2] * n0[2];
        B[2][0] = p0[0] + (Edge[0] - n0[0] * t) * Tension;
        B[2][1] = p0[1] + (Edge[1] - n0[1] * t) * Tension;
        B[2][2] = p0[2] + (Edge[2] - n0[2] * t) * Tension;
        Edge[0] = p0[0] - p2[0];
        Edge[1] = p0[1] - p2[1];
        Edge[2] = p0[2] - p2[2];
        t = Edge[0] * n2[0] + Edge[1] * n2[1] + Edge[2] * n2[2];
        B[5][0] = p2[0] + (Edge[0] - n2[0] * t) * Tension;
        B[5][1] = p2[1] + (Edge[1] - n2[1] * t) * Tension;
        B[5][2] = p2[2] + (Edge[2] - n2[2] * t) * Tension;

        B[4][0] = (B[1][0] + B[2][0] + B[3][0] + B[5][0] + B[7][0] + B[8][0]) / 4.0f - (B[0][0] + B[6][0] + B[9][0]) / 6.0f;
        B[4][1] = (B[1][1] + B[2][1] + B[3][1] + B[5][1] + B[7][1] + B[8][1]) / 4.0f - (B[0][1] + B[6][1] + B[9][1]) / 6.0f;
        B[4][2] = (B[1][2] + B[2][2] + B[3][2] + B[5][2] + B[7][2] + B[8][2]) / 4.0f - (B[0][2] + B[6][2] + B[9][2]) / 6.0f;
    }
    if (m_NormalOrder == D3DORDER_QUADRATIC)
    {
        // Compute central control point
        if (m_bNormalizeNormals)
        {
            VecNormalizeFast(*n0);
            VecNormalizeFast(*n1);
            VecNormalizeFast(*n2);
        }
        N002 = *(D3DVECTOR*)n1;
        N020 = *(D3DVECTOR*)n0;
        N200 = *(D3DVECTOR*)n2;

        // Compute edge control points

        ComputeNormalControlPoint(&N110, p0, p2, n0, n2);
        ComputeNormalControlPoint(&N101, p2, p1, n2, n1);
        ComputeNormalControlPoint(&N011, p1, p0, n1, n0);
    }

    float CP[__NUMELEMENTS*4][10];      // Computed tri-patch control pointes
    int iCP;                            // Float value index in the control point array
    for(int k = 0; k < 10; k++)
    {
        iCP = 0;                        
        const float U = g_uvw[k].u;
        const float V = g_uvw[k].v;
        const float W = g_uvw[k].w;

        for (UINT iElement=0; iElement < CVertexPointer::NumUsedElements; iElement++)
        {
            if (iElement == m_PositionIndex)
            {
                if (m_PositionOrder == D3DORDER_CUBIC)
                {
                    CP[iCP++][k] = B[k][0];
                    CP[iCP++][k] = B[k][1];
                    CP[iCP++][k] = B[k][2];
                }
                else
                {
                    CP[iCP++][k] = p2[0] * U + p0[0] * V + p1[0] * W;
                    CP[iCP++][k] = p2[1] * U + p0[1] * V + p1[1] * W;
                    CP[iCP++][k] = p2[2] * U + p0[2] * V + p1[2] * W;
                }
            }
            else
            if (iElement == m_NormalIndex)
            {
                if (m_NormalOrder == D3DORDER_QUADRATIC)
                {
                    D3DVECTOR Q;
                    // Do degree elevation from quadratic to cubic
                    switch (k)
                    {
                    case 0:
                        Q.x = N020.x;
                        Q.y = N020.y;
                        Q.z = N020.z;
                        break;
                    case 1:
                        Q.x = (2.0f*N011.x + N020.x) * OneOver3;
                        Q.y = (2.0f*N011.y + N020.y) * OneOver3;
                        Q.z = (2.0f*N011.z + N020.z) * OneOver3;
                        break;
                    case 2:
                        Q.x = (2.0f*N110.x + N020.x) * OneOver3;
                        Q.y = (2.0f*N110.y + N020.y) * OneOver3;
                        Q.z = (2.0f*N110.z + N020.z) * OneOver3;
                        break;
                    case 3:
                        Q.x = (2.0f*N011.x + N002.x) * OneOver3;
                        Q.y = (2.0f*N011.y + N002.y) * OneOver3;
                        Q.z = (2.0f*N011.z + N002.z) * OneOver3;
                        break;
                    case 4:
                        Q.x = (N011.x + N101.x + N110.x) * OneOver3;
                        Q.y = (N011.y + N101.y + N110.y) * OneOver3;
                        Q.z = (N011.z + N101.z + N110.z) * OneOver3;
                        break;
                    case 5:
                        Q.x = (2.0f*N110.x + N200.x) * OneOver3;
                        Q.y = (2.0f*N110.y + N200.y) * OneOver3;
                        Q.z = (2.0f*N110.z + N200.z) * OneOver3;
                        break;
                    case 6:
                        Q.x = N002.x;
                        Q.y = N002.y;
                        Q.z = N002.z;
                        break;
                    case 7:
                        Q.x = (2.0f*N101.x + N002.x) * OneOver3;
                        Q.y = (2.0f*N101.y + N002.y) * OneOver3;
                        Q.z = (2.0f*N101.z + N002.z) * OneOver3;
                        break;
                    case 8:
                        Q.x = (2.0f*N101.x + N200.x) * OneOver3;
                        Q.y = (2.0f*N101.y + N200.y) * OneOver3;
                        Q.z = (2.0f*N101.z + N200.z) * OneOver3;
                        break;
                    case 9:
                        Q.x = N200.x;
                        Q.y = N200.y;
                        Q.z = N200.z;
                        break;
                    }
                    CP[iCP++][k] = Q.x;
                    CP[iCP++][k] = Q.y;
                    CP[iCP++][k] = Q.z;
                }
                else
                {
                    CP[iCP++][k] = n2[0] * U + n0[0] * V + n1[0] * W;
                    CP[iCP++][k] = n2[1] * U + n0[1] * V + n1[1] * W;
                    CP[iCP++][k] = n2[2] * U + n0[2] * V + n1[2] * W;
                }
            }
            else
            {
                switch(CVertexPointer::DataType[iElement])
                {
                case D3DVSDT_FLOAT1:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    break;
                case D3DVSDT_FLOAT2:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[1] * U + 
                                   ((float*)pV0.pData[iElement])[1] * V + 
                                   ((float*)pV1.pData[iElement])[1] * W;
                    break;
                case D3DVSDT_FLOAT3:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[1] * U + 
                                   ((float*)pV0.pData[iElement])[1] * V + 
                                   ((float*)pV1.pData[iElement])[1] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[2] * U + 
                                   ((float*)pV0.pData[iElement])[2] * V + 
                                   ((float*)pV1.pData[iElement])[2] * W;
                    break;
                case D3DVSDT_FLOAT4:
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[0] * U + 
                                   ((float*)pV0.pData[iElement])[0] * V + 
                                   ((float*)pV1.pData[iElement])[0] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[1] * U + 
                                   ((float*)pV0.pData[iElement])[1] * V + 
                                   ((float*)pV1.pData[iElement])[1] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[2] * U + 
                                   ((float*)pV0.pData[iElement])[2] * V + 
                                   ((float*)pV1.pData[iElement])[2] * W;
                    CP[iCP++][k] = ((float*)pV2.pData[iElement])[3] * U + 
                                   ((float*)pV0.pData[iElement])[3] * V + 
                                   ((float*)pV1.pData[iElement])[3] * W;
                    break;
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_UBYTE4:
                    DWORD c;
                    c = *(DWORD*)pV0.pData[iElement];
                    float r[3], g[3], b[3], a[3];
                    r[0] = float(c & 0xFF);
                    g[0] = float((c >> 8) & 0xFF);
                    b[0] = float((c >> 16) & 0xFF);
                    a[0] = float((c >> 24) & 0xFF);
                    c = *(DWORD*)pV1.pData[iElement];
                    r[1] = float(c & 0xFF);
                    g[1] = float((c >> 8) & 0xFF);
                    b[1] = float((c >> 16) & 0xFF);
                    a[1] = float((c >> 24) & 0xFF);
                    c = *(DWORD*)pV2.pData[iElement];
                    r[2] = float(c & 0xFF);
                    g[2] = float((c >> 8) & 0xFF);
                    b[2] = float((c >> 16) & 0xFF);
                    a[2] = float((c >> 24) & 0xFF);
                    CP[iCP++][k] = r[2] * U + r[0] * V + r[1] * W;
                    CP[iCP++][k] = g[2] * U + g[0] * V + g[1] * W;
                    CP[iCP++][k] = b[2] * U + b[0] * V + b[1] * W;
                    CP[iCP++][k] = a[2] * U + a[0] * V + a[1] * W;
                    break;
                case D3DVSDT_SHORT2:
                    CP[iCP++][k]= (float)(
                                        ((short*)pV2.pData[iElement])[0] * U + 
                                        ((short*)pV0.pData[iElement])[0] * V + 
                                        ((short*)pV1.pData[iElement])[0] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[1] * U + 
                                        ((short*)pV0.pData[iElement])[1] * V + 
                                        ((short*)pV1.pData[iElement])[1] * W);
                    break;
                case D3DVSDT_SHORT4:
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[0] * U + 
                                        ((short*)pV0.pData[iElement])[0] * V + 
                                        ((short*)pV1.pData[iElement])[0] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[1] * U + 
                                        ((short*)pV0.pData[iElement])[1] * V + 
                                        ((short*)pV1.pData[iElement])[1] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[2] * U + 
                                        ((short*)pV0.pData[iElement])[2] * V + 
                                        ((short*)pV1.pData[iElement])[2] * W);
                    CP[iCP++][k] = (float)(
                                        ((short*)pV2.pData[iElement])[3] * U + 
                                        ((short*)pV0.pData[iElement])[3] * V + 
                                        ((short*)pV1.pData[iElement])[3] * W);
                    break;
                default: DXGASSERT(FALSE);
                }
            }
        }
    }

    // Now convert Tri-Patch to Rect-Patch by transforming 10 tri-patch control
    // points to 16 rect-patch control points

    float CPR[16][__NUMELEMENTS*4];      // Computed rect-patch control pointes
    {
        for (int i=0; i < iCP; i++)
        {
            // First row - copy first point 4 times
            CPR[0][i] = CPR[1][i] = 
            CPR[2][i] = CPR[3][i] = CP[i][0];

            // 2nd row
            float v1 = CP[i][1];
            float v2 = CP[i][2];
            CPR[ 4][i] = v1;
            CPR[ 5][i] = (v1 * 2.0f + v2       ) * OneOver3;
            CPR[ 6][i] = (v1        + v2 * 2.0f) * OneOver3;
            CPR[ 7][i] = v2;

            // 3rd row
            CPR[ 8][i] = CP[i][3];
            CPR[ 9][i] = (CP[i][3]        + CP[i][4] * 2.0f) * OneOver3;
            CPR[10][i] = (CP[i][4] * 2.0f + CP[i][5]       ) * OneOver3;
            CPR[11][i] = CP[i][5];

            // 4th row - copy all elements
            CPR[12][i] = CP[i][6];
            CPR[13][i] = CP[i][7];
            CPR[14][i] = CP[i][8];
            CPR[15][i] = CP[i][9];
        }
    }

    // Output the result

    {
        for (int i=0; i < 16; i++)
        {
            UINT k = 0; 
            for (UINT iElement=0; iElement < CVertexPointer::NumUsedElements; iElement++)
            {
                float* pout = (float*)m_OutVertex.pData[iElement];
                switch(CVertexPointer::DataType[iElement])
                {
                case D3DVSDT_FLOAT1:
                    pout[0] = CPR[i][k++];
                    break;
                case D3DVSDT_FLOAT2:
                    pout[0] = CPR[i][k++];
                    pout[1] = CPR[i][k++];
                    break;
                case D3DVSDT_FLOAT3:
                    pout[0] = CPR[i][k++];
                    pout[1] = CPR[i][k++];
                    pout[2] = CPR[i][k++];
                    break;
                case D3DVSDT_FLOAT4:
                    pout[0] = CPR[i][k++];
                    pout[1] = CPR[i][k++];
                    pout[2] = CPR[i][k++];
                    pout[3] = CPR[i][k++];
                    break;
                case D3DVSDT_D3DCOLOR:
                case D3DVSDT_UBYTE4:
                    {
                        DWORD c;
                        float r = CPR[i][k++];
                        float g = CPR[i][k++];
                        float b = CPR[i][k++];
                        float a = CPR[i][k++];
                        c  = DWORD(r);
                        c |= DWORD(g) << 8;
                        c |= DWORD(b) << 16;
                        c |= DWORD(a) << 24;
                        *(DWORD*)pout = c;
                    }
                    break;
                case D3DVSDT_SHORT2:
                    ((short*)pout)[0] = (short)(CPR[i][k++]);
                    ((short*)pout)[1] = (short)(CPR[i][k++]);
                    break;
                case D3DVSDT_SHORT4:
                    ((short*)pout)[0] = (short)(CPR[i][k++]);
                    ((short*)pout)[1] = (short)(CPR[i][k++]);
                    ((short*)pout)[2] = (short)(CPR[i][k++]);
                    ((short*)pout)[3] = (short)(CPR[i][k++]);
                    break;
                default: DXGASSERT(FALSE);
                }
            }
            m_OutVertex++;
        }
    }
}
//-----------------------------------------------------------------------------
void DrawPatches(CD3DHal* pDevice, UINT PrimitiveCount)
{
    // Unlock output vertex buffers 
    if (D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
    {
        pDevice->m_pConvObj->m_pOutStream[0]->m_pVB->Unlock();
    }
    else
    {
        CVDeclaration* pDecl = &pDevice->m_pCurrentShader->m_Declaration;
        CVStreamDecl* pStreamDecl = pDevice->m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while (pStreamDecl)
        {
            pDevice->m_pConvObj->m_pOutStream[pStreamDecl->m_dwStreamIndex]->m_pVB->Unlock();
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }
     }

    // Draw rect patches
    float numSegs[4];
    numSegs[0] = 
    numSegs[1] = 
    numSegs[2] = 
    numSegs[3] = *(float*)&pDevice->rstates[D3DRS_PATCHSEGMENTS];
    D3DRECTPATCH_INFO info;
    info.StartVertexOffsetWidth = pDevice->m_pConvObj->m_FirstVertex;
    info.StartVertexOffsetHeight = 0;
    info.Width = 4;
    info.Height = 4;
    info.Stride = 4; // verticies to next row of verticies
    info.Basis = D3DBASIS_BEZIER;
    info.Order = D3DORDER_CUBIC;

    for (UINT i = PrimitiveCount; i > 0; i--)
    {
        pDevice->DrawRectPatch(0, numSegs, &info);
        info.StartVertexOffsetWidth += 16;
    }

    // Restore input vertex streams
    if (D3DVSD_ISLEGACY(pDevice->m_dwCurrentShaderHandle))
    {
        // Always need to call SetStreamSource to decrease reference count of 
        // the internal VB buffer
        pDevice->SetStreamSource(0, pDevice->m_pConvObj->m_InpStream[0].m_pVB, 
                                 CVertexPointer::Stride[0]);
        if (pDevice->m_pConvObj->m_InpStream[0].m_pVB)
        {
            // Remove additional ref count, because the stream is set 
            // second time
            pDevice->m_pConvObj->m_InpStream[0].m_pVB->Release();
            pDevice->m_pConvObj->m_InpStream[0].m_pVB = NULL;
        }
    }
    else
    {
        CVDeclaration* pDecl = &pDevice->m_pCurrentShader->m_Declaration;
        CVStreamDecl* pStreamDecl = pDevice->m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while (pStreamDecl)
        {
            UINT si = pStreamDecl->m_dwStreamIndex;
            UINT Stride = pStreamDecl->m_dwStride;
            CVStream* pStream = &pDevice->m_pConvObj->m_InpStream[si];
            // Always need to call SetStreamSource to decrease reference count 
            // of the internal VB buffer
            pDevice->SetStreamSource(si, pStream->m_pVB, Stride);
            if (pStream->m_pVB)
            {
                // Remove additional ref count, because the stream is set second 
                // time
                pStream->m_pVB->Release();
                pStream->m_pVB = NULL;
            }
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }
    }
}
//-----------------------------------------------------------------------------
void CD3DHal_DrawNPatch(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                        UINT StartVertex, UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);

    // Draw as usual for non-triangle primitive types
    if (PrimitiveType < D3DPT_TRIANGLELIST)
    {
        (*pDevice->m_pfnDrawPrimFromNPatch)(pBaseDevice, PrimitiveType, 
                                            StartVertex, PrimitiveCount);
        // m_pfnDrawPrim could be switched to fast path, so we need to restore it
        pDevice->m_pfnDrawPrim = CD3DHal_DrawNPatch;
        return;
    }

#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pDevice->ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, nVer,
                           FALSE);
#endif

    pDevice->PrepareNPatchConversion(PrimitiveCount, StartVertex);

    // Go through triangles and generate tri-patches

    CNPatch2TriPatch* pConvObj = pDevice->m_pConvObj;
    switch( PrimitiveType )
    {
    case D3DPT_TRIANGLELIST:
        {
            for (UINT i = PrimitiveCount; i > 0; i--)
            {
                CVertexPointer pV0 = pConvObj->m_InpVertex; 
                pConvObj->m_InpVertex++;
                CVertexPointer pV1 = pConvObj->m_InpVertex; 
                pConvObj->m_InpVertex++;
                CVertexPointer pV2 = pConvObj->m_InpVertex; 
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.   
            CVertexPointer pV0;
            CVertexPointer pV1 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;
            CVertexPointer pV2 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;

            for (UINT i =PrimitiveCount; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pConvObj->m_InpVertex;
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pConvObj->m_InpVertex;
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pConvObj->m_InpVertex;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            CVertexPointer pV0;
            CVertexPointer pV1;
            CVertexPointer pV2;
            pV2 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;
            // Preload initial pV0.
            pV1 = pConvObj->m_InpVertex;
            pConvObj->m_InpVertex++;
            for (UINT i = PrimitiveCount; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pConvObj->m_InpVertex;
                pConvObj->m_InpVertex++;
                pConvObj->MakeRectPatch(pV0, pV1, pV2);
            }
        }
        break;
    default:
        DXGASSERT(FALSE);
    }

    pDevice->m_pDDI->SetWithinPrimitive(TRUE);
    DrawPatches(pDevice, PrimitiveCount);
    pDevice->m_pDDI->SetWithinPrimitive(FALSE);
}
//-----------------------------------------------------------------------------
void CD3DHal_DrawIndexedNPatch(CD3DBase* pBaseDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseIndex,
                               UINT MinIndex, UINT NumVertices,
                               UINT StartIndex,
                               UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);

    // Draw as usual for non-triangle primitive types
    if (PrimitiveType < D3DPT_TRIANGLELIST)
    {
        (*pDevice->m_pfnDrawIndexedPrimFromNPatch)(pBaseDevice, PrimitiveType, 
                                          BaseIndex, MinIndex, NumVertices, 
                                          StartIndex, PrimitiveCount);
        // m_pfnDrawIndexedPrim could be switched to fast path, so we 
        // need to restore it
        pDevice->m_pfnDrawIndexedPrim = CD3DHal_DrawIndexedNPatch;
        return;
    }

#if DBG
    pDevice->ValidateDraw2(PrimitiveType, MinIndex + BaseIndex, PrimitiveCount, NumVertices,
                           TRUE, StartIndex);
#endif

    pDevice->PrepareNPatchConversion(PrimitiveCount, BaseIndex);

    // Go through triangles and generate tri-patches

    CNPatch2TriPatch* pConvObj = pDevice->m_pConvObj;

    if (pDevice->m_pIndexStream->m_dwStride == 2)
    {
        WORD* pIndices = (WORD*)pDevice->m_pIndexStream->Data() + StartIndex;
        switch( PrimitiveType )
        {
        case D3DPT_TRIANGLELIST:
            {
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0;
                    CVertexPointer pV1;
                    CVertexPointer pV2;
                    pV0.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLESTRIP:
            {
                CVertexPointer pV0;
                CVertexPointer pV1;
                CVertexPointer pV2;
                // Get initial vertex values.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));

                for (UINT i = PrimitiveCount; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLEFAN:
            {
                CVertexPointer pV1;
                CVertexPointer pV2;
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                // Preload initial pV0.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0 = pV1;
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }
            }
            break;
        default:
            DXGASSERT(FALSE);
        }
    }
    else
    {
        DWORD* pIndices = (DWORD*)pDevice->m_pIndexStream->Data() + StartIndex;
        switch( PrimitiveType )
        {
        case D3DPT_TRIANGLELIST:
            {
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0;
                    CVertexPointer pV1;
                    CVertexPointer pV2;
                    pV0.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLESTRIP:
            {
                CVertexPointer pV0;
                CVertexPointer pV1;
                CVertexPointer pV2;
                // Get initial vertex values.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));

                for (UINT i = PrimitiveCount; i > 1; i -= 2)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);

                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }

                if (i > 0)
                {
                    pV0 = pV1;
                    pV1 = pV2;
                    pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV1, pV2);
                }
            }
            break;
        case D3DPT_TRIANGLEFAN:
            {
                CVertexPointer pV1;
                CVertexPointer pV2;
                pV2.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                // Preload initial pV0.
                pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                for (UINT i = PrimitiveCount; i > 0; i--)
                {
                    CVertexPointer pV0 = pV1;
                    pV1.SetVertex(pConvObj->m_InpVertex, (*pIndices++));
                    pConvObj->MakeRectPatch(pV0, pV2, pV1);
                }
            }
            break;
        default:
            DXGASSERT(FALSE);
        }
    }

    DrawPatches(pDevice, PrimitiveCount);
}
//-----------------------------------------------------------------------------
// Conversion output will have the same number of streams as input and the
// same vertex shader
//
void CD3DHal::PrepareNPatchConversion(UINT PrimitiveCount, UINT StartVertex)
{
    if (m_pConvObj == NULL)
    {
        m_pConvObj = new CNPatch2TriPatch;
     
        if (m_pConvObj == NULL)
        {
            D3D_THROW(E_OUTOFMEMORY, "Not enough memory");
        }

        // Pre-allocate output streams
        for (int i=0; i < __NUMELEMENTS; i++)
        {
            m_pConvObj->m_pOutStream[i]->Grow(512*32, m_pDDI); 
        }
    }

    m_pConvObj->m_PositionOrder = (D3DORDERTYPE)rstates[D3DRS_POSITIONORDER];
    m_pConvObj->m_NormalOrder   = (D3DORDERTYPE)rstates[D3DRS_NORMALORDER];
    m_pConvObj->m_bNormalizeNormals = rstates[D3DRS_NORMALIZENORMALS];

    // Compute number of vertices in the output. Each output patch has 16
    // control points
    UINT nOutVertices = PrimitiveCount * 16;

    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
    {
        CVStream* pStream = &m_pStream[0];
        UINT Stride = pStream->m_dwStride;

        // Get memory pointer for the input stream 0
        m_pConvObj->m_pInpStreamMem[0] = pStream->Data() + StartVertex * Stride; 
        if (Stride != m_pConvObj->m_pOutStream[0]->m_dwStride &&
            m_pConvObj->m_pOutStream[0]->GetPrimitiveBase() != 0)
        {
            m_pDDI->FlushStates();
            m_pConvObj->m_pOutStream[0]->Reset();
            m_pConvObj->m_FirstVertex = 0;
        }
        // Allocate space in the corresponding output stream and get its
        // memory pointer
        m_pConvObj->m_pOutStreamMem[0] = m_pConvObj->m_pOutStream[0]->Lock(nOutVertices * Stride, m_pDDI);
        m_pConvObj->m_pOutStream[0]->SetVertexSize(Stride);
        m_pConvObj->m_FirstVertex = m_pConvObj->m_pOutStream[0]->GetPrimitiveBase();
        m_pConvObj->m_FirstVertex /= Stride;
        m_pConvObj->m_pOutStream[0]->SkipVertices(nOutVertices);
       // Save the old vertex buffer
        UINT tmp;
        GetStreamSource(0, (IDirect3DVertexBuffer8**)&m_pConvObj->m_InpStream[0].m_pVB, &tmp);
        // Set new vertex buffer as input stream
        SetStreamSource(0, m_pConvObj->m_pOutStream[0]->m_pVB, Stride);

        // Initialize vertex elements pointers based on the FVF handle

        UINT VertexOffset = 0;
        CVertexPointer::NumUsedElements = 0;
        BYTE* pinp = m_pConvObj->m_pInpStreamMem[0];
        BYTE* pout = m_pConvObj->m_pOutStreamMem[0];
        // Position
        m_pConvObj->m_PositionIndex = CVertexPointer::NumUsedElements;
        m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
        m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp;
        m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout;
        VertexOffset += 3*sizeof(float);
        CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
        CVertexPointer::NumUsedElements++;
        // Data after position
        switch (m_dwCurrentShaderHandle & D3DFVF_POSITION_MASK)
        {
        case D3DFVF_XYZB1:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB2:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 2;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT2;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB3:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 3;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB4:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 4;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT4;
            CVertexPointer::NumUsedElements++;
            break;
        case D3DFVF_XYZB5:  
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 4;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT4;
            CVertexPointer::NumUsedElements++;
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float) * 1;
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
            CVertexPointer::NumUsedElements++;
            break;
        }
        //Normal
        m_pConvObj->m_NormalIndex = CVertexPointer::NumUsedElements;
        m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
        m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
        m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
        VertexOffset += 3*sizeof(float);
        CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
        CVertexPointer::NumUsedElements++;
        if (m_dwCurrentShaderHandle & D3DFVF_PSIZE)
        {
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(float);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
            CVertexPointer::NumUsedElements++;
        }
        if (m_dwCurrentShaderHandle & D3DFVF_DIFFUSE)
        {
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(DWORD);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_D3DCOLOR;
            CVertexPointer::NumUsedElements++;
        }
        if (m_dwCurrentShaderHandle & D3DFVF_SPECULAR)
        {
            m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
            m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
            m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
            VertexOffset += sizeof(DWORD);
            CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_D3DCOLOR;
            CVertexPointer::NumUsedElements++;
        }
        UINT iTexCount = FVF_TEXCOORD_NUMBER(m_dwCurrentShaderHandle);
        for (UINT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(m_dwCurrentShaderHandle, i))
            {
            case D3DFVF_TEXTUREFORMAT2: 
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float) * 2;
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT2;
                CVertexPointer::NumUsedElements++;
                break;
            case D3DFVF_TEXTUREFORMAT1:
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float);
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT1;
                CVertexPointer::NumUsedElements++;
                break;
            case D3DFVF_TEXTUREFORMAT3:
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float) * 3;
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT3;
                CVertexPointer::NumUsedElements++;
                break;
            case D3DFVF_TEXTUREFORMAT4:
                m_pConvObj->m_InpVertex.Stride[CVertexPointer::NumUsedElements] = Stride;
                m_pConvObj->m_InpVertex.pData[CVertexPointer::NumUsedElements]  =  pinp + VertexOffset;
                m_pConvObj->m_OutVertex.pData[CVertexPointer::NumUsedElements]  =  pout + VertexOffset;
                VertexOffset += sizeof(float) * 4;
                CVertexPointer::DataType[CVertexPointer::NumUsedElements] = D3DVSDT_FLOAT4;
                CVertexPointer::NumUsedElements++;
                break;
            }
        }
    }
    else
    {
        // Check if we can batch to the same output vertex streams.
        // All output streams must have the same stride as declaration, the 
        // same primitive base and enough space to store output vertices
        CVStreamDecl* pStreamDecl = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        BOOL bFirstStream = TRUE;
        UINT FirstVertexIndex = 0;
        while (pStreamDecl)
        {
            UINT si = pStreamDecl->m_dwStreamIndex;
            UINT Stride = pStreamDecl->m_dwStride;
            UINT PrimitiveBase = m_pConvObj->m_pOutStream[si]->GetPrimitiveBase();
            PrimitiveBase /= Stride;
            if (bFirstStream)
            {
                FirstVertexIndex = PrimitiveBase;
                m_pConvObj->m_FirstVertex = FirstVertexIndex;
            }
            if ((m_pConvObj->m_pOutStream[si]->m_dwStride != Stride &&
                 PrimitiveBase !=  0) || FirstVertexIndex != PrimitiveBase ||
                 !m_pConvObj->m_pOutStream[si]->CheckFreeSpace(nOutVertices * Stride))
            {
                m_pDDI->FlushStates();
                for (int i=0; i < __NUMELEMENTS; i++)
                {
                    m_pConvObj->m_pOutStream[i]->Reset();
                }
                m_pConvObj->m_FirstVertex = 0;
            }
            bFirstStream = FALSE;
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }

        // Build an array of all vertex elements used in the shader by going
        // through all streams and elements inside each stream.

        CVDeclaration* pDecl = &m_pCurrentShader->m_Declaration;
        pStreamDecl = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        UINT ve = 0;    // Vertex element index
        bFirstStream = TRUE;
        while (pStreamDecl)
        {
            UINT si = pStreamDecl->m_dwStreamIndex;
            UINT Stride = pStreamDecl->m_dwStride;
            CVStream * pStream = &m_pStream[si];
            m_pConvObj->m_pInpStreamMem[si] = pStream->Data() + StartVertex * Stride;
            // Allocate space in the corresponding output stream and get 
            // memory pointer
            m_pConvObj->m_pOutStreamMem[si] = m_pConvObj->m_pOutStream[si]->Lock(nOutVertices * Stride, m_pDDI);
            m_pConvObj->m_pOutStream[si]->SetVertexSize(Stride);
            m_pConvObj->m_pOutStream[si]->SkipVertices(nOutVertices);
            // Save the old vertex buffer
            UINT tmp;
            GetStreamSource(si, (IDirect3DVertexBuffer8**)&m_pConvObj->m_InpStream[si].m_pVB, &tmp);
            // Set new vertex buffer as input
            SetStreamSource(si, m_pConvObj->m_pOutStream[si]->m_pVB, Stride);

            for (DWORD i=0; i < pStreamDecl->m_dwNumElements; i++)
            {
                if (i >= __NUMELEMENTS)
                {
                    D3D_THROW_FAIL("Declaration is using too many elements");
                }
                // This is the array we build
                CVElement* pVerElem = &pStreamDecl->m_Elements[i];
                CVertexPointer::Stride[ve] =  Stride;
                CVertexPointer::DataType[ve] = pVerElem->m_dwDataType;
                m_pConvObj->m_InpVertex.pData[ve]  =  m_pConvObj->m_pInpStreamMem[si] + pVerElem->m_dwOffset;
                m_pConvObj->m_OutVertex.pData[ve]  =  m_pConvObj->m_pOutStreamMem[si] + pVerElem->m_dwOffset;
                if (pVerElem->m_dwRegister == D3DVSDE_POSITION)
                    m_pConvObj->m_PositionIndex = ve;
                else
                if (pVerElem->m_dwRegister == D3DVSDE_NORMAL)
                    m_pConvObj->m_NormalIndex = ve;
                ve++;
            }
            pStreamDecl = (CVStreamDecl*)pStreamDecl->m_pNext;
        }
        pDecl->m_dwNumElements = ve;
        CVertexPointer::NumUsedElements = ve;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fw\buffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       buffer.cpp
 *  Content:    Implementation of the CBuffer class.
 *
 *
 ***************************************************************************/

#include "ddrawpr.h"

#include "buffer.hpp"


#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::CBuffer"

// Constructor returns an error code
// if the object could not be fully
// constructed
CBuffer::CBuffer(CBaseDevice       *pDevice,
                 DWORD              cbLength,
                 DWORD              dwFVF,
                 D3DFORMAT          Format,
                 D3DRESOURCETYPE    Type,
                 DWORD              dwUsage,
                 DWORD              dwActualUsage,
                 D3DPOOL            Pool,
                 D3DPOOL            ActualPool,
                 REF_TYPE           refType,
                 HRESULT           *phr
                 ) :
    CResource(pDevice, Pool, refType),
    m_pbBuffer(NULL),
#if DBG
    m_isLockable((dwActualUsage & (D3DUSAGE_LOCK | D3DUSAGE_LOADONCE)) != 0),
    m_SceneStamp(0xFFFFFFFF),
    m_TimesLocked(0),
#endif // DBG
    m_LockCount(0)
{
    // Determine if we need to allocate
    // any memory
    if (ActualPool == D3DPOOL_SYSTEMMEM ||
        IsTypeD3DManaged(pDevice, Type, ActualPool))
    {
        // cbLength must be a DWORD multiple
        cbLength = (cbLength + 3) & (DWORD) ~3;

        m_pbBuffer = new BYTE[cbLength];

        if (m_pbBuffer == NULL)
        {
            DPF_ERR("Out Of Memory allocating vertex or index buffer");
            *phr = E_OUTOFMEMORY;
            return;
        }

        DXGASSERT((cbLength & 3) == 0);
    }


    // We need to call the driver
    // to get a handle for all cases

    // Create a DDSURFACEINFO and CreateSurfaceData object
    DDSURFACEINFO SurfInfo;
    ZeroMemory(&SurfInfo, sizeof(SurfInfo));

    D3D8_CREATESURFACEDATA CreateSurfaceData;
    ZeroMemory(&CreateSurfaceData, sizeof(CreateSurfaceData));

    // Set up the basic information
    CreateSurfaceData.hDD      = pDevice->GetHandle();
    CreateSurfaceData.pSList   = &SurfInfo;
    CreateSurfaceData.dwSCnt   = 1;
    CreateSurfaceData.Type     = Type;
    CreateSurfaceData.dwUsage  = dwActualUsage;
    CreateSurfaceData.Pool     = DetermineCreationPool(Device(), Type, dwActualUsage, ActualPool);
    CreateSurfaceData.Format   = Format;
    CreateSurfaceData.MultiSampleType = D3DMULTISAMPLE_NONE;
    CreateSurfaceData.dwFVF    = dwFVF;

    if (Pool == D3DPOOL_DEFAULT &&
        CreateSurfaceData.Pool == D3DPOOL_SYSTEMMEM)
    {
        // If we are using sys-mem in cases where the
        // user asked for POOL_DEFAULT, we need to let
        // the thunk layer know so that Reset will
        // fail if this buffer hasn't been released
        CreateSurfaceData.bTreatAsVidMem = TRUE;
    }

    // Specify the surface data
    SurfInfo.cpWidth           = cbLength;
    SurfInfo.cpHeight          = 1;
    SurfInfo.pbPixels          = m_pbBuffer;
    SurfInfo.iPitch            = cbLength;

    // Call thunk to get our handles
    *phr = pDevice->GetHalCallbacks()->CreateSurface(&CreateSurfaceData);
    if (FAILED(*phr))
        return;

    // Cache away our handle
    SetKernelHandle(SurfInfo.hKernelHandle);

    return;

} // CBuffer::CBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::~CBuffer"

// Destructor
CBuffer::~CBuffer()
{
    // Tell the thunk layer that we need to
    // be freed.
    if (CBaseObject::BaseKernelHandle())
    {
        D3D8_DESTROYSURFACEDATA DestroySurfData;
        DestroySurfData.hDD = Device()->GetHandle();
        DestroySurfData.hSurface = CBaseObject::BaseKernelHandle();
        Device()->GetHalCallbacks()->DestroySurface(&DestroySurfData);
    }

    delete [] m_pbBuffer;

} // CBuffer::~CBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::OnBufferChangeImpl"

void CBuffer::OnBufferChangeImpl(UINT cbOffsetToLock, UINT cbSizeToLock)
{
    // 0 for cbSizeToLock; means the rest of the buffer
    // We use this as a special value.
    DWORD cbOffsetMax;
    if (cbSizeToLock == 0)
        cbOffsetMax = 0;
    else
        cbOffsetMax = cbOffsetToLock + cbSizeToLock;

    if (!IsDirty())
    {
        m_cbDirtyMin    = cbOffsetToLock;
        m_cbDirtyMax    = cbOffsetMax;
        OnResourceDirty();
    }
    else
    {
        if (m_cbDirtyMin > cbOffsetToLock)
            m_cbDirtyMin = cbOffsetToLock;

        // An cbOffsetMax of zero means all the way to the
        // end of the buffer
        if (m_cbDirtyMax < cbOffsetMax || cbOffsetMax == 0)
            m_cbDirtyMax = cbOffsetMax;

        // We should already be marked as dirty
        DXGASSERT(IsDirty());
    }
    return;
} // OnBufferChangeImpl

#undef DPF_MODNAME
#define DPF_MODNAME "CBuffer::MarkAllDirty"

void CBuffer::MarkAllDirty()
{
    // Mark our dirty bounds as being the whole
    // thing.
    m_cbDirtyMin = 0;

    // Zero for max is a special value meaning
    // all they way to the end
    m_cbDirtyMax = 0;

    // Mark ourselves as dirty
    OnResourceDirty();
} // CBuffer::MarkAllDirty

// Methods for CCommandBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "CCommandBuffer::Create"

// Static class function for creating a command buffer object.
// (Because it is static; it doesn't have a this pointer.)

// Creation function for Command Buffers
HRESULT CCommandBuffer::Create(CBaseDevice *pDevice,
                               DWORD cbLength,
                               D3DPOOL Pool,
                               CCommandBuffer **ppCmdBuffer)
{
    HRESULT hr;

    // Zero-out return parameter
    *ppCmdBuffer = NULL;

    // Allocate new buffer
    CCommandBuffer *pCmdBuffer;
    DXGASSERT(Pool == D3DPOOL_SYSTEMMEM);
    pCmdBuffer = new CCommandBuffer(pDevice,
                                    cbLength,
                                    Pool,
                                    &hr);

    if (pCmdBuffer == NULL)
    {
        DPF_ERR("Out of Memory creating command buffer");
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        // Command buffers are always internal and hence
        // need to be released through DecrementUseCount
        DPF_ERR("Error during initialization of command buffer");
        pCmdBuffer->DecrementUseCount();
        return hr;
    }

    // We're done; just return the object
    *ppCmdBuffer = pCmdBuffer;

    return hr;
} // static CCommandBuffer::Create

#undef DPF_MODNAME
#define DPF_MODNAME "CCommandBuffer::Clone"

HRESULT CCommandBuffer::Clone(D3DPOOL    Pool,
                              CResource **ppResource) const
{
    HRESULT hr;
    *ppResource = new CCommandBuffer(Device(), m_cbLength, Pool, &hr);
    if (*ppResource == NULL)
    {
        DPF_ERR("Failed to allocate command buffer");
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        DPF_ERR("Failure creating command buffer");
    }
    return hr;
} // CCommandBuffer::Clone



// End of file : buffer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\vwport.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vwport.c
 *  Content:    Direct3D viewport functions
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DViewport object
 */

#include "drawprim.hpp"
#include "ddibase.h"

//---------------------------------------------------------------------
// Update pre-computed constants related to viewport
//
// This functions should be called every time the viewport parameters are
// changed
//
// Notes:
//      1. scaleY and offsetY are computed to flip Y axes from up to down.
//      2. Mclip matrix is computed multiplied by Mshift matrix
//
const D3DVALUE SMALL_NUMBER = 0.000001f;

void
UpdateViewportCache(LPD3DHAL device, D3DVIEWPORT8 *data)
{
#if DBG
    // Bail if we are going to cause any divide by zero exceptions.
    // The likely reason is that we have a bogus viewport set by
    // TLVertex execute buffer app.
    if (data->Width == 0 || data->Height == 0)
    {
        D3D_ERR("Viewport width or height is zero");
        throw D3DERR_INVALIDCALL;
    }
    if (data->MaxZ < 0 ||
        data->MinZ < 0 ||
        data->MaxZ > 1 ||
        data->MinZ > 1)
    {
        D3D_ERR("dvMaxZ and dvMinZ should be between 0 and 1");
        throw D3DERR_INVALIDCALL;
    }
    if (data->MaxZ < data->MinZ)
    {
        D3D_ERR("dvMaxZ should not be smaller than dvMinZ");
        throw D3DERR_INVALIDCALL;
    }
#endif // DBG
    const D3DVALUE eps = 0.001f;
    if (data->MaxZ - data->MinZ < eps)
    {
        // When we clip, we transform vertices from the screen space to the
        // clipping space. With the above condition it is impossible. So we do
        // a little hack here by setting dvMinZ and dvMaxZ to different values
        if (data->MaxZ >= 0.5f)
            data->MinZ = data->MaxZ - eps;
        else
            data->MaxZ = data->MinZ + eps;
    }
    D3DFE_VIEWPORTCACHE *cache = &device->m_pv->vcache;
    cache->dvX = D3DVAL(data->X);
    cache->dvY = D3DVAL(data->Y);
    cache->dvWidth = D3DVAL(data->Width);
    cache->dvHeight = D3DVAL(data->Height);

    cache->scaleX  = cache->dvWidth;
    cache->scaleY  = - cache->dvHeight;
    cache->scaleZ  = D3DVAL(data->MaxZ - data->MinZ);
    cache->offsetX = cache->dvX;
    cache->offsetY = cache->dvY + cache->dvHeight;
    cache->offsetZ = D3DVAL(data->MinZ);
    // Small offset is added to prevent generation of negative screen
    // coordinates (this could happen because of precision errors).
    cache->offsetX += SMALL_NUMBER;
    cache->offsetY += SMALL_NUMBER;

    cache->scaleXi = D3DVAL(1) / cache->scaleX;
    cache->scaleYi = D3DVAL(1) / cache->scaleY;
    cache->scaleZi = D3DVAL(1) / cache->scaleZ;
    cache->minX = cache->dvX;
    cache->maxX = cache->dvX + cache->dvWidth;
    cache->minY = cache->dvY;
    cache->maxY = cache->dvY + cache->dvHeight;
    cache->minXi = FTOI(cache->minX);
    cache->maxXi = FTOI(cache->maxX);
    cache->minYi = FTOI(cache->minY);
    cache->maxYi = FTOI(cache->maxY);
    if (device->m_pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        const D3DCAPS8 *pCaps = device->GetD3DCaps();

        // Because we clip by guard band window we have to use its extents
        cache->minXgb = pCaps->GuardBandLeft;
        cache->maxXgb = pCaps->GuardBandRight;
        cache->minYgb = pCaps->GuardBandTop;
        cache->maxYgb = pCaps->GuardBandBottom;

        D3DVALUE w = 2.0f / cache->dvWidth;
        D3DVALUE h = 2.0f / cache->dvHeight;
        D3DVALUE ax1 = -(pCaps->GuardBandLeft - cache->dvX)   * w + 1.0f;
        D3DVALUE ax2 =  (pCaps->GuardBandRight  - cache->dvX) * w - 1.0f;
        D3DVALUE ay1 =  (pCaps->GuardBandBottom - cache->dvY) * h - 1.0f;
        D3DVALUE ay2 = -(pCaps->GuardBandTop - cache->dvY)    * h + 1.0f;
        cache->gb11 = 2.0f / (ax1 + ax2);
        cache->gb41 = cache->gb11 * (ax1 - 1.0f) * 0.5f;
        cache->gb22 = 2.0f / (ay1 + ay2);
        cache->gb42 = cache->gb22 * (ay1 - 1.0f) * 0.5f;

        cache->Kgbx1 = 0.5f * (1.0f - ax1);
        cache->Kgbx2 = 0.5f * (1.0f + ax2);
        cache->Kgby1 = 0.5f * (1.0f - ay1);
        cache->Kgby2 = 0.5f * (1.0f + ay2);
    }
    else
    {
        cache->minXgb = cache->minX;
        cache->maxXgb = cache->maxX;
        cache->minYgb = cache->minY;
        cache->maxYgb = cache->maxY;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DBase::CheckViewport"

void CD3DBase::CheckViewport(CONST D3DVIEWPORT8* lpData)
{
    // We have to check parameters here, because viewport could be changed
    // after creating a state set
    DWORD uSurfWidth,uSurfHeight;
    D3DSURFACE_DESC desc = this->RenderTarget()->InternalGetDesc();

    uSurfWidth  = desc.Width;
    uSurfHeight = desc.Height;

    if (lpData->X > uSurfWidth ||
        lpData->Y > uSurfHeight ||
        lpData->X + lpData->Width > uSurfWidth ||
        lpData->Y + lpData->Height > uSurfHeight)
    {
        D3D_THROW(D3DERR_INVALIDCALL, "Viewport outside the render target surface");
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetViewportI"

void CD3DHal::SetViewportI(CONST D3DVIEWPORT8* lpData)
{
    // We check viewport here, because the render target could have been
    // changed after a state block is created
    CheckViewport(lpData);

    m_Viewport = *lpData;
    // Update front-end data
    UpdateViewportCache(this, &this->m_Viewport);
    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
        m_pDDI->SetViewport(&m_Viewport);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::GetViewport"

HRESULT
D3DAPI CD3DHal::GetViewport(D3DVIEWPORT8* lpData)
{
    API_ENTER(this); // Takes D3D Lock if necessary

    if (!VALID_WRITEPTR(lpData, sizeof(*lpData)))
    {
        D3D_ERR( "Invalid viewport pointer. GetViewport failed." );
        return D3DERR_INVALIDCALL;
    }

    *lpData = this->m_Viewport;

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\fe\vshader.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vshader.cpp
 *  Content:    SetStreamSource and VertexShader
 *              software implementation.
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "ibuffer.hpp"
#include "fe.h"
#include "ddibase.h"
#include "pvvid.h"

void __Transpose(D3DMATRIXI* m, D3DMATRIX* res)
{
    res->_11 = m->_11;
    res->_12 = m->_21;
    res->_13 = m->_31;
    res->_14 = m->_41;
    res->_21 = m->_12;
    res->_22 = m->_22;
    res->_23 = m->_32;
    res->_24 = m->_42;
    res->_31 = m->_13;
    res->_32 = m->_23;
    res->_33 = m->_33;
    res->_34 = m->_43;
    res->_41 = m->_14;
    res->_42 = m->_24;
    res->_43 = m->_34;
    res->_44 = m->_44;
}
//-----------------------------------------------------------------------------
// Forward definitions
//
void CD3DHal_DrawPrimitive(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                           UINT StartVertex, UINT PrimitiveCount);
void CD3DHal_DrawIndexedPrimitive(CD3DBase* pBaseDevice,
                                  D3DPRIMITIVETYPE PrimitiveType,
                                  UINT BaseIndex,
                                  UINT MinIndex, UINT NumVertices,
                                  UINT StartIndex,
                                  UINT PrimitiveCount);
void CD3DHal_DrawNPatch(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                           UINT StartVertex, UINT PrimitiveCount);
void CD3DHal_DrawIndexedNPatch(CD3DBase* pBaseDevice,
                               D3DPRIMITIVETYPE PrimitiveType,
                               UINT BaseIndex,
                               UINT MinIndex, UINT NumVertices,
                               UINT StartIndex,
                               UINT PrimitiveCount);
//-----------------------------------------------------------------------------
void __declspec(nothrow) CD3DHal::PickDrawPrimFn()
{
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        m_pfnDrawPrim = m_pDDI->GetDrawPrimFunction();
        m_pfnDrawIndexedPrim = m_pDDI->GetDrawIndexedPrimFunction();
        if (m_dwRuntimeFlags & D3DRT_DONPATCHCONVERSION)
        {
            m_pfnDrawPrimFromNPatch = m_pfnDrawPrim;
            m_pfnDrawIndexedPrimFromNPatch = m_pfnDrawIndexedPrim;
            m_pfnDrawPrim = CD3DHal_DrawNPatch;
            m_pfnDrawIndexedPrim = CD3DHal_DrawIndexedNPatch;
        }
    }
    else
    {
        DWORD dwDeviceFlags = m_pv->dwDeviceFlags;
        BOOL bCallDriver;
        if (Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8)
        {
            bCallDriver = dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
                         (dwDeviceFlags & D3DDEV_DONOTCLIP ||
                         !(dwDeviceFlags & D3DDEV_VBPROCVER));
        }
        else
        {
            bCallDriver = dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
                          dwDeviceFlags & D3DDEV_DONOTCLIP;
        }
        if (bCallDriver)
        {
            m_pfnDrawPrim = m_pDDI->GetDrawPrimFunction();
            m_pfnDrawIndexedPrim = m_pDDI->GetDrawIndexedPrimFunction();
        }
        else
        {
            m_pfnDrawPrim = CD3DHal_DrawPrimitive;
            m_pfnDrawIndexedPrim = CD3DHal_DrawIndexedPrimitive;
        }
    }
}
//-----------------------------------------------------------------------------
// Checks if we can call driver directly to draw the current primitive
//
inline BOOL CanCallDriver(CD3DHal* pDev, D3DPRIMITIVETYPE PrimType)
{
    DWORD dwDeviceFlags = pDev->m_pv->dwDeviceFlags;
    if (PrimType != D3DPT_POINTLIST)
        return dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
               (dwDeviceFlags & D3DDEV_DONOTCLIP || 
                pDev->Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8);
    else
        // This function could be called from DrawPointsI, which could be
        // called from other Draw() function than DrawPrimitiveUP, so we need
        // to check for D3DDEV_VBPROCVER. We cannot pass vertices, which are
        // result of ProcessVertices(), to the driver directly
        return dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
               !(pDev->m_dwRuntimeFlags & D3DRT_DOPOINTSPRITEEMULATION) &&
               (dwDeviceFlags & D3DDEV_DONOTCLIP || 
                (pDev->Enum()->GetAppSdkVersion() == D3D_SDK_VERSION_DX8 &&
                !(dwDeviceFlags & D3DDEV_VBPROCVER)));
}
//-----------------------------------------------------------------------------
//                              API calls
//-----------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetStreamSourceI"

void
CD3DHal::SetStreamSourceI(CVStream* pStream)
{
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
    {
        CVertexBuffer * pVB = pStream->m_pVB;
        m_pv->dwDeviceFlags &= ~D3DDEV_VBPROCVER;
        DWORD dwFVF = pVB->GetFVF();
        if (pVB->GetClipCodes() != NULL)
        {
            // This vertex buffer is the output of ProcessVertices
            DXGASSERT(FVF_TRANSFORMED(dwFVF));
            m_pv->dwDeviceFlags |= D3DDEV_VBPROCVER;
        }
        if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
        {
            SetupStrides(m_pv, m_pStream[0].m_dwStride);
        }
    }   
    PickDrawPrimFn();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetIndicesI"

void
CD3DHal::SetIndicesI(CVIndexStream* pStream)
{
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::CreateVertexShaderI"

void
CD3DHal::CreateVertexShaderI(CONST DWORD* pdwDeclaration, DWORD dwDeclSize,
                             CONST DWORD* pdwFunction, DWORD dwCodeSize,
                             DWORD dwHandle)
{
    BOOL bIsCheckedBuild =
#if DBG
        TRUE;
#else
        FALSE;
#endif
    CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
    if (pShader->m_dwFlags & CVShader::SOFTWARE)
    {

        // Build the array of all vertex elements used in the shader by going
        // through all streams and elements inside each stream.

        CVDeclaration* pDecl = &pShader->m_Declaration;
        CVStreamDecl* pStream = pShader->m_Declaration.m_pActiveStreams;
        // This is the array we build
        CVElement* pVerElem = pShader->m_Declaration.m_VertexElements;
        pDecl->m_dwNumElements = 0;
        while (pStream)
        {
            for (DWORD i=0; i < pStream->m_dwNumElements; i++)
            {
                if (pDecl->m_dwNumElements >= __NUMELEMENTS)
                {
                    D3D_THROW_FAIL("Declaration is using too many elements");
                }
                *pVerElem = pStream->m_Elements[i];
                pVerElem->m_dwStreamIndex = pStream->m_dwStreamIndex;
                pVerElem++;
                pDecl->m_dwNumElements++;
            }
            pStream = (CVStreamDecl*)pStream->m_pNext;
        }

        if (pdwFunction != NULL)
        {
            // compute adjusted function pointer depending on FREE/CHECKED and PSGP
            LPDWORD pdwFunctionAdj = pShader->m_pStrippedFuncCode;
            if ( bIsCheckedBuild &&
                 ((LPVOID)m_pv->pGeometryFuncs == (LPVOID)GeometryFuncsGuaranteed) ) // !PSGP
            {
                pdwFunctionAdj = pShader->m_pOrgFuncCode;
            }
            // Microsoft shader is always created.
            // It is used for validation and to compute the output FVF in case
            // when PSGP is present
            HRESULT hr;
            hr = GeometryFuncsGuaranteed->CreateShader(
                            pDecl->m_VertexElements,
                            pDecl->m_dwNumElements,
                            pdwFunctionAdj, 0,
                            (CPSGPShader**)&pShader->m_pCode);
            if(FAILED(hr))
            {
                D3D_THROW_FAIL("Failed to create vertex shader code");
            }
            // When device driver can not handle separate fog value in the FVF,
            // we should use specular alpha as the fog factor
            if (pShader->m_pCode->m_dwOutFVF & D3DFVF_FOG &&
                !(GetD3DCaps()->PrimitiveMiscCaps & D3DPMISCCAPS_FOGINFVF))
            {
                pShader->m_pCode->m_dwOutFVF &= ~D3DFVF_FOG;
                // Assume that texture coordinates follow fog value
                // No need to adjust offsets when specular is already present
                if (pShader->m_pCode->m_dwOutFVF & D3DFVF_SPECULAR)
                {
                    pShader->m_pCode->m_dwOutVerSize -= 4;
                    pShader->m_pCode->m_dwTextureOffset -= 4;
                }
                pShader->m_pCode->m_dwOutFVF |= D3DFVF_SPECULAR;
            }
            // Clear texture format bits if device can handle only 2 floats per
            // texture coordinate
            if (m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE &&
                pShader->m_pCode->m_dwOutFVF & 0xFFFF0000)
            {
                CVShaderCode * pCode = pShader->m_pCode;
                pCode->m_dwOutFVF &= 0x0000FFFF;
                pCode->m_dwOutVerSize = ComputeVertexSizeFVF(pCode->m_dwOutFVF);
                for (DWORD i=0; i < pCode->m_nOutTexCoord; i++)
                {
                    pCode->m_dwOutTexCoordSize[i] = 2 * 4;
                }
            }
            if ((LPVOID)m_pv->pGeometryFuncs != (LPVOID)GeometryFuncsGuaranteed)
            {
                DWORD dwOutputFVF = pShader->m_pCode->m_dwOutFVF;
                CVShaderCode* pCodeMs = pShader->m_pCode;
                // Now we can create PSGP shader
                hr = m_pv->pGeometryFuncs->CreateShader(pDecl->m_VertexElements,
                                                  pDecl->m_dwNumElements,
                                                  pdwFunctionAdj, dwOutputFVF,
                                                  (CPSGPShader**)&pShader->m_pCode);
                if(FAILED(hr))
                {
                    delete pCodeMs;
                    D3D_THROW_FAIL("Failed to create vertex shader code");
                }
                // Copy pre-computed data from Microsoft's shader to the PSGP
                CPSGPShader * pCode = pShader->m_pCode;
                CPSGPShader * pMsShader = pCodeMs;
                pCode->m_dwOutRegs        = pMsShader->m_dwOutRegs;
                pCode->m_dwOutFVF         = pMsShader->m_dwOutFVF;
                pCode->m_dwPointSizeOffset = pMsShader->m_dwPointSizeOffset;
                pCode->m_dwDiffuseOffset  = pMsShader->m_dwDiffuseOffset;
                pCode->m_dwSpecularOffset = pMsShader->m_dwSpecularOffset;
                pCode->m_dwFogOffset      = pMsShader->m_dwFogOffset;
                pCode->m_dwTextureOffset  = pMsShader->m_dwTextureOffset;
                pCode->m_nOutTexCoord     = pMsShader->m_nOutTexCoord;
                pCode->m_dwOutVerSize     = pMsShader->m_dwOutVerSize;
                for (DWORD i=0; i < pCode->m_nOutTexCoord; i++)
                {
                    pCode->m_dwOutTexCoordSize[i] = pMsShader->m_dwOutTexCoordSize[i];
                }
                // Microsoft shader is not needed any more
                 delete pCodeMs;
            }
        }
    }
    else
    {
        if ( bIsCheckedBuild && (GetDeviceType() != D3DDEVTYPE_HAL ) )
        {
            // pass non-stripped version
            m_pDDI->CreateVertexShader(
                pdwDeclaration, dwDeclSize,
                pShader->m_pOrgFuncCode, 
                pShader->m_OrgFuncCodeSize, dwHandle,
                pShader->m_Declaration.m_bLegacyFVF);
        }
        else
        {
            // pass stripped version
            m_pDDI->CreateVertexShader(
                pdwDeclaration, dwDeclSize,
                pShader->m_pStrippedFuncCode, 
                pShader->m_StrippedFuncCodeSize, dwHandle,
                pShader->m_Declaration.m_bLegacyFVF);
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetVertexShaderI"

void CD3DHal::SetVertexShaderI(DWORD dwHandle)
{
#if DBG
    // We need to validate shader handle here, because the shader could be
    // deleted by user after creating a state block with the shader handle.
    CheckVertexShaderHandle(dwHandle);
#endif
    
    CVConstantData* pConst = NULL;
    if (!D3DVSD_ISLEGACY(dwHandle))
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
        pConst = pShader->m_Declaration.m_pConstants;
    }
    // Ignore redundant handle when we do not need to update constantes
    if(pConst == NULL)
    {
        if(dwHandle == m_dwCurrentShaderHandle)
            return;
    }
    else
    {
        // Load constants
        while (pConst)
        {
            HRESULT hr;
            hr = m_pv->pGeometryFuncs->LoadShaderConstants(pConst->m_dwAddress,
                                                           pConst->m_dwCount,
                                                           pConst->m_pData);
            if (FAILED(hr))
            {
                D3D_THROW_FAIL("Failed to load vertex shader constants");
            }
            pConst =  (CVConstantData*)pConst->m_pNext;
            m_dwRuntimeFlags |= D3DRT_NEED_VSCONST_UPDATE;
        }
    }

    ForceFVFRecompute();
    // When we switch from FVF shaders to programmable we need to re-compute 
    // clipping planes, because they are transformed by different matrix
    if (this->rstates[D3DRENDERSTATE_CLIPPLANEENABLE])
    {
        this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY;
    }

    m_dwCurrentShaderHandle = dwHandle;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
    {
        m_dwRuntimeFlags &= ~D3DRT_POINTSIZEINVERTEX;
        m_dwRuntimeFlags |= D3DRT_SHADERDIRTY;
        m_pv->dwDeviceFlags &= ~D3DDEV_TRANSFORMEDFVF;

        if (D3DVSD_ISLEGACY(dwHandle))
        {
            if (dwHandle & D3DFVF_PSIZE)
                m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;

            m_pCurrentShader = NULL;
            m_pv->dwDeviceFlags &= ~(D3DDEV_STRIDE | D3DDEV_VERTEXSHADERS);

            if (FVF_TRANSFORMED(dwHandle))
            {
                if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
                {
                    m_pDDI->SetVertexShader(dwHandle);
                }
                m_pv->dwDeviceFlags |= D3DDEV_TRANSFORMEDFVF;
            }

            m_pfnPrepareToDraw = PrepareToDrawLegacy;
            m_pv->dwVIDIn  = dwHandle;
            SetupStrides(m_pv, m_pStream[0].m_dwStride);
        }
        else
        {
            CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            m_pCurrentShader = pShader;
            if(!(pShader->m_dwFlags & CVShader::FIXEDFUNCTION))
            {
                // Programmable vertex shaders are used
                m_pv->dwDeviceFlags |= D3DDEV_VERTEXSHADERS;
                m_pfnPrepareToDraw = PrepareToDrawVVM;
                if (m_pCurrentShader->m_pCode->m_dwOutFVF & D3DFVF_PSIZE)
                    m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;

                // Pre-compute as much info as possible and keep it
                // in the vertex descriptors. This information is constant
                // unless shader is changed
                CVDeclaration* pDecl = &m_pCurrentShader->m_Declaration;
                CVertexDesc* pVD = m_pv->VertexDesc;
                CVElement *pElem = pDecl->m_VertexElements;
                m_pv->dwNumUsedVertexDescs = pDecl->m_dwNumElements;
                for (DWORD i = pDecl->m_dwNumElements; i; i--)
                {
                    pVD->pfnCopy = pElem->m_pfnCopy;
                    pVD->dwRegister = pElem->m_dwRegister;
                    pVD->dwVertexOffset = pElem->m_dwOffset;
                    pVD->pStream = &m_pStream[pElem->m_dwStreamIndex];
                    pVD++;
                    pElem++;
                }
            }
            else
            {
                // Fixed-function pipeline is used with declarations
                // We draw primitives using strided code path
                m_pv->dwDeviceFlags |= D3DDEV_STRIDE;
                m_pv->dwDeviceFlags &= ~D3DDEV_VERTEXSHADERS;

                m_pfnPrepareToDraw = PrepareToDraw;

                if (pShader->m_dwInputFVF & D3DFVF_PSIZE)
                    m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;

                // Go through the elements in the current declaration and
                // initialize vertex descriptors. They are used to quickly
                // initialize strided data pointers.
                CVDeclaration* pDecl = &m_pCurrentShader->m_Declaration;
                CVertexDesc* pVD = m_pv->VertexDesc;
                CVElement *pElem = pDecl->m_VertexElements;
                m_pv->dwNumUsedVertexDescs = pDecl->m_dwNumElements;
                for (DWORD i = pDecl->m_dwNumElements; i; i--)
                {
                    pVD->pElement = &m_pv->elements[pElem->m_dwRegister];
                    pVD->pStream = &m_pStream[pElem->m_dwStreamIndex];
                    pVD->dwVertexOffset = pElem->m_dwOffset;
                    pVD++;
                    pElem++;
                }
                m_pv->dwVIDIn  = pDecl->m_dwInputFVF;
                if (pDecl->m_dwInputFVF & D3DFVF_PSIZE)
                    m_dwRuntimeFlags |= D3DRT_POINTSIZEINVERTEX;
            }
            HRESULT hr = m_pv->pGeometryFuncs->SetActiveShader(pShader->m_pCode);
            if (FAILED(hr))
            {
                D3D_THROW_FAIL("Failed to set active vertex shader");
            }
        }
        m_pDDI->PickProcessPrimitive();
    }
    else
    {
#if DBG
        // For the validation we need to set the m_pCurrentShader even for
        // hardware mode
        m_pv->dwDeviceFlags &= ~D3DDEV_VERTEXSHADERS;
        if (D3DVSD_ISLEGACY(dwHandle))
        {
            m_pCurrentShader = NULL;
        }
        else
        {
            m_pCurrentShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
            if(!(m_pCurrentShader->m_dwFlags & CVShader::FIXEDFUNCTION))
            {
                // Programmable pipeline is used
                m_pv->dwDeviceFlags |= D3DDEV_VERTEXSHADERS;
            }
        }
#endif
        if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
        {
            m_pDDI->SetVertexShaderHW(dwHandle);
        }
    }
    PickDrawPrimFn();
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DeleteVertexShaderI"

void CD3DHal::DeleteVertexShaderI(DWORD dwHandle)
{
#if DBG
    for(unsigned Handle = 0; Handle < m_pRTPatchValidationInfo->GetSize(); ++Handle)
    {
        if ((*m_pRTPatchValidationInfo)[Handle].m_pObj != 0)
        {
            if (static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle == dwHandle)
            {
                static_cast<CRTPatchValidationInfo*>((*m_pRTPatchValidationInfo)[Handle].m_pObj)->m_ShaderHandle = 0;
                D3D_INFO(0, "Found this vertex shader in a cached patch. Will invalidate the cached patch.");
            }
        }
    }
#endif // DBG
    if (dwHandle == m_dwCurrentShaderHandle)
    {
        m_pCurrentShader = NULL;
        m_dwCurrentShaderHandle = 0;
    }
    if (!D3DVSD_ISLEGACY(dwHandle))
    {
        CVShader* pShader = (CVShader*)m_pVShaderArray->GetObject(dwHandle);
#if DBG
        if (pShader == NULL)
        {
            D3D_THROW(D3DERR_INVALIDCALL, "Invalid vertex shader handle");
        }
#endif
        if (!(pShader->m_dwFlags & CVShader::SOFTWARE))
        {
            m_pDDI->DeleteVertexShader(dwHandle);
        }
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::SetVertexShaderConstantI"

void
CD3DHal::SetVertexShaderConstantI(DWORD Register, CONST VOID* pData, DWORD count)
{
    HRESULT hr;
    if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING ||
        ((count + Register) <= D3DVS_CONSTREG_MAX_V1_1))
    {
        // For software vertex processing we store constant registers in PSGP if
        // possible
        hr = m_pv->pGeometryFuncs->LoadShaderConstants(Register, count, 
                                                       const_cast<VOID*>(pData));
    }
    else
    {
        if (Register >= D3DVS_CONSTREG_MAX_V1_1)
        {
            // When all modified registers are above software limit, we use Microsoft 
            // internal array
            hr = GeometryFuncsGuaranteed->LoadShaderConstants(Register, count, 
                                                              const_cast<VOID*>(pData));
        }
        else
        {
            // Part of constant data is stores in the PSGP array and part in the
            // Microsoft's array
            UINT FirstCount = D3DVS_CONSTREG_MAX_V1_1 - Register;
            hr = m_pv->pGeometryFuncs->LoadShaderConstants(Register, FirstCount, 
                                                           const_cast<VOID*>(pData));
            if (FAILED(hr))
            {
                D3D_THROW(hr, "Failed to set vertex shader constants");
            }
            hr = GeometryFuncsGuaranteed->LoadShaderConstants(D3DVS_CONSTREG_MAX_V1_1, 
                                                              Register + count - D3DVS_CONSTREG_MAX_V1_1,
                                                              &((DWORD*)pData)[FirstCount*4]);
        }
    }
    if (FAILED(hr))
    {
        D3D_THROW(hr, "Failed to set vertex shader constants");
    }

    if (!(m_dwRuntimeFlags & D3DRT_EXECUTESTATEMODE))
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            m_dwRuntimeFlags |= D3DRT_NEED_VSCONST_UPDATE;
        else
            m_pDDI->SetVertexShaderConstant(Register, 
                                            pData, 
                                            count);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::ValidateDraw2"

void CD3DHal::ValidateDraw2(D3DPRIMITIVETYPE primType,
                            UINT StartVertex,
                            UINT PrimitiveCount,
                            UINT NumVertices,
                            BOOL bIndexPrimitive,
                            UINT StartIndex)
{
#if DBG
    if (this->rstates[D3DRS_FILLMODE] == D3DFILL_POINT &&
        m_dwRuntimeFlags & D3DRT_POINTSIZEPRESENT &&
        primType != D3DPT_POINTLIST)
    {
        D3D_INFO(0, "Result of drawing primitives with D3DFILL_POINT fill mode "
                    "and point size not equal 1.0f could be different on "
                    "different devices");
    }
    if ((m_dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) == 0 &&
        !(m_pv->dwFlags & D3DPV_VBCALL))
    {
        D3D_THROW_FAIL("Need to call BeginScene before rendering.");
    }
    if (m_dwCurrentShaderHandle == 0)
    {
        D3D_THROW_FAIL("Invalid vertex shader handle (0x0)");
    }
    if (bIndexPrimitive && primType == D3DPT_POINTLIST)
    {
        D3D_THROW_FAIL("Indexed point lists are not supported");
    }
    if (*(FLOAT*)&rstates[D3DRS_PATCHSEGMENTS] > 1.f)
    {
        if (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
        {
            D3D_THROW_FAIL("N-Patches are not supported with software vertex processing");
        }
        else
        if ((GetD3DCaps()->DevCaps & (D3DDEVCAPS_NPATCHES | D3DDEVCAPS_RTPATCHES)) == 0)
        {
            D3D_THROW_FAIL("N-Patches are not supported");
        }
    }
    BOOL bUserMemPrimitive = this->m_dwRuntimeFlags & D3DRT_USERMEMPRIMITIVE;
    if (D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
    {
        // DX7 FVF handles can work only from stream zero
        if (!bUserMemPrimitive)
        {
            if (m_pStream[0].m_pVB == NULL)
            {
                D3D_THROW_FAIL("Stream 0 should be initialized for FVF shaders");
            }
            DWORD dwFVF = m_pStream[0].m_pVB->GetFVF();
            if (dwFVF != 0 && dwFVF != m_dwCurrentShaderHandle)
            {
                D3D_THROW_FAIL("Current vertex shader doesn't match VB's FVF");
            }
            if (FVF_TRANSFORMED(m_dwCurrentShaderHandle))
            {
                if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP) &&
                    m_pStream[0].m_pVB->GetBufferDesc()->Usage & D3DUSAGE_DONOTCLIP)
                {
                    D3D_THROW_FAIL("Vertex buffer with D3DUSAGE_DONOTCLIP is used with clipping");
                }
            }
            else
            {
                D3DVERTEXBUFFER_DESC Desc;
                static_cast<IDirect3DVertexBuffer8*>(m_pStream[0].m_pVB)->GetDesc(&Desc);
                if ((BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
                    (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0 &&
                    (Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING) == 0 &&
                    Desc.Pool != D3DPOOL_SYSTEMMEM)
                {
                    D3D_THROW_FAIL("Vertex buffer should have software usage or should be managed or should be in system memory");
                }
            }
            if (m_pStream[0].m_pVB->IsLocked())
            {
                D3D_THROW_FAIL("Vertex buffer must be unlocked during DrawPrimitive call");
            }
            if (*((FLOAT*)&rstates[D3DRS_PATCHSEGMENTS]) > 1.f && (m_pStream[0].m_pVB->GetBufferDesc()->Usage & D3DUSAGE_NPATCHES) == 0)
            {
                D3D_THROW_FAIL("Vertex buffers used for rendering N-Patches should have D3DUSAGE_NPATCHES set");
            }
        }
        // DX7 drivers cannot handle case when vertex size, computed from FVF, 
        // is different from the stream stride
        if (m_pStream[0].m_dwStride != ComputeVertexSizeFVF(m_dwCurrentShaderHandle))
        {
            D3D_THROW_FAIL("Stream 0 stride should match the stride, implied by the current vertex shader");
        }
        if (m_pStream[0].m_dwNumVertices < (StartVertex + NumVertices))
        {
            D3D_THROW_FAIL("Streams do not have required number of vertices");
        }
    }
    else
    {
        if (m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
        {
            CVShaderCode * pCode = m_pCurrentShader->m_pCode;
            for (DWORD i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
            {
                if (this->tsstates[i][D3DTSS_TEXCOORDINDEX] != i)
                {
                    D3D_ERR("Stage %d - Texture coordinate index in the stage "
                            "must be equal to the stage index when programmable"
                            " vertex pipeline is used", i);
                    D3D_THROW_FAIL("");
                }
                DWORD TexTransformFlags = tsstates[i][D3DTSS_TEXTURETRANSFORMFLAGS];
                if (pCode)
                {
                    if (TexTransformFlags & D3DTTFF_PROJECTED && 
                        !(m_dwRuntimeFlags & D3DRT_ONLY2FLOATSPERTEXTURE) &&
                        pCode->m_dwOutTexCoordSize[i] != 16)
                    {
                        D3D_ERR("Stage %d - Vertex shader must write XYZW to the "
                                "output texture register when texture projection is enabled", i);
                        D3D_THROW_FAIL("");
                    }
                }
                if ((TexTransformFlags & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE)
                {
                    D3D_ERR("Stage %d - Count in D3DTSS_TEXTURETRANSFORMFLAGS "
                            "must be 0 when programmable pipeline is used", i);
                    D3D_THROW_FAIL("");
                }
            }
        }

        if (m_pCurrentShader->m_Declaration.m_bStreamTessPresent)
        {
            D3D_THROW_FAIL("Declaration with tesselator stream cannot be used with DrawPrimitive API");
        }
        if (((GetDDIType() < D3DDDITYPE_DX8)&&
              (m_pCurrentShader->m_Declaration.m_bLegacyFVF == FALSE))
             &&
             !(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING)
            )
        {
            D3D_THROW_FAIL("Device does not support declarations");
        }
        // Check if
        // 1. streams, referenced by the current shader, are valid
        // 2. stride in the current shader and in the stream matches
        // 3. Compute max number of vertices the streams can contain
        CVStreamDecl* pStream;
        pStream = m_pCurrentShader->m_Declaration.m_pActiveStreams;
        while(pStream)
        {
            UINT index = pStream->m_dwStreamIndex;
            CVStream* pDeviceStream = &m_pStream[index];
            if (bUserMemPrimitive)
            {
                DXGASSERT(pDeviceStream->m_pData != NULL);
                if (index != 0)
                {
                    D3D_THROW_FAIL("DrawPrimitiveUP can use declaration only with stream 0");
                }
            }
            else
            {
                if (pDeviceStream->m_pVB == NULL)
                {
                    D3D_ERR("Stream %d is not set, but used by current declaration", index);
                    D3D_THROW_FAIL("");
                }
                if (pDeviceStream->m_pVB->IsLocked())
                {
                    D3D_ERR("Vertex buffer in stream %d must be unlocked during drawing", index);
                    D3D_THROW_FAIL("");
                }
                D3DVERTEXBUFFER_DESC Desc;
                static_cast<IDirect3DVertexBuffer8*>(pDeviceStream->m_pVB)->GetDesc(&Desc);
                if ((BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
                    (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0 &&
                    (Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING) == 0 &&
                    Desc.Pool != D3DPOOL_SYSTEMMEM)
                {
                    D3D_INFO(0, "In stream %d vertex buffer should have software usage or should be managed or should be in system memory", pStream->m_dwStreamIndex);
                    D3D_THROW_FAIL("");
                }
                if (*((FLOAT*)&rstates[D3DRS_PATCHSEGMENTS]) > 1.f && (pDeviceStream->m_pVB->GetBufferDesc()->Usage & D3DUSAGE_NPATCHES) == 0)
                {
                    D3D_THROW_FAIL("Vertex buffers used for rendering N-Patches should have D3DUSAGE_NPATCHES set");
                }
                // Validate matching of FVF in the vertex buffer and stream 
                // declaration
                if (m_pv->dwDeviceFlags & D3DDEV_VERTEXSHADERS)
                {
                    if (pDeviceStream->m_pVB->GetFVF() != 0)
                    {
                        D3D_INFO(1, "In stream %d vertex buffer with FVF is "
                                 "used with programmable vertex shader",
                                 pStream->m_dwStreamIndex);
                    }
                }
                else
                {
                    // Fixed function pipeline case
                    DWORD vbFVF = pDeviceStream->m_pVB->GetFVF();
                    DWORD streamFVF = pStream->m_dwFVF;
                    // VB FVF should be a superset of the stream FVF
                    if (vbFVF && ((vbFVF & streamFVF) != streamFVF))
                    {
                        D3D_INFO(0, "In stream %d vertex buffer FVF and declaration FVF do not match", 
                                 pStream->m_dwStreamIndex);
                    }
                }
            }
            // Stride 0 is allowed
            if (pDeviceStream->m_dwStride)
            {
                if (pDeviceStream->m_dwStride < pStream->m_dwStride)
                {
                    D3D_ERR("Vertex strides in stream %d is less than in the declaration", index);
                    D3D_THROW_FAIL("");
                }
                if (pDeviceStream->m_dwNumVertices < (StartVertex + NumVertices))
                {
                    D3D_ERR("Stream %d does not have required number of vertices",
                            pStream->m_dwStreamIndex);
                    D3D_THROW_FAIL("");
                }
            }
            pStream = (CVStreamDecl*)pStream->m_pNext;
        }
    }
    if (bIndexPrimitive)
    {
        if (!bUserMemPrimitive)
        {
            if (m_pIndexStream->m_pVBI == NULL)
            {
                D3D_THROW_FAIL("Index stream is not set");
            }
            if (m_pIndexStream->m_pVBI->IsLocked())
            {
                D3D_THROW_FAIL("Index buffer must be unlocked during drawing");
            }
            UINT NumIndices = GETVERTEXCOUNT(primType, PrimitiveCount);
            if (m_pIndexStream->m_dwNumVertices < (StartIndex + NumIndices))
            {
                D3D_THROW_FAIL("Index stream does not have required number of indices");
            }
            if (FVF_TRANSFORMED(m_dwCurrentShaderHandle) &&
                D3DVSD_ISLEGACY(m_dwCurrentShaderHandle))
            {
                if (!(m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP) &&
                    (m_pIndexStream->m_pVBI->GetBufferDesc()->Usage & D3DUSAGE_DONOTCLIP))
                {
                    D3D_THROW_FAIL("Index buffer with D3DUSAGE_DONOTCLIP is used with clipping");
                }
            }
            else
            {
                D3DINDEXBUFFER_DESC Desc;
                static_cast<IDirect3DIndexBuffer8*>(m_pIndexStream->m_pVBI)->GetDesc(&Desc);
                if ((BehaviorFlags() & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 &&
                    (m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) != 0 &&
                    (Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING) == 0 &&
                    Desc.Pool != D3DPOOL_SYSTEMMEM)
                {
                    D3D_THROW_FAIL("Index buffer should have software usage or should be managed or should be in system memory");
                }
            }
            if (*((FLOAT*)&rstates[D3DRS_PATCHSEGMENTS]) > 1.f && (m_pIndexStream->m_pVBI->GetBufferDesc()->Usage & D3DUSAGE_NPATCHES) == 0)
            {
                D3D_THROW_FAIL("Index buffers used for rendering N-Patches should have D3DUSAGE_NPATCHES set");
            }
        }
        else
        {
            DXGASSERT(m_pIndexStream->m_pData != NULL);
        }
    }
#endif //DBG
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawPoints"

void CD3DHal::DrawPoints(UINT StartVertex)
{
    BOOL bRecomputeOutputFVF = FALSE;
    // If point scale is enabled and device supports point sprites
    // we may need to add the point size to the output FVF
    if (rstates[D3DRS_POINTSCALEENABLE] &&
        !(m_dwRuntimeFlags & D3DRT_POINTSIZEINVERTEX) &&
        !(m_pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF))
    {
        ForceFVFRecompute();
        bRecomputeOutputFVF = TRUE;
    }
    if (m_dwRuntimeFlags & D3DRT_DOPOINTSPRITEEMULATION)
    {
        // We do point sprite expansion when point size is not 1.0 in the
        // render state or it is present in vertices or we need to do point
        // scaling for untransformed vertices
        if ((m_dwRuntimeFlags & D3DRT_POINTSIZEPRESENT ||
            (rstates[D3DRS_POINTSCALEENABLE] &&
            !(m_pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF))) &&
            // We do not do emulation for devices which supports point sprites,
            // but only when there is no point size in the FVF
            !(bRecomputeOutputFVF == FALSE &&
             (m_dwRuntimeFlags & D3DRT_POINTSIZEINVERTEX) == 0 &&
             m_dwRuntimeFlags & D3DRT_SUPPORTSPOINTSPRITES))
        {
            m_pv->dwDeviceFlags |= D3DDEV_DOPOINTSPRITEEMULATION;
            m_pDDI->PickProcessPrimitive();
        }
        else
        {
            if (m_pv->dwDeviceFlags & D3DDEV_TRANSFORMEDFVF &&
                (m_pv->dwDeviceFlags & D3DDEV_DONOTCLIP ||
                !(m_pv->dwDeviceFlags & D3DDEV_VBPROCVER)))
            {
                // Now we can call DDI directly, because no emulation is
                // necessary
                if (m_pStream[0].m_pVB)
                {
                    (*m_pDDI->GetDrawPrimFunction())(this, m_pv->primType,
                                                     StartVertex,
                                                     m_pv->dwNumPrimitives);
                }
                else
                {
                    m_pDDI->SetVertexShader(m_dwCurrentShaderHandle);
                    m_pDDI->SetStreamSource(0, &m_pStream[0]);
                    m_pDDI->DrawPrimitiveUP(m_pv->primType, m_pv->dwNumPrimitives);
                }
                return;
            }
        }
    }

    (this->*m_pfnPrepareToDraw)(StartVertex);
    (m_pDDI->*m_pDDI->m_pfnProcessPrimitive)(m_pv, StartVertex);

    if (bRecomputeOutputFVF)
    {
        ForceFVFRecompute();
    }
    m_pv->dwDeviceFlags &= ~D3DDEV_DOPOINTSPRITEEMULATION;
    m_pDDI->PickProcessPrimitive();
}
//-----------------------------------------------------------------------------
// Draw all primitive types except points
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveHal"

void CD3DHal_DrawPrimitive(CD3DBase* pBaseDevice, D3DPRIMITIVETYPE PrimitiveType,
                           UINT StartVertex, UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);
    CD3DDDIDX6* pDDI = pBaseDevice->m_pDDI;

#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pDevice->ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, nVer,
                           FALSE);
#endif
    D3DFE_PROCESSVERTICES* pv = pDevice->m_pv;
    pv->primType = PrimitiveType;
    pv->dwNumPrimitives = PrimitiveCount;
    pv->dwNumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pv->dwFlags &= D3DPV_PERSIST;
    (pDevice->*pDevice->m_pfnPrepareToDraw)(StartVertex);
    (pDDI->*pDDI->m_pfnProcessPrimitive)(pv, StartVertex);
}
//-----------------------------------------------------------------------------
// Draw only points
//
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawPointsI"

void CD3DHal::DrawPointsI(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex,
                          UINT PrimitiveCount)
{
#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    ValidateDraw2(PrimitiveType, StartVertex, PrimitiveCount, nVer, FALSE);
#endif
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING) ||
        CanCallDriver(this, PrimitiveType))
    {
        (*m_pfnDrawPrim)(this, PrimitiveType, StartVertex, PrimitiveCount);
    }
    else
    {
        m_pv->primType = PrimitiveType;
        m_pv->dwNumPrimitives = PrimitiveCount;
        m_pv->dwNumVertices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
        m_pv->dwFlags &= D3DPV_PERSIST;
        DrawPoints(StartVertex);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal_DrawIndexedPrimitive"

void CD3DHal_DrawIndexedPrimitive(CD3DBase* pBaseDevice,
                                  D3DPRIMITIVETYPE PrimitiveType,
                                  UINT BaseIndex,
                                  UINT MinIndex, UINT NumVertices,
                                  UINT StartIndex,
                                  UINT PrimitiveCount)
{
    CD3DHal* pDevice = static_cast<CD3DHal*>(pBaseDevice);
    CVIndexStream* pIndexStream = pBaseDevice->m_pIndexStream;
    CD3DDDIDX6* pDDI = pBaseDevice->m_pDDI;

#if DBG
    pDevice->ValidateDraw2(PrimitiveType, MinIndex + pIndexStream->m_dwBaseIndex,
                           PrimitiveCount, NumVertices, TRUE, StartIndex);
#endif
    D3DFE_PROCESSVERTICES* pv = pDevice->m_pv;
    pIndexStream->m_pData = NULL;
    pv->primType = PrimitiveType;
    pv->dwNumPrimitives = PrimitiveCount;
    pv->dwFlags &= D3DPV_PERSIST;

    pv->dwNumVertices = NumVertices;
    pv->dwNumIndices = GETVERTEXCOUNT(PrimitiveType, PrimitiveCount);
    pv->dwIndexSize = pIndexStream->m_dwStride;
    UINT StartVertex = MinIndex + pIndexStream->m_dwBaseIndex;
    pDDI->SetIndexedPrimParams(StartIndex, MinIndex, NumVertices,
                               pIndexStream->m_dwBaseIndex);
    (pDevice->*pDevice->m_pfnPrepareToDraw)(StartVertex);
    (pDDI->*pDDI->m_pfnProcessIndexedPrimitive)(pv, StartVertex);
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawPrimitiveUPI"

void CD3DHal::DrawPrimitiveUPI(D3DPRIMITIVETYPE PrimType, UINT PrimCount)

{
#if DBG
    UINT nVer = GETVERTEXCOUNT(PrimType, PrimCount);
    ValidateDraw2(PrimType, 0, PrimCount, nVer, FALSE);
#endif
    m_pv->dwDeviceFlags &= ~D3DDEV_VBPROCVER;
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        if (m_dwRuntimeFlags & D3DRT_DONPATCHCONVERSION &&
            PrimType >= D3DPT_TRIANGLELIST)
        {
            CD3DHal_DrawNPatch(this, PrimType, 0, PrimCount);
        }
        else
        {
            m_pDDI->DrawPrimitiveUP(PrimType, PrimCount);
        }
    }
    else
    if (CanCallDriver(this, PrimType))
    {
        m_pDDI->SetVertexShader(m_dwCurrentShaderHandle);
        m_pDDI->SetStreamSource(0, &m_pStream[0]);
        m_pDDI->DrawPrimitiveUP(PrimType, PrimCount);
    }
    else
    {
        SetupStrides(m_pv, m_pStream[0].m_dwStride);
        m_pv->primType = PrimType;
        m_pv->dwNumPrimitives = PrimCount;
        m_pv->dwNumVertices = GETVERTEXCOUNT(PrimType, PrimCount);
        m_pv->dwFlags &= D3DPV_PERSIST;
        if (PrimType != D3DPT_POINTLIST)
        {
            (this->*m_pfnPrepareToDraw)(0);
            (m_pDDI->*m_pDDI->m_pfnProcessPrimitive)(m_pv, 0);
        }
        else
            DrawPoints(0);
    }
}
//-----------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CD3DHal::DrawIndexedPrimitiveUPI"

void
CD3DHal::DrawIndexedPrimitiveUPI(D3DPRIMITIVETYPE PrimType,
                                 UINT MinVertexIndex,
                                 UINT NumVertices,
                                 UINT PrimCount)
{
#if DBG
    ValidateDraw2(PrimType, 0, PrimCount, NumVertices, TRUE);
#endif
    m_pv->dwDeviceFlags &= ~D3DDEV_VBPROCVER;
    if (!(m_dwRuntimeFlags & D3DRT_RSSOFTWAREPROCESSING))
    {
        if (m_dwRuntimeFlags & D3DRT_DONPATCHCONVERSION &&
            PrimType >= D3DPT_TRIANGLELIST)
        {
            CD3DHal_DrawIndexedNPatch(this, PrimType, 0, MinVertexIndex, 
                                      NumVertices, 0, PrimCount);
        }
        else
        {
            m_pDDI->DrawIndexedPrimitiveUP(PrimType, MinVertexIndex, NumVertices,
                                           PrimCount);
        }
    }
    else
    if (CanCallDriver(this, PrimType))
    {
        m_pDDI->SetVertexShader(m_dwCurrentShaderHandle);
        m_pDDI->SetStreamSource(0, &m_pStream[0]);
        m_pDDI->SetIndices(m_pIndexStream);
        m_pDDI->DrawIndexedPrimitiveUP(PrimType, MinVertexIndex, NumVertices,
                                       PrimCount);
    }
    else
    {
        SetupStrides(m_pv, m_pStream[0].m_dwStride);
        m_pv->primType = PrimType;
        m_pv->dwNumPrimitives = PrimCount;
        m_pv->dwFlags &= D3DPV_PERSIST;

        m_pv->dwNumVertices = NumVertices;
        m_pv->dwNumIndices = GETVERTEXCOUNT(PrimType, PrimCount);
        m_pv->lpwIndices = (WORD*)m_pIndexStream->m_pData;
        m_pv->dwIndexSize = m_pIndexStream->m_dwStride;
        m_pDDI->SetIndexedPrimParams(0, MinVertexIndex,
                                     MinVertexIndex + NumVertices, 0);
        (this->*m_pfnPrepareToDraw)(MinVertexIndex);
        (m_pDDI->*m_pDDI->m_pfnProcessIndexedPrimitive)(m_pv, MinVertexIndex);
    }
}
//-----------------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "SetupFVFDataVVM"

void SetupFVFDataVVM(CD3DHal* pDev)
{
    D3DFE_PROCESSVERTICES* pv = pDev->m_pv;
// We have to restore texture stage indices if previous primitive
// re-mapped them
    if (pv->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(pDev);
    }

	// Input FVF has no meaning for vertex shaders, but it is used for validaion
    pv->dwVIDIn = 0;

// Compute output FVF

    CVShaderCode * pCode = pDev->m_pCurrentShader->m_pCode;

    pv->dwVIDOut          = pCode->m_dwOutFVF;
    pv->dwOutputSize      = pCode->m_dwOutVerSize;
    pv->nOutTexCoord      = pCode->m_nOutTexCoord;
    // We use offsets, computed by the vertex shader
    pv->pointSizeOffsetOut = pCode->m_dwPointSizeOffset;
    pv->diffuseOffsetOut = pCode->m_dwDiffuseOffset;
    pv->specularOffsetOut = pCode->m_dwSpecularOffset;
    pv->fogOffsetOut = pCode->m_dwFogOffset;
    pv->texOffsetOut = pCode->m_dwTextureOffset;
    pv->dwTextureCoordSizeTotal = 0;
    for (DWORD i=0; i < pv->nOutTexCoord; i++)
    {
        DWORD dwSize = pCode->m_dwOutTexCoordSize[i];
        pv->dwTextureCoordSize[i] = dwSize;
        pv->dwTextureCoordSizeTotal += dwSize;
    }
}
//----------------------------------------------------------------------
void CD3DHal::SetupFVFData()
{
    CD3DHal::SetupFVFDataCommon();
    if (!(m_pv->dwVIDIn & D3DFVF_NORMAL))
        m_pv->dwDeviceFlags &= ~D3DDEV_NORMALINCAMERASPACE;
}
//---------------------------------------------------------------------
// Computes the following data
//  - dwTextureCoordOffset[] offset of every input texture coordinates

static __inline void ComputeInpTexCoordOffsets(DWORD dwNumTexCoord,
                                               DWORD dwFVF,
                                               DWORD *pdwTextureCoordOffset)
{
    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = i << 3;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = dwOffset;
            dwOffset += g_TextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }
    return;
}
//---------------------------------------------------------------------
// Returns 2 bits of FVF texture format for the texture index
//
static inline DWORD FVFGetTextureFormat(DWORD dwFVF, DWORD dwTextureIndex)
{
    return (dwFVF >> (dwTextureIndex*2 + 16)) & 3;
}
//---------------------------------------------------------------------
// Retu