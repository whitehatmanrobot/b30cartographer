	VERIFY (szMenu.LoadString (IDS_NEW_SAFER_POLICY));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_NEW_SAFER_POLICY_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TOP == lInsertionPointID ? 
            IDM_TOP_CREATE_NEW_SAFER_POLICY : IDM_TASK_CREATE_NEW_SAFER_POLICY;

	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferCreateNewPolicyMenuItems: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddOptionsMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddOptionsMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.fFlags = 0;
	menuItem.fSpecialFlags = 0;
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
	VERIFY (szMenu.LoadString (IDS_OPTIONS));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (IDS_OPTIONS_HINT));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = IDM_OPTIONS;
	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"LeavingLeaving CCertMgrComponentData::AddOptionsMenuItem: 0x%x\n", hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\componentdatasafer.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       ComponentDataSafer.cpp
//
//  Contents:   Implementation of CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTMGR (ComponentDataSafer.cpp)")
#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "Certifct.h"
#include "dlgs.h"
#pragma warning(push, 3)
#include <wintrust.h>
#include <cryptui.h>
#pragma warning(pop)
#include "storegpe.h"
#include "PolicyPrecedencePropertyPage.h"
#include "SaferLevelGeneral.h"
#include "SaferEntry.h"
#include "SaferEntryPathPropertyPage.h"
#include "SaferEntryPropertySheet.h"
#include "SaferEntryHashPropertyPage.h"
#include "SaferEntryCertificatePropertyPage.h"
#include "SaferEntryInternetZonePropertyPage.h"
#include "SaferTrustedPublishersPropertyPage.h"
#include "SaferDefinedFileTypesPropertyPage.h"
#include "SaferEnforcementPropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
    
extern HKEY g_hkeyLastSaferRegistryScope;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;


CSaferWindowsExtension::CSaferWindowsExtension() : CCertMgrComponentData () 
{
    SetHtmlHelpFileName (SAFER_WINDOWS_HELP_FILE);
    m_strLinkedHelpFile = SAFER_WINDOWS_LINKED_HELP_FILE;
};


HRESULT CCertMgrComponentData::AddSaferLevelSetAsDefaultMenuItem (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferLevelSetAsDefaultMenuItem\n");
 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
 	ASSERT (pContextMenuCallback);
    if ( !pContextMenuCallback )
        return E_POINTER;

 	HRESULT			hr = S_OK;
 	CONTEXTMENUITEM	menuItem;
 	CString			szMenu;
 	CString			szHint;
 
    ASSERT (m_pGPEInformation); // must not be RSOP
    if ( !m_pGPEInformation )
        return E_FAIL;

 	// unchanging settings
 	::ZeroMemory (&menuItem, sizeof (menuItem));
 	menuItem.lInsertionPointID = lInsertionPointID;
 	menuItem.fFlags = 0;
 
 	VERIFY (szMenu.LoadString (IDS_SAFER_SET_DEFAULT));
 	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
 	VERIFY (szHint.LoadString (IDS_SAFER_SET_DEFAULT_HINT));
 	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
 	menuItem.lCommandID = IDM_SAFER_LEVEL_SET_DEFAULT;
 
 	hr = pContextMenuCallback->AddItem (&menuItem);
 	ASSERT (SUCCEEDED (hr));

 	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferLevelSetAsDefaultMenuItem: 0x%x\n", hr);
 	return hr;
}
    

HRESULT CCertMgrComponentData::AddSaferNewEntryMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferNewEntryMenuItems\n");
 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
 	ASSERT (pContextMenuCallback);
    if ( !pContextMenuCallback )
        return E_POINTER;

 	HRESULT			hr = S_OK;
 	CONTEXTMENUITEM	menuItem;
 	CString			szMenu;
 	CString			szHint;
 
    ASSERT (m_pGPEInformation); // must not be RSOP
    if ( !m_pGPEInformation )
        return E_FAIL;


 	// unchanging settings
 	::ZeroMemory (&menuItem, sizeof (menuItem));
 	menuItem.lInsertionPointID = lInsertionPointID;
 	menuItem.fFlags = 0;
 
    if ( SUCCEEDED (hr) )
    {
 	    VERIFY (szMenu.LoadString (IDS_SAFER_NEW_ENTRY_CERTIFICATE));
 	    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
 	    VERIFY (szHint.LoadString (IDS_SAFER_NEW_ENTRY_CERTIFICATE_HINT));
 	    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
 	    menuItem.lCommandID = IDM_SAFER_NEW_ENTRY_CERTIFICATE;
 
 	    hr = pContextMenuCallback->AddItem (&menuItem);
 	    ASSERT (SUCCEEDED (hr));
    }

    if ( SUCCEEDED (hr) )
    {
 	    VERIFY (szMenu.LoadString (IDS_SAFER_NEW_ENTRY_HASH));
 	    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
 	    VERIFY (szHint.LoadString (IDS_SAFER_NEW_ENTRY_HASH_HINT));
 	    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
 	    menuItem.lCommandID = IDM_SAFER_NEW_ENTRY_HASH;
 
 	    hr = pContextMenuCallback->AddItem (&menuItem);
 	    ASSERT (SUCCEEDED (hr));
    }

    if ( SUCCEEDED (hr) )
    {
 	    VERIFY (szMenu.LoadString (IDS_SAFER_NEW_ENTRY_INTERNET_ZONE));
 	    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
 	    VERIFY (szHint.LoadString (IDS_SAFER_NEW_ENTRY_INTERNET_ZONE_HINT));
 	    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
 	    menuItem.lCommandID = IDM_SAFER_NEW_ENTRY_INTERNET_ZONE;
 
 	    hr = pContextMenuCallback->AddItem (&menuItem);
 	    ASSERT (SUCCEEDED (hr));
    }

    if ( SUCCEEDED (hr) )
    {
 	    VERIFY (szMenu.LoadString (IDS_SAFER_NEW_ENTRY_PATH));
 	    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
 	    VERIFY (szHint.LoadString (IDS_SAFER_NEW_ENTRY_PATH_HINT));
 	    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
 	    menuItem.lCommandID = IDM_SAFER_NEW_ENTRY_PATH;
 
 	    hr = pContextMenuCallback->AddItem (&menuItem);
 	    ASSERT (SUCCEEDED (hr));
    }

 	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferNewEntryMenuItems: 0x%x\n", hr);
 	return hr;
}

HRESULT CCertMgrComponentData::OnSetSaferLevelDefault (LPDATAOBJECT pDataObject)
{
 	_TRACE (1, L"Entering CCertMgrComponentData::OnSetSaferLevelDefault\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	ASSERT (pDataObject);
 	if ( !pDataObject )
 		return E_POINTER;

    ASSERT (m_pGPEInformation); // must not be RSOP
    if ( !m_pGPEInformation )
        return E_FAIL;

 	HRESULT			hr = S_OK;
 	CCertMgrCookie*	pCookie = ConvertCookie (pDataObject);
 	ASSERT (pCookie);
 	if ( pCookie )
 	{
        if ( pCookie->HasOpenPropertyPages () )
        {
            CString text;
            CString	caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            VERIFY (text.LoadString (IDS_CANT_CHANGE_DEFAULT_PAGES_OPEN)); 
            int		iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
	             MB_OK, &iRetVal)));
            return S_OK;
        }

        if ( CERTMGR_SAFER_COMPUTER_LEVEL == pCookie->m_objecttype ||
                CERTMGR_SAFER_USER_LEVEL == pCookie->m_objecttype )
        {
            CSaferLevel* pSaferLevel = dynamic_cast<CSaferLevel*>(pCookie);
            if ( pSaferLevel )
            {
                int iRetVal = IDYES;

                if ( pSaferLevel->GetLevel () < m_dwDefaultSaferLevel )
                {
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
                    VERIFY (text.LoadString (IDS_DEFAULT_LEVEL_CHANGE_WARNING));
                    m_pConsole->MessageBox (text, caption, 
                            MB_ICONWARNING | MB_YESNO, &iRetVal);
                }

                if ( IDYES == iRetVal )
                {
                    hr = pSaferLevel->SetAsDefault ();
                    if ( SUCCEEDED (hr) )
                    {
                        m_dwDefaultSaferLevel = pSaferLevel->GetLevel ();
                        if ( m_pConsole )
                            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                    }
                    else
                    {
                        CString text;
                        CString caption;

                        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
                        text.FormatMessage (IDS_CANT_SET_AS_DEFAULT, 
                                pSaferLevel->GetObjectName (),
                                GetSystemMessage (hr));
	                    iRetVal = 0;
                        ASSERT (m_pConsole);
	                    if ( m_pConsole )
	                    {
		                    HRESULT	hr1 = m_pConsole->MessageBox (text, caption,
			                    MB_ICONWARNING | MB_OK, &iRetVal);
		                    ASSERT (SUCCEEDED (hr1));
	                    }
                    }
                }
            }
        }
        else
            hr = E_FAIL;
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnSetSaferLevelDefault: 0x%x\n", hr);
    return hr;
}



HRESULT CCertMgrComponentData::AddSaferLevelPropPage (
        LPPROPERTYSHEETCALLBACK pCallback, 
        CSaferLevel* pSaferLevel, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferLevelPropPage\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback && pSaferLevel);
	if ( pCallback && pSaferLevel )
	{
		CSaferLevelGeneral * pLevelPage = new CSaferLevelGeneral (*pSaferLevel,
                m_bIsRSOP, lNotifyHandle, pDataObject, m_dwDefaultSaferLevel);
		if ( pLevelPage )
		{
			HPROPSHEETPAGE hLevelPage = MyCreatePropertySheetPage (&pLevelPage->m_psp);
            if ( hLevelPage )
            {
			    hr = pCallback->AddPage (hLevelPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
//                        CString regPath = SAFER_LEVELOBJECTS_REGKEY;
//                        regPath += L"\\";
//                        DWORD   dwLevel = pSaferLevel->GetLevel ();
//                        WCHAR   szLevel[16];
//                        regPath += _itow (dwLevel, szLevel, 10);

                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, SAFER_HKLM_REGBASE,
                                        SAFER_DEFAULTOBJ_REGVALUE,
                                        CERTMGR_SAFER_COMPUTER_LEVEL == pSaferLevel->m_objecttype);
	                    if ( pPrecedencePage )
	                    {
                            HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hLevelPage));
                }
            }
            else
                delete pLevelPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferLevelPropPage: 0x%x\n", hr);
	return hr;
}
    
HRESULT CCertMgrComponentData::OnCreateNewSaferPolicy (LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;
  	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
    {
        bool    bIsComputer = CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype;
        HKEY    hGroupPolicyKey = 0;
        hr = m_pGPEInformation->GetRegistryKey (
                bIsComputer ? 
                GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &hGroupPolicyKey);
        if ( SUCCEEDED (hr) )
        {
            BOOL bDefaultsActuallyPopulated = FALSE;
            BOOL bResult = ::SaferiPopulateDefaultsInRegistry(
                    hGroupPolicyKey, &bDefaultsActuallyPopulated);
            if ( bResult && bDefaultsActuallyPopulated )
            {
                m_pGPEInformation->PolicyChanged (TRUE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (TRUE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
            }

            ::RegCloseKey (hGroupPolicyKey);
        }

        CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
        if ( pSaferRootCookie )
            pSaferRootCookie->m_bCreateSaferNodes = true;

        if ( !m_pResultData )
            hr = GetResultData (&m_pResultData);

        if ( m_pResultData )
            hr = m_pResultData->DeleteAllRsltItems ();

        // Force scope item selection to for call to 
        // IComponent::QueryResultViewType ()
        hr = m_pComponentConsole->SelectScopeItem (pCookie->m_hScopeItem);
        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
        hr = OnNotifyExpand (pDataObject, TRUE, pCookie->m_hScopeItem);
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CCertMgrComponentData::OnNewSaferEntry(long nCommandID, LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNewSaferEntry ()\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT                     hr = S_OK;

	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
	{
        bool    bIsComputer = false;

        switch (pCookie->m_objecttype)
        {
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
            bIsComputer = true;
            break;

        case CERTMGR_SAFER_USER_ENTRIES:
            break;

        default:
            ASSERT (0);
            hr = E_FAIL;
            return hr;
        }

        CSaferEntries* pSaferEntries = dynamic_cast <CSaferEntries*> (pCookie);
        if ( !pSaferEntries )
            return E_UNEXPECTED;

        SAFER_ENTRY_TYPE  saferEntryType = SAFER_ENTRY_TYPE_UNKNOWN;
        switch (nCommandID)
        {
            case IDM_SAFER_NEW_ENTRY_PATH:
                saferEntryType = SAFER_ENTRY_TYPE_PATH;
                break;

            case IDM_SAFER_NEW_ENTRY_HASH:
                saferEntryType = SAFER_ENTRY_TYPE_HASH;
                break;

            case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
                saferEntryType = SAFER_ENTRY_TYPE_CERT;
                break;

            case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
                saferEntryType = SAFER_ENTRY_TYPE_URLZONE;
                break;

            default:
                ASSERT (0);
                break;
        }
		CSaferEntry* pSaferEntry = new CSaferEntry (
                saferEntryType,
                bIsComputer, 
                L"", 
                L"", 
                0, 
                (DWORD) AUTHZ_UNKNOWN_LEVEL,
                m_pGPEInformation, 
                0,
                pSaferEntries, 
                bIsComputer ? m_rsopObjectArrayComputer : m_rsopObjectArrayUser);
		ASSERT (pSaferEntry);
        if ( pSaferEntry )
        {
            UINT    nIDCaption = 0;

            switch (nCommandID)
            {
            case IDM_SAFER_NEW_ENTRY_PATH:
                nIDCaption = IDS_NEW_PATH_RULE;
                break;

            case IDM_SAFER_NEW_ENTRY_HASH:
                nIDCaption = IDS_NEW_HASH_RULE;
                break;

            case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
                nIDCaption = IDS_NEW_CERTIFICATE_RULE;
                break;

            case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
                nIDCaption = IDS_NEW_URLZONE_RULE;
                break;

            default:
                ASSERT (0);
                hr = E_FAIL;
                break;
            }

            HWND    hParent = 0;
			hr = m_pConsole->GetMainWindow (&hParent);
			ASSERT (SUCCEEDED (hr));
			if ( SUCCEEDED (hr) )
			{
				CWnd	parentWnd;
				VERIFY (parentWnd.Attach (hParent));

                CSaferEntryPropertySheet    propSheet (nIDCaption, &parentWnd);
                CPropertyPage*              pPage = 0;

                switch (nCommandID)
                {
                case IDM_SAFER_NEW_ENTRY_PATH:
                    {
                        CSaferEntryPathPropertyPage* pPropPage = new 
                                CSaferEntryPathPropertyPage (*pSaferEntry, 0, 
                                0, false, true, this, bIsComputer);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                case IDM_SAFER_NEW_ENTRY_HASH:
                    {
                        CSaferEntryHashPropertyPage* pPropPage = new 
                                CSaferEntryHashPropertyPage (*pSaferEntry, 0, 
                                0, false, this, bIsComputer);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
                    {
                        CSaferEntryCertificatePropertyPage* pPropPage = new 
                                CSaferEntryCertificatePropertyPage (*pSaferEntry,
                                pSaferEntries, 0, 0, false, this, true, 
                                m_pGPEInformation, bIsComputer);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
                    {
                        CSaferEntryInternetZonePropertyPage* pPropPage = new 
                                CSaferEntryInternetZonePropertyPage (*pSaferEntry, 
                                true, 0, 0, false, this, bIsComputer);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                default:
                    hr = E_FAIL;
                    break;
                }


                if ( SUCCEEDED (hr) && pPage )
                {
                    propSheet.AddPage (pPage);

                    CThemeContextActivator activator;
                    INT_PTR iRet = propSheet.DoModal ();
                    if ( IDOK == iRet )
                    {
                        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                    }
                }

                delete pSaferEntry;

				parentWnd.Detach ();
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnNewSaferEntry (): 0x%x\n", hr);
    return hr;
}

	
HRESULT	CCertMgrComponentData::AddSaferTrustedPublisherPropPages (
			LPPROPERTYSHEETCALLBACK pCallback,
            bool bIsMachineType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferTrustedPublisherPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CSaferTrustedPublishersPropertyPage * pTrustedPublisherPage = new 
                CSaferTrustedPublishersPropertyPage (
                    bIsMachineType,
                    m_pGPEInformation, this);
		if ( pTrustedPublisherPage )
		{
			HPROPSHEETPAGE hTrustedPublisherPage = MyCreatePropertySheetPage (&pTrustedPublisherPage->m_psp);
            if ( hTrustedPublisherPage )
            {
		        hr = pCallback->AddPage (hTrustedPublisherPage);
		        ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    // Add the precedence page if this is RSOP
                    if ( m_bIsRSOP )
                    {
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, 
                                        CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,
                                        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
                                        bIsMachineType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = 
                                    MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
                                hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                            {
                                delete pPrecedencePage;
                            }
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hTrustedPublisherPage));
                }
            }
            else
                delete pTrustedPublisherPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferTrustedPublisherPropPages: 0x%x\n", hr);
	return hr;

}


	
HRESULT	CCertMgrComponentData::AddSaferDefinedFileTypesPropPages (
			LPPROPERTYSHEETCALLBACK pCallback,
            bool bIsComputerType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferDefinedFileTypesPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CSaferDefinedFileTypesPropertyPage * pDefinedFileTypesPage = new 
                CSaferDefinedFileTypesPropertyPage (
                    m_pGPEInformation,
                    m_bIsRSOP,
                    bIsComputerType ?
                            m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                    bIsComputerType);
		if ( pDefinedFileTypesPage )
		{
			HPROPSHEETPAGE hDefinedFileTypesPage = MyCreatePropertySheetPage (&pDefinedFileTypesPage->m_psp);
            if ( hDefinedFileTypesPage )
            {
			    hr = pCallback->AddPage (hDefinedFileTypesPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, 
                                        SAFER_HKLM_REGBASE,
                                        SAFER_EXETYPES_REGVALUE,
                                        bIsComputerType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = 
                                    MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hDefinedFileTypesPage));
                }
            }
            else
                delete pDefinedFileTypesPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferDefinedFileTypesPropPages: 0x%x\n", hr);
	return hr;

}

HRESULT	CCertMgrComponentData::AddSaferEnforcementPropPages (
			LPPROPERTYSHEETCALLBACK pCallback,
            bool bIsComputerType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferEnforcementPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CSaferEnforcementPropertyPage * pEnforcementPage = new 
                CSaferEnforcementPropertyPage (
                    m_pGPEInformation, this,
                    m_bIsRSOP,
                    bIsComputerType ?
                            m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                    bIsComputerType);
		if ( pEnforcementPage )
		{
			HPROPSHEETPAGE hEnforcementPage = MyCreatePropertySheetPage (&pEnforcementPage->m_psp);
            if ( hEnforcementPage )
            {
			    hr = pCallback->AddPage (hEnforcementPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, 
                                        SAFER_HKLM_REGBASE,
                                        SAFER_TRANSPARENTENABLED_REGVALUE,
                                        bIsComputerType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = 
                                    MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hEnforcementPage));
                }
            }
            else
                delete pEnforcementPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferEnforcementPropPages: 0x%x\n", hr);
	return hr;

}


HRESULT CCertMgrComponentData::AddSaferEntryPropertyPage (
        LPPROPERTYSHEETCALLBACK pCallback, 
        CCertMgrCookie* pCookie,
        LPDATAOBJECT pDataObject, 
        LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddSaferEntryPropertyPage\n");
    ASSERT (pCallback && pCookie);
    if ( !pCallback || !pCookie )
        return E_POINTER;

    HRESULT hr = S_OK;
    bool    bIsComputer = false;

    switch (pCookie->m_objecttype)
    {
    case CERTMGR_SAFER_COMPUTER_ENTRY:
        bIsComputer = true;
        break;

    case CERTMGR_SAFER_USER_ENTRY:
        break;

    default:
        ASSERT (0);
        hr = E_FAIL;
        return hr;
    }

	CSaferEntry* pSaferEntry = dynamic_cast <CSaferEntry*> (pCookie);
	ASSERT (pSaferEntry);
    if ( pSaferEntry )
    {
        pSaferEntry->Refresh ();

        switch (pSaferEntry->GetType ())
        {
        case SAFER_ENTRY_TYPE_PATH:
            {
                CSaferEntryPathPropertyPage* pPage = new 
                        CSaferEntryPathPropertyPage (*pSaferEntry, 
                        lNotifyHandle, pDataObject, 
                        m_bIsRSOP, false, this, bIsComputer);
                if ( pPage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                    if ( hPage )
                    {
                        hr = pCallback->AddPage (hPage);
                        if ( FAILED (hr) )
                        {
                            VERIFY (::DestroyPropertySheetPage (hPage));
                        }
                    }
                    else
                        delete pPage;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            break;

        case SAFER_ENTRY_TYPE_HASH:
            {
                CSaferEntryHashPropertyPage* pPage = new 
                        CSaferEntryHashPropertyPage (*pSaferEntry, 
                        lNotifyHandle, pDataObject, 
                        m_bIsRSOP, this, bIsComputer);
                if ( pPage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                    if ( hPage )
                    {
                        hr = pCallback->AddPage (hPage);
                        if ( FAILED (hr) )
                        {
                            VERIFY (::DestroyPropertySheetPage (hPage));
                        }
                    }
                    else
                        delete pPage;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            break;

        case SAFER_ENTRY_TYPE_CERT:
            {
                CSaferEntries* pSaferEntries = 0;
                hr = pSaferEntry->GetSaferEntriesNode (&pSaferEntries);
                if ( SUCCEEDED (hr) )
                {
                    CSaferEntryCertificatePropertyPage* pPage = new 
                            CSaferEntryCertificatePropertyPage (*pSaferEntry, 
                            pSaferEntries, lNotifyHandle, pDataObject, 
                            m_bIsRSOP, this, false, m_pGPEInformation, bIsComputer);
                    if ( pPage )
                    {
                        HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                        if ( hPage )
                        {
                            hr = pCallback->AddPage (hPage);
                            if ( FAILED (hr) )
                            {
                                VERIFY (::DestroyPropertySheetPage (hPage));
                            }
                        }
                        else
                            delete pPage;
                    }
                    else
                        hr = E_OUTOFMEMORY;

                    pSaferEntries->Release ();
                }
            }
            break;

        case SAFER_ENTRY_TYPE_URLZONE:
            {
                CSaferEntryInternetZonePropertyPage* pPage = new 
                        CSaferEntryInternetZonePropertyPage (*pSaferEntry, 
                        false, lNotifyHandle, pDataObject,
                        m_bIsRSOP, this, bIsComputer);
                if ( pPage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                    if ( hPage )
                    {
                        hr = pCallback->AddPage (hPage);
                        if ( FAILED (hr) )
                        {
                            VERIFY (::DestroyPropertySheetPage (hPage));
                        }
                    }
                    else
                        delete pPage;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            break;

        default:
            hr = E_FAIL;
            break;
        }

        if ( SUCCEEDED (hr) && m_bIsRSOP )
        {
            CString szValue;
            switch (pSaferEntry->GetType ())
            {
            case SAFER_ENTRY_TYPE_PATH:
            case SAFER_ENTRY_TYPE_HASH:
            case SAFER_ENTRY_TYPE_URLZONE:
                szValue = SAFER_IDS_ITEMDATA_REGVALUE;
                break;

            case SAFER_ENTRY_TYPE_CERT:
                szValue = STR_BLOB;
                break;

            default:
                ASSERT (0);
                break;
            }

            CPolicyPrecedencePropertyPage * pPrecedencePage = 
                    new CPolicyPrecedencePropertyPage (this, 
                            pSaferEntry->GetRSOPRegistryKey (),
                            szValue,
                            bIsComputer);
	        if ( pPrecedencePage )
	        {
		        HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                if ( hPrecedencePage )
                {
		            hr = pCallback->AddPage (hPrecedencePage);
		            ASSERT (SUCCEEDED (hr));
                    if ( FAILED (hr) )
                        VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                }
                else
                    delete pPrecedencePage;
	        }
	        else
	        {
		        hr = E_OUTOFMEMORY;
	        }
        }
    }
    else
        hr = E_FAIL;
    
    _TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferEntryPropertyPage: 0x%x\n", hr);
    return hr;
}

bool CSaferWindowsExtension::FoundInRSOPFilter (BSTR bstrKey) const
{
    static  size_t  nSaferKeyLen = wcslen (SAFER_HKLM_REGBASE);
    static  size_t  nSaferPKKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH);
    static  size_t  nTrustedPublisherKeyLane = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH);
    static  size_t  nDisallowedKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH);

    if ( !_wcsnicmp (SAFER_HKLM_REGBASE, bstrKey, nSaferKeyLen) ||
            !_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH, bstrKey, 
                    nSaferPKKeyLen) ||
            !_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH, 
                    bstrKey, nTrustedPublisherKeyLane) ||
            !_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH, 
                    bstrKey, nDisallowedKeyLen) )
    {
        return true;
    }
    else
        return false;
}


HRESULT CCertMgrComponentData::SaferEnumerateLevels (bool bIsComputer)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateLevels ()\n");
    HRESULT hr = S_OK;

    if ( !m_pdwSaferLevels )
    {
        if ( m_pGPEInformation )
        {
            DWORD   cbBuffer = 0;
            CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    bIsComputer);

            SetRegistryScope (policyKey.GetKey (), bIsComputer);
            BOOL    bRVal = SaferGetPolicyInformation(
                    SAFER_SCOPEID_REGISTRY,
                    SaferPolicyLevelList,
                    cbBuffer,
                    m_pdwSaferLevels,
                    &cbBuffer,
                    0);
            if ( !bRVal && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
            {
                DWORD   nLevels = cbBuffer/sizeof (DWORD);
                m_pdwSaferLevels = new DWORD[nLevels+1];
                if ( m_pdwSaferLevels )
                {
                    memset (m_pdwSaferLevels, NO_MORE_SAFER_LEVELS, 
                            sizeof (DWORD) * (nLevels + 1));
                    bRVal = SaferGetPolicyInformation(
                        SAFER_SCOPEID_REGISTRY,
                        SaferPolicyLevelList,
                        cbBuffer,
                        m_pdwSaferLevels,
                        &cbBuffer,
                        0);
                    ASSERT (bRVal);
                    if ( !bRVal )
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"SaferGetPolicyInformation(SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n", 
                                dwErr);
                    }
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else if ( !bRVal )
            {
                ASSERT (0);
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation(SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n",
                        dwErr);
            }
        }
        else
        {
            // Is RSOP
            const int RSOP_SAFER_LEVELS = 3;    // SAFER_LEVELID_FULLYTRUSTED, SAFER_LEVELID_DISALLOWED + 1
            m_pdwSaferLevels = new DWORD[RSOP_SAFER_LEVELS];
            if ( m_pdwSaferLevels )
            {
                memset (m_pdwSaferLevels, NO_MORE_SAFER_LEVELS, 
                            sizeof (DWORD) * RSOP_SAFER_LEVELS);
                m_pdwSaferLevels[0] = SAFER_LEVELID_FULLYTRUSTED;
                m_pdwSaferLevels[1] = SAFER_LEVELID_DISALLOWED;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateLevels (): 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\complete.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       complete.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Complete.h"
#include "AddSheet.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizComplete property page


CAddEFSWizComplete::CAddEFSWizComplete() : CWizard97PropertyPage(CAddEFSWizComplete::IDD)
{
	//{{AFX_DATA_INIT(CAddEFSWizComplete)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

CAddEFSWizComplete::~CAddEFSWizComplete()
{
}

void CAddEFSWizComplete::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddEFSWizComplete)
	DDX_Control(pDX, IDC_BIGBOLD, m_bigBoldStatic);
	DDX_Control(pDX, IDC_ADDLIST, m_UserAddList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddEFSWizComplete, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(CAddEFSWizComplete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizComplete message handlers

BOOL CAddEFSWizComplete::OnSetActive() 
{
	BOOL bResult = CWizard97PropertyPage::OnSetActive ();

	if ( bResult )
	{
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH | PSWIZB_BACK);

		SetUserList();
	}

	return bResult;
}

void CAddEFSWizComplete::SetUserList()
{
    CAddEFSWizSheet*	pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
	ASSERT (pAddSheet);
	if ( !pAddSheet )
		return;

    PUSERSONFILE	Token = NULL;
    CString			UserName;
    CString			DnName;

    try {
        CString UnKnownUser;
        CString NoCertName;

        VERIFY (UnKnownUser.LoadString(IDS_UNKNOWNUSER));
        VERIFY (NoCertName.LoadString(IDS_NOCERTNAME));
        Token = pAddSheet->StartEnum();
        while (Token)
		{
            Token = pAddSheet->GetNextUser(Token, UserName, DnName);
            if ( (!UserName.IsEmpty()) || (!DnName.IsEmpty()))
			{
                LV_ITEM fillItem;

                fillItem.mask = LVIF_TEXT;
                fillItem.iItem = 0;
                fillItem.iSubItem = 0;

                if (UserName.IsEmpty())
				{
                    fillItem.pszText = UnKnownUser.GetBuffer(UnKnownUser.GetLength() + 1);
                } 
				else 
				{
                    fillItem.pszText = UserName.GetBuffer(UserName.GetLength() + 1);
                }
                fillItem.iItem = m_UserAddList.InsertItem(&fillItem);
                if (UserName.IsEmpty())
				{
                    UnKnownUser.ReleaseBuffer();
                } 
				else 
				{
                    UserName.ReleaseBuffer();
                }
                if (fillItem.iItem != -1 )
				{
                    fillItem.iSubItem = 1;
                    if (DnName.IsEmpty())
					{
                        fillItem.pszText = NoCertName.GetBuffer(NoCertName.GetLength() + 1);
                    } 
					else 
					{
                        fillItem.pszText = DnName.GetBuffer(DnName.GetLength() + 1);
                    }
                    m_UserAddList.SetItem(&fillItem);
                    if (DnName.IsEmpty())
					{
                        NoCertName.ReleaseBuffer();
                    } 
					else 
					{
                        DnName.ReleaseBuffer();
                    }
                }

            }
        }
	}
    catch(...){
                m_UserAddList.DeleteAllItems( );
    }

}

LRESULT CAddEFSWizComplete::OnWizardBack() 
{
    m_UserAddList.DeleteAllItems( );	
	return CWizard97PropertyPage::OnWizardBack();
}

BOOL CAddEFSWizComplete::OnWizardFinish() 
{
    CAddEFSWizSheet*	pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
	ASSERT (pAddSheet);
	if ( !pAddSheet )
		return FALSE;

    pAddSheet->AddNewUsers();	
	return CWizard97PropertyPage::OnWizardFinish();
}

BOOL CAddEFSWizComplete::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();
	
	m_bigBoldStatic.SetFont (&GetBigBoldFont ());

    CString UserNameTitle;
    CString UserDnTitle;
    RECT	ListRect;
    DWORD	ColWidth = 0;


    try {	
	    m_UserAddList.GetClientRect(&ListRect);
        ColWidth = (ListRect.right - ListRect.left)/2;
        VERIFY (UserNameTitle.LoadString(IDS_USERCOLTITLE));
        VERIFY (UserDnTitle.LoadString(IDS_DNCOLTITLE));
        m_UserAddList.InsertColumn(0, UserNameTitle, LVCFMT_LEFT, ColWidth );
        m_UserAddList.InsertColumn(1, UserDnTitle, LVCFMT_LEFT, ColWidth );
    }
    catch (...){
    }
	
    DWORD   color = GetSysColor (COLOR_WINDOW);
    VERIFY (m_UserAddList.SetBkColor (color));
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\componentsafer.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:         cmponent.cpp
//
//  Contents:   Implementation of CCertMgrComponent
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <gpedit.h>
#include "compdata.h" // CCertMgrComponentData
#include "cmponent.h" // CCertMgrComponent
#include "SaferLevel.h"
#include "SaferEntry.h"
#include "storeGPE.h"
#include "SaferUtil.h"
#include "PolicyKey.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HKEY g_hkeyLastSaferRegistryScope = 0;
extern PCWSTR pcszNEWLINE;


HRESULT CCertMgrComponent::AddSaferLevels(
        bool bIsComputer, 
        PCWSTR pszServerName,
        HKEY hGroupPolicyKey)
{
    _TRACE (1, L"Entering CCertMgrComponent::AddSaferLevels ()\n");
    HRESULT         hr = S_OK;
	CWaitCursor		cursor;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();

    if ( dataRef.m_pdwSaferLevels )
    {
        for (UINT nIndex = 0; 
                NO_MORE_SAFER_LEVELS != dataRef.m_pdwSaferLevels[nIndex] && SUCCEEDED (hr); 
                nIndex++)
        {
            CString         szLevel;

            switch (dataRef.m_pdwSaferLevels[nIndex])
            {
            case SAFER_LEVELID_FULLYTRUSTED:
            case SAFER_LEVELID_CONSTRAINED:
            case SAFER_LEVELID_DISALLOWED:
            case SAFER_LEVELID_NORMALUSER:
            case SAFER_LEVELID_UNTRUSTED:
                szLevel = SaferGetLevelFriendlyName (dataRef.m_pdwSaferLevels[nIndex], 
                        hGroupPolicyKey, bIsComputer);
                hr = AddLevel (szLevel, dataRef.m_pdwSaferLevels[nIndex], 
                        bIsComputer,
                        pszServerName);
                break;

            default:
                ASSERT (0);
                _TRACE (0, L"Unexpected safer level while enumerating levels: 0x%x\n", 
                        dataRef.m_pdwSaferLevels[nIndex]);
                break;
            }
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertMgrComponent::AddSaferLevels (): 0x%x\n", hr);
    return hr;
}



HRESULT CCertMgrComponent::AddLevel (
            const CString& szLevel, 
            DWORD dwLevel, 
            bool fIsMachine, 
            PCWSTR pszServerName)
{
    _TRACE (1, L"Entering CCertMgrComponent::AddLevel ()\n");
    HRESULT         hr = S_OK;
    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
	CCookie&		rootCookie = dataRef.QueryBaseRootCookie ();


	RESULTDATAITEM	rdItem;
	::ZeroMemory (&rdItem, sizeof (rdItem));
	rdItem.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
	rdItem.nCol = 0;

    CSaferLevel*    pNewLevel = new CSaferLevel (
            dwLevel,
            fIsMachine,
            pszServerName,
            szLevel,
            dataRef.m_pGPEInformation,
            fIsMachine ?
                dataRef.m_rsopObjectArrayComputer :
                dataRef.m_rsopObjectArrayUser);
	if ( pNewLevel )
    {
        if ( pNewLevel->IsDefault () )
        {
            rdItem.nImage = iIconDefaultSaferLevel;
            dataRef.m_dwDefaultSaferLevel = pNewLevel->GetLevel ();
        }
        else
            rdItem.nImage = iIconSaferLevel;
	    rootCookie.m_listResultCookieBlocks.AddHead (pNewLevel);
	    rdItem.str = MMC_TEXTCALLBACK ;
	    rdItem.lParam = (LPARAM) pNewLevel;
	    pNewLevel->m_resultDataID = m_pResultData;
	    hr = m_pResultData->InsertItem (&rdItem);
        if ( FAILED (hr) )
        {
             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
        }
    }
    else
	{
		hr = E_OUTOFMEMORY;
	}
    _TRACE (-1, L"Leaving CCertMgrComponent::AddLevel () : 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferEnumerateEntries (
            bool bIsComputer, 
            CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateEntries ()\n");
    HRESULT hr = S_OK;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
   
    if ( dataRef.m_pGPEInformation )
    {
        CPolicyKey policyKey (dataRef.m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                bIsComputer);
        hr = SetRegistryScope (policyKey.GetKey (), bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            hr = SaferEnumerateNonCertEntries (policyKey.GetKey (), 
                    bIsComputer);

            hr = SaferEnumerateCertEntries (
                    bIsComputer, 
                    pSaferEntries);
        }
    }
    else if ( dataRef.m_bIsRSOP )
    {
        hr = SaferEnumerateRSOPNonCertEntries (bIsComputer, pSaferEntries);

        hr = SaferEnumerateCertEntries (bIsComputer, 
                pSaferEntries);
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateEntries () : 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::SaferEnumerateRSOPNonCertEntries (
        bool bIsComputer, 
        CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateRSOPNonCertEntries\n");
    HRESULT                 hr = S_OK;
    int                     nIndex = 0;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    CString                 szKeyStart (SAFER_HKLM_REGBASE);
    const CRSOPObjectArray* pObjectArray = bIsComputer ?
        dataRef.GetRSOPObjectArrayComputer () : dataRef.GetRSOPObjectArrayUser ();
    INT_PTR                 nUpperBound = pObjectArray->GetUpperBound ();

    szKeyStart += L"\\";
    szKeyStart += SAFER_CODEIDS_REGSUBKEY;
    size_t  nKeyStartLen = wcslen (szKeyStart);

    // Skip the common text and get the level
    long                dwLevel = 0;
    long                dwPreviousLevel = 0;
    CString             szLevel;
    CString             szType;   // hash, url, path
    SAFER_ENTRY_TYPE    type = SAFER_ENTRY_TYPE_UNKNOWN;    // hash, url, path
    SAFER_ENTRY_TYPE    previousType = SAFER_ENTRY_TYPE_UNKNOWN;
    CString             szGUID;
    GUID                guid;
    ::ZeroMemory (&guid, sizeof (GUID));
    bool                bCreateNew = false;
    PSAFER_IDENTIFICATION_HEADER   pCaiCommon = 0;
    CString             szPreviousKey;
    CString             szKey;
    CRSOPObject* pCurrObject = 0;


    while ( nUpperBound >= nIndex )
    {
        if ( pCurrObject )
            szPreviousKey = pCurrObject->GetRegistryKey ();

        pCurrObject = pObjectArray->GetAt (nIndex);
        if ( pCurrObject )
        {
            szKey = pCurrObject->GetRegistryKey ();
            if ( !wcsncmp (szKey, szKeyStart, nKeyStartLen) )
            {
                szKey = szKey.Right ((int) (wcslen (szKey) - (nKeyStartLen + 1)));

                if ( !szKey.IsEmpty () )
                {
                    // get level
                    int nPos = szKey.Find (L'\\');
                    szLevel = szKey.Left (nPos);
                    dwPreviousLevel = dwLevel;
                    dwLevel = wcstol(szLevel, 0, 10);
                    szKey = szKey.Right ((int)(wcslen (szKey) - (nPos + 1)));

                    // get type
                    nPos = szKey.Find (L'\\');
                    szType = szKey.Left (nPos);
                    if ( SAFER_PATHS_REGSUBKEY == szType )
                        type = SAFER_ENTRY_TYPE_PATH;
                    else if ( SAFER_HASHMD5_REGSUBKEY == szType )
                        type = SAFER_ENTRY_TYPE_HASH;
                    else if ( SAFER_SOURCEURL_REGSUBKEY == szType )
                        type = SAFER_ENTRY_TYPE_URLZONE;
                    else
                    {
                        ASSERT (0);
                    }

                    if ( SAFER_ENTRY_TYPE_UNKNOWN == previousType )
                        previousType = type;

                    szKey = szKey.Right ((int) (wcslen (szKey) - (nPos + 1)));
                    
                    // get guid
                    if ( szKey != szGUID )
                    {
                        szGUID = szKey;
                        if ( !GuidFromString (&guid, szGUID) )
                            continue;

                        bCreateNew = true;
                    }
                    else
                        bCreateNew = false;

                    if ( bCreateNew && pCaiCommon )
                    {
                        // If we were working on an old one, create the 
                        // CSaferEntry with the available information and add 
                        // it to the result pane
                        hr = SaferFinishEntryAndAdd (previousType, pCaiCommon,
                                bIsComputer, dwPreviousLevel, pSaferEntries, 
                                szPreviousKey);
                        if ( SUCCEEDED (hr) )
                        {
                            pCaiCommon = 0;
                        }
                        else if ( E_OUTOFMEMORY == hr )
                        {
                            ::LocalFree (pCaiCommon);
                            pCaiCommon = 0;
                        }


                        previousType = type;
                    }

                    switch (type)
                    {
                    case SAFER_ENTRY_TYPE_PATH:
                        if ( bCreateNew )
                        {
                            ASSERT (!pCaiCommon);
                            pCaiCommon = (PSAFER_IDENTIFICATION_HEADER) 
                                ::LocalAlloc (LPTR, sizeof (SAFER_PATHNAME_IDENTIFICATION));
                            if ( pCaiCommon )
                            {
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.cbStructSize = 
                                        sizeof (SAFER_PATHNAME_IDENTIFICATION);
                                memcpy (&((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid, 
                                        &guid, sizeof (GUID));
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.dwIdentificationType = 
                                        SaferIdentityTypeImageName;
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        
                        if ( SUCCEEDED (hr) && pCaiCommon )
                        {
                            if ( SAFER_IDS_DESCRIPTION_REGVALUE == pCurrObject->GetValueName () )
                            {
                                BSTR    bstr = 0;
                                if ( SUCCEEDED (pCurrObject->GetBSTR (&bstr)) )
                                {
                                    wcsncpy (((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->Description, 
                                            bstr, 
                                            SAFER_MAX_DESCRIPTION_SIZE);
                                    SysFreeString (bstr);
                                }
                            }
                            else if ( SAFER_IDS_ITEMDATA_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ASSERT ( MAX_PATH * sizeof (WCHAR) >= pCurrObject->GetBlobLength ());
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->ImageName = 
                                        (PWCHAR) pCurrObject->GetBlob ();
                            }
                            else if ( SAFER_IDS_LASTMODIFIED_REGVALUE == pCurrObject->GetValueName () )
                            {
                                pCurrObject->GetFileTime (
                                        ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.lastModified);
                            }
                            else if ( SAFER_IDS_SAFERFLAGS_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->dwSaferFlags = 
                                        pCurrObject->GetDWORDValue ();
                            }
                        }
                        break;

                    case SAFER_ENTRY_TYPE_HASH:
                        if ( bCreateNew )
                        {
                            ASSERT (!pCaiCommon);
                            pCaiCommon = (PSAFER_IDENTIFICATION_HEADER) 
                                ::LocalAlloc (LPTR, sizeof (SAFER_HASH_IDENTIFICATION));
                            if ( pCaiCommon )
                            {
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.cbStructSize = 
                                        sizeof (SAFER_HASH_IDENTIFICATION);
                                memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid, 
                                        &guid, sizeof (GUID));
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.dwIdentificationType = 
                                        SaferIdentityTypeImageHash;
                                // NTRAID# 424997 SAFER:  File hash not displayed on hash rule property sheets in RSOP mode.
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashSize = 16;
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        
                        if ( SUCCEEDED (hr) && pCaiCommon && !pCurrObject->GetValueName ().IsEmpty () )
                        {
                            if ( SAFER_IDS_ITEMDATA_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ASSERT (SAFER_MAX_HASH_SIZE >= pCurrObject->GetBlobLength ());
                                memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageHash, 
                                        pCurrObject->GetBlob (),
                                        pCurrObject->GetBlobLength ());
                            }
                            else if ( SAFER_IDS_LASTMODIFIED_REGVALUE == pCurrObject->GetValueName () )
                            {
                                pCurrObject->GetFileTime (
                                        ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.lastModified);
                            }
                            else if ( SAFER_IDS_SAFERFLAGS_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->dwSaferFlags = 
                                        pCurrObject->GetDWORDValue ();
                            }
                            else if ( SAFER_IDS_FRIENDLYNAME_REGVALUE == pCurrObject->GetValueName () )
                            {
                                BSTR    bstr = 0;
                                if ( SUCCEEDED (pCurrObject->GetBSTR (&bstr)) )
                                {
                                    wcsncpy (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->FriendlyName,
                                            bstr,
                                            SAFER_MAX_FRIENDLYNAME_SIZE);
                                    SysFreeString (bstr);
                                }
                            }
                            else if ( SAFER_IDS_HASHALG_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ASSERT (sizeof (ALG_ID) == pCurrObject->GetBlobLength ());                                memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashAlgorithm, 
                                        pCurrObject->GetBlob (),
                                        pCurrObject->GetBlobLength ());
                            }
                            else if ( SAFER_IDS_ITEMSIZE_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ASSERT (sizeof (LARGE_INTEGER) == pCurrObject->GetBlobLength ());
                                memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageSize, 
                                        pCurrObject->GetBlob (),
                                        pCurrObject->GetBlobLength ());
                            }
                            else if ( SAFER_IDS_DESCRIPTION_REGVALUE == pCurrObject->GetValueName () )
                            {
                                BSTR    bstr = 0;
                                if ( SUCCEEDED (pCurrObject->GetBSTR (&bstr)) )
                                {
                                    wcsncpy (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->Description, 
                                            bstr, 
                                            SAFER_MAX_DESCRIPTION_SIZE);
                                    SysFreeString (bstr);
                                }
                            }
                            else if ( SAFER_VALUE_NAME_HASH_SIZE == pCurrObject->GetValueName () )
                            {
                                ASSERT (sizeof (LARGE_INTEGER) == pCurrObject->GetBlobLength ());
                                memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashSize, 
                                        pCurrObject->GetBlob (),
                                        pCurrObject->GetBlobLength ());
                            }

                        }
                        break;

                    case SAFER_ENTRY_TYPE_URLZONE:
                        if ( bCreateNew )
                        {
                            ASSERT (!pCaiCommon);
                            pCaiCommon = (PSAFER_IDENTIFICATION_HEADER) 
                                ::LocalAlloc (LPTR, sizeof (SAFER_URLZONE_IDENTIFICATION));
                            if ( pCaiCommon )
                            {
                                ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.cbStructSize = 
                                        sizeof (SAFER_URLZONE_IDENTIFICATION);
                                memcpy (&((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid, 
                                        &guid, sizeof (GUID));
                                ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.dwIdentificationType = 
                                        SaferIdentityTypeUrlZone;
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        
                        if ( SUCCEEDED (hr) && pCaiCommon )
                        {
                            if ( SAFER_IDS_ITEMDATA_REGVALUE == pCurrObject->GetValueName () )
                            {
                                memcpy (&((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->UrlZoneId, 
                                        pCurrObject->GetBlob (),
                                        pCurrObject->GetBlobLength ());
#if DBG
                                SAFER_URLZONE_IDENTIFICATION* pCaiUrlZone = 
                                            (SAFER_URLZONE_IDENTIFICATION*) pCaiCommon;
                                ASSERT (URLZONE_LOCAL_MACHINE == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_INTRANET == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_TRUSTED == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_INTERNET == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_UNTRUSTED == pCaiUrlZone->UrlZoneId);
#endif DBG
                            }
                            else if ( SAFER_IDS_LASTMODIFIED_REGVALUE == pCurrObject->GetValueName () )
                            {
                                pCurrObject->GetFileTime (
                                        ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.lastModified);
                            }
                            else if ( SAFER_IDS_SAFERFLAGS_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->dwSaferFlags = 
                                        pCurrObject->GetDWORDValue ();
                            }
                        }
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
            }
        }
        else
            break;
        nIndex++;
    }

    if ( pCaiCommon )
    {
        // If we were working on an old one, create the 
        // CSaferEntry with the available information and add 
        // it to the result pane
        hr = SaferFinishEntryAndAdd (previousType, pCaiCommon,
                bIsComputer, dwLevel, pSaferEntries, 
                szPreviousKey);
        if ( SUCCEEDED (hr) )
        {
            pCaiCommon = 0;
        }
        else if ( E_OUTOFMEMORY == hr )
        {
            ::LocalFree (pCaiCommon);
            pCaiCommon = 0;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateRSOPNonCertEntries: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::SaferFinishEntryAndAdd (SAFER_ENTRY_TYPE previousType, 
            PSAFER_IDENTIFICATION_HEADER pCaiCommon, 
            bool bIsComputer, 
            long dwLevel,
            CSaferEntries* pSaferEntries, 
            const CString& szPreviousKey)
{
    HRESULT hr = S_OK;
    CString szSubjectName; 
    switch (previousType)
    {
    case SAFER_ENTRY_TYPE_PATH:
        szSubjectName = ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->ImageName;
        break;

    case SAFER_ENTRY_TYPE_HASH:
        szSubjectName = ((PSAFER_HASH_IDENTIFICATION) (pCaiCommon))->FriendlyName;
        szSubjectName.Replace (pcszNEWLINE, L"  ");
        break;

    case SAFER_ENTRY_TYPE_URLZONE:
        szSubjectName = GetURLZoneFriendlyName (
                ((SAFER_URLZONE_IDENTIFICATION*) pCaiCommon)->UrlZoneId);
        break;

    default:
        ASSERT (0);
        break;
    }

    ASSERT (pCaiCommon);
    if ( pCaiCommon )
    {
        hr = InsertNewSaferEntry (
                previousType, 
                bIsComputer, 
                szSubjectName,
                pCaiCommon,
                dwLevel,
                pSaferEntries,
                QueryComponentDataRef ().m_pGPEInformation,
                0,
                szPreviousKey);
    }
    return hr; 
}


HRESULT CCertMgrComponent::InsertNewSaferEntry (
        SAFER_ENTRY_TYPE type, 
        bool bIsComputer, 
        PCWSTR pwcszObjectName, 
        PSAFER_IDENTIFICATION_HEADER pCaiCommon,
        DWORD dwLevel,
        CSaferEntries* pSaferEntries,
        IGPEInformation* pGPEInformation,
        CCertificate* pCert,
        PCWSTR pszRSOPRegistryKey)
{
    _TRACE (1, L"Entering CCertMgrComponent::InsertNewSaferEntry (%s)\n", pwcszObjectName);
    HRESULT hr = S_OK;

    switch (type)
    {
    case SAFER_ENTRY_TYPE_PATH:
        ASSERT (pCaiCommon && 
                SaferIdentityTypeImageName == pCaiCommon->dwIdentificationType);
        break;

    case SAFER_ENTRY_TYPE_HASH:
        ASSERT (pCaiCommon && 
                SaferIdentityTypeImageHash == pCaiCommon->dwIdentificationType);
        break;

    case SAFER_ENTRY_TYPE_URLZONE:
        ASSERT (pCaiCommon && 
                SaferIdentityTypeUrlZone == pCaiCommon->dwIdentificationType);
        break;

    case SAFER_ENTRY_TYPE_CERT:
        ASSERT (pCert);
        break;

    default:
        ASSERT (0);
        break;
    }

    CSaferEntry* pNewEntry = new CSaferEntry (
            type, 
            bIsComputer,
            L"", 
            pwcszObjectName,
            pCaiCommon,
            dwLevel,
            pGPEInformation,
            pCert,
            pSaferEntries,
            bIsComputer ? QueryComponentDataRef ().m_rsopObjectArrayComputer : 
                    QueryComponentDataRef ().m_rsopObjectArrayUser,
            pszRSOPRegistryKey);
    if ( pNewEntry )
    {
	    RESULTDATAITEM	rdItem;

	    ::ZeroMemory (&rdItem, sizeof (rdItem));
	    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        switch (type)
        {
        case SAFER_ENTRY_TYPE_HASH:
            rdItem.nImage = iIconSaferHashEntry;
            break;

        case SAFER_ENTRY_TYPE_PATH:
            rdItem.nImage = iIconSaferNameEntry;
            break;

        case SAFER_ENTRY_TYPE_CERT:
    	    rdItem.nImage = iIconSaferCertEntry;
            break;

        case SAFER_ENTRY_TYPE_URLZONE:
            rdItem.nImage = iIconSaferURLEntry;
            break;

        default:
            ASSERT (0);
            break;
        }
	    rdItem.nCol = 0;
	    rdItem.str = MMC_TEXTCALLBACK;
	    QueryComponentDataRef ().QueryBaseRootCookie ().m_listResultCookieBlocks.AddHead (pNewEntry);
	    rdItem.lParam = (LPARAM) pNewEntry;
	    pNewEntry->m_resultDataID = m_pResultData;
	    hr = m_pResultData->InsertItem (&rdItem);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_OUTOFMEMORY;

    _TRACE (-1, L"Leaving CCertMgrComponent::InsertNewSaferEntry (%s): 0x%x\n", pwcszObjectName, hr);
    return hr;
}

HRESULT CCertMgrComponent::SaferEnumerateNonCertEntries (
        HKEY hGroupPolicyKey, 
        bool bIsComputer)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateNonCertEntries ()\n");
    ASSERT (0 != g_hkeyLastSaferRegistryScope);
    HRESULT hr = S_OK;
    DWORD*  pdwLevels = 0;
    DWORD   cbBuffer = 0;

    SetRegistryScope (hGroupPolicyKey, bIsComputer);
    BOOL    bRVal = SaferGetPolicyInformation (
            SAFER_SCOPEID_REGISTRY,
            SaferPolicyLevelList,
            cbBuffer,
            pdwLevels,
            &cbBuffer,
            0);
    if ( !bRVal && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
    {
        DWORD   nLevels = cbBuffer/sizeof (DWORD);
        pdwLevels = new DWORD[nLevels];
        if ( pdwLevels )
        {
            bRVal = SaferGetPolicyInformation (
                SAFER_SCOPEID_REGISTRY,
                SaferPolicyLevelList,
                cbBuffer,
                pdwLevels,
                &cbBuffer,
                0);
            ASSERT (bRVal);
            if ( bRVal )
            {
                for (DWORD dwIndex = 0; dwIndex < nLevels; dwIndex++)
                {
                    hr = SaferEnumerateEntriesAtLevel (
                            bIsComputer,
                            hGroupPolicyKey, 
                            pdwLevels[dwIndex]);
                }
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n", 
                        dwErr);
            }
            delete [] pdwLevels;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if ( !bRVal )
    {
        ASSERT (0);
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n",
                dwErr);
    }


    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateNonCertEntries (): 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferEnumerateCertEntries (
        bool bIsComputer,
        CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateCertEntries ()\n");
    HRESULT hr = S_OK;
    CCertStore* pTrustedPublisherStore = 0;
    hr = pSaferEntries->GetTrustedPublishersStore (&pTrustedPublisherStore);
    if ( pTrustedPublisherStore )
    {
		hr = EnumSaferCertificates (
                bIsComputer, 
                *pTrustedPublisherStore, 
                pSaferEntries);
		if ( SUCCEEDED (hr) )
		{
			m_currResultNodeType = bIsComputer ?
                    CERTMGR_SAFER_COMPUTER_ENTRY : CERTMGR_SAFER_USER_ENTRY;
			m_pResultData->Sort (m_nSelectedSaferEntryColumn, 0, 
                    (long) m_currResultNodeType);
		}

        pTrustedPublisherStore->Release ();
    }
    else
        hr = E_OUTOFMEMORY;

    CCertStore* pDisallowedStore = 0;
    hr = pSaferEntries->GetDisallowedStore (&pDisallowedStore);
    if ( pDisallowedStore )
    {
		hr = EnumSaferCertificates (
                bIsComputer, 
                *pDisallowedStore, 
                pSaferEntries);
		if ( SUCCEEDED (hr) )
		{
			m_currResultNodeType = bIsComputer ?
                    CERTMGR_SAFER_COMPUTER_ENTRY : CERTMGR_SAFER_USER_ENTRY;
			m_pResultData->Sort (m_nSelectedSaferEntryColumn, 0, 
                    (long) m_currResultNodeType);
		}

        pDisallowedStore->Release ();
    }
    else
        hr = E_OUTOFMEMORY;


    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateCertEntries (): 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::EnumSaferCertificates (
        bool bIsComputer, 
        CCertStore& rCertStore, 
        CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

	_TRACE (1, L"Entering CCertMgrComponent::EnumCertificates\n");
	CWaitCursor		cursor;
    PCCERT_CONTEXT	pCertContext = 0;
	HRESULT			hr = 0;
	CCertificate*	pCert = 0;
    DWORD           dwLevelID = SAFER_TRUSTED_PUBLISHER_STORE == rCertStore.GetStoreType () ? 
                            SAFER_LEVELID_FULLYTRUSTED : SAFER_LEVELID_DISALLOWED;

	//	Iterate through the list of certificates in the system store,
	//	allocate new certificates with the CERT_CONTEXT returned,
	//	and store them in the certificate list.
	while ( 1 )
	{
		pCertContext = rCertStore.EnumCertificates (pCertContext);
		if ( !pCertContext )
			break;

		pCert =
			new CCertificate (pCertContext, &rCertStore);
		if ( pCert )
        {
            hr = InsertNewSaferEntry (SAFER_ENTRY_TYPE_CERT,
                    bIsComputer,
                    pCert->GetSubjectName (), 
                    0,
                    dwLevelID,
                    pSaferEntries,
                    QueryComponentDataRef ().m_pGPEInformation,
                    pCert);
            if ( FAILED (hr) )
                break;
            pCert->Release ();
        }
        else
		{
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	rCertStore.Close ();

	_TRACE (-1, L"Leaving CCertMgrComponent::EnumCertificates: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponent::SaferEnumerateEntriesAtLevel (
            bool bIsComputer, 
            HKEY hGroupPolicyKey, 
            DWORD dwLevel)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateEntriesAtLevel (%d)\n", dwLevel);
    SetRegistryScope (hGroupPolicyKey, bIsComputer);
    HRESULT     hr = S_OK;
    SAFER_LEVEL_HANDLE hLevel = 0;
    BOOL        bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
            dwLevel,
            SAFER_LEVEL_OPEN,
            &hLevel,
            hGroupPolicyKey);
    ASSERT (bRVal);
    if ( bRVal )
    {
        DWORD   dwBufferSize = 0;
        bRVal = SaferGetLevelInformation(hLevel, 
                SaferObjectAllIdentificationGuids,
                0,
                dwBufferSize,
                &dwBufferSize);
        if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
        {
            DWORD   nGuids = dwBufferSize/sizeof (GUID);
            GUID*   pGuids = new GUID[nGuids];
            if ( pGuids )
            {
                bRVal = SaferGetLevelInformation(hLevel, 
                        SaferObjectAllIdentificationGuids,
                        pGuids,
                        dwBufferSize,
                        &dwBufferSize);
                ASSERT (bRVal);
                if ( bRVal )
                {
                    for (DWORD dwIndex = 0; dwIndex < nGuids; dwIndex++)
                    {
                        hr = SaferGetSingleEntry (bIsComputer, hLevel, 
                                pGuids[dwIndex], dwLevel);
                    }
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"SaferGetLevelInformation (SaferObjectAllIdentificationGuids) failed: %d\n",
                            dwErr);
                }
                delete [] pGuids;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else if ( !bRVal )
        {
            DWORD   dwErr = GetLastError ();
            ASSERT (ERROR_NOT_FOUND == dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"SaferGetLevelInformation (SaferObjectAllIdentificationGuids) failed: %d\n",
                    dwErr);
        }

        VERIFY (SaferCloseLevel (hLevel));
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferCreateLevel (SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                dwLevel, dwErr);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateEntriesAtLevel () : 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferGetSingleEntry(
        bool bIsComputer, 
        SAFER_LEVEL_HANDLE hLevel, 
        GUID &rEntryGuid,
        DWORD  dwLevelID)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferGetSingleEntry ()\n");
    ASSERT (0 != g_hkeyLastSaferRegistryScope);
    HRESULT hr = S_OK;
    DWORD   dwBufferSize = sizeof (SAFER_IDENTIFICATION_HEADER);
    SAFER_IDENTIFICATION_HEADER    caiCommon;
    ::ZeroMemory (&caiCommon, sizeof (SAFER_IDENTIFICATION_HEADER));
    caiCommon.cbStructSize = dwBufferSize;
    memcpy (&caiCommon.IdentificationGuid, &rEntryGuid, sizeof (GUID));


    BOOL bRVal = SaferGetLevelInformation(hLevel, 
            SaferObjectSingleIdentification,
            &caiCommon,
            dwBufferSize,
            &dwBufferSize);
    if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
    {
        PBYTE   pBytes = (PBYTE) LocalAlloc (LPTR, dwBufferSize);
        if ( pBytes )
        {
            SAFER_ENTRY_TYPE    saferEntryType = SAFER_ENTRY_TYPE_UNKNOWN;
            PSAFER_IDENTIFICATION_HEADER pCommon = (PSAFER_IDENTIFICATION_HEADER) pBytes;
            pCommon->cbStructSize = dwBufferSize;
            memcpy (&pCommon->IdentificationGuid, &rEntryGuid, sizeof (GUID));

            bRVal = SaferGetLevelInformation(hLevel, 
                    SaferObjectSingleIdentification,
                    pBytes,
                    dwBufferSize,
                    &dwBufferSize);
            ASSERT (bRVal);
            if ( bRVal )
            {
                CString   szObjectName;

                switch (pCommon->dwIdentificationType)
                {
                case SaferIdentityTypeImageName:
                    szObjectName = ((PSAFER_PATHNAME_IDENTIFICATION) (pCommon))->ImageName;
                    saferEntryType = SAFER_ENTRY_TYPE_PATH;
                    break;

                case SaferIdentityTypeImageHash:
                    szObjectName = ((PSAFER_HASH_IDENTIFICATION) (pCommon))->FriendlyName;

                    // replace new-line characters with spaces
                    szObjectName.Replace (pcszNEWLINE, L"  ");
                    saferEntryType = SAFER_ENTRY_TYPE_HASH;
                    break;

                case SaferIdentityTypeUrlZone:
                    szObjectName = GetURLZoneFriendlyName (
                            ((PSAFER_URLZONE_IDENTIFICATION) (pCommon))->UrlZoneId);
                    saferEntryType = SAFER_ENTRY_TYPE_URLZONE;
                    break;

                default:
                    ASSERT (0);
                    break;
                }

                hr = InsertNewSaferEntry (
                        saferEntryType, 
                        bIsComputer, 
                        szObjectName, 
                        pCommon,
                        dwLevelID,
                        0,
                        QueryComponentDataRef ().m_pGPEInformation,
                        0);
                if ( E_OUTOFMEMORY == hr )
                    ::LocalFree (pBytes);
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetLevelInformation (SaferObjectSingleIdentification) failed: %d\n",
                        dwErr);
            }
            // pBytes is freed in ~CSaferEntry
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if ( !bRVal )
    {
        ASSERT (0);
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferGetLevelInformation (SaferObjectSingleIdentification) failed: %d\n",
                dwErr);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferGetSingleEntry (): 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::DeleteSaferEntryFromResultPane (
        CSaferEntry * pSaferEntry, 
        LPDATAOBJECT pDataObject, 
        bool bDoCommit)
{
	_TRACE (1, L"Entering CCertMgrComponent::DeleteSaferEntryFromResultPane\n");
	HRESULT hr = S_OK;
	hr = pSaferEntry->Delete (bDoCommit);
    if ( SUCCEEDED (hr) )
	{
		HRESULTITEM	itemID = 0;
		hr = m_pResultData->FindItemByLParam ( (LPARAM) pSaferEntry, &itemID);
		if ( SUCCEEDED (hr) )
		{
			hr = m_pResultData->DeleteItem (itemID, 0);
		}

		// If we can't succeed in removing this one item, then update the whole panel.
		if ( !SUCCEEDED (hr) )
		{
			hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
		}
	}
	else
	{
		CString text;
		CString	caption;

		VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
		text.FormatMessage (IDS_CANT_DELETE_SAFER_ENTRY, GetSystemMessage (hr));
		int		iRetVal = 0;
		VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
				MB_OK, &iRetVal)));
	}

	_TRACE (-1, L"Leaving CCertMgrComponent::DeleteSaferEntryFromResultPane: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponent::OnNotifyCanPasteOutOfProc (LPBOOL pbCanHandle)
{
    if ( !pbCanHandle )
        return E_POINTER;

    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
    CLSID   clsID;
    if ( SUCCEEDED (dataRef.GetClassID (&clsID)) )
    {
        if ( CLSID_SaferWindowsExtension == clsID )
            *pbCanHandle = TRUE;
    }

    return S_OK;    // snapins should redefine this
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\cookie.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Cookie.cpp
//
//  Contents:   Implementation of CCertMgrCookie and related classes
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include <gpedit.h>
#include "cookie.h"
#include "storegpe.h"
#pragma warning(push, 3)
#include <atlimpl.cpp>
#pragma warning(pop)

DECLARE_INFOLEVEL(CertificateManagerSnapin)

USE_HANDLE_MACROS("CERTMGR(cookie.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcooki.cpp"
#include "stdutils.cpp"
#include "certifct.h"


//
// CCertMgrCookie
//

// returns <0, 0 or >0


CCertMgrCookie::CCertMgrCookie (CertificateManagerObjectType objecttype,
		LPCWSTR lpcszMachineName,
		LPCWSTR objectName)
	: CStoresMachineName (lpcszMachineName),
	m_objecttype (objecttype),
	m_objectName (objectName),
	m_resultDataID (0),
    m_nOpenPageCount (0)
{
	ASSERT (IsValidObjectType (m_objecttype));
	if ( m_objectName.IsEmpty () )
	{
		AFX_MANAGE_STATE (AfxGetStaticModuleState ());
		VERIFY (m_objectName.LoadString (IDS_CERTIFICATE_MANAGER));
	}
}

CCertMgrCookie::~CCertMgrCookie ()
{
}


HRESULT CCertMgrCookie::CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult )
{
	ASSERT (pOtherCookie);

	CCertMgrCookie* pcookie = reinterpret_cast <CCertMgrCookie*>(pOtherCookie);
	ASSERT (pcookie);
	if ( pcookie && m_objecttype != pcookie->m_objecttype )
	{
		*pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype); // arbitrary ordering
		return S_OK;
	}

	return E_UNEXPECTED;
}

CCookie* CCertMgrCookie::QueryBaseCookie(int i)
{
	ASSERT(!i);
	return (CCookie*)this;
}

int CCertMgrCookie::QueryNumCookies()
{
	return 1;
}

LPCWSTR CCertMgrCookie::GetObjectName()
{
	return m_objectName;
}

HRESULT CCertMgrCookie::Commit()
{
	return S_OK;
}

UINT CCertMgrCookie::IncrementOpenPageCount ()
{
    m_nOpenPageCount++;
    return m_nOpenPageCount;
}

UINT CCertMgrCookie::DecrementOpenPageCount ()
{
    ASSERT (0 != m_nOpenPageCount);
    if ( 0 != m_nOpenPageCount )
        m_nOpenPageCount--;

    return m_nOpenPageCount;
}

bool CCertMgrCookie::HasOpenPropertyPages () const
{
    return (0 != m_nOpenPageCount) ? true : false;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CCertStore::CCertStore (
		CertificateManagerObjectType	objecttype,
		LPCSTR							pszStoreProv,
		DWORD							dwFlags,
		LPCWSTR							lpcszMachineName,
		LPCWSTR							objectName,
		const CString &					pcszLogStoreName,
		const CString &					pcszPhysStoreName,
		const SPECIAL_STORE_TYPE		storeType,
		const DWORD						dwLocation,
		IConsole*						pConsole)
	: CCertMgrCookie (objecttype,
		lpcszMachineName,
		objectName),
	m_hCertStore (0),
	m_dwFlags (dwFlags),
	m_storeProvider (pszStoreProv),
	m_pcszStoreName (pcszLogStoreName),
	m_storeType (storeType),
	m_bReadOnly (false),
	m_bUnableToOpenMsgDisplayed (false),
	m_dwLocation (dwLocation),
	m_pConsole (pConsole),
	m_bDirty (false),
	m_fReadOnlyFlagChecked (false),
	m_nCertCount (0),
	m_fCertCountValid (false),
    m_nLockCnt (0) // test
{
	_TRACE (1, L"Entering CCertStore::CCertStore LS: %s  PS: %s\n",
			(LPCWSTR) pcszLogStoreName,
			(LPCWSTR) pcszPhysStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	if ( CERT_STORE_PROV_COLLECTION != pszStoreProv )
	{
		ASSERT (!pcszLogStoreName.IsEmpty ());
		if ( !pcszPhysStoreName.IsEmpty () )
			m_pcszStoreName += _T("\\") + pcszPhysStoreName;
	}
	ASSERT (m_pConsole);
	if ( m_pConsole )
		m_pConsole->AddRef ();
	_TRACE (-1, L"Leaving CCertStore::CCertStore - %s\n",
			(LPCWSTR) m_pcszStoreName);
}


CCertStore::~CCertStore ()
{
	_TRACE (1, L"Entering CCertStore::~CCertStore - %s\n",
			(LPCWSTR) m_pcszStoreName);
	Close (true);   // force close
	if ( m_pConsole )
		m_pConsole->Release ();
	_TRACE (-1, L"Leaving CCertStore::~CCertStore - %s\n",
			(LPCWSTR) m_pcszStoreName);
}

HCERTSTORE	CCertStore::GetStoreHandle (BOOL bSilent /* = FALSE*/, HRESULT* phr /* = 0*/)
{
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);

    DWORD   dwErr = 0;
	if ( !m_hCertStore )
	{
		void*	pvPara = 0;
		
		if ( CERT_STORE_PROV_COLLECTION != m_storeProvider )
			pvPara = (void*)(LPCWSTR) m_pcszStoreName;
		m_dwFlags |= CERT_STORE_SET_LOCALIZED_NAME_FLAG;

    	_TRACE (0, L"Opening %s store\n", (LPCWSTR) m_pcszStoreName);
		m_hCertStore = ::CertOpenStore (m_storeProvider,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				NULL,
				m_dwFlags | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
				pvPara);
		if ( !m_hCertStore )
		{
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"Open of %s store failed. 0x%x\n", (LPCWSTR) m_pcszStoreName,
					dwErr);
        	_TRACE (0, L"Opening %s store (read-only)\n", (LPCWSTR) m_pcszStoreName);
			m_dwFlags |= CERT_STORE_READONLY_FLAG;
			m_hCertStore = ::CertOpenStore (m_storeProvider,
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
					NULL,
					m_dwFlags,
					pvPara);
			if ( m_hCertStore )
				m_bReadOnly = true;
			else
			{
                dwErr = GetLastError ();
                if ( phr )
                    *phr = HRESULT_FROM_WIN32 (dwErr);
				_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
							(PCWSTR) m_pcszStoreName, dwErr);			
            }
		}
		if ( !m_hCertStore )
		{
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"Open of %s store (read-only) failed. 0x%x\n", 
					(LPCWSTR) m_pcszStoreName, dwErr);
			if ( CERT_STORE_PROV_FILENAME_W == m_storeProvider)
			{
                _TRACE (0, L"Open %s store (file-based).\n", (LPCWSTR) m_pcszStoreName);
			    DWORD   cbData = 0;
				BYTE*	pbData = NULL;

				//get the BLOB from the file
				HRESULT hr = RetrieveBLOBFromFile ((LPCWSTR) m_pcszStoreName, 
						&cbData, &pbData);
				if ( SUCCEEDED (hr) )
				{
					//open a generic memory store
					m_hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
							 0, NULL,
							 CERT_STORE_SET_LOCALIZED_NAME_FLAG | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
							 NULL);


					if ( m_hCertStore )
					{
						if ( !CertAddSerializedElementToStore (
								m_hCertStore,
								pbData,
								cbData,
								CERT_STORE_ADD_ALWAYS,
								0,
								CERT_STORE_ALL_CONTEXT_FLAG,
								NULL,
								NULL) )
						{
							// CertAddSerializedElementToStore failed.  This means this is probably a
							// base64 certificate or a store containing a base64 certificate.  Open it
							// up with CryptQueryObject.
							_TRACE (0, L"CCertStore::GetStoreHandle () - File input is not a serialized element.\n");
							DWORD			dwMsgAndCertEncodingType = 0;
							DWORD			dwContentType = 0;
							DWORD			dwFormatType = 0;
							PCERT_CONTEXT	pCertContext = 0;
							CERT_BLOB		certBlob;
							HCERTSTORE		hCertStore = 0;

							::ZeroMemory (&certBlob, sizeof (CERT_BLOB));
							certBlob.cbData = cbData;
							certBlob.pbData = pbData;
							BOOL	bResult = ::CryptQueryObject (
										CERT_QUERY_OBJECT_BLOB, // CERT_QUERY_OBJECT_FILE,
										(void *) &certBlob, //(LPCWSTR) m_pcszStoreName,
										CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
											CERT_QUERY_CONTENT_FLAG_CERT |
											CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
											CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED |
											CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
										CERT_QUERY_FORMAT_FLAG_ALL,
										0,
										&dwMsgAndCertEncodingType,
										&dwContentType,
										&dwFormatType,
										&hCertStore,
										NULL,
										(const void **) &pCertContext);
							if ( bResult && pCertContext )
							{		
								// The file contains a certificate context
								hr = AddCertificateContext (pCertContext, 0, false);
							}
							else if ( bResult && hCertStore )
							{
								// The file contains a certificate store, so close the temporary memory store we created
								// and assign the returned store handle to the global handle.
								::CertCloseStore (m_hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
								m_hCertStore = hCertStore;
							}
							else
							{
								CString	caption;
								CString	message;
								int		iRetVal = 0;

								VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
								VERIFY (message.LoadString (IDS_UNKNOWN_CERT_FILE_TYPE));

								if ( m_pConsole )
									m_pConsole->MessageBox (message, caption, MB_ICONWARNING | MB_OK, &iRetVal);
							}
						}
					}
					else
					{
                        dwErr = GetLastError ();
						_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
								(PCWSTR) m_pcszStoreName, dwErr);
					}
				}
				else
				{
					_TRACE (0, L"CCertStore::GetStoreHandle () - Unable to retrieve BLOB from file: %x.\n", hr);
				}
                if ( phr )
                    *phr = hr;
			}
		}
        else
        {
            _TRACE (0, L"Open of %s store succeeded.\n", (LPCWSTR) m_pcszStoreName);
        }
	}

	if ( !m_hCertStore && !m_bUnableToOpenMsgDisplayed && !bSilent && 
            (USERDS_STORE != GetStoreType ()) )
	{
		m_bUnableToOpenMsgDisplayed = true;
		CString	caption;
		CString	text;
		int		iRetVal = 0;

		VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
		text.FormatMessage (IDS_UNABLE_TO_OPEN_STORE, GetStoreName (), 
                GetSystemMessage (dwErr));
		if ( m_pConsole )
			m_pConsole->MessageBox ( text, caption, MB_OK, &iRetVal);
	}

	return m_hCertStore;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
// Note; Memory is allocated via malloc.    S_OK is returned
//       via succees
//
//
//
//---------------------------------------------------------------------------------
HRESULT CCertStore::RetrieveBLOBFromFile (LPCWSTR pwszFileName, DWORD *pcb, BYTE **ppb)
{
	_TRACE (1, L"Entering CCertStore::RetrieveBLOBFromFile - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	HRESULT	hr = S_OK;
	HANDLE	hFile = NULL;
	DWORD	dwBytesRead = 0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

	hFile = ::CreateFile (pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
    if (INVALID_HANDLE_VALUE != hFile )
    {
        *pcb = GetFileSize(hFile, NULL);
        if ( 0xffffffff != *pcb )
        {
            *ppb = (BYTE *)malloc(*pcb);

	        if ( *ppb )
            {
                 // Read the pkcs7 message
                if ( !ReadFile(hFile,
                              *ppb,
                              *pcb,
                              &dwBytesRead,
                              NULL) ||
                       dwBytesRead != *pcb )
	            {
			        free(*ppb);
			        *ppb=NULL;
                    hr = HRESULT_FROM_WIN32(GetLastError());;
	            }
            }
            else
		        hr = E_OUTOFMEMORY;
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

	     //close the file handle
	    CloseHandle(hFile);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());


	_TRACE (-1, L"Leaving CCertStore::RetrieveBLOBFromFile - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return S_OK;
}



bool CCertStore::IsReadOnly ()
{
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);

	// GetCertStore () sets the read-only checked flag
	// Optimization: If the flag is true, it's already been set.
	if ( !m_fReadOnlyFlagChecked )	
	{
		GetStoreHandle ();
		Close ();
		m_fReadOnlyFlagChecked = true;
	}

	return m_bReadOnly;
}


HRESULT CCertStore::Commit()
{
	_TRACE (1, L"Entering CCertStore::Commit - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	HRESULT hr = CCertMgrCookie::Commit ();

	if ( m_hCertStore && !m_bReadOnly && m_bDirty )
	{
		BOOL	bResult = ::CertControlStore (m_hCertStore, 0,
				CERT_STORE_CTRL_COMMIT, NULL);
		if ( bResult )
			m_bDirty = false;
		else
		{
			DWORD	dwErr = GetLastError ();
			hr = HRESULT_FROM_WIN32 (dwErr);

			if ( E_ACCESSDENIED == hr )
			{
				m_bReadOnly = true;
				m_dwFlags |= CERT_STORE_READONLY_FLAG;
			}
			else
			{
				LPVOID	lpMsgBuf = 0;
					
				FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
						NULL,
						dwErr,
						MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
						 (LPWSTR) &lpMsgBuf,    0,    NULL);
					
				// Display the string.
				CString	caption;
				CString message;
				int		iRetVal = 0;

				VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
				message.FormatMessage (IDS_CANT_SAVE_STORE, GetStoreName (), (LPWSTR) lpMsgBuf);
				if ( m_pConsole )
					m_pConsole->MessageBox ((LPCWSTR) message, (LPCWSTR) caption,
							MB_OK, &iRetVal);
				// Free the buffer.
				LocalFree (lpMsgBuf);
			}
		}
	}

	_TRACE (-1, L"Leaving CCertStore::Commit - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return hr;
}


bool CCertStore::ContainsCertificates()
{
	_TRACE (1, L"Entering CCertStore::ContainsCertificates - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	bool	bResult = false;

	bResult = (GetCertCount () > 0);
	_TRACE (-1, L"Leaving CCertStore::ContainsCertificates - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return bResult;
}

bool CCertStore::ContainsCRLs()
{
	_TRACE (1, L"Entering CCertStore::ContainsCRLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	bool	bResult = false;
	PCCRL_CONTEXT	pCRLContext = EnumCRLs (0);
	if ( !pCRLContext )
		bResult = false;
	else
	{
		::CertFreeCRLContext (pCRLContext);
		bResult = true;
	}
	Close ();

	_TRACE (-1, L"Leaving CCertStore::ContainsCRLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return bResult;
}

bool CCertStore::ContainsCTLs()
{
	_TRACE (1, L"Entering CCertStore::ContainsCTLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	bool	bResult = false;
	PCCTL_CONTEXT	pCTLContext = EnumCTLs (0);
	if ( !pCTLContext )
		bResult = false;
	else
	{
		::CertFreeCTLContext (pCTLContext);
		bResult = true;
	}
	Close ();

	_TRACE (-1, L"Leaving CCertStore::ContainsCTLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return bResult;
}


LPCWSTR CCertStore::GetLocalizedName()
{
//	_TRACE (1, L"Entering CCertStore::GetLocalizedName - %s\n",
//			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	if ( m_localizedName.IsEmpty () )
	{
		m_localizedName = ::CryptFindLocalizedName (GetObjectName ());
		if ( m_localizedName.IsEmpty () )
		{
			DWORD		cbLocalizedName;
            HCERTSTORE	hStore = 0;
            bool        bStoreOpenedByThisMethod = false;

            // NTRAID# 366562 Safer:  Inconsistent drag-and-drop behavior for certificate rules
            if ( m_hCertStore )
                hStore = m_hCertStore;
            else
            {
                hStore = GetStoreHandle ();
                bStoreOpenedByThisMethod = true;
            }

			if ( hStore )
			{
				if ( CertGetStoreProperty(
						hStore,
						CERT_STORE_LOCALIZED_NAME_PROP_ID,
						NULL,
						&cbLocalizedName))
				{
					LPWSTR	pwszLocalizedName = new WCHAR[cbLocalizedName/sizeof (WCHAR)];
					if ( pwszLocalizedName )
					{
                        ::ZeroMemory (pwszLocalizedName, cbLocalizedName);
						if ( CertGetStoreProperty(
								hStore,
								CERT_STORE_LOCALIZED_NAME_PROP_ID,
								pwszLocalizedName,
								&cbLocalizedName
								))
						{
							m_localizedName = pwszLocalizedName;
							if ( m_localizedName == m_pcszStoreName )
								m_localizedName = GetObjectName ();
						}
						
						delete [] pwszLocalizedName;
					}
				}

                if ( bStoreOpenedByThisMethod )
				    Close ();
			}
		}

		// If it's still empty, get the object name
		if ( m_localizedName.IsEmpty () )
			m_localizedName = GetObjectName ();
	}
//	_TRACE (-1, L"Leaving CCertStore::GetLocalizedName - %s\n",
//			(LPCWSTR) m_pcszStoreName);
	return (LPCWSTR) m_localizedName;
}

CString CCertStore::GetStoreName() const
{
//	_TRACE (0, L"Entering and leaving CCertStore::GetStoreName - %s\n",
//			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	return m_pcszStoreName;
}


HRESULT CCertStore::AddCertificateContext(
        PCCERT_CONTEXT pContext, 
        LPCONSOLE pConsole, 
        bool bDeletePrivateKey, 
        PCCERT_CONTEXT* ppNewCertContext)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	_TRACE (1, L"Entering CCertStore::AddCertificateContext - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	ASSERT (pContext);
	if ( !pContext )
		return E_POINTER;

	HRESULT		hr = S_OK;
	HCERTSTORE	hCertStore = GetStoreHandle (FALSE, &hr);

	if ( hCertStore )
	{
		PCCERT_CONTEXT	pNewContext = 0;

		BOOL	bResult = ::CertAddCertificateContextToStore (hCertStore,
				::CertDuplicateCertificateContext (pContext), CERT_STORE_ADD_NEW,
				&pNewContext);
		if ( !bResult )
		{
			DWORD	dwErr = GetLastError ();
            _TRACE (0, L"CertAddCertificateContextToStore () failed: 0x%x\n", dwErr);

			if ( CRYPT_E_EXISTS == dwErr )
			{
                if ( pConsole ) // if !pConsole then no popup is desired
                {
                    CCertificate    cert (pContext, this);
				    CString	text;
				    CString	caption;
				    int		iRetVal = 0;


				    text.FormatMessage (IDS_DUPLICATE_CERT,
                            (PCWSTR) GetLocalizedName (),
                            (PCWSTR) cert.GetFriendlyName (),
                            (PCWSTR) cert.GetSubjectName ());
				    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
				    hr = pConsole->MessageBox (text, caption, 
						    MB_YESNO | MB_DEFBUTTON2, &iRetVal);
                    if ( IDYES == iRetVal )
                    {
                        bResult = ::CertAddCertificateContextToStore (hCertStore,
				                        ::CertDuplicateCertificateContext (pContext), 
                                        CERT_STORE_ADD_REPLACE_EXISTING,
				                        &pNewContext);
		                if ( !bResult )
		                {
			                hr = HRESULT_FROM_WIN32 (GetLastError ());
                        }
                    }
                    else
				        hr = HRESULT_FROM_WIN32 (CRYPT_E_EXISTS);
                }
			}
			else
			{
				hr = HRESULT_FROM_WIN32 (dwErr);
			}
		}
		else
		{
			m_fCertCountValid = false;
			SetDirty ();
			ASSERT (pNewContext);
			if ( bDeletePrivateKey )
			{
				::CertSetCertificateContextProperty (pNewContext,
						CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
			}
		}

        if ( pNewContext && ppNewCertContext)
            *ppNewCertContext = pNewContext;
		Close ();
	}
	else
		hr = E_FAIL;

	_TRACE (-1, L"Leaving CCertStore::AddCertificateContext - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return hr;
}

void CCertStore::IncrementCertCount ()
{
    m_nCertCount++;
}

int CCertStore::GetCertCount()
{
	_TRACE (1, L"Entering CCertStore::GetCertCount - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	if ( !m_fCertCountValid )
	{
		PCCERT_CONTEXT	pCertContext = 0;

		
		m_nCertCount = 0;
		while ( 1 )
		{
			pCertContext = EnumCertificates (pCertContext);
			if ( pCertContext )
				m_nCertCount++;
			else
				break;
		}
		Close ();
		m_fCertCountValid = true;
	}
	_TRACE (-1, L"Leaving CCertStore::GetCertCount - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return m_nCertCount;
}


BOOL CCertStore::operator ==(CCertStore &rStore)
{
	_TRACE (1, L"Entering CCertStore::operator == - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	BOOL	bResult = FALSE;

	if ( GetStoreHandle () == rStore.GetStoreHandle () )
		bResult = TRUE;

	Close ();
	rStore.Close ();
	_TRACE (-1, L"Leaving CCertStore::operator == - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return bResult;
}

CCertificate* CCertStore::GetSubjectCertificate(PCERT_INFO pCertId)
{
	_TRACE (1, L"Entering CCertStore::GetSubjectCertificate - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	CCertificate* pCert = 0;

	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
	{
		PCCERT_CONTEXT pSignerCert =
				::CertGetSubjectCertificateFromStore (
						hCertStore,
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						pCertId);
		if ( pSignerCert )
		{
			pCert = new CCertificate (pSignerCert, this);
		}
		Close ();
	}

	_TRACE (-1, L"Leaving CCertStore::GetSubjectCertificate - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return pCert;
}

PCCERT_CONTEXT CCertStore::EnumCertificates(PCCERT_CONTEXT pPrevCertContext)
{
//	_TRACE (1, L"Entering CCertStore::EnumCertificates - %s\n",
//			(LPCWSTR) m_pcszStoreName);
	PCCERT_CONTEXT pCertContext = 0;

	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
		pCertContext = ::CertEnumCertificatesInStore (hCertStore, pPrevCertContext);


	m_fCertCountValid = false;

//	_TRACE (-1, L"Leaving CCertStore::EnumCertificates - %s\n",
//			(LPCWSTR) m_pcszStoreName);
	return pCertContext;
}

PCCTL_CONTEXT CCertStore::EnumCTLs(PCCTL_CONTEXT pPrevCtlContext)
{
	_TRACE (1, L"Entering CCertStore::EnumCTLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	PCCTL_CONTEXT pCTLContext = 0;


	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);

	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
		pCTLContext = ::CertEnumCTLsInStore (hCertStore, pPrevCtlContext);

	_TRACE (-1, L"Leaving CCertStore::EnumCTLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return pCTLContext;
}

PCCRL_CONTEXT CCertStore::EnumCRLs(PCCRL_CONTEXT pPrevCrlContext)
{
	_TRACE (1, L"Entering CCertStore::EnumCRLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	PCCRL_CONTEXT pCRLContext = 0;

	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
		pCRLContext = ::CertEnumCRLsInStore (hCertStore, pPrevCrlContext);

	_TRACE (1, L"Entering CCertStore::EnumCRLs - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return pCRLContext;
}

PCCERT_CONTEXT CCertStore::FindCertificate(
		DWORD dwFindFlags,
		DWORD dwFindType,
		const void * pvFindPara,
		PCCERT_CONTEXT pPrevCertContext)
{
	_TRACE (1, L"Entering CCertStore::FindCertificate - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	PCCERT_CONTEXT	pCertContext = 0;
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
		pCertContext = ::CertFindCertificateInStore (hCertStore,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);

	_TRACE (-1, L"Leaving CCertStore::FindCertificate - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return pCertContext;
}


void CCertStore::FinalCommit()
{
	_TRACE (1, L"Entering CCertStore::FinalCommit - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	// Called only from destructor
	if ( m_hCertStore && m_bDirty )
		::CertControlStore (m_hCertStore, 0, CERT_STORE_CTRL_COMMIT, NULL);
	_TRACE (-1, L"Leaving CCertStore::FinalCommit - %s\n",
			(LPCWSTR) m_pcszStoreName);
}

bool CCertStore::AddCTLContext(PCCTL_CONTEXT pCtlContext)
{
	_TRACE (1, L"Entering CCertStore::AddCTLContext - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	BOOL		bResult = FALSE;
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
	{
		bResult = ::CertAddCTLContextToStore (hCertStore,
				pCtlContext,
				CERT_STORE_ADD_NEW,
				0);
		Close ();
	}
	if ( bResult )
		SetDirty ();
	
	_TRACE (-1, L"Leaving CCertStore::AddCTLContext - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return bResult ? true : false;
}

bool CCertStore::AddCRLContext(PCCRL_CONTEXT pCrlContext)
{
	_TRACE (1, L"Entering CCertStore::AddCRLContext - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	BOOL		bResult = FALSE;
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
	{
		bResult = ::CertAddCRLContextToStore (hCertStore,
				pCrlContext,
				CERT_STORE_ADD_NEW,
				0);
		Close ();
	}
	if ( bResult )
		SetDirty ();
	_TRACE (-1, L"Leaving CCertStore::AddCRLContext - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return bResult ? true : false;
}

PCCRL_CONTEXT CCertStore::GetCRL(PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD * pdwFlags)
{
	_TRACE (1, L"Entering CCertStore::GetCRL - %s\n",
			(LPCWSTR) m_pcszStoreName);
	PCCRL_CONTEXT pCRLContext = 0;

	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
	{
		pCRLContext = ::CertGetCRLFromStore (hCertStore, pIssuerContext,
				pPrevCrlContext, pdwFlags);
		Close ();
	}
	
	_TRACE (-1, L"Leaving CCertStore::GetCRL - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return pCRLContext;
}

HRESULT CCertStore::Resync()
{
	_TRACE (1, L"Entering CCertStore::Resync - %s\n",
			(LPCWSTR) m_pcszStoreName);
	HRESULT		hr = S_OK;

    // 256803 CertMgr: F5 refresh of Certificates Current User - Active 
    // Directory User Object, overwrites UserCerificate DS object resulting 
    // in data loss
// 	Close (true);
	if ( (CERT_STORE_PROV_COLLECTION != m_storeProvider) && 
			!m_bReadOnly && 
			CERTMGR_LOG_STORE_RSOP != m_objecttype )
	{
		FinalCommit ();
	}

	HCERTSTORE hCertStore = GetStoreHandle (FALSE);
	if ( hCertStore )
	{
		BOOL	bResult = ::CertControlStore (hCertStore, 0,
				CERT_STORE_CTRL_RESYNC, NULL);
		if ( !bResult )
		{
			DWORD	dwErr = GetLastError ();
			ASSERT (ERROR_NOT_SUPPORTED == dwErr);
			if ( ERROR_NOT_SUPPORTED != dwErr )
				hr = HRESULT_FROM_WIN32 (dwErr);
		}
	}
    m_fCertCountValid = false;

	_TRACE (-1, L"Leaving CCertStore::Resync - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return hr;
}



int CCertStore::GetCTLCount()
{
	_TRACE (1, L"Entering CCertStore::GetCTLCount - %s\n",
			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype ||
			CERTMGR_LOG_STORE_RSOP == m_objecttype);
	int				nCTLCount = 0;
    PCCTL_CONTEXT	pCTLContext = 0;


	while ( 1 )
	{
		pCTLContext = EnumCTLs (pCTLContext);
		if ( pCTLContext )
			nCTLCount++;
		else
			break;
	}

	_TRACE (-1, L"Leaving CCertStore::GetCTLCount - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return nCTLCount;
}

HRESULT CCertStore::AddStoreToCollection(HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
{
	_TRACE (1, L"Entering CCertStore::AddStoreToCollection - %s\n",
			(LPCWSTR) m_pcszStoreName);
	HRESULT		hr = S_OK;
	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore && hSiblingStore)
	{
		BOOL	bResult = ::CertAddStoreToCollection (hCertStore,
				hSiblingStore,
				dwUpdateFlags,
				dwPriority);
		if ( bResult )
			SetDirty ();
		else
		{
			DWORD	dwErr = GetLastError ();
			ASSERT (ERROR_NOT_SUPPORTED == dwErr);
			if ( ERROR_NOT_SUPPORTED != dwErr )
				hr = HRESULT_FROM_WIN32 (dwErr);
		}
	}
	else
		hr = E_FAIL;

	Close ();
	_TRACE (-1, L"Leaving CCertStore::AddStoreToCollection - %s\n",
			(LPCWSTR) m_pcszStoreName);
	return hr;
}

HRESULT CCertStore::AddStoreToCollection(CCertStore& siblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
{
	_TRACE (1, L"Entering CCertStore::AddStoreToCollection - %s\n", 
			(LPCWSTR) m_pcszStoreName);
	HRESULT		hr = S_OK;
	HCERTSTORE	hSiblingStore = siblingStore.GetStoreHandle ();
	if ( hSiblingStore)
	{
        hr = AddStoreToCollection (hSiblingStore, dwUpdateFlags, dwPriority);
	}
	else
		hr = E_FAIL;

	_TRACE (-1, L"Leaving CCertStore::AddStoreToCollection - %s\n", 
			(LPCWSTR) m_pcszStoreName);
	return hr;
}

void CCertStore::SetDirty()
{
	_TRACE (1, L"Entering CCertStore::SetDirty - %s\n",
			(LPCWSTR) m_pcszStoreName);
	m_bDirty = true;
	_TRACE (-1, L"Leaving CCertStore::SetDirty - %s\n",
			(LPCWSTR) m_pcszStoreName);
}

void CCertStore::Close(bool bForceClose)
{
//	_TRACE (1, L"Entering CCertStore::Close - %s\n",
//			(LPCWSTR) m_pcszStoreName);
	ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			CERTMGR_LOG_STORE == m_objecttype ||
			CERTMGR_PHYS_STORE == m_objecttype);
    if ( CERTMGR_LOG_STORE_GPE == m_objecttype || bForceClose )
    {
	    if ( m_hCertStore && m_nLockCnt <= 0 )
	    {
		    if ( (CERT_STORE_PROV_COLLECTION != m_storeProvider) && 
					!m_bReadOnly && 
					CERTMGR_LOG_STORE_RSOP != m_objecttype )
			{
			    FinalCommit ();
			}
		    ::CertCloseStore (m_hCertStore, 0);
            _TRACE (-1, L"Leaving%s store closed\n", (LPCWSTR) m_pcszStoreName);
		    m_hCertStore = 0;
		    m_bDirty = false;
	    }
    }
//	_TRACE (-1, L"Leaving CCertStore::Close - %s\n",
//			(LPCWSTR) m_pcszStoreName);
}

BOOL CCertStore::AddEncodedCTL(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
{
	BOOL	bResult = FALSE;

	HCERTSTORE	hCertStore = GetStoreHandle ();
	if ( hCertStore )
	{	
		bResult = ::CertAddEncodedCTLToStore (hCertStore,
				dwMsgAndCertEncodingType,
				pbCtlEncoded,
				cbCtlEncoded,
				dwAddDisposition, ppCtlContext);
		if ( bResult )
        {
            m_bDirty = true;
			Commit ();
        }
		Close ();
	}

	return bResult;
}

void CCertStore::InvalidateCertCount()
{
	m_fCertCountValid = false;
}

void CCertStore::Lock()
{
    m_nLockCnt++;
}

void CCertStore::Unlock()
{
    ASSERT (m_nLockCnt > 0);
    m_nLockCnt--;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CContainerCookie::CContainerCookie (CCertStore& rStore,
		CertificateManagerObjectType objectType,
		LPCWSTR lpcszMachineName,
		LPCWSTR objectName)
: CCertMgrCookie (objectType, lpcszMachineName, objectName),
	m_rCertStore (rStore)
{
	m_rCertStore.AddRef ();
	ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
		CERTMGR_CTL_CONTAINER == m_objecttype ||
		CERTMGR_CERT_CONTAINER == m_objecttype);
}


CContainerCookie::~CContainerCookie ()
{
	ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
		CERTMGR_CTL_CONTAINER == m_objecttype ||
		CERTMGR_CERT_CONTAINER == m_objecttype);
	m_rCertStore.Release ();
}


CCertStore&	CContainerCookie::GetCertStore () const
{
	ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
		CERTMGR_CTL_CONTAINER == m_objecttype ||
		CERTMGR_CERT_CONTAINER == m_objecttype);
	return m_rCertStore;
}


HRESULT CContainerCookie::Commit()
{
	ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
		CERTMGR_CTL_CONTAINER == m_objecttype ||
		CERTMGR_CERT_CONTAINER == m_objecttype);
	CCertMgrCookie::Commit ();

	return m_rCertStore.Commit ();
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CUsageCookie::CUsageCookie (
		CertificateManagerObjectType objecttype,
		LPCWSTR lpcszMachineName,
		LPCWSTR objectName)
: CCertMgrCookie (objecttype, lpcszMachineName, objectName),
	m_OIDListPos (0),
	m_nCertCount (0)
{
	ASSERT (CERTMGR_USAGE == m_objecttype);
}

CUsageCookie::~CUsageCookie ()
{
	ASSERT (CERTMGR_USAGE == m_objecttype);
	LPSTR	pszOID = 0;
	while ( !m_OIDList.IsEmpty () )
	{
		pszOID = m_OIDList.RemoveHead ();
		ASSERT (pszOID);
		if ( pszOID )
			delete [] pszOID;
	}
}

void CUsageCookie::AddOID (LPCSTR pszNewOID)
{
	ASSERT (CERTMGR_USAGE == m_objecttype);
	LPSTR	pszOID = new char[strlen (pszNewOID)+1];
	if ( pszOID )
	{
		::ZeroMemory (pszOID, strlen (pszNewOID) + 1);
		strcpy (pszOID, pszNewOID);
		m_OIDList.AddTail (pszOID);
	}
}

LPSTR CUsageCookie::GetFirstOID ()
{
	ASSERT (CERTMGR_USAGE == m_objecttype);
	LPSTR	pszOID = 0;

	m_OIDListPos = m_OIDList.GetHeadPosition ();
	if ( m_OIDListPos )
		pszOID = m_OIDList.GetNext (m_OIDListPos);

	return pszOID;
}

LPSTR CUsageCookie::GetNextOID ()
{
	ASSERT (CERTMGR_USAGE == m_objecttype);
	LPSTR	pszOID = 0;

	if ( m_OIDListPos )
		pszOID = m_OIDList.GetNext (m_OIDListPos);

	return pszOID;
}

int	CUsageCookie::GetOIDCount () const
{
	ASSERT (CERTMGR_USAGE == m_objecttype);
	return (int)m_OIDList.GetCount ();
}

void CUsageCookie::SetCertCount(int nCertCount)
{
	m_nCertCount = nCertCount;
}

int CUsageCookie::GetCertCount() const
{
	return m_nCertCount;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
SPECIAL_STORE_TYPE GetSpecialStoreType(LPWSTR pwszStoreName)
{
	SPECIAL_STORE_TYPE	storeType = NO_SPECIAL_TYPE;

	if ( !_wcsicmp (pwszStoreName, MY_SYSTEM_STORE_NAME) )
		storeType = MY_STORE;
	else if ( !_wcsicmp (pwszStoreName, CA_SYSTEM_STORE_NAME) )
		storeType = CA_STORE;
	else if ( !_wcsicmp (pwszStoreName, ROOT_SYSTEM_STORE_NAME) )
		storeType = ROOT_STORE;
	else if ( !_wcsicmp (pwszStoreName, TRUST_SYSTEM_STORE_NAME) )
		storeType = TRUST_STORE;
	else if ( !_wcsicmp (pwszStoreName, USERDS_SYSTEM_STORE_NAME) )
		storeType = USERDS_STORE;
	else if ( !_wcsicmp (pwszStoreName, ACRS_SYSTEM_STORE_NAME) )
		storeType = ACRS_STORE;
	else if ( !_wcsicmp (pwszStoreName, REQUEST_SYSTEM_STORE_NAME) )
		storeType = REQUEST_STORE;
	else
	{
		// The stores might be concatenated with machine or services names.
		// Check for the token preceded by a slash.
		CString	revStoreName (pwszStoreName);
		revStoreName.MakeReverse ();
		revStoreName.MakeUpper ();
		CString	revToken (MY_SYSTEM_STORE_NAME);
		revToken.MakeReverse ();
		revToken += L"\\";
		
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = MY_STORE;
			goto Found;
		}

		revToken = CA_SYSTEM_STORE_NAME;
		revToken.MakeReverse ();
		revToken += L"\\";
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = CA_STORE;
			goto Found;
		}

		revToken = ROOT_SYSTEM_STORE_NAME;
		revToken.MakeReverse ();
		revToken += L"\\";
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = ROOT_STORE;
			goto Found;
		}

		revToken = TRUST_SYSTEM_STORE_NAME;
		revToken.MakeReverse ();
		revToken += L"\\";
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = TRUST_STORE;
			goto Found;
		}

		revToken = USERDS_SYSTEM_STORE_NAME;
		revToken.MakeReverse ();
		revToken += L"\\";
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = USERDS_STORE;
			goto Found;
		}

		revToken = ACRS_SYSTEM_STORE_NAME;
		revToken.MakeReverse ();
		revToken += L"\\";
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = ACRS_STORE;
			goto Found;
		}

		revToken = REQUEST_SYSTEM_STORE_NAME;
		revToken.MakeReverse ();
		revToken += L"\\";
		if ( 0 == revStoreName.Find (revToken) )
		{
			storeType = REQUEST_STORE;
			goto Found;
		}
	}

Found:

	return storeType;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CEnrollmentNodeCookie::CEnrollmentNodeCookie (
		CertificateManagerObjectType	objecttype,
		LPCWSTR							objectName,
		IGPEInformation*				pGPEInformation)
	: CCertMgrCookie (objecttype, 0, objectName),
	m_pGPEInformation (pGPEInformation)
{
	if ( m_pGPEInformation )
		m_pGPEInformation->AddRef ();
}

CEnrollmentNodeCookie::~CEnrollmentNodeCookie ()
{
	if ( m_pGPEInformation )
		m_pGPEInformation->Release ();
}

IGPEInformation* CEnrollmentNodeCookie::GetGPEInformation ()
{
	return m_pGPEInformation;
}

void CCertMgrCookie::Refresh()
{

}


SPECIAL_STORE_TYPE StoreNameToType (const CString& szStoreName)
{
    SPECIAL_STORE_TYPE  type = NO_SPECIAL_TYPE;

    if ( szStoreName == ACRS_SYSTEM_STORE_NAME )
        type = ACRS_STORE;
    else if ( szStoreName == ROOT_SYSTEM_STORE_NAME )
        type = ROOT_STORE;
    else if ( szStoreName == TRUST_SYSTEM_STORE_NAME )
        type = TRUST_STORE;
    else if ( szStoreName == EFS_SYSTEM_STORE_NAME )
        type  = EFS_STORE;
    else if ( szStoreName == SAFER_TRUSTED_PUBLISHER_STORE_NAME )
        type = SAFER_TRUSTED_PUBLISHER_STORE;
    else if ( szStoreName == SAFER_DISALLOWED_STORE_NAME )
        type = SAFER_DISALLOWED_STORE;

    return type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\complete.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       complete.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_COMPLETE_H__F3A2938F_54B9_11D1_BB63_00A0C906345D__INCLUDED_)
#define AFX_COMPLETE_H__F3A2938F_54B9_11D1_BB63_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Complete.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizComplete dialog

class CAddEFSWizComplete : public CWizard97PropertyPage
{

// Construction
public:
	CAddEFSWizComplete();
	virtual ~CAddEFSWizComplete();

// Dialog Data
	//{{AFX_DATA(CAddEFSWizComplete)
	enum { IDD = IDD_COMPLETION };
	CStatic	m_bigBoldStatic;
	CListCtrl	m_UserAddList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAddEFSWizComplete)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddEFSWizComplete)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void SetUserList(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPLETE_H__F3A2938F_54B9_11D1_BB63_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\componentdatarsop.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ComponentDataRSOP.cpp
//
//  Contents:   Implementation of RSOP portions CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "Certifct.h"
#pragma warning(push, 3)
#include <wintrust.h>
#include <cryptui.h>
#include <sceattch.h>
#pragma warning(pop)
#include "StoreRSOP.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// CCertMgrComponentData
//


HRESULT CCertMgrComponentData::BuildWMIList (LPDATAOBJECT pDataObject, bool bIsComputer)
{
    _TRACE (1, L"Entering CCertMgrComponentData::BuildWMIList (%s)\n", bIsComputer ? L"computer" : L"user");
    HRESULT hr = S_OK;

#if DBG
    if ( bIsComputer )
    {
        _TRACE (0, L"m_rsopObjectArrayComputer contains %d objects\n", 
                m_rsopObjectArrayComputer.GetUpperBound ());
    }
    else
    {
        _TRACE (0, L"m_rsopObjectArrayUser contains %d objects\n", 
                m_rsopObjectArrayUser.GetUpperBound ());
    }
#endif
    if ( bIsComputer )
        m_rsopObjectArrayComputer.RemoveAll ();
    else 
        m_rsopObjectArrayUser.RemoveAll ();


    if ( ((bIsComputer && !m_pRSOPInformationComputer) || 
                (!bIsComputer && !m_pRSOPInformationUser) ) 
            && pDataObject )
    {
	    IUnknown* pIUnknown = 0;

	    hr = ExtractData (pDataObject,
		    CCertMgrDataObject::m_CFSCE_RSOPUnknown,
		    &pIUnknown, sizeof (IUnknown*));
	    ASSERT (SUCCEEDED (hr));
	    if ( SUCCEEDED (hr) )
	    {
            if ( bIsComputer )
            {
		        hr = pIUnknown->QueryInterface (
				        IID_PPV_ARG (IRSOPInformation, &m_pRSOPInformationComputer));
            }
            else
            {
		        hr = pIUnknown->QueryInterface (
				        IID_PPV_ARG (IRSOPInformation, &m_pRSOPInformationUser));
            }
		    ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                if ( bIsComputer )
                {
                    hr = m_pRSOPInformationComputer->GetFlags (&m_dwRSOPFlagsComputer);
                }
                else
                {
                     hr = m_pRSOPInformationUser->GetFlags (&m_dwRSOPFlagsUser);
                }
                ASSERT (SUCCEEDED (hr));

                int cchMaxLength = 512;
                LPOLESTR    pszNameSpace = (LPOLESTR) LocalAlloc (LPTR, cchMaxLength * sizeof (WCHAR));
                if ( pszNameSpace )
                {
                    DWORD   dwSection = 0;

                    switch (m_dwSCEMode)
                    {
                    case SCE_MODE_LOCAL_USER:
                    case SCE_MODE_DOMAIN_USER:
                    case SCE_MODE_OU_USER:
                    case SCE_MODE_REMOTE_USER:
                    case SCE_MODE_RSOP_USER:
                        dwSection = GPO_SECTION_USER;
                        break;

                    case SCE_MODE_LOCAL_COMPUTER:
                    case SCE_MODE_DOMAIN_COMPUTER:
                    case SCE_MODE_OU_COMPUTER:
                    case SCE_MODE_RSOP_COMPUTER:
                    case SCE_MODE_REMOTE_COMPUTER:
                        dwSection = GPO_SECTION_MACHINE;
                        break;

                    default:
                        ASSERT (0);
                        return E_UNEXPECTED;
                    }
                    if ( bIsComputer )
                    {
                        hr = m_pRSOPInformationComputer->GetNamespace (
                                dwSection, 
                                pszNameSpace,
                                cchMaxLength);
                    }
                    else
                    {
                        hr = m_pRSOPInformationUser->GetNamespace (
                                dwSection, 
                                pszNameSpace,
                                cchMaxLength);
                    }
                    if ( SUCCEEDED (hr) )
                    {
                        IWbemLocator *pIWbemLocator = 0;
                        hr = CoCreateInstance (CLSID_WbemLocator, 
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_PPV_ARG(IWbemLocator, &pIWbemLocator));
                        if ( SUCCEEDED (hr) )
                        {
                            BSTR    bstrNameSpace = SysAllocString (pszNameSpace);
                            if ( bstrNameSpace )
                            {
                                if ( bIsComputer )
                                {
                                    hr = pIWbemLocator->ConnectServer (bstrNameSpace,
                                            NULL, NULL, 0, 0, NULL, NULL,
                                            &m_pIWbemServicesComputer);
                                }
                                else
                                {
                                    hr = pIWbemLocator->ConnectServer (bstrNameSpace,
                                            NULL, NULL, 0, 0, NULL, NULL,
                                            &m_pIWbemServicesUser);
                                }
					            if ( FAILED (hr) )
					            {
						            _TRACE (0, L"IWbemLocator::ConnectServer (%s) failed: 0x%x(%s)\n", 
								            bstrNameSpace, hr, (PCWSTR) GetSystemMessage (hr));
					            }
                                SysFreeString (bstrNameSpace);
                            }
				            else
					            hr = E_OUTOFMEMORY;
				            pIWbemLocator->Release ();
                        }
                    }
                    LocalFree (pszNameSpace);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
	    }
    }

    if ( SUCCEEDED (hr) && ((bIsComputer && m_pIWbemServicesComputer) || 
            (!bIsComputer && m_pIWbemServicesUser)) )
    {
        IEnumWbemClassObject * pEnum = 0;
        IWbemClassObject *pObject = 0;
        ULONG   ulRet = 0;


        //
        // Execute the query
        //
        if ( bIsComputer )
        {
            hr = m_pIWbemServicesComputer->ExecQuery (m_pbstrLanguage, m_pbstrQuery, 
                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
                    NULL, &pEnum);
        }
        else
        {
            hr = m_pIWbemServicesUser->ExecQuery (m_pbstrLanguage, m_pbstrQuery, 
                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
                    NULL, &pEnum);
        }
        if ( SUCCEEDED (hr) )
        {
            //
            // Loop through the results retrieving the registry key and value names
            //
            while ( (hr = pEnum->Next(WBEM_INFINITE, 1, &pObject, &ulRet)) == WBEM_S_NO_ERROR )
            {
                hr = GetValuesAndInsertInRSOPObjectList (pObject, 
                        bIsComputer ? m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                        bIsComputer);

                pObject->Release ();

                if ( FAILED (hr) )
                    break;
            }

            pEnum->Release();

#if DBG
            int     nIndex = 0;
            INT_PTR nUpperBound = 0;
            
            if ( bIsComputer )
                nUpperBound = m_rsopObjectArrayComputer.GetUpperBound ();
            else
                nUpperBound = m_rsopObjectArrayUser.GetUpperBound ();

            while ( nUpperBound >= nIndex )
            {
                CRSOPObject* pCurrObject = 0;
                if ( bIsComputer )
                    pCurrObject = m_rsopObjectArrayComputer.GetAt (nIndex);
                else
                    pCurrObject = m_rsopObjectArrayUser.GetAt (nIndex);
                if ( !pCurrObject )
                    break;
                _TRACE (0, L"\t%d\t%s\t%s\n", pCurrObject->GetPrecedence (), 
                        (PCWSTR) pCurrObject->GetRegistryKey (),
                        (PCWSTR) pCurrObject->GetValueName ());
                nIndex++;
            }
#endif
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::BuildWMIList (): 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::GetValuesAndInsertInRSOPObjectList (
           IWbemClassObject* pObject, 
           CRSOPObjectArray& rRsopObjectArray,
           bool bIsComputer)
{
    HRESULT         hr = S_OK;

    if ( !pObject )
        return E_POINTER;

    //
    // Check if the allocations succeeded
    //

    if ( m_pbstrLanguage && m_pbstrQuery && m_pbstrRegistryKey && 
            m_pbstrValueName && m_pbstrValue && 
            m_pbstrPrecedence && m_pbstrGPOid )
    {
        COleVariant varRegistryKey;
        COleVariant varValueName;
        COleVariant varValue;
        COleVariant varPrecedence;
        COleVariant varGPOid;
        hr = pObject->Get (m_pbstrRegistryKey, 0, &varRegistryKey, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pObject->Get (m_pbstrValueName, 0, &varValueName, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                hr = pObject->Get (m_pbstrValue, 0, &varValue, NULL, NULL);
                if (SUCCEEDED(hr))
                {
//#ifndef DBG
                    // only include objects that have a value name
                    if ( varValueName.bstrVal[0] )
//#endif
                    {
//#ifndef DBG
                        // Only include those objects that are in the system store registry 
                        // path or in the cryptography\autoenrollment path
                        if ( FoundInRSOPFilter (varRegistryKey.bstrVal) )
//#endif
                        {
                            hr = pObject->Get (m_pbstrPrecedence, 0, &varPrecedence, NULL, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = pObject->Get (m_pbstrGPOid, 0, &varGPOid, NULL, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    PWSTR lpGPOName = 0;

                                    hr = GetGPOFriendlyName ( 
                                                varGPOid.bstrVal,
                                                &lpGPOName,
                                                bIsComputer);

                                    if (SUCCEEDED(hr))
                                    {

                                        CRSOPObject* pRSOPObject = new CRSOPObject (
                                                varRegistryKey.bstrVal, 
                                                varValueName.bstrVal,
                                                lpGPOName,
                                                varPrecedence.uintVal,
                                                varValue);
                                        if ( pRSOPObject )
                                        {
                                            CRSOPObject*    pCurrObject = 0;
                                            int             nIndex = 0;
                                            bool            bInserted = false;
                                            INT_PTR         nUpperBound = rRsopObjectArray.GetUpperBound ();

                                            while ( nUpperBound >= nIndex )
                                            {
                                                pCurrObject = rRsopObjectArray.GetAt (nIndex);
                                                if ( !pCurrObject )
                                                    break;

                                                // Sort first by registry key name, 
                                                // then by value name, then by 
                                                // precedence
                                                int nCmpVal = wcscmp (pCurrObject->GetRegistryKey (),
                                                        pRSOPObject->GetRegistryKey ());
                                                if ( nCmpVal > 0 )
                                                {
                                                    rRsopObjectArray.InsertAt (nIndex, pRSOPObject);
                                                    bInserted = true;
                                                    break;
                                                }
                                                else if ( nCmpVal == 0 )
                                                {
                                                    // Sort by value name
                                                    nCmpVal = wcscmp (pCurrObject->GetValueName (),
                                                            pRSOPObject->GetValueName ());
                                                    if ( nCmpVal > 0 )
                                                    {
                                                        rRsopObjectArray.InsertAt (nIndex, pRSOPObject);
                                                        bInserted = true;
                                                        break;
                                                    }
                                                    else if ( nCmpVal == 0 )
                                                    {
                                                        // Sort by precedence
                                                        if ( pCurrObject->GetPrecedence () >
                                                                pRSOPObject->GetPrecedence () )
                                                        {
                                                            rRsopObjectArray.InsertAt (nIndex, pRSOPObject);
                                                            bInserted = true;
                                                            break;
                                                        }
                                                        else if ( pCurrObject->GetPrecedence () ==
                                                                pRSOPObject->GetPrecedence () )
                                                        {
                                                            // The registry key, value name and precedence
                                                            // are the same - this is a duplicate. Pretend
                                                            // we've added it and move on.
                                                            bInserted = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                nIndex++;
                                            }
                                            if ( !bInserted )
                                                rRsopObjectArray.Add (pRSOPObject);
                                        }

                                        LocalFree (lpGPOName);
                                    }
                                    varGPOid.Clear ();
                                }

                                varPrecedence.Clear ();
                            }
                        }
                    }
                    varValue.Clear ();
                }

                varValueName.Clear ();
            }

            varRegistryKey.Clear ();
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT CCertMgrComponentData::GetGPOFriendlyName (PWSTR lpGPOID, PWSTR *pGPOName, bool bIsComputer)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    lpQuery = (LPTSTR) LocalAlloc (LPTR, ((lstrlen(lpGPOID) + 50) * sizeof(TCHAR)));

    if (!lpQuery)
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for unicode query");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    wsprintf (lpQuery, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);


    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for query");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
       _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for name");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    if ( bIsComputer )
    {
        hr = m_pIWbemServicesComputer->ExecQuery (m_pbstrLanguage, pQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL, &pEnum);
    }
    else
    {
        hr = m_pIWbemServicesUser->ExecQuery (m_pbstrLanguage, pQuery,
                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                NULL, &pEnum);
    }


    if (FAILED(hr))
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to query for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    if (FAILED(hr))
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x\n",
                  pQuery, hr);
        goto Exit;
    }


    //
    // Save the name
    //

    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(varGPOName.bstrVal) + 1) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for GPO Name");
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    lstrcpy (*pGPOName, varGPOName.bstrVal);

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool CCertMgrPKPolExtension::FoundInRSOPFilter (BSTR bstrKey) const
{
    static  size_t  nRegPathLen = wcslen (CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH);
    static  size_t  nTrustedPublisherKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH);
    static  size_t  nDisallowedKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH);
	static  size_t  nSaferKeyLen = wcslen (SAFER_HKLM_REGBASE);
    static  size_t  nEFSKeyLen = wcslen (EFS_SETTINGS_REGPATH);


    //Include group policy system stores but not trusted publisher or disallowed
    if ( !_wcsnicmp (CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH, bstrKey, nRegPathLen) &&
				(_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH, 
						bstrKey, nTrustedPublisherKeyLen) &&
				_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH, 
						bstrKey, nDisallowedKeyLen)) )
    {
        return true;
    }
    else if ( !_wcsnicmp (SAFER_HKLM_REGBASE, bstrKey, nSaferKeyLen) ||
             !_wcsnicmp (EFS_SETTINGS_REGPATH, bstrKey, nEFSKeyLen) ||
             !_wcsicmp (AUTO_ENROLLMENT_KEY, bstrKey) )
    {
        return true;
    }
    else
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\cookie.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cookie.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CCertMgrComponent::Initialize)


#include "nodetype.h"
#pragma warning(push,3)
#include <efsstruc.h>
#pragma warning(pop)

// Name of Encrypting File System store
#define ACRS_SYSTEM_STORE_NAME		L"ACRS"
#define EFS_SYSTEM_STORE_NAME		L"EFS"
#define TRUST_SYSTEM_STORE_NAME		L"Trust"
#define ROOT_SYSTEM_STORE_NAME		L"Root"
#define MY_SYSTEM_STORE_NAME		L"MY"
#define CA_SYSTEM_STORE_NAME		L"CA"
#define USERDS_SYSTEM_STORE_NAME	L"UserDS"
#define REQUEST_SYSTEM_STORE_NAME	L"REQUEST"
#define SAFER_TRUSTED_PUBLISHER_STORE_NAME  L"TrustedPublisher"
#define SAFER_DISALLOWED_STORE_NAME         L"Disallowed"



/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.


class CCertificate;	// forward declaration

class CCertMgrCookie : public CCookie,
                        public CStoresMachineName,
                        public CBaseCookieBlock
{
public:
	CCertMgrCookie (CertificateManagerObjectType objecttype,
			LPCWSTR lpcszMachineName = 0,
			LPCWSTR objectName = 0);

	virtual ~CCertMgrCookie ();

	// returns <0, 0 or >0
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult );
	
// CBaseCookieBlock
	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();

public:
	LPRESULTDATA m_resultDataID;
	virtual void Refresh ();
	virtual HRESULT Commit ();
	CString GetServiceName () const;
	void SetServiceName (CString &szManagedService);
	LPCWSTR GetObjectName ();
	const CertificateManagerObjectType m_objecttype;
    UINT    IncrementOpenPageCount ();
    UINT    DecrementOpenPageCount ();
    bool    HasOpenPropertyPages () const;

private:
	CString m_objectName;
    UINT    m_nOpenPageCount;
};

typedef enum {
	NO_SPECIAL_TYPE = 0,
	MY_STORE,
	CA_STORE,
	ROOT_STORE,
	TRUST_STORE,
	USERDS_STORE,
	ACRS_STORE,
	EFS_STORE,
	REQUEST_STORE,
    SAFER_TRUSTED_PUBLISHER_STORE,
    SAFER_DISALLOWED_STORE
} SPECIAL_STORE_TYPE;
SPECIAL_STORE_TYPE GetSpecialStoreType(LPWSTR pwszStoreName);

SPECIAL_STORE_TYPE StoreNameToType (const CString& szStoreName);

class CCTL; // forward declaration
class CCertStore : public CCertMgrCookie
{
	friend CCTL;
public:
    virtual bool IsNullEFSPolicy()
    {
        return false;
    }
    void IncrementCertCount ();
	void Unlock ();
	void Lock ();
	void InvalidateCertCount();
	BOOL AddEncodedCTL (DWORD dwMsgAndCertEncodingType, 
			const BYTE* pbCtlEncoded, 
			DWORD cbCtlEncoded, 
			DWORD dwAddDisposition, 
			PCCTL_CONTEXT* ppCtlContext);
	virtual void Close (bool bForceClose = false);
	void SetDirty();
	HRESULT AddStoreToCollection(CCertStore& siblingStore, 
			DWORD dwUpdateFlags = 0, 
			DWORD dwPriority = 0);
	HRESULT AddStoreToCollection(HCERTSTORE hSiblingStore, 
			DWORD dwUpdateFlags = 0, 
			DWORD dwPriority = 0);
	int GetCTLCount ();
	inline DWORD GetLocation () { return m_dwLocation;}
	HRESULT Resync ();
	inline bool IsOpen()
	{
		// If m_hCertStore is 0, then this store hasn't been used for anything
		if ( !m_hCertStore )
			return false;
		else
			return true;
	}

	PCCRL_CONTEXT GetCRL (
						PCCERT_CONTEXT pIssuerContext, 
						PCCRL_CONTEXT pPrevCrlContext, 
						DWORD* pdwFlags);
	bool AddCTLContext (PCCTL_CONTEXT pCtlContext);
	bool AddCRLContext (PCCRL_CONTEXT pCrlContext);
	PCCERT_CONTEXT FindCertificate (
						DWORD dwFindFlags, 
						DWORD dwFindType, 
						const void *pvFindPara, 
						PCCERT_CONTEXT pPrevCertContext);
	PCCRL_CONTEXT EnumCRLs (PCCRL_CONTEXT pPrevCrlContext);
	PCCTL_CONTEXT EnumCTLs (PCCTL_CONTEXT pPrevCtlContext);
	virtual PCCERT_CONTEXT EnumCertificates (PCCERT_CONTEXT pPrevCertContext);
	CCertificate* GetSubjectCertificate (PCERT_INFO pCertId);
	BOOL operator==(CCertStore&);
	int GetCertCount ();
	virtual HRESULT AddCertificateContext (
				PCCERT_CONTEXT pContext, 
				LPCONSOLE pConsole, 
				bool bDeletePrivateKey,
                PCCERT_CONTEXT* ppNewCertContext = 0);
	inline virtual void AddRef()
	{
	    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
                CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			    CERTMGR_LOG_STORE == m_objecttype ||
			    CERTMGR_PHYS_STORE == m_objecttype);
		CCertMgrCookie::AddRef ();
	}

	inline virtual void Release ()
	{
	    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
                CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			    CERTMGR_LOG_STORE == m_objecttype ||
			    CERTMGR_PHYS_STORE == m_objecttype);
		CCertMgrCookie::Release ();
	}

	CString GetStoreName () const;
	LPCWSTR GetLocalizedName();
	bool ContainsCTLs ();
	bool ContainsCRLs ();
	bool ContainsCertificates ();
	virtual HRESULT Commit ();
	virtual bool IsReadOnly ();
	inline const SPECIAL_STORE_TYPE GetStoreType () const
	{
	    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
                CERTMGR_LOG_STORE_RSOP == m_objecttype ||
			    CERTMGR_LOG_STORE == m_objecttype ||
			    CERTMGR_PHYS_STORE == m_objecttype);
		return m_storeType;
	}

	CCertStore (CertificateManagerObjectType objecttype,
			LPCSTR pszStoreProv, 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			const SPECIAL_STORE_TYPE storeType,
			const DWORD dwLocation,
			IConsole* pConsole);
	virtual ~CCertStore ();
	virtual HCERTSTORE	GetStoreHandle (BOOL bSilent = FALSE, HRESULT* phr = 0);
    virtual bool CanContain (CertificateManagerObjectType /*nodeType*/)
    {
        return false;
    }

    virtual bool IsMachineStore()
    {
        return false;
    }

protected:
	virtual void FinalCommit();
	HRESULT RetrieveBLOBFromFile (LPCWSTR pwszFileName, DWORD *pcb, BYTE **ppb);

    bool	    m_fCertCountValid;
	bool	    m_bUnableToOpenMsgDisplayed;
	LPCSTR		m_storeProvider;
	DWORD		m_dwFlags;
	CString		m_pcszStoreName;
	bool		m_bReadOnly;
	HCERTSTORE  m_hCertStore;
	IConsole*	m_pConsole;
	bool		m_bDirty;

private:
	int         m_nCertCount;
	bool        m_fReadOnlyFlagChecked;
	const DWORD m_dwLocation;
	CString     m_localizedName;
	const SPECIAL_STORE_TYPE	m_storeType;
    int         m_nLockCnt; // test
};


class CContainerCookie : public CCertMgrCookie
{
public:
	virtual HRESULT Commit ();
	inline const SPECIAL_STORE_TYPE GetStoreType () const
    {
	    ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
		    CERTMGR_CTL_CONTAINER == m_objecttype ||
		    CERTMGR_CERT_CONTAINER == m_objecttype);
	    return m_rCertStore.GetStoreType ();
    }

	CContainerCookie (CCertStore& rStore, 
		CertificateManagerObjectType objecttype, 
		LPCWSTR lpcszMachineName, 
		LPCWSTR objectName);
	virtual ~CContainerCookie ();
	CCertStore&	GetCertStore () const;
private:
	CCertStore&  m_rCertStore;
};


class CUsageCookie : public CCertMgrCookie
{
public:
	int GetCertCount () const;
	void SetCertCount (int nCertCount);
	CUsageCookie ( 
		CertificateManagerObjectType objecttype, 
		LPCWSTR lpcszMachineName, 
		LPCWSTR objectName);
	void	AddOID (LPCSTR pszOID);
	virtual ~CUsageCookie ();
	LPSTR	GetFirstOID ();
	LPSTR	GetNextOID ();
	int		GetOIDCount () const;

private:
	int m_nCertCount;
	CTypedPtrList<CPtrList, LPSTR>	m_OIDList;
	POSITION						m_OIDListPos;
};

#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\crl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       crl.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_CRL_H__6C3D4D38_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
#define AFX_CRL_H__6C3D4D38_3527_11D1_B4AD_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cookie.h"

class CCRL : public CCertMgrCookie  
{
public:
	BOOL DeleteFromStore ();
	virtual void Refresh();
	CCRL(const PCCRL_CONTEXT pCRLContext, CCertStore& CertStore);
	virtual ~CCRL();
	int CompareNextUpdate (const CCRL& crl) const;
	int CompareEffectiveDate (const CCRL& crl) const;
	PCCRL_CONTEXT GetCRLContext() const;
	CCertStore& GetCertStore() const;
	CString GetIssuerName ();
	CString GetNextUpdate ();
	CString GetEffectiveDate ();

private:
	CString m_szEffectiveDate;
	CString m_szNextUpdate;
	CString m_szIssuerName;
	CCertStore&			m_rCertStore;
	const PCCRL_CONTEXT	m_pCRLContext;
	PCRL_INFO			m_pCRLInfo;
};

#endif // !defined(AFX_CRL_H__6C3D4D38_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\crl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       CRL.cpp
//
//  Contents:   implementation of the CCRL class.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "CRL.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCRL::CCRL(const PCCRL_CONTEXT pCRLContext, CCertStore& rCertStore) :
	CCertMgrCookie (CERTMGR_CRL),
	m_pCRLContext (::CertDuplicateCRLContext (pCRLContext)),
	m_rCertStore (rCertStore),
	m_pCRLInfo (0)
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	m_rCertStore.AddRef ();
	ASSERT (m_pCRLContext);
	if ( m_pCRLContext )
		m_pCRLInfo = m_pCRLContext->pCrlInfo;
}

CCRL::~CCRL()
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	m_rCertStore.Release ();
	if ( m_pCRLContext )
		::CertFreeCRLContext (m_pCRLContext);
}

PCCRL_CONTEXT CCRL::GetCRLContext() const
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	return m_pCRLContext;
}

CCertStore& CCRL::GetCertStore() const	
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	return m_rCertStore;
}

CString CCRL::GetIssuerName ()
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	ASSERT (m_pCRLInfo);
	if ( m_pCRLInfo )
	{
		// Decode issuer name if not already present
		if ( m_szIssuerName.IsEmpty () )
		{
			HRESULT hResult = ConvertNameBlobToString (m_pCRLInfo->Issuer, 
					m_szIssuerName);
			if ( !SUCCEEDED (hResult) )
				return _T("");
		}
	}
	else
		return _T("");


	return m_szIssuerName;
}

CString CCRL::GetEffectiveDate()
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	ASSERT (m_pCRLInfo);
	if ( m_pCRLInfo )
	{
		// Format date/time string if not already present
		if ( m_szEffectiveDate.IsEmpty () )
		{
			HRESULT	hResult = FormatDate (m_pCRLInfo->ThisUpdate, m_szEffectiveDate);
			if ( !SUCCEEDED (hResult) )
				m_szEffectiveDate = _T("");
		}
	}
	else
		m_szEffectiveDate = _T("");

	return m_szEffectiveDate;
}

CString CCRL::GetNextUpdate()
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	ASSERT (m_pCRLInfo);
	if ( m_pCRLInfo )
	{
		// Format date/time string if not already present
		if ( m_szNextUpdate.IsEmpty () )
		{
			HRESULT	hResult = FormatDate (m_pCRLInfo->NextUpdate, m_szNextUpdate);
			if ( !SUCCEEDED (hResult) )
				m_szNextUpdate = _T("");
		}
	}
	else
		m_szNextUpdate = _T("");

	return m_szNextUpdate;
}


int CCRL::CompareEffectiveDate (const CCRL& crl) const
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	int	compVal = 0;

	ASSERT (m_pCRLInfo && crl.m_pCRLInfo);
	if ( m_pCRLInfo && crl.m_pCRLInfo )
	{
		compVal = ::CompareFileTime (&m_pCRLInfo->ThisUpdate, 
				&crl.m_pCRLInfo->ThisUpdate);
	}

	return compVal;
}

int CCRL::CompareNextUpdate (const CCRL& crl) const
{
	ASSERT (CERTMGR_CRL == m_objecttype);
	int	compVal = 0;

	ASSERT (m_pCRLInfo && crl.m_pCRLInfo);
	if ( m_pCRLInfo && crl.m_pCRLInfo )
	{
		compVal = ::CompareFileTime (&m_pCRLInfo->NextUpdate, 
				&crl.m_pCRLInfo->NextUpdate);
	}

	return compVal;
}

void CCRL::Refresh()
{
	m_szEffectiveDate = L"";
	m_szIssuerName = L"";
	m_szNextUpdate = L"";
}

BOOL CCRL::DeleteFromStore()
{
	BOOL	bResult = FALSE;
	ASSERT (m_pCRLContext);
	if ( m_pCRLContext )
	{
		bResult = ::CertDeleteCRLFromStore (
				::CertDuplicateCRLContext (m_pCRLContext));
		if ( bResult )
			m_rCertStore.SetDirty ();
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\ctl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       CTL.cpp
//
//  Contents:   implementation of the CCTL class.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "CTL.h"
#include "certifct.h"


USE_HANDLE_MACROS("CERTMGR(ctl.cpp)")  

////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCTL::CCTL (const PCCTL_CONTEXT pCTLContext, 
			CCertStore& rCertStore, 
			CertificateManagerObjectType objectType,
			CTypedPtrList<CPtrList, CCertStore*>*	pStoreList) :
	CCertMgrCookie (objectType),
		m_pCTLContext (::CertDuplicateCTLContext (pCTLContext)),
	m_rCertStore (rCertStore),
	m_pStoreCollection (0),
    m_hExtraStore (0)
{
	_TRACE (1, L"Entering CCTL::CCTL\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	m_rCertStore.AddRef ();
	ASSERT (m_pCTLContext);
	if ( m_pCTLContext )
		m_pCTLInfo = m_pCTLContext->pCtlInfo;

	m_pStoreCollection = new CCertStore (CERTMGR_LOG_STORE, CERT_STORE_PROV_COLLECTION, 0,
			L"", L"", L"", L"", NO_SPECIAL_TYPE, 0, rCertStore.m_pConsole);
	if ( m_pStoreCollection )
	{
		m_pStoreCollection->AddStoreToCollection (m_rCertStore);

        m_hExtraStore = CertOpenStore(
                                CERT_STORE_PROV_MSG, 
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                                NULL, 
                                NULL,
                                (const void *) pCTLContext->hCryptMsg);
        if ( m_hExtraStore )
            m_pStoreCollection->AddStoreToCollection (m_hExtraStore);
		else
		{
			_TRACE (0, L"CertOpenStore (CERT_STORE_PROV_MSG) failed: 0x%x\n", 
					GetLastError ());		
		}
		if ( pStoreList )
		{
			for (POSITION pos = pStoreList->GetHeadPosition (); pos; )
			{
				CCertStore* pStore = pStoreList->GetNext (pos);
				ASSERT (pStore);
				if ( pStore )
				{
					m_pStoreCollection->AddStoreToCollection (*pStore);
				}
				pStore->AddRef ();
				m_storeList.AddTail (pStore);
			}
		}
	}
	_TRACE (-1, L"Leaving CCTL::CCTL\n");
}

CCTL::~CCTL()
{
	_TRACE (1, L"Entering CCTL::~CCTL\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);


	if ( m_pStoreCollection )
	{
		delete m_pStoreCollection;
		m_pStoreCollection = 0;
	}

	CCertStore* pStore = 0;

	// Clean up store list
	while (!m_storeList.IsEmpty () )
	{
		pStore = m_storeList.RemoveHead ();
		ASSERT (pStore);
		if ( pStore )
			pStore->Release ();
	}

    if ( m_hExtraStore )
    {
        CertCloseStore (m_hExtraStore, 0);
        m_hExtraStore = 0;
    }

	m_rCertStore.Release ();
	if ( m_pCTLContext )
		::CertFreeCTLContext (m_pCTLContext);
	_TRACE (-1, L"Leaving CCTL::~CCTL\n");
}


PCCTL_CONTEXT CCTL::GetCTLContext() const
{
	_TRACE (1, L"Entering CCTL::GetCTLContext\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	_TRACE (-1, L"Leaving CCTL::GetCTLContext\n");
	return m_pCTLContext;
}

CCertStore& CCTL::GetCertStore() const	
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	return m_rCertStore;
}

CString CCTL::GetIssuerName ()
{
	_TRACE (1, L"Entering CCTL::GetIssuerName\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	ASSERT (m_pCTLInfo);
	if ( m_pCTLInfo )
	{
		// Decode issuer name if not already present
		if ( m_szIssuerName.IsEmpty () )
		{
			HRESULT	hResult = GetSignerInfo (m_szIssuerName);
			if ( !SUCCEEDED (hResult) )
				VERIFY (m_szIssuerName.LoadString (IDS_NOT_AVAILABLE));
		}
	}

	_TRACE (-1, L"Leaving CCTL::GetIssuerName\n");
	return m_szIssuerName;
}

CString CCTL::GetEffectiveDate()
{
	_TRACE (1, L"Entering CCTL::GetEffectiveDate\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	ASSERT (m_pCTLInfo);
	if ( m_pCTLInfo )
	{
		// Format date/time string if not already present
		if ( m_szEffectiveDate.IsEmpty () )
		{
			HRESULT	hResult = FormatDate (m_pCTLInfo->ThisUpdate, m_szEffectiveDate);
			if ( !SUCCEEDED (hResult) )
				m_szEffectiveDate = _T("");
		}
	}
	else
		m_szEffectiveDate = _T("");

	_TRACE (-1, L"Leaving CCTL::GetEffectiveDate\n");
	return m_szEffectiveDate;
}

CString CCTL::GetNextUpdate()
{
	_TRACE (1, L"Entering CCTL::GetNextUpdate\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	ASSERT (m_pCTLInfo);
	if ( m_pCTLInfo )
	{
		// Format date/time string if not already present
		if ( m_szNextUpdate.IsEmpty () )
		{
			HRESULT	hResult = FormatDate (m_pCTLInfo->NextUpdate, m_szNextUpdate);
			if ( !SUCCEEDED (hResult) )
				m_szNextUpdate = _T("");
		}
	}
	else
		m_szNextUpdate = _T("");

	_TRACE (-1, L"Leaving CCTL::GetNextUpdate\n");
	return m_szNextUpdate;
}

CString CCTL::GetPurpose()
{
	_TRACE (1, L"Entering CCTL::GetPurpose\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	ASSERT (m_pCTLInfo);
	if ( m_pCTLInfo )
	{
		// Format date/time string if not already present
		if ( m_szPurpose.IsEmpty () )
			FormatEnhancedKeyUsagePropertyString (m_szPurpose);
	}
	_TRACE (-1, L"Leaving CCTL::GetPurpose\n");
	return m_szPurpose;
}


void CCTL::FormatEnhancedKeyUsagePropertyString (CString& string)
{
	_TRACE (1, L"Entering CCTL::FormatEnhancedKeyUsagePropertyString\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	ASSERT (m_pCTLInfo);
	if ( m_pCTLInfo )
	{
		CString		usageName;
		CTL_USAGE&	usage = m_pCTLInfo->SubjectUsage;


		for (DWORD dwIndex = 0; dwIndex < usage.cUsageIdentifier; dwIndex++)
		{
			if ( MyGetOIDInfo (usageName, usage.rgpszUsageIdentifier[dwIndex]) )
			{
				// add delimeter if not first iteration
				if ( dwIndex )
					string += _T(", ");
				string += usageName;
			}
		}
	}
	_TRACE (-1, L"Leaving CCTL::FormatEnhancedKeyUsagePropertyString\n");
}


HRESULT CCTL::GetSignerInfo (CString & signerName)
{
	_TRACE (1, L"Entering CCTL::GetSignerInfo\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	HRESULT		hResult = S_OK;
    
    //
    // Use CryptMsg to crack the encoded PKCS7 Signed Message
    //
    HCRYPTMSG	hMsg = ::CryptMsgOpenToDecode (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      0,              
                                      0,
                                      0,
                                      NULL,           
                                      NULL);
	ASSERT (hMsg);
	if ( hMsg )
    {
		BOOL	bResult = ::CryptMsgUpdate (hMsg, m_pCTLContext->pbCtlEncoded,
				m_pCTLContext->cbCtlEncoded, TRUE);
		ASSERT (bResult);
		if ( bResult )
		{
			//
			// get the encoded signer BLOB
			//
		    DWORD       cbEncodedSigner = 0;
			bResult = ::CryptMsgGetParam (hMsg, CMSG_ENCODED_SIGNER, 0, NULL,
					&cbEncodedSigner);
			if ( bResult && cbEncodedSigner )
			{
				BYTE*	pbEncodedSigner = (PBYTE) ::LocalAlloc (LPTR, cbEncodedSigner);
				if ( pbEncodedSigner )
				{
					bResult = ::CryptMsgGetParam (hMsg, CMSG_ENCODED_SIGNER, 0,
							pbEncodedSigner, &cbEncodedSigner);
					ASSERT (bResult);
					if ( bResult )
					{
						DWORD	cbSignerInfo = 0;
						//
						// decode the EncodedSigner info
						//
						bResult = ::CryptDecodeObject (
								PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
								PKCS7_SIGNER_INFO,
								pbEncodedSigner,
								cbEncodedSigner,
								0,
								NULL,
								&cbSignerInfo);
						ASSERT (bResult);
						if ( bResult )
						{
							PCMSG_SIGNER_INFO	pbSignerInfo = (PCMSG_SIGNER_INFO) ::LocalAlloc (LPTR, cbSignerInfo);
							if ( pbSignerInfo )
							{
								bResult = ::CryptDecodeObject (
										PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
										PKCS7_SIGNER_INFO,
										pbEncodedSigner,
										cbEncodedSigner,
										0,
										pbSignerInfo,
										&cbSignerInfo);
								ASSERT (bResult);
								if ( bResult )
								{
									DWORD       cbCertInfo = 0;
									//
									// get the signers cert context
									//
									bResult = ::CryptMsgGetParam (hMsg,
													 CMSG_SIGNER_CERT_INFO_PARAM,
													 0,
													 NULL,               
													 &cbCertInfo);
									ASSERT (bResult);
									if ( bResult && cbEncodedSigner )
									{
										CERT_INFO*	pCertInfo = (CERT_INFO *) ::LocalAlloc (LPTR, cbCertInfo);
										if ( pCertInfo )
										{
											bResult = ::CryptMsgGetParam (hMsg,
												  CMSG_SIGNER_CERT_INFO_PARAM,
												  0,
												  pCertInfo,
												  &cbCertInfo);
											ASSERT (bResult);
											if ( bResult )
											{
												CCertificate* pCert = 
														m_pStoreCollection->GetSubjectCertificate (pCertInfo);
												if ( pCert )
												{
													signerName = pCert->GetSubjectName ();
													pCert->Release ();
												}
												else
													hResult = E_FAIL;
											}

											::LocalFree (pCertInfo);
										}
										else
										{
											hResult = E_OUTOFMEMORY;
										}
									}
								}
								::LocalFree (pbSignerInfo);
							}
							else
							{
								hResult = E_OUTOFMEMORY;
							}
						}
					}
					::LocalFree (pbEncodedSigner);
				}
				else
				{
					hResult = E_OUTOFMEMORY;
				}
			}
			else
				hResult = E_FAIL;
		}
		bResult = ::CryptMsgClose (hMsg);
		ASSERT (bResult);
	}
	else
		hResult = E_UNEXPECTED;

	_TRACE (-1, L"Leaving CCTL::GetSignerInfo\n");
	return hResult;
}


int CCTL::CompareEffectiveDate (const CCTL& ctl) const
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	int	compVal = 0;

	ASSERT (m_pCTLInfo && ctl.m_pCTLInfo);
	if ( m_pCTLInfo && ctl.m_pCTLInfo )
	{
		compVal = ::CompareFileTime (&m_pCTLInfo->ThisUpdate, 
				&ctl.m_pCTLInfo->ThisUpdate);
	}

	return compVal;
}

int CCTL::CompareNextUpdate (const CCTL& ctl) const
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	int	compVal = 0;

	ASSERT (m_pCTLInfo && ctl.m_pCTLInfo);
	if ( m_pCTLInfo && ctl.m_pCTLInfo )
	{
		compVal = ::CompareFileTime (&m_pCTLInfo->NextUpdate, 
				&ctl.m_pCTLInfo->NextUpdate);
	}

	return compVal;
}

CString CCTL::GetFriendlyName()
{
	_TRACE (1, L"Entering CCTL::GetFriendlyName\n");
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	ASSERT (m_pCTLContext);
	if ( m_pCTLContext && m_szFriendlyName.IsEmpty () )
	{	
		DWORD	cbData = 0;
		BOOL bResult = ::CertGetCTLContextProperty (
				m_pCTLContext,
				CERT_FRIENDLY_NAME_PROP_ID,
				NULL,
				&cbData);
		if ( bResult )
		{
			LPWSTR	pszName = new WCHAR[cbData];
			if ( pszName )
			{
				::ZeroMemory (pszName, cbData * sizeof (WCHAR));
				bResult = ::CertGetCTLContextProperty (
						m_pCTLContext,
						CERT_FRIENDLY_NAME_PROP_ID,
						pszName,
						&cbData);
				ASSERT (bResult);
				if ( bResult )
				{
					m_szFriendlyName = pszName;
				}
				else
				{
					VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
				}
				delete [] pszName;
			}
		}
		else
		{
			if ( GetLastError () == CRYPT_E_NOT_FOUND )
			{
				VERIFY (m_szFriendlyName.LoadString (IDS_NONE));
			}
			else
			{
				ASSERT (0);
				VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
			}
		}
    }
	_TRACE (-1, L"Leaving CCTL::GetFriendlyName\n");
	return m_szFriendlyName;
}

SPECIAL_STORE_TYPE CCTL::GetStoreType() const
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
			CERTMGR_CTL == m_objecttype);
	return m_rCertStore.GetStoreType ();
}

void CCTL::Refresh()
{
	m_szEffectiveDate = L"";
	m_szFriendlyName = L"";
	m_szIssuerName = L"";
	m_szNextUpdate = L"";
	m_szPurpose = L"";
}


BOOL CCTL::DeleteFromStore()
{
	_TRACE (1, L"Entering CCTL::DeleteFromStore\n");
	BOOL	bResult = FALSE;

	PCCTL_CONTEXT pCTLContext = GetNewCTLContext ();
	if ( pCTLContext )
	{
		bResult = ::CertDeleteCTLFromStore (pCTLContext);
		if ( bResult )
		{
			m_rCertStore.InvalidateCertCount ();
			m_rCertStore.SetDirty ();
			HRESULT hr = m_rCertStore.Commit ();
			if ( SUCCEEDED (hr) )
				m_rCertStore.Resync ();
			else
				bResult = FALSE;
		}
		m_rCertStore.Close ();
	}

	_TRACE (-1, L"Leaving CCTL::DeleteFromStore\n");
	return bResult;
}

PCCTL_CONTEXT CCTL::GetNewCTLContext()
{
	_TRACE (1, L"Entering CCTL::GetNewCTLContext\n");
	PCCTL_CONTEXT	pCTLContext = 0;
	HCERTSTORE		hCertStore = m_rCertStore.GetStoreHandle ();
	if ( hCertStore )
	{
		DWORD	cbData = 20;
		BYTE	certHash[20];
		BOOL bReturn = ::CertGetCTLContextProperty (
				m_pCTLContext,
				CERT_SHA1_HASH_PROP_ID,
				&certHash,
				&cbData);
		ASSERT (bReturn);
		if ( bReturn )
		{
			CRYPT_DATA_BLOB	blob = {sizeof (certHash), certHash};
			pCTLContext = CertFindCTLInStore(
				hCertStore,
				0,
				0,
				CTL_FIND_SHA1_HASH,
				&blob,
				0);
			if ( pCTLContext )
			{
				::CertFreeCTLContext (m_pCTLContext);
				m_pCTLContext = ::CertDuplicateCTLContext (pCTLContext);
			}
		}
	}

	_TRACE (-1, L"Leaving CCTL::GetNewCTLContext\n");
	return pCTLContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Cert Template Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Cert Template Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

    void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)

#endif



#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\disabledwarnings.h ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// pragma warnings
//
// 8 Feb 2000 sburns



// disable "symbols too long for debugger" warning: it happens a lot w/ STL

#pragma warning (disable: 4786)

// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)

// who cares about unreferenced inline removal?

#pragma warning (disable: 4514)
#pragma warning (disable : 4505)

// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)

// some stl templates are lousy signed/unsigned mismatches

#pragma warning (disable: 4018 4146)

// we like this extension

#pragma warning (disable: 4239)

// we don't always want copy constructors

#pragma warning (disable: 4511)

// we don't always want assignment operators

#pragma warning (disable: 4512)

// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\dataobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       DataObj.cpp
//
//  Contents:   Implementation of data object classes
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS("CERTMGR(dataobj.cpp)")

#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"

#pragma warning(push,3)
#include <sceattch.h>
#pragma warning(pop)
#include "uuids.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"


// IDataObject interface implementation

CCertMgrDataObject::CCertMgrDataObject()
		: m_pCookie (0),
		m_objecttype (CERTMGR_SNAPIN),
		m_dataobjecttype (CCT_UNINITIALIZED),
		m_dwLocation (0),
		m_pGPEInformation (0),
		m_pRSOPInformation (0),
        m_pbMultiSelData(NULL),
        m_cbMultiSelData(0),
		m_bMultiSelDobj(false),
		m_iCurr(0)
{
}

HRESULT CCertMgrDataObject::GetDataHere(
	FORMATETC __RPC_FAR *pFormatEtcIn,
	STGMEDIUM __RPC_FAR *pMedium)
{
    HRESULT hr = DV_E_FORMATETC;
	
	const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
	if (cf == m_CFNodeType)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const GUID* pguid = GetObjectTypeGUID( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			hr = s.Write(pguid, sizeof(GUID));
		}
		else
			hr = E_UNEXPECTED;
	}
	else if (cf == m_CFSnapInCLSID)
	{
		stream_ptr s(pMedium);
		hr =  s.Write(&m_SnapInCLSID, sizeof(GUID));
	}
	else if (cf == m_CFNodeTypeString)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const BSTR strGUID = GetObjectTypeString( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			hr = s.Write(strGUID);
		}
		else
			hr = E_UNEXPECTED;
	}
	else if (cf == m_CFDisplayName)
	{
		hr = PutDisplayName(pMedium);
	}
	else if (cf == m_CFDataObjectType)
	{
		stream_ptr s(pMedium);
		hr = s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
	}
	else if (cf == m_CFMachineName)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			stream_ptr s(pMedium);
			hr = s.Write(m_pCookie->QueryNonNULLMachineName());
		}
		else
			hr = E_UNEXPECTED;
	}
	else if (cf == m_CFRawCookie)
	{
		stream_ptr s(pMedium);


		if ( m_pCookie )
		{
			// CODEWORK This cast ensures that the data format is
			// always a CCookie*, even for derived subclasses
			if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie ||
					IsValidObjectType (m_pCookie->m_objecttype) )
			{
				CCookie* pcookie = (CCookie*) m_pCookie;
				hr = s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pCookie));
			}
			else
				hr = E_UNEXPECTED;
		}
	}
	else if ( cf == m_CFSCE_GPTUnknown )
	{
		hr = CreateGPTUnknown (pMedium);
    }
	else if ( cf == m_CFSCE_RSOPUnknown )
	{
		hr = CreateRSOPUnknown (pMedium);
    }
	else if ( cf == m_CFMultiSel )
	{
		hr = CreateMultiSelectObject (pMedium);
	}
	else if (cf == m_CFSnapinPreloads)
	{
		stream_ptr s(pMedium);
		// If this is TRUE, then the next time this snapin is loaded, it will
		// be preloaded to give us the opportunity to change the root node
		// name before the user sees it.
		hr = s.Write (reinterpret_cast<PBYTE>(&m_fAllowOverrideMachineName), sizeof (BOOL));
	}

	return hr;
}

HRESULT CCertMgrDataObject::Initialize(
	CCertMgrCookie*			pcookie,
	DATA_OBJECT_TYPES		type,
	BOOL					fAllowOverrideMachineName,
	DWORD					dwLocation,
	CString					szManagedUser,
	CString					szManagedComputer,
	CString					szManagedService,
	CCertMgrComponentData&	refComponentData)
{
	if ( !pcookie || m_pCookie )
	{
		ASSERT(FALSE);
		return S_OK;	// Initialize must not fail
	}

	m_dataobjecttype = type;
	m_pCookie = pcookie;
	m_fAllowOverrideMachineName = fAllowOverrideMachineName;
	m_dwLocation = dwLocation;
	m_szManagedUser = szManagedUser;
	m_szManagedComputer = szManagedComputer;
	m_szManagedService = szManagedService;

	if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie )
		((CRefcountedObject*)m_pCookie)->AddRef();
	VERIFY( SUCCEEDED(refComponentData.GetClassID(&m_SnapInCLSID)) );
	return S_OK;
}


CCertMgrDataObject::~CCertMgrDataObject()
{
	if ( m_pGPEInformation )
	{
		m_pGPEInformation->Release ();
		m_pGPEInformation = 0;
	}
	
	if ( m_pRSOPInformation )
	{
		m_pRSOPInformation->Release ();
		m_pRSOPInformation = 0;
	}
	
	if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie &&
			m_pCookie && IsValidObjectType (m_pCookie->m_objecttype) )
	{
		((CRefcountedObject*)m_pCookie)->Release();
	}
    if (m_pbMultiSelData)
        delete m_pbMultiSelData;

    for (int i=0; i < m_rgCookies.GetSize(); ++i)
    {
        m_rgCookies[i]->Release();
    }
}

void CCertMgrDataObject::AddCookie(CCertMgrCookie* pCookie)
{
    m_rgCookies.Add(pCookie);
    pCookie->AddRef();
}

HRESULT CCertMgrDataObject::PutDisplayName(STGMEDIUM* pMedium)
	// Writes the "friendly name" to the provided storage medium
	// Returns the result of the write operation
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CString strDisplayName = m_pCookie->QueryTargetServer();
	CString	formattedName;

	switch (m_dwLocation)
	{
	case CERT_SYSTEM_STORE_CURRENT_USER:
		VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_USER));
		break;

	case CERT_SYSTEM_STORE_LOCAL_MACHINE:
		if (strDisplayName.IsEmpty())
		{
			VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_LOCAL_MACHINE));
		}
		else
			formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_MACHINE, strDisplayName);
		break;

	case CERT_SYSTEM_STORE_CURRENT_SERVICE:
	case CERT_SYSTEM_STORE_SERVICES:
		if (strDisplayName.IsEmpty())
		{
			// Get this machine name and add it to the string.
			formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE_LOCAL_MACHINE,
					m_szManagedService);
		}
		else
		{
			formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE,
					m_szManagedService, strDisplayName);
		}
		break;

	// These next two titles can only be set from the debugger.  They are used
	// to create custom .MSC files.
	case -1:
		formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_CERT_MGR_CURRENT_USER);
		break;

	case 0:
		formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_FILE);
		break;

	default:
		ASSERT (0);
		break;
	}

	stream_ptr s (pMedium);
	return s.Write (formattedName);
}

// Register the clipboard formats
CLIPFORMAT CCertMgrDataObject::m_CFDisplayName =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CCertMgrDataObject::m_CFMachineName =
								(CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
								(CLIPFORMAT)RegisterClipboardFormat(L"CERTMGR_SNAPIN_RAW_COOKIE");
CLIPFORMAT CCertMgrDataObject::m_CFMultiSel =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
CLIPFORMAT CCertMgrDataObject::m_CFMultiSelDobj =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
CLIPFORMAT CCertMgrDataObject::m_CFSCEModeType =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_SCE_MODE_TYPE);
CLIPFORMAT CCertMgrDataObject::m_CFSCE_GPTUnknown =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_SCE_GPT_UNKNOWN);
CLIPFORMAT CCertMgrDataObject::m_CFSCE_RSOPUnknown =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_SCE_RSOP_UNKNOWN);
CLIPFORMAT CCertMgrDataObject::m_CFMultiSelDataObjs =
							    (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);


void CCertMgrDataObject::SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
{
    m_pbMultiSelData = pbMultiSelData;
    m_cbMultiSelData = cbMultiSelData;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertMgrComponentData::QueryDataObject (
		MMC_COOKIE cookie,
		DATA_OBJECT_TYPES type,
		LPDATAOBJECT* ppDataObject)
{
	if ( MMC_MULTI_SELECT_COOKIE == cookie )
	{
		return QueryMultiSelectDataObject (cookie, type, ppDataObject);
	}
	CCertMgrCookie* pUseThisCookie =
			(CCertMgrCookie*) ActiveBaseCookie (
			reinterpret_cast<CCookie*> (cookie));

	CComObject<CCertMgrDataObject>* pDataObject = 0;
	HRESULT hRes = CComObject<CCertMgrDataObject>::CreateInstance(&pDataObject);
	if ( FAILED(hRes) )
		return hRes;

	if ( m_szManagedUser.IsEmpty () )
		m_szManagedUser = m_szLoggedInUser;

	m_szManagedComputer = pUseThisCookie->QueryTargetServer();
	if ( m_szManagedComputer.IsEmpty () && m_strMachineNamePersist.CompareNoCase (m_szThisComputer) ) // !=
    {
        m_szManagedComputer = m_strMachineNamePersist;
    }
	if ( m_szManagedComputer.IsEmpty () )
		m_szManagedComputer = pUseThisCookie->QueryNonNULLMachineName ();
	if ( m_szManagedComputer.IsEmpty () )
		m_szManagedComputer = m_szThisComputer;

    // Raid bug 278491	US: Cert search for a remote computer application 
    // fails to search certs on a remote computer, instead running a search 
    // on Local machine
    if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )
        pUseThisCookie->SetMachineName (m_szManagedComputer);

    // Truncate leading "\\"
    if ( !wcsncmp (m_szManagedComputer, L"\\\\", 2) )
        m_szManagedComputer = m_szManagedComputer.Mid (2);

	HRESULT hr = pDataObject->Initialize (
			pUseThisCookie,
			type,
			m_fAllowOverrideMachineName,
			m_dwLocationPersist,
			m_szManagedUser,
			m_szManagedComputer,
			m_szManagedServiceDisplayName,
			*this);
	if ( FAILED(hr) )
	{
		delete pDataObject;
		return hr;
	}

	if ( m_pGPEInformation )
		pDataObject->SetGPTInformation (m_pGPEInformation);
	if ( m_bIsRSOP )
    {
        IRSOPInformation*   pRSOPInformation = 0;

        switch (pUseThisCookie->m_objecttype)
        {
	    case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
            pRSOPInformation = m_pRSOPInformationComputer;
            break;

	    case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_USER_ENTRIES:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_USER_ENTRY:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
            pRSOPInformation = m_pRSOPInformationUser;
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_LOG_STORE:
	    case CERTMGR_PHYS_STORE:
	    case CERTMGR_USAGE:
	    case CERTMGR_CRL_CONTAINER:
	    case CERTMGR_CTL_CONTAINER:
	    case CERTMGR_CERT_CONTAINER:
	    case CERTMGR_CRL:
	    case CERTMGR_CTL:
	    case CERTMGR_AUTO_CERT_REQUEST:
	    case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        default:
            pRSOPInformation = m_pRSOPInformationComputer;
            break;
        }
		pDataObject->SetRSOPInformation (pRSOPInformation);
    }
    pDataObject->AddRef();
	*ppDataObject = pDataObject;
	return hr;
}

typedef CArray<GUID, const GUID&> CGUIDArray;

void GuidArray_Add(CGUIDArray& rgGuids, const GUID& guid)
{
    for (INT_PTR i=rgGuids.GetUpperBound(); i >= 0; --i)
    {
        if (rgGuids[i] == guid)
            break;
    }

    if (i < 0)
        rgGuids.Add(guid);
}

HRESULT CCertMgrComponentData::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

	HRESULT		hr = S_OK;
    CGUIDArray	rgGuids;

    // Determine the items selected
    ASSERT(m_pResultData != NULL);
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = TVIS_SELECTED;

	CCookiePtrArray	rgCookiesSelected;
    while (m_pResultData->GetNextItem (&rdi) == S_OK)
    {
        const GUID* pguid;
        CCertMgrCookie* pCookie = reinterpret_cast <CCertMgrCookie*> (rdi.lParam);
        if ( pCookie )
        {
			rgCookiesSelected.Add (pCookie);
			switch (pCookie->m_objecttype)
			{
			case CERTMGR_CERTIFICATE:
				pguid = &NODEID_CertMgr_CERTIFICATE;
				break;

			case CERTMGR_CTL:
				pguid = &NODEID_CertMgr_CTL;
				break;

			case CERTMGR_CRL:
				pguid = &NODEID_CertMgr_CRL;
				break;

			case CERTMGR_AUTO_CERT_REQUEST:
				pguid = &NODEID_CertMgr_AUTOCERT;
				break;

            case CERTMGR_SAFER_COMPUTER_ENTRY:
                pguid = &NODEID_Safer_COMPUTER_ENTRY;
                break;

            case CERTMGR_SAFER_USER_ENTRY:
                pguid = &NODEID_Safer_USER_ENTRY;
                break;

			default:
				ASSERT (0);
				continue;
			}
        }
        else
        {
			hr = E_INVALIDARG;
			break;
        }

        GuidArray_Add(rgGuids, *pguid);
    }

    CComObject<CCertMgrDataObject>* pObject;
    CComObject<CCertMgrDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
	pObject->Initialize ((CCertMgrCookie*) cookie,
				type,
				m_fAllowOverrideMachineName,
				m_dwLocationPersist,
				m_szManagedUser,
				m_szManagedComputer,
				m_szManagedServiceDisplayName,
				*this);
    pObject->SetMultiSelDobj();



    // Store the coclass with the data object
    UINT cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
    GUID* pGuid = new GUID[(UINT)rgGuids.GetSize()];
	if ( pGuid )
	{
		CopyMemory(pGuid, rgGuids.GetData(), cb);
		pObject->SetMultiSelData((BYTE*)pGuid, cb);
		for (int i=0; i < rgCookiesSelected.GetSize(); ++i)
		{
			pObject->AddCookie(rgCookiesSelected[i]);
		}

		return  pObject->QueryInterface(
				IID_PPV_ARG (IDataObject, ppDataObject));
	}
	else
		return E_OUTOFMEMORY;
}


HRESULT CCertMgrDataObject::SetGPTInformation(IGPEInformation * pGPTInformation)
{
	HRESULT hr = S_OK;

	if  ( pGPTInformation )
	{
		m_pGPEInformation = pGPTInformation;
		m_pGPEInformation->AddRef ();
	}
	else
		hr = E_POINTER;

	return hr;
}

HRESULT CCertMgrDataObject::SetRSOPInformation(IRSOPInformation * pRSOPInformation)
{
	HRESULT hr = S_OK;

	if  ( pRSOPInformation )
	{
		m_pRSOPInformation = pRSOPInformation;
		m_pRSOPInformation->AddRef ();
	}
	else
		hr = E_POINTER;

	return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateGPTUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to GPT's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertMgrDataObject::CreateGPTUnknown(LPSTGMEDIUM lpMedium)
{
   HRESULT hr = S_OK;
   LPUNKNOWN pUnk = 0;

   if ( !m_pGPEInformation )
   {
      //
      // If we don't have a pointer to a GPT interface then we must not
      // be in a mode where we're extending GPT and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   hr = m_pGPEInformation->QueryInterface (
		IID_PPV_ARG (IUnknown, &pUnk));
   if ( SUCCEEDED(hr) )
   {
      return Create (&pUnk, sizeof(pUnk), lpMedium);
   }
   else
   {
      return hr;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateRSOPUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to RSOP's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertMgrDataObject::CreateRSOPUnknown(LPSTGMEDIUM lpMedium)
{
   HRESULT hr = S_OK;
   LPUNKNOWN pUnk = 0;

   if ( !m_pRSOPInformation )
   {
      //
      // If we don't have a pointer to a GPT interface then we must not
      // be in a mode where we're extending GPT and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   hr = m_pRSOPInformation->QueryInterface (
		IID_PPV_ARG (IUnknown, &pUnk));
   if ( SUCCEEDED(hr) )
   {
      return Create (&pUnk, sizeof(pUnk), lpMedium);
   }
   else
   {
      return hr;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::Create
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the data in pBuffer
//
//  Arguments:  [pBuffer]  - [in] the data to be written
//              [len]      - [in] the length of that data
//              [lpMedium] - [in,out] where to store the data
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertMgrDataObject::Create (const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
   HRESULT hr = DV_E_TYMED;

   //
   // Do some simple validation
   //
   if (pBuffer == NULL || lpMedium == NULL)
      return E_POINTER;

   //
   // Make sure the type medium is HGLOBAL
   //
   if (lpMedium->tymed == TYMED_HGLOBAL) {
      //
      // Create the stream on the hGlobal passed in
      //
      LPSTREAM lpStream = 0;
      hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

	  ASSERT (SUCCEEDED (hr));
      if (SUCCEEDED(hr))
	  {
         //
         // Write to the stream the number of bytes
         //
         ULONG written = 0;
         hr = lpStream->Write(pBuffer, len, &written);
		 ASSERT (SUCCEEDED (hr));

         //
         // Because we told CreateStreamOnHGlobal with 'FALSE',
         // only the stream is released here.
         // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
         // at the correct time.  This is according to the IDataObject specification.
         //
         lpStream->Release();
      }
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CCertMgrDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT CCertMgrDataObject::CreateMultiSelectObject(LPSTGMEDIUM lpMedium)
{
    ASSERT(m_pbMultiSelData != 0);
    ASSERT(m_cbMultiSelData != 0);

    lpMedium->tymed = TYMED_HGLOBAL;
    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                                      (m_cbMultiSelData + sizeof(DWORD)));
    if (lpMedium->hGlobal == NULL)
        return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID);
    pb += sizeof(DWORD);
    CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

    ::GlobalUnlock(lpMedium->hGlobal);

	return S_OK;
}




LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject)
{
	if (lpDataObject == NULL)
		return NULL;

	SMMCDataObjects * pDO = NULL;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { CCertMgrDataObject::m_CFMultiSelDataObjs, NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	if ( FAILED (lpDataObject->GetData (&formatetc, &stgmedium)) )
	{
		return NULL;
	}
	else
	{
		pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
		return pDO->lpDataObject[0]; //assume that ours is the 1st
	}
}

STDMETHODIMP CCertMgrDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetc->cfFormat == m_CFMultiSel)
    {
        ASSERT(((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie);
        if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie )
        {
            hr = CreateMultiSelectObject (lpMedium);
        }
        else
            hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CCertMgrDataObject::Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;

    if ((rgelt == NULL) ||
        ((celt > 1) && (pceltFetched == NULL)))
    {
        hr = E_INVALIDARG;
        CHECK_HRESULT(hr);
        return hr;
    }

    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    if (pceltFetched)
        *pceltFetched = celtTemp;

    if (celtTemp == 0)
        return S_FALSE;

    for (ULONG i=0; i < celtTemp; ++i)
    {
        rgelt[i] = reinterpret_cast<MMC_COOKIE>(m_rgCookies[m_iCurr++]);
    }

    return (celtTemp < celt) ? S_FALSE : S_OK;
}

STDMETHODIMP CCertMgrDataObject::Skip(ULONG celt)
{
    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    m_iCurr += celtTemp;

    return (celtTemp < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CCertMgrDataObject::Reset(void)
{
    m_iCurr = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dbg.h
//
//  Contents:   
//
//----------------------------------------------------------------------------


#pragma warning(push, 3)
#include "StdDbg.h"
#pragma warning(pop)

#if DBG==1
    DECLARE_DEBUG(CertificateManagerSnapin)
    #define DBG_COMP    CertificateManagerSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\ctl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ctl.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_CTL_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
#define AFX_CTL_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cookie.h"


class CCTL : public CCertMgrCookie  
{
public:
	BOOL DeleteFromStore ();
	virtual void Refresh();
	SPECIAL_STORE_TYPE GetStoreType () const;
	CString GetFriendlyName ();
	CString GetPurpose ();
	CCTL (const PCCTL_CONTEXT pCTLContext, 
			CCertStore& rCertStore, 
			CertificateManagerObjectType objectType = CERTMGR_CTL,
			CTypedPtrList<CPtrList, CCertStore*>*	pStoreList = 0);
	virtual ~CCTL();

	int CompareNextUpdate (const CCTL& ctl) const;
	int CompareEffectiveDate (const CCTL& ctl) const;
	PCCTL_CONTEXT GetCTLContext() const;
	CCertStore& GetCertStore() const;
	CString GetIssuerName ();
	CString GetNextUpdate ();
	CString GetEffectiveDate ();

protected:
    PCCTL_CONTEXT GetNewCTLContext();
	void FormatEnhancedKeyUsagePropertyString (CString& string);
	HRESULT GetSignerInfo (CString & signerName);

private:
	CCertStore*								m_pStoreCollection;
	CString									m_szFriendlyName;
	CString									m_szPurpose;
	CCertStore&								m_rCertStore;
	PCCTL_CONTEXT						    m_pCTLContext;
	CString									m_szEffectiveDate;
	CString									m_szNextUpdate;
	CString									m_szIssuerName;
	PCTL_INFO								m_pCTLInfo;
	CTypedPtrList<CPtrList, CCertStore*>	m_storeList;
    HCERTSTORE                              m_hExtraStore;
};

#endif // !defined(AFX_CTL_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\dataobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dataobj.h
//
//  Contents:
//
//----------------------------------------------------------------------------

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__


// For use in multiple selection.
LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject);


class CCertMgrDataObject : public CDataObject
{
	DECLARE_NOT_AGGREGATABLE(CCertMgrDataObject)

public:

// debug refcount
#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

	CCertMgrDataObject();

	virtual ~CCertMgrDataObject();

	STDMETHODIMP Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched);
	STDMETHODIMP Skip(ULONG celt);
	STDMETHODIMP Reset(void);
	void AddCookie(CCertMgrCookie* pCookie);
	virtual HRESULT Initialize (
			CCertMgrCookie* pcookie,
			DATA_OBJECT_TYPES type,
			BOOL fAllowOverrideMachineName,
			DWORD	dwLocation,
			CString	szManagedUser,
			CString szManagedComputer,
			CString szManagedService,
			CCertMgrComponentData& refComponentData);

	// IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

    HRESULT PutDisplayName(STGMEDIUM* pMedium);
	HRESULT PutServiceName(STGMEDIUM* pMedium);
	void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData);
	STDMETHODIMP GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(IsMultiSelect)(void)
    {
        return (m_rgCookies.GetSize() > 1) ? S_OK : S_FALSE;
    }

protected:
	HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);
	HRESULT Create (const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
	HRESULT CreateGPTUnknown(LPSTGMEDIUM lpMedium) ;
	HRESULT CreateRSOPUnknown(LPSTGMEDIUM lpMedium) ;
	CCertMgrCookie* m_pCookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
	CertificateManagerObjectType m_objecttype;
	DATA_OBJECT_TYPES m_dataobjecttype;
	BOOL m_fAllowOverrideMachineName;	// From CCertMgrComponentData
	GUID m_SnapInCLSID;

public:
	HRESULT SetGPTInformation (IGPEInformation* pGPTInformation);
	HRESULT SetRSOPInformation (IRSOPInformation* pRSOPInformation);

	// Clipboard formats
	static CLIPFORMAT m_CFDisplayName;
	static CLIPFORMAT m_CFMachineName;
    static CLIPFORMAT m_CFMultiSel;        // Required for multiple selection
    static CLIPFORMAT m_CFMultiSelDobj;    // Required for multiple selection
	static CLIPFORMAT m_CFSCEModeType;	 // For SCE snapin mode type
	static CLIPFORMAT m_CFSCE_GPTUnknown;	 // For IUnknown of GPT (which SCE extends)
	static CLIPFORMAT m_CFSCE_RSOPUnknown;	 // For IUnknown of GPT (which SCE extends)
	static CLIPFORMAT m_CFMultiSelDataObjs;// for Multiple selection

private:
    // data member used by IEnumCookies
    ULONG							m_iCurr;
	CCookiePtrArray					m_rgCookies;
	bool							m_bMultiSelDobj;
	IGPEInformation*				m_pGPEInformation;
	IRSOPInformation*				m_pRSOPInformation;
    BYTE*							m_pbMultiSelData;
    UINT							m_cbMultiSelData;
	CString							m_szManagedComputer;
	CString							m_szManagedUser;
	CString							m_szManagedService;
	DWORD							m_dwLocation;

public:
    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = true;
    }
}; // CCertMgrDataObject

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#if DBG == 1
static int indentLevel = 0;

#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;

void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const size_t DEBUG_BUF_LEN = 512;
        WCHAR Buffer[DEBUG_BUF_LEN];
        int cb;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        cb = _vsnwprintf (Buffer, DEBUG_BUF_LEN, format, arglist);
        if ( cb )
        {
            OutputDebugStringW (Buffer);
        }

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, NULL,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\dynamlnk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       DynamLnk.h
//
//  Contents:   Base class for DLLs which are loaded only when needed
//
//----------------------------------------------------------------------------
 

#ifndef __DYNAMLNK_H_INCLUDED__
#define __DYNAMLNK_H_INCLUDED__

class DynamicDLL
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	DynamicDLL(LPCWSTR ptchLibraryName, LPCSTR* apchFunctionNames);
	virtual ~DynamicDLL();

	BOOL LoadFunctionPointers();

	FARPROC QueryFunctionPtr(INT i) const;
	inline FARPROC operator[] (INT i) const
		{ return QueryFunctionPtr(i); }

private:
	HMODULE m_hLibrary;
	FARPROC* m_apfFunctions;
	LPCWSTR m_ptchLibraryName;
	LPCSTR* m_apchFunctionNames;
	INT m_nNumFunctions;
};
#endif // ~__DYNAMLNK_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\efsgeneralpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       EFSGeneralPropertyPage.h
//
//  Contents:   Declaration of CEFSGeneralPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_EFSGENERALPROPERTYPAGE_H__C1A52682_9D6B_4436_AD3E_F47232BF7B88__INCLUDED_)
#define AFX_EFSGENERALPROPERTYPAGE_H__C1A52682_9D6B_4436_AD3E_F47232BF7B88__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EFSGeneralPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEFSGeneralPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CEFSGeneralPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CEFSGeneralPropertyPage(CCertMgrComponentData* pCompData, bool bIsMachine);
	~CEFSGeneralPropertyPage();

// Dialog Data
	//{{AFX_DATA(CEFSGeneralPropertyPage)
	enum { IDD = IDD_EFS_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CEFSGeneralPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CEFSGeneralPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnTurnOnEfs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void RSOPGetEFSFlags ();
    virtual void DoContextHelp (HWND hWndControl);
    void GPEGetEFSFlags();

private:
    const bool              m_bIsMachine;
    CCertMgrComponentData*  m_pCompData;
	IGPEInformation*	    m_pGPEInformation;
	HKEY				    m_hGroupPolicyKey;
    bool                    m_bDirty;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EFSGENERALPROPERTYPAGE_H__C1A52682_9D6B_4436_AD3E_F47232BF7B88__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\finddlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001
//
//  File:       FindDlg.cpp
//
//  Contents:   implementation Find certificate dialog
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#pragma warning(push, 3)
#include <process.h>
#pragma warning(pop)
#include "mbstring.h"
#include "FindDlg.h"
#include "cookie.h"
#include <wintrust.h>
#include <cryptui.h>
#include "compdata.h"
USE_HANDLE_MACROS("CERTMGR(finddlg.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFindDialog dialog
const WCHAR chLEFT_TO_RIGHT = 0x200e;


CFindDialog::CFindDialog (CWnd* pParent,
		const CString &pcszMachineName,
		const CString &szFileName,
		CCertMgrComponentData* pCompData)
	: CHelpDialog(CFindDialog::IDD, pParent),
	m_cyOriginal (0),
	m_fWindowExpandedOnce (false),
	m_cyMin (0),
	m_cxBtnMargin (0),
	m_cxMin (0),
	m_cxAnimMargin (0),
	m_cxStoreListMargin (0),
	m_cxContainMargin (0),
	m_cxTabMargin (0),
	m_cxFieldListMargin (0),
	m_cxResultListMargin (0),
	m_szMachineName (pcszMachineName),
	m_bAnimationRunning (false),
	m_szFileName (szFileName),
	m_hSearchThread (0),
	m_singleLock (&m_critSec, FALSE),
	m_pCompData (pCompData),
	m_bConsoleRefreshRequired (false),
	m_hCancelSearchEvent (0),
    m_bInitComplete (false)
{
	_TRACE (1, L"Entering CFindDialog::CFindDialog\n");
	//{{AFX_DATA_INIT(CFindDialog)
	m_szContains = _T("");
	m_szSearchField = _T("");
	m_szSelectedStore = _T("");
	//}}AFX_DATA_INIT

	// Get name of logged-in user
	DWORD	dwSize = 0;
	::GetUserName (0, &dwSize);
	ASSERT (dwSize > 0);
	if ( dwSize > 0 )
	{
		BOOL bRet = ::GetUserName (m_szLoggedInUser.GetBufferSetLength (dwSize), &dwSize);
		ASSERT (bRet);
		m_szLoggedInUser.ReleaseBuffer ();
	}

	m_hCancelSearchEvent = CreateEvent(
		NULL,   // pointer to security attributes
		TRUE,  // flag for manual-reset event
		FALSE, // flag for initial state
		L"CancelSearchEvent");     // pointer to event-object name
	if ( !m_hCancelSearchEvent )
	{
		_TRACE (0, L"CreateEvent (CancelSearchEvent) failed: 0x%x\n", GetLastError ());
	}
	_TRACE (-1, L"Leaving CFindDialog::CFindDialog\n");
}


CFindDialog::~CFindDialog ()
{
	_TRACE (1, L"Entering CFindDialog::~CFindDialog\n");
	if ( m_hSearchThread )
		StopSearch ();
	if ( m_hCancelSearchEvent )
		CloseHandle (m_hCancelSearchEvent);
	_TRACE (-1, L"Leaving CFindDialog::~CFindDialog\n");
}

void CFindDialog::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFindDialog)
	DDX_Control(pDX, IDC_STORE_LIST, m_storeList);
	DDX_Control(pDX, IDC_STOP, m_stopBtn);
	DDX_Control(pDX, IDC_RESULT_LIST, m_resultsList);
	DDX_Control(pDX, IDC_NEW_SEARCH, m_newSearchBtn);
	DDX_Control(pDX, IDC_FIND_NOW, m_findNowBtn);
	DDX_Control(pDX, IDC_FIELD_LIST, m_fieldList);
	DDX_Control(pDX, IDC_ANIMATE, m_animate);
	DDX_Text(pDX, IDC_CONTAINS_TEXT, m_szContains);
	DDX_CBString(pDX, IDC_FIELD_LIST, m_szSearchField);
	DDX_CBString(pDX, IDC_STORE_LIST, m_szSelectedStore);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFindDialog, CHelpDialog)
	//{{AFX_MSG_MAP(CFindDialog)
	ON_BN_CLICKED(IDC_FIND_NOW, OnFindNow)
	ON_WM_SIZING()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_NEW_SEARCH, OnNewSearch)
	ON_BN_CLICKED(IDC_STOP, OnStop)
	ON_NOTIFY(NM_RCLICK, IDC_RESULT_LIST, OnRclickResultList)
	ON_NOTIFY(NM_DBLCLK, IDC_RESULT_LIST, OnDblclkResultList)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_RESULT_LIST, OnColumnclickResultList)
	ON_EN_CHANGE(IDC_CONTAINS_TEXT, OnChangeContainsText)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_RESULT_LIST, OnItemchangedResultList)
	ON_WM_CONTEXTMENU()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_COMMAND(ID_VIEW, OnView)
	ON_COMMAND(ID_ENROLL_SAME_KEY, OnEnrollSameKey)
	ON_COMMAND(ID_ENROLL_NEW_KEY, OnEnrollNewKey)
	ON_COMMAND(ID_FILE_DELETE, OnFileDelete)
	ON_COMMAND(ID_FILE_EXPORT, OnFileExport)
	ON_COMMAND(ID_FILE_RENEW_NEW_KEY, OnFileRenewNewKey)
	ON_COMMAND(ID_FILE_RENEW_SAME_KEY, OnFileRenewSameKey)
	ON_COMMAND(ID_EDIT_INVERTSELECTION, OnEditInvertselection)
	ON_COMMAND(ID_EDIT_SELECTALL, OnEditSelectall)
	ON_COMMAND(ID_FILE_PROPERTIES, OnFileProperties)
	ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpHelptopics)
	ON_COMMAND(IDM_VIEW_DETAILS, OnViewDetails)
	ON_COMMAND(ID_VIEW_LARGEICONS, OnViewLargeicons)
	ON_COMMAND(IDM_VIEW_LIST, OnViewList)
	ON_COMMAND(ID_VIEW_SMALLICONS, OnViewSmallicons)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
	ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()


BOOL CFindDialog::OnInitDialog()
{
    _TRACE (1, L"Entering CFindDialog::OnInitDialog\n");
	CHelpDialog::OnInitDialog();



	// Set up the menu
	HMENU	hMenu = ::LoadMenu (AfxGetInstanceHandle (),
				MAKEINTRESOURCE (IDR_FIND_DLG_MENU));
	ASSERT (hMenu);
	if ( hMenu )
	{
		if (::SetMenu (m_hWnd, hMenu) )
		{
			// Disable these menu items until the window is expanded when searching
			VERIFY (::EnableMenuItem (hMenu, ID_VIEW_LARGEICONS, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_VIEW_SMALLICONS, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_LIST, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_DETAILS, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_DELETE, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_EXPORT, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_PROPERTIES, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_VIEW, MF_GRAYED) != -1);
		}
		else
			ASSERT (0);
	}

	SetUpResultList ();

	// Size window to hide list view until search is performed
	HideResultList ();

	// Initialize animation
	VERIFY (m_animate.Open (IDR_FINDCERT_AVI));

	// Set up cert store list
	AddLogicalStoresToList ();

	// Set cert field list
	AddFieldsToList ();

	m_findNowBtn.EnableWindow (FALSE);
	m_stopBtn.EnableWindow (FALSE);
	m_newSearchBtn.EnableWindow (FALSE);
	
    m_bInitComplete = true;
    _TRACE (-1, L"Leaving CFindDialog::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFindDialog::OnFindNow()
{
    _TRACE (1, L"Entering CFindDialog::OnFindNow\n");
	// Disable the controls during the search
	GetDlgItem (IDC_CONTAINS_TEXT)->EnableWindow (FALSE);
	m_resultsList.EnableWindow (FALSE);
	m_fieldList.EnableWindow (FALSE);
	m_storeList.EnableWindow (FALSE);
	m_findNowBtn.EnableWindow (FALSE);
	m_newSearchBtn.EnableWindow (FALSE);
	m_stopBtn.EnableWindow (TRUE);
	m_stopBtn.SetFocus ();

	VERIFY (m_animate.Play (0, (UINT) -1, (UINT) -1));
	m_bAnimationRunning = true;
	UpdateData (TRUE);
	DeleteAllResultItems ();


	if ( !m_fWindowExpandedOnce )
    {
//        ChangeToSizableFrame ();
        ExpandWindow ();
    }

	DoSearch ();

	EnableMenuItems ();

}

void CFindDialog::EnableMenuItems ()
{
	_TRACE (1, L"Entering CFindDialog::EnableMenuItems\n");
    HMENU   hMenu = ::GetMenu (m_hWnd);
	ASSERT (hMenu);
	if ( hMenu )
	{
		int nCnt = m_resultsList.GetItemCount ();
		if ( nCnt > 0 )
		{
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_ENABLED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_ENABLED) != -1);
		}
		else
		{
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_GRAYED) != -1);
		}

		UINT	nSelCnt = m_resultsList.GetSelectedCount ();

        VERIFY (::EnableMenuItem (hMenu, ID_FILE_DELETE,
				(nSelCnt >= 1) ? MF_ENABLED : MF_GRAYED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_FILE_EXPORT,
				(nSelCnt >= 1) ? MF_ENABLED : MF_GRAYED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_FILE_PROPERTIES,
				(nSelCnt == 1) ? MF_ENABLED : MF_GRAYED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_VIEW,
				(nSelCnt == 1) ? MF_ENABLED : MF_GRAYED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY, MF_GRAYED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY, MF_GRAYED) != -1);
		if ( nSelCnt == 1 )
		{
			int				nSelItem = 0;
			CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
			ASSERT (pCert);
			if ( pCert )
			{
				bool bIsMyStore = (pCert->GetStoreType () == MY_STORE);
				if ( bIsMyStore && CERT_SYSTEM_STORE_SERVICES != m_pCompData->GetLocation () )
				{
					VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY,
							MF_ENABLED) != -1);
					VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY,
							MF_ENABLED) != -1);
				}
			}
		}	
	}	
	_TRACE (-1, L"Leaving CFindDialog::EnableMenuItems\n");
}


void CFindDialog::OnSize (UINT nType, int cx, int cy)
{
    CHelpDialog::OnSize (nType, cx, cy);

    MoveControls ();
}


void CFindDialog::OnSizing (UINT nSide, LPRECT lpRect)
{
    _TRACE (1, L"Entering CFindDialog::OnSizing\n");
	int	cyHeight = lpRect->bottom - lpRect->top;
	int	cxWidth = lpRect->right - lpRect->left;

	// If the user has never pressed "Find Now", don't let the user expand the window down
	// Don't let the user shrink the window below it's initial state - I don't want to deal with
	// control compression!
	switch (nSide)
	{
	case WMSZ_BOTTOM:
		if ( !m_fWindowExpandedOnce )
			lpRect->top = lpRect->bottom - m_cyMin;
		else
		{
			if ( cyHeight < m_cyMin )
				lpRect->bottom = lpRect->top + m_cyMin;
		}
		break;
		
	case WMSZ_BOTTOMLEFT:
		if ( cxWidth < m_cxMin )
			lpRect->left = lpRect->right - m_cxMin;
		if ( !m_fWindowExpandedOnce )
			lpRect->top = lpRect->bottom - m_cyMin;
		else
		{
			if ( cyHeight < m_cyMin )
				lpRect->bottom = lpRect->top + m_cyMin;
		}
		break;
		
	case WMSZ_BOTTOMRIGHT:
		if ( cxWidth < m_cxMin )
			lpRect->right = lpRect->left + m_cxMin;
		if ( !m_fWindowExpandedOnce )
			lpRect->bottom = lpRect->top + m_cyMin;
		else
		{
			if ( cyHeight < m_cyMin )
				lpRect->bottom = lpRect->top + m_cyMin;
		}
		break;
		
	case WMSZ_TOP:
		if ( !m_fWindowExpandedOnce )
			lpRect->top = lpRect->bottom - m_cyMin;
		else
		{
			if ( cyHeight < m_cyMin )
				lpRect->top = lpRect->bottom - m_cyMin;
		}
		break;
		
	case WMSZ_TOPLEFT:
		if ( cxWidth < m_cxMin )
			lpRect->left = lpRect->right - m_cxMin;
		if ( !m_fWindowExpandedOnce )
			lpRect->top = lpRect->bottom - m_cyMin;
		else
		{
			if ( cyHeight < m_cyMin )
				lpRect->top = lpRect->bottom - m_cyMin;
		}
		break;
		
	case WMSZ_TOPRIGHT:
		if ( cxWidth < m_cxMin )
			lpRect->right = lpRect->left + m_cxMin;
		if ( !m_fWindowExpandedOnce )
			lpRect->top = lpRect->bottom - m_cyMin;
		else
		{
			if ( cyHeight < m_cyMin )
				lpRect->top = lpRect->bottom - m_cyMin;
		}
		break;
		
	case WMSZ_RIGHT:
		if ( cxWidth < m_cxMin )
			lpRect->right = lpRect->left + m_cxMin;
		break;
		
	case WMSZ_LEFT:
		if ( cxWidth < m_cxMin )
			lpRect->left = lpRect->right - m_cxMin;
		break;
		
	default:
		break;
	}
	
	
	CHelpDialog::OnSizing (nSide, lpRect);

    _TRACE (-1, L"Leaving CFindDialog::OnSizing\n");
}


void CFindDialog::MoveControls ()
{
    _TRACE (1, L"Entering CFindDialog::MoveControls\n");

    if ( !m_hWnd || !m_bInitComplete )
        return;

    // Only come down here if the window has already been created.

	// Keep buttons glued to the right
	CRect	rcDlg;
	GetWindowRect (&rcDlg);	// returned in screen coords
	ScreenToClient (&rcDlg);	


	// Move "Stop" button
	CRect	rcCtrl;
	m_stopBtn.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	int	cxCtrl = rcCtrl.right - rcCtrl.left;
	rcCtrl.right = rcDlg.right - m_cxBtnMargin;
	rcCtrl.left = rcCtrl.right - cxCtrl;
	m_stopBtn.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Move "Find Now" button
	m_findNowBtn.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	cxCtrl = rcCtrl.right - rcCtrl.left;
	rcCtrl.right = rcDlg.right - m_cxBtnMargin;
	rcCtrl.left = rcCtrl.right - cxCtrl;
	m_findNowBtn.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Move "New Search" button
	m_newSearchBtn.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	cxCtrl = rcCtrl.right - rcCtrl.left;
	rcCtrl.right = rcDlg.right - m_cxBtnMargin;
	rcCtrl.left = rcCtrl.right - cxCtrl;
	m_newSearchBtn.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Move animation control
	m_animate.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	cxCtrl = rcCtrl.right - rcCtrl.left;
	rcCtrl.right = rcDlg.right - m_cxAnimMargin;
	rcCtrl.left = rcCtrl.right - cxCtrl;
	m_animate.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Stretch store list control
	m_storeList.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	rcCtrl.right = rcDlg.right - m_cxStoreListMargin;
	m_storeList.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Stretch "contains" edit control
	GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowRect (&rcCtrl);
	ScreenToClient (&rcCtrl);
	rcCtrl.right = rcDlg.right - m_cxContainMargin;
	GetDlgItem (IDC_CONTAINS_TEXT)->MoveWindow (rcCtrl);
	
	// Stretch field list control
	m_singleLock.Lock ();
	m_fieldList.GetWindowRect (&rcCtrl);	// returned in screen coords
	m_singleLock.Unlock ();
	ScreenToClient (&rcCtrl);
	rcCtrl.right = rcDlg.right - m_cxFieldListMargin;
	m_singleLock.Lock ();
	m_fieldList.MoveWindow (rcCtrl);	// child window coords relative to parent client
	m_singleLock.Unlock ();
	m_fieldList.InvalidateRect (NULL, TRUE);

	// Stretch list view to right edge and to bottom
	int	cyResultListMargin = 0;
	if ( m_statusBar.m_hWnd )
	{
		// If the status bar has already been created, we need to take that
		// account when we resize the list view
		CRect	rcStatusBar;
		m_statusBar.GetWindowRect (&rcStatusBar);
		cyResultListMargin = (rcStatusBar.bottom - rcStatusBar.top)
			+ ::GetSystemMetrics (SM_CYDLGFRAME);
	}

	m_resultsList.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	rcCtrl.right = rcDlg.right - m_cxResultListMargin;
	if ( m_fWindowExpandedOnce )
		rcCtrl.bottom = rcDlg.bottom - cyResultListMargin;
	m_resultsList.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Resize last column to fill results list window
	int nNewWidth = rcCtrl.right - (m_resultsList.GetColumnWidth (COL_ISSUED_TO) +
		m_resultsList.GetColumnWidth (COL_ISSUED_BY) +
		m_resultsList.GetColumnWidth (COL_EXPIRATION_DATE) +
		m_resultsList.GetColumnWidth (COL_PURPOSES) +
		m_resultsList.GetColumnWidth (COL_FRIENDLY_NAME));
	if ( nNewWidth > m_resultsList.GetColumnWidth (COL_SOURCE_STORE) )
		VERIFY (m_resultsList.SetColumnWidth (COL_SOURCE_STORE, nNewWidth));



	// Stretch status bar to right edge
	if ( m_statusBar.m_hWnd )
	{
		m_statusBar.GetWindowRect (&rcCtrl);	// returned in screen coords
		ScreenToClient (&rcCtrl);
		int	cyCtrl = rcCtrl.bottom - rcCtrl.top;
		rcCtrl.right = rcDlg.right;
		rcCtrl.bottom = rcDlg.bottom;
		rcCtrl.top = rcCtrl.bottom - cyCtrl;
		m_statusBar.MoveWindow (rcCtrl);	// child window coords relative to parent client
	}
    _TRACE (-1, L"Leaving CFindDialog::MoveControls\n");
}


typedef struct _ENUM_ARG {
    DWORD					dwFlags;
	CComboBox*				m_pComboBox;
	LPCWSTR					m_szMachineName;
	IConsole*				m_pConsole;
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumFindDlgSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    _TRACE (1, L"Entering EnumFindDlgSysCallback\n");
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;

	// Create new cookies
	SPECIAL_STORE_TYPE	storeType = GetSpecialStoreType ((LPWSTR) pwszSystemStore);

	//
	// We will not expose the ACRS store for machines or users.  It is not
	// interesting or useful at this level.  All Auto Cert Requests should
	// be managed only at the policy level.
	//
	if ( ACRS_STORE != storeType )
	{
		CCertStore* pNewCookie = new CCertStore (CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				dwFlags, pEnumArg->m_szMachineName,
				(LPCWSTR) pwszSystemStore,
				(LPCWSTR) pwszSystemStore,
				_T(""), storeType,
				dwFlags,
				pEnumArg->m_pConsole);
		if ( pNewCookie )
		{
			CString	storeName = _T("    ");
			int		iResult = 0;
			LPCWSTR localizedName = pNewCookie->GetLocalizedName ();

			if ( localizedName )
				storeName += localizedName;
			else
				storeName += (LPWSTR) pwszSystemStore;
			
			iResult = pEnumArg->m_pComboBox->AddString ((LPCWSTR) storeName);
			ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
			if ( CB_ERR != iResult && CB_ERRSPACE != iResult)
			{
				iResult = pEnumArg->m_pComboBox->SetItemDataPtr (iResult, (void*) pNewCookie);
				ASSERT (CB_ERR != iResult);
			}
			else
				pNewCookie->Release ();
		}
	}

    _TRACE (-1, L"Leaving EnumFindDlgSysCallback\n");
    return TRUE;
}


void CFindDialog::AddLogicalStoresToList ()
{
    _TRACE (1, L"Entering CFindDialog::AddLogicalStoresToList\n");
	CString		text;
	CWaitCursor	cursor;

	VERIFY (text.LoadString (IDS_ALL_STORES));
	VERIFY (m_storeList.AddString (text) >= 0);
	VERIFY (m_storeList.SetCurSel (0) != CB_ERR);

    DWORD		dwFlags = m_pCompData->GetLocation ();
    ENUM_ARG	EnumArg;

     ::ZeroMemory (&EnumArg, sizeof(EnumArg));
    EnumArg.dwFlags = dwFlags;
	EnumArg.m_szMachineName = m_szMachineName;
	EnumArg.m_pComboBox = &m_storeList;
	EnumArg.m_pConsole = m_pCompData->m_pConsole;
	CString	location;
	void*	pvPara = 0;

	
	if ( !m_pCompData->GetManagedService ().IsEmpty () )
	{
		if ( !m_szMachineName.IsEmpty () )
		{
			location = m_szMachineName + _T("\\") +
					m_pCompData->GetManagedService ();
			pvPara = (void *) (LPCWSTR) location;
		}
		else
			pvPara = (void *) (LPCWSTR) m_pCompData->GetManagedService ();
	}
	else if ( !m_szMachineName.IsEmpty () )
	{
		pvPara = (void *) (LPCWSTR) m_szMachineName;
	}

	if ( m_szFileName.IsEmpty () )
	{
		// This is not a file store but some kind of system store.
	    if ( !::CertEnumSystemStore (dwFlags, pvPara, &EnumArg, EnumFindDlgSysCallback) )
		{
			DWORD	dwErr = GetLastError ();
			CString	caption;

			VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			if ( ERROR_ACCESS_DENIED == dwErr )
			{
				VERIFY (text.LoadString (IDS_NO_PERMISSION));

			}
			else
			{
				text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
			}
            CThemeContextActivator activator;
			MessageBox (text, caption, MB_OK);
			if ( ERROR_BAD_NETPATH == dwErr )
			{
				// Close dialog
				PostMessage (WM_CLOSE, 0, 0L);
			}
		}
	}
	else
	{
		//	CertOpenStore with provider type of:
		//	CERT_STORE_PROV_FILE or CERT_STORE_PROV_FILENAME_A
		//	or CERT_STORE_PROV_FILENAME_W.
		//	See online documentation or wincrypt.h for more info.
		// Create new cookies
		CCertStore* pNewCookie = new CCertStore (
				CERTMGR_LOG_STORE,
				CERT_STORE_PROV_FILENAME_W,
				0,
				m_szMachineName,
				m_szFileName, m_szFileName, _T(""), NO_SPECIAL_TYPE,
				m_pCompData->GetLocation (),
				m_pCompData->m_pConsole);
		if ( pNewCookie )
		{
			CString	storeName = _T("    ");
			
			storeName += m_szFileName;

			int	iResult = m_storeList.AddString ((LPCWSTR) storeName);
			ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
			if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
			{
				iResult = m_storeList.SetItemDataPtr (iResult, (void*) pNewCookie);
				ASSERT (CB_ERR != iResult);
			}
		}
	}
    _TRACE (-1, L"Leaving CFindDialog::AddLogicalStoresToList\n");
}


void CFindDialog::OnDestroy()
{
    _TRACE (1, L"Entering CFindDialog::OnDestroy\n");
	// In case a search is running when the user destroys the window, stop it!
	StopSearch ();

	CHelpDialog::OnDestroy();
	
	
	CCertStore*	pCookie = 0;
	const	int	nCnt = m_storeList.GetCount ();

	for (int nIndex = 0; nIndex < nCnt; nIndex++)
	{
		pCookie = (CCertStore*) m_storeList.GetItemDataPtr (nIndex);
		if ( pCookie )	// one of the items has no cookie
			pCookie->Release ();
	}

	DeleteAllResultItems ();

    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
    _TRACE (-1, L"Leaving CFindDialog::OnDestroy\n");
}


void CFindDialog::AddFieldsToList()
{
    _TRACE (1, L"Entering CFindDialog::AddFieldsToList\n");
	CString	text;
	int		iResult = 0;


	VERIFY (text.LoadString (IDS_FIND_MD5_HASH));
	iResult = m_fieldList.AddString (text);
	ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
	if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
		VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_MD5_HASH) != CB_ERR);

	VERIFY (text.LoadString (IDS_FIND_SHA1_HASH));
	iResult = m_fieldList.AddString (text);
	ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
	if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
		VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_SHA1_HASH) != CB_ERR);

	VERIFY (text.LoadString (IDS_FIND_SUBJECT_NAME));
	iResult = m_fieldList.AddString (text);
	ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
	if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
		VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_SUBJECT_STR_W) != CB_ERR);

	VERIFY (text.LoadString (IDS_FIND_ISSUER_NAME));
	iResult = m_fieldList.AddString (text);
	ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
	if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
	{
		VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_ISSUER_STR_W) != CB_ERR);
		VERIFY (m_fieldList.SetCurSel (iResult) != CB_ERR);
	}

	VERIFY (text.LoadString (IDS_COLUMN_SERIAL_NUMBER));
	iResult = m_fieldList.AddString (text);
	ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
	if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
		VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_SERIAL_NUMBER) != CB_ERR);
    _TRACE (-1, L"Leaving CFindDialog::AddFieldsToList\n");
}

void CFindDialog::OnNewSearch()
{
    _TRACE (1, L"Entering CFindDialog::OnNewSearch\n");
	CString	caption;
	CString	text;

	VERIFY (text.LoadString (IDS_CLEAR_SEARCH));
	VERIFY (caption.LoadString (IDS_FIND_CERT));
    CThemeContextActivator activator;
	if ( MessageBox (text, caption, MB_ICONQUESTION | MB_OKCANCEL) == IDOK )
	{
		DeleteAllResultItems ();
		m_singleLock.Lock ();
		VERIFY (m_fieldList.SetCurSel (0) != CB_ERR);
		m_singleLock.Unlock ();

		VERIFY (text.LoadString (IDS_ALL_STORES));
		int nIndex = m_storeList.FindStringExact (-1, text);
		ASSERT (CB_ERR != nIndex);
		if ( CB_ERR != nIndex )
			VERIFY (m_storeList.SetCurSel (nIndex) != CB_ERR);
		GetDlgItem (IDC_CONTAINS_TEXT)->SetWindowText (L"");

		CString	statusText;
		VERIFY (statusText.LoadString (IDS_NO_CERTS_FOUND));
		if ( m_statusBar.m_hWnd )
			m_statusBar.SetWindowText (statusText);
		m_newSearchBtn.EnableWindow (FALSE);

        HMENU   hMenu = ::GetMenu (m_hWnd);
		ASSERT (hMenu);
		if ( hMenu )
		{
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_DELETE, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_EXPORT, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_PROPERTIES, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_VIEW, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_GRAYED) != -1);
			VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_GRAYED) != -1);
		}	

        GetDlgItem (IDC_CONTAINS_TEXT)->SetFocus ();
	}
    _TRACE (-1, L"Leaving CFindDialog::OnNewSearch\n");
}


void CFindDialog::OnStop()
{
    _TRACE (1, L"Entering CFindDialog::OnStop\n");
	StopSearch ();
    _TRACE (-1, L"Leaving CFindDialog::OnStop\n");
}


void CFindDialog::StopSearch()
{
    _TRACE (1, L"Entering CFindDialog::StopSearch\n");
	if ( m_bAnimationRunning )
	{
		VERIFY (m_animate.Stop ());
		m_bAnimationRunning = false;
	}
	VERIFY (m_animate.Seek (0));

	if ( m_hSearchThread && WaitForSingleObject (m_hSearchThread, 0) != WAIT_OBJECT_0 )  
	{
		VERIFY (SetEvent (m_hCancelSearchEvent));
		if ( WaitForSingleObject (m_hSearchThread, 5000) != WAIT_OBJECT_0 )
		{
			RestoreAfterSearchSettings ();
		}
	}
	
    _TRACE (-1, L"Leaving CFindDialog::StopSearch\n");
}


void CFindDialog::ExpandWindow()
{
    _TRACE (1, L"Entering CFindDialog::ExpandWindow\n");
	ASSERT (!m_fWindowExpandedOnce);
	if ( m_fWindowExpandedOnce )
		return;

	m_fWindowExpandedOnce = true;

	CRect	rcDlg;
	GetWindowRect (&rcDlg);
	VERIFY (SetWindowPos (&wndTop, rcDlg.left, rcDlg.top,
			rcDlg.right - rcDlg.left,
			m_cyOriginal,
			SWP_NOMOVE | SWP_NOOWNERZORDER));

	// Create the status bar
	CRect	rcStatusBar;
    CThemeContextActivator activator;
	VERIFY (m_statusBar.Create (WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP,
			rcStatusBar, this, 1));
	if ( m_statusBar.m_hWnd )
		m_statusBar.GetWindowRect (&rcStatusBar);
	int	cyResultListMargin = (rcStatusBar.bottom - rcStatusBar.top)
			+ ::GetSystemMetrics (SM_CYDLGFRAME);

	// Stretch list view to right edge and to bottom
	GetWindowRect (&rcDlg);
	ScreenToClient (&rcDlg);	
	CRect	rcCtrl;
	m_resultsList.GetWindowRect (&rcCtrl);	// returned in screen coords
	ScreenToClient (&rcCtrl);
	m_cxResultListMargin = (rcDlg.right - rcCtrl.right); //	+ ::GetSystemMetrics (SM_CXDLGFRAME);
	rcCtrl.right = rcDlg.right - m_cxResultListMargin;
	rcCtrl.bottom = rcDlg.bottom - cyResultListMargin;
	m_resultsList.MoveWindow (rcCtrl);	// child window coords relative to parent client

	// Permanently enable some menu items
	HMENU	hMenu = ::GetMenu (m_hWnd);
	ASSERT (hMenu);
	if ( hMenu)
	{
		VERIFY (::EnableMenuItem (hMenu, ID_VIEW_LARGEICONS, MF_ENABLED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_VIEW_SMALLICONS, MF_ENABLED) != -1);
		VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_LIST, MF_ENABLED) != -1);
		VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_DETAILS, MF_ENABLED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_ENABLED) != -1);
		VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_ENABLED) != -1);
	}
    _TRACE (-1, L"Leaving CFindDialog::ExpandWindow\n");
}



//DWORD WINAPI FindThreadFunc (LPVOID lpvThreadParm)
void __cdecl FindThreadFunc (LPVOID lpvThreadParm)
{
    _TRACE (1, L"Entering FindThreadFunc\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CFindDialog*	pFindDlg = (CFindDialog*) lpvThreadParm;
	ASSERT (pFindDlg);
	if ( !pFindDlg )
		return; // dwResult;

	pFindDlg->m_singleLock.Lock ();
	int		nCurSel = pFindDlg->m_fieldList.GetCurSel ();
	pFindDlg->m_singleLock.Unlock ();
	ASSERT (CB_ERR != nCurSel);
	if ( CB_ERR != nCurSel )
	{
		CString		statusText;
		pFindDlg->m_singleLock.Lock ();
		DWORD		dwFindType = (DWORD)pFindDlg->m_fieldList.GetItemData (nCurSel);
		pFindDlg->m_singleLock.Unlock ();
		CString		szFindText;


		statusText.LoadString (IDS_SEARCHING);
		if ( pFindDlg->m_statusBar.m_hWnd )
		{
			pFindDlg->m_statusBar.SetWindowText (statusText);
			pFindDlg->GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowText (szFindText);
		}

        // Bug 218084 - in BiDi, string may be prepended with Left-to-Right 
        // mark (0x200e).  See if this character is present.  If so, omit it 
        // from the search.  Check for multiple occurances.
        while ( chLEFT_TO_RIGHT == szFindText.GetAt (0) )
        {
            szFindText = ((PCWSTR) szFindText) + 1;
        }

		switch (dwFindType)
		{
		case CERT_FIND_SUBJECT_STR_W:
		case CERT_FIND_ISSUER_STR_W:
			pFindDlg->SearchForNames (szFindText, dwFindType);
			break;

		case CERT_FIND_MD5_HASH:
			pFindDlg->SearchForText (szFindText, CERT_MD5_HASH_PROP_ID);
			break;

		case CERT_FIND_SHA1_HASH:
			pFindDlg->SearchForText (szFindText, CERT_SHA1_HASH_PROP_ID);
			break;

		case CERT_FIND_SERIAL_NUMBER:
			pFindDlg->SearchForText (szFindText, CERT_FIND_SERIAL_NUMBER);
			break;

		default:
            {
                CThemeContextActivator activator;
			    AfxMessageBox (_T("Search type not implemented"), MB_OK);
            }
			break;
		}


		int		nCnt = pFindDlg->m_resultsList.GetItemCount ();
		ASSERT (-1 != nCnt);
		switch (nCnt)
		{
		case -1:
		case 0:
			VERIFY (statusText.LoadString (IDS_NO_CERTS_FOUND));
			break;

		case 1:
			VERIFY (statusText.LoadString (IDS_1_CERT_FOUND));
			break;

			break;

		default:
			statusText.FormatMessage (IDS_X_CERTS_FOUND, nCnt);
			break;
		}
		pFindDlg->m_statusBar.SetWindowText (statusText);
	}

	pFindDlg->RestoreAfterSearchSettings ();

    _TRACE (-1, L"Leaving FindThreadFunc\n");

    pFindDlg->m_hSearchThread = 0;
	_endthread ();
}

void CFindDialog::DoSearch()
{
    _TRACE (1, L"Entering CFindDialog::DoSearch\n");
	CWaitCursor waitCursor;

	// Because FindThreadFunc calls c-runtime functions, use _beginthread instead of CreateThread.
	// BoundsChecker warns that using CreateThread here results in small memory leaks
 
	VERIFY (ResetEvent (m_hCancelSearchEvent));
	m_hSearchThread = (HANDLE) _beginthread (FindThreadFunc, 0, reinterpret_cast <void*> (this));
	ASSERT (m_hSearchThread);
    _TRACE (-1, L"Leaving CFindDialog::DoSearch\n");
}


void CFindDialog::SearchForTextOnStore (DWORD dwPropId, CString &szFindText,
		CCertStore& rCertStore)
{
    _TRACE (0, L"Entering CFindDialog::SearchForTextOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
	// NOTE: szFindText is already in upper case
	CWaitCursor			cursor;
    PCCERT_CONTEXT		pCertContext = 0;
	CCertificate*		pCert = 0;
	CString				szCertText;
	int					nPos = 0;


	// Remove all spaces from szFindText
	RemoveSpaces (szFindText);

	//	Iterate through the list of certificates in the system store,
	//	allocate new certificates with the CERT_CONTEXT returned,
	//	and store them in the certificate list if they meet search criteria
	while ( WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0) )
	{
		pCertContext = rCertStore.EnumCertificates (pCertContext);
		if ( !pCertContext )
			break;
		pCert =
			new CCertificate (pCertContext, &rCertStore);
		if ( pCert )
		{
			switch (dwPropId)
			{
			case CERT_MD5_HASH_PROP_ID:
				szCertText = pCert->GetMD5Hash ();
				break;

			case CERT_SHA1_HASH_PROP_ID:
				szCertText = pCert->GetSHAHash ();
				break;

			case CERT_FIND_SERIAL_NUMBER:
				szCertText = pCert->GetSerialNumber ();
				RemoveSpaces (szCertText);
				break;

			default:
				ASSERT (0);
				return;
			}

			szCertText.MakeUpper ();
			nPos = szCertText.Find (szFindText);
			if ( -1 != nPos )
			{
				pCert->AddRef ();

				// Add cert to list control
				InsertItemInList (pCert);
			}
			pCert->Release ();
		}
	}
	rCertStore.Close ();
    _TRACE (-1, L"Leaving CFindDialog::SearchForTextOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
}


void CFindDialog::SearchForNameOnStore (DWORD dwFindFlags, DWORD dwFindType,
		void * pvPara, CCertStore& rCertStore)
{
    _TRACE (0, L"Entering CFindDialog::SearchForNameOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
	PCCERT_CONTEXT		pPrevCertContext = 0;
	PCCERT_CONTEXT		pCertContext = 0;
	CCertificate*		pCert = 0;
	DWORD				dwErr = 0;


	while ( WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0) )
	{
		pCertContext = rCertStore.FindCertificate (
					dwFindFlags,
					dwFindType,
					pvPara,
 					pPrevCertContext);
		if ( !pCertContext )
		{
			dwErr = GetLastError ();
			switch (dwErr)
			{
			case ERROR_SUCCESS:
				break;

			case CRYPT_E_NOT_FOUND:	// We're done.  No more certificates.
			case ERROR_FILE_NOT_FOUND:
				break;

			default:
                if ( !rCertStore.GetStoreHandle () )
                {
					CString	text;
					CString caption;

					text.FormatMessage 
                            (IDS_CANNOT_OPEN_CERT_STORE_TO_FIND_CERT_BY_PURPOSE,
                            rCertStore.GetLocalizedName ());
					VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
					MessageBox (text, caption, MB_ICONWARNING | MB_OK);
                    break;
                }
                else
				    DisplaySystemError ();
				break;
			}
			break;
		}
		pCert = new CCertificate (pCertContext, &rCertStore);
		if ( pCert )
			InsertItemInList (pCert); // Add cert to list control
		else
			break;

		pPrevCertContext = pCertContext;
	}
	rCertStore.Close ();
    _TRACE (-1, L"Leaving CFindDialog::SearchForNameOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
}


void CFindDialog::InsertItemInList(CCertificate * pCert)
{
    _TRACE (1, L"Entering CFindDialog::InsertItemInList\n");
	LV_ITEM	lvItem;
	int		iItem = m_resultsList.GetItemCount ();
	int iResult = 0;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_ISSUED_TO;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetSubjectName ();
	lvItem.iImage = 0;
    lvItem.lParam = (LPARAM) pCert;
	iItem = m_resultsList.InsertItem (&lvItem);
	ASSERT (-1 != iItem);
	if ( -1 == iItem )
		return;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_ISSUED_BY;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetIssuerName ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_EXPIRATION_DATE;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetValidNotAfter ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_PURPOSES;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetEnhancedKeyUsage ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_FRIENDLY_NAME;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetFriendlyName ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
    _TRACE (-1, L"Leaving CFindDialog::InsertItemInList\n");

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_SOURCE_STORE;
    if ( pCert->GetCertStore () )
	    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetCertStore ()->GetLocalizedName ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
    _TRACE (-1, L"Leaving CFindDialog::InsertItemInList\n");

}


void CFindDialog::RefreshItemInList (CCertificate * pCert, int nItem)
{
    _TRACE (1, L"Entering CFindDialog::RefreshItemInList\n");
	LV_ITEM	lvItem;
	int iResult = 0;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	lvItem.iItem = nItem;
    lvItem.iSubItem = COL_ISSUED_TO;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetSubjectName ();
	lvItem.iImage = 0;
    lvItem.lParam = (LPARAM) pCert;
	iResult = m_resultsList.SetItem (&lvItem); 
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
    lvItem.iSubItem = COL_ISSUED_BY;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetIssuerName ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
    lvItem.iSubItem = COL_EXPIRATION_DATE;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetValidNotAfter ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
    lvItem.iSubItem = COL_PURPOSES;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetEnhancedKeyUsage ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
    lvItem.iSubItem = COL_FRIENDLY_NAME;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetFriendlyName ();
	iResult = m_resultsList.SetItem (&lvItem);
	ASSERT (-1 != iResult);

	VERIFY (m_resultsList.Update (nItem));
    _TRACE (-1, L"Leaving CFindDialog::RefreshItemInList\n");
}


void CFindDialog::DeleteAllResultItems()
{
    _TRACE (1, L"Entering CFindDialog::DeleteAllResultItems\n");
	int	nCnt = m_resultsList.GetItemCount ();
	ASSERT (-1 != nCnt);
	CCertificate*	pCert = 0;

	for (int nIndex = 0; nIndex < nCnt; nIndex++)
	{
		pCert = (CCertificate*) m_resultsList.GetItemData (nIndex);
		ASSERT (pCert);
		if ( pCert )
			pCert->Release ();
	}

	VERIFY (m_resultsList.DeleteAllItems ());
    _TRACE (-1, L"Leaving CFindDialog::DeleteAllResultItems\n");
}

void CFindDialog::OnRclickResultList(NMHDR* pNMHDR, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnRclickResultList\n");

	m_hWndWhatsThis = 0;
	CMenu bar;
	if ( bar.LoadMenu(IDR_FIND_DLG_CONTEXT_MENU) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);
		CPoint	point;
		NM_LISTVIEW* pnmv = (NM_LISTVIEW FAR *) pNMHDR;
		bool	bIsMyStore = false;
		if ( -1 == pnmv->iItem )
			return;		// mouse not over valid item

		DWORD_PTR dwItemData = m_resultsList.GetItemData (pnmv->iItem);
		ASSERT (dwItemData);
		if ( dwItemData )
		{
			CCertificate* pCert = (CCertificate*) dwItemData;
			bIsMyStore = (pCert->GetStoreType () == MY_STORE);
		}

		int	nSelCnt = m_resultsList.GetSelectedCount ();
		switch (nSelCnt)
		{
		case 0:
			popup.EnableMenuItem (ID_VIEW, MF_GRAYED);
        	popup.EnableMenuItem (IDM_PROPERTIES, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_EXPORT, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_DELETE, MF_GRAYED);
			break;

		case 1:
			popup.EnableMenuItem (ID_VIEW, MF_ENABLED);
        	popup.EnableMenuItem (IDM_PROPERTIES, MF_ENABLED);
            if ( bIsMyStore && CERT_SYSTEM_STORE_SERVICES != m_pCompData->GetLocation () )
            {
        	    popup.EnableMenuItem (ID_ENROLL_NEW_KEY, MF_ENABLED);
        	    popup.EnableMenuItem (ID_ENROLL_SAME_KEY, MF_ENABLED);
        	    popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_ENABLED);
        	    popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_ENABLED);
            }
            else
            {
        	    popup.EnableMenuItem (ID_ENROLL_NEW_KEY, MF_GRAYED);
        	    popup.EnableMenuItem (ID_ENROLL_SAME_KEY, MF_GRAYED);
        	    popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_GRAYED);
        	    popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_GRAYED);
            }
        	popup.EnableMenuItem (ID_FILE_EXPORT, MF_ENABLED);
        	popup.EnableMenuItem (ID_FILE_DELETE, MF_ENABLED);
			break;

		default:
			popup.EnableMenuItem (ID_VIEW, MF_GRAYED);
        	popup.EnableMenuItem (IDM_PROPERTIES, MF_GRAYED);
        	popup.EnableMenuItem (ID_ENROLL_NEW_KEY, MF_GRAYED);
        	popup.EnableMenuItem (ID_ENROLL_SAME_KEY, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_GRAYED);
        	popup.EnableMenuItem (ID_FILE_EXPORT, MF_ENABLED);
        	popup.EnableMenuItem (ID_FILE_DELETE, MF_ENABLED);
			break;
		}
		GetCursorPos (&point);
		m_hWndWhatsThis = GetDlgItem (IDC_RESULT_LIST)->m_hWnd;
		popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			point.x, point.y,
			this); // route commands through main window
	}
	
	*pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnRclickResultList\n");
}


void CFindDialog::ChangeViewStyle (DWORD dwNewStyle)
{
    _TRACE (1, L"Entering CFindDialog::ChangeViewStyle\n");
	if ( m_resultsList.m_hWnd )
	{
	    DWORD dwStyle = ::GetWindowLong (m_resultsList.m_hWnd, GWL_STYLE);
		::SetWindowLong (m_resultsList.m_hWnd, GWL_STYLE,
			    (dwStyle & ~LVS_TYPEMASK) | dwNewStyle); 		
	}
    _TRACE (-1, L"Leaving CFindDialog::ChangeViewStyle\n");
}


void CFindDialog::OnDelete()
{
    _TRACE (1, L"Entering CFindDialog::OnDelete\n");
	if ( m_resultsList.m_hWnd )
	{
		int				nCnt = m_resultsList.GetItemCount ();
		ASSERT (nCnt >= 1);
		CCertificate*	pCert = 0;
		CString			text;
		CString			caption;
		int				nSelCnt = m_resultsList.GetSelectedCount ();
		ASSERT (nSelCnt >= 1);

		VERIFY (text.LoadString (1 == nSelCnt ? IDS_CONFIRM_DELETE : IDS_CONFIRM_DELETE_MULTIPLE));
		VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));

        CThemeContextActivator activator;
		if ( MessageBox (text, caption, MB_ICONWARNING | MB_YESNO) == IDYES )
		{
			UINT	flag = 0;
			while (--nCnt >= 0)
			{
				flag = ListView_GetItemState (m_resultsList.m_hWnd, nCnt, LVIS_SELECTED);
				if ( flag & LVNI_SELECTED )
				{
					pCert = (CCertificate*) m_resultsList.GetItemData (nCnt);
					ASSERT (pCert);
					if ( pCert )
					{
						if ( pCert->DeleteFromStore (true) )
						{
                            m_bConsoleRefreshRequired = true;
    						if ( m_resultsList.DeleteItem (nCnt) )
								pCert->Release ();
						}
						else
						{
							DWORD dwErr = GetLastError ();
							ASSERT (E_ACCESSDENIED == dwErr);
							if ( E_ACCESSDENIED == dwErr )
							{
								DisplaySystemError ();
							}
						}
					}
				}
			}
		}
		
		EnableMenuItems ();
	}
    _TRACE (-1, L"Leaving CFindDialog::OnDelete\n");
}

DWORD CFindDialog::DisplaySystemError()
{
	LPVOID lpMsgBuf;
	DWORD	dwErr = GetLastError ();
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPWSTR) &lpMsgBuf,    0,    NULL );
		
	// Display the string.
	CString	caption;
	VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
    CThemeContextActivator activator;
	MessageBox ((LPWSTR) lpMsgBuf, (LPCWSTR) caption, MB_OK);
	// Free the buffer.
	LocalFree (lpMsgBuf);

	return dwErr;
}


CCertificate* CFindDialog::GetSelectedCertificate (int * pnSelItem)
{
    _TRACE (1, L"Entering CFindDialog::GetSelectedCertificate\n");
	CCertificate*	pCert = 0;

	if ( m_resultsList.m_hWnd )
	{
		int nCnt = m_resultsList.GetItemCount ();
		int	nSelCnt = m_resultsList.GetSelectedCount ();
		ASSERT (1 == nSelCnt);


		if ( 1 == nSelCnt )
		{
			UINT	flag = 0;
			while (--nCnt >= 0)
			{
				flag = ListView_GetItemState (m_resultsList.m_hWnd, nCnt, LVIS_SELECTED);
				if ( flag & LVNI_SELECTED )
				{
					pCert = (CCertificate*) m_resultsList.GetItemData (nCnt);
					ASSERT (pCert);
					if ( pCert && pnSelItem )
						*pnSelItem = nCnt;
					break;
				}
			}
		}
	}

    _TRACE (-1, L"Leaving CFindDialog::GetSelectedCertificate\n");
	return pCert;
}

void CFindDialog::OnProperties()
{
    _TRACE (1, L"Entering CFindDialog::OnProperties\n");
	int				nSelItem = 0;
	CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
	ASSERT (pCert);
	if ( pCert )
	{
		HCERTSTORE*		pPropPageStores = new HCERTSTORE[1];
		if ( pPropPageStores && pCert->GetCertStore () )
		{
			pPropPageStores[0] = pCert->GetCertStore ()->GetStoreHandle ();


			CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT	sps;


			::ZeroMemory (&sps, sizeof (sps));
			sps.dwSize = sizeof (sps);
			sps.hwndParent = m_hWnd;
			sps.dwFlags = 0;
			sps.pCertContext = pCert->GetNewCertContext ();
			sps.cStores = 1;
			sps.rghStores = pPropPageStores;


			BOOL fPropertiesChanged = FALSE;
            CThemeContextActivator activator;
			BOOL bResult = ::CryptUIDlgViewCertificateProperties (&sps, &fPropertiesChanged);
			if ( bResult )
			{
				if ( fPropertiesChanged )
				{
                    m_bConsoleRefreshRequired = true;
                    if ( pCert->GetCertStore () )
                        pCert->GetCertStore ()->SetDirty ();
					pCert->Refresh ();
					RefreshItemInList (pCert, nSelItem);
				}
			}

            if ( pCert->GetCertStore () )
			    pCert->GetCertStore ()->Close ();
			delete [] pPropPageStores;
		}
	}
    _TRACE (-1, L"Leaving CFindDialog::OnProperties\n");
}

void CFindDialog::OnView()
{
    _TRACE (1, L"Entering CFindDialog::OnView\n");
	int				nSelItem = 0;
	CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
	ASSERT (pCert);
	if ( pCert )
	{
		LaunchCommonCertDialog (pCert, nSelItem);
	}
    _TRACE (-1, L"Leaving CFindDialog::OnView\n");
}

void CFindDialog::OnFileDelete()
{
    _TRACE (1, L"Entering CFindDialog::OnFileDelete\n");
	OnDelete ();
    _TRACE (-1, L"Leaving CFindDialog::OnFileDelete\n");
}

void CFindDialog::OnEnrollNewKey()
{
    _TRACE (1, L"Entering CFindDialog::OnEnrollNewKey\n");
	OnEnroll (true);
    _TRACE (-1, L"Leaving CFindDialog::OnEnrollNewKey\n");
}

void CFindDialog::OnEnrollSameKey()
{
    _TRACE (1, L"Entering CFindDialog::OnEnrollSameKey\n");
	OnEnroll (false);
    _TRACE (-1, L"Leaving CFindDialog::OnEnrollSameKey\n");
}

void CFindDialog::OnEnroll(bool bNewKey)
{
    _TRACE (1, L"Entering CFindDialog::OnEnroll\n");
	int				nSelItem = 0;
	CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
	ASSERT (pCert);
	if ( pCert )
	{
		CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT	pvkCert;
		CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW	pvkNew;
		CRYPTUI_WIZ_CERT_REQUEST_INFO		cri;
		CRYPT_KEY_PROV_INFO					ckpi;

		::ZeroMemory (&cri, sizeof (cri));
		cri.dwSize = sizeof (cri);
		cri.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

		// User wants to manage user account
		//	pass in NULL to machine name and to account name
		// User wants to manage local machine account
		//  pass in NULL for account name and result of ::GetComputerName ()
		//	to machine name
		// User want to manage remote machine
		//  pass in NULL for account name and machine name for machineName
		// User wants to manage remote account on remote machine
		//  pass in account name for accountName and machine name for machineName
		// TODO: Ensure that this is NULL if the local machine
		switch (m_pCompData->GetLocation ())
		{
		case CERT_SYSTEM_STORE_CURRENT_SERVICE:
		case CERT_SYSTEM_STORE_SERVICES:
			cri.pwszMachineName = (LPCWSTR) m_szMachineName;
			cri.pwszAccountName = (LPCWSTR) m_pCompData->GetManagedService ();
			break;

		case CERT_SYSTEM_STORE_CURRENT_USER:
			cri.pwszMachineName = NULL;
			cri.pwszAccountName = NULL;
			break;

		case CERT_SYSTEM_STORE_LOCAL_MACHINE:
			cri.pwszMachineName = (LPCWSTR) m_szMachineName;
			cri.pwszAccountName = NULL;
			break;

		default:
			ASSERT (0);
			return;
			break;
		}

		if ( bNewKey )
		{
			cri.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
			::ZeroMemory (&pvkNew, sizeof (pvkNew));
			pvkNew.dwSize = sizeof (pvkNew);
			cri.pPvkNew = &pvkNew;
			if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_pCompData->GetLocation () )
			{
				::ZeroMemory (&ckpi, sizeof (ckpi));
				ckpi.dwFlags = CRYPT_MACHINE_KEYSET;
				pvkNew.pKeyProvInfo = &ckpi;
			}
		}
		else
		{
            if ( IsLocalComputername (m_pCompData->m_szManagedComputer) )
            {
                DWORD   dwFlags = 0;

                if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_pCompData->m_dwLocationPersist )
                    dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
			    if ( !::CryptFindCertificateKeyProvInfo (
					    pCert->GetCertContext (), dwFlags, 0) )
			    {
				    CString	text;
				    CString caption;
                    CThemeContextActivator activator;

				    VERIFY (text.LoadString (IDS_NO_PRIVATE_KEY));
				    VERIFY (caption.LoadString (IDS_REQUEST_CERT_SAME_KEY));
				    MessageBox (text, caption, MB_OK);
				    return;
			    }
            }
			cri.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT;
			::ZeroMemory (&pvkCert, sizeof (pvkCert));
			pvkCert.dwSize = sizeof (pvkCert);
			pvkCert.pCertContext = pCert->GetCertContext ();
			cri.pPvkCert = &pvkCert;
		}
		CString	dnName;
		dnName.FormatMessage (L"CN=%1", m_szLoggedInUser);
		cri.pwszCertDNName = (LPWSTR) (LPCWSTR) dnName;

			
		DWORD			status = 0;
		PCCERT_CONTEXT	pNewCertContext = 0;
		BOOL			bResult = FALSE;
        CThemeContextActivator activator;
        while (1)
        {
            bResult = ::CryptUIWizCertRequest (
                bNewKey ? CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY : 0, 
				m_hWnd, 
				NULL,
				&cri, &pNewCertContext, &status);
            if ( !bResult && HRESULT_FROM_WIN32 (NTE_TOKEN_KEYSET_STORAGE_FULL) == GetLastError () )
            {
                // NTRAID# 299089 Enrollment Wizard: Should return some 
                // meaningful message when users fail to enroll/renew on a 
                // smart card
                if ( !bNewKey )
                    break;

                CString text;
                CString caption;

                VERIFY (text.LoadString (IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY));
			    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
			    if ( IDYES == MessageBox (text, caption, MB_YESNO) )
                {
                    bNewKey = false;
                }
                else
                    break;
            }
            else
                break;
        }

        if ( pNewCertContext )
            CertFreeCertificateContext (pNewCertContext);
    }

	ResetMenu ();
    _TRACE (-1, L"Leaving CFindDialog::OnEnroll\n");
}

void CFindDialog::OnFileExport()
{
    _TRACE (1, L"Entering CFindDialog::OnFileExport\n");
	UINT	nSelCnt = m_resultsList.GetSelectedCount ();
    if ( 1 == nSelCnt )
    {
	    int				nSelItem = 0;
	    CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
	    ASSERT (pCert);
	    if ( pCert )
	    {
		    CRYPTUI_WIZ_EXPORT_INFO	cwi;

		    ::ZeroMemory (&cwi, sizeof (cwi));
		    cwi.dwSize = sizeof (cwi);
		    cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
		    cwi.pCertContext = pCert->GetCertContext ();

            CThemeContextActivator activator;
		    ::CryptUIWizExport (
				    0,
				    m_hWnd,
				    0,
				    &cwi,
				    NULL);
	    }
    }
    else if ( nSelCnt > 1 )
    {
		HCERTSTORE	hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
				0, NULL, 0, NULL);
		ASSERT (hCertStore);
		if ( hCertStore )
		{
            CCertificate*   pCert = 0;
            int		        nCnt = m_resultsList.GetItemCount ();
	        UINT	        flag = 0;
            BOOL            bResult = FALSE;
	        while (--nCnt >= 0)
	        {
		        flag = ListView_GetItemState (m_resultsList.m_hWnd, nCnt, LVIS_SELECTED);
		        if ( flag & LVNI_SELECTED )
		        {
			        pCert = (CCertificate*) m_resultsList.GetItemData (nCnt);
			        ASSERT (pCert);
			        if ( pCert )
    				{
						bResult = ::CertAddCertificateContextToStore (
								hCertStore,
								::CertDuplicateCertificateContext (pCert->GetCertContext ()),
								CERT_STORE_ADD_NEW, 0);
						ASSERT (bResult);
						if ( !bResult )
							break;
					}
				}
			}

			// Call Export Wizard
			CRYPTUI_WIZ_EXPORT_INFO	cwi;
			::ZeroMemory (&cwi, sizeof (cwi));
			cwi.dwSize = sizeof (cwi);
			cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY;
			cwi.hCertStore = hCertStore;

            CThemeContextActivator activator;
			bResult = ::CryptUIWizExport (
					0,
					m_hWnd,
					0,
					&cwi,
					NULL);

			VERIFY (::CertCloseStore (hCertStore, CERT_CLOSE_STORE_CHECK_FLAG));
		}
		else
		{
			_TRACE (0, L"CertOpenStore (CERT_STORE_PROVIDER_MEMORY) failed: 0x%x\n", 
					GetLastError ());		
		}
    }
    _TRACE (-1, L"Leaving CFindDialog::OnFileExport\n");
}


void CFindDialog::OnFileRenewNewKey()
{
    _TRACE (1, L"Entering CFindDialog::OnFileRenewNewKey\n");
	OnFileRenew (true);
    _TRACE (-1, L"Leaving CFindDialog::OnFileRenewNewKey\n");
}

void CFindDialog::OnFileRenewSameKey()
{
    _TRACE (1, L"Entering CFindDialog::OnFileRenewSameKey\n");
	OnFileRenew (false);
    _TRACE (-1, L"Leaving CFindDialog::OnFileRenewSameKey\n");
}

void CFindDialog::OnFileRenew(bool bNewKey)
{
    _TRACE (1, L"Entering CFindDialog::OnFileRenew\n");
	int				nSelItem = 0;
	CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
	ASSERT (pCert);
	if ( pCert )
	{
        RenewCertificate (
                pCert, 
                bNewKey, 
                m_szMachineName, 
                m_pCompData->GetLocation (),
                m_pCompData->GetManagedComputer (), 
                m_pCompData->GetManagedService (), 
                m_hWnd, 
                0,
                0);
	}

	ResetMenu ();

    _TRACE (-1, L"Leaving CFindDialog::OnFileRenew\n");
}

void CFindDialog::OnEditInvertselection()
{
    _TRACE (1, L"Entering CFindDialog::OnEditInvertselection\n");
	if ( m_resultsList.m_hWnd )
	{
		int iItem = -1;
		while ((iItem = ListView_GetNextItem (m_resultsList.m_hWnd, iItem, 0)) != -1)
		{
			UINT flag;

			// flip the selection bit on each item
			flag = ListView_GetItemState (m_resultsList.m_hWnd, iItem, LVIS_SELECTED);
			flag ^= LVNI_SELECTED;
			ListView_SetItemState (m_resultsList.m_hWnd, iItem, flag, LVIS_SELECTED);
		}
	}
    _TRACE (-1, L"Leaving CFindDialog::OnEditInvertselection\n");
}

void CFindDialog::OnEditSelectall()
{
    _TRACE (1, L"Entering CFindDialog::OnEditSelectall\n");
	if ( m_resultsList.m_hWnd )
		ListView_SetItemState (m_resultsList.m_hWnd, -1, LVIS_SELECTED, LVIS_SELECTED);
    _TRACE (-1, L"Leaving CFindDialog::OnEditSelectall\n");
}


void CFindDialog::OnFileProperties()
{
    _TRACE (1, L"Entering CFindDialog::OnFileProperties\n");
	OnProperties ();
    _TRACE (-1, L"Leaving CFindDialog::OnFileProperties\n");
}

void CFindDialog::OnHelpHelptopics()
{
    _TRACE (1, L"Entering CFindDialog::OnHelpHelptopics\n");
	CComPtr<IDisplayHelp>	spDisplayHelp;

	HRESULT	hr = m_pCompData->m_pConsole->QueryInterface (
			IID_PPV_ARG (IDisplayHelp, &spDisplayHelp));
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        CString helpTopic;

        UINT nLen = ::GetSystemWindowsDirectory (helpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        helpTopic.ReleaseBuffer();
        if (0 == nLen)
        {
            ASSERT(FALSE);
            return;
        }

        helpTopic += L"\\help\\";
		helpTopic += CM_LINKED_HELP_FILE; //CM_HELP_FILE; //CM_LINKED_HELP_FILE;
        helpTopic += L"::/";
		helpTopic += CM_HELP_TOPIC;
		hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) helpTopic));
		ASSERT (SUCCEEDED (hr));
	}
	if ( !SUCCEEDED (hr) )
	{
		CString	caption;
		CString	text;
        CThemeContextActivator activator;

		VERIFY (caption.LoadString (IDS_FIND_CERT));
		text.FormatMessage (IDS_CERTMGR_CHM_NOT_FOUND, CM_HELP_FILE);
		MessageBox (text, caption, MB_OK);
	}
    _TRACE (-1, L"Leaving CFindDialog::OnHelpHelptopics\n");
}


void CFindDialog::OnViewDetails()
{
    _TRACE (1, L"Entering CFindDialog::OnViewDetails\n");
	ChangeViewStyle (LVS_REPORT);
    _TRACE (-1, L"Leaving CFindDialog::OnViewDetails\n");
}

void CFindDialog::OnViewLargeicons()
{
    _TRACE (1, L"Entering CFindDialog::OnViewLargeicons\n");
	ChangeViewStyle (LVS_ICON);
    _TRACE (-1, L"Leaving CFindDialog::OnViewLargeicons\n");
}


void CFindDialog::OnViewList()
{
    _TRACE (1, L"Entering CFindDialog::OnViewList\n");
	ChangeViewStyle (LVS_LIST);
    _TRACE (-1, L"Leaving CFindDialog::OnViewList\n");
}

void CFindDialog::OnViewSmallicons()
{
    _TRACE (1, L"Entering CFindDialog::OnViewSmallicons\n");
	ChangeViewStyle (LVS_SMALLICON);
    _TRACE (-1, L"Leaving CFindDialog::OnViewSmallicons\n");
}


HRESULT CFindDialog::SearchForNames(const CString & szFindText, DWORD dwFindType)
{
    _TRACE (0, L"Entering CFindDialog::SearchForNames - %s\n", (LPCWSTR) szFindText);
	HRESULT				hr = S_OK;
	void*				pvFindPara = (void*) (LPCWSTR) szFindText;
	int					nCurSel = m_storeList.GetCurSel ();
	CCertStore*			pStore = (CCertStore*) m_storeList.GetItemData (nCurSel);
	DWORD				dwFindFlags = 0;


	if ( pStore )
	{
		SearchForNameOnStore (dwFindFlags, dwFindType, pvFindPara,
					*pStore);
	}
	else
	{
		// if pStore is 0, then search on all stores in store list
		int	nCnt = m_storeList.GetCount ();
		ASSERT (CB_ERR != nCnt);
		for (int nIndex = 0; 
                nIndex < nCnt && WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0); 
                nIndex++)
		{
			pStore = (CCertStore*) m_storeList.GetItemData (nIndex);
			if ( pStore )
			{
				SearchForNameOnStore (dwFindFlags, dwFindType,
						pvFindPara, *pStore);
			}
		}
	}

    _TRACE (-1, L"Leaving CFindDialog::SearchForNames - %s\n", (LPCWSTR) szFindText);
	return hr;
}


HRESULT CFindDialog::SearchForText (CString & szFindText, DWORD dwPropId)
{
    _TRACE (0, L"Entering CFindDialog::SearchForText - %s\n", (LPCWSTR) szFindText);
	HRESULT		hr = S_OK;
	int			nCurSel = m_storeList.GetCurSel ();
	CCertStore*	pStore = (CCertStore*) m_storeList.GetItemData (nCurSel);


	szFindText.MakeUpper ();

	if ( pStore && pStore->GetStoreHandle () )
	{
		SearchForTextOnStore (dwPropId, szFindText, *pStore);
		pStore->Close ();
	}
	else
	{
		// if hCertStore is 0, then search on all stores in store list
		int	nCnt = m_storeList.GetCount ();
		ASSERT (CB_ERR != nCnt);
		for (int nIndex = 0; 
                nIndex < nCnt && WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0); 
                nIndex++)
		{
			pStore = (CCertStore*) m_storeList.GetItemData (nIndex);
			if ( pStore )
			{
				SearchForTextOnStore (dwPropId,
						szFindText, *pStore);
				pStore->Close ();
			}
		}
	}

    _TRACE (-1, L"Leaving CFindDialog::SearchForText - %s\n", (LPCWSTR) szFindText);
	return hr;
}

void CFindDialog::RemoveSpaces(CString & text)
{
    _TRACE (0, L"Entering CFindDialog::RemoveSpaces - %s\n", (LPCWSTR) text);
	text.TrimLeft ();
	text.TrimRight ();

	int		nLen = text.GetLength ();
	LPCWSTR	pszText = text.GetBuffer (nLen);
	int		nResultLen = nLen+2;
	LPWSTR	pszResult = new WCHAR[nResultLen];
	if ( pszResult )
	{
		while (--nResultLen >= 0)
			pszResult[nResultLen] = 0;

		nResultLen = 0;
		for (int nText = 0; nText < nLen; nText++)
		{
			if ( _T(" ")[0] != pszText[nText] )
				pszResult[nResultLen++] = pszText[nText];
		}
		text.ReleaseBuffer ();
		text = pszResult;
		delete [] pszResult;
	}
    _TRACE (-1, L"Leaving CFindDialog::RemoveSpaces - %s\n", (LPCWSTR) text);
}

void CFindDialog::OnDblclkResultList(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnDblclkResultList\n");
	OnOpen ();

	*pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnDblclkResultList\n");
}


int CALLBACK CFindDialog::CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CCertificate*	pCert1 = (CCertificate*) lParam1;
	CCertificate*	pCert2 = (CCertificate*) lParam2;
	int				compVal = 0;

	ASSERT (pCert1 && pCert2);
	if ( pCert1 && pCert2 )
	{
		switch (lParamSort)
		{
		case COL_ISSUED_TO:
			compVal = LocaleStrCmp (pCert1->GetSubjectName (), pCert2->GetSubjectName ());
			break;

		case COL_ISSUED_BY:
			compVal = LocaleStrCmp (pCert1->GetIssuerName (), pCert2->GetIssuerName ());
			break;

		case COL_EXPIRATION_DATE:
			compVal = pCert1->CompareExpireDate (*pCert2);
			break;

		case COL_PURPOSES:
			compVal = LocaleStrCmp (pCert1->GetEnhancedKeyUsage (), pCert2->GetEnhancedKeyUsage ());
			break;

		case COL_FRIENDLY_NAME:
			compVal = LocaleStrCmp (pCert1->GetFriendlyName (), pCert2->GetFriendlyName ());
			break;

        case COL_SOURCE_STORE:
            if ( pCert1->GetCertStore () && pCert2->GetCertStore () )
                compVal = LocaleStrCmp (pCert1->GetCertStore ()->GetLocalizedName (), 
                        pCert2->GetCertStore ()->GetLocalizedName ());
            break;

		default:
			ASSERT (0);
			break;
		}
	}

	return compVal;
}

void CFindDialog::OnColumnclickResultList(NMHDR* pNMHDR, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnColumnclickResultList\n");
	CWaitCursor	cursor;
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	BOOL bResult = m_resultsList.SortItems (CompareFunc, pNMListView->iSubItem);
	ASSERT (bResult);
	*pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnColumnclickResultList\n");
}

void CFindDialog::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CFindDialog::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_STORE_LIST,     IDH_FIND_STORE_LIST,
        IDC_CONTAINS_TEXT,  IDH_FIND_CONTAINS_TEXT,
        IDC_FIELD_LIST,     IDH_FIND_FIELD_LIST,
        IDC_FIND_NOW,       IDH_FIND_FIND_NOW,
        IDC_STOP,           IDH_FIND_STOP,
        IDC_NEW_SEARCH,     IDH_FIND_NEW_SEARCH,
        IDC_RESULT_LIST,    IDH_FIND_RESULT_LIST,
        0, 0
    };


    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_STORE_LIST:
    case IDC_CONTAINS_TEXT:
    case IDC_FIELD_LIST:
    case IDC_FIND_NOW:
    case IDC_STOP:
    case IDC_NEW_SEARCH:
    case IDC_RESULT_LIST:
        // Display context help for a control
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CFindDialog::DoContextHelp\n");
}

void CFindDialog::OnChangeContainsText()
{
    _TRACE (1, L"Entering CFindDialog::OnChangeContainsText\n");
	int nLen = GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowTextLength ();

    // If the text starts with the invisible Left-to-Right marker, don't count
    // it in the length
    UpdateData (TRUE);
    int nIndex = 0;
    while ( chLEFT_TO_RIGHT == m_szContains.GetAt (nIndex) )
    {
        nLen--;
        nIndex++;
    }
 
	m_findNowBtn.EnableWindow (nLen ? TRUE : FALSE);
    _TRACE (-1, L"Leaving CFindDialog::OnChangeContainsText\n");
}

void CFindDialog::RestoreAfterSearchSettings()
{
    _TRACE (1, L"Entering CFindDialog::RestoreAfterSearchSettings\n");
	if ( m_bAnimationRunning )
	{
		VERIFY (m_animate.Stop ());
		m_bAnimationRunning = false;
	}
	VERIFY (m_animate.Seek (0));

	// Reenable the controls
	m_stopBtn.EnableWindow (FALSE);
	m_findNowBtn.EnableWindow (TRUE);
	m_newSearchBtn.EnableWindow (TRUE);
	GetDlgItem (IDC_CONTAINS_TEXT)->EnableWindow (TRUE);
	m_resultsList.EnableWindow (TRUE);
	m_fieldList.EnableWindow (TRUE);
	m_storeList.EnableWindow (TRUE);
	
	m_resultsList.SetFocus ();
	EnableMenuItems ();

    // NTRAID# 281799 Cert UI: Cert Snapin:  Accessibility:  Focus indicator 
    // cannot be seen in certificate list in Find Certificates
    int nIndex = m_resultsList.GetTopIndex();
    m_resultsList.SetFocus ();
    m_resultsList.SetItemState (nIndex, LVIS_FOCUSED, LVIS_FOCUSED);

    _TRACE (-1, L"Leaving CFindDialog::RestoreAfterSearchSettings\n");
}

//
// Initialize the result list view
//
void CFindDialog::SetUpResultList()
{
    _TRACE (1, L"Entering CFindDialog::SetUpResultList\n");
	// Set up result list view
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_CERTIFICATE_LARGE, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_CERTIFICATE_SMALL, 16, 0, cr));
	m_resultsList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_resultsList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

	int	colWidths[NUM_COLS] = {100, 100, 100, 100, 100, 400};

	// Add "Issued To" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_ISSUED_TO));
	VERIFY (m_resultsList.InsertColumn (COL_ISSUED_TO, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_ISSUED_TO], COL_ISSUED_TO) != -1);

	// Add "Issued By" column
	VERIFY (szText.LoadString (IDS_ISSUED_BY));
	VERIFY (m_resultsList.InsertColumn (COL_ISSUED_BY, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_ISSUED_BY], COL_ISSUED_BY) != -1);

	// Add "Expiration Date" column
	VERIFY (szText.LoadString (IDS_COLUMN_EXPIRATION_DATE));
	VERIFY (m_resultsList.InsertColumn (COL_EXPIRATION_DATE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_EXPIRATION_DATE], COL_EXPIRATION_DATE) != -1);

	// Add "Purposes" column
	VERIFY (szText.LoadString (IDS_COLUMN_PURPOSE));
	VERIFY (m_resultsList.InsertColumn (COL_PURPOSES, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_PURPOSES], COL_PURPOSES) != -1);

	// Add "Friendly Name" column
  	VERIFY (szText.LoadString (IDS_COLUMN_FRIENDLY_NAME));
	VERIFY (m_resultsList.InsertColumn (COL_FRIENDLY_NAME, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_FRIENDLY_NAME], COL_FRIENDLY_NAME) != -1);

    // Add "Source Store" column
	VERIFY (szText.LoadString (IDS_COLUMN_SOURCE_STORE));
	VERIFY (m_resultsList.InsertColumn (COL_SOURCE_STORE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_SOURCE_STORE], COL_SOURCE_STORE) != -1);

    // Set to full-row select
    DWORD   dwExstyle = m_resultsList.GetExtendedStyle ();
    m_resultsList.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);

    _TRACE (-1, L"Leaving CFindDialog::SetUpResultList\n");
}

//
// Hide the portion of the dialog containing the result list.  This part
// becomes visible when a search is performed.
//
void CFindDialog::HideResultList()
{
    _TRACE (1, L"Entering CFindDialog::HideResultList\n");
	// Size window to hide list view until search is performed
	CRect	rcList;
	m_resultsList.GetWindowRect (&rcList);
	ScreenToClient (&rcList);
	CRect	rcDlg;
	GetWindowRect (&rcDlg);
	ScreenToClient (&rcDlg);

	int	cyCaption = ::GetSystemMetrics (SM_CYCAPTION);
	m_cyOriginal = (rcDlg.bottom - rcDlg.top) + cyCaption;
	m_cyMin = (rcList.top - rcDlg.top) + cyCaption - 16;
	m_cxMin = rcDlg.right - rcDlg.left;
	VERIFY (SetWindowPos (&wndTop, rcDlg.left, rcDlg.top,
			rcDlg.right - rcDlg.left,
			m_cyMin,
			SWP_NOMOVE | SWP_NOOWNERZORDER));

	//
	// Get information about the spatial relationship of the controls to the window.
	// We will need this later for expanding and resizing the dialog.
	// Get right margin to maintain distance of buttons to right side
	//
	CRect	rcCtrl;
	m_stopBtn.GetWindowRect (&rcCtrl);
	ScreenToClient (&rcCtrl);
	m_cxBtnMargin = rcDlg.right - rcCtrl.right;

	m_animate.GetWindowRect (&rcCtrl);
	ScreenToClient (&rcCtrl);
	m_cxAnimMargin = rcDlg.right - rcCtrl.right;

	m_storeList.GetWindowRect (&rcCtrl);
	ScreenToClient (&rcCtrl);
	m_cxStoreListMargin = rcDlg.right - rcCtrl.right;

	GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowRect (&rcCtrl);
	ScreenToClient (&rcCtrl);
	m_cxContainMargin = rcDlg.right - rcCtrl.right;
	
	m_fieldList.GetWindowRect (&rcCtrl);
	ScreenToClient (&rcCtrl);
	m_cxFieldListMargin = rcDlg.right - rcCtrl.right;
    _TRACE (-1, L"Leaving CFindDialog::HideResultList\n");
}


void CFindDialog::OnItemchangedResultList(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnItemchangedResultList\n");
	EnableMenuItems ();
	*pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnItemchangedResultList\n");
}

void CFindDialog::OnOpen()
{
    _TRACE (1, L"Entering CFindDialog::OnOpen\n");
	int				nSelItem = 0;
	CCertificate*	pCert = GetSelectedCertificate (&nSelItem);
	ASSERT (pCert);
	if ( pCert )
	{
		VERIFY (SUCCEEDED (LaunchCommonCertDialog (pCert, nSelItem)));
	}
    _TRACE (-1, L"Leaving CFindDialog::OnOpen\n");
}

HRESULT CFindDialog::LaunchCommonCertDialog (CCertificate* pCert, const int nItem)
{
    _TRACE (1, L"Entering CFindDialog::LaunchCommonCertDialog\n");
	ASSERT (pCert);
	if ( !pCert )
		return E_POINTER;

    HRESULT hr = S_OK;

	CTypedPtrList<CPtrList, CCertStore*>	storeList;

	//  Add the Root store first on a remote machine.
	if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
	{
		storeList.AddTail (new CCertStore (CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				(LPCWSTR) m_pCompData->GetManagedComputer (),
				ROOT_SYSTEM_STORE_NAME,
				ROOT_SYSTEM_STORE_NAME,
				_T (""), ROOT_STORE,
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				m_pCompData->m_pConsole));
	}
	CCertStore*	pStore = pCert->GetCertStore ();
    if ( pStore )
    {
	    pStore->AddRef ();
	    storeList.AddTail (pStore);

	    hr = m_pCompData->EnumerateLogicalStores (&storeList);
	    if ( SUCCEEDED (hr) )
	    {
            POSITION pos = 0;
            POSITION prevPos = 0;

            // Validate store handles
		    for (pos = storeList.GetHeadPosition ();
				    pos;)
		    {
                prevPos = pos;
			    pStore = storeList.GetNext (pos);
			    ASSERT (pStore);
			    if ( pStore )
			    {
                    // Do not open the userDS store
                    if ( USERDS_STORE == pStore->GetStoreType () )
                    {
                        storeList.RemoveAt (prevPos);
                        pStore->Release ();
                        pStore = 0;
                    }
                    else
                    {
				        if ( !pStore->GetStoreHandle () )
                        {
	                        CString	caption;
	                        CString	text;
                            CThemeContextActivator activator;

	                        text.FormatMessage (IDS_CANT_OPEN_STORE_AND_FAIL, pStore->GetLocalizedName ());
	                        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
                            hr = E_FAIL;
                            break;
                        }
                    }
			    }
		    }

            // Proceed only if all handles are valid 
            if ( SUCCEEDED (hr) )
            {
		        CRYPTUI_VIEWCERTIFICATE_STRUCT	vcs;
		        ::ZeroMemory (&vcs, sizeof (vcs));
		        vcs.dwSize = sizeof (vcs);
		        vcs.hwndParent = m_hWnd;

		        //  Set these flags only on a remote machine.
		        if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
			        vcs.dwFlags = CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
		        else
			        vcs.dwFlags = 0;
		        vcs.pCertContext = pCert->GetNewCertContext ();
		        vcs.cStores = (DWORD)storeList.GetCount ();
		        vcs.rghStores = new HCERTSTORE[vcs.cStores];
		        if ( vcs.rghStores )
		        {
			        DWORD			index = 0;

			        for (pos = storeList.GetHeadPosition ();
					        pos && index < vcs.cStores;
					        index++)
			        {
				        pStore = storeList.GetNext (pos);
				        ASSERT (pStore);
				        if ( pStore )
				        {
					        vcs.rghStores[index] = pStore->GetStoreHandle ();
				        }
			        }
			        BOOL fPropertiesChanged = FALSE;
                    CThemeContextActivator activator;
			        BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
			        if ( bResult )
			        {
				        if ( fPropertiesChanged )
				        {
                            m_bConsoleRefreshRequired = true;
                            if ( pCert->GetCertStore () )
					            pCert->GetCertStore ()->SetDirty ();
                            pCert->Refresh ();
					        RefreshItemInList (pCert, nItem);
				        }
			        }
			        delete vcs.rghStores;
		        }
		        else
			        hr = E_OUTOFMEMORY;
            }
        }

		// Release all the stores in the list.
		while (!storeList.IsEmpty () )
		{
			pStore = storeList.RemoveHead ();
			ASSERT (pStore);
			if ( pStore )
			{
				pStore->Close ();
				pStore->Release ();
			}
		}
	}

    _TRACE (-1, L"Leaving CFindDialog::LaunchCommonCertDialog\n");
	return hr;
}


void CFindDialog::ChangeToSizableFrame()
{
    _TRACE (1, L"Entering CFindDialog::ChangeToSizableFrame\n");
    LONG    lStyle = ::GetWindowLong (m_hWnd, GWL_STYLE);

    if ( lStyle )
    {
        lStyle &= ~DS_MODALFRAME;
        lStyle |= WS_THICKFRAME;
        if ( !::SetWindowLong (m_hWnd, GWL_STYLE, lStyle) )
        {
            _TRACE (0, L"SetWindowLong () failed: 0x%x\n", GetLastError ());
        }
    }
    else
    {
        _TRACE (0, L"GetWindowLong () failed: 0x%x\n", GetLastError ());
    }
    _TRACE (-1, L"Leaving CFindDialog::ChangeToSizableFrame\n");
}


void CFindDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint scrPoint) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CFindDialog::OnContextMenu\n");
	CMenu   bar;
    CPoint  clPoint;
    clPoint.x = scrPoint.x;
    clPoint.y = scrPoint.y;
    ScreenToClient (&clPoint);


    // Get the handle of the window under the point.
    CWnd* pChild = ChildWindowFromPoint (
            clPoint,  // in client coordinates
            CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
    if ( pChild && pChild->m_hWnd != GetDlgItem (IDC_RESULT_LIST)->m_hWnd )
    {
		m_hWndWhatsThis = 0;
        
        if ( GetDlgItem (IDC_STORE_LIST)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_FIND_NOW)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_STOP)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_NEW_SEARCH)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_RESULT_LIST)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_CONTAINS_TEXT)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_FIELD_LIST)->m_hWnd == pChild->m_hWnd )
        {
            m_hWndWhatsThis = pChild->m_hWnd;
        }

        
        if ( m_hWndWhatsThis )
        {
	        if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	        {
		        CMenu& popup = *bar.GetSubMenu (0);
		        ASSERT(popup.m_hMenu);

		        if ( !popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			            scrPoint.x,    // in screen coordinates
                        scrPoint.y,    // in screen coordinates
			            this) ) // route commands through main window
                {
                    m_hWndWhatsThis = 0;
                }
            }
            else
                m_hWndWhatsThis = 0;
        }
	}

    _TRACE (-1, L"Leaving CFindDialog::OnContextMenu\n");
}

bool CFindDialog::ConsoleRefreshRequired() const
{
    return m_bConsoleRefreshRequired;
}



void CFindDialog::ResetMenu()
{
	// Set up the menu
	if ( !::GetMenu (m_hWnd) )
	{
		HMENU	hMenu = ::LoadMenu (AfxGetInstanceHandle (),
					MAKEINTRESOURCE (IDR_FIND_DLG_MENU));
		ASSERT (hMenu);
		if ( hMenu )
		{
			if (::SetMenu (m_hWnd, hMenu) )
				EnableMenuItems ();
		}
	}
}


void CFindDialog::OnCancel() 
{
	if ( m_hSearchThread && WaitForSingleObject (m_hSearchThread, 0) != WAIT_OBJECT_0 )
    {
	    CString	caption;
	    CString	text;

	    VERIFY (text.LoadString (IDS_FIND_CLICK_STOP_BEFORE_CLOSING));
	    VERIFY (caption.LoadString (IDS_FIND_CERT));
        CThemeContextActivator activator;
	    MessageBox (text, caption, MB_OK);

        return;
    }

	CHelpDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\dynamlnk.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001
//
//  File:       DynamLnk.cpp
//
//  Contents:   base class for DLLs which are loaded only when needed
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "DynamLnk.h"

USE_HANDLE_MACROS("CERTMGR(DynamLnk.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DynamicDLL::DynamicDLL(LPCWSTR ptchLibraryName, LPCSTR* apchFunctionNames)
: m_hLibrary( (HMODULE)-1 ),
  m_apfFunctions( NULL ),
  m_ptchLibraryName( ptchLibraryName ),
  m_apchFunctionNames( apchFunctionNames ),
  m_nNumFunctions( 0 )
{
	ASSERT( !IsBadStringPtr(m_ptchLibraryName,MAX_PATH) );
	ASSERT (apchFunctionNames);
	for (LPCSTR pchFunctionName = *apchFunctionNames;
	     pchFunctionName;
		 pchFunctionName = *(++apchFunctionNames) )
	{
		m_nNumFunctions++;
		ASSERT( !IsBadStringPtrA(pchFunctionName,MAX_PATH) );
	}
}

DynamicDLL::~DynamicDLL()
{
	if ( m_apfFunctions )
	{
		delete m_apfFunctions;
		m_apfFunctions = NULL;
	}
	if ((HMODULE)-1 != m_hLibrary && NULL != m_hLibrary)
	{
		VERIFY( ::FreeLibrary( m_hLibrary ) );
		m_hLibrary = NULL;
	}
}

BOOL DynamicDLL::LoadFunctionPointers()
{
	if ((HMODULE)-1 != m_hLibrary)
		return (NULL != m_hLibrary);

	m_hLibrary = ::LoadLibrary( m_ptchLibraryName );
	if ( !m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}

	// let this throw an exception
	m_apfFunctions = new FARPROC[m_nNumFunctions];
	if ( m_apfFunctions )
	{
		for (INT i = 0; i < m_nNumFunctions; i++)
		{
			m_apfFunctions[i] = ::GetProcAddress( m_hLibrary, m_apchFunctionNames[i] );
			if ( NULL == m_apfFunctions[i] )
			{
				// The library is present but does not have all of the entrypoints
				VERIFY( ::FreeLibrary( m_hLibrary ) );
				m_hLibrary = NULL;
				return FALSE;
			}
		}
	}
	else
		return FALSE;

	return TRUE;
}


FARPROC DynamicDLL::QueryFunctionPtr(INT i) const
{
	if ( 0 > i || m_nNumFunctions <= i || !m_apfFunctions || !m_apfFunctions[i] )
	{
		ASSERT( FALSE );
		return NULL;
	}
	return m_apfFunctions[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\efsgeneralpropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       EFSGeneralPropertyPage.cpp
//
//  Contents:   Implementation of CEFSGeneralPropertyPage
//
//----------------------------------------------------------------------------
// EFSGeneralPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "EFSGeneralPropertyPage.h"
#include "compdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CEFSGeneralPropertyPage property page

CEFSGeneralPropertyPage::CEFSGeneralPropertyPage(CCertMgrComponentData* pCompData, bool bIsMachine) 
: CHelpPropertyPage(CEFSGeneralPropertyPage::IDD),
    m_bIsMachine (bIsMachine),
    m_hGroupPolicyKey (0),
    m_pGPEInformation (pCompData ? pCompData->GetGPEInformation () : 0),
    m_pCompData (pCompData),
    m_bDirty (false)
{
	//{{AFX_DATA_INIT(CEFSGeneralPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    if ( m_pCompData )
        m_pCompData->AddRef ();

    if ( m_pGPEInformation )
    {
        HRESULT hResult = m_pGPEInformation->GetRegistryKey (m_bIsMachine ?
                GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
    } 
}

CEFSGeneralPropertyPage::~CEFSGeneralPropertyPage()
{
    if ( m_pCompData )
        m_pCompData->Release ();
}

void CEFSGeneralPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEFSGeneralPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEFSGeneralPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CEFSGeneralPropertyPage)
	ON_BN_CLICKED(IDC_TURN_ON_EFS, OnTurnOnEfs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEFSGeneralPropertyPage message handlers

BOOL CEFSGeneralPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
    // The regkey to disable EFS is:
    // HKLM\Software\Policies\Microsoft\Windows NT\CurrentVersion\EFS\EfsConfiguration   DWORD 0x00000001 =>Disable EFS

    // If this is the RSOP, make it read-only
    if ( !m_pGPEInformation )
    {
        // Make the page read-only
        GetDlgItem (IDC_TURN_ON_EFS)->EnableWindow (FALSE);

        RSOPGetEFSFlags ();
    }
    else
    {
        GPEGetEFSFlags ();
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEFSGeneralPropertyPage::GPEGetEFSFlags()
{

    HKEY hKey = 0;
    LONG lResult = ::RegOpenKeyEx (m_hGroupPolicyKey,         // handle to open key
            EFS_SETTINGS_REGPATH,  // subkey name
            0,   // reserved
            KEY_READ, // security access mask
            &hKey);    // handle to open key
    if ( ERROR_SUCCESS == lResult )
    {
        // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
		        EFS_SETTINGS_REGVALUE,  // address of name of value to query
			    0,              // reserved
	            &dwType,        // address of buffer for value type
		        (LPBYTE) &dwData,       // address of data buffer
			    &cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            if ( 0 == dwData )  // 0 means enable EFS
                SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
		}
        else
            DisplaySystemError (NULL, lResult);

        ::RegCloseKey (hKey);
    }
    else    // no key means EFS enabled
        SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
}

void CEFSGeneralPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CEFSGeneralPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_TURN_ON_EFS,    IDH_TURN_ON_EFS,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CEFSGeneralPropertyPage::DoContextHelp\n");
}

void CEFSGeneralPropertyPage::RSOPGetEFSFlags()
{
    if ( m_pCompData )
    {
        const CRSOPObjectArray* pObjectArray = 
                m_bIsMachine ? m_pCompData->GetRSOPObjectArrayComputer () : 
                        m_pCompData->GetRSOPObjectArrayUser ();
        int     nIndex = 0;
        bool    bFound = false;
        // NOTE: rsop object array is sorted first by registry key, then by precedence
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // Consider only entries from this store
                if ( !_wcsicmp (EFS_SETTINGS_REGPATH, pObject->GetRegistryKey ()) &&
						!_wcsicmp (EFS_SETTINGS_REGVALUE, pObject->GetValueName ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    if ( 0 == pObject->GetDWORDValue () )  // 0 means enable EFS
                        SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
                    bFound = true;
                    break;
                }
            }
            else
                break;

            nIndex++;
        }

        if ( !bFound )  // not found means EFS enabled
            SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
    }
}

BOOL CEFSGeneralPropertyPage::OnApply() 
{
    if ( m_bDirty && m_pGPEInformation )
    {
        // Unchecked means disable EFS - set flag to 1
        if ( BST_UNCHECKED == SendDlgItemMessage (IDC_TURN_ON_EFS, BM_GETCHECK) )
        {
            // Create Key
            HKEY    hKey = 0;
            DWORD   dwDisposition = 0;
            LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
                    EFS_SETTINGS_REGPATH,     // address of subkey name
                    0,   // reserved
                    L"",       // address of class string
                    REG_OPTION_NON_VOLATILE,      // special options flag
                    KEY_ALL_ACCESS,    // desired security access
                    NULL,     // address of key security structure
			        &hKey,      // address of buffer for opened handle
		            &dwDisposition);  // address of disposition value buffer
	        ASSERT (lResult == ERROR_SUCCESS);
            if ( lResult == ERROR_SUCCESS )
            {
                DWORD   dwData = 0x01;   // 0 means disable EFS
                DWORD   cbData = sizeof (dwData);
                lResult = ::RegSetValueEx (hKey,
				            EFS_SETTINGS_REGVALUE, // address of value to set
				            0,              // reserved
				            REG_DWORD,          // flag for value type
				            (CONST BYTE *) &dwData, // address of value data
				            cbData);        // size of value data);
                ASSERT (ERROR_SUCCESS == lResult);
                if ( ERROR_SUCCESS == lResult )
	            {
			        // TRUE means we're changing the machine policy only
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidExtension, &g_guidSnapin);
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidRegExt, &g_guidSnapin);
		        }
		        else
                    DisplaySystemError (m_hWnd, lResult);

                ::RegCloseKey (hKey);
            }
        }
        else
        {
            // Delete Key
            HKEY hKey = 0;
            LONG lResult = ::RegOpenKeyEx (m_hGroupPolicyKey,         // handle to open key
                    EFS_SETTINGS_REGPATH,  // subkey name
                    0,   // reserved
                    KEY_ALL_ACCESS, // security access mask
                    &hKey);    // handle to open key
            if ( ERROR_SUCCESS == lResult )
            {
                lResult =  ::RegDeleteValue (hKey,       // handle of key to query
		                EFS_SETTINGS_REGVALUE);
                ASSERT (ERROR_SUCCESS == lResult);
                if ( ERROR_SUCCESS == lResult )
                {
			        // TRUE means we're changing the machine policy only
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidExtension, &g_guidSnapin);
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidRegExt, &g_guidSnapin);
                }
                else if ( ERROR_FILE_NOT_FOUND != lResult )
                {
                    CString text;
                    CString caption;

                    text.FormatMessage (IDS_CANNOT_SET_EFS_VALUE, lResult);
                    VERIFY (caption.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));

                    MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                    return FALSE;
                }

                ::RegCloseKey (hKey);
            }  
            else if ( ERROR_FILE_NOT_FOUND != lResult ) // expected error
            {
                CString text;
                CString caption;

                text.FormatMessage (IDS_CANNOT_SET_EFS_VALUE, lResult);
                VERIFY (caption.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));

                MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                return FALSE;
            }
        }
    }
	
	return CHelpPropertyPage::OnApply();
}

void CEFSGeneralPropertyPage::OnTurnOnEfs() 
{
	SetModified ();
    m_bDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\finddlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       FindDlg.h
//
//  Contents:   Base class for cert find dialog
//
//----------------------------------------------------------------------------\

#if !defined(AFX_FINDDLG_H__013A1C28_2930_11D1_B48F_00C04FB94F17__INCLUDED_)
#define AFX_FINDDLG_H__013A1C28_2930_11D1_B48F_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// FindDlg.h : header file
//
#include "certifct.h"

/////////////////////////////////////////////////////////////////////////////
// CFindDialog dialog

#define CERT_FIND_SERIAL_NUMBER		0x0000FFFE
class CCertMgrComponentData;	//forward declaration
class CFindDialog : public CHelpDialog
{
// Construction
public:
	CFindDialog (CWnd* pParent,
			const CString &pcszMachineName,
			const CString &szFileName,
			CCertMgrComponentData* pCompData); 

	virtual ~CFindDialog ();

// Dialog Data
	//{{AFX_DATA(CFindDialog)
	enum { IDD = IDD_FIND };
	CComboBox	m_storeList;
	CButton	m_stopBtn;
	CListCtrl	m_resultsList;
	CButton	m_newSearchBtn;
	CButton	m_findNowBtn;
	CComboBox	m_fieldList;
	CAnimateCtrl	m_animate;
	CString	m_szContains;
	CString	m_szSearchField;
	CString	m_szSelectedStore;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFindDialog)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static int CALLBACK CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
	void RemoveSpaces (CString & text);

public:
	HRESULT SearchForText (CString & szFindText, DWORD dwPropId);
	HRESULT SearchForNames (const CString& szFindText, DWORD dwFindType);


protected:
    void DoContextHelp (HWND hWndControl);
    void ChangeToSizableFrame ();
	HRESULT LaunchCommonCertDialog (CCertificate* pCert, const int nItem);
	void OnOpen();
	CCertificate* GetSelectedCertificate (OUT int * nSelectedItem = NULL);
	DWORD DisplaySystemError ();
	void OnDelete ();
	void ChangeViewStyle (DWORD dwStyle);
	void DeleteAllResultItems ();
	void RefreshItemInList(CCertificate * pCert, int nItem);
	void InsertItemInList (CCertificate* pCert);
	void SearchForTextOnStore (DWORD dwPropId, 
			CString &szFindName, CCertStore& rCertStore);
	void SearchForNameOnStore (DWORD dwFindFlags, DWORD dwFindType, 
			void* pvPara, CCertStore& rCertStore);
	void DoSearch ();
	void ExpandWindow ();
	void StopSearch ();
	void AddFieldsToList ();
	void AddLogicalStoresToList ();
	void MoveControls ();

	// Generated message map functions
	//{{AFX_MSG(CFindDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnFindNow();
	afx_msg void OnSizing( UINT nSide, LPRECT lpRect );
	afx_msg void OnDestroy();
	afx_msg void OnNewSearch();
	afx_msg void OnStop();
	afx_msg void OnRclickResultList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkResultList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickResultList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeContainsText();
	afx_msg void OnItemchangedResultList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	virtual void OnCancel();
	//}}AFX_MSG
	afx_msg void OnProperties();
	afx_msg void OnView();
	afx_msg void OnFileDelete();
	void OnEnroll(bool bNewKey);
	afx_msg void OnEnrollNewKey();
	afx_msg void OnEnrollSameKey();
	afx_msg void OnFileExport();
	void OnFileRenew(bool bNewKey);
	afx_msg void OnFileRenewNewKey();
	afx_msg void OnFileRenewSameKey();
	afx_msg void OnEditInvertselection();
	afx_msg void OnEditSelectall();
	afx_msg void OnFileProperties();
	afx_msg void OnHelpHelptopics();
	afx_msg void OnViewDetails();
	afx_msg void OnViewLargeicons();
	afx_msg void OnViewList();
	afx_msg void OnViewSmallicons();
	DECLARE_MESSAGE_MAP()

	enum {
		COL_ISSUED_TO = 0,
		COL_ISSUED_BY,
		COL_EXPIRATION_DATE,
		COL_PURPOSES,
		COL_FRIENDLY_NAME,
        COL_SOURCE_STORE,
		NUM_COLS	// must be last
	};
private:
	void EnableMenuItems ();
	void HideResultList();
	void SetUpResultList();

	HANDLE			m_hCancelSearchEvent;
	bool			m_bConsoleRefreshRequired;
	CCertMgrComponentData* m_pCompData;
	CString			m_szLoggedInUser;
	const CString	m_szManagedService;
	const CString	m_szFileName;
	bool			m_bAnimationRunning;
	CString			m_szMachineName;
	int				m_cyMin;
	int				m_cxMin;
	bool			m_fWindowExpandedOnce;
	int				m_cyOriginal;
	int				m_cxBtnMargin;
	int				m_cxAnimMargin;
	int				m_cxStoreListMargin;
	int				m_cxContainMargin;
	int				m_cxTabMargin;
	int				m_cxFieldListMargin;
	int				m_cxResultListMargin;
    WTL::CImageList	m_imageListSmall;
    WTL::CImageList	m_imageListNormal;
    bool            m_bInitComplete;

public:
	void ResetMenu();
	
	bool ConsoleRefreshRequired () const;
	void RestoreAfterSearchSettings();
	CCriticalSection	m_critSec;
	CSingleLock			m_singleLock;
	CStatusBarCtrl		m_statusBar;
	HANDLE			    m_hSearchThread;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FINDDLG_H__013A1C28_2930_11D1_B48F_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\gpepage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       GPEPage.cpp
//
//  Contents:   Implementation of CGPERootGeneralPage
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "GPEPage.h"
#include "storegpe.h"
#include "CompData.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidSnapin;
extern GUID g_guidRegExt;


/////////////////////////////////////////////////////////////////////////////
// CGPERootGeneralPage property page


CGPERootGeneralPage::CGPERootGeneralPage(CCertMgrComponentData* pCompData,
        bool fIsComputerType) :
    CHelpPropertyPage(CGPERootGeneralPage::IDD),
    m_dwGPERootFlags (0),
    m_hUserRootFlagsKey (0),
    m_hGroupPolicyKey (0),
    m_pGPEInformation (pCompData->GetGPEInformation ()),
    m_fIsComputerType (fIsComputerType)
{
    //{{AFX_DATA_INIT(CGPERootGeneralPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();

        HRESULT hResult = m_pGPEInformation->GetRegistryKey (GPO_SECTION_MACHINE,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
        if ( SUCCEEDED (hResult) )
		    GPEGetUserRootFlags ();
    } 
    else 
        RSOPGetUserRootFlags (pCompData);
}

CGPERootGeneralPage::~CGPERootGeneralPage()
{
    if ( m_hUserRootFlagsKey )
        VERIFY (ERROR_SUCCESS == ::RegCloseKey (m_hUserRootFlagsKey));
    if ( m_hGroupPolicyKey )
        VERIFY (::RegCloseKey (m_hGroupPolicyKey) == ERROR_SUCCESS);
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}

void CGPERootGeneralPage::DoDataExchange(CDataExchange* pDX)
{
    CHelpPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGPERootGeneralPage)
    DDX_Control(pDX, IDC_ENABLE_USER_ROOT_STORE, m_enableUserRootStoreBtn);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGPERootGeneralPage, CHelpPropertyPage)
    //{{AFX_MSG_MAP(CGPERootGeneralPage)
    ON_BN_CLICKED(IDC_ENABLE_USER_ROOT_STORE, OnEnableUserRootStore)
    ON_BN_CLICKED(IDC_SET_DISABLE_LM_AUTH_FLAG, OnSetDisableLmAuthFlag)
	ON_BN_CLICKED(IDC_UNSET_DISABLE_LM_AUTH_FLAG, OnUnsetDisableLmAuthFlag)
	ON_BN_CLICKED(IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG, OnUnsetDisableNtAuthRequiredFlag)
	ON_BN_CLICKED(IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG, OnSetDisableNtAuthRequiredFlag)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPERootGeneralPage message handlers


BOOL CGPERootGeneralPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog();

    // If this is the RSOP, make it read-only
    if ( !m_pGPEInformation )
    {
        // Make the page read-only
        m_enableUserRootStoreBtn.EnableWindow (FALSE);
        GetDlgItem (IDC_SET_DISABLE_LM_AUTH_FLAG)->EnableWindow (FALSE);
        GetDlgItem (IDC_UNSET_DISABLE_LM_AUTH_FLAG)->EnableWindow (FALSE);
        GetDlgItem (IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG)->EnableWindow (FALSE);
        GetDlgItem (IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG)->EnableWindow (FALSE);
    }

    if ( IsCurrentUserRootEnabled () )
		m_enableUserRootStoreBtn.SetCheck (BST_CHECKED);

    if ( m_dwGPERootFlags & CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG )
        SendDlgItemMessage (IDC_SET_DISABLE_LM_AUTH_FLAG, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_UNSET_DISABLE_LM_AUTH_FLAG, BM_SETCHECK, BST_CHECKED);
 
    if ( m_dwGPERootFlags & CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG )
        SendDlgItemMessage (IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_SETCHECK, BST_CHECKED);
 
 
	return TRUE;  // return TRUE unless you set the focus to a control
      // EXCEPTION: OCX Property Pages should return FALSE
}

void CGPERootGeneralPage::OnOK()
{
    if ( m_pGPEInformation )
    {
	    SaveCheck ();
	    CHelpPropertyPage::OnOK ();
    }
}

void CGPERootGeneralPage::SaveCheck()
{
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        bool    bRetVal = false;

        if ( m_enableUserRootStoreBtn.GetCheck () == BST_CHECKED )
            bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG, TRUE); // remove flag
        else
            bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG, FALSE); // set flag

        if ( bRetVal )
        {
            if ( BST_CHECKED == SendDlgItemMessage (IDC_SET_DISABLE_LM_AUTH_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG, FALSE);	// set flag
            else if ( BST_CHECKED == SendDlgItemMessage (IDC_UNSET_DISABLE_LM_AUTH_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG, TRUE);	// remove flag
        }
        
        if ( bRetVal )
        {
            if ( BST_CHECKED == SendDlgItemMessage (IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG, FALSE);	// set flag
            else if ( BST_CHECKED == SendDlgItemMessage (IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG, TRUE);	// remove flag
        }

        if ( bRetVal )
        {
			// TRUE means we're changing the machine policy only
            m_pGPEInformation->PolicyChanged (TRUE, TRUE, &g_guidExtension, &g_guidSnapin);
            m_pGPEInformation->PolicyChanged (TRUE, TRUE, &g_guidRegExt, &g_guidSnapin);
        }
    }
}

void CGPERootGeneralPage::OnEnableUserRootStore()
{
    SetModified (TRUE);
}


void CGPERootGeneralPage::OnSetDisableLmAuthFlag()
{
    SetModified (TRUE);
}

bool CGPERootGeneralPage::SetGPEFlags (DWORD dwFlags, BOOL bRemoveFlag)
{
    bool    bRetVal = false;

    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        LONG    lResult =  ::RegQueryValueEx (m_hUserRootFlagsKey,       // handle of key to query
		            CERT_PROT_ROOT_FLAGS_VALUE_NAME,  // address of name of value to query
			        0,              // reserved
				    &dwType,        // address of buffer for value type
				    (LPBYTE) &dwData,       // address of data buffer
				    &cbData);           // address of data buffer size);
	    ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
        {
            if ( bRemoveFlag )
                dwData &= ~dwFlags;
            else
                dwData |= dwFlags;

            lResult = ::RegSetValueEx (m_hUserRootFlagsKey,
				    CERT_PROT_ROOT_FLAGS_VALUE_NAME, // address of value to set
				    0,              // reserved
				    REG_DWORD,          // flag for value type
				    (CONST BYTE *) &dwData, // address of value data
				    cbData);        // size of value data);
            ASSERT (ERROR_SUCCESS == lResult);
            if ( ERROR_SUCCESS == lResult )
		    {
                m_dwGPERootFlags = dwData;
                bRetVal = true;
		    }
		    else
                DisplaySystemError (m_hWnd, lResult);
        }
        else
            DisplaySystemError (m_hWnd, lResult);
    }

    return bRetVal;
}

bool CGPERootGeneralPage::IsCurrentUserRootEnabled() const
{
    if (m_dwGPERootFlags & CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG)
        return false;
    else
        return true;
}

void CGPERootGeneralPage::RSOPGetUserRootFlags(const CCertMgrComponentData* pCompData)
{
    if ( pCompData )
    {
        const CRSOPObjectArray* pObjectArray = m_fIsComputerType ?
                pCompData->GetRSOPObjectArrayComputer () : 
                pCompData->GetRSOPObjectArrayUser ();
        int     nIndex = 0;

        // NOTE: rsop object array is sorted first by registry key, then by precedence
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // Consider only entries from this store
                if ( !wcscmp (CERT_PROT_ROOT_FLAGS_REGPATH, pObject->GetRegistryKey ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    m_dwGPERootFlags = pObject->GetDWORDValue ();
                    break;
                }
            }
            else
                break;

            nIndex++;
        }
    }
}

void CGPERootGeneralPage::GPEGetUserRootFlags()
{
    DWORD   dwDisposition = 0;

    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            CERT_PROT_ROOT_FLAGS_REGPATH,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&m_hUserRootFlagsKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (lResult == ERROR_SUCCESS);
    if ( lResult == ERROR_SUCCESS )
    {
    // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        lResult =  ::RegQueryValueEx (m_hUserRootFlagsKey,       // handle of key to query
		        CERT_PROT_ROOT_FLAGS_VALUE_NAME,  // address of name of value to query
			    0,              // reserved
	        &dwType,        // address of buffer for value type
		    (LPBYTE) &dwData,       // address of data buffer
			&cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            m_dwGPERootFlags = dwData;
		}
        else
            DisplaySystemError (NULL, lResult);
    }
    else
        DisplaySystemError (NULL, lResult);
}


void CGPERootGeneralPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CGPERootGeneralPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_ENABLE_USER_ROOT_STORE,                 IDH_GPEPAGE_ENABLE_USER_ROOT_STORE,
        IDC_SET_DISABLE_LM_AUTH_FLAG,               IDH_SET_DISABLE_LM_AUTH_FLAG,
        IDC_UNSET_DISABLE_LM_AUTH_FLAG,             IDH_UNSET_DISABLE_LM_AUTH_FLAG,
        IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG,      IDH_SET_DISABLE_NT_AUTH_REQUIRED_FLAG,
        IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG,    IDH_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CGPERootGeneralPage::DoContextHelp\n");
}


void CGPERootGeneralPage::OnUnsetDisableLmAuthFlag() 
{
	SetModified (TRUE);
}

void CGPERootGeneralPage::OnUnsetDisableNtAuthRequiredFlag() 
{
	SetModified (TRUE);
}

void CGPERootGeneralPage::OnSetDisableNtAuthRequiredFlag() 
{
	SetModified (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\gpepage.h ===
#if !defined(AFX_GPEPAGE_H__61B8B05B_7B0C_11D1_85DF_00C04FB94F17__INCLUDED_)
#define AFX_GPEPAGE_H__61B8B05B_7B0C_11D1_85DF_00C04FB94F17__INCLUDED_
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       gpepage.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// GPEPage.h : header file
//

class CCertMgrComponentData; // forward declaration

/////////////////////////////////////////////////////////////////////////////
// CGPERootGeneralPage dialog
class CCertStoreGPE;	// forward declaration

class CGPERootGeneralPage : public CHelpPropertyPage
{
// Construction
public:
	CGPERootGeneralPage(CCertMgrComponentData* pCompData, bool fIsComputerType);
	virtual ~CGPERootGeneralPage();

// Dialog Data
	//{{AFX_DATA(CGPERootGeneralPage)
	enum { IDD = IDD_GPE_GENERAL };
	CButton	m_enableUserRootStoreBtn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGPERootGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual void OnOK();

// Implementation
protected:
    virtual void DoContextHelp (HWND hWndControl);
    bool SetGPEFlags (DWORD dwFlags, BOOL bRemoveFlag);
	bool IsCurrentUserRootEnabled () const;
	void GPEGetUserRootFlags ();
    void RSOPGetUserRootFlags (const CCertMgrComponentData* pCompData);

	void SaveCheck();
	// Generated message map functions
	//{{AFX_MSG(CGPERootGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnableUserRootStore();
	afx_msg void OnSetDisableLmAuthFlag();
	afx_msg void OnUnsetDisableLmAuthFlag();
	afx_msg void OnUnsetDisableNtAuthRequiredFlag();
	afx_msg void OnSetDisableNtAuthRequiredFlag();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HKEY				    m_hUserRootFlagsKey;
	DWORD				    m_dwGPERootFlags;
	IGPEInformation*	    m_pGPEInformation;
	HKEY				    m_hGroupPolicyKey;
    bool                    m_fIsComputerType;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GPEPAGE_H__61B8B05B_7B0C_11D1_85DF_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\helpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       helpids.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------

// IDD_FIND
#define	IDH_FIND_STORE_LIST			            100000001
#define	IDH_FIND_CONTAINS_TEXT		            100000003
#define	IDH_FIND_FIELD_LIST			            100000004
#define	IDH_FIND_FIND_NOW			            100000005
#define	IDH_FIND_STOP				            100000006
#define	IDH_FIND_NEW_SEARCH			            100000007
#define	IDH_FIND_RESULT_LIST		            100000008

// IDD_PASSWORD
#define IDH_PASSWORD_PASSWORD1                  100000009
#define IDH_PASSWORD_PASSWORD2                  100000010

// IDD_VIEW_OPTIONS
#define IDH_OPTIONS_VIEW_BY_PURPOSE             100000011
#define IDH_OPTIONS_VIEW_BY_STORE               100000012
#define IDH_OPTIONS_SHOW_PHYSICAL               100000013
#define IDH_OPTIONS_SHOW_ARCHIVED               100000014

// IDD_AUTO_CERT_REQUEST_GENERAL
#define IDH_ACRPAGE_CERT_TYPE                   100000017
#define IDH_ACRPAGE_CERT_PURPOSES               100000018
#define IDH_ACRPAGE_CA_LIST                     100000019

// IDD_POLICY_PRECEDENCE
#define IDH_POLICY_PRECEDENCE                   100000020

// IDD_PROPPAGE_AUTOENROLL
#define IDH_AUTOENROLL_DISABLE_ALL              100000021
#define IDH_AUTOENROLL_ENABLE                   100000022
#define IDH_AUTOENROLL_ENABLE_PENDING           100000023
#define IDH_AUTOENROLL_ENABLE_TEMPLATE          100000024

// IDD_SAFER_LEVEL_GENERAL
#define IDH_SAFER_LEVEL_NAME                    100000030
#define IDH_SAFER_LEVEL_DESCRIPTION             100000031
#define IDH_SAFER_LEVEL_SET_AS_DEFAULT          100000032
#define IDH_SAFER_LEVEL_STATUS                  100000033

// IDD_SAFER_TRUSTED_PUBLISHER
#define IDH_TP_BY_END_USER                      100000040
#define IDH_TP_BY_LOCAL_COMPUTER_ADMIN          100000041
#define IDH_TP_BY_ENTERPRISE_ADMIN              100000042
#define IDH_TP_REV_CHECK_PUBLISHER              100000043
#define IDH_TP_REV_CHECK_TIMESTAMP              100000044

// IDD_SAFER_DEFINED_FILE_TYPES
#define IDH_DEFINED_FILE_TYPES                  100000050
#define IDH_DELETE_DEFINED_FILE_TYPE            100000051
#define IDH_DEFINED_FILE_TYPE_EDIT              100000052
#define IDH_ADD_DEFINED_FILE_TYPE               100000053

// IDD_SAFER_ENTRY_CERTIFICATE
#define IDH_CERT_ENTRY_SUBJECT_NAME             100000060
#define IDH_CERT_ENTRY_BROWSE                   100000061
#define IDH_CERT_ENTRY_SECURITY_LEVEL           100000062
#define IDH_CERT_ENTRY_DESCRIPTION              100000066
#define IDH_CERT_ENTRY_LAST_MODIFIED            100000067

// IDD_SAFER_ENTRY_PATH
#define IDH_PATH_ENTRY_PATH                     100000070
#define IDH_PATH_ENTRY_SECURITY_LEVEL           100000072
#define IDH_PATH_ENTRY_DESCRIPTION              100000076
#define IDH_PATH_ENTRY_LAST_MODIFIED            100000077
#define IDH_PATH_ENTRY_BROWSE_FOLDER            100000078

// IDD_SAFER_ENTRY_HASH
#define IDH_HASH_ENTRY_APPLICATION_NAME         100000080
#define IDH_HASH_ENTRY_BROWSE                   100000081
#define IDH_HASH_ENTRY_SECURITY_LEVEL           100000082
#define IDH_HASH_ENTRY_DESCRIPTION              100000084
#define IDH_HASH_ENTRY_LAST_MODIFIED            100000085
#define IDH_HASH_HASHED_FILE_PATH               100000086

// IDD_SAFER_ENTRY_INTERNET_ZONE
#define IDH_IZONE_ENTRY_ZONES                   100000090
#define IDH_IZONE_ENTRY_SECURITY_LEVEL          100000091
#define IDH_IZONE_ENTRY_DESCRIPTION             100000095
#define IDH_IZONE_ENTRY_LAST_MODIFIED           100000096

// IDD_GPE_GENERAL
#define IDH_GPEPAGE_ENABLE_USER_ROOT_STORE      100000015
#define IDH_SET_DISABLE_LM_AUTH_FLAG            100000100
#define IDH_UNSET_DISABLE_LM_AUTH_FLAG          100000101
#define IDH_SET_DISABLE_NT_AUTH_REQUIRED_FLAG   100000102
#define IDH_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG 100000103

// IDD_SAFER_ENFORCEMENT
#define IDH_ALL_EXCEPT_LIBS                     100000110
#define IDH_ALL_SOFTWARE_FILES                  100000111
#define IDH_APPLY_TO_ALL_USERS                  100000112
#define IDH_APPLY_EXCEPT_ADMINS                 100000113

// IDD_EFS_GENERAL
#define IDH_TURN_ON_EFS                         100000120
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\makefile.inc ===
!include ..\..\makefile.inc

$(O)\CERTMGR.res: resource.h certmgr.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\locate.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       locate.cpp
//
//  Contents:   Implementation of Add EFS Agent Wizard Location Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "AddSheet.h"
#include "Locate.h"
#pragma warning(push, 3)
#include <initguid.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <efsstruc.h>
#pragma warning(pop)

USE_HANDLE_MACROS("CERTMGR(locate.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define szCertAttr  _T ("?userCertificate")

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizLocate property page

IMPLEMENT_DYNCREATE(CAddEFSWizLocate, CWizard97PropertyPage)

CAddEFSWizLocate::CAddEFSWizLocate() : CWizard97PropertyPage(CAddEFSWizLocate::IDD)
{
	//{{AFX_DATA_INIT(CAddEFSWizLocate)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	VERIFY (m_szHeaderTitle.LoadString (IDS_EFS_LOCATE_TITLE));
	VERIFY (m_szHeaderSubTitle.LoadString (IDS_EFS_LOCATE_SUBTITLE));
	InitWizard97 (FALSE);
}

CAddEFSWizLocate::~CAddEFSWizLocate()
{
}

void CAddEFSWizLocate::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddEFSWizLocate)
	DDX_Control (pDX, IDC_ADDLIST, m_UserAddList);
	//}}AFX_DATA_MAP
	InitWizard97 (FALSE);
}


BEGIN_MESSAGE_MAP(CAddEFSWizLocate, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(CAddEFSWizLocate)
	ON_BN_CLICKED (IDC_BROWSE_DIR, OnBrowseDir)
	ON_BN_CLICKED (IDC_BROWSE_FILE, OnBrowseFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizLocate message handlers

BOOL CAddEFSWizLocate::OnSetActive ()
{
	BOOL bResult = CWizard97PropertyPage::OnSetActive ();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT | PSWIZB_BACK);
	
	return bResult;
}

void CAddEFSWizLocate::OnBrowseDir ()
{
	FindUserFromDir ();	
}

void CAddEFSWizLocate::OnBrowseFile ()
{
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_CERTFILEFILTER));

    // replace "|" with 0;
    const size_t  nFilterLen = wcslen (szFileFilter) + 1;
    PWSTR   pszFileFilter = new WCHAR [nFilterLen];
    if ( pszFileFilter )
    {
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }

        WCHAR           szFile[MAX_PATH];
        ::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
        OPENFILENAME    ofn;
        ::ZeroMemory (&ofn, sizeof (OPENFILENAME));

        ofn.lStructSize = sizeof (OPENFILENAME);
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = (PCWSTR) pszFileFilter; 
        ofn.lpstrFile = szFile; 
        ofn.nMaxFile = MAX_PATH; 
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; 


        BOOL bResult = ::GetOpenFileName (&ofn);
        if ( bResult )
        {
            CString szFileName = ofn.lpstrFile;
		    //
		    // Open cert store from the file
		    //

		    HCERTSTORE      hCertStore = NULL;
		    PVOID			FileNameVoidP = (PVOID) (LPCWSTR)szFileName;
		    PCCERT_CONTEXT  pCertContext = NULL;
		    DWORD			dwEncodingType = 0;
		    DWORD			dwContentType = 0;
		    DWORD			dwFormatType = 0;

		    BOOL	bReturn = ::CryptQueryObject (
				    CERT_QUERY_OBJECT_FILE,
				    FileNameVoidP,
				    CERT_QUERY_CONTENT_FLAG_ALL,
				    CERT_QUERY_FORMAT_FLAG_ALL,
				    0,
				    &dwEncodingType,
				    &dwContentType,
				    &dwFormatType,
				    &hCertStore,
				    NULL,
				    (const void **)&pCertContext);

		    ASSERT (bReturn);
		    if ( bReturn )
		    {
			    //
			    // Success. See what we get back. A store or a cert.
			    //

			    if (  (dwContentType == CERT_QUERY_CONTENT_SERIALIZED_STORE)
					    && hCertStore)
			    {

 				    CERT_ENHKEY_USAGE	enhKeyUsage;
				    ::ZeroMemory (&enhKeyUsage, sizeof (CERT_ENHKEY_USAGE));
				    enhKeyUsage.cUsageIdentifier = 1;
				    enhKeyUsage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;
				    //
				    // We get the certificate store
				    //
				    pCertContext = ::CertFindCertificateInStore (
						    hCertStore,
						    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						    0,
						    CERT_FIND_ENHKEY_USAGE,
						    &enhKeyUsage,
 						    NULL);
				    if ( !pCertContext )
				    {
					    CString	caption;
					    CString text;
                        CThemeContextActivator activator;

					    VERIFY (text.LoadString (IDS_EFS_FILE_HAS_NO_EFS_USAGE));
					    VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENTY));
					    MessageBox (text, caption, MB_OK);
					    return;
				    }

				    if ( hCertStore )
					    ::CertCloseStore (hCertStore, 0);
			    }
			    else if ( (dwContentType != CERT_QUERY_CONTENT_CERT) || !pCertContext )
			    {
				    //
				    // Neither a valid cert file nor a store file we like.
				    //

				    if ( hCertStore )
					    ::CertCloseStore (hCertStore, 0);

				    if  ( pCertContext )
					    ::CertFreeCertificateContext (pCertContext);

				    CString ErrMsg;
                    CThemeContextActivator activator;

				    VERIFY (ErrMsg.LoadString (IDS_CERTFILEFORMATERR));
				    MessageBox (ErrMsg);
				    return;

			    }

			    if ( hCertStore )
			    {
				    ::CertCloseStore (hCertStore, 0);
				    hCertStore = NULL;
			    }

			    //
			    // Add the user
			    //

			    if ( CertHasEFSKeyUsage (pCertContext) )
			    {
				    //
				    // We got the cert. Add it to the structure. We need get the subject name first.
				    //

				    LPWSTR  pszUserCertName = 0;
				    INT_PTR iRetCode = GetCertNameFromCertContext (
						    pCertContext,
						    &pszUserCertName);

				    if ( ERROR_SUCCESS != iRetCode )
				    {
					    if  ( pCertContext )
					    {
						    ::CertFreeCertificateContext (pCertContext);
					    }

					    return;
				    }
				    CAddEFSWizSheet*	pAddSheet = reinterpret_cast <CAddEFSWizSheet*> (m_pWiz);
				    ASSERT (pAddSheet);
				    if ( !pAddSheet )
					    return;

				    EFS_CERTIFICATE_BLOB	certBlob;

				    certBlob.cbData = pCertContext->cbCertEncoded;
				    certBlob.pbData = pCertContext->pbCertEncoded;
				    certBlob.dwCertEncodingType = pCertContext->dwCertEncodingType;
				    iRetCode = pAddSheet->Add (
						    NULL,
						    pszUserCertName,
						    (PVOID)&certBlob,
						    NULL,
						    USERADDED,
						    pCertContext);

				    if ( (ERROR_SUCCESS != iRetCode) && (CRYPT_E_EXISTS != iRetCode) )
				    {
					    //
					    // Error in adding the user
					    //

					    ::CertFreeCertificateContext (pCertContext);
					    pCertContext = NULL;
				    }
				    else
				    {
					    //
					    // Add the user to the list box.
					    //

					    if ( iRetCode == ERROR_SUCCESS )
					    {
						    LV_ITEM fillItem;
						    CString userUnknown;

						    try {
							    if (!userUnknown.LoadString (IDS_UNKNOWNUSER))
							    {
								    ASSERT (0);
								    userUnknown.Empty ();
							    }
						    }
						    catch (...)
						    {
							    userUnknown.Empty ();
						    }

						    fillItem.mask = LVIF_TEXT;
						    fillItem.iItem = 0;
						    fillItem.iSubItem = 0;
						    if ( userUnknown.IsEmpty () )
						    {
							    fillItem.pszText = _T ("");
						    }
						    else
						    {
							    fillItem.pszText = userUnknown.GetBuffer (userUnknown.GetLength () + 1);
						    }
						    fillItem.iItem = m_UserAddList.InsertItem (&fillItem);
						    if ( !userUnknown.IsEmpty () )
						    {
							    userUnknown.ReleaseBuffer ();
						    }

						    if ( fillItem.iItem != -1 )
						    {
							    fillItem.pszText = pszUserCertName;
							    fillItem.iSubItem = 1;
							    m_UserAddList.SetItem (&fillItem);
						    }
						    else
						    {
							    pAddSheet->Remove (NULL,  pszUserCertName);
						    }
						    pszUserCertName = NULL;
					    }
					    else
					    {
						    //
						    // Already deleted inside the Add.
						    //

						    pszUserCertName = NULL;
					    }
				    }

				    if (pszUserCertName)
				    {
					    delete [] pszUserCertName;
					    pszUserCertName = NULL;
				    }
			    }
			    else
			    {
				    CString	caption;
				    CString text;
                    CThemeContextActivator activator;

				    VERIFY (text.LoadString (IDS_EFS_FILE_HAS_NO_EFS_USAGE));
				    VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENTY));
				    MessageBox (text, caption, MB_OK);
			    }
		    }
		    else
		    {
			    //
			    // Fail. Get the error code.
			    //
			    DWORD   dwErr = GetLastError ();
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENTY));
			    text.FormatMessage (IDS_CERTFILEOPENERR, 
                        szFileName, GetSystemMessage (dwErr));
			    MessageBox (text, caption);
		    }
        }

        delete [] pszFileFilter;
	}
}


HRESULT CAddEFSWizLocate::FindUserFromDir ()
{
    HRESULT				hr = S_OK;
    LPWSTR				pszListUserName = NULL;
    LPWSTR				pszUserCertName = NULL;

    FORMATETC			fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM			medium = { TYMED_NULL, NULL, NULL };

    ICommonQuery*		pCommonQuery = NULL;
    OPENQUERYWINDOW		oqw;
    DSQUERYINITPARAMS	dqip;
    bool				bCheckDS = false;
    HANDLE				hDS = NULL;
    CAddEFSWizSheet*			pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
	ASSERT (pAddSheet);
	if ( !pAddSheet )
		return E_POINTER;

    hr = ::CoInitialize (NULL);
    if ( FAILED (hr) )
        return hr;

    hr = ::CoCreateInstance (CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
			IID_ICommonQuery, (LPVOID*)&pCommonQuery);

	ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) )
	{
        dqip.cbStruct = sizeof (dqip);
        dqip.dwFlags = DSQPF_SHOWHIDDENOBJECTS |
                       DSQPF_ENABLEADMINFEATURES;

        dqip.pDefaultScope = NULL;  //szScopeLocn

        oqw.cbStruct = sizeof (oqw);
        oqw.dwFlags = OQWF_OKCANCEL |
                    //    OQWF_SINGLESELECT |
                        OQWF_DEFAULTFORM |
                        OQWF_REMOVEFORMS ;
        oqw.clsidHandler = CLSID_DsQuery;
        oqw.pHandlerParameters = &dqip;
        oqw.clsidDefaultForm = CLSID_DsFindPeople;

        IDataObject* pDataObject = NULL;

        hr = pCommonQuery->OpenQueryWindow (m_hWnd, &oqw, &pDataObject);
		ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) && pDataObject )
        {
            // Fill the list view

            fmte.cfFormat = pAddSheet->GetDataFormat ();
			hr = pDataObject->GetData (&fmte, &medium);
			// A return of DV_E_FORMATETC (0x80040064) here can mean that
			// nothing was selected in the query window
            if ( SUCCEEDED (hr) )
            {
                LPDSOBJECTNAMES pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;

                hr = DsBind (NULL, NULL, &hDS);
                if ( SUCCEEDED (hr) )
				{
                    //
                    //  We are going to use the DS to crack the names
                    //

                    bCheckDS = true;
                }


                if ( pDsObjects->cItems )
				{
					// Verify that each user has a cert that allows the necessary
					// action (efs decryption)
                    for ( UINT i = 0 ; i < pDsObjects->cItems ; i++ )
					{
                        LPWSTR			pszTemp = (LPWSTR)
							 ( ( (LPBYTE)pDsObjects)+pDsObjects->aObjects[i].offsetName);
                        DS_NAME_RESULT* pUserName = NULL;
                        PSID			userSID = NULL;
                        DWORD			cbSid = 0;
                        LPWSTR			pszReferencedDomainName = NULL;
                        DWORD			cbReferencedDomainName = 0;
                        SID_NAME_USE	SidUse;


                        //
                        // Get rid of the head :\\
                        //

                        LPWSTR pszSearch = _tcschr (pszTemp, _T (':'));
                        if (pszSearch && (pszSearch[1] == _T ('/')) && (pszSearch[2] == _T ('/')))
						{
                            pszTemp = pszSearch + 3;
                        }

                        if ( bCheckDS )
						{
                            hr = DsCrackNames (
                                                    hDS,
                                                    DS_NAME_NO_FLAGS,
                                                    DS_FQDN_1779_NAME,
                                                    DS_NT4_ACCOUNT_NAME,
                                                    1,
                                                    &pszTemp,
                                                    &pUserName
                                                   );

                            if ( SUCCEEDED (hr) && pUserName )
							{
                                if ( ( pUserName->cItems > 0 ) && (DS_NAME_NO_ERROR == pUserName->rItems[0].status))
								{
                                    //
                                    // Save the NT4 name first, in case we cannot get the principle name
                                    //

                                    pszListUserName = new WCHAR[_tcslen (pUserName->rItems[0].pName) + 1];
                                    if (pszListUserName)
									{
                                        _tcscpy (pszListUserName, pUserName->rItems[0].pName);
                                    }
									else
									{
										hr = E_OUTOFMEMORY;
										break;
									}

                                    BOOL	bReturn =  ::LookupAccountName (
                                                NULL,
                                                pUserName->rItems[0].pName,
                                                userSID,
                                                &cbSid,
                                                pszReferencedDomainName,
                                                &cbReferencedDomainName,
                                                &SidUse
                                               );

                                    hr = GetLastError ();
                                    if ( !bReturn && (HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) == hr) )
									{
                                        //
                                        // We are expecting this error
                                        //

                                        userSID = new BYTE[cbSid];
                                        pszReferencedDomainName =  new WCHAR[cbReferencedDomainName];
                                        if ( userSID && pszReferencedDomainName )
										{
                                            bReturn =  ::LookupAccountName (
                                                        NULL,
                                                        pUserName->rItems[0].pName,
                                                        userSID,
                                                        &cbSid,
                                                        pszReferencedDomainName,
                                                        &cbReferencedDomainName,
                                                        &SidUse);

                                            delete [] pszReferencedDomainName;
                                            pszReferencedDomainName = NULL;
                                            if (!bReturn)
											{
                                                //
                                                // Get SID failed. We can live with it.
                                                //

                                                userSID = NULL;
                                            }
                                        }
										else
										{
                                            if (userSID)
											{
                                                delete [] userSID;
                                                userSID = NULL;
                                            }
                                            if (pszReferencedDomainName)
											{
                                                delete [] pszReferencedDomainName;
                                                pszReferencedDomainName = NULL;
                                            }
											hr = E_OUTOFMEMORY;
											break;
                                        }
                                    }
									else
									{
                                        ASSERT (!bReturn);
                                        userSID = NULL;
                                    }
                                }
                            }
							else
							{
                                //
                                // Cannot get the NT4 name. Set the SID to NULL. Go on.
                                //

                                userSID = NULL;
                            }

                            if (pUserName)
							{
                                DsFreeNameResult (pUserName);
                                pUserName = NULL;
                            }

                            hr = DsCrackNames (
									hDS,
									DS_NAME_NO_FLAGS,
									DS_FQDN_1779_NAME,
									DS_USER_PRINCIPAL_NAME,
									1,
									&pszTemp,
									&pUserName);

							ASSERT (SUCCEEDED (hr));
                            if ( (HRESULT_FROM_WIN32 (ERROR_SUCCESS) == hr) &&
                                  ( pUserName->cItems > 0 ) &&
                                  (DS_NAME_NO_ERROR == pUserName->rItems[0].status) )
							{
                                //
                                // We got the principal name
                                //

                                LPWSTR  pszTmpNameStr =
										new WCHAR[_tcslen (pUserName->rItems[0].pName) + 1];
                                if ( pszTmpNameStr )
								{
                                    _tcscpy (pszTmpNameStr, pUserName->rItems[0].pName);
                                    delete [] pszListUserName;
                                    pszListUserName = pszTmpNameStr;
                                }
								else
								{
                                    hr = ERROR_OUTOFMEMORY;
                                }
                            }
                        }

                        if ( (HRESULT_FROM_WIN32 (ERROR_OUTOFMEMORY) != hr) && ( !pszListUserName))
						{
                            //
                            // Use the LDAP name
                            //
                            pszListUserName = new WCHAR[_tcslen (pszTemp)+1];
                            if ( pszListUserName )
							{
                                _tcscpy (pszListUserName, pszTemp);
                            }
							else
							{
                                hr = ERROR_OUTOFMEMORY;
                            }

                        }

                        if (pUserName)
						{
                            DsFreeNameResult (pUserName);
                            pUserName = NULL;
                        }

                        if ( HRESULT_FROM_WIN32 (ERROR_OUTOFMEMORY) != hr )
						{
                            //
                            // Now is the time to get the certificate
                            //
							PCWSTR	pszHeader1 = L"LDAP://";
							PCWSTR	pszHeader2 = L"LDAP:///";
                            PWSTR	pszLdapUrl = new WCHAR[wcslen (pszTemp) +
										wcslen (pszHeader2) + 
										wcslen (szCertAttr) + 2];

                            if ( pszLdapUrl )
							{
								PCWSTR	szCN = L"CN=";
                                //
                                // This is really not necessary. MS should make the name convention consistant.
                                //
								if ( !wcsncmp (pszTemp, szCN, wcslen (szCN)) )
								{
									// pszTemp is object name without server
									wcscpy (pszLdapUrl, pszHeader2);
								}
								else
									wcscpy (pszLdapUrl, pszHeader1);
                                wcscat (pszLdapUrl, pszTemp);
                                wcscat (pszLdapUrl, szCertAttr);

                                hr = ERROR_SUCCESS;
                                HCERTSTORE hDSCertStore = ::CertOpenStore (
										sz_CERT_STORE_PROV_LDAP,
										X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
										NULL,
										CERT_STORE_MAXIMUM_ALLOWED_FLAG,
										(void*) pszLdapUrl);
                                //
                                // In case delete change the result of GetLastError ()
                                //

                                hr = GetLastError ();

                                if (hDSCertStore)
								{
									CERT_ENHKEY_USAGE	enhKeyUsage;

									::ZeroMemory (&enhKeyUsage, sizeof (CERT_ENHKEY_USAGE));
									enhKeyUsage.cUsageIdentifier = 1;
									enhKeyUsage.rgpszUsageIdentifier = new LPSTR[1];
									if ( enhKeyUsage.rgpszUsageIdentifier )
									{
										enhKeyUsage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;
										//
										// We get the certificate store
										//
				                        PCCERT_CONTEXT  pCertContext =
												::CertFindCertificateInStore (
													hDSCertStore,
													X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
													0,
													CERT_FIND_ENHKEY_USAGE,
													&enhKeyUsage,
 													NULL);
										if ( pCertContext )
										{
											if ( CertHasEFSKeyUsage (pCertContext) )
											{
												//
												// We got the certificate. Add it to the lists.
												// Get the certificate display name first
												//

												hr = GetCertNameFromCertContext (
														pCertContext,
														&pszUserCertName);

												//
												// Add the user
												//

												EFS_CERTIFICATE_BLOB certBlob;

												certBlob.cbData = pCertContext->cbCertEncoded;
												certBlob.pbData = pCertContext->pbCertEncoded;
												certBlob.dwCertEncodingType = pCertContext->dwCertEncodingType;
												hr = pAddSheet->Add (
														pszListUserName,
														pszUserCertName,
														(PVOID)&certBlob,
														userSID,
														USERADDED,
														pCertContext);

												if ( FAILED (hr) && (HRESULT_FROM_WIN32 (CRYPT_E_EXISTS) != hr) )
												{
													//
													// Error in adding the user
													//

													::CertFreeCertificateContext (pCertContext);
													pCertContext = NULL;
												}
												else
												{
													//
													// Add the user to the list box.
													//

													if ( SUCCEEDED (hr) )
													{
														LV_ITEM fillItem;

														fillItem.mask = LVIF_TEXT;
														fillItem.iItem = 0;
														fillItem.iSubItem = 0;

														fillItem.pszText = pszListUserName;
														fillItem.iItem = m_UserAddList.InsertItem (&fillItem);

														if ( fillItem.iItem == -1 )
														{
															pAddSheet->Remove ( pszListUserName,  pszUserCertName);
														}
														else
														{
															fillItem.pszText = pszUserCertName;
															fillItem.iSubItem = 1;
															m_UserAddList.SetItem (&fillItem);
														}
													}

													//
													//Either deleted (CRYPT_E_EXISTS) or should not be freed (ERROR_SUCCESS)
													//

													pszListUserName = NULL;
													pszUserCertName = NULL;
												}
											}
											else
											{
												CString	caption;
												CString text;
                                                CThemeContextActivator activator;

												VERIFY (text.LoadString (IDS_USER_OBJECT_HAS_NO_CERTS));
												VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENTY));
												MessageBox (text, caption, MB_OK);
											}
										}
										else
										{
											CString	text;
											CString caption;
                                            CThemeContextActivator activator;

											
											VERIFY (text.LoadString (IDS_USER_OBJECT_HAS_NO_CERTS));
											VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENTY));
											MessageBox (text, caption, MB_OK);
										}
										delete [] enhKeyUsage.rgpszUsageIdentifier;
									}
									else
									{
										hr = E_OUTOFMEMORY;
									}

                                    delete [] userSID;
                                    userSID = NULL;
                                    if (pszListUserName)
									{
                                        delete [] pszListUserName;
                                        pszListUserName = NULL;
                                    }
                                    if (pszUserCertName)
									{
                                        delete [] pszUserCertName;
                                        pszUserCertName = NULL;
                                    }
                                    if ( hDSCertStore )
									{
                                        CertCloseStore (hDSCertStore, 0);
                                        hDSCertStore = NULL;
                                    }
                                }
								else
								{
                                    //
                                    // Failed to open the cert store
                                    //
                                    delete [] userSID;
                                    userSID = NULL;
                                    if (pszListUserName)
									{
                                        delete [] pszListUserName;
                                        pszListUserName = NULL;
                                    }
                                    if (pszUserCertName)
									{
                                        delete [] pszUserCertName;
                                        pszUserCertName = NULL;
                                    }
									CString	caption;
									CString	text;
                                    CThemeContextActivator activator;

									VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
									text.FormatMessage (IDS_UNABLE_TO_OPEN_EFS_STORE, pszLdapUrl, 
											GetSystemMessage (hr));
									::MessageBox (NULL, text, caption, MB_OK);
                                }
                                delete [] pszLdapUrl;
                                pszLdapUrl = NULL;
                            }
							else
							{
                                hr = ERROR_OUTOFMEMORY;
                            }

                        }
                        if ( HRESULT_FROM_WIN32 (ERROR_OUTOFMEMORY) == hr )
						{
                            //
                            // Free the memory. Delete works for NULL. No check is needed.
                            //
                            delete [] userSID;
                            userSID = NULL;
                            delete [] pszListUserName;
                            pszListUserName = NULL;
                            delete [] pszUserCertName;
                            pszUserCertName = NULL;
                        }

                    }//For
                }

                if (bCheckDS)
				{
                    DsUnBindW ( &hDS);
                }

                ReleaseStgMedium (&medium);
            }

            pDataObject->Release ();
        }

        pCommonQuery->Release ();
    }

    return hr;
}

DWORD CAddEFSWizLocate::GetCertNameFromCertContext (
    PCCERT_CONTEXT pCertContext,
    LPWSTR * pszUserCertName)
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the user name from the certificate
// Arguments:
//      pCertContext -- Cert Context
//      pszUserCertName -- User name
//                                  ( Caller is responsible to delete this memory using delete [] )
//  Return Value:
//      ERROR_SUCCESS if succeed.
//      If No Name if found. "USER_UNKNOWN is returned".
//
//////////////////////////////////////////////////////////////////////
{
    if ( !pszUserCertName )
	{
        return ERROR_INVALID_PARAMETER ;
    }

    *pszUserCertName = NULL;

    CString szSubjectName = ::GetNameString (pCertContext, 0);
    if ( !szSubjectName.IsEmpty () )
    {
        *pszUserCertName = new WCHAR[wcslen (szSubjectName) + 1];
        if ( *pszUserCertName )
        {
            wcscpy (*pszUserCertName, szSubjectName);
        }
        else
            return ERROR_NOT_ENOUGH_MEMORY;
    }
    else
        return ERROR_FILE_NOT_FOUND;

/*
    DWORD	dwNameLength = CertGetNameString (
            pCertContext,
            CERT_NAME_EMAIL_TYPE,
            0,
            NULL,
            NULL,
            0
           );

    DWORD   dwUserNameBufLen = 0;
    if ( dwNameLength > 1)
	{
        //
        // The E-Mail name exist. Go get the email name.
        //

        *pszUserCertName = new WCHAR[dwNameLength];
        if ( !(*pszUserCertName) )
		{
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        dwUserNameBufLen = dwNameLength;
        dwNameLength = CertGetNameString (
                pCertContext,
                CERT_NAME_EMAIL_TYPE,
                0,
                NULL,
                *pszUserCertName,
                dwUserNameBufLen
               );

        ASSERT (dwNameLength == dwUserNameBufLen);
    }
	else
	{
        //
        // Get the subject name in the X500 format
        //

        DWORD   dwStrType = CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG;

        dwNameLength = CertGetNameString (
                pCertContext,
                CERT_NAME_RDN_TYPE,
                0,
                &dwStrType,
                NULL,
                0
               );

        if  ( dwNameLength > 1 )
		{
            //
            // Name exists. Go get it.
            //

            *pszUserCertName = new WCHAR[dwNameLength];
            if ( !(*pszUserCertName) )
			{
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            dwUserNameBufLen = dwNameLength;
            dwNameLength = CertGetNameString (
                    pCertContext,
                    CERT_NAME_RDN_TYPE,
                    0,
                    &dwStrType,
                    *pszUserCertName,
                    dwUserNameBufLen
                   );

            ASSERT (dwNameLength == dwUserNameBufLen);
        }
		else
		{
            try {
                CString unknownCertName;

                VERIFY (unknownCertName.LoadString (IDS_NOCERTNAME));

                dwUserNameBufLen = unknownCertName.GetLength ();
                *pszUserCertName = new WCHAR[dwUserNameBufLen + 1];
                _tcscpy (*pszUserCertName, unknownCertName);

            }
            catch (...){
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
*/

    return ERROR_SUCCESS;
}

BOOL CAddEFSWizLocate::OnInitDialog ()
{
	CWizard97PropertyPage::OnInitDialog ();
    CString userNameTitle;
    CString userDNTitle;
    RECT	rcList;

    try {	
	    m_UserAddList.GetClientRect (&rcList);
        DWORD	dwColWidth = (rcList.right - rcList.left)/2;
        VERIFY (userNameTitle.LoadString (IDS_USERCOLTITLE));
        VERIFY (userDNTitle.LoadString (IDS_DNCOLTITLE));
        m_UserAddList.InsertColumn (0, userNameTitle, LVCFMT_LEFT, dwColWidth);
        m_UserAddList.InsertColumn (1, userDNTitle, LVCFMT_LEFT, dwColWidth);
    }
    catch (...){
    }
	
	CAddEFSWizSheet*	pAddSheet = reinterpret_cast <CAddEFSWizSheet*> (m_pWiz);
	ASSERT (pAddSheet);
	if ( pAddSheet )
    {
        if ( pAddSheet->m_bMachineIsStandAlone )
            GetDlgItem (IDC_BROWSE_DIR)->EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CAddEFSWizLocate::OnWizardBack ()
{
    CAddEFSWizSheet *pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
	ASSERT (pAddSheet);
	if ( !pAddSheet )
		return -1;

    pAddSheet->ClearUserList ();	
    m_UserAddList.DeleteAllItems ();
	return CWizard97PropertyPage::OnWizardBack ();
}


LRESULT CAddEFSWizLocate::OnWizardNext()
{
	if ( m_UserAddList.GetItemCount () <= 0 )
	{
		CString	caption;
		CString	text;
        CThemeContextActivator activator;

		VERIFY (caption.LoadString (IDS_ADDTITLE));
		VERIFY (text.LoadString (IDS_MUST_ADD_RECOVERY_AGENT));
		MessageBox (text, caption, MB_OK);
		return -1;
	}
	
	return CWizard97PropertyPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\nodetype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       nodetype.h
//
//  Contents:   Declaration of CertificateManagerObjectType
//
//----------------------------------------------------------------------------

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _CertificateManagerObjectType {
	CERTMGR_MULTISEL = MMC_MULTI_SELECT_COOKIE,
	CERTMGR_NULL_POLICY = -2,
	CERTMGR_INVALID = -1,
	CERTMGR_SNAPIN = 0,
	CERTMGR_CERTIFICATE,
	CERTMGR_LOG_STORE,
	CERTMGR_PHYS_STORE,
	CERTMGR_USAGE,
	CERTMGR_CRL_CONTAINER,
	CERTMGR_CTL_CONTAINER,
	CERTMGR_CERT_CONTAINER,
	CERTMGR_CRL,
	CERTMGR_CTL,
	CERTMGR_AUTO_CERT_REQUEST,
	CERTMGR_CERT_POLICIES_USER,
	CERTMGR_CERT_POLICIES_COMPUTER,
	CERTMGR_LOG_STORE_GPE,
    CERTMGR_LOG_STORE_RSOP,
    CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS,
    CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS,
    CERTMGR_SAFER_COMPUTER_ROOT,
    CERTMGR_SAFER_USER_ROOT,
    CERTMGR_SAFER_COMPUTER_LEVELS,
    CERTMGR_SAFER_USER_LEVELS,
    CERTMGR_SAFER_COMPUTER_ENTRIES,
    CERTMGR_SAFER_USER_ENTRIES,
    CERTMGR_SAFER_COMPUTER_LEVEL,
    CERTMGR_SAFER_USER_LEVEL,
    CERTMGR_SAFER_COMPUTER_ENTRY,
    CERTMGR_SAFER_USER_ENTRY,
    CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS,
    CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS,
    CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES,
    CERTMGR_SAFER_USER_DEFINED_FILE_TYPES,
    CERTMGR_SAFER_USER_ENFORCEMENT,
    CERTMGR_SAFER_COMPUTER_ENFORCEMENT,
	CERTMGR_NUMTYPES		//must be last
} CertificateManagerObjectType, *PCertificateManagerObjectType;

inline bool IsValidObjectType (CertificateManagerObjectType objecttype)
{ 
	return ((objecttype >= CERTMGR_SNAPIN && objecttype < CERTMGR_NUMTYPES) 
			|| CERTMGR_NULL_POLICY == objecttype); 
}


#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\helppropertypage.cpp ===
// HelpPropertyPage.cpp : implementation file
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage property page


CHelpPropertyPage::CHelpPropertyPage(UINT uIDD) : 
    CAutoDeletePropPage(uIDD),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpPropertyPage::~CHelpPropertyPage()
{
}

void CHelpPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpPropertyPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CHelpPropertyPage)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage message handlers
void CHelpPropertyPage::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpPropertyPage::OnWhatsThis\n");
}

BOOL CHelpPropertyPage::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnHelp\n");
    return TRUE;
}

void CHelpPropertyPage::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpPropertyPage::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpPropertyPage::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnContextMenu\n");
}


/////////////////////////////////////////////////////////////////////////////
// CHelpDialog property page


CHelpDialog::CHelpDialog(UINT uIDD, CWnd* pParentWnd) : 
    CDialog(uIDD, pParentWnd),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpDialog::~CHelpDialog()
{
}

void CHelpDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog message handlers
void CHelpDialog::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpDialog::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpDialog::OnWhatsThis\n");
}

BOOL CHelpDialog::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpDialog::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpDialog::OnHelp\n");
    return TRUE;
}

void CHelpDialog::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpDialog::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpDialog::OnContextMenu\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\helppropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       HelpPropertyPage.h
//
//  Contents:   Declaration of CHelpPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
#define AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HelpPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpPropertyPage : public CAutoDeletePropPage
{
// Construction
public:
	CHelpPropertyPage(UINT uIDD);
	~CHelpPropertyPage();

// Dialog Data
	//{{AFX_DATA(CHelpPropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpPropertyPage)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

    HWND            m_hWndWhatsThis;
};


/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpDialog : public CDialog
{
// Construction
public:
	CHelpDialog(UINT uIDD, CWnd* pParentWnd);
	~CHelpDialog();

// Dialog Data
	//{{AFX_DATA(CHelpDialog)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpDialog)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

    HWND            m_hWndWhatsThis;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\locate.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       locate.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_LOCATE_H__DE5E8115_A351_11D1_861B_00C04FB94F17__INCLUDED_)
#define AFX_LOCATE_H__DE5E8115_A351_11D1_861B_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Locate.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizLocate dialog

class CAddEFSWizLocate : public CWizard97PropertyPage
{
	DECLARE_DYNCREATE(CAddEFSWizLocate)

// Construction
public:
	CAddEFSWizLocate();
	~CAddEFSWizLocate();

// Dialog Data
	//{{AFX_DATA(CAddEFSWizLocate)
	enum { IDD = IDD_LOCATING };
	CListCtrl	m_UserAddList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAddEFSWizLocate)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddEFSWizLocate)
	afx_msg void OnBrowseDir();
	afx_msg void OnBrowseFile();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	DWORD GetCertNameFromCertContext(PCCERT_CONTEXT CertContext, LPWSTR *UserCertName);
	HRESULT FindUserFromDir();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOCATE_H__DE5E8115_A351_11D1_861B_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\options.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       options.cpp
//
//  Contents:   CViewOptionsDlg - snapin-wide view options
//
//----------------------------------------------------------------------------
// options.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "options.h"
#include "compdata.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CViewOptionsDlg dialog


CViewOptionsDlg::CViewOptionsDlg(CWnd* pParent, CCertMgrComponentData* pCompData)
	: CHelpDialog(CViewOptionsDlg::IDD, pParent),
	m_pCompData (pCompData)
{
	ASSERT (m_pCompData);
	//{{AFX_DATA_INIT(CViewOptionsDlg)
	m_bShowPhysicalStores = FALSE;
	m_bShowArchivedCerts = FALSE;
	//}}AFX_DATA_INIT
}


void CViewOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CViewOptionsDlg)
	DDX_Control(pDX, IDC_SHOW_PHYSICAL, m_showPhysicalButton);
	DDX_Control(pDX, IDC_VIEW_BY_STORE, m_viewByStoreBtn);
	DDX_Control(pDX, IDC_VIEW_BY_PURPOSE, m_viewByPurposeBtn);
	DDX_Check(pDX, IDC_SHOW_PHYSICAL, m_bShowPhysicalStores);
	DDX_Check(pDX, IDC_SHOW_ARCHIVED, m_bShowArchivedCerts);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewOptionsDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CViewOptionsDlg)
	ON_BN_CLICKED(IDC_VIEW_BY_PURPOSE, OnViewByPurpose)
	ON_BN_CLICKED(IDC_VIEW_BY_STORE, OnViewByStore)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewOptionsDlg message handlers

BOOL CViewOptionsDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	
	if ( m_pCompData )
	{
		BOOL	bIsFileView = !m_pCompData->m_szFileName.IsEmpty ();

		if ( bIsFileView )
			m_showPhysicalButton.ShowWindow (SW_HIDE);

		m_bShowArchivedCerts = m_pCompData->m_bShowArchivedCertsPersist;
		m_bShowPhysicalStores = m_pCompData->m_bShowPhysicalStoresPersist;

		if ( IDM_STORE_VIEW == m_pCompData->m_activeViewPersist )
			m_viewByStoreBtn.SetCheck (1);
		else
		{
			m_viewByPurposeBtn.SetCheck (1);
			m_showPhysicalButton.EnableWindow (FALSE);
		}

		UpdateData (FALSE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CViewOptionsDlg::OnOK() 
{
	UpdateData (TRUE);

	if ( m_pCompData )
	{
		m_pCompData->m_bShowArchivedCertsPersist = m_bShowArchivedCerts;
		m_pCompData->m_bShowPhysicalStoresPersist = m_bShowPhysicalStores;

		if ( m_viewByStoreBtn.GetCheck () )
			m_pCompData->m_activeViewPersist = IDM_STORE_VIEW;
		else
			m_pCompData->m_activeViewPersist = IDM_USAGE_VIEW;
	}
	CHelpDialog::OnOK();
}

void CViewOptionsDlg::OnViewByPurpose() 
{
	if ( m_viewByPurposeBtn.GetCheck () )
		m_showPhysicalButton.EnableWindow (FALSE);
	else
		m_showPhysicalButton.EnableWindow (TRUE);
}

void CViewOptionsDlg::OnViewByStore() 
{
	if ( m_viewByStoreBtn.GetCheck () )
		m_showPhysicalButton.EnableWindow (TRUE);
	else
		m_showPhysicalButton.EnableWindow (FALSE);
}

void CViewOptionsDlg::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CViewOptionsDlg::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_VIEW_BY_PURPOSE,    IDH_OPTIONS_VIEW_BY_PURPOSE,
        IDC_VIEW_BY_STORE,      IDH_OPTIONS_VIEW_BY_STORE,
        IDC_SHOW_PHYSICAL,      IDH_OPTIONS_SHOW_PHYSICAL,
        IDC_SHOW_ARCHIVED,      IDH_OPTIONS_SHOW_ARCHIVED,
        0, 0
    };
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    _TRACE (-1, L"Leaving CViewOptionsDlg::DoContextHelp\n");
}

void CViewOptionsDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CViewOptionsDlg::OnContextMenu\n");

	if ( pWnd->m_hWnd == GetDlgItem (IDC_VIEW_BY_PURPOSE)->m_hWnd ||
			pWnd->m_hWnd == GetDlgItem (IDC_VIEW_BY_STORE)->m_hWnd ||
			pWnd->m_hWnd == GetDlgItem (IDC_SHOW_PHYSICAL)->m_hWnd ||
			pWnd->m_hWnd == GetDlgItem (IDC_SHOW_ARCHIVED)->m_hWnd )
	{
		CMenu bar;
		if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
		{
			CMenu& popup = *bar.GetSubMenu (0);
			ASSERT(popup.m_hMenu);

			if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
					point.x,    // in screen coordinates
					point.y,    // in screen coordinates
					this) ) // route commands through main window
			{
				m_hWndWhatsThis = 0;
				CPoint  clPoint (point);
				ScreenToClient (&clPoint);
				CWnd* pChild = ChildWindowFromPoint (
						clPoint,  // in client coordinates
						CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
				if ( pChild )
				{
					// Check to see if the window returned is the group box.
					// If it is, we want to get the child windows that lie in
					// the group box, since we're 
					// not interested in the group box itself.
					CWnd* pGroup = GetDlgItem (IDC_VIEW_MODE_GROUP);
					if ( pChild->m_hWnd == pGroup->m_hWnd )
					{
						CRect   rc;

						// Try the "Certificate Purpose" control
						pChild = GetDlgItem (IDC_VIEW_BY_PURPOSE);
						if ( pChild )
						{
							pChild->GetWindowRect (&rc);
							if ( rc.PtInRect (point) )
								m_hWndWhatsThis = pChild->m_hWnd;
							else
							{
								// Try the "Logical Certificate Stores" control
								pChild = GetDlgItem (IDC_VIEW_BY_STORE);
								if ( pChild )
								{
									pChild->GetWindowRect (&rc);
									if ( rc.PtInRect (point) )
										m_hWndWhatsThis = pChild->m_hWnd;
								}
							}
						}
                    
					}
					else
						m_hWndWhatsThis = pChild->m_hWnd;
				}
			}
		}
	}

    _TRACE (-1, L"Leaving CViewOptionsDlg::OnContextMenu\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\options.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       options.h
//
//  Contents:   CViewOptionsDlg - snapin-wide view options
//
//----------------------------------------------------------------------------
#if !defined(AFX_OPTIONS_H__191D8831_D3A8_11D1_955E_0000F803A951__INCLUDED_)
#define AFX_OPTIONS_H__191D8831_D3A8_11D1_955E_0000F803A951__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// options.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CViewOptionsDlg dialog
class CCertMgrComponentData;	// forward declaration

class CViewOptionsDlg : public CHelpDialog
{
// Construction
public:
	CViewOptionsDlg(CWnd* pParent, CCertMgrComponentData* pCompData);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CViewOptionsDlg)
	enum { IDD = IDD_VIEW_OPTIONS };
	CButton	m_showPhysicalButton;
	CButton	m_viewByStoreBtn;
	CButton	m_viewByPurposeBtn;
	BOOL	m_bShowPhysicalStores;
	BOOL	m_bShowArchivedCerts;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CViewOptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void DoContextHelp (HWND hWndControl);

	// Generated message map functions
	//{{AFX_MSG(CViewOptionsDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnViewByPurpose();
	afx_msg void OnViewByStore();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CCertMgrComponentData*	m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONS_H__191D8831_D3A8_11D1_955E_0000F803A951__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\policykey.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyKey.cpp
//
//  Contents:   Implementation of CPolicyKey
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "PolicyKey.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CPolicyKey::CPolicyKey (IGPEInformation* pGPEInformation, PCWSTR pszKey, bool fIsMachineType)
:   m_hKeyGroupPolicy (0),
    m_hSubKey (0)
{
    ASSERT (pszKey);
    if ( pGPEInformation )
    {
        HRESULT hr = pGPEInformation->GetRegistryKey (
                fIsMachineType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hKeyGroupPolicy);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            if ( pszKey && pszKey[0] )
            {
                DWORD   dwDisposition = 0;
                LONG lResult = ::RegCreateKeyEx (m_hKeyGroupPolicy, // handle of an open key
                        pszKey,     // address of subkey name
                        0,       // reserved
                        L"",       // address of class string
                        REG_OPTION_NON_VOLATILE,      // special options flag
                        KEY_ALL_ACCESS,    // desired security access
                        NULL,         // address of key security structure
                        &m_hSubKey,      // address of buffer for opened handle
                        &dwDisposition);  // address of disposition value buffer
                ASSERT (lResult == ERROR_SUCCESS);
                if ( lResult != ERROR_SUCCESS )
                {
                    _TRACE (0, L"RegCreateKeyEx (%s) failed: %d\n", pszKey, 
                            lResult);
                }
            }
        }
        else
        {
            _TRACE (0, L"IGPEInformation::GetRegistryKey (%s) failed: 0x%x\n", 
                    fIsMachineType ? 
                        L"GPO_SECTION_MACHINE" : L"GPO_SECTION_USER",
                    hr);
        }
    }
}

CPolicyKey::~CPolicyKey ()
{
    if ( m_hSubKey )
        VERIFY (ERROR_SUCCESS == ::RegCloseKey (m_hSubKey));

    if ( m_hKeyGroupPolicy )
        VERIFY (ERROR_SUCCESS == ::RegCloseKey (m_hKeyGroupPolicy));
}

HKEY CPolicyKey::GetKey () const
{
    if (m_hSubKey) 
        return m_hSubKey;
    else
    {
        return m_hKeyGroupPolicy;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\persist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Persist.cpp
//
//  Contents:   Implementation of persistence
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "compdata.h"

USE_HANDLE_MACROS("CERTMGR(persist.cpp)")


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCWSTR PchGetMachineNameOverride();	// Defined in chooser.cpp

/////////////////////////////////////////////////
//	The _dwMagicword is the internal version number.
//	Increment this number if you make a file format change.
#define _dwMagicword	10001


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertMgrComponentData::Load(IStream __RPC_FAR *pIStream)
{
	HRESULT hResult;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword;
	hResult = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		_TRACE (0, L"INFO: CCertMgrComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read m_activeViewPersist from stream
	hResult = pIStream->Read (&m_activeViewPersist, 
			sizeof(m_activeViewPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// read m_dwLocationPersist from stream
	hResult = pIStream->Read (&m_dwLocationPersist, 
			sizeof(m_dwLocationPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// read m_bShowPhysicalStoresPersist from stream
	hResult = pIStream->Read (&m_bShowPhysicalStoresPersist, 
			sizeof(m_bShowPhysicalStoresPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// read m_bShowArchivedCertsPersist from stream
	hResult = pIStream->Read (&m_bShowArchivedCertsPersist, 
			sizeof(m_bShowArchivedCertsPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// read flags from stream
	DWORD dwFlags;
	hResult = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}
	SetPersistentFlags(dwFlags);

	// read server name from stream
	DWORD dwLen = 0;
	hResult = pIStream->Read (&dwLen, 4, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT (FALSE);
		return hResult;
	}
	ASSERT (dwLen <= MAX_PATH * sizeof (WCHAR));
	LPCWSTR wcszMachineName = (LPCWSTR) alloca (dwLen);

	hResult = pIStream->Read ((PVOID) wcszMachineName, dwLen, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT (FALSE);
		return hResult;
	}
	

    // Skip leading "\\", if present
    if ( !wcsncmp (wcszMachineName, L"\\\\", 2) )
        m_strMachineNamePersist = wcszMachineName + 2;
    else
        m_strMachineNamePersist = wcszMachineName;


	LPCWSTR pszMachineNameT = PchGetMachineNameOverride ();
	if ( m_fAllowOverrideMachineName && pszMachineNameT )
	{
		// Allow machine name override
	}
	else
	{
		pszMachineNameT = wcszMachineName;
	}

        // Truncate leading "\\"
    if ( !wcsncmp (pszMachineNameT, L"\\\\", 2) )
        pszMachineNameT += 2;

	QueryRootCookie().SetMachineName (pszMachineNameT);


	// read service name from stream
	dwLen = 0;
	hResult = pIStream->Read (&dwLen, 4, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT (FALSE);
		return hResult;
	}
	ASSERT (dwLen <= MAX_PATH * sizeof (WCHAR));
	LPCWSTR wcszServiceName = (LPCWSTR) alloca (dwLen);

	hResult = pIStream->Read ((PVOID) wcszServiceName, dwLen, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT (FALSE);
		return hResult;
	}

	m_szManagedServicePersist = wcszServiceName;

#endif
	return S_OK;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertMgrComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	HRESULT hResult;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hResult = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}

	// Persist m_activeViewPersist
	hResult = pIStream->Write (&m_activeViewPersist, 
			sizeof (m_activeViewPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}

	// Persist m_dwLocationPersist
	hResult = pIStream->Write (&m_dwLocationPersist, 
			sizeof (m_dwLocationPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// Persist m_bShowPhysicalStoresPersist
	hResult = pIStream->Write (&m_bShowPhysicalStoresPersist, 
			sizeof (m_bShowPhysicalStoresPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// Persist m_bShowArchivedCertsPersist
	hResult = pIStream->Write (&m_bShowArchivedCertsPersist, 
			sizeof (m_bShowArchivedCertsPersist), NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}


	// persist flags
	DWORD dwFlags = GetPersistentFlags();
	hResult = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}

	// Persist machine name length and machine name
	LPCWSTR wcszMachineName = m_strMachineNamePersist;
	size_t dwLen = (::wcslen (wcszMachineName) + 1) * sizeof (WCHAR);
	ASSERT( 4 == sizeof(DWORD) );
	hResult = pIStream->Write (&dwLen, 4, NULL);
	if ( FAILED(hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}
	hResult = pIStream->Write (wcszMachineName, (DWORD) dwLen, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT (FALSE);
		return hResult;
	}

	// Persist service name length and service name
	LPCWSTR wcszServiceName = m_szManagedServicePersist;
	dwLen = (::wcslen (wcszServiceName) + 1) * sizeof (WCHAR);
	ASSERT (4 == sizeof (DWORD));
	hResult = pIStream->Write (&dwLen, 4, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT( FALSE );
		return hResult;
	}
	hResult = pIStream->Write (wcszServiceName, (DWORD) dwLen, NULL);
	if ( FAILED (hResult) )
	{
		ASSERT (FALSE);
		return hResult;
	}

#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\password.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       password.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_PASSWORD_H__2BCA22DA_8E91_11D1_85F9_00C04FB94F17__INCLUDED_)
#define AFX_PASSWORD_H__2BCA22DA_8E91_11D1_85F9_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Password.h : header file
//

/*
// This dialog is used by EFS Recovery agent export key code, which is 
// currently commented out.
/////////////////////////////////////////////////////////////////////////////
// CPassword dialog

class CPassword : public CHelpDialog
{
// Construction
public:
	virtual  ~CPassword();
	LPCWSTR GetPassword() const;
	CPassword(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPassword)
	enum { IDD = IDD_PASSWORD };
	CEdit	m_password1Edit;
	CString	m_strPassword1;
	CString	m_strPassword2;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPassword)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    virtual void DoContextHelp (HWND hWndControl);
	void ClearPasswords ();

	// Generated message map functions
	//{{AFX_MSG(CPassword)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
};
*/

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PASSWORD_H__2BCA22DA_8E91_11D1_85F9_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\password.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Password.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------\
// Password.cpp : implementation file
//

#include "stdafx.h"
#include "Password.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPassword dialog

/*
// This dialog is used by EFS Recovery agent export key code, which is 
// currently commented out.
CPassword::CPassword(CWnd* pParent)
	: CHelpDialog(CPassword::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPassword)
	m_strPassword1 = _T("");
	m_strPassword2 = _T("");
	//}}AFX_DATA_INIT
}


void CPassword::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPassword)
	DDX_Control(pDX, IDC_PASSWORD1, m_password1Edit);
	DDX_Text(pDX, IDC_PASSWORD1, m_strPassword1);
	DDX_Text(pDX, IDC_PASSWORD2, m_strPassword2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPassword, CHelpDialog)
	//{{AFX_MSG_MAP(CPassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPassword message handlers

LPCWSTR CPassword::GetPassword() const
{
	return (LPCWSTR) m_strPassword1;
}

void CPassword::OnOK() 
{
	VERIFY (UpdateData (TRUE));

 	if ( m_strPassword1 != m_strPassword2 )
	{
		CString	caption;
		CString	text;
        CThemeContextActivator activator;

		VERIFY (caption.LoadString (IDS_SET_PASSWORD));
		VERIFY (text.LoadString (IDS_PASSWORDS_DONT_MATCH));

		MessageBox (text, caption, MB_OK);
		ClearPasswords ();
		VERIFY (UpdateData (FALSE));
		m_password1Edit.SetFocus ();
	}
	else
		CHelpDialog::OnOK();
}

void CPassword::OnCancel() 
{
	CString	caption;
	CString	text;
    CThemeContextActivator activator;

	VERIFY (caption.LoadString (IDS_SET_PASSWORD));
	VERIFY (text.LoadString (IDS_CANCEL_NO_CREATE_PFX));

	if ( IDYES == MessageBox (text, caption, MB_YESNO) )
		CHelpDialog::OnCancel();
}

CPassword::~CPassword()
{
	// Zero out memory before freeing to protect password
	ClearPasswords ();
}

BOOL CPassword::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	
	m_password1Edit.SetFocus ();
	
	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPassword::ClearPasswords()
{
	size_t	len = m_strPassword1.GetLength ();
	LPWSTR	pstr = m_strPassword1.GetBuffer ((int) len);
	if ( pstr )
	{
		memset (pstr, 0, len * sizeof (TCHAR));
	}
	m_strPassword1.ReleaseBuffer ();

	len = m_strPassword2.GetLength ();
	pstr = m_strPassword2.GetBuffer ((int) len);
	if ( pstr )
	{
		memset (pstr, 0, len * sizeof (TCHAR));
	}
	m_strPassword2.ReleaseBuffer ();
}

void CPassword::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CPassword::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_PASSWORD1,      IDH_PASSWORD_PASSWORD1,
        IDC_PASSWORD2,      IDH_PASSWORD_PASSWORD2,
        0, 0
    };

    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    _TRACE (-1, L"Leaving CPassword::DoContextHelp\n");
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\policykey.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyKey.h
//
//  Contents:   Definition of CPolicyKey
//
//----------------------------------------------------------------------------
#ifndef __POLICYKEY_H
#define __POLICYKEY_H

class CPolicyKey 
{
public:
    CPolicyKey (IGPEInformation* pGPEInformation, PCWSTR pszKey, bool fIsMachine);
    ~CPolicyKey ();

    HKEY GetKey () const;

private:
    HKEY    m_hKeyGroupPolicy;
    HKEY    m_hSubKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\policyprecedencepropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyPrecedencePropertyPage.h
//
//  Contents:   Declaration of CPolicyPrecedencePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_POLICYPRECEDENCEPROPERTYPAGE_H__A28637BD_1A87_4410_9EC4_33CD9165FAD3__INCLUDED_)
#define AFX_POLICYPRECEDENCEPROPERTYPAGE_H__A28637BD_1A87_4410_9EC4_33CD9165FAD3__INCLUDED_
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PolicyPrecedencePropertyPage.h : header file
//
#include "RSOPObject.h"

/////////////////////////////////////////////////////////////////////////////
// CPolicyPrecedencePropertyPage dialog
class CCertMgrComponentData;    // forward declaration
class CCertStore;               // forward declaration

class CPolicyPrecedencePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CPolicyPrecedencePropertyPage(
            const CCertMgrComponentData* pCompData, 
            const CString& szRegPath,
            PCWSTR  pszValueName,
            bool    bIsComputer);
	~CPolicyPrecedencePropertyPage();

// Dialog Data
	//{{AFX_DATA(CPolicyPrecedencePropertyPage)
	enum { IDD = IDD_POLICY_PRECEDENCE };
	CListCtrl	m_precedenceTable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPolicyPrecedencePropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPolicyPrecedencePropertyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void InsertItemInList(const CRSOPObject * pObject);
    virtual void DoContextHelp (HWND hWndControl);
    
private:
    CRSOPObjectArray    m_rsopObjectArray;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_POLICYPRECEDENCEPROPERTYPAGE_H__A28637BD_1A87_4410_9EC4_33CD9165FAD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\policyprecedencepropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyPrecedencePropertyPage.cpp
//
//  Contents:   Implementation of PolicyPrecedencePropertyPage
//
//----------------------------------------------------------------------------
// PolicyPrecedencePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "compdata.h"
#include "PolicyPrecedencePropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {
    COL_GPO_NAME = 0,
    COL_SETTING,
    NUM_COLS
};

/////////////////////////////////////////////////////////////////////////////
// CPolicyPrecedencePropertyPage property page

CPolicyPrecedencePropertyPage::CPolicyPrecedencePropertyPage(
        const CCertMgrComponentData* pCompData, 
        const CString& szRegPath,
        PCWSTR  pszValueName,
        bool bIsComputer) 
: CHelpPropertyPage(CPolicyPrecedencePropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CPolicyPrecedencePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    const CRSOPObjectArray* pObjectArray = bIsComputer ? 
            pCompData->GetRSOPObjectArrayComputer () : pCompData->GetRSOPObjectArrayUser ();
    int     nIndex = 0;
    // NOTE: rsop object array is sorted first by registry key, then by precedence
    INT_PTR nUpperBound = pObjectArray->GetUpperBound ();
    bool    bFound = false;
    size_t  nLenRegPath = wcslen (szRegPath);
    UINT    nLastPrecedenceFound = 0;

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
        if ( pObject )
        {
            // Consider only entries from this store
            if ( !_wcsnicmp (szRegPath, pObject->GetRegistryKey (), nLenRegPath) )
            {
                // If the value is present, check for that, too
                if ( pszValueName )
                {
                    if ( !wcscmp (STR_BLOB, pszValueName) )
                    {
                        // If not equal to "Blob" or "Blob0", then continue
                        if ( wcscmp (STR_BLOB, pObject->GetValueName ()) &&
                                wcscmp (STR_BLOB0, pObject->GetValueName ()) )
                        {
					        nIndex++;
					        continue;
                        }
                    }
                    else if ( wcscmp (pszValueName, pObject->GetValueName ()) ) // not equal
                    {
					    nIndex++;
					    continue;
				    }
                }

                bFound = true;
                // While we are only interested, for example, in the Root store,
                // there is no object ending in "Root", so we just want to get 
                // any object from the root store and to find, essentially, how
                // many policies we're dealing with.  So get one object from
                // each precedence level.
                if ( pObject->GetPrecedence () > nLastPrecedenceFound )
                {
                    nLastPrecedenceFound = pObject->GetPrecedence ();

					// If there is a value, we want that, otherwise we only want the key
                    if ( pszValueName || pObject->GetValueName ().IsEmpty () ) 
                    {
                        CRSOPObject* pNewObject = new CRSOPObject (*pObject);
                        if ( pNewObject )
                            m_rsopObjectArray.Add (pNewObject);
                    }
                }
            }
            else if ( bFound )
            {
                // Since the list is sorted, and we've already found the 
                // desired RSOP objects and no longer are finding them, 
                // there aren't any more.  We can optimize and break here.
                break;
            }
        }
        else
            break;

        nIndex++;
    }
}

CPolicyPrecedencePropertyPage::~CPolicyPrecedencePropertyPage()
{
    m_rsopObjectArray.RemoveAll ();
}

void CPolicyPrecedencePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPolicyPrecedencePropertyPage)
	DDX_Control(pDX, IDC_POLICY_PRECEDENCE, m_precedenceTable);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPolicyPrecedencePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CPolicyPrecedencePropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPolicyPrecedencePropertyPage message handlers

BOOL CPolicyPrecedencePropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
	int	colWidths[NUM_COLS] = {200, 100};

	// Add "Policy Name" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_PRECEDENCE_TABLE_GPO_NAME));
	VERIFY (m_precedenceTable.InsertColumn (COL_GPO_NAME, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_GPO_NAME], COL_GPO_NAME) != -1);

	// Add "Setting" column
	VERIFY (szText.LoadString (IDS_PRECEDENCE_TABLE_SETTING));
	VERIFY (m_precedenceTable.InsertColumn (COL_SETTING, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_SETTING], COL_SETTING) != -1);
	
    // Set to full-row select
    DWORD   dwExstyle = m_precedenceTable.GetExtendedStyle ();
    m_precedenceTable.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);

    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            InsertItemInList (pObject);
        }
        else
            break;

        nIndex++;
    }


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPolicyPrecedencePropertyPage::InsertItemInList(const CRSOPObject * pObject)
{
    _TRACE (1, L"CPolicyPrecedencePropertyPage::InsertItemInList\n");
	LV_ITEM	lvItem;
	int		iItem = m_precedenceTable.GetItemCount ();
	int iResult = 0;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_GPO_NAME;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pObject->GetPolicyName ();
	lvItem.iImage = 0;
    lvItem.lParam = 0;
	iItem = m_precedenceTable.InsertItem (&lvItem);
	ASSERT (-1 != iItem);
	if ( -1 == iItem )
		return;

    CString szEnabled;
    CString szDisabled;

    VERIFY (szEnabled.LoadString (IDS_ENABLED));
    VERIFY (szDisabled.LoadString (IDS_DISABLED));
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_SETTING;
    lvItem.pszText = (LPWSTR)(LPCWSTR) ((1 == pObject->GetPrecedence ()) ? szEnabled : szDisabled);
	iResult = m_precedenceTable.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
    _TRACE (-1, L"Leaving CPolicyPrecedencePropertyPage::InsertItemInList\n");
}

void CPolicyPrecedencePropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CPolicyPrecedencePropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_POLICY_PRECEDENCE,  IDH_POLICY_PRECEDENCE,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CPolicyPrecedencePropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certmgr.rc
//
#define IDS_USERCOLTITLE                1
#define IDS_ADDTITLE                    3
#define IDS_CERTFILEFILTER              8
#define IDS_CERTFILEOPENERR             9
#define IDS_CERTFILEFORMATERR           10
#define IDS_UNKNOWNUSER                 11
#define IDS_DNCOLTITLE                  12
#define IDS_NOCERTNAME                  13
#define IDS_SAFER_WINDOWS_EXTENSION_REGISTRY 14
#define IDS_CERTMGR_DESC                101
#define IDD_COMPLETION                  102
#define IDD_LOCATING                    103
#define IDD_WELCOME                     104
#define IDR_FINDCERT_AVI                105
#define IDD_PROPPAGE_AUTOENROLL         107
#define IDS_COLUMN_ISSUER               110
#define IDS_SCOPE_SNAPIN_TITLE_MACHINE  190
#define IDS_SCOPE_SNAPIN_TITLE_SERVICE  191
#define IDS_CERT_CANNOT_BE_PASTED       192
#define IDS_SCOPE_SNAPIN_TITLE_LOCAL_MACHINE 193
#define IDS_PKP_AUTOENROLLMENT_SETTINGS 194
#define IDS_COLUMN_LOG_CERTIFICATE_STORE 195
#define IDS_SNAPINSAFERWINDOWSABOUT_DESCRIPTION 196
#define IDS_PUBLIC_KEY_POLICIES_NODE_NAME 197
#define IDD_ACR_SETUP_WELCOME           198
#define IDS_SAFER_LEVELS_NODE_NAME      198
#define IDS_SAFER_ENTRIES_NODE_NAME     199
#define IDS_COLUMN_NAME                 200
#define IDC_PERSONAL_ACCT               201
#define IDS_COLUMN_DESCRIPTION          201
#define IDC_SERVICE_ACCT                202
#define IDS_COLUMN_TYPE                 202
#define IDC_MACHINE_ACCT                203
#define IDS_COLUMN_LEVEL                203
#define IDS_COLUMN_LAST_MODIFIED_DATE   204
#define IDS_ENROLL                      205
#define IDS_NEW_PATH_RULE               206
#define IDS_RENEW_NEW_KEY               207
#define IDS_RENEW_NEW_KEY_HINT          208
#define IDS_RENEW_SAME_KEY              209
#define IDS_RENEW_SAME_KEY_HINT         210
#define IDS_REQUEST_CERT_SAME_KEY       211
#define IDS_RENEW_CERT_SAME_KEY         212
#define IDS_IMPORT                      213
#define IDS_IMPORT_HINT                 214
#define IDS_EXPORT                      215
#define IDS_EXPORT_HINT                 216
#define IDC_STORE_LIST                  216
#define IDC_CONTAINS_TEXT               217
#define IDS_NEW_AUTO_CERT_REQUEST       217
#define IDI_CERTIFICATE                 218
#define IDC_FIELD_LIST                  218
#define IDS_NEW_AUTO_CERT_REQUEST_HINT  218
#define IDS_CERTMGR_SAFER_WINDOWS_DESC  219
#define IDS_SAFER_WINDOWS_NODE_NAME     220
#define IDC_CERTS_TAB                   221
#define IDC_FIND_NOW                    222
#define IDS_SAFER_PATH_CONTAINS_INVALID_CHARS 222
#define IDC_STOP                        223
#define IDC_NEW_SEARCH                  224
#define IDC_RESULT_LIST                 225
#define IDS_SAFER_SET_DEFAULT           225
#define IDC_ANIMATE                     226
#define IDS_SAFER_SET_DEFAULT_HINT      226
#define IDC_VIEW_BY_PURPOSE             227
#define IDS_NEW_HASH_RULE               228
#define IDS_MS_CERT_MGR                 229
#define IDS_NEW_CERTIFICATE_RULE        231
#define IDS_COLUMN_SUBJECT              233
#define IDS_COLUMN_EXPIRATION_DATE      234
#define IDS_VIEW                        235
#define IDS_VIEW_HINT                   236
#define IDS_FIND                        237
#define IDS_FIND_HINT                   238
#define IDS_PRECEDENCE_TABLE_GPO_NAME   239
#define IDS_PRECEDENCE_TABLE_SETTING    240
#define IDS_ENROLL_NEW_CERT             241
#define IDS_ENROLL_NEW_CERT_HINT        242
#define IDS_ENABLED                     243
#define IDS_DISABLED                    244
#define IDD_PROPPAGE_CHOOSE_ACCOUNT     245
#define IDS_COLUMN_EFFECTIVE_DATE       245
#define IDD_PROPPAGE_CHOOSE_SERVICE     246
#define IDS_SCOPE_SNAPIN_TITLE_USER     246
#define IDS_CANT_SET_AS_DEFAULT         247
#define IDS_NOT_AVAILABLE               248
#define IDD_FIND                        248
#define IDS_COLUMN_FRIENDLY_NAME        249
#define IDS_COLUMN_PURPOSE              250
#define IDS_SAFER_NEW_ENTRY_PATH        251
#define IDB_CERTIFICATE                 252
#define IDS_SAFER_NEW_ENTRY_PATH_HINT   252
#define IDS_CERTIFICATES                253
#define IDR_FIND_DLG_MENU               253
#define IDS_ISSUED_TO                   254
#define IDB_CERTIFICATE_SMALL           254
#define IDS_ISSUED_BY                   255
#define IDB_CERTIFICATE_LARGE           255
#define IDS_SAFER_NEW_ENTRY_HASH        256
#define IDS_SNAPINABOUT_PROVIDER        257
#define IDR_FIND_DLG_CONTEXT_MENU       257
#define IDS_SNAPINABOUT_VERSION         258
#define IDS_SNAPINABOUT_DESCRIPTION     259
#define IDS_COLUMN_NEXT_UPDATE          260
#define IDS_FIND_SUBJECT_NAME           261
#define IDS_FIND_ISSUER_NAME            262
#define IDS_SAFER_NEW_ENTRY_CERTIFICATE_HINT 263
#define IDS_SAFER_NEW_ENTRY_INTERNET_ZONE 264
#define IDS_SAFER_NEW_ENTRY_INTERNET_ZONE_HINT 265
#define IDS_ALL_STORES                  266
#define IDS_SAFER_NEW_ENTRY_CERTIFICATE 267
#define IDS_FIND_CERT                   268
#define IDS_CLEAR_SEARCH                269
#define IDS_SEARCHING                   270
#define IDS_1_CERT_FOUND                271
#define IDS_NO_CERTS_FOUND              272
#define IDS_X_CERTS_FOUND               273
#define IDS_FIND_MD5_HASH               274
#define IDS_FIND_SHA1_HASH              275
#define IDI_CTL                         276
#define IDC_POLICY_PRECEDENCE           276
#define IDS_COLUMN_SOURCE_STORE         276
#define IDS_SAFER_NEW_ENTRY_HASH_HINT   277
#define IDI_CRL                         277
#define IDS_EXPORT_STORE                278
#define IDS_EXPORT_STORE_HINT           279
#define IDC_ACCT_NAME                   280
#define IDD_AUTO_CERT_REQUEST_GENERAL   280
#define IDS_CTL_EXPORT_HINT             281
#define IDC_BROWSE                      281
#define IDS_CTL_VIEW_HINT               282
#define IDC_INSTRUCTIONS                282
#define IDD_ACR_SETUP_TYPE              282
#define IDS_ANY                         283
#define IDS_NONE                        284
#define IDD_ACR_SETUP_FINAL             284
#define IDS_COLUMN_OBJECT_TYPE          285
#define IDD_GPE_GENERAL                 285
#define IDS_COLUMN_PHYS_CERTIFICATE_STORE 286
#define IDC_CERT_TYPE                   286
#define IDS_SCOPE_SNAPIN_TITLE_CERT_MGR_CURRENT_USER 287
#define IDS_CERTIFICATE_MANAGER_REGISTRY 288
#define IDC_CERT_PURPOSES               288
#define IDS_CERTIFICATE_TRUST_LISTS     290
#define IDC_CA_LIST                     290
#define IDS_EDIT                        291
#define IDS_CTL_EDIT_HINT               292
#define IDS_NEW_CTL                     293
#define IDS_NEW_CTL_HINT                294
#define IDC_CERT_TYPES                  294
#define IDS_DUPLICATE_CERT              295
#define IDC_USE_SMARTCARD               295
#define IDC_TRUST_ONLY_ENTERPRISE_ROOTS 295
#define IDC_SHOW_PHYSICAL               295
#define IDS_DUPLICATE_CTL               296
#define IDC_BOLD_STATIC                 296
#define IDS_DUPLICATE_CRL               297
#define IDC_CHOICES_LIST                299
#define IDS_ENROLL_CERT_WITH_NEW_KEY    299
#define IDS_ENROLL_CERT_WITH_NEW_KEY_HINT 300
#define IDC_STATICB_BOLD                300
#define IDS_CONFIRM_DELETE_ROOT_CERT    301
#define IDS_CONFIRM_DELETE_CA_CERT      302
#define IDC_ENABLE_USER_ROOT_STORE      302
#define IDS_CONFIRM_DELETE_MY_CERT      303
#define IDC_PASSWORD1                   303
#define IDS_CONFIRM_DELETE_CTL          304
#define IDC_PASSWORD2                   304
#define IDS_CONFIRM_DELETE_CRL          305
#define IDS_SELECT_SERVICE_ON_LOCAL_MACHINE 306
#define IDS_NO_PRIVATE_KEY              307
#define IDS_WARNING_CERT_COPY_W_PRIVATE_KEY 308
#define IDC_VIEW_BY_STORE               308
#define IDS_CERTIFICATE_COPY            309
#define IDC_SHOW_ARCHIVED               309
#define IDS_DOMAIN_ROOT_CERT_AUTHS_NODE_NAME 310
#define IDS_ENCRYPTING_FILE_SYSTEM_NODE_NAME 311
#define IDS_ADD_DATA_RECOVERY_AGENT     312
#define IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT 314
#define IDC_EDIT1                       314
#define IDC_SAFER_LEVEL_DESCRIPTION     314
#define IDC_DEFINED_FILE_TYPE_EDIT      314
#define IDC_CERT_ENTRY_SUBJECT_NAME     314
#define IDC_HASH_HASHED_FILE_PATH       314
#define IDS_CREATE                      315
#define IDC_BIGBOLD                     315
#define IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT 316
#define IDS_AUTOMATIC_CERT_REQUEST_SETTINGS_NODE_NAME 317
#define IDC_VIEW_MODE_GROUP             317
#define IDS_ENCRYPTED_RECOVERY_AGENT    320
#define IDS_ACRS_WIZARD_SHEET_CAPTION   322
#define IDS_CERTIFICATE_TYPE_COLUMN_NAME 323
#define IDS_PURPOSES_ALLOWED_COLUMN_NAME 324
#define IDS_ADD_RECOVERY_AGENTY         325
#define IDS_USER_OBJECT_HAS_NO_CERTS    326
#define IDS_COLUMN_SERIAL_NUMBER        327
#define IDI_AUTO_CERT_REQUEST           328
#define IDD_PASSWORD                    329
#define IDS_MUST_SELECT_CERT_TYPE       338
#define IDS_COLUMN_AUTO_CERT_REQUEST    340
#define IDS_CONFIRM_DELETE_ACR          341
#define IDS_EFS_FILE_HAS_NO_EFS_USAGE   342
#define IDS_EXPORT_AND_DELETE_EFS_KEY   343
#define IDS_CREATE_AUTO_CERT_REQUEST    344
#define IDS_PASSWORDS_DONT_MATCH        345
#define IDS_SET_PASSWORD                346
#define IDS_CANCEL_NO_CREATE_PFX        347
#define IDS_ERROR_RETRIEVING_SELECTED_CERT_TYPE 348
#define IDS_FILE_ENCRYPTION_OID_FRIENDLY_NAME 349
#define IDS_FILE_RECOVERY_OID_FRIENDLY_NAME 350
#define IDS_CERTMGR_REGISTRATION        352
#define IDS_CERTIFICATE_AUTHORITIES     354
#define IDS_ERROR_READING_ACR_PURPOSES  357
#define IDS_ERROR_READING_ACR_CERTTYPE  358
#define IDS_ACR_EDIT_HINT               361
#define IDS_CRL_VIEW_HINT               362
#define IDS_CRL_EXPORT_HINT             363
#define IDS_SMALLFONTNAME               364
#define IDS_SMALLFONTSIZE               365
#define IDS_REGISTER_CERTMGR            366
#define IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTMGR 367
#define IDS_ACRS_TYPE_TITLE             368
#define IDS_ACRS_TYPE_SUBTITLE          369
#define IDS_EFS_LOCATE_TITLE            372
#define IDB_ACRS_BANNER                 373
#define IDS_EFS_LOCATE_SUBTITLE         373
#define IDB_ACRS_WATERMARK              374
#define IDS_MUST_ADD_RECOVERY_AGENT     374
#define IDS_UNABLE_TO_OPEN_STORE        375
#define IDB_RECOVERY_WATERMARK          375
#define IDS_UNABLE_TO_OPEN_EFS_STORE    376
#define IDB_RECOVERY_BANNER             376
#define IDS_SAVE_PFX_FILTER             377
#define IDD_VIEW_OPTIONS                377
#define IDI_CERTMGR                     379
#define IDS_WARNING_MULTI_CERT_COPY_W_PRIVATE_KEY_MULTI 380
#define IDB_CERTMGR_SMALL               380
#define IDS_CONFIRM_DELETE_ROOT_MULTI_CERT 381
#define IDB_CERTMGR_LARGE               381
#define IDS_CONFIRM_DELETE_CA_MULTI_CERT 382
#define IDS_CONFIRM_DELETE_MY_MULTI_CERT 383
#define IDR_WHATS_THIS_CONTEXT_MENU1    383
#define IDS_CONFIRM_DELETE_MULTI        384
#define IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE 385
#define IDS_CERT_MGR_SCE_EXTENSION_REGISTRY 386
#define IDS_OPTIONS                     387
#define IDS_OPTIONS_HINT                388
#define IDS_CANT_SAVE_STORE             390
#define IDS_STATUS                      391
#define IDS_NO_POLICY_DEFINED           392
#define IDS_INIT_POLICY                 393
#define IDS_INIT_POLICY_HINT            394
#define IDS_DEL_POLICY                  395
#define IDS_DEL_POLICY_HINT             396
#define IDS_CONFIRM_DELETE_EFS_POLICY   397
#define IDS_STATUS_NO_CERTS             398
#define IDS_STATUS_ONE_CERT             399
#define IDS_STATUS_X_CERTS              400
#define IDS_STATUS_NO_CERTS_USAGE       401
#define IDS_STATUS_ONE_CERT_USAGE       402
#define IDS_STATUS_X_CERTS_USAGE        403
#define IDS_COLUMN_STATUS               404
#define IDS_CERTMGR_CHM_NOT_FOUND       405
#define IDS_STATUS_NO_AUTOENROLLMENT_OBJECTS 406
#define IDS_STATUS_ONE_AUTOENROLLMENT_OBJECT 407
#define IDS_STATUS_X_AUTOENROLLMENT_OBJECTS 408
#define IDS_STATUS_NO_CTLS              409
#define IDS_STATUS_ONE_CTL              410
#define IDS_STATUS_X_CTLS               411
#define IDS_CERT_COULD_NOT_BE_VALIDATED 412
#define IDS_UNKNOWN_CERT_FILE_TYPE      413
#define IDS_SNAPINPKPABOUT_DESCRIPTION  418
#define IDM_VIEW_LIST                   419
#define IDM_VIEW_DETAILS                420
#define IDS_CONFIRM_DELETE              421
#define ID_ENROLL_SAME_KEY              422
#define IDS_CONFIRM_DELETE_MULTIPLE     423
#define ID_FILE_RENEW_NEW_KEY           424
#define IDS_CERTIFICATE_MANAGER         425
#define ID_FILE_RENEW_SAME_KEY          426
#define IDS_CERTIFICATE_REVOCATION_LIST 427
#define ID_ENROLL_NEW_KEY               428
#define IDS_CERTIFICATE_TRUST_LIST      429
#define IDM_WHATS_THIS                  430
#define IDS_ENROLL_CERT_WITH_SAME_KEY   431
#define IDS_ENROLL_CERT_WITH_SAME_KEY_HINT 432
#define IDS_SCOPE_SNAPIN_TITLE_FILE     433
#define IDS_CANT_OPEN_STORE_AND_FAIL    435
#define IDS_CHANGE_COMPUTER             436
#define IDS_CHANGE_COMPUTER_HINT        437
#define IDS_SCOPE_SNAPIN_TITLE_SERVICE_LOCAL_MACHINE 438
#define IDS_NO_PERMISSION               439
#define IDS_CANT_ENUMERATE_SYSTEM_STORES 440
#define IDS_CANT_DELETE_CERT_FROM_SYSTEM_STORE 441
#define IDD_POLICY_PRECEDENCE           441
#define IDC_RADIO1                      441
#define IDC_AUTOENROLL_DISABLE_ALL      441
#define IDC_TP_BY_END_USER              441
#define IDC_SET_DISABLE_LM_AUTH_FLAG    441
#define IDC_ALL_EXCEPT_LIBS             441
#define IDC_RADIO2                      442
#define IDC_AUTOENROLL_ENABLE           442
#define IDD_SAFER_LEVEL_GENERAL         442
#define IDS_URLZONE_TRUSTED             442
#define IDC_TP_BY_LOCAL_COMPUTER_ADMIN  442
#define IDC_CERT_ENTRY_ALL_FILES        442
#define IDC_UNSET_DISABLE_LM_AUTH_FLAG  442
#define IDC_ALL_SOFTWARE_FILES          442
#define IDC_CHECK1                      443
#define IDC_AUTOENROLL_ENABLE_PENDING   443
#define IDI_AUTOENROLL                  443
#define IDD_SAFER_ENTRY_PATH            443
#define IDS_URLZONE_INTERNET            443
#define IDC_TP_REV_CHECK_PUBLISHER      443
#define IDC_SAFER_LEVEL_STATUS          443
#define IDC_TURN_ON_EFS                 443
#define IDC_CHECK2                      444
#define IDC_AUTOENROLL_ENABLE_TEMPLATE  444
#define IDI_SAFER_LEVEL                 444
#define IDD_SAFER_ENTRY_HASH            444
#define IDS_URLZONE_UNTRUSTED           444
#define IDC_TP_REV_CHECK_TIMESTAMP      444
#define IDC_CHECK3                      445
#define IDS_URLZONE_LOCAL_MACHINE       445
#define IDI_DEFAULT_SAFER_LEVEL         445
#define IDD_SAFER_ENTRY_INTERNET_ZONE   445
#define IDC_AUTOENROLL_BLOCK_USER_DS_STORE_HINT1 446
#define IDD_SAFER_ENTRY_CERTIFICATE     446
#define IDS_URLZONE_INTRANET            446
#define IDC_AUTOENROLL_BLOCK_USER_DS_STORE_HINT2 447
#define IDI_SAFER_HASH_ENTRY            447
#define IDS_URLZONE_UNKNOWN             447
#define IDD_SAFER_DEFINED_FILE_TYPES    447
#define IDC_SAFER_LEVEL_NAME            448
#define IDI_SAFER_URL_ENTRY             448
#define IDS_CodeIdentityType_ImageName  448
#define IDD_SAFER_TRUSTED_PUBLISHER     448
#define IDI_SAFER_HASH_NAME             449
#define IDI_SAFER_NAME_ENTRY            449
#define IDS_CodeIdentityType_ImageHash  449
#define IDC_TP_BY_ENTERPRISE_ADMIN      449
#define IDD_SAFER_ENFORCEMENT           449
#define IDS_CodeIdentityType_UrlZone    450
#define IDI_SETTINGS                    450
#define IDC_DEFINED_FILE_TYPES          450
#define IDD_EFS_GENERAL                 450
#define IDS_CodeIdentityType_Certificate 451
#define IDC_DELETE_DEFINED_FILE_TYPE    451
#define IDS_SAFER_TRUSTED_PUBLISHERS    452
#define IDC_ADD_DEFINED_FILE_TYPE       452
#define IDI_SAFER_CERT_ENTRY            452
#define IDS_SAFER_DEFINED_FILE_TYPES    453
#define IDC_CERT_ENTRY_BROWSE           453
#define IDI_SAFER_WINDOWS_SNAPIN        453
#define IDC_CERT_ENTRY_SECURITY_LEVEL   454
#define IDB_SAFERWINDOWS_LARGE          454
#define IDC_CERT_ENTRY_ONLY_DEFINED_FILE_TYPES 455
#define IDC_CERT_ENTRY_END_USER_NOTIFICATION 456
#define IDC_CERT_ENTRY_DESCRIPTION      457
#define IDS_SAFER_PATH_ENTRY_FILE_FILTER 457
#define IDC_CERT_ENTRY_LAST_MODIFIED    458
#define IDS_URLZONE_LOCAL_MACHINE_DESCRIPTION 458
#define IDC_PATH_ENTRY_PATH             459
#define IDS_URLZONE_INTRANET_DESCRIPTION 459
#define IDS_URLZONE_TRUSTED_DESCRIPTION 460
#define IDC_PATH_ENTRY_SECURITY_LEVEL   461
#define IDS_URLZONE_INTERNET_DESCRIPTION 461
#define IDS_URLZONE_UNTRUSTED_DESCRIPTION 462
#define IDS_SAFER_PATH_EMPTY            463
#define IDC_PATH_ENTRY_END_USER_NOTIFICATION 464
#define IDC_PATH_ENTRY_DESCRIPTION      465
#define IDS_CANT_DELETE_SAFER_ENTRY     465
#define IDC_PATH_ENTRY_LAST_MODIFIED    466
#define IDS_CONFIRM_DELETE_SAFER_ENTRY  466
#define IDC_HASH_ENTRY_HASHFILE_DETAILS 467
#define IDS_CONFIRM_DELETE_MULTI_SAFER_ENTRY 467
#define IDC_PATH_ENTRY_BROWSE           467
#define IDC_HASH_ENTRY_BROWSE           468
#define IDS_CANNOT_HASH_FILE            468
#define IDC_HASH_ENTRY_SECURITY_LEVEL   469
#define IDS_NO_APPLICATION_SELECTED     469
#define IDS_FILE_CANNOT_BE_READ         470
#define IDS_CANNOT_GET_FILESIZE         471
#define IDS_ERROR_SAVING_ENTRY          472
#define IDC_HASH_ENTRY_DESCRIPTION      473
#define IDS_FT_EXTENSIONS               473
#define IDC_HASH_ENTRY_LAST_MODIFIED    474
#define IDS_FT_FILE_TYPES               474
#define IDC_IZONE_ENTRY_ZONES           475
#define IDS_CONFIRM_DELETE_FILE_TYPE    475
#define IDC_IZONE_ENTRY_SECURITY_LEVEL  476
#define IDS_CONFIRM_DELETE_FILE_TYPE_MULTIPLE 476
#define IDS_FILE_TYPE_ALREADY_IN_LIST   477
#define IDS_BYTES                       478
#define IDC_IZONE_ENTRY_END_USER_NOTIFICATION 479
#define IDS_KB                          479
#define IDC_IZONE_ENTRY_DESCRIPTION     480
#define IDS_IS_DEFAULT_LEVEL            480
#define IDC_IZONE_ENTRY_LAST_MODIFIED   481
#define IDS_DEFAULT_LEVEL_CHANGE_WARNING 481
#define IDC_BUTTON1                     482
#define IDC_SAFER_CERT_VIEW             482
#define IDC_SAFER_LEVEL_SET_AS_DEFAULT  483
#define IDS_SELECT_A_FOLDER             484
#define IDS_FILE_CONTAINS_NO_CERT       485
#define IDC_HASH_INSTRUCTIONS           485
#define IDS_SAFER_CERTFILEFILTER        486
#define IDC_HASH_TITLE                  486
#define IDS_HASH_STRING_INVALID_CHAR    487
#define IDS_HASH_STRING_TOO_LONG        488
#define IDS_HASH_TITLE                  489
#define IDS_NEW_URLZONE_RULE            490
#define IDC_DATE_LAST_MODIFIED_LABEL    491
#define IDS_URLZONE_TITLE               491
#define IDC_URLZONE_TITLE               492
#define IDS_PATH_TITLE                  492
#define IDC_PATH_TITLE                  493
#define IDS_CERTIFICATE_TITLE           493
#define IDC_CERTIFICATE_TITLE           494
#define IDS_HASH_INVALID_LENGTH         494
#define IDS_PULSEAUTOENROLL             495
#define IDS_PULSEAUTOENROLL_HINT        496
#define IDS_CANT_OPEN_AUTOENROLL_EVENT  497
#define IDS_CANT_SET_CONSTRAINED_AS_DEFAULT 498
#define IDS_FILE                        499
#define IDC_LEVEL_INSTRUCTIONS          501
#define IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG 502
#define IDS_SAFER_ENFORCEMENT           502
#define IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG 503
#define IDS_HASH_STRING_BAD_FORMAT      503
#define IDS_SHBROWSEFORFOLDER_TITLE     504
#define IDS_CAN_SET_SAFER_ENFORCEMENT   505
#define IDC_APPLY_TO_ALL_USERS          505
#define IDS_CANT_DELETE_OBJECT_PAGES_OPEN 506
#define IDC_APPLY_EXCEPT_ADMINS         506
#define IDS_USER_MUST_ENTER_HASH        507
#define IDS_CANT_CHANGE_DEFAULT_PAGES_OPEN 508
#define IDS_CANT_REFRESH_PAGES_OPEN     509
#define IDS_ZERO_BYTE_FILE_CANNOT_HASH  510
#define IDS_COLUMN_TEMPLATE_NAME        511
#define IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY 512
#define IDS_SAFER_NOT_SUPPORTED         513
#define IDS_CANNOT_SET_EFS_VALUE        514
#define IDS_FIND_CLICK_STOP_BEFORE_CLOSING 515
#define IDS_NEW_SAFER_POLICY            516
#define IDS_NEW_SAFER_POLICY_HINT       517
#define IDS_SAFER_NO_POLICY_TITLE       518
#define IDS_SAFER_NO_POLICY_TEXT        519
#define IDS_DESIGNATED_FILE_TYPES_NOT_FOUND 520
#define IDS_NO_CERT_TEMPLATES_INSTALLED 521
#define IDS_CANNOT_OPEN_CERT_STORE_TO_FIND_CERT_BY_PURPOSE 522
#define IDS_CERT_CANNOT_BE_PASTED_CANT_OPEN_STORE 523
#define IDC_BROWSE_DIR                  1003
#define IDC_BROWSE_FILE                 1004
#define IDC_ADDLIST                     1005
#define IDC_WIZARD_STATIC_BIG_BOLD1     1008
#define IDS_LARGEFONTNAME               6157
#define IDS_LARGEFONTSIZE               6158
#define ID_FILE_RENEW                   32768
#define ID_FILE_EXPORT                  32769
#define ID_FILE_DELETE                  32770
#define ID_FILE_PROPERTIES              32771
#define ID_EDIT_SELECTALL               32773
#define ID_EDIT_INVERTSELECTION         32774
#define ID_VIEW_LARGEICONS              32775
#define ID_VIEW_SMALLICONS              32776
#define ID_HELP_HELPTOPICS              32779
#define IDM_PROPERTIES                  32782
#define ID_VIEW                         32786
#define IDS_CANT_ADD_CERT               32787
#define IDS_SAFER_MUST_CHOOSE_CERT      32788

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        502
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         507
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferdefinedfiletypespropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferDefinedFileTypesPropertyPage.h
//
//  Contents:   Declaration of CSaferDefinedFileTypesPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERDEFINEDFILETYPESPROPERTYPAGE_H__1358E7A4_DE44_4747_A5AA_38EF0C3EEE1A__INCLUDED_)
#define AFX_SAFERDEFINEDFILETYPESPROPERTYPAGE_H__1358E7A4_DE44_4747_A5AA_38EF0C3EEE1A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferDefinedFileTypesPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaferDefinedFileTypesPropertyPage dialog

class CSaferDefinedFileTypesPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CString GetFileTypeDescription (PCWSTR pszExtension);
	CSaferDefinedFileTypesPropertyPage(
            IGPEInformation* pGPEInformation,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputerType);
	~CSaferDefinedFileTypesPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferDefinedFileTypesPropertyPage)
	enum { IDD = IDD_SAFER_DEFINED_FILE_TYPES };
	CButton	m_addButton;
	CEdit	m_fileTypeEdit;
	CListCtrl	m_definedFileTypes;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferDefinedFileTypesPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void GetRSOPDefinedFileTypes();
    void DisplayExtensions (PWSTR pszExtensions, size_t nBytes);
    HRESULT GetFileTypeIcon (PCWSTR pszExtension, int* piIcon);
	// Generated message map functions
	//{{AFX_MSG(CSaferDefinedFileTypesPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDeleteDefinedFileType();
	afx_msg void OnAddDefinedFileType();
	afx_msg void OnItemchangedDefinedFileTypes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeDefinedFileTypeEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);

private:
    int  InsertItemInList(PCWSTR pszExtension);
	void GetDefinedFileTypes();

    IGPEInformation*	                m_pGPEInformation;
    HKEY                                m_hGroupPolicyKey;
    DWORD                               m_dwTrustedPublisherFlags;
    bool                                m_fIsComputerType;
    CImageList                          m_systemImageList;
    bool                                m_bSystemImageListCreated;
    const bool                          m_bReadOnly;
    CRSOPObjectArray&                   m_rsopObjectArray;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERDEFINEDFILETYPESPROPERTYPAGE_H__1358E7A4_DE44_4747_A5AA_38EF0C3EEE1A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferdefinedfiletypespropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferDefinedFileTypesPropertyPage.h
//
//  Contents:   Declaration of CSaferDefinedFileTypesPropertyPage
//
//----------------------------------------------------------------------------
// SaferDefinedFileTypesPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certmgr.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferDefinedFileTypesPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {
    COL_EXTENSIONS = 0,
    COL_FILETYPES,
    NUM_COLS
};

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

const UINT MAX_EXTENSION_LENGTH = 128;

/////////////////////////////////////////////////////////////////////////////
// CSaferDefinedFileTypesPropertyPage property page

CSaferDefinedFileTypesPropertyPage::CSaferDefinedFileTypesPropertyPage(
            IGPEInformation* pGPEInformation,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputer) 
    : CHelpPropertyPage(CSaferDefinedFileTypesPropertyPage::IDD),
    m_pGPEInformation (pGPEInformation),
    m_hGroupPolicyKey (0),
    m_dwTrustedPublisherFlags (0),
    m_fIsComputerType (bIsComputer),
    m_bReadOnly (bReadOnly),
    m_rsopObjectArray (rsopObjectArray)
{
    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        HRESULT hr = m_pGPEInformation->GetRegistryKey (
                m_fIsComputerType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hr));
    }
}

CSaferDefinedFileTypesPropertyPage::~CSaferDefinedFileTypesPropertyPage()
{
    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
    }

    m_systemImageList.Detach ();
}

void CSaferDefinedFileTypesPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferDefinedFileTypesPropertyPage)
	DDX_Control(pDX, IDC_ADD_DEFINED_FILE_TYPE, m_addButton);
	DDX_Control(pDX, IDC_DEFINED_FILE_TYPE_EDIT, m_fileTypeEdit);
	DDX_Control(pDX, IDC_DEFINED_FILE_TYPES, m_definedFileTypes);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferDefinedFileTypesPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferDefinedFileTypesPropertyPage)
	ON_BN_CLICKED(IDC_DELETE_DEFINED_FILE_TYPE, OnDeleteDefinedFileType)
	ON_BN_CLICKED(IDC_ADD_DEFINED_FILE_TYPE, OnAddDefinedFileType)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_DEFINED_FILE_TYPES, OnItemchangedDefinedFileTypes)
	ON_EN_CHANGE(IDC_DEFINED_FILE_TYPE_EDIT, OnChangeDefinedFileTypeEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferDefinedFileTypesPropertyPage message handlers
void CSaferDefinedFileTypesPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CAutoenrollmentPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_DEFINED_FILE_TYPES, IDH_DEFINED_FILE_TYPES,
        IDC_DELETE_DEFINED_FILE_TYPE, IDH_DELETE_DEFINED_FILE_TYPE,
        IDC_DEFINED_FILE_TYPE_EDIT, IDH_DEFINED_FILE_TYPE_EDIT,
        IDC_ADD_DEFINED_FILE_TYPE, IDH_ADD_DEFINED_FILE_TYPE,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CAutoenrollmentPropertyPage::DoContextHelp\n");
}


BOOL CSaferDefinedFileTypesPropertyPage::OnApply() 
{
    BOOL bRVal = TRUE;

	if ( m_definedFileTypes.m_hWnd && m_pGPEInformation )
	{
        int nCharacters = 0;
		int	nCnt = m_definedFileTypes.GetItemCount ();
		
        if ( nCnt > 0 )
        {
            // iterate through and count the desired lengths
	        while (--nCnt >= 0)
	        {
                CString szText = m_definedFileTypes.GetItemText (nCnt, COL_EXTENSIONS);
                nCharacters += szText.GetLength () + 1;
	        }

            PWSTR   pszItems = (PWSTR) ::LocalAlloc (LPTR, nCharacters * sizeof (WCHAR));
            if ( pszItems )
            {
                PWSTR   pszPtr = pszItems;
                nCnt = m_definedFileTypes.GetItemCount ();

	            while (--nCnt >= 0)
	            {
                    CString szText = m_definedFileTypes.GetItemText (nCnt, COL_EXTENSIONS);
                    wcscpy (pszPtr, szText);
                    pszPtr += szText.GetLength () + 1;
	            }

                HRESULT hr = SaferSetDefinedFileTypes (m_hWnd, m_hGroupPolicyKey,
                            pszItems, nCharacters * sizeof (WCHAR));
                if ( SUCCEEDED (hr) )
                {
			        // TRUE means we're changing the machine policy only
                    m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                            TRUE, &g_guidExtension, &g_guidSnapin);
                    m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                            TRUE, &g_guidRegExt, &g_guidSnapin);
                }
                else
                    bRVal = FALSE;
                ::LocalFree (pszItems);
            }
        }
        else
        {
            HRESULT hr = SaferSetDefinedFileTypes (m_hWnd, m_hGroupPolicyKey, 0, 0);
            if ( FAILED (hr) )
                bRVal = FALSE;
        }
		
		GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
	}

    if ( bRVal )
    {
	    return CHelpPropertyPage::OnApply();
    }
    else
        return FALSE;
}

BOOL CSaferDefinedFileTypesPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	

    int	colWidths[NUM_COLS] = {100, 200};

	SHFILEINFO sfi;
	memset(&sfi, 0, sizeof(sfi));
	HIMAGELIST hil = reinterpret_cast<HIMAGELIST> (
		SHGetFileInfo (
			L"C:\\", 
			0, 
			&sfi, 
			sizeof(sfi), 
			SHGFI_SYSICONINDEX | SHGFI_SMALLICON)
	);
    ASSERT (hil);
	if (hil)
	{
		m_systemImageList.Attach (hil);
		m_definedFileTypes.SetImageList (&m_systemImageList, LVSIL_SMALL);
	}

	// Add "Extensions" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_FT_EXTENSIONS));
	VERIFY (m_definedFileTypes.InsertColumn (COL_EXTENSIONS, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_EXTENSIONS], COL_EXTENSIONS) != -1);

	// Add "File Types" column
	VERIFY (szText.LoadString (IDS_FT_FILE_TYPES));
	VERIFY (m_definedFileTypes.InsertColumn (COL_FILETYPES, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_FILETYPES], COL_FILETYPES) != -1);
    m_definedFileTypes.SetColumnWidth (COL_FILETYPES, LVSCW_AUTOSIZE_USEHEADER);

    // Set to full-row select
    DWORD   dwExstyle = m_definedFileTypes.GetExtendedStyle ();
	m_definedFileTypes.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT);

    if ( m_pGPEInformation && m_hGroupPolicyKey )
        GetDefinedFileTypes ();
    else
        GetRSOPDefinedFileTypes ();

    GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
    GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (FALSE);

    if ( m_bReadOnly )
    {
        m_fileTypeEdit.EnableWindow (FALSE); 
        GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
    }

    m_fileTypeEdit.SetLimitText (MAX_EXTENSION_LENGTH);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSaferDefinedFileTypesPropertyPage::DisplayExtensions (PWSTR pszExtensions, size_t nBytes)
{
    if ( pszExtensions )
    {
        size_t  bytesRead = 0;

        while (bytesRead < nBytes)
        {
            size_t nLen = wcslen (pszExtensions) + 1;
            if ( nLen > 1 )
            {
                InsertItemInList (pszExtensions);
                pszExtensions += nLen;
                bytesRead += nLen * sizeof (WCHAR);
            }
            else
                break;  // was last one
        }
    }
}

void CSaferDefinedFileTypesPropertyPage::GetRSOPDefinedFileTypes()
{
    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            if ( pObject->GetRegistryKey () == SAFER_COMPUTER_CODEIDS_REGKEY &&
                    pObject->GetValueName () == SAFER_EXETYPES_REGVALUE )
            {
                DisplayExtensions ((PWSTR) pObject->GetBlob (), pObject->GetBlobLength ());
            }
        }
        else
            break;

        nIndex++;
    }
}

void CSaferDefinedFileTypesPropertyPage::GetDefinedFileTypes()
{
    DWORD   dwDisposition = 0;

    HKEY    hKey = 0;
    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            SAFER_COMPUTER_CODEIDS_REGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (ERROR_SUCCESS == lResult);
    if ( ERROR_SUCCESS == lResult )
    {

        // Read value
        DWORD   dwType = REG_MULTI_SZ;
        DWORD   cbData = 0;
        lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
		        SAFER_EXETYPES_REGVALUE,  // address of name of value to query
			    0,              // reserved
	            &dwType,        // address of buffer for value type
		        0,       // address of data buffer
			    &cbData);           // address of data buffer size);

        if ( ERROR_SUCCESS == lResult )
		{
            PBYTE   pData = (PBYTE) ::LocalAlloc (LPTR, cbData);
            if ( pData )
            {
                lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
		                SAFER_EXETYPES_REGVALUE,  // address of name of value to query
			            0,              // reserved
	                &dwType,        // address of buffer for value type
		            pData,       // address of data buffer
			        &cbData);           // address of data buffer size);
		        ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
                if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		        {
                    DisplayExtensions ((PWSTR) pData, cbData);
		        }
                else
                    DisplaySystemError (m_hWnd, lResult);

                ::LocalFree (pData);
            }
        }
        else 
        {
            CString caption;
            CString text;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_DESIGNATED_FILE_TYPES_NOT_FOUND, 
                    GetSystemMessage (lResult));
            MessageBox (text, caption, MB_OK);
        }

        RegCloseKey (hKey);
    }
    else
        DisplaySystemError (m_hWnd, lResult);
}

int CSaferDefinedFileTypesPropertyPage::InsertItemInList(PCWSTR pszExtension)
{
    _TRACE (1, L"CSaferDefinedFileTypesPropertyPage::InsertItemInList\n");

    int nCnt = m_definedFileTypes.GetItemCount ();
	while (--nCnt >= 0)
	{
        CString szText = m_definedFileTypes.GetItemText (nCnt, COL_EXTENSIONS);
        if ( !_wcsicmp (szText, pszExtension) )
        {
            if ( m_pGPEInformation )  
            {
                // is not RSOP.  If RSOP, multiple entries might be added
                // because we're getting the stuff from different policies
                // We don't want a message in that case, we'll just ignore
                // the duplication.
                CString caption;
                CString text;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_FILE_TYPE_ALREADY_IN_LIST, pszExtension);
                MessageBox (text, caption, MB_OK);
            }

            return -1;
        }
	}

	LV_ITEM	lvItem;
	int		iItem = m_definedFileTypes.GetItemCount ();
	int     iResult = 0;
    int     iIcon = 0;

    if ( SUCCEEDED (GetFileTypeIcon (pszExtension, &iIcon)) )
    {
	    ::ZeroMemory (&lvItem, sizeof (lvItem));
	    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
	    lvItem.iItem = iItem;
        lvItem.iSubItem = COL_EXTENSIONS;
	    lvItem.pszText = const_cast <PWSTR> (pszExtension);
	    lvItem.iImage = iIcon;
        lvItem.lParam = 0;
	    iItem = m_definedFileTypes.InsertItem (&lvItem);
	    ASSERT (-1 != iItem);
	    if ( -1 != iItem )
        {
            CString szDescription = GetFileTypeDescription (pszExtension);
	        ::ZeroMemory (&lvItem, sizeof (lvItem));
	        lvItem.mask = LVIF_TEXT;
	        lvItem.iItem = iItem;
            lvItem.iSubItem = COL_FILETYPES;
            lvItem.pszText = const_cast <PWSTR> ((PCWSTR) szDescription);
	        iResult = m_definedFileTypes.SetItem (&lvItem);
	        ASSERT (-1 != iResult);
        }
    }
    else
        iItem = -1;

    _TRACE (-1, L"Leaving CSaferDefinedFileTypesPropertyPage::InsertItemInList\n");
    return iItem;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetFileTypeIcon
//  Purpose:    Return the file icon belonging to the specified extension
//  Inputs:     pszExtension - contains the extension, without a leading period
//  Outputs:    piIcon - the offset into the system image list containing the 
//              file type icon
//  Return:     S_OK if success, error code on failure
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSaferDefinedFileTypesPropertyPage::GetFileTypeIcon (PCWSTR pszExtension, int* piIcon)
{
    HRESULT     hr = S_OK;
    SHFILEINFO  sfi;
    ::ZeroMemory (&sfi, sizeof (sfi));
   
    CString     szExtension (L".");
    szExtension += pszExtension;

    if ( 0 != SHGetFileInfo (
            szExtension, 
            FILE_ATTRIBUTE_NORMAL,
            &sfi, 
            sizeof (SHFILEINFO), 
            SHGFI_USEFILEATTRIBUTES | SHGFI_SMALLICON | SHGFI_ICON) )
    {
        *piIcon = sfi.iIcon;
        DestroyIcon(sfi.hIcon);                
    }
    else
        hr = E_FAIL;

    return hr;
}

void CSaferDefinedFileTypesPropertyPage::OnDeleteDefinedFileType() 
{
	if ( m_definedFileTypes.m_hWnd )
	{
		int				nCnt = m_definedFileTypes.GetItemCount ();
		ASSERT (nCnt >= 1);
		CString			text;
		CString			caption;
		int				nSelCnt = m_definedFileTypes.GetSelectedCount ();
		ASSERT (nSelCnt >= 1);

		VERIFY (text.LoadString (1 == nSelCnt ? IDS_CONFIRM_DELETE_FILE_TYPE : 
                IDS_CONFIRM_DELETE_FILE_TYPE_MULTIPLE));
		VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));

        CThemeContextActivator activator;
		if ( MessageBox (text, caption, MB_ICONWARNING | MB_YESNO) == IDYES )
		{
			UINT	flag = 0;
			while (--nCnt >= 0)
			{
				flag = ListView_GetItemState (m_definedFileTypes.m_hWnd, nCnt, LVIS_SELECTED);
				if ( flag & LVNI_SELECTED )
				{
                    m_definedFileTypes.DeleteItem (nCnt);
				}
			}
    		GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
		}
	}

	SetModified ();
}

void CSaferDefinedFileTypesPropertyPage::OnAddDefinedFileType() 
{
    _TRACE (1, L"Entering CSaferDefinedFileTypesPropertyPage::OnAddDefinedFileType ()\n");
    CString szExtension;

	// Get text, strip off leading "." and whitespace, if present, add to list control, clear text field
    m_fileTypeEdit.GetWindowText (szExtension);
    szExtension.TrimLeft ();
    PWSTR   pszExtension = szExtension.GetBuffer (szExtension.GetLength ());

    if ( pszExtension[0] == L'.' )
        pszExtension++;

    szExtension.ReleaseBuffer ();

    szExtension = pszExtension;

    // strip off trailing whitespace
    szExtension.TrimRight ();

    if ( wcslen (szExtension) > 0 )
    {
        int nItem = InsertItemInList (szExtension);
        if ( -1 != nItem )
        {
            VERIFY (m_definedFileTypes.EnsureVisible (nItem, FALSE));
        }
        SetModified ();
    }


    m_fileTypeEdit.SetWindowText (L"");
    GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (FALSE);

    // Bug 265587 Safer Windows:  Add button on Designated File Types 
    // properties should be the default button when it is enabled.
    //
    // Set the OK button as the default push button
    //
    GetParent()->SendMessage(DM_SETDEFID, IDOK, 0);

    //
    // Force the Add button to redraw itself
    //
    m_addButton.SendMessage(BM_SETSTYLE,
                BS_DEFPUSHBUTTON,
                MAKELPARAM(TRUE, 0));
                   
    //
    // Force the previous default button to redraw itself
    //
    m_addButton.SendMessage (BM_SETSTYLE,
               BS_PUSHBUTTON,
               MAKELPARAM(TRUE, 0));    


    _TRACE (-1, L"Leaving CSaferDefinedFileTypesPropertyPage::OnAddDefinedFileType ()\n");
}

void CSaferDefinedFileTypesPropertyPage::OnItemchangedDefinedFileTypes(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	// NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if ( !m_bReadOnly )
    {
        UINT	nSelCnt = m_definedFileTypes.GetSelectedCount ();
        GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (nSelCnt > 0);
    }
	
	*pResult = 0;
}

void CSaferDefinedFileTypesPropertyPage::OnChangeDefinedFileTypeEdit() 
{
    CString szText;

    m_fileTypeEdit.GetWindowText (szText);
    PWSTR   pszText = szText.GetBuffer (szText.GetLength ());

    while ( iswspace (pszText[0]) )
        pszText++;
    if ( pszText[0] == L'.' )
        pszText++;
    

    GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (0 != pszText[0]); // is not empty

    if ( 0 != pszText[0] )
    {
        // Bug 265587 Safer Windows:  Add button on Designated File Types 
        // properties should be the default button when it is enabled.
        //
        // Set the add button as the default push button
        //
        GetParent()->SendMessage(DM_SETDEFID, (WPARAM)m_addButton.GetDlgCtrlID(), 0);

        //
        // Force the Add button to redraw itself
        //
        m_addButton.SendMessage(BM_SETSTYLE,
                    BS_DEFPUSHBUTTON,
                    MAKELPARAM(TRUE, 0));
                       
        //
        // Force the previous default button to redraw itself
        //
        ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                           IDOK,
                           BM_SETSTYLE,
                           BS_PUSHBUTTON,
                           MAKELPARAM(TRUE, 0));    

        ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                           IDCANCEL,
                           BM_SETSTYLE,
                           BS_PUSHBUTTON,
                           MAKELPARAM(TRUE, 0));    
    }

    szText.ReleaseBuffer ();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetFileTypeDescription
//  Purpose:    Return the file type description belonging to the specified
//              extension
//  Inputs:     pszExtension - contains the extension, without a leading period
//  Return:     the file type
//
///////////////////////////////////////////////////////////////////////////////
CString CSaferDefinedFileTypesPropertyPage::GetFileTypeDescription(PCWSTR pszExtension)
{
    CString     strFPath (L".");
    strFPath += pszExtension;
	SHFILEINFO  sfi;
    ::ZeroMemory (&sfi, sizeof(sfi));

	WCHAR pBuff[MAX_PATH];
	pBuff[0] = L'\0';

	DWORD_PTR   dwRet = SHGetFileInfo (
		strFPath, 
		FILE_ATTRIBUTE_NORMAL, 
		&sfi, 
		sizeof(sfi), 
		SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME);
    if ( !dwRet )
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"SHGetFileInfo (%s) failed: %d\n", dwErr);
    }

	wcscpy (pBuff, sfi.szTypeName);
	if ( pBuff[0] == L'\0')
	{
        CString szText;
        VERIFY (szText.LoadString (IDS_FILE));
        size_t  nLen = wcslen (szText) + 2;

		wcsncpy (pBuff, pszExtension, MAX_PATH - nLen);
        wcscat (pBuff, L" ");
		wcscat (pBuff, szText);
	}

	return pBuff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\rsopobject.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       RSOPObject.cpp
//
//  Contents:   Implementation of CRSOPObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <AutoEnr.h>
#include <winsafer.h>
#include <winsaferp.h>
#include <gpedit.h>
#include "RSOPObject.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CRSOPObject::CRSOPObject (
        const CString& szRegistryKey, 
        const CString& szValueName, 
        const CString& szPolicyName,
        UINT precedence, 
        COleVariant& varValue)
    : CObject (),
    m_szRegistryKey (szRegistryKey),
    m_szValueName (szValueName),
    m_szPolicyName (szPolicyName),
    m_precedence (precedence),
    m_vtType (0),
    m_pbyBlob (0),
    m_sizeArray (0),
    m_bstr (0)
{
    if ( szValueName.IsEmpty () )
    {
        // Do nothing, but avoid all the string comparisons
    }
    else if ( !_wcsicmp (SAFER_IDS_DESCRIPTION_REGVALUE, szValueName) ||
        !_wcsicmp (SAFER_IDS_FRIENDLYNAME_REGVALUE, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_FULLY_TRUSTED, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_NORMAL_USER, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_CONSTRAINED, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_UNTRUSTED, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_DISALLOWED, szValueName) )
    {
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        HRESULT hr = BstrFromVector(pArray, &m_bstr);
        if ( SUCCEEDED (hr) )
        {
            m_vtType = VT_BSTR;
        }
    }
    else if ( !_wcsicmp (SAFER_IDS_LASTMODIFIED_REGVALUE, szValueName) )
    {
        m_vtType = VT_ARRAY;
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        if ( pArray )
        {
            BYTE HUGEP *pByte = 0;

            // Get a pointer to the elements of the array.
            HRESULT hr = SafeArrayAccessData(pArray, (void HUGEP**)&pByte);
            if ( SUCCEEDED (hr) )
            {
                m_sizeArray = pArray->rgsabound->cElements;
                ASSERT (m_sizeArray == sizeof (FILETIME));
                if ( m_sizeArray == sizeof (FILETIME) )
                {
                    memcpy (&m_fileTime, pByte, m_sizeArray);
                }

                SafeArrayUnaccessData (pArray);
            }
        }
    }   
    else if ( !_wcsicmp (STR_BLOBCOUNT, szValueName) ||
            !_wcsicmp (STR_BLOBLENGTH, szValueName) ||
            !_wcsicmp (CERT_PROT_ROOT_FLAGS_VALUE_NAME, szValueName) ||
			!_wcsicmp (AUTO_ENROLLMENT_POLICY, szValueName) ||
            !_wcsicmp (SAFER_IDS_SAFERFLAGS_REGVALUE, szValueName) ||
            !_wcsicmp (CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, szValueName) ||
            !_wcsicmp (SAFER_TRANSPARENTENABLED_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_VALUE_NAME_HASH_SIZE, szValueName) ||
            !_wcsicmp (SAFER_VALUE_NAME_DEFAULT_LEVEL, szValueName) ||
            !_wcsicmp (EFS_SETTINGS_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_POLICY_SCOPE, szValueName) )
    {
        m_vtType = VT_I4;
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        if ( pArray )
        {
            BYTE HUGEP *pByte = 0;

            // Get a pointer to the elements of the array.
            HRESULT hr = SafeArrayAccessData(pArray, (void HUGEP**)&pByte);
            if ( SUCCEEDED(hr) )
            {
				ASSERT (pArray->rgsabound->cElements == sizeof (m_dwValue));
				memcpy (&m_dwValue, pByte, pArray->rgsabound->cElements);
                SafeArrayUnaccessData (pArray);
            }
        }
    }
    else if ( !wcsncmp (STR_BLOB, szValueName, wcslen (STR_BLOB)) ||
            !_wcsicmp (SAFER_IDS_ITEMDATA_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_IDS_ITEMSIZE_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_IDS_HASHALG_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_EXETYPES_REGVALUE, szValueName) )
    {
        // Blob, Blob0, Blob1, etc.
        m_vtType = VT_ARRAY;
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        if ( pArray )
        {
            BYTE HUGEP *pByte = 0;

            // Get a pointer to the elements of the array.
            HRESULT hr = SafeArrayAccessData(pArray, (void HUGEP**)&pByte);
            if ( SUCCEEDED (hr) )
            {
                m_sizeArray = pArray->rgsabound->cElements;
                m_pbyBlob = new BYTE[m_sizeArray];
                if ( m_pbyBlob )
                {
                    memcpy (m_pbyBlob, pByte, m_sizeArray);
                }

                SafeArrayUnaccessData (pArray);
            }
        }
    }
    else if ( !_wcsicmp (CERT_EFSBLOB_VALUE_NAME, szValueName) )
    {
    }
    else
    {
        ASSERT (0);
    }
}

CRSOPObject::CRSOPObject (const CRSOPObject& rObject)
:
    m_szRegistryKey (rObject.m_szRegistryKey),
    m_szValueName (rObject.m_szValueName),
    m_szPolicyName (rObject.m_szPolicyName),
    m_precedence (rObject.m_precedence),
    m_vtType (rObject.m_vtType),
    m_pbyBlob (0),
    m_sizeArray (rObject.m_sizeArray),
    m_bstr (0)
{
    if ( VT_ARRAY == m_vtType )
    {
        m_pbyBlob = new BYTE[m_sizeArray];
        if ( m_pbyBlob )
        {
            memcpy (m_pbyBlob, rObject.m_pbyBlob, m_sizeArray);
        }
    }
    else if ( VT_I4 == m_vtType )
    {
        m_dwValue = rObject.m_dwValue;
    }

    memcpy (&m_fileTime, &rObject.m_fileTime, sizeof (FILETIME));

    if ( rObject.m_bstr )
        m_bstr = SysAllocString (rObject.m_bstr);
}

CRSOPObject::~CRSOPObject ()
{
    if ( VT_ARRAY == m_vtType && m_pbyBlob )
        delete [] m_pbyBlob;

    if ( m_bstr )
        SysFreeString (m_bstr);
}

HRESULT CRSOPObject::GetBSTR (BSTR* pBstr) const
{
    HRESULT hr = S_OK;
    if ( pBstr )
    {
        if ( m_bstr ) 
            *pBstr = SysAllocString ((PCWSTR) m_bstr);
        else
            hr = E_NOTIMPL;
    }
    else 
        hr = E_POINTER;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\rsopobject.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       RSOPObject.h
//
//  Contents:
//
//----------------------------------------------------------------------------

#ifndef __RSOPOBJECT_H_INCLUDED__
#define __RSOPOBJECT_H_INCLUDED__
#include <wbemcli.h>

class CRSOPObject : public CObject 
{
public:
    CRSOPObject (
            const CString& szRegistryKey, 
            const CString& szValueName, 
            const CString& szPolicyName,
            UINT precedence, 
            COleVariant& variant);
    CRSOPObject (const CRSOPObject& rObject);
    virtual ~CRSOPObject ();

    CString GetRegistryKey () const
    {
        return m_szRegistryKey;
    }

    UINT    GetPrecedence () const
    {
        return m_precedence;
    }

    CString GetValueName () const
    {
        return m_szValueName;
    }

    BYTE*   GetBlob () const
    {
        ASSERT (VT_ARRAY == m_vtType);
        BYTE*   pByte = 0;
        if ( VT_ARRAY == m_vtType )
            pByte = m_pbyBlob;

        return pByte;
    }

    size_t GetBlobLength () const
    {
        return m_sizeArray;
    }

    DWORD GetDWORDValue () const
    {
        ASSERT (VT_I4 == m_vtType);
        if ( VT_I4 == m_vtType )
            return m_dwValue;
        else
            return 0;
    }

    CString GetPolicyName () const
    {
        return m_szPolicyName;
    }

    void GetFileTime (FILETIME& fileTime) const
    {
        memcpy (&fileTime, &m_fileTime, sizeof (FILETIME));
    }

    HRESULT GetBSTR (BSTR* pBstr) const;

private:
    const CString   m_szRegistryKey;
    const CString   m_szValueName;
    const UINT      m_precedence;
    CString         m_szPolicyName;
    size_t          m_sizeArray;
    BSTR            m_bstr;
    FILETIME        m_fileTime;

public:
    CIMTYPE m_vtType;
    union {
        DWORD       m_dwValue;
        BYTE HUGEP* m_pbyBlob;
    }; 
};

typedef CTypedPtrArray<CObArray,CRSOPObject*> CRSOPObjectArray;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferenforcementpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEnforcementPropertyPage.h
//
//  Contents:   Declaration of CSaferEnforcementPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENFORCEMENTPROPERTYPAGE_H__92727CF5_8AC5_42E7_AAEA_1C91573D4B40__INCLUDED_)
#define AFX_SAFERENFORCEMENTPROPERTYPAGE_H__92727CF5_8AC5_42E7_AAEA_1C91573D4B40__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEnforcementPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaferEnforcementPropertyPage dialog

class CSaferEnforcementPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferEnforcementPropertyPage(
            IGPEInformation* pGPEInformation,
            CCertMgrComponentData* pCompData,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputer);
	~CSaferEnforcementPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEnforcementPropertyPage)
	enum { IDD = IDD_SAFER_ENFORCEMENT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEnforcementPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void DoContextHelp (HWND hWndControl);
    void RSOPGetEnforcement(CCertMgrComponentData* /*pCompData*/);

	// Generated message map functions
	//{{AFX_MSG(CSaferEnforcementPropertyPage)
	afx_msg void OnAllExceptLibs();
	afx_msg void OnAllSoftwareFiles();
	virtual BOOL OnInitDialog();
	afx_msg void OnApplyExceptAdmins();
	afx_msg void OnApplyToAllUsers();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    IGPEInformation*    m_pGPEInformation;
    HKEY                m_hGroupPolicyKey;
    const bool          m_fIsComputerType;
    const bool          m_bReadOnly;
    CRSOPObjectArray&   m_rsopObjectArray;
    DWORD               m_dwEnforcement;
    bool                m_bDirty;
    DWORD               m_dwScopeFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENFORCEMENTPROPERTYPAGE_H__92727CF5_8AC5_42E7_AAEA_1C91573D4B40__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentry.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntry.cpp
//
//  Contents:   Implementation of CSaferEntry
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "SaferEntry.h"
#include "PolicyKey.h"
#include "SaferLevel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HKEY g_hkeyLastSaferRegistryScope;
const DWORD AUTHZ_UNKNOWN_LEVEL = 0xFFFFFFFF;
extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;
extern PCWSTR pcszNEWLINE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaferEntry::CSaferEntry (
        SAFER_ENTRY_TYPE saferEntryType,
        bool bIsMachine, 
        PCWSTR pszMachineName, 
        PCWSTR pszObjectName, 
        PSAFER_IDENTIFICATION_HEADER pAuthzInfo,
        DWORD   dwLevelID,
        IGPEInformation* pGPEInformation,
        CCertificate* pCertificate,
        CSaferEntries* pSaferEntries,
        CRSOPObjectArray& rRSOPArray,
        PCWSTR pszRSOPRegistryKey)
: CCertMgrCookie (bIsMachine ? CERTMGR_SAFER_COMPUTER_ENTRY : CERTMGR_SAFER_USER_ENTRY, 
        pszMachineName, pszObjectName),
    m_pAuthzInfo (pAuthzInfo),
    m_dwLevelID (dwLevelID),
    m_dwOriginalLevelID (dwLevelID),
    m_pCertificate (pCertificate),
    m_pSaferEntries (pSaferEntries),
    m_pGPEInformation (pGPEInformation),
    m_saferEntryType (saferEntryType),
    m_dwFlags (0),
    m_bDeleted (false),
    m_cbFileHash (0),
    m_UrlZoneId (0),
    m_szRSOPRegistryKey (pszRSOPRegistryKey),
    m_hashAlgid (0),
    m_bIsComputer (bIsMachine)
{
    ::ZeroMemory (&m_nHashFileSize, sizeof (__int64));
    ::ZeroMemory (m_rgbFileHash, SAFER_MAX_HASH_SIZE);

    m_szDisplayName = pszObjectName;

    if ( m_pCertificate )
        m_pCertificate->AddRef ();

    if ( m_pSaferEntries )
        m_pSaferEntries->AddRef ();

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();

        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                bIsMachine);

        if ( AUTHZ_UNKNOWN_LEVEL == m_dwLevelID )
        {
            // Bug 264556	Set better Security level defaults for new Safer rules
            m_dwLevelID = CSaferLevel::ReturnDefaultLevel (
                m_pGPEInformation, 
                m_bIsComputer, 
                rRSOPArray);
            if ( SAFER_LEVELID_FULLYTRUSTED == m_dwLevelID )
                m_dwLevelID = SAFER_LEVELID_DISALLOWED;
            else
                m_dwLevelID = SAFER_LEVELID_FULLYTRUSTED;
        }
        m_szLevelFriendlyName = SaferGetLevelFriendlyName (m_dwLevelID, 
                policyKey.GetKey (), m_bIsComputer); 
    }
    else
    {
        m_szLevelFriendlyName = SaferGetLevelFriendlyName (m_dwLevelID, 0, 
                m_bIsComputer);
    }

    if ( SAFER_ENTRY_TYPE_URLZONE == m_saferEntryType )
    {
        if ( m_pAuthzInfo )
        {
            ASSERT (SaferIdentityTypeUrlZone == m_pAuthzInfo->dwIdentificationType);
            PSAFER_URLZONE_IDENTIFICATION pURLEntry = 
                    reinterpret_cast <PSAFER_URLZONE_IDENTIFICATION> (m_pAuthzInfo);
            ASSERT (pURLEntry->header.cbStructSize == 
                    sizeof (SAFER_URLZONE_IDENTIFICATION));
            m_UrlZoneId = pURLEntry->UrlZoneId;
        }
        else
        {
            // This is a new entry
            m_UrlZoneId = URLZONE_TRUSTED;
        }
    }
}


CSaferEntry::~CSaferEntry()
{
    if ( m_pAuthzInfo )
        LocalFree (m_pAuthzInfo);
    if ( m_pCertificate )
        m_pCertificate->Release ();
    if ( m_pSaferEntries )
        m_pSaferEntries->Release ();
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}


CString CSaferEntry::GetDescription()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString     szDescription;

    if ( SAFER_ENTRY_TYPE_URLZONE == m_saferEntryType )
    {
        switch (m_UrlZoneId)
        {
            case URLZONE_LOCAL_MACHINE:
                VERIFY (szDescription.LoadString (IDS_URLZONE_LOCAL_MACHINE_DESCRIPTION));
                break;

            case URLZONE_INTRANET:
                VERIFY (szDescription.LoadString (IDS_URLZONE_INTRANET_DESCRIPTION));
                break;

            case URLZONE_TRUSTED:
                VERIFY (szDescription.LoadString (IDS_URLZONE_TRUSTED_DESCRIPTION));
                break;

            case URLZONE_INTERNET:
                VERIFY (szDescription.LoadString (IDS_URLZONE_INTERNET_DESCRIPTION));
                break;

            case URLZONE_UNTRUSTED:
                VERIFY (szDescription.LoadString (IDS_URLZONE_UNTRUSTED_DESCRIPTION));
                break;

            default:
                ASSERT (0);
                break;
        }
    }
    else if ( m_pAuthzInfo )
    {
        switch (m_pAuthzInfo->dwIdentificationType)
        {
        case SaferIdentityTypeImageName:
            {
                PSAFER_PATHNAME_IDENTIFICATION    pNameEntry = 
                        (PSAFER_PATHNAME_IDENTIFICATION) m_pAuthzInfo;
                ASSERT (pNameEntry->header.cbStructSize >= 
                        sizeof (SAFER_PATHNAME_IDENTIFICATION));
                szDescription = pNameEntry->Description;
            }
            break;

        case SaferIdentityTypeImageHash:
            {
                PSAFER_HASH_IDENTIFICATION pHashEntry = 
                        (PSAFER_HASH_IDENTIFICATION) m_pAuthzInfo;
                ASSERT (pHashEntry->header.cbStructSize == 
                        sizeof (SAFER_HASH_IDENTIFICATION));
                szDescription = pHashEntry->Description;
            }
            break;

        case SaferIdentityTypeUrlZone:
            ASSERT (0);
            break;

        default:
            ASSERT (0);
            break;
        }
    }
    else if ( m_pCertificate )
    {
        // Is certificate
        szDescription = m_pCertificate->GetDescription ();
    }

    m_szDescription = szDescription;
    return szDescription;
}

SAFER_ENTRY_TYPE CSaferEntry::GetType () const
{
    return m_saferEntryType;
}


CString CSaferEntry::GetTypeString() const
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szType;
    switch (m_saferEntryType)
    {
    case SAFER_ENTRY_TYPE_PATH:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_ImageName));
        break;

    case SAFER_ENTRY_TYPE_HASH:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_ImageHash));
        break;

    case SAFER_ENTRY_TYPE_URLZONE:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_UrlZone));
        break;

    case SAFER_ENTRY_TYPE_CERT:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_Certificate));
        break;

    default:
        ASSERT (0);
        break;
    }

    return szType;
}

CString CSaferEntry::GetLevelFriendlyName() const
{
    return m_szLevelFriendlyName;
}

CString CSaferEntry::GetShortLastModified() const
{
    CString     szDate;

    if ( m_pAuthzInfo )
    {
        VERIFY (SUCCEEDED (FormatDate (m_pAuthzInfo->lastModified, szDate, DATE_SHORTDATE, true)) );
    }
    else if ( m_pCertificate )
    {
        szDate = m_pCertificate->GetShortLastModified ();
    }

    return szDate;
}

CString CSaferEntry::GetLongLastModified() const
{
    CString     szDate;

    if ( m_pAuthzInfo )
    {
        VERIFY (SUCCEEDED (FormatDate (m_pAuthzInfo->lastModified, szDate, DATE_LONGDATE, true)) );
    }
    else if ( m_pCertificate )
    {
        szDate = m_pCertificate->GetLongLastModified ();
    }

    return szDate;
}

HRESULT CSaferEntry::GetCertificate(CCertificate **ppCert)
{
    ASSERT (ppCert);
    if ( !ppCert )
        return E_POINTER;

    if ( !m_pCertificate )
        return E_NOTIMPL;

    *ppCert = m_pCertificate;
    m_pCertificate->AddRef ();

    return S_OK;
}

HRESULT CSaferEntry::SetCertificate(CCertificate *pCert)
{
    ASSERT (m_pSaferEntries);
    if ( !m_pSaferEntries )
        return E_FAIL;

    HRESULT hr = S_OK;
    CCertStore* pStore = 0;

    switch (m_dwLevelID)
    {
    case SAFER_LEVELID_FULLYTRUSTED:
        hr = m_pSaferEntries->GetTrustedPublishersStore (&pStore);
        break;

    case SAFER_LEVELID_DISALLOWED:
        hr = m_pSaferEntries->GetDisallowedStore (&pStore);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    if ( SUCCEEDED (hr) )
    {
        if ( m_pCertificate )
        {
            m_pCertificate->DeleteFromStore (false);
            m_pCertificate->Release ();
            m_pCertificate = 0;
        }

        if ( pCert )
        {
            m_pCertificate = pCert;
            m_pCertificate->AddRef ();
            hr = pStore->AddCertificateContext (m_pCertificate->GetCertContext (), 0, false);
            if ( SUCCEEDED (hr) )
            {
                m_pCertificate->GetNewCertContext ();
            }
        }
    }

    return hr;
}

void CSaferEntry::SetDescription(const CString& szDescription)
{
    m_szDescription = szDescription;
}

HRESULT CSaferEntry::GetSaferEntriesNode(CSaferEntries **ppSaferEntries)
{
    if ( !ppSaferEntries )
        return E_POINTER;

    if ( !m_pSaferEntries )
        return E_NOTIMPL;

    m_pSaferEntries->AddRef ();
    *ppSaferEntries = m_pSaferEntries;

    return S_OK;
}

DWORD CSaferEntry::GetLevel() const
{
    return m_dwLevelID;
}

HRESULT CSaferEntry::SetLevel(DWORD dwLevelID)
{
    HRESULT hr = S_OK;
    if ( m_dwLevelID != dwLevelID )
    {
        m_dwLevelID = dwLevelID;

        // Get the new "friendly name"
        if ( m_pGPEInformation )
        {
            CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsComputer);
            m_szLevelFriendlyName = SaferGetLevelFriendlyName (dwLevelID, 
                    policyKey.GetKey (),
                    m_bIsComputer); 
        }
        else
        {
            m_szLevelFriendlyName = SaferGetLevelFriendlyName (dwLevelID, 0,
                   m_bIsComputer);
        }
    }

    return hr;
}

CString CSaferEntry::GetPath()
{
    CString szPath;

    if ( m_pAuthzInfo )
    {
        if ( SaferIdentityTypeImageName == m_pAuthzInfo->dwIdentificationType )
        {
            PSAFER_PATHNAME_IDENTIFICATION pNameEntry =
                    (PSAFER_PATHNAME_IDENTIFICATION) m_pAuthzInfo;
            ASSERT (pNameEntry->header.cbStructSize >= 
                    sizeof (SAFER_PATHNAME_IDENTIFICATION));
            ASSERT (SaferIdentityTypeImageName == m_pAuthzInfo->dwIdentificationType);
            szPath = pNameEntry->ImageName;
        }
    }

    m_szPath = szPath;
    return szPath;
}

void CSaferEntry::SetPath(const CString &szPath)
{
    m_szPath = szPath;
}

HRESULT CSaferEntry::Save()
{
    _TRACE (1, L"Entering CSaferEntry::Save\n");
    HRESULT hr = S_OK;

    ASSERT (!m_bDeleted);
    if ( m_bDeleted )
        return E_FAIL;

    if ( m_pCertificate )
    {
        hr = m_pCertificate->SetDescription (m_szDescription);
        if ( SUCCEEDED (hr) )
        {
            hr = m_pCertificate->SetLastModified ();
            if ( SUCCEEDED (hr) )
            {
                // If the level has changed, then the cert must be removed 
                // from the current level store added to the new one.
                if ( m_dwOriginalLevelID != m_dwLevelID )
                {
                    CCertStore* pStore = 0;
                    switch (m_dwLevelID)
                    {
                    case SAFER_LEVELID_FULLYTRUSTED:
                        hr = m_pSaferEntries->GetTrustedPublishersStore (&pStore);
                        break;

                    case SAFER_LEVELID_DISALLOWED:
                        hr = m_pSaferEntries->GetDisallowedStore (&pStore);
                        break;

                    default:
                        hr = E_FAIL;
                        break;
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        m_pCertificate->DeleteFromStore (true);
                        hr = pStore->AddCertificateContext (m_pCertificate->GetCertContext (), 0, false);
                        if ( SUCCEEDED (hr) )
                        {
                            m_pCertificate->SetStore (pStore);
                            hr = PolicyChanged ();
                        }
                    }
                }

                if ( SUCCEEDED (hr) )
                    m_szDisplayName = m_pCertificate->GetSubjectName ();
            }
        }
    }
    else if ( m_pGPEInformation )
    {
        BOOL    bRVal = TRUE;
        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsComputer);
        hr = SetRegistryScope  (policyKey.GetKey (), m_bIsComputer);
        if ( SUCCEEDED (hr) )
        {

            DWORD   dwInBufferSize = 0;
            switch (m_saferEntryType)
            {
                case SAFER_ENTRY_TYPE_PATH:
                    dwInBufferSize = sizeof (SAFER_PATHNAME_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_HASH:
                    dwInBufferSize = sizeof (SAFER_HASH_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_URLZONE:
                    dwInBufferSize = sizeof (SAFER_URLZONE_IDENTIFICATION);
                    break;

                default:
                    ASSERT (0);
                    break;
            }

            SAFER_LEVEL_HANDLE hLevel = 0;

            // If this entry is not being created for the first time
            // and the level has changed, delete this object from its original
            // level.
            if ( m_pAuthzInfo && 
                    AUTHZ_UNKNOWN_LEVEL != m_dwOriginalLevelID && 
                    m_dwOriginalLevelID != m_dwLevelID )
            {
                bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                        m_dwOriginalLevelID,
                        SAFER_LEVEL_OPEN,
                        &hLevel,
                        policyKey.GetKey ());
                ASSERT (bRVal);
                if ( bRVal )
                {
                    SAFER_IDENTIFICATION_TYPES dwIdentificationType =
                            m_pAuthzInfo->dwIdentificationType;
                    m_pAuthzInfo->dwIdentificationType = (SAFER_IDENTIFICATION_TYPES) 0; // 0 will cause deletion

                    bRVal = SaferSetLevelInformation(hLevel,
                             SaferObjectSingleIdentification,
                             m_pAuthzInfo,
                             m_pAuthzInfo->cbStructSize);
                    ASSERT (bRVal);
                    if ( !bRVal )
                    {
                        DWORD   dwErr = GetLastError ();
                        _TRACE (0, L"Attempt to delete entry using SaferSetLevelInformation(SaferObjectSingleIdentification) failed: %d\n", dwErr);
                        hr = HRESULT_FROM_WIN32 (dwErr);
                    }
                    m_pAuthzInfo->dwIdentificationType = dwIdentificationType; // restore type
                            
                    VERIFY (SaferCloseLevel(hLevel));
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"SaferCreateLevel(SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                            m_dwOriginalLevelID, dwErr);
                }
            }

            if ( SUCCEEDED (hr) )
            {
                // If this is new, create and initialize a new info structure
                if ( !m_pAuthzInfo )
                {
                    // generate guid
                    GUID    guid;
                    hr = CoCreateGuid (&guid);
                    if ( SUCCEEDED (hr) )
                    {
                        m_pAuthzInfo = (PSAFER_IDENTIFICATION_HEADER)
                                ::LocalAlloc (LPTR, dwInBufferSize);
                        if ( m_pAuthzInfo )
                        {
                            m_pAuthzInfo->cbStructSize = dwInBufferSize;
                            memcpy (&m_pAuthzInfo->IdentificationGuid, &guid, sizeof (GUID));
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED (hr) )
                {
                    switch (m_saferEntryType)
                    {
                    case SAFER_ENTRY_TYPE_PATH:
                        {
                            m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageName;
                            PSAFER_PATHNAME_IDENTIFICATION    pNameEntry = 
                                    reinterpret_cast<PSAFER_PATHNAME_IDENTIFICATION> (m_pAuthzInfo);
                            ASSERT (pNameEntry->header.cbStructSize >= 
                                    sizeof (SAFER_PATHNAME_IDENTIFICATION));
                            wcsncpy (pNameEntry->Description, m_szDescription, SAFER_MAX_DESCRIPTION_SIZE-1);
                            pNameEntry->ImageName = const_cast <PWCHAR>((PCWSTR) m_szPath);
                            pNameEntry->dwSaferFlags = m_dwFlags;
                        }
                        break;

                    case SAFER_ENTRY_TYPE_HASH:
                        {
                            m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageHash;
                            PSAFER_HASH_IDENTIFICATION pHashEntry = 
                                    reinterpret_cast<PSAFER_HASH_IDENTIFICATION>(m_pAuthzInfo);
                            ASSERT (pHashEntry->header.cbStructSize == 
                                    sizeof (SAFER_HASH_IDENTIFICATION));

                            wcsncpy (pHashEntry->FriendlyName, m_szHashFriendlyName, 
                                    SAFER_MAX_FRIENDLYNAME_SIZE-1);

                            wcsncpy (pHashEntry->Description, 
                                    m_szDescription, 
                                    SAFER_MAX_DESCRIPTION_SIZE-1);
                            pHashEntry->dwSaferFlags = m_dwFlags;
                            memcpy (pHashEntry->ImageHash, m_rgbFileHash, SAFER_MAX_HASH_SIZE);
                            pHashEntry->HashSize = m_cbFileHash;
                            memcpy (&pHashEntry->ImageSize, &m_nHashFileSize, sizeof (__int64));
                            pHashEntry->HashAlgorithm = m_hashAlgid;
                        }
                        break;

                    case SAFER_ENTRY_TYPE_URLZONE:
                        {
                            m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeUrlZone;
                            PSAFER_URLZONE_IDENTIFICATION pURLEntry = 
                                    reinterpret_cast <PSAFER_URLZONE_IDENTIFICATION> (m_pAuthzInfo);
                            ASSERT (pURLEntry->header.cbStructSize == 
                                    sizeof (SAFER_URLZONE_IDENTIFICATION));
                            pURLEntry->dwSaferFlags = m_dwFlags;
                            pURLEntry->UrlZoneId = m_UrlZoneId;
                        }
                        break;
                    }

                    bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                            m_dwLevelID,
                            SAFER_LEVEL_OPEN,
                            &hLevel,
                            policyKey.GetKey ());
                    ASSERT (bRVal);
                    if ( bRVal )
                    {
                        bRVal = SaferSetLevelInformation(hLevel,
                                    SaferObjectSingleIdentification,
                                    m_pAuthzInfo, m_pAuthzInfo->cbStructSize);
                        if ( bRVal )
                        {
                            switch ( m_saferEntryType )
                            {
                            case SAFER_ENTRY_TYPE_HASH:
                                m_szDisplayName = m_szHashFriendlyName;
                                m_szDisplayName.Replace (pcszNEWLINE, L"  ");
                                break;

                            case SAFER_ENTRY_TYPE_PATH:
                                m_szDisplayName = m_szPath;
                                break;

                            case SAFER_ENTRY_TYPE_URLZONE:
                                m_szDisplayName = GetURLZoneFriendlyName (m_UrlZoneId);
                                break;

                            default:
                                ASSERT (0);
                                break;
                            }
                        

                            hr = PolicyChanged ();
                            if ( SUCCEEDED (hr) )
                            {
                                m_dwOriginalLevelID = m_dwLevelID;
                            }
                        }
                        else
                        {
                            DWORD   dwErr = GetLastError ();
                            _TRACE (0, L"SaferSetLevelInformation(SaferObjectSingleIdentification) failed: %d\n",
                                    dwErr);
                            hr = HRESULT_FROM_WIN32 (dwErr);
                        }
                        VERIFY (SaferCloseLevel(hLevel));
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"SaferCreateLevel(AUTHZSCOPID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                                m_dwLevelID, dwErr);
                    }
                }
            }
        }    
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CSaferEntry::Save: 0x%x\n", hr);
    return hr;
}

HRESULT CSaferEntry::PolicyChanged()
{
    _TRACE (1, L"Entering CSaferEntry::PolicyChanged\n");
    HRESULT hr = E_FAIL;

    if ( m_pGPEInformation )
    {
        hr = m_pGPEInformation->PolicyChanged (
                m_bIsComputer ? TRUE : FALSE,
                TRUE, &g_guidExtension, &g_guidSnapin);
        hr = m_pGPEInformation->PolicyChanged (
                m_bIsComputer ? TRUE : FALSE,
                TRUE, &g_guidRegExt, &g_guidSnapin);
    }

    _TRACE (-1, L"Leaving CSaferEntry::PolicyChanged\n");
    return hr;
}

void CSaferEntry::SetFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

HRESULT CSaferEntry::GetFlags(DWORD &dwFlags)
{
    HRESULT hr = S_OK;

    if ( m_pAuthzInfo )
    {
        switch (m_saferEntryType)
        {
        case SAFER_ENTRY_TYPE_PATH:
            {
                m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageName;
                PSAFER_PATHNAME_IDENTIFICATION    pNameEntry = 
                        reinterpret_cast<PSAFER_PATHNAME_IDENTIFICATION>(m_pAuthzInfo);
                ASSERT (pNameEntry->header.cbStructSize >= 
                        sizeof (SAFER_PATHNAME_IDENTIFICATION));
                dwFlags = pNameEntry->dwSaferFlags;
            }
            break;

        case SAFER_ENTRY_TYPE_HASH:
            {
                m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageHash;
                PSAFER_HASH_IDENTIFICATION pHashEntry = 
                        reinterpret_cast<PSAFER_HASH_IDENTIFICATION>(m_pAuthzInfo);
                ASSERT (pHashEntry->header.cbStructSize == 
                        sizeof (SAFER_HASH_IDENTIFICATION));
                dwFlags = pHashEntry->dwSaferFlags;
            }
            break;

        case SAFER_ENTRY_TYPE_URLZONE:
            {
                m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeUrlZone;
                PSAFER_URLZONE_IDENTIFICATION pURLEntry = 
                        reinterpret_cast<PSAFER_URLZONE_IDENTIFICATION>(m_pAuthzInfo);
                ASSERT (pURLEntry->header.cbStructSize == 
                        sizeof (SAFER_URLZONE_IDENTIFICATION));
                dwFlags = pURLEntry->dwSaferFlags;
            }
            break;

        default:
            hr = E_FAIL;
            break;
        }
    }
    else if ( m_pCertificate )
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

HRESULT CSaferEntry::Delete(bool bCommit)
{
    _TRACE (1, L"Entering CSaferEntry::Delete\n");
    HRESULT hr = S_OK;
    
    ASSERT (!m_bDeleted);
    if ( m_bDeleted )
        return E_FAIL;

    if ( m_pCertificate )
    {
        BOOL bRVal = m_pCertificate->DeleteFromStore (bCommit);
        if ( bRVal )
        {
            m_bDeleted = true;
        }
        else
        {
		    DWORD	dwErr = GetLastError ();
		    hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else if ( m_pGPEInformation )
    {
        BOOL    bRVal = TRUE;
        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsComputer);
        hr = SetRegistryScope  (policyKey.GetKey (), m_bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwInBufferSize = 0;
            switch (m_saferEntryType)
            {
                case SAFER_ENTRY_TYPE_PATH:
                    dwInBufferSize = sizeof (SAFER_PATHNAME_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_HASH:
                    dwInBufferSize = sizeof (SAFER_HASH_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_URLZONE:
                    dwInBufferSize = sizeof (SAFER_URLZONE_IDENTIFICATION);
                    break;

                default:
                    ASSERT (0);
                    break;
            }

            SAFER_LEVEL_HANDLE hLevel = 0;

            if ( m_pAuthzInfo )
            {
                bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                        m_dwOriginalLevelID,
                        SAFER_LEVEL_OPEN,
                        &hLevel,
                        policyKey.GetKey ());
                ASSERT (bRVal);
                if ( bRVal )
                {
                    SAFER_IDENTIFICATION_TYPES dwIdentificationType =
                            m_pAuthzInfo->dwIdentificationType;
                    m_pAuthzInfo->dwIdentificationType = (SAFER_IDENTIFICATION_TYPES) 0; // 0 will cause deletion

                    bRVal = SaferSetLevelInformation(hLevel,
                             SaferObjectSingleIdentification,
                             m_pAuthzInfo,
                             m_pAuthzInfo->cbStructSize);
                    ASSERT (bRVal);
                    if ( bRVal )
                    {
                        m_bDeleted = true;
                        if ( bCommit )
                        {
                            hr = m_pGPEInformation->PolicyChanged (
                                    m_bIsComputer ? TRUE : FALSE,
                                    TRUE, &g_guidExtension, &g_guidSnapin);
                            hr = m_pGPEInformation->PolicyChanged (
                                    m_bIsComputer ? TRUE : FALSE,
                                    TRUE, &g_guidRegExt, &g_guidSnapin);
                        }
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        _TRACE (0, L"Attempt to delete entry using SaferSetLevelInformation(SaferObjectSingleIdentification) failed: %d\n", dwErr);
                        hr = HRESULT_FROM_WIN32 (dwErr);
                    }
                    m_pAuthzInfo->dwIdentificationType = dwIdentificationType;   
                            
                    VERIFY (SaferCloseLevel(hLevel));  // restore type
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"SaferCreateLevel(AUTHZSCOPID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                            m_dwOriginalLevelID, dwErr);
                }
            }
        }    
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CSaferEntry::Delete: 0x%x\n", hr);
    return hr;
}

HRESULT CSaferEntry::GetHash(BYTE rgbFileHash[], DWORD& cbFileHash, __int64& nFileSize, ALG_ID& algId) const
{
    HRESULT hr = S_OK;

    if ( m_pAuthzInfo )
    {
        if ( SAFER_ENTRY_TYPE_HASH == m_saferEntryType )
        {
            PSAFER_HASH_IDENTIFICATION pHashEntry = 
                    reinterpret_cast<PSAFER_HASH_IDENTIFICATION>(m_pAuthzInfo);
            ASSERT (pHashEntry->header.cbStructSize == 
                    sizeof (SAFER_HASH_IDENTIFICATION));
            memcpy (rgbFileHash, pHashEntry->ImageHash, SAFER_MAX_HASH_SIZE);
            cbFileHash = pHashEntry->HashSize;
            memcpy (&nFileSize, &pHashEntry->ImageSize, sizeof (__int64));
            algId = pHashEntry->HashAlgorithm;
        }
        else
            hr = E_NOTIMPL;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CSaferEntry::SetHash (
            BYTE    rgbFileHash[], 
            DWORD   cbFileHash, 
            __int64 nFileSize, 
            ALG_ID   hashAlgid)
{
    ASSERT (cbFileHash <= SAFER_MAX_HASH_SIZE);
    if ( cbFileHash > SAFER_MAX_HASH_SIZE )
        return E_FAIL;

    ASSERT (rgbFileHash);
    if ( !rgbFileHash )
        return E_POINTER;

    m_nHashFileSize = nFileSize;
    m_cbFileHash = cbFileHash;
    ::ZeroMemory (m_rgbFileHash, SAFER_MAX_HASH_SIZE);
    memcpy (m_rgbFileHash, rgbFileHash, cbFileHash);
    m_hashAlgid = hashAlgid;

    return S_OK;
}

DWORD CSaferEntry::GetURLZoneID() const
{
    return m_UrlZoneId;
}

void CSaferEntry::SetURLZoneID(DWORD dwURLZoneID)
{
    m_UrlZoneId = dwURLZoneID;
}

CString CSaferEntry::GetHashFriendlyName()
{
    CString szFriendlyName;

    if ( m_szHashFriendlyName.IsEmpty () )
    {
        if ( m_pAuthzInfo )
        {
            if ( SaferIdentityTypeImageHash == m_pAuthzInfo->dwIdentificationType )
            {
                PSAFER_HASH_IDENTIFICATION pHashEntry = 
                        (PSAFER_HASH_IDENTIFICATION) m_pAuthzInfo;
                ASSERT (pHashEntry->header.cbStructSize == 
                        sizeof (SAFER_HASH_IDENTIFICATION));
                m_szHashFriendlyName = pHashEntry->FriendlyName;
            }
        }
    }
    
    return m_szHashFriendlyName;
}

void CSaferEntry::SetHashFriendlyName(const CString &szFriendlyName)
{
    m_szHashFriendlyName = szFriendlyName;
}

int CSaferEntry::CompareLastModified (const CSaferEntry& saferEntry) const
{
	int	compVal = 0;

    FILETIME    thisFt;
    FILETIME    inFt;

    if ( m_pAuthzInfo )
        thisFt = m_pAuthzInfo->lastModified;
    else if ( m_pCertificate )
    {
        if ( FAILED (m_pCertificate->GetLastModifiedFileTime (thisFt)) )
            return 0;
    }
    else
    {
        ASSERT (0);
        return 0;
    }

    if ( saferEntry.m_pAuthzInfo )
        inFt = saferEntry.m_pAuthzInfo->lastModified;
    else if ( saferEntry.m_pCertificate )
    {
        if ( FAILED (saferEntry.m_pCertificate->GetLastModifiedFileTime (inFt)) )
            return 0;
    }
    else
    {
        ASSERT (0);
        return 0;
    }

	compVal = ::CompareFileTime (&thisFt, &inFt);

	return compVal;
}

CString CSaferEntry::GetRSOPRegistryKey () const
{
    CString szRegistryKey;
    if ( m_pCertificate )
    {
        if ( SAFER_LEVELID_FULLYTRUSTED == m_dwLevelID )
            szRegistryKey = CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH;
        else
            szRegistryKey = CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH;

        szRegistryKey += STR_REGKEY_CERTIFICATES;
        szRegistryKey += L"\\";
        //szRegistryKey += m_pCertificate->GetMD5Hash ();
        szRegistryKey += m_pCertificate->GetSHAHash ();
    }
    else
        szRegistryKey = m_szRSOPRegistryKey;

    ASSERT (!szRegistryKey.IsEmpty ());
    return szRegistryKey;
}


void CSaferEntry::Refresh()
{
    _TRACE (1, L"Entering CSaferEntry::Refresh ()\n");
    if ( m_pAuthzInfo )
    {
        if ( m_pGPEInformation )
        {
            SAFER_LEVEL_HANDLE hLevel = 0;
            CPolicyKey policyKey (m_pGPEInformation, 
                            SAFER_HKLM_REGBASE, 
                            m_bIsComputer);
            BOOL        bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                            m_dwLevelID,
                            SAFER_LEVEL_OPEN,
                            &hLevel,
                            policyKey.GetKey ());
            if ( bRVal )
            {
                DWORD   dwBufferSize = sizeof (SAFER_IDENTIFICATION_HEADER);
                bRVal = SaferGetLevelInformation (hLevel, 
                            SaferObjectSingleIdentification,
                            m_pAuthzInfo,
                            dwBufferSize,
                            &dwBufferSize);
                if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
                {
                    PBYTE   pBytes = (PBYTE) LocalAlloc (LPTR, dwBufferSize);
                    if ( pBytes )
                    {
                        PSAFER_IDENTIFICATION_HEADER pCommon = (PSAFER_IDENTIFICATION_HEADER) pBytes;
                        pCommon->cbStructSize = dwBufferSize;
                        memcpy (&pCommon->IdentificationGuid, &m_pAuthzInfo->IdentificationGuid, sizeof (GUID));

                        bRVal = SaferGetLevelInformation (hLevel, 
                                SaferObjectSingleIdentification,
                                pBytes,
                                dwBufferSize,
                                &dwBufferSize);
                        ASSERT (bRVal);
                        if ( bRVal )
                        {
                            LocalFree (m_pAuthzInfo);
                            m_pAuthzInfo = (PSAFER_IDENTIFICATION_HEADER) pBytes;
                        }
                        else
                        {
                            _TRACE (0, L"SaferGetLevelInformation () failed: %d\n", GetLastError ());
                        }
                    }
                }

                VERIFY (SaferCloseLevel(hLevel));
            }
            else
            {
                _TRACE (0, L"SaferCreateLevel() failed: %d\n", GetLastError ());
            }
        }
        else
        {
            // Is RSOP
        }
    }
    _TRACE (-1, L"Leaving CSaferEntry::Refresh ()\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferenforcementpropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEnforcementPropertyPage.h
//
//  Contents:   Declaration of CSaferEnforcementPropertyPage
//
//----------------------------------------------------------------------------
// SaferEnforcementPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certmgr.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferEnforcementPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CSaferEnforcementPropertyPage property page

// The "TransparentEnforcement" flag has the following values:
//	0 = disable all transparent hooks (in CreateProcess and LoadLibrary)
//	1 = enable transparent hooks for CreateProcess
//	2 = enable transparent hooks for CreateProcess and LoadLibrary
#define SAFER_TRANSPARENT_ENFORCEMENT_DISABLE_ALL               0
#define SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS     1
#define SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL                2

CSaferEnforcementPropertyPage::CSaferEnforcementPropertyPage(
            IGPEInformation* pGPEInformation,
            CCertMgrComponentData* pCompData,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputer) 
: CHelpPropertyPage(CSaferEnforcementPropertyPage::IDD),
    m_pGPEInformation (pGPEInformation),
    m_hGroupPolicyKey (0),
    m_fIsComputerType (bIsComputer),
    m_bReadOnly (bReadOnly),
    m_rsopObjectArray (rsopObjectArray),
    m_dwEnforcement (0),
    m_bDirty (false),
    m_dwScopeFlags (0)
{
	//{{AFX_DATA_INIT(CSaferEnforcementPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        HRESULT hr = m_pGPEInformation->GetRegistryKey (
                m_fIsComputerType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            DWORD   cbBuffer = sizeof (DWORD);
            CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_fIsComputerType);

            SetRegistryScope (policyKey.GetKey (), bIsComputer);
            BOOL    bRVal = SaferGetPolicyInformation (
                    SAFER_SCOPEID_REGISTRY,
                    SaferPolicyEnableTransparentEnforcement,
                    cbBuffer,
                    &m_dwEnforcement,
                    &cbBuffer,
                    0);
            if ( !bRVal )
            {
                ASSERT (0);
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyEnableTransparentEnforcement) failed: %d\n",
                        dwErr);
            }

            
            bRVal = SaferGetPolicyInformation (
                    SAFER_SCOPEID_REGISTRY,
                    SaferPolicyScopeFlags,
                    cbBuffer,
                    &m_dwScopeFlags,
                    &cbBuffer,
                    0);
            if ( !bRVal )
            {
                ASSERT (0);
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyScopeFlags) failed: %d\n",
                        dwErr);
            }
        }
    }
    else
    {
        RSOPGetEnforcement (pCompData);
    }
}

CSaferEnforcementPropertyPage::~CSaferEnforcementPropertyPage()
{
    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
    }
}

void CSaferEnforcementPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferEnforcementPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEnforcementPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferEnforcementPropertyPage)
	ON_BN_CLICKED(IDC_ALL_EXCEPT_LIBS, OnAllExceptLibs)
	ON_BN_CLICKED(IDC_ALL_SOFTWARE_FILES, OnAllSoftwareFiles)
	ON_BN_CLICKED(IDC_APPLY_EXCEPT_ADMINS, OnApplyExceptAdmins)
	ON_BN_CLICKED(IDC_APPLY_TO_ALL_USERS, OnApplyToAllUsers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEnforcementPropertyPage message handlers
void CSaferEnforcementPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEnforcementPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_ALL_EXCEPT_LIBS, IDH_ALL_EXCEPT_LIBS,
        IDC_ALL_SOFTWARE_FILES, IDH_ALL_SOFTWARE_FILES,
        IDC_APPLY_TO_ALL_USERS, IDH_APPLY_TO_ALL_USERS,
        IDC_APPLY_EXCEPT_ADMINS, IDH_APPLY_EXCEPT_ADMINS,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CSaferEnforcementPropertyPage::DoContextHelp\n");
}

void CSaferEnforcementPropertyPage::RSOPGetEnforcement(CCertMgrComponentData* /*pCompData*/)
{
    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();
    bool    bEnforcementFlagFound = false;
    bool    bScopeFlagFound = false;

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            if ( pObject->GetRegistryKey () == SAFER_HKLM_REGBASE &&
                    pObject->GetValueName () == SAFER_TRANSPARENTENABLED_REGVALUE &&
                    1 == pObject->GetPrecedence ())
            {
                m_dwEnforcement = pObject->GetDWORDValue ();
                bEnforcementFlagFound = true;
            }
            else if ( pObject->GetRegistryKey () == SAFER_HKLM_REGBASE &&
                    pObject->GetValueName () == SAFER_POLICY_SCOPE &&
                    1 == pObject->GetPrecedence ())
            {
                m_dwScopeFlags = pObject->GetDWORDValue ();
                bScopeFlagFound = true;
            }
        }
        else
            break;

        if ( bScopeFlagFound && bEnforcementFlagFound )
            break;

        nIndex++;
    }
}

void CSaferEnforcementPropertyPage::OnAllExceptLibs() 
{
	SetModified ();
    m_bDirty = true;
}

void CSaferEnforcementPropertyPage::OnAllSoftwareFiles() 
{
	SetModified ();
    m_bDirty = true;
}

BOOL CSaferEnforcementPropertyPage::OnApply() 
{
    _TRACE (1, L"Entering CSaferEnforcementPropertyPage::OnApply ()\n");
    if ( m_bDirty && m_pGPEInformation)
    {
	    if ( BST_CHECKED == SendDlgItemMessage (IDC_ALL_EXCEPT_LIBS,
                BM_GETCHECK) )
        {
            m_dwEnforcement = SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS;
        }
        else if ( BST_CHECKED == SendDlgItemMessage (IDC_ALL_SOFTWARE_FILES,
                BM_GETCHECK) )
        {
            m_dwEnforcement = SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL;
        }

	    if ( BST_CHECKED == SendDlgItemMessage (IDC_APPLY_EXCEPT_ADMINS,
                BM_GETCHECK) )
        {
            m_dwScopeFlags = 1;
        }
        else if ( BST_CHECKED == SendDlgItemMessage (IDC_APPLY_TO_ALL_USERS,
                BM_GETCHECK) )
        {
            m_dwScopeFlags = 0;
        }

        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_fIsComputerType);
        SetRegistryScope (policyKey.GetKey (), m_fIsComputerType);
        DWORD   cbData = sizeof (m_dwEnforcement);
        BOOL    bRVal = SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                SaferPolicyEnableTransparentEnforcement, cbData, 
                    &m_dwEnforcement, 0);
        if ( bRVal )
        {
            cbData = sizeof (m_dwScopeFlags);
            bRVal = SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                SaferPolicyScopeFlags, cbData, 
                    &m_dwScopeFlags, 0);
            if ( bRVal )
            {
			    // TRUE means we're changing the machine policy only
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyScopeFlags, %d failed: 0x%x\n",
                        m_dwEnforcement, dwErr);
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_CAN_SET_SAFER_ENFORCEMENT, GetSystemMessage (dwErr));
                MessageBox (text, caption);

                return FALSE;
            }
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyEnableTransparentEnforcement, %d failed: 0x%x\n",
                    m_dwEnforcement, dwErr);
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_CAN_SET_SAFER_ENFORCEMENT, GetSystemMessage (dwErr));
            MessageBox (text, caption);

            return FALSE;
        }

        
        m_bDirty = false;
    }
	
    _TRACE (-1, L"Leaving CSaferEnforcementPropertyPage::OnApply ()\n");
	return CHelpPropertyPage::OnApply();
}

BOOL CSaferEnforcementPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
	switch (m_dwEnforcement)
    {
    case SAFER_TRANSPARENT_ENFORCEMENT_DISABLE_ALL:
        break;

    case SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS:
        SendDlgItemMessage (IDC_ALL_EXCEPT_LIBS, BM_SETCHECK, BST_CHECKED);
        break;

    case SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL:
        SendDlgItemMessage (IDC_ALL_SOFTWARE_FILES, BM_SETCHECK, BST_CHECKED);
        break;

    default:
        ASSERT (0);
        break;
    }
	
    if ( 1 == m_dwScopeFlags )
    {
        SendDlgItemMessage (IDC_APPLY_EXCEPT_ADMINS, BM_SETCHECK, BST_CHECKED);
    }
    else
    {
        SendDlgItemMessage (IDC_APPLY_TO_ALL_USERS, BM_SETCHECK, BST_CHECKED);
    }

    if ( m_bReadOnly )
    {
        GetDlgItem (IDC_ALL_EXCEPT_LIBS)->EnableWindow (FALSE);
        GetDlgItem (IDC_ALL_SOFTWARE_FILES)->EnableWindow (FALSE);
        GetDlgItem (IDC_APPLY_TO_ALL_USERS)->EnableWindow (FALSE);
        GetDlgItem (IDC_APPLY_EXCEPT_ADMINS)->EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CSaferEnforcementPropertyPage::OnApplyExceptAdmins() 
{
	SetModified ();
    m_bDirty = true;
}

void CSaferEnforcementPropertyPage::OnApplyToAllUsers() 
{
	SetModified ();
    m_bDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentryhashpropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryHashPropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryHashPropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryHashPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "certmgr.h"
#include "compdata.h"
#include "SaferEntryHashPropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

PCWSTR pcszNEWLINE = L"\x00d\x00a";

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryHashPropertyPage property page

CSaferEntryHashPropertyPage::CSaferEntryHashPropertyPage(
        CSaferEntry& rSaferEntry, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        CCertMgrComponentData* pCompData,
        bool bIsMachine) 
: CHelpPropertyPage(CSaferEntryHashPropertyPage::IDD),
    m_rSaferEntry (rSaferEntry),
    m_bDirty (false),
    m_cbFileHash (0),
    m_lNotifyHandle (lNotifyHandle),
    m_pDataObject (pDataObject),
    m_bReadOnly (bReadOnly),
    m_bIsMachine (bIsMachine),
    m_hashAlgid (0),
    m_bFirst (true),
    m_pCompData (pCompData)
{
    ::ZeroMemory (&m_nFileSize, sizeof (__int64));
    ::ZeroMemory (m_rgbFileHash, SAFER_MAX_HASH_SIZE);

	//{{AFX_DATA_INIT(CSaferEntryHashPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rSaferEntry.AddRef ();
    m_rSaferEntry.IncrementOpenPageCount ();

    m_rSaferEntry.GetHash (m_rgbFileHash, m_cbFileHash, m_nFileSize, 
            m_hashAlgid);
}

CSaferEntryHashPropertyPage::~CSaferEntryHashPropertyPage()
{
    if ( m_lNotifyHandle )
        MMCFreeNotifyHandle (m_lNotifyHandle);
    m_rSaferEntry.DecrementOpenPageCount ();
    m_rSaferEntry.Release ();
}

void CSaferEntryHashPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferEntryHashPropertyPage)
	DDX_Control(pDX, IDC_HASH_ENTRY_HASHFILE_DETAILS, m_hashFileDetailsEdit);
	DDX_Control(pDX, IDC_HASH_ENTRY_DESCRIPTION, m_descriptionEdit);
	DDX_Control(pDX, IDC_HASH_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryHashPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferEntryHashPropertyPage)
	ON_BN_CLICKED(IDC_HASH_ENTRY_BROWSE, OnHashEntryBrowse)
	ON_EN_CHANGE(IDC_HASH_ENTRY_DESCRIPTION, OnChangeHashEntryDescription)
	ON_CBN_SELCHANGE(IDC_HASH_ENTRY_SECURITY_LEVEL, OnSelchangeHashEntrySecurityLevel)
	ON_EN_CHANGE(IDC_HASH_HASHED_FILE_PATH, OnChangeHashHashedFilePath)
	ON_EN_SETFOCUS(IDC_HASH_HASHED_FILE_PATH, OnSetfocusHashHashedFilePath)
	ON_EN_CHANGE(IDC_HASH_ENTRY_HASHFILE_DETAILS, OnChangeHashEntryHashfileDetails)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryHashPropertyPage message handlers
void CSaferEntryHashPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryHashPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_HASH_ENTRY_HASHFILE_DETAILS, IDH_HASH_ENTRY_APPLICATION_NAME,
        IDC_HASH_ENTRY_BROWSE, IDH_HASH_ENTRY_BROWSE,
        IDC_HASH_ENTRY_DESCRIPTION, IDH_HASH_ENTRY_DESCRIPTION,
        IDC_HASH_ENTRY_LAST_MODIFIED, IDH_HASH_ENTRY_LAST_MODIFIED,
        IDC_HASH_HASHED_FILE_PATH, IDH_HASH_HASHED_FILE_PATH,
        IDC_HASH_ENTRY_SECURITY_LEVEL, IDH_HASH_ENTRY_SECURITY_LEVEL,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_HASH_ENTRY_HASHFILE_DETAILS:
    case IDC_HASH_ENTRY_BROWSE:
    case IDC_HASH_ENTRY_DESCRIPTION:
    case IDC_HASH_ENTRY_LAST_MODIFIED:
    case IDC_HASH_HASHED_FILE_PATH:
    case IDC_HASH_ENTRY_SECURITY_LEVEL:
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryHashPropertyPage::DoContextHelp\n");
}

BOOL CSaferEntryHashPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
    DWORD   dwFlags = 0;
    m_rSaferEntry.GetFlags (dwFlags);

    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        CPolicyKey policyKey (m_pCompData->m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsMachine);
        InitializeSecurityLevelComboBox (m_securityLevelCombo, false,
                m_rSaferEntry.GetLevel (), policyKey.GetKey (), 
                m_pCompData->m_pdwSaferLevels,
                m_bIsMachine);

        m_hashFileDetailsEdit.SetWindowText (m_rSaferEntry.GetHashFriendlyName ());
        m_descriptionEdit.LimitText (SAFER_MAX_DESCRIPTION_SIZE);
        m_descriptionEdit.SetWindowText (m_rSaferEntry.GetDescription ());

        SetDlgItemText (IDC_HASH_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

        SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_LIMITTEXT, 64);

        if ( m_bReadOnly )
        {
            SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_SETREADONLY, TRUE);

            m_securityLevelCombo.EnableWindow (FALSE);
            GetDlgItem (IDC_HASH_ENTRY_BROWSE)->EnableWindow (FALSE);
        
            m_descriptionEdit.SendMessage (EM_SETREADONLY, TRUE);

            m_hashFileDetailsEdit.SendMessage (EM_SETREADONLY, TRUE);
        }

        if ( m_cbFileHash )
        {
            // Only allow editing on the creation of a new hash
            SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_SETREADONLY, TRUE);

            FormatAndDisplayHash ();

            CString szText;

            VERIFY (szText.LoadString (IDS_HASH_TITLE));
            SetDlgItemText (IDC_HASH_TITLE, szText);
            SetDlgItemText (IDC_HASH_INSTRUCTIONS, L"");
        }
        else
            SetDlgItemText (IDC_DATE_LAST_MODIFIED_LABEL, L"");  
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
 *  [alanau]
 *
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is a local function, it allocates the memory which is freed by the caller.
 *   This makes it slightly more efficient than a GetFileVersionInfoSize/GetFileVersionInfo pair.
 */
BOOL CSaferEntryHashPropertyPage::MyGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo)
{
//    VS_FIXEDFILEINFO  *pvsFFI = NULL;
//    UINT              uiBytes = 0;
    HINSTANCE         hinst = 0;
    HRSRC             hVerRes = 0;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    LPVOID            DllBase = NULL;
    VERHEAD           *pVerHead = 0;
    BOOL              bResult = FALSE;
    DWORD             dwHandle = 0;
    DWORD             dwLength = 0;

    if (!lpVersionInfo)
        return FALSE;

    *lpVersionInfo = NULL;

    FileHandle = CreateFile( lpszFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Cleanup;

    MappingHandle = CreateFileMapping( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );

    if (MappingHandle == NULL)
        goto Cleanup;

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    if (DllBase == NULL)
        goto Cleanup;

    hinst = (HMODULE)((ULONG_PTR)DllBase | 0x00000001);
    __try {

        hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
        if (hVerRes == NULL)
        {
            // Probably a 16-bit file.  Fall back to system APIs.
            dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle);
            if( !dwLength )
            {
                if(!GetLastError())
                    SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
                __leave;
            }

            *lpVersionInfo = ::LocalAlloc (LPTR, dwLength);
            if ( !(*lpVersionInfo) )
                __leave;

            if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo))
                __leave;

            bResult = TRUE;
            __leave;
        }   
            
        pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
        if (pVerHead == NULL)
            __leave;

        *lpVersionInfo = ::LocalAlloc (LPTR, pVerHead->wTotLen + pVerHead->wTotLen/2);
        if (*lpVersionInfo == NULL)
            __leave;

        memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
        bResult = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    }

Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase)
        UnmapViewOfFile(DllBase);
    if (*lpVersionInfo && bResult == FALSE)
        ::LocalFree (*lpVersionInfo);

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// Method:  OnHashEntryBrowse
//
// Purpose: Allow the user to browse for a file, then create a hash and an
//          output string for use as the friendly name, using the following
//          rules:
//
//          If either the product name or description information is found in 
//          the version resource, provide the following (in order):
//
//	        Description
//	        Product name
//	        Company name
//	        File name
//	        Fixed file version
//
//	        Details:
//          1) Use the fixed file version, since that is what is shown in the 
//              Windows Explorer properties.
//          2) Prefer the long file name to the 8.3 name.
//          3) Delimit the fields with '\n'.
//          4) If the field is missing, don't output the field or the delimiter
//          5) Instead of displaying the file version on a new line, display 
//              it after the file name in parens, as in "Filename (1.0.0.0)"
//          6) Since we are limited to 256 TCHARs, we have to accomodate long 
//              text. First, format the text as described above to determine 
//              its length. If it is too long, truncate one field at a time in 
//              the following order: Company name, Description, Product name. 
//              To truncate a field, set it to a maximum of 60 TCHARs, then 
//              append a "...\n" to visually indicate that the field was 
//              truncated. Lastly, if the text is still to long, use the 8.3 
//              file name instead of the long filename.
//
//          If neither the product name nor description information is found, 
//          provide the following (in order):
//
//          File name
//          File size
//          File last modified date
//
//          Details:
//          1) If the file size is < 1 KB, display the number in bytes, as in 
//              "123 bytes". If the file size is >= 1 KB, display in KB, as in 
//              "123 KB". Of course, 1 KB is 1024 bytes. Note that the older 
//              style format "123K" is no longer used in Windows.
//          2) For the last modified date, use the short format version in the 
//              user's current locale.
//          3) Delimit the fields with '\n'.
//          4) If the field is missing, don't output the field or the delimiter
//
///////////////////////////////////////////////////////////////////////////////

void CSaferEntryHashPropertyPage::OnHashEntryBrowse() 
{
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_SAFER_PATH_ENTRY_FILE_FILTER));

    // replace "|" with 0;
    const size_t  nFilterLen = wcslen (szFileFilter) + 1;
    PWSTR   pszFileFilter = new WCHAR [nFilterLen];
    if ( pszFileFilter )
    {
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }

        WCHAR           szFile[MAX_PATH];
        ::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
        wcscpy (szFile, m_szLastOpenedFile);

        OPENFILENAME    ofn;
        ::ZeroMemory (&ofn, sizeof (OPENFILENAME));

        ofn.lStructSize = sizeof (OPENFILENAME);
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = (PCWSTR) pszFileFilter; 
        ofn.lpstrFile = szFile; 
        ofn.nMaxFile = MAX_PATH; 
        ofn.Flags = OFN_DONTADDTORECENT | 
            OFN_FORCESHOWHIDDEN | OFN_HIDEREADONLY; 


        CThemeContextActivator activator;
        BOOL bResult = ::GetOpenFileName (&ofn);
        if ( bResult )
        {
            m_szLastOpenedFile = ofn.lpstrFile;
            HANDLE  hFile = ::CreateFile(
                    ofn.lpstrFile,                         // file name
                    GENERIC_READ,                      // access mode
                    FILE_SHARE_READ,                          // share mode
                    0, // SD
                    OPEN_EXISTING,                // how to create
                    FILE_ATTRIBUTE_NORMAL,                 // file attributes
                    0 );                       // handle to template file
            if ( INVALID_HANDLE_VALUE != hFile )
            {
                bResult = GetFileSizeEx(
                        hFile,              // handle to file
                        (PLARGE_INTEGER) &m_nFileSize);  // file size
                if ( !bResult )
                {
                    DWORD   dwErr = GetLastError ();
                    CloseHandle (hFile);
                    _TRACE (0, L"GetFileSizeEx () failed: 0x%x\n", dwErr);
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    text.FormatMessage (IDS_CANNOT_GET_FILESIZE, ofn.lpstrFile, 
                            GetSystemMessage (dwErr));

                    MessageBox (text, caption, MB_OK);
                    
                    return;
                }

                if ( 0 == m_nFileSize )
                {
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    text.FormatMessage (IDS_ZERO_BYTE_FILE_CANNOT_HASH, ofn.lpstrFile);

                    MessageBox (text, caption, MB_OK);
                    
                    return;
                }

                FILETIME    ftLastModified;
                

                bResult = ::GetFileTime (hFile, // handle to file
                        0,    // creation time
                        0,  // last access time
                        &ftLastModified);    // last write time

                ::ZeroMemory (m_rgbFileHash, SAFER_MAX_HASH_SIZE);
                HRESULT hr = GetSignedFileHash (ofn.lpstrFile, m_rgbFileHash, 
                        &m_cbFileHash, &m_hashAlgid);
                if ( FAILED (hr) )
                {
                    m_hashAlgid = 0;
                    hr = ComputeMD5Hash (hFile, m_rgbFileHash, m_cbFileHash);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( SHA1_HASH_LEN == m_cbFileHash )
                            m_hashAlgid = CALG_SHA;
                        else if ( MD5_HASH_LEN == m_cbFileHash )
                            m_hashAlgid = CALG_MD5;
                        else
                        {
                            ASSERT (0);
                        }
                    }
                }

                VERIFY (CloseHandle (hFile));
                hFile = 0;

                if ( SUCCEEDED (hr) )
                {
                    FormatAndDisplayHash ();

                    PBYTE pData = 0;
                    bResult = MyGetFileVersionInfo (ofn.lpstrFile, (LPVOID*) &pData);
                    if ( bResult )
                    {
                        CString infoString = BuildHashFileInfoString (pData);
                        m_hashFileDetailsEdit.SetWindowText (infoString);


                        m_bDirty = true;
                        SetModified ();
                    }
                    else
                    {
                        CString infoString (wcsrchr(ofn.lpstrFile, L'\\') + 1);
                        CString szDate;

                        infoString += pcszNEWLINE;
                        WCHAR   szBuffer[32];
                        CString szText;
                        if ( m_nFileSize < 1024 )
                        {
                            wsprintf (szBuffer, L"%u", m_nFileSize);
                            infoString += szBuffer;
                            VERIFY (szText.LoadString (IDS_BYTES));
                            infoString += L" ";
                            infoString += szText;
                        }
                        else
                        {
                            __int64    nFileSize = m_nFileSize;
                            nFileSize += 1024; // this causes us to round up
                            nFileSize /= 1024;
                            wsprintf (szBuffer, L"%u ", nFileSize);
                            infoString += szBuffer;
                            VERIFY (szText.LoadString (IDS_KB));
                            infoString += L" ";
                            infoString += szText;
                        }

                        hr = FormatDate (ftLastModified, szDate, 
                                DATE_SHORTDATE, true);
                    
                        if ( SUCCEEDED (hr) )
                        {
                            infoString += pcszNEWLINE;
                            infoString += szDate;
                        }

                        m_hashFileDetailsEdit.SetWindowText (infoString);
                        m_bDirty = true;
                        SetModified ();
                    }
                    ::LocalFree (pData);
                }
                else
                {
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    text.FormatMessage (IDS_CANNOT_HASH_FILE, ofn.lpstrFile, 
                            GetSystemMessage (hr));

                    MessageBox (text, caption, MB_OK);
                }
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"CreateFile (%s, OPEN_EXISTING) failed: 0x%x\n", 
                        ofn.lpstrFile, dwErr);

                CString text;
                CString caption;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_FILE_CANNOT_BE_READ, ofn.lpstrFile, 
                        GetSystemMessage (dwErr));

                MessageBox (text, caption, MB_OK);
            }
        }	

        delete [] pszFileFilter;
    }
}

/***************************************************************************\
*
* BuildHashFileInfoString()
*
*  Given a file name, GetVersion retrieves the version
*    information from the specified file.
*
*
\***************************************************************************/
const PWSTR VERSION_INFO_KEY_ROOT = L"\\StringFileInfo\\";

CString CSaferEntryHashPropertyPage::BuildHashFileInfoString (PVOID pData)
{
    CString szInfoString;
    PVOID   lpInfo = 0;
    UINT    cch = 0;
    CString key;
    WCHAR   szBuffer[10];
    CString keyBase;

    wsprintf (szBuffer, L"%04X", GetUserDefaultLangID ());
	wcscat (szBuffer, L"04B0");
    
    keyBase = VERSION_INFO_KEY_ROOT;
    keyBase += szBuffer;
    keyBase += L"\\";
    
    CString productName;
    CString description;
    CString companyName;
    CString fileName;
    CString fileVersion;
 

    key = keyBase + L"ProductName";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        productName = (PWSTR) lpInfo;
    }

    key = keyBase + L"FileDescription";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        description = (PWSTR) lpInfo;
    }

    key = keyBase + L"CompanyName";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        companyName = (PWSTR) lpInfo;
    }

    key = keyBase + L"OriginalFilename";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        fileName = (PWSTR) lpInfo;
    }

    // Get Fixedlength fileInfo
    VS_FIXEDFILEINFO *pFixedFileInfo = 0;
    if ( VerQueryValue (pData, L"\\", (PVOID*) &pFixedFileInfo, &cch) )
    {
        WCHAR   szFileVer[32];

        wsprintf(szFileVer, L"%u.%u.%u.%u",
                HIWORD(pFixedFileInfo->dwFileVersionMS),
                LOWORD(pFixedFileInfo->dwFileVersionMS),
                HIWORD(pFixedFileInfo->dwFileVersionLS),
                LOWORD(pFixedFileInfo->dwFileVersionLS));
        fileVersion = szFileVer;
    }

    int nLen = 0;
    do {
        szInfoString = ConcatStrings (productName, description, companyName, fileName, fileVersion);
        nLen = szInfoString.GetLength ();
        if ( nLen >= SAFER_MAX_FRIENDLYNAME_SIZE )
        {
            if ( CheckLengthAndTruncateToken (companyName) )
                continue;

            if ( CheckLengthAndTruncateToken (description) )
                continue;

            if ( CheckLengthAndTruncateToken (productName) )
                continue;

            szInfoString.SetAt (SAFER_MAX_FRIENDLYNAME_SIZE-4, 0);
            szInfoString += L"...";
        }
    } while (nLen >= SAFER_MAX_FRIENDLYNAME_SIZE);

    return szInfoString;
}

bool CSaferEntryHashPropertyPage::CheckLengthAndTruncateToken (CString& token)
{
    bool        bResult = false;
    const int   nMAX_ITEM_LEN = 60;

    int nItemLen = token.GetLength ();
    if ( nItemLen > nMAX_ITEM_LEN )
    {
        token.SetAt (nMAX_ITEM_LEN-5, 0);
        token += L"...";
        token += pcszNEWLINE;
        bResult = true;
    }

    return bResult;
}

CString CSaferEntryHashPropertyPage::ConcatStrings (
            const CString& productName, 
            const CString& description, 
            const CString& companyName,
            const CString& fileName, 
            const CString& fileVersion)
{
    CString szInfoString;

    if ( !description.IsEmpty () )
        szInfoString += description + pcszNEWLINE;

    if ( !productName.IsEmpty () )
        szInfoString += productName + pcszNEWLINE;

    if ( !companyName.IsEmpty () )
        szInfoString += companyName + pcszNEWLINE;

    if ( !fileName.IsEmpty () )
        szInfoString += fileName;

    if ( !fileVersion.IsEmpty () )
    {
        szInfoString += L" (";
        szInfoString += fileVersion + L")";;
    }

    return szInfoString;
}

BOOL CSaferEntryHashPropertyPage::OnApply() 
{
    CString szText;
    CThemeContextActivator activator;

    GetDlgItemText (IDC_HASH_HASHED_FILE_PATH, szText);

    if ( szText.IsEmpty () )
    {
        CString szCaption;

        VERIFY (szCaption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        VERIFY (szText.LoadString (IDS_USER_MUST_ENTER_HASH));

        MessageBox (szText, szCaption, MB_OK);

        GetDlgItem (IDC_HASH_HASHED_FILE_PATH)->SetFocus ();
        return FALSE;
    }

	if ( !m_bReadOnly && m_bDirty )
    {
        if ( !ConvertStringToHash ((PCWSTR) szText) )
        {
            GetDlgItem (IDC_HASH_HASHED_FILE_PATH)->SetFocus ();
            return FALSE;
        }

        // Get image size and hash type
        bool    bBadFormat = false;
        int nFirstColon = szText.Find (L":", 0);
        if ( -1 != nFirstColon )
        {
            int nSecondColon = szText.Find (L":", nFirstColon+1);
            if ( -1 != nSecondColon )
            {
                CString szImageSize = szText.Mid (nFirstColon+1, nSecondColon - (nFirstColon + 1));
                CString szHashType = szText.Right (((int) wcslen (szText)) - (nSecondColon + 1));


                m_nFileSize = wcstol (szImageSize, 0, 10);
                m_hashAlgid = wcstol (szHashType, 0, 10);
            }
            else
                bBadFormat = true;
        }
        else
            bBadFormat = true;

        if ( bBadFormat )
        {
            CString caption;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (szText.LoadString (IDS_HASH_STRING_BAD_FORMAT));

            MessageBox (szText, caption, MB_OK);

            return FALSE;
        }
       



        if ( !m_cbFileHash )
        {
            CString caption;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (szText.LoadString (IDS_NO_APPLICATION_SELECTED));

            MessageBox (szText, caption, MB_OK);
            GetDlgItem (IDC_HASH_ENTRY_BROWSE)->SetFocus ();
            return FALSE;
        }

	    if ( m_bDirty )
        {
            // Set the level
            int nCurSel = m_securityLevelCombo.GetCurSel ();
            ASSERT (CB_ERR != nCurSel);
            m_rSaferEntry.SetLevel ((DWORD) m_securityLevelCombo.GetItemData (nCurSel));

            // Set description
            m_descriptionEdit.GetWindowText (szText);
            m_rSaferEntry.SetDescription (szText);

            // Set friendly name
            m_hashFileDetailsEdit.GetWindowText (szText);
            m_rSaferEntry.SetHashFriendlyName (szText);

            // Get and save flags
            DWORD   dwFlags = 0;

            m_rSaferEntry.SetFlags (dwFlags);

            m_rSaferEntry.SetHash (m_rgbFileHash, m_cbFileHash, m_nFileSize, m_hashAlgid);
            HRESULT hr = m_rSaferEntry.Save ();
            if ( SUCCEEDED (hr) )
            {
                if ( m_lNotifyHandle )
                    MMCPropertyChangeNotify (
                            m_lNotifyHandle,  // handle to a notification
                            (LPARAM) m_pDataObject);          // unique identifier

                m_bDirty = false;
            }
            else
            {
                CString caption;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                if ( HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER) != hr )
                    szText.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));
                else
                    VERIFY (szText.LoadString (IDS_HASH_STRING_BAD_FORMAT));

                MessageBox (szText, caption, MB_OK);

                return FALSE;
            }
        }
    }
	
	return CHelpPropertyPage::OnApply();
}

void CSaferEntryHashPropertyPage::OnChangeHashEntryDescription() 
{
    m_bDirty = true;
    SetModified ();
}

void CSaferEntryHashPropertyPage::OnSelchangeHashEntrySecurityLevel() 
{
    m_bDirty = true;
    SetModified ();
}

void CSaferEntryHashPropertyPage::OnChangeHashHashedFilePath() 
{
    m_bDirty = true;
    SetModified ();
}

bool CSaferEntryHashPropertyPage::FormatMemBufToString(PWSTR *ppString, PBYTE pbData, DWORD cbData)
{   
    const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    DWORD   i = 0;
    PBYTE   pb;
    
    *ppString = (LPWSTR) LocalAlloc (LPTR, ((cbData * 3) * sizeof(WCHAR)));
    if ( !*ppString )
    {
        return false;
    }

    //
    // copy to the buffer
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        pb++;         
    }
    (*ppString)[i] = 0;
    
    return true;
}

bool CSaferEntryHashPropertyPage::ConvertStringToHash (PCWSTR pszString)
{
    _TRACE (1, L"Entering CSaferEntryHashPropertyPage::ConvertStringToHash (%s)\n", pszString);
    bool    bRetVal = true;
    BYTE    rgbFileHash[SAFER_MAX_HASH_SIZE];
    ::ZeroMemory (rgbFileHash, SAFER_MAX_HASH_SIZE);

    DWORD   cbFileHash = 0;
    DWORD   dwNumHashChars = 0;
    bool    bFirst = true;
    bool    bEndOfHash = false;
    CThemeContextActivator activator;

    for (int nIndex = 0; !bEndOfHash && pszString[nIndex] && bRetVal; nIndex++)
    {
        if ( cbFileHash >= SAFER_MAX_HASH_SIZE )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_HASH_STRING_TOO_LONG, SAFER_MAX_HASH_SIZE, SAFER_MAX_HASH_SIZE/4);
            _TRACE (0, L"%s", (PCWSTR) text);

            VERIFY (text.LoadString (IDS_HASH_STRING_BAD_FORMAT));
            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
            bRetVal = false;
            break;
        }
        dwNumHashChars++;
        
        switch (pszString[nIndex])
        {
        case L'0':
            bFirst = !bFirst;
            break;

        case L'1':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x10;
            else
                rgbFileHash[cbFileHash] |= 0x01;
            bFirst = !bFirst;
            break;

        case L'2':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x20;
            else
                rgbFileHash[cbFileHash] |= 0x02;
            bFirst = !bFirst;
            break;

        case L'3':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x30;
            else
                rgbFileHash[cbFileHash] |= 0x03;
            bFirst = !bFirst;
            break;

        case L'4':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x40;
            else
                rgbFileHash[cbFileHash] |= 0x04;
            bFirst = !bFirst;
            break;

        case L'5':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x50;
            else
                rgbFileHash[cbFileHash] |= 0x05;
            bFirst = !bFirst;
            break;

        case L'6':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x60;
            else
                rgbFileHash[cbFileHash] |= 0x06;
            bFirst = !bFirst;
            break;

        case L'7':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x70;
            else
                rgbFileHash[cbFileHash] |= 0x07;
            bFirst = !bFirst;
            break;

        case L'8':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x80;
            else
                rgbFileHash[cbFileHash] |= 0x08;
            bFirst = !bFirst;
            break;

        case L'9':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x90;
            else
                rgbFileHash[cbFileHash] |= 0x09;
            bFirst = !bFirst;
            break;

        case L'a':
        case L'A':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xA0;
            else
                rgbFileHash[cbFileHash] |= 0x0A;
            bFirst = !bFirst;
            break;

        case L'b':
        case L'B':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xB0;
            else
                rgbFileHash[cbFileHash] |= 0x0B;
            bFirst = !bFirst;
            break;

        case L'c':
        case L'C':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xC0;
            else
                rgbFileHash[cbFileHash] |= 0x0C;
            bFirst = !bFirst;
            break;

        case L'd':
        case L'D':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xD0;
            else
                rgbFileHash[cbFileHash] |= 0x0D;
            bFirst = !bFirst;
            break;

        case L'e':
        case L'E':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xE0;
            else
                rgbFileHash[cbFileHash] |= 0x0E;
            bFirst = !bFirst;
            break;

        case L'f':
        case L'F':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xF0;
            else
                rgbFileHash[cbFileHash] |= 0x0F;
            bFirst = !bFirst;
            break;

        case L':':
            // end of hash
            bEndOfHash = true;
            bFirst = !bFirst;
            dwNumHashChars--; // ':' already counted, subtract it
            break;

        default:
            bRetVal = false;
            {
                CString caption;
                CString text;
                WCHAR   szChar[2];

                szChar[0] = pszString[nIndex];
                szChar[1] = 0;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_HASH_STRING_INVALID_CHAR, szChar);
                _TRACE (0, L"%s", (PCWSTR) text);

                VERIFY (text.LoadString (IDS_HASH_STRING_BAD_FORMAT));

                MessageBox (text, caption, MB_ICONWARNING | MB_OK);
            }
            break;
        }

        if ( bFirst )
            cbFileHash++;
    }

    if ( bRetVal )
    {
        //  2 characters map to 1 each byte in the hash
        if ( MD5_HASH_LEN != dwNumHashChars/2 && SHA1_HASH_LEN != dwNumHashChars/2 )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (text.LoadString (IDS_HASH_INVALID_LENGTH));
            _TRACE (0, L"%s", (PCWSTR) text);

            VERIFY (text.LoadString (IDS_HASH_STRING_BAD_FORMAT));

            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
            bRetVal = false;
        }
        else
        {
            m_cbFileHash = cbFileHash;
            memcpy (m_rgbFileHash, rgbFileHash, SAFER_MAX_HASH_SIZE);
        }
    }

    _TRACE (-1, L"Leaving CSaferEntryHashPropertyPage::ConvertStringToHash (): %s\n", 
            bRetVal ? L"true" : L"false");
    return bRetVal;
}

void CSaferEntryHashPropertyPage::OnSetfocusHashHashedFilePath() 
{
    if ( m_bFirst )
    {
        if ( true == m_bReadOnly )
            SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}

void CSaferEntryHashPropertyPage::FormatAndDisplayHash ()
{
    PWSTR   pwszText = 0;

    if ( FormatMemBufToString (&pwszText, m_rgbFileHash, m_cbFileHash) )
    {
        WCHAR   szAlgID[10];
        _ltow (m_hashAlgid, szAlgID, 10);
    
        PWSTR   pszFormattedText = new WCHAR[wcslen (pwszText) + 50];
        if ( pszFormattedText )
        {

            wsprintf (pszFormattedText, L"%s:%ld:", pwszText, 
                    m_nFileSize);
            wcscat (pszFormattedText, szAlgID);
            SetDlgItemText (IDC_HASH_HASHED_FILE_PATH, 
                    pszFormattedText);
            delete [] pszFormattedText;
        }
        LocalFree (pwszText);
    }
}

void CSaferEntryHashPropertyPage::OnChangeHashEntryHashfileDetails() 
{
    SetModified ();	
    m_bDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentrycertificatepropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryCertificatePropertyPage.h
//
//  Contents:   Declaration of CSaferEntryCertificatePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
#define AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryCertificatePropertyPage.h : header file
//
#include "SaferEntry.h"
#include <cryptui.h>
#include "SaferUtil.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryCertificatePropertyPage dialog
class CCertMgrComponentData; // forward declaration
class CSaferEntryCertificatePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferEntryCertificatePropertyPage(CSaferEntry& rSaferEntry,
            CSaferEntries* pSaferEntries,
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            CCertMgrComponentData* pCompData,
            bool bNew,
            IGPEInformation* pGPEInformation,
            bool bIsMachine);
	~CSaferEntryCertificatePropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryCertificatePropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_CERTIFICATE };
	CEdit	m_descriptionEdit;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryCertificatePropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryCertificatePropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCertEntryBrowse();
	afx_msg void OnChangeCertEntryDescription();
	afx_msg void OnSelchangeCertEntrySecurityLevel();
	afx_msg void OnSaferCertView();
	afx_msg void OnSetfocusCertEntrySubjectName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    void LaunchCommonCertDialog ();

private:
	CCertStore*                         m_pOriginalStore;
	bool m_bDirty;
    CSaferEntry&                        m_rSaferEntry;
    CRYPTUI_SELECTCERTIFICATE_STRUCT    m_selCertStruct;
    bool                                m_bStoresEnumerated;
    bool                                m_bCertificateChanged;
    PCCERT_CONTEXT	                    m_pCertContext;
    CSaferEntries*                      m_pSaferEntries;
    LONG_PTR                            m_lNotifyHandle;
    LPDATAOBJECT                        m_pDataObject;
    const bool                          m_bReadOnly;
    CCertMgrComponentData*              m_pCompData;
    IGPEInformation*                    m_pGPEInformation;
    bool                                m_bIsMachine;
    bool                                m_bFirst;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentrycertificatepropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryCertificatePropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryCertificatePropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryCertificatePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "compdata.h"
#include "certmgr.h"
#include "SaferEntryCertificatePropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryCertificatePropertyPage property page


CSaferEntryCertificatePropertyPage::CSaferEntryCertificatePropertyPage(
        CSaferEntry& rSaferEntry,
        CSaferEntries* pSaferEntries,
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        CCertMgrComponentData* pCompData,
        bool bNew,
        IGPEInformation* pGPEInformation,
        bool bIsMachine) : 
    CHelpPropertyPage(CSaferEntryCertificatePropertyPage::IDD),
    m_rSaferEntry (rSaferEntry),
    m_bStoresEnumerated (false),
    m_bCertificateChanged (false),
    m_pCertContext (0),
    m_pSaferEntries (pSaferEntries),
    m_bDirty (bNew),
    m_pOriginalStore (0),
    m_lNotifyHandle (lNotifyHandle),
    m_pDataObject (pDataObject),
    m_bReadOnly (bReadOnly),
    m_pCompData (pCompData),
    m_pGPEInformation (pGPEInformation),
    m_bIsMachine (bIsMachine),
    m_bFirst (true)
{
	//{{AFX_DATA_INIT(CSaferEntryCertificatePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rSaferEntry.AddRef ();
    m_rSaferEntry.IncrementOpenPageCount ();

    ::ZeroMemory (&m_selCertStruct, sizeof (m_selCertStruct));

    if ( m_pSaferEntries )
        m_pSaferEntries->AddRef ();

    if ( m_pCompData )
        m_pCompData->AddRef ();
}

CSaferEntryCertificatePropertyPage::~CSaferEntryCertificatePropertyPage()
{
    m_rSaferEntry.DecrementOpenPageCount ();
    m_rSaferEntry.Release ();
  	// Clean up enumerated store list
	for (DWORD dwIndex = 0; dwIndex < m_selCertStruct.cDisplayStores; dwIndex++)
	{
		ASSERT (m_selCertStruct.rghDisplayStores);
        if ( m_selCertStruct.rghDisplayStores[dwIndex] )
		    ::CertCloseStore (m_selCertStruct.rghDisplayStores[dwIndex], CERT_CLOSE_STORE_FORCE_FLAG);
	}
	if ( m_selCertStruct.rghDisplayStores )
		delete [] m_selCertStruct.rghDisplayStores;

//    if ( m_pCertContext )
//        CertFreeCertificateContext (m_pCertContext);

    if ( m_pCompData )
        m_pCompData->Release ();

    if ( m_pSaferEntries )
        m_pSaferEntries->Release ();

    if ( m_pOriginalStore )
        m_pOriginalStore->Release ();

    if ( m_lNotifyHandle )
        MMCFreeNotifyHandle (m_lNotifyHandle);
}

void CSaferEntryCertificatePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferEntryCertificatePropertyPage)
	DDX_Control(pDX, IDC_CERT_ENTRY_DESCRIPTION, m_descriptionEdit);
	DDX_Control(pDX, IDC_CERT_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryCertificatePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferEntryCertificatePropertyPage)
	ON_BN_CLICKED(IDC_CERT_ENTRY_BROWSE, OnCertEntryBrowse)
	ON_EN_CHANGE(IDC_CERT_ENTRY_DESCRIPTION, OnChangeCertEntryDescription)
	ON_CBN_SELCHANGE(IDC_CERT_ENTRY_SECURITY_LEVEL, OnSelchangeCertEntrySecurityLevel)
	ON_BN_CLICKED(IDC_SAFER_CERT_VIEW, OnSaferCertView)
	ON_EN_SETFOCUS(IDC_CERT_ENTRY_SUBJECT_NAME, OnSetfocusCertEntrySubjectName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryCertificatePropertyPage message handlers
void CSaferEntryCertificatePropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryCertificatePropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_CERT_ENTRY_SUBJECT_NAME, IDH_CERT_ENTRY_SUBJECT_NAME,
        IDC_CERT_ENTRY_BROWSE, IDH_CERT_ENTRY_BROWSE,
        IDC_CERT_ENTRY_SECURITY_LEVEL, IDH_CERT_ENTRY_SECURITY_LEVEL,
        IDC_CERT_ENTRY_DESCRIPTION, IDH_CERT_ENTRY_DESCRIPTION,
        IDC_CERT_ENTRY_LAST_MODIFIED, IDH_CERT_ENTRY_LAST_MODIFIED,
        0, 0
    };


    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_CERT_ENTRY_SUBJECT_NAME:
    case IDC_CERT_ENTRY_BROWSE:
    case IDC_CERT_ENTRY_SECURITY_LEVEL:
    case IDC_CERT_ENTRY_DESCRIPTION:
    case IDC_CERT_ENTRY_LAST_MODIFIED:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryCertificatePropertyPage::DoContextHelp\n");
}


BOOL CSaferEntryCertificatePropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
    HRESULT hr = S_OK;
    DWORD   dwLevelID = m_rSaferEntry.GetLevel ();

    ASSERT (SAFER_LEVELID_FULLYTRUSTED == dwLevelID || SAFER_LEVELID_DISALLOWED == dwLevelID);
    switch (dwLevelID)
    {
    case SAFER_LEVELID_FULLYTRUSTED:
        hr = m_pSaferEntries->GetTrustedPublishersStore (&m_pOriginalStore);
        break;

    case SAFER_LEVELID_DISALLOWED:
        hr = m_pSaferEntries->GetDisallowedStore (&m_pOriginalStore);
        break;

    default:
        break;
    }

    CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsMachine);
    InitializeSecurityLevelComboBox (m_securityLevelCombo, true, dwLevelID, 
            policyKey.GetKey (), m_pCompData->m_pdwSaferLevels,
            m_bIsMachine);

    m_descriptionEdit.LimitText (SAFER_MAX_DESCRIPTION_SIZE);
    m_descriptionEdit.SetWindowText (m_rSaferEntry.GetDescription ());

    SetDlgItemText (IDC_CERT_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

    CCertificate*   pCert = 0;
    hr = m_rSaferEntry.GetCertificate (&pCert);
    if ( SUCCEEDED (hr) && pCert )
    {
        m_pCertContext = CertDuplicateCertificateContext (pCert->GetCertContext ());
        if ( m_pCertContext )
            SetDlgItemText (IDC_CERT_ENTRY_SUBJECT_NAME, ::GetNameString (m_pCertContext, 0));
        pCert->Release ();
    }

    if ( !m_pCertContext )
        GetDlgItem (IDC_SAFER_CERT_VIEW)->EnableWindow (FALSE);

    if ( m_bReadOnly )
    {
        m_descriptionEdit.EnableWindow (FALSE);
        m_securityLevelCombo.EnableWindow (FALSE);
        GetDlgItem (IDC_CERT_ENTRY_BROWSE)->EnableWindow (FALSE);
    }

    if ( !m_bDirty )
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_CERTIFICATE_TITLE));
        SetDlgItemText (IDC_CERTIFICATE_TITLE, szText);
    }
    else
    {
        SetDlgItemText (IDC_DATE_LAST_MODIFIED_LABEL, L""); 
        GetDlgItem (IDC_CERT_ENTRY_LAST_MODIFIED)->ShowWindow (SW_HIDE);
    }


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

typedef struct _ENUM_ARG {
    DWORD				dwFlags;
    DWORD*              pcDisplayStores;          
    HCERTSTORE **       prghDisplayStores;        
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumSaferStoresSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD /*dwFlags*/,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void * /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
	void*		pvPara = (void*)pwszSystemStore;



	HCERTSTORE	hNewStore  = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
				CERT_SYSTEM_STORE_CURRENT_USER, pvPara);
	if ( !hNewStore )
	{
		hNewStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
				CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG, pvPara);
	}
	if ( hNewStore )
	{
		DWORD		dwCnt = *(pEnumArg->pcDisplayStores);
		HCERTSTORE*	phStores = 0;

		phStores = new HCERTSTORE[dwCnt+1];
		if ( phStores )
		{
			DWORD	dwIndex = 0;
			if ( *(pEnumArg->prghDisplayStores) )
			{
				for (; dwIndex < dwCnt; dwIndex++)
				{
					phStores[dwIndex] = (*(pEnumArg->prghDisplayStores))[dwIndex];
				}
				delete [] (*(pEnumArg->prghDisplayStores));
			}
			(*(pEnumArg->pcDisplayStores))++;
			(*(pEnumArg->prghDisplayStores)) = phStores;
			(*(pEnumArg->prghDisplayStores))[dwIndex] = hNewStore;
		}
		else
		{
			SetLastError (ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}
	}

    return TRUE;
}

void CSaferEntryCertificatePropertyPage::OnCertEntryBrowse() 
{
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_SAFER_CERTFILEFILTER));

    // replace "|" with 0;
    const size_t  nFilterLen = wcslen (szFileFilter) + 1;
    PWSTR   pszFileFilter = new WCHAR [nFilterLen];
    if ( pszFileFilter )
    {
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }

        WCHAR           szFile[MAX_PATH];
        ::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
        OPENFILENAME    ofn;
        ::ZeroMemory (&ofn, sizeof (OPENFILENAME));

        ofn.lStructSize = sizeof (OPENFILENAME);
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = (PCWSTR) pszFileFilter; 
        ofn.lpstrFile = szFile; 
        ofn.nMaxFile = MAX_PATH; 
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; 


        BOOL bResult = ::GetOpenFileName (&ofn);
        if ( bResult )
        {
            CString szFileName = ofn.lpstrFile;
		    //
		    // Open cert store from the file
		    //

		    HCERTSTORE      hCertStore = NULL;
		    PVOID			FileNameVoidP = (PVOID) (LPCWSTR)szFileName;
		    PCCERT_CONTEXT  pCertContext = NULL;
		    DWORD			dwEncodingType = 0;
		    DWORD			dwContentType = 0;
		    DWORD			dwFormatType = 0;

		    BOOL	bReturn = ::CryptQueryObject (
				    CERT_QUERY_OBJECT_FILE,
				    FileNameVoidP,
				    CERT_QUERY_CONTENT_FLAG_ALL,
				    CERT_QUERY_FORMAT_FLAG_ALL,
				    0,
				    &dwEncodingType,
				    &dwContentType,
				    &dwFormatType,
				    &hCertStore,
				    NULL,
				    (const void **)&pCertContext);
		    if ( bReturn )
		    {
			    //
			    // Success. See what we get back. A store or a cert.
			    //

			    if (  (dwContentType == CERT_QUERY_CONTENT_SERIALIZED_STORE)
					    && hCertStore)
			    {

 				    CERT_ENHKEY_USAGE	enhKeyUsage;
				    ::ZeroMemory (&enhKeyUsage, sizeof (CERT_ENHKEY_USAGE));
				    enhKeyUsage.cUsageIdentifier = 1;
				    enhKeyUsage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;
				    //
				    // We get the certificate store
				    //
				    pCertContext = ::CertFindCertificateInStore (
						    hCertStore,
						    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						    0,
						    CERT_FIND_ENHKEY_USAGE,
						    &enhKeyUsage,
 						    NULL);
				    if ( !pCertContext )
				    {
					    CString	caption;
					    CString text;
                        CThemeContextActivator activator;

					    VERIFY (text.LoadString (IDS_FILE_CONTAINS_NO_CERT));
					    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
					    MessageBox (text, caption, MB_OK);
					    return;
				    }

				    if ( hCertStore )
					    ::CertCloseStore (hCertStore, 0);
			    }
			    else if ( (dwContentType != CERT_QUERY_CONTENT_CERT) || !pCertContext )
			    {
				    //
				    // Neither a valid cert file nor a store file we like.
				    //

				    if ( hCertStore )
					    ::CertCloseStore (hCertStore, 0);

				    if  ( pCertContext )
					    ::CertFreeCertificateContext (pCertContext);

				    CString ErrMsg;
                    CThemeContextActivator activator;

				    VERIFY (ErrMsg.LoadString (IDS_CERTFILEFORMATERR));
				    MessageBox (ErrMsg);
				    return;

			    }

                if ( pCertContext )
                {
                    if ( m_pCertContext )
                        CertFreeCertificateContext (m_pCertContext);
            
                    m_pCertContext = pCertContext;
                    if ( m_pCertContext )
                    {
                        SetDlgItemText (IDC_CERT_ENTRY_SUBJECT_NAME, ::GetNameString (m_pCertContext, 0));
                        GetDlgItem (IDC_SAFER_CERT_VIEW)->EnableWindow (TRUE);
                    }

                    m_bCertificateChanged = true;
                    m_bDirty = true;
                    SetModified ();
                }

			    if ( hCertStore )
			    {
				    ::CertCloseStore (hCertStore, 0);
				    hCertStore = NULL;
			    }
		    }
		    else
		    {
			    //
			    // Fail. Get the error code.
			    //
			    DWORD   dwErr = GetLastError ();
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
			    text.FormatMessage (IDS_CERTFILEOPENERR, szFileName, 
                        GetSystemMessage (dwErr));
			    MessageBox (text, caption);
		    }
        }

        delete [] pszFileFilter;
	}
}

BOOL CSaferEntryCertificatePropertyPage::OnApply() 
{
    if ( !m_bReadOnly )
    {
        ASSERT (m_pSaferEntries);
        if ( !m_pSaferEntries )
            return FALSE;

        CThemeContextActivator activator;
        if ( !m_pCertContext )
        {
            CString     text;
            CString     caption;

            VERIFY (text.LoadString (IDS_SAFER_MUST_CHOOSE_CERT));
            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            MessageBox (text, caption, MB_OK);
            GetDlgItem (IDC_CERT_ENTRY_BROWSE)->SetFocus ();
            return FALSE;
        }

        if ( m_bDirty )
        {
            int nCurSel = m_securityLevelCombo.GetCurSel ();
            ASSERT (CB_ERR < nCurSel);
            if ( CB_ERR < nCurSel )
            {
                CCertStore* pTrustedPublishersStore = 0;
        
                HRESULT hr = m_pSaferEntries->GetTrustedPublishersStore (&pTrustedPublishersStore);
                ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    CCertStore* pDisallowedStore = 0;
                    hr = m_pSaferEntries->GetDisallowedStore (&pDisallowedStore);
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        DWORD_PTR dwLevel = m_securityLevelCombo.GetItemData (nCurSel);
                        m_rSaferEntry.SetLevel ((DWORD) dwLevel);

                        CCertStore* pStore = (SAFER_LEVELID_FULLYTRUSTED == dwLevel) ?
                                pTrustedPublishersStore : pDisallowedStore;
                        CCertificate*   pCert = 0;
	                    hr = m_rSaferEntry.GetCertificate (&pCert);
                        if ( E_NOTIMPL == hr )
                        {
                            // This is a new entry

                            if ( m_pOriginalStore )
                                m_pOriginalStore->Release ();
                            m_pOriginalStore = pStore;
                            m_pOriginalStore->AddRef ();

                            CCertificate* pNewCert = new CCertificate (
                                    m_pCertContext,
                                    pStore);
                            if ( pNewCert )
                            {
                                hr = m_rSaferEntry.SetCertificate (pNewCert);
                            }
                            else
                                hr = E_OUTOFMEMORY;

                            if ( SUCCEEDED (hr) )
                            {
                                CString szDescription;
                                m_descriptionEdit.GetWindowText (szDescription);
                                m_rSaferEntry.SetDescription (szDescription);

                                hr = m_rSaferEntry.Save ();
                                if ( SUCCEEDED (hr) )
                                {
                                    pStore->Commit ();
                                    if ( m_lNotifyHandle )
                                        MMCPropertyChangeNotify (
                                                m_lNotifyHandle,  // handle to a notification
                                                (LPARAM) m_pDataObject);          // unique identifier
 
                                    m_bDirty = false;
                                }
                                else
                                {
                                    CString text;
                                    CString caption;

                                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                                    text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

                                    MessageBox (text, caption, MB_OK);
                                }
                            }
                        }
                        else
                        {
                            // We're modifying an existing entry
                            ASSERT (m_pSaferEntries);
                            if ( m_pSaferEntries )
                            {
                                // 1. If original cert has been changed, it must be removed from its 
                                // store and the new one added to the appropriate store
                                // 2. If the security level was changed.  The cert 
                                // removed from the original store, which must be Committed and
                                // released.  The cert must then be added to the new store.
                                // 3. If both the cert and the level have been changed, same as step 2.
                                if ( m_bCertificateChanged )
                                {
                                    CCertificate* pNewCert = new CCertificate (
                                            ::CertDuplicateCertificateContext (m_pCertContext),
                                            pStore);
                                    if ( pNewCert )
                                    {
                                        hr = m_rSaferEntry.SetCertificate (pNewCert);
                                    }
                                }
                            }

                            CString szDescription;
                            m_descriptionEdit.GetWindowText (szDescription);
                            m_rSaferEntry.SetDescription (szDescription);

                            hr = m_rSaferEntry.SetLevel ((DWORD) dwLevel);
                            if ( SUCCEEDED (hr) )
                            {
                                hr = m_rSaferEntry.Save ();
                                if ( SUCCEEDED (hr) )
                                {
                                    pDisallowedStore->Commit ();
                                    pTrustedPublishersStore->Commit ();

                                    if ( m_lNotifyHandle )
                                        MMCPropertyChangeNotify (
                                                m_lNotifyHandle,  // handle to a notification
                                                (LPARAM) m_pDataObject);          // unique identifier
 
                                    m_bDirty = false;
                                }
                                else
                                {
                                    CString text;
                                    CString caption;

                                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                                    text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

                                    MessageBox (text, caption, MB_OK);
                                }
                            }
                        }

                        pDisallowedStore->Release ();
                    }

                    pTrustedPublishersStore->Release ();
                }
            }
        }
    }

    if ( !m_bDirty )
	    return CHelpPropertyPage::OnApply();
    else
        return FALSE;
}

void CSaferEntryCertificatePropertyPage::OnChangeCertEntryDescription() 
{
    m_bDirty = true;
    SetModified ();	
}

void CSaferEntryCertificatePropertyPage::OnSelchangeCertEntrySecurityLevel() 
{
    m_bDirty = true;
    SetModified ();	
}

void CSaferEntryCertificatePropertyPage::OnSaferCertView() 
{
    LaunchCommonCertDialog ();
}

void CSaferEntryCertificatePropertyPage::LaunchCommonCertDialog ()
{
	_TRACE (1, L"Entering CSaferEntryCertificatePropertyPage::LaunchCommonCertDialog\n");
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if ( !m_pCertContext )
        return;

    HRESULT                                 hr = S_OK;
    CWaitCursor                             waitCursor;
	CTypedPtrList<CPtrList, CCertStore*>    storeList;

	//  Add the Root store first on a remote machine.
	if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
	{
		storeList.AddTail (new CCertStore (CERTMGR_LOG_STORE,
				CERT_STORE_PROV_SYSTEM,
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				(LPCWSTR) m_pCompData->GetManagedComputer (),
				ROOT_SYSTEM_STORE_NAME,
				ROOT_SYSTEM_STORE_NAME,
				_T (""), ROOT_STORE,
				CERT_SYSTEM_STORE_LOCAL_MACHINE,
				m_pCompData->m_pConsole));
	}

	hr = m_pCompData->EnumerateLogicalStores (&storeList);
	if ( SUCCEEDED (hr) )
	{
          POSITION pos = 0;
          POSITION prevPos = 0;

          // Validate store handles
		for (pos = storeList.GetHeadPosition ();
				pos;)
		{
               prevPos = pos;
			CCertStore* pStore = storeList.GetNext (pos);
			ASSERT (pStore);
			if ( pStore )
			{
                // Do not open the userDS store
                if ( USERDS_STORE == pStore->GetStoreType () )
                {
                    storeList.RemoveAt (prevPos);
                    pStore->Release ();
                    pStore = 0;
                }
                else
                {
				    if ( !pStore->GetStoreHandle () )
                    {
                        CString	caption;
                        CString	text;
                        CThemeContextActivator activator;

                        text.FormatMessage (IDS_CANT_OPEN_STORE_AND_FAIL, pStore->GetLocalizedName ());
                        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                        MessageBox (text, caption, MB_ICONWARNING | MB_OK);
                        break;
                    }
                }
			}
		}

          // Proceed only if all handles are valid 
          if ( SUCCEEDED (hr) )
          {
		     CRYPTUI_VIEWCERTIFICATE_STRUCT	vcs;
		     ::ZeroMemory (&vcs, sizeof (vcs));
		     vcs.dwSize = sizeof (vcs);
		     vcs.hwndParent = m_hWnd;

		     //  Set these flags only on a remote machine.
		     if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
			     vcs.dwFlags = CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
		     else
			     vcs.dwFlags = 0;

             vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

		     vcs.pCertContext = m_pCertContext;
		     vcs.cStores = (DWORD)storeList.GetCount ();
		     vcs.rghStores = new HCERTSTORE[vcs.cStores];
		     if ( vcs.rghStores )
		     {
			     CCertStore*		pStore = 0;
			     DWORD			index = 0;

			     for (pos = storeList.GetHeadPosition ();
					     pos && index < vcs.cStores;
					     index++)
			     {
				     pStore = storeList.GetNext (pos);
				     ASSERT (pStore);
				     if ( pStore )
				     {
					     vcs.rghStores[index] = pStore->GetStoreHandle ();
				     }
			     }

			     BOOL fPropertiesChanged = FALSE;
          	     _TRACE (0, L"Calling CryptUIDlgViewCertificate()\n");
                 CThemeContextActivator activator;
			     ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);

			     delete vcs.rghStores;
		     }
		     else
			     hr = E_OUTOFMEMORY;
        }

		while (!storeList.IsEmpty () )
		{
			CCertStore* pStore = storeList.RemoveHead ();
			if ( pStore )
			{
				pStore->Close ();
				pStore->Release ();
			}
		}
	}

	_TRACE (-1, L"Leaving CSaferEntryCertificatePropertyPage::LaunchCommonCertDialog: 0x%x\n", hr);
}

void CSaferEntryCertificatePropertyPage::OnSetfocusCertEntrySubjectName() 
{
    if ( m_bFirst )
    {
        SendDlgItemMessage (IDC_CERT_ENTRY_SUBJECT_NAME, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentryhashpropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryHashPropertyPage.h
//
//  Contents:   Declaration of CSaferEntryHashPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYHASHPROPERTYPAGE_H__9F1BE911_6A3E_4BBA_8BE9_BFE3B29D2A6F__INCLUDED_)
#define AFX_SAFERENTRYHASHPROPERTYPAGE_H__9F1BE911_6A3E_4BBA_8BE9_BFE3B29D2A6F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryHashPropertyPage.h : header file
//
#include "SaferEntry.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryHashPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CSaferEntryHashPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferEntryHashPropertyPage(
            CSaferEntry& rSaferEntry, 
            LONG_PTR lNotifyHandle, 
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            CCertMgrComponentData*   pCompData,
            bool bIsMachine);
	~CSaferEntryHashPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryHashPropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_HASH };
	CEdit	m_hashFileDetailsEdit;
	CEdit	m_descriptionEdit;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryHashPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryHashPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnHashEntryBrowse();
	afx_msg void OnChangeHashEntryDescription();
	afx_msg void OnSelchangeHashEntrySecurityLevel();
	afx_msg void OnChangeHashHashedFilePath();
	afx_msg void OnSetfocusHashHashedFilePath();
	afx_msg void OnChangeHashEntryHashfileDetails();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    BOOL MyGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo);
    CString BuildHashFileInfoString (PVOID szBuff);
    CString ConcatStrings (
                const CString& productName, 
                const CString& description, 
                const CString& companyName,
                const CString& fileName, 
                const CString& fileVersion);
    bool CheckLengthAndTruncateToken (CString& token);
    virtual void DoContextHelp (HWND hWndControl);
    bool FormatMemBufToString (PWSTR *ppString, PBYTE pbData, DWORD cbData);
    bool ConvertStringToHash (PCWSTR pszString);
    void FormatAndDisplayHash ();

private:
	CString             m_szLastOpenedFile;
    CSaferEntry&        m_rSaferEntry;
    bool                m_bDirty;
    BYTE                m_rgbFileHash[SAFER_MAX_HASH_SIZE];
    DWORD               m_cbFileHash;
    __int64             m_nFileSize;
    LONG_PTR            m_lNotifyHandle;
    LPDATAOBJECT        m_pDataObject;
    const bool          m_bReadOnly;
    bool                m_bIsMachine;
    ALG_ID              m_hashAlgid;
    bool                m_bFirst;
    CCertMgrComponentData*   m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYHASHPROPERTYPAGE_H__9F1BE911_6A3E_4BBA_8BE9_BFE3B29D2A6F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentry.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntry.h
//
//  Contents:   Declaration of CSaferEntry
//
//----------------------------------------------------------------------------

#if !defined(AFX_SAFERENTRY_H__CF4D8002_5484_40E9_B4F6_CC4A0030D738__INCLUDED_)
#define AFX_SAFERENTRY_H__CF4D8002_5484_40E9_B4F6_CC4A0030D738__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winsafer.h>
#include "cookie.h"
#include "certifct.h"
#include "SaferUtil.h"

typedef enum {
    SAFER_ENTRY_TYPE_UNKNOWN = 0,
    SAFER_ENTRY_TYPE_HASH,
    SAFER_ENTRY_TYPE_PATH,
    SAFER_ENTRY_TYPE_URLZONE,
    SAFER_ENTRY_TYPE_CERT
} SAFER_ENTRY_TYPE;

extern const DWORD AUTHZ_UNKNOWN_LEVEL;

class CSaferEntry : public CCertMgrCookie  
{
public:
	CSaferEntry (
            SAFER_ENTRY_TYPE    saferEntryType,
            bool bIsMachine, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName, 
            PSAFER_IDENTIFICATION_HEADER pAuthzInfo,
            DWORD   dwLevelID,
            IGPEInformation* m_pGPEInformation,
            CCertificate*       pCertificate,
            CSaferEntries*      pSaferEntries,
            CRSOPObjectArray&   rRSOPArray,
            PCWSTR              pszRSOPRegistryKey = 0);

    virtual ~CSaferEntry();

public:
	virtual void Refresh ();
    CString GetRSOPRegistryKey () const;
	void SetHashFriendlyName (const CString& szFriendlyName);
	CString GetHashFriendlyName ();
	void SetURLZoneID (DWORD dwURLZoneID);
    int CompareLastModified (const CSaferEntry& saferEntry) const;
	HRESULT Delete (bool bCommit);
	HRESULT GetCertificate (CCertificate** ppCert);
	CString GetDescription ();
	HRESULT GetFlags (DWORD& dwFlags);
    HRESULT GetHash (
                BYTE rgbFileHash[SAFER_MAX_HASH_SIZE], 
                DWORD& cbFileHash, 
                __int64& m_nFileSize, 
                ALG_ID& algId) const;
	CString GetShortLastModified () const;
	CString GetLongLastModified () const;
	DWORD GetLevel () const;
	CString GetLevelFriendlyName () const;
	CString GetPath ();
	HRESULT GetSaferEntriesNode (CSaferEntries** ppSaferEntries);
    SAFER_ENTRY_TYPE GetType () const;
   	CString GetTypeString () const;
	DWORD GetURLZoneID() const;
    HRESULT PolicyChanged();
	HRESULT Save ();
	HRESULT SetCertificate (CCertificate* pCert);
	void SetDescription(const CString& szDescription);
	void SetFlags (DWORD dwFlags);
	HRESULT SetHash (
                BYTE    rgbFileHash[SAFER_MAX_HASH_SIZE], 
                DWORD   cbFileHash, 
                __int64 m_nFileSize, 
                ALG_ID   hashAlgid);
	HRESULT SetLevel (DWORD dwLevelID);
	void SetPath (const CString& szPath);
    CString GetDisplayName () const
    {
        return m_szDisplayName;
    }

private:
	CString m_szHashFriendlyName;
	DWORD                               m_dwFlags;
    PSAFER_IDENTIFICATION_HEADER   m_pAuthzInfo;
    DWORD                               m_dwLevelID;
    DWORD                               m_dwOriginalLevelID;
    CString                             m_szLevelFriendlyName;
    CCertificate*                       m_pCertificate;
    CSaferEntries*                      m_pSaferEntries;
    IGPEInformation*                    m_pGPEInformation;
    const SAFER_ENTRY_TYPE              m_saferEntryType;
    CString                             m_szDescription;
    CString                             m_szPath;
    bool                                m_bDeleted;
    BYTE                                m_rgbFileHash[SAFER_MAX_HASH_SIZE];
    DWORD                               m_cbFileHash;
    DWORD                               m_UrlZoneId;
    __int64                             m_nHashFileSize;
    ALG_ID                              m_hashAlgid;
    CString                             m_szDisplayName;
    CString                             m_szRSOPRegistryKey;
    const bool                          m_bIsComputer;
};

#endif // !defined(AFX_SAFERENTRY_H__CF4D8002_5484_40E9_B4F6_CC4A0030D738__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentrypathpropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryPathPropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryPathPropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryPathPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "certmgr.h"
#include "compdata.h"
#include "SaferEntryPathPropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryPathPropertyPage property page

CSaferEntryPathPropertyPage::CSaferEntryPathPropertyPage(
        CSaferEntry& rSaferEntry,
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        bool bNew,
        CCertMgrComponentData* pCompData,
        bool bIsMachine)
: CHelpPropertyPage(CSaferEntryPathPropertyPage::IDD),
    m_rSaferEntry (rSaferEntry),
    m_bDirty (bNew),
    m_lNotifyHandle (lNotifyHandle),
    m_pDataObject (pDataObject),
    m_bReadOnly (bReadOnly),
    m_pCompData (pCompData),
    m_bIsMachine (bIsMachine),
    m_bFirst (true),
    m_pidl (0),
    m_bDialogInitInProgress (false)
{
	//{{AFX_DATA_INIT(CSaferEntryPathPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rSaferEntry.AddRef ();
    m_rSaferEntry.IncrementOpenPageCount ();
}

CSaferEntryPathPropertyPage::~CSaferEntryPathPropertyPage()
{
    if ( m_lNotifyHandle )
        MMCFreeNotifyHandle (m_lNotifyHandle);

    m_rSaferEntry.DecrementOpenPageCount ();
    m_rSaferEntry.Release ();

    if ( m_pidl )
    {
        LPMALLOC pMalloc = 0;
        if ( SUCCEEDED (SHGetMalloc (&pMalloc)) )
        {
           pMalloc->Free (m_pidl);
           pMalloc->Release ();
        }
    }
}

void CSaferEntryPathPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferEntryPathPropertyPage)
	DDX_Control(pDX, IDC_PATH_ENTRY_DESCRIPTION, m_descriptionEdit);
	DDX_Control(pDX, IDC_PATH_ENTRY_PATH, m_pathEdit);
	DDX_Control(pDX, IDC_PATH_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryPathPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferEntryPathPropertyPage)
	ON_EN_CHANGE(IDC_PATH_ENTRY_DESCRIPTION, OnChangePathEntryDescription)
	ON_CBN_SELCHANGE(IDC_PATH_ENTRY_SECURITY_LEVEL, OnSelchangePathEntrySecurityLevel)
	ON_EN_CHANGE(IDC_PATH_ENTRY_PATH, OnChangePathEntryPath)
	ON_BN_CLICKED(IDC_PATH_ENTRY_BROWSE, OnPathEntryBrowse)
	ON_EN_SETFOCUS(IDC_PATH_ENTRY_PATH, OnSetfocusPathEntryPath)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryPathPropertyPage message handlers
void CSaferEntryPathPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryPathPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_PATH_ENTRY_PATH, IDH_PATH_ENTRY_PATH,
        IDC_PATH_ENTRY_SECURITY_LEVEL, IDH_PATH_ENTRY_SECURITY_LEVEL,
        IDC_PATH_ENTRY_DESCRIPTION, IDH_PATH_ENTRY_DESCRIPTION,
        IDC_PATH_ENTRY_LAST_MODIFIED, IDH_PATH_ENTRY_LAST_MODIFIED,
        IDC_PATH_ENTRY_BROWSE, IDH_PATH_ENTRY_BROWSE_FOLDER,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_PATH_ENTRY_PATH:
    case IDC_PATH_ENTRY_SECURITY_LEVEL:
    case IDC_PATH_ENTRY_DESCRIPTION:
    case IDC_PATH_ENTRY_LAST_MODIFIED:
    case IDC_PATH_ENTRY_BROWSE:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryPathPropertyPage::DoContextHelp\n");
}

BOOL CSaferEntryPathPropertyPage::OnInitDialog()
{
	CHelpPropertyPage::OnInitDialog();
    m_bDialogInitInProgress = true;

    if ( m_bDirty )  // bNew
    {
        SetDlgItemText (IDC_DATE_LAST_MODIFIED_LABEL, L"");
    }
    else
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_PATH_TITLE));
        SetDlgItemText (IDC_PATH_TITLE, szText);
    }


    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        CPolicyKey policyKey (m_pCompData->m_pGPEInformation,
                    SAFER_HKLM_REGBASE,
                    m_bIsMachine);
        InitializeSecurityLevelComboBox (m_securityLevelCombo, false,
                m_rSaferEntry.GetLevel (), policyKey.GetKey (), 
                m_pCompData->m_pdwSaferLevels,
                m_bIsMachine);

        // Initialize path
        m_pathEdit.SetWindowText (m_rSaferEntry.GetPath ());

        // Initialize description
        m_descriptionEdit.LimitText (SAFER_MAX_DESCRIPTION_SIZE);
        m_descriptionEdit.SetWindowText (m_rSaferEntry.GetDescription ());

        SetDlgItemText (IDC_PATH_ENTRY_LAST_MODIFIED,
                m_rSaferEntry.GetLongLastModified ());

        if ( m_bReadOnly )
        {
            m_pathEdit.SetReadOnly ();
            m_descriptionEdit.SetReadOnly ();
            m_securityLevelCombo.EnableWindow (FALSE);
            GetDlgItem (IDC_PATH_ENTRY_BROWSE)->EnableWindow (FALSE);
        }
    }

    m_bDialogInitInProgress = false;
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CSaferEntryPathPropertyPage::OnApply()
{
	if ( m_bDirty && !m_bReadOnly )
    {
        if ( !ValidateEntryPath () )
            return FALSE;

        // Set the level
        int nCurSel = m_securityLevelCombo.GetCurSel ();
        ASSERT (CB_ERR != nCurSel);
        m_rSaferEntry.SetLevel ((DWORD) m_securityLevelCombo.GetItemData (nCurSel));

        CString szText;

        m_pathEdit.GetWindowText (szText);
        if ( szText.IsEmpty () )
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (text.LoadString (IDS_SAFER_PATH_EMPTY));

            MessageBox (text, caption, MB_OK);
            m_pathEdit.SetFocus ();

            return FALSE;
        }

        m_rSaferEntry.SetPath (szText);

        m_descriptionEdit.GetWindowText (szText);
        m_rSaferEntry.SetDescription (szText);

        HRESULT hr = m_rSaferEntry.Save ();
        if ( SUCCEEDED (hr) )
        {
            if ( m_lNotifyHandle )
                MMCPropertyChangeNotify (
                        m_lNotifyHandle,  // handle to a notification
                        (LPARAM) m_pDataObject);          // unique identifier

            m_bDirty = false;
        }
        else
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
            return FALSE;
        }
    }
	
	return CHelpPropertyPage::OnApply();
}

void CSaferEntryPathPropertyPage::OnChangePathEntryDescription()
{
    if ( !m_bDialogInitInProgress )
    {
        m_bDirty = true;
        SetModified ();	
    }
}

void CSaferEntryPathPropertyPage::OnSelchangePathEntrySecurityLevel()
{
    if ( !m_bDialogInitInProgress )
    {
        m_bDirty = true;
        SetModified ();	
    }
}

void CSaferEntryPathPropertyPage::OnChangePathEntryPath()
{
    if ( !m_bDialogInitInProgress )
    {
        m_bDirty = true;
        SetModified ();	
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   BrowseCallbackProc
//
//  Synopsis:   Callback procedure for File & Folder adding SHBrowseForFolder
//              to set the title bar appropriately
//
//  Arguments:  [hwnd]   - the hwnd of the browse dialog
//              [uMsg]   - the message from the dialog
//              [lParam] - message dependant
//              [pData]  - PIDL from last successful call to SHBrowseForFolder
//
//  Returns:    0
//
//---------------------------------------------------------------------------
int CSaferEntryPathPropertyPage::BrowseCallbackProc (HWND hwnd, UINT uMsg, LPARAM /*lParam*/, LPARAM pData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch(uMsg)
    {
        case BFFM_INITIALIZED:
            {
                CString szTitle;
                VERIFY (szTitle.LoadString (IDS_SHBROWSEFORFOLDER_TITLE));
                ::SetWindowText (hwnd, szTitle);

                if ( pData )
                    ::SendMessage (hwnd, BFFM_SETSELECTION, FALSE, pData);
            }
            break;

        default:
            break;
    }
    return 0;
}

void CSaferEntryPathPropertyPage::OnPathEntryBrowse()
{
    _TRACE (1, L"Entering CSaferEntryPathPropertyPage::OnPathEntryBrowse()\n");
    CString     szTitle;
    VERIFY (szTitle.LoadString (IDS_SELECT_A_FOLDER));
    WCHAR       szDisplayName[MAX_PATH];
    BROWSEINFO  bi;
    ::ZeroMemory (&bi, sizeof (BROWSEINFO));

    bi.hwndOwner = m_hWnd;
    bi.pidlRoot = 0;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_VALIDATE | BIF_BROWSEINCLUDEFILES;
    bi.lpfn = BrowseCallbackProc;
    bi.lParam = (LPARAM) m_pidl;
    bi.iImage = 0;

	LPITEMIDLIST pidl = SHBrowseForFolder (&bi);
    if ( pidl )
    {
        CString szFolderPath;
        BOOL bRVal = SHGetPathFromIDList (pidl, szFolderPath.GetBuffer (MAX_PATH));
        szFolderPath.ReleaseBuffer();

        if ( bRVal )
        {
           LPMALLOC pMalloc = 0;
           if ( SUCCEEDED (SHGetMalloc (&pMalloc)) )
           {
               if ( m_pidl )
                   pMalloc->Free (m_pidl);
               pMalloc->Release ();
               m_pidl = pidl;
           }

           m_pathEdit.SetWindowText (szFolderPath);
           m_bDirty = true;
           SetModified ();
        }
    }
    _TRACE (-1, L"Leaving CSaferEntryPathPropertyPage::OnPathEntryBrowse()\n");
}

// NTRAID# 310880 SAFER:  New Path Rule property sheet should not reject 
// wildcard characters * and ?
#define ILLEGAL_FAT_CHARS   L"\"+,;<=>[]|"

bool CSaferEntryPathPropertyPage::ValidateEntryPath()
{
    bool    bRVal = true;
	CString szPath;

    m_pathEdit.GetWindowText (szPath);

    PCWSTR szInvalidCharSet = ILLEGAL_FAT_CHARS; 


    if ( -1 != szPath.FindOneOf (szInvalidCharSet) )
    {
        bRVal = false;
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        CString charsWithSpaces;

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        text.FormatMessage (IDS_SAFER_PATH_CONTAINS_INVALID_CHARS, charsWithSpaces);

        CThemeContextActivator activator;
        MessageBox (text, caption, MB_OK);
        m_pathEdit.SetFocus ();
    }

    return bRVal;
}

void CSaferEntryPathPropertyPage::OnSetfocusPathEntryPath()
{
    if ( m_bFirst )
    {
        if ( true == m_bReadOnly )
            SendDlgItemMessage (IDC_PATH_ENTRY_PATH, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentryinternetzonepropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryInternetZonePropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryInternetZonePropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryInternetZonePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "certmgr.h"
#include "compdata.h"
#include "SaferEntryInternetZonePropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryInternetZonePropertyPage property page

CSaferEntryInternetZonePropertyPage::CSaferEntryInternetZonePropertyPage(
        CSaferEntry& rSaferEntry, 
        bool bNew, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        CCertMgrComponentData* pCompData,
        bool bIsMachine) 
: CHelpPropertyPage(CSaferEntryInternetZonePropertyPage::IDD),
    m_rSaferEntry (rSaferEntry),
    m_bDirty (bNew),
    m_lNotifyHandle (lNotifyHandle),
    m_pDataObject (pDataObject),
    m_bReadOnly (bReadOnly),
    m_pCompData (pCompData),
    m_bIsMachine (bIsMachine)
{
	//{{AFX_DATA_INIT(CSaferEntryInternetZonePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_rSaferEntry.AddRef ();
    m_rSaferEntry.IncrementOpenPageCount ();
}

CSaferEntryInternetZonePropertyPage::~CSaferEntryInternetZonePropertyPage()
{
    if ( m_lNotifyHandle )
        MMCFreeNotifyHandle (m_lNotifyHandle);

    m_rSaferEntry.DecrementOpenPageCount ();
    m_rSaferEntry.Release ();
}

void CSaferEntryInternetZonePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferEntryInternetZonePropertyPage)
	DDX_Control(pDX, IDC_IZONE_ENTRY_ZONES, m_internetZoneCombo);
	DDX_Control(pDX, IDC_IZONE_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryInternetZonePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferEntryInternetZonePropertyPage)
	ON_CBN_SELCHANGE(IDC_IZONE_ENTRY_SECURITY_LEVEL, OnSelchangeIzoneEntrySecurityLevel)
	ON_CBN_SELCHANGE(IDC_IZONE_ENTRY_ZONES, OnSelchangeIzoneEntryZones)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSaferEntryInternetZonePropertyPage message handlers
BOOL CSaferEntryInternetZonePropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	

    // Set up User Notification combo box
    DWORD   dwFlags = 0;
    m_rSaferEntry.GetFlags (dwFlags);

    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        CPolicyKey policyKey (m_pCompData->m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsMachine);
        InitializeSecurityLevelComboBox (m_securityLevelCombo, false,
                m_rSaferEntry.GetLevel (), policyKey.GetKey (), 
                m_pCompData->m_pdwSaferLevels,
                m_bIsMachine);

        InitializeInternetZoneComboBox (m_rSaferEntry.GetURLZoneID ());

        SendDlgItemMessage (IDC_IZONE_ENTRY_DESCRIPTION, EM_LIMITTEXT, SAFER_MAX_DESCRIPTION_SIZE, 0);
        SetDlgItemText (IDC_IZONE_ENTRY_DESCRIPTION, m_rSaferEntry.GetDescription ());

        SetDlgItemText (IDC_IZONE_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

        if ( m_bReadOnly )
        {
            m_securityLevelCombo.EnableWindow (FALSE);
            m_internetZoneCombo.EnableWindow (FALSE);
        }

        if ( !m_bDirty )
        {
            CString szText;

            VERIFY (szText.LoadString (IDS_URLZONE_TITLE));
            SetDlgItemText (IDC_URLZONE_TITLE, szText);
        }
        else
            SetDlgItemText (IDC_DATE_LAST_MODIFIED_LABEL, L""); 
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CSaferEntryInternetZonePropertyPage::InitializeInternetZoneComboBox (DWORD UrlZoneId)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString szText;
    VERIFY (szText.LoadString (IDS_URLZONE_LOCAL_MACHINE));
    int nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_LOCAL_MACHINE == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_LOCAL_MACHINE));

    }

    VERIFY (szText.LoadString (IDS_URLZONE_INTRANET));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_INTRANET == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_INTRANET));
    }
    
    VERIFY (szText.LoadString (IDS_URLZONE_TRUSTED));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_TRUSTED == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_TRUSTED));
    }
    
    VERIFY (szText.LoadString (IDS_URLZONE_INTERNET));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_INTERNET == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_INTERNET));
    }
    
    VERIFY (szText.LoadString (IDS_URLZONE_UNTRUSTED));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_UNTRUSTED == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_UNTRUSTED));
    }
    
}


void CSaferEntryInternetZonePropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryInternetZonePropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_IZONE_ENTRY_ZONES, IDH_IZONE_ENTRY_ZONES,
        IDC_IZONE_ENTRY_SECURITY_LEVEL, IDH_IZONE_ENTRY_SECURITY_LEVEL,
        IDC_IZONE_ENTRY_DESCRIPTION, IDH_IZONE_ENTRY_DESCRIPTION,
        IDC_IZONE_ENTRY_LAST_MODIFIED, IDH_IZONE_ENTRY_LAST_MODIFIED,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_IZONE_ENTRY_ZONES:
    case IDC_IZONE_ENTRY_SECURITY_LEVEL:
    case IDC_IZONE_ENTRY_DESCRIPTION:
    case IDC_IZONE_ENTRY_LAST_MODIFIED:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryInternetZonePropertyPage::DoContextHelp\n");
}

BOOL CSaferEntryInternetZonePropertyPage::OnApply() 
{
    if ( m_bDirty && !m_bReadOnly )
    {
        // Set the level
        int nCurSel = m_securityLevelCombo.GetCurSel ();
        ASSERT (CB_ERR != nCurSel);
        m_rSaferEntry.SetLevel ((DWORD) m_securityLevelCombo.GetItemData (nCurSel));

        int nSel = m_internetZoneCombo.GetCurSel ();
        ASSERT (CB_ERR != nSel);
        if ( CB_ERR != nSel )
        {
            DWORD_PTR   dwURLZoneID = m_internetZoneCombo.GetItemData (nSel);
            ASSERT (CB_ERR != dwURLZoneID);
            if ( CB_ERR != dwURLZoneID )
                m_rSaferEntry.SetURLZoneID ((DWORD) dwURLZoneID);
        }

        HRESULT hr = m_rSaferEntry.Save ();
        if ( SUCCEEDED (hr) )
        {
            if ( m_lNotifyHandle )
                MMCPropertyChangeNotify (
                        m_lNotifyHandle,  // handle to a notification
                        (LPARAM) m_pDataObject);          // unique identifier
 
            m_bDirty = false;
        }
        else
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
            return FALSE;
        }
    }
	return CHelpPropertyPage::OnApply();
}

void CSaferEntryInternetZonePropertyPage::OnSelchangeIzoneEntrySecurityLevel() 
{
    m_bDirty = true;
    SetModified ();
}

void CSaferEntryInternetZonePropertyPage::OnSelchangeIzoneEntryZones() 
{
    int nSel = m_internetZoneCombo.GetCurSel ();
    ASSERT (CB_ERR != nSel);
    if ( CB_ERR != nSel )
    {
        DWORD_PTR   dwURLZoneID = m_internetZoneCombo.GetItemData (nSel);
        ASSERT (CB_ERR != dwURLZoneID);
        if ( CB_ERR != dwURLZoneID )
            m_rSaferEntry.SetURLZoneID ((DWORD) dwURLZoneID);
    }
    
    SetDlgItemText (IDC_IZONE_ENTRY_DESCRIPTION, m_rSaferEntry.GetDescription ());
    m_bDirty = true;
    SetModified ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentryinternetzonepropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryInternetZonePropertyPage.h
//
//  Contents:   Declaration of CSaferEntryInternetZonePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYINTERNETZONEPROPERTYPAGE_H__2C1B5841_0334_4763_8AEF_1EE611B1958B__INCLUDED_)
#define AFX_SAFERENTRYINTERNETZONEPROPERTYPAGE_H__2C1B5841_0334_4763_8AEF_1EE611B1958B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryInternetZonePropertyPage.h : header file
//
#include "SaferEntry.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryInternetZonePropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CSaferEntryInternetZonePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferEntryInternetZonePropertyPage(
            CSaferEntry& rSaferEntry, 
            bool bNew, 
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            CCertMgrComponentData* pCompData,
            bool bIsMachine);
	~CSaferEntryInternetZonePropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryInternetZonePropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_INTERNET_ZONE };
	CComboBox	m_internetZoneCombo;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryInternetZonePropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryInternetZonePropertyPage)
    virtual BOOL OnInitDialog();	
	afx_msg void OnSelchangeIzoneEntrySecurityLevel();
	afx_msg void OnSelchangeIzoneEntryZones();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    void InitializeInternetZoneComboBox (DWORD UrlZoneId);

private:
    CSaferEntry&        m_rSaferEntry;
    bool                m_bDirty;
    LONG_PTR            m_lNotifyHandle;
    LPDATAOBJECT        m_pDataObject;
    const bool          m_bReadOnly;
    CCertMgrComponentData*    m_pCompData;
    bool                m_bIsMachine;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYINTERNETZONEPROPERTYPAGE_H__2C1B5841_0334_4763_8AEF_1EE611B1958B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentrypathpropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryPathPropertyPage.h
//
//  Contents:   Declaration of CSaferEntryPathPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYPATHPROPERTYPAGE_H__B32CBA62_1C9A_4763_AA55_B32E25FF2426__INCLUDED_)
#define AFX_SAFERENTRYPATHPROPERTYPAGE_H__B32CBA62_1C9A_4763_AA55_B32E25FF2426__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryPathPropertyPage.h : header file
//
#include "SaferEntry.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryPathPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CSaferEntryPathPropertyPage : public CHelpPropertyPage
{

// Construction
public:
	CSaferEntryPathPropertyPage(
            CSaferEntry& rSaferEntry, 
            LONG_PTR lNotifyHandle, 
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            bool bNew,
            CCertMgrComponentData* pCompData,
            bool bIsMachine);
	~CSaferEntryPathPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryPathPropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_PATH };
	CEdit	m_descriptionEdit;
	CEdit	m_pathEdit;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryPathPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryPathPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangePathEntryDescription();
	afx_msg void OnSelchangePathEntrySecurityLevel();
	afx_msg void OnChangePathEntryPath();
	afx_msg void OnPathEntryBrowse();
	afx_msg void OnSetfocusPathEntryPath();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    static int BrowseCallbackProc (HWND hwnd,UINT uMsg, LPARAM lParam, LPARAM pData);
	bool ValidateEntryPath();

private:
    CSaferEntry&        m_rSaferEntry;
    bool                m_bDirty;
    LONG_PTR            m_lNotifyHandle;
    LPDATAOBJECT        m_pDataObject;
    const bool          m_bReadOnly;
    CCertMgrComponentData*    m_pCompData;
    bool                m_bIsMachine;
    bool                m_bFirst;
    LPITEMIDLIST        m_pidl;
    bool                m_bDialogInitInProgress;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYPATHPROPERTYPAGE_H__B32CBA62_1C9A_4763_AA55_B32E25FF2426__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentrypropertysheet.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryPropertySheet.cpp
//
//  Contents:   Implementation of CSaferEntryPropertySheet
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "SaferEntryPropertySheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_SETOKDEFAULT     WM_APP + 2001

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaferEntryPropertySheet::CSaferEntryPropertySheet(UINT nIDCaption, CWnd *pParentWnd)
: CPropertySheet (nIDCaption, pParentWnd)
{

}

CSaferEntryPropertySheet::~CSaferEntryPropertySheet()
{

}

BEGIN_MESSAGE_MAP(CSaferEntryPropertySheet, CPropertySheet)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE (WM_SETOKDEFAULT, OnSetOKDefault)
END_MESSAGE_MAP()

BOOL CSaferEntryPropertySheet::OnInitDialog() 
{
    _TRACE (1, L"Entering CSaferEntryPropertySheet::OnInitDialog ()\n");
	CPropertySheet::OnInitDialog();
	
    LONG    dwStyle = GetWindowLong (m_hWnd, GWL_STYLE);

    dwStyle |= DS_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_STYLE, dwStyle);
    
    dwStyle = GetWindowLong (m_hWnd, GWL_EXSTYLE);
    dwStyle |= WS_EX_DLGMODALFRAME | WS_EX_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_EXSTYLE, dwStyle);

    // Make the OK button the default
    PostMessage (WM_SETOKDEFAULT, 0, 0);

    _TRACE (-1, L"Leaving CSaferEntryPropertySheet::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSaferEntryPropertySheet::OnSetOKDefault (WPARAM, LPARAM)
{
    // Make the OK button the default
    SendMessage (DM_SETDEFID, MAKEWPARAM (IDOK, 0), 0);
    SendDlgItemMessage (IDOK, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    SendDlgItemMessage (IDCANCEL, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));


    return 0;
}


BOOL CSaferEntryPropertySheet::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CSaferEntryPropertySheet::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CSaferEntryPropertySheet::OnHelp\n");

    return TRUE;
}

void CSaferEntryPropertySheet::DoContextHelp (HWND hWndControl)
{
	_TRACE (1, L"Entering CSaferEntryPropertySheet::DoContextHelp\n");
    const int	IDC_COMM_APPLYNOW = 12321;
	const int	IDH_COMM_APPLYNOW = 28447;
    const DWORD aHelpIDs_PropSheet[]=
    {
		IDC_COMM_APPLYNOW, IDH_COMM_APPLYNOW,
        0, 0
    };

    PWSTR  pszHelpFile = 0;
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_COMM_APPLYNOW:
        pszHelpFile = const_cast <PWSTR> (WINDOWS_HELP);
        break;

	default:
		// Display context help for a control
        pszHelpFile = const_cast<PWSTR> ((PCWSTR)GetF1HelpFilename());
		break;
	}

	if ( !::WinHelp (
			hWndControl,
			pszHelpFile,
			HELP_WM_HELP,
			(DWORD_PTR) aHelpIDs_PropSheet) )
	{
		_TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
	}

    _TRACE (-1, L"Leaving CSaferEntryPropertySheet::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferentrypropertysheet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryPropertySheet.h
//
//  Contents:   Declaration of CSaferEntryPropertySheet
//
//----------------------------------------------------------------------------

#if !defined(AFX_SAFERENTRYPROPERTYSHEET_H__A9834C09_038E_4430_A4C4_5CBB9045E3A9__INCLUDED_)
#define AFX_SAFERENTRYPROPERTYSHEET_H__A9834C09_038E_4430_A4C4_5CBB9045E3A9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSaferEntryPropertySheet : public CPropertySheet  
{
public:
	CSaferEntryPropertySheet(UINT nIDCaption, CWnd *pParentWnd);
	virtual ~CSaferEntryPropertySheet();

protected:
    virtual BOOL OnInitDialog();

	// Generated message map functions
	//{{AFX_MSG(CSaferEntryPropertySheet)
	//}}AFX_MSG
    afx_msg LRESULT OnSetOKDefault (WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

    BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	virtual void DoContextHelp (HWND hWndControl);

private:
};

#endif // !defined(AFX_SAFERENTRYPROPERTYSHEET_H__A9834C09_038E_4430_A4C4_5CBB9045E3A9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferlevel.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevel.h
//
//  Contents:   Declaration of CSaferLevel
//
//----------------------------------------------------------------------------

#if !defined(AFX_SAFERLEVEL_H__894DD3C5_A1A4_4DD5_8853_5F999D8F3FF5__INCLUDED_)
#define AFX_SAFERLEVEL_H__894DD3C5_A1A4_4DD5_8853_5F999D8F3FF5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "cookie.h"
#include "RSOPObject.h"

class CSaferLevel : public CCertMgrCookie  
{
public:
	CSaferLevel(
            DWORD dwSaferLevel, 
            bool bIsMachine, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName,
            IGPEInformation* pGPEInformation,
            CRSOPObjectArray& rRSOPArray);
	virtual ~CSaferLevel();

    DWORD GetLevel () const
    {
        return m_dwSaferLevel;
    }

  	bool IsDefault ();
	HRESULT SetAsDefault ();
	CString GetDescription () const;

    static DWORD ReturnDefaultLevel (
            IGPEInformation* pGPEInformation, 
            bool bIsComputer, 
            CRSOPObjectArray& rRSOPArray);

private:
	CString m_szLevel;
	const bool          m_bIsComputer;
	CString             m_szDescription;
	const DWORD         m_dwSaferLevel;
    IGPEInformation*    m_pGPEInformation;
    CRSOPObjectArray&   m_rRSOPArray;
};

#endif // !defined(AFX_SAFERLEVEL_H__894DD3C5_A1A4_4DD5_8853_5F999D8F3FF5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferlevel.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevel.cpp
//
//  Contents:   Implementation of CSaferLevel
//
//----------------------------------------------------------------------------
#include "stdafx.h"

#include <gpedit.h>
#include <winsafer.h>
#include <wintrust.h>
#include "SaferLevel.h"
#include "SaferUtil.h"
#include "PolicyKey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

extern const DWORD AUTHZ_UNKNOWN_LEVEL;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaferLevel::CSaferLevel(
        DWORD dwSaferLevel, 
        bool bIsMachine, 
        PCWSTR pszMachineName, 
        PCWSTR pszObjectName,
        IGPEInformation* pGPEInformation,
        CRSOPObjectArray& rRSOPArray)
: CCertMgrCookie (bIsMachine ? CERTMGR_SAFER_COMPUTER_LEVEL : CERTMGR_SAFER_USER_LEVEL, 
        pszMachineName, pszObjectName),
    m_dwSaferLevel (dwSaferLevel),
    m_bIsComputer (bIsMachine),
    m_pGPEInformation (pGPEInformation),
    m_rRSOPArray (rRSOPArray)
{
    if ( m_pGPEInformation )
        m_pGPEInformation->AddRef ();

    // OK to pass in NULL for m_pGPEInformation
    CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsComputer);
    m_szDescription = SaferGetLevelDescription (dwSaferLevel, policyKey.GetKey (),
            m_bIsComputer);
}

CSaferLevel::~CSaferLevel()
{
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}

CString CSaferLevel::GetDescription() const
{
    return m_szDescription;
}

HRESULT CSaferLevel::SetAsDefault()
{
    _TRACE (1, L"Entering CSaferLevel::SetAsDefault ()\n");
    HRESULT hr = S_OK;

    if ( m_pGPEInformation )
    {
        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsComputer);
        hr = SetRegistryScope (policyKey.GetKey (), m_bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwData = GetLevel ();
            DWORD   cbData = sizeof (dwData);
            BOOL    bRVal = SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                    SaferPolicyDefaultLevel, cbData, &dwData, policyKey.GetKey ());
            if ( bRVal )
            {
			    // TRUE means we're changing the machine policy only
                m_pGPEInformation->PolicyChanged (m_bIsComputer ? TRUE : FALSE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (m_bIsComputer ? TRUE : FALSE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (GetLastError ());
            }
        }
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CSaferLevel::SetAsDefault (): 0x%x\n", hr);
    return hr;
}

DWORD CSaferLevel::ReturnDefaultLevel (
        IGPEInformation* pGPEInformation, 
        bool bIsComputer, 
        CRSOPObjectArray& rRSOPArray)
{
    _TRACE (1, L"Entering CSaferLevel::IsDefault ()\n");
    DWORD   dwDefaultLevelID = AUTHZ_UNKNOWN_LEVEL;


    if ( pGPEInformation )
    {
        CPolicyKey policyKey (pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                bIsComputer);

        HRESULT hr = SetRegistryScope (policyKey.GetKey (), bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwData = 0;
            DWORD   cbData = sizeof (dwData);
            DWORD   dwRetSize = 0;
            BOOL    bRVal = SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                    SaferPolicyDefaultLevel, cbData, &dwData, &dwRetSize,
                        policyKey.GetKey ());
            if ( bRVal )
            {
                dwDefaultLevelID = dwData;
	        }
        }
    }
    else 
    {
        int     nIndex = 0;
        INT_PTR nUpperBound = rRSOPArray.GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pCurrObject = rRSOPArray.GetAt (nIndex);
            if ( pCurrObject )
            {
                if ( SAFER_HKLM_REGBASE == pCurrObject->GetRegistryKey () && 
                        SAFER_DEFAULTOBJ_REGVALUE == pCurrObject->GetValueName () )
                {
                    DWORD   dwLevelID = pCurrObject->GetDWORDValue ();
                    dwDefaultLevelID = dwLevelID;
                    break;
                }
            }
            nIndex++;
        }
    }

    _TRACE (1, L"Entering CSaferLevel::ReturnDefaultLevel (): %d\n", dwDefaultLevelID);
    return dwDefaultLevelID;
}

bool CSaferLevel::IsDefault()
{
    _TRACE (1, L"Entering CSaferLevel::IsDefault ()\n");
    bool    bResult = false;
    DWORD   dwDefaultLevelID = CSaferLevel::ReturnDefaultLevel (
                m_pGPEInformation, m_bIsComputer, m_rRSOPArray);
    if ( GetLevel () == dwDefaultLevelID )
        bResult = true;


    _TRACE (1, L"Entering CSaferLevel::IsDefault (): %s\n", bResult ? L"true" : L"false");
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferlevelgeneral.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevelGeneral.h
//
//  Contents:   Declaration of CSaferLevelGeneral
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERLEVELGENERAL_H__C8398890_ED8E_40E1_AEE6_91BFD32257B1__INCLUDED_)
#define AFX_SAFERLEVELGENERAL_H__C8398890_ED8E_40E1_AEE6_91BFD32257B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SaferLevel.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferLevelGeneral dialog

class CSaferLevelGeneral : public CHelpPropertyPage
{
// Construction
public:
	CSaferLevelGeneral (
            CSaferLevel& rSaferLevel, 
            bool bReadOnly, 
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            DWORD dwDefaultSaferLevel);
	~CSaferLevelGeneral();

// Dialog Data
	//{{AFX_DATA(CSaferLevelGeneral)
	enum { IDD = IDD_SAFER_LEVEL_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferLevelGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferLevelGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnSaferLevelSetAsDefault();
	afx_msg void OnSetfocusSaferLevelDescription();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	virtual BOOL OnApply();

private:
    CSaferLevel&    m_rSaferLevel;
    const bool      m_bReadOnly;
    bool            m_bSetAsDefault;
    LONG_PTR        m_lNotifyHandle;
    bool            m_bDirty;
    LPDATAOBJECT    m_pDataObject;
    DWORD           m_dwDefaultSaferLevel;
    bool            m_bFirst;
    bool            m_bLevelChanged;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERLEVELGENERAL_H__C8398890_ED8E_40E1_AEE6_91BFD32257B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferlevelgeneral.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevelGeneral.cpp
//
//  Contents:   Implementation of CSaferLevelGeneral
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include <winsafer.h>
#include "SaferLevelGeneral.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferLevelGeneral property page

CSaferLevelGeneral::CSaferLevelGeneral(
        CSaferLevel& rSaferLevel, 
        bool bReadOnly, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        DWORD dwDefaultSaferLevel) 
    : CHelpPropertyPage(CSaferLevelGeneral::IDD),
    m_rSaferLevel (rSaferLevel),
    m_bReadOnly (bReadOnly),
    m_bSetAsDefault (false),
    m_lNotifyHandle (lNotifyHandle),
    m_bDirty (false),
    m_pDataObject (pDataObject),
    m_dwDefaultSaferLevel (dwDefaultSaferLevel),
    m_bFirst (true),
    m_bLevelChanged (false)
{
	//{{AFX_DATA_INIT(CSaferLevelGeneral)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rSaferLevel.IncrementOpenPageCount ();
}

CSaferLevelGeneral::~CSaferLevelGeneral()
{
    if ( m_lNotifyHandle )
    {
        if ( m_bLevelChanged )
        {
            MMCPropertyChangeNotify (
                    m_lNotifyHandle,  // handle to a notification
                   (LPARAM) m_pDataObject);          // unique identifier
        }
        MMCFreeNotifyHandle (m_lNotifyHandle);
    }
    m_rSaferLevel.DecrementOpenPageCount ();
}

void CSaferLevelGeneral::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferLevelGeneral)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferLevelGeneral, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferLevelGeneral)
	ON_BN_CLICKED(IDC_SAFER_LEVEL_SET_AS_DEFAULT, OnSaferLevelSetAsDefault)
	ON_EN_SETFOCUS(IDC_SAFER_LEVEL_DESCRIPTION, OnSetfocusSaferLevelDescription)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferLevelGeneral message handlers

void CSaferLevelGeneral::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferLevelGeneral::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_SAFER_LEVEL_NAME,           IDH_SAFER_LEVEL_NAME,
        IDC_SAFER_LEVEL_DESCRIPTION,    IDH_SAFER_LEVEL_DESCRIPTION,
        IDC_SAFER_LEVEL_SET_AS_DEFAULT, IDH_SAFER_LEVEL_SET_AS_DEFAULT,
        IDC_SAFER_LEVEL_STATUS, IDH_SAFER_LEVEL_STATUS,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CSaferLevelGeneral::DoContextHelp\n");
}


BOOL CSaferLevelGeneral::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
    SetDlgItemText (IDC_SAFER_LEVEL_NAME, m_rSaferLevel.GetObjectName ());

    SetDlgItemText (IDC_SAFER_LEVEL_DESCRIPTION, m_rSaferLevel.GetDescription ());

    if ( m_rSaferLevel.IsDefault () )
    {
        m_bSetAsDefault = true;
        CString text;
        VERIFY (text.LoadString (IDS_IS_DEFAULT_LEVEL));
        SetDlgItemText (IDC_SAFER_LEVEL_STATUS, text);
        GetDlgItem (IDC_SAFER_LEVEL_SET_AS_DEFAULT)->EnableWindow (FALSE);
        GetDlgItem (IDC_LEVEL_INSTRUCTIONS)->EnableWindow (FALSE);
    }

    if ( m_bReadOnly ||  ( SAFER_LEVELID_DISALLOWED != m_rSaferLevel.GetLevel () &&
            SAFER_LEVELID_FULLYTRUSTED != m_rSaferLevel.GetLevel () ) )
    {
        CString text;

        if ( SAFER_LEVELID_CONSTRAINED == m_rSaferLevel.GetLevel () )
        {
            VERIFY (text.LoadString (IDS_CANT_SET_CONSTRAINED_AS_DEFAULT));
            SetDlgItemText (IDC_LEVEL_INSTRUCTIONS, text);
        }
        GetDlgItem (IDC_SAFER_LEVEL_SET_AS_DEFAULT)->EnableWindow (FALSE);
        GetDlgItem (IDC_LEVEL_INSTRUCTIONS)->EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CSaferLevelGeneral::OnApply ()
{
    if ( !m_bReadOnly && m_bDirty )
    {
        HRESULT hr = S_OK;
        BOOL    bResult = FALSE;


        if ( m_bSetAsDefault )
            hr = m_rSaferLevel.SetAsDefault ();
        if ( SUCCEEDED (hr) )
        {
            m_bLevelChanged = true;
            bResult =  CHelpPropertyPage::OnApply ();
        }
        else
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
            text.FormatMessage (IDS_CANT_SET_AS_DEFAULT, m_rSaferLevel.GetObjectName (),
                    GetSystemMessage (hr));
            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
        }

        return bResult;
    }
    else
        return CHelpPropertyPage::OnApply ();
}

void CSaferLevelGeneral::OnSaferLevelSetAsDefault() 
{
    if ( !m_bSetAsDefault )
    {
        int     iRet = IDYES;

        if ( m_rSaferLevel.GetLevel () < m_dwDefaultSaferLevel )
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
            VERIFY (text.LoadString (IDS_DEFAULT_LEVEL_CHANGE_WARNING));
            iRet = MessageBox (text, caption, MB_ICONWARNING | MB_YESNO);
        }

        if ( IDYES == iRet )
        {
            m_dwDefaultSaferLevel = m_rSaferLevel.GetLevel ();
            m_bDirty = true;
	        m_bSetAsDefault = true;
            CString text;
            VERIFY (text.LoadString (IDS_IS_DEFAULT_LEVEL));
            SetDlgItemText (IDC_SAFER_LEVEL_STATUS, text);
            SetModified (TRUE);
            GetDlgItem (IDC_SAFER_LEVEL_SET_AS_DEFAULT)->EnableWindow (FALSE);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// This method traps keyboard commands from the dialog, which has only 
// disabled controls, usually.  That prevented the closing of the dialog
// when the user pressed ESC.
// 222693 SAFER: Pressing ESC doesn't dismiss SAFER Level dialogs
///////////////////////////////////////////////////////////////////////////////
BOOL CSaferLevelGeneral::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	WORD    id = LOWORD (wParam);

    if ( IDCANCEL == id )
    {
        GetParent ()->SendMessage (WM_COMMAND, wParam, lParam);
    }
	
	return CHelpPropertyPage::OnCommand(wParam, lParam);
}

void CSaferLevelGeneral::OnSetfocusSaferLevelDescription() 
{
    if ( m_bFirst )
    {
        SendDlgItemMessage (IDC_SAFER_LEVEL_DESCRIPTION, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferstore.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferStore.cpp
//
//  Contents:   Implementation of CSaferStore
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "SaferStore.h"
#include "PolicyKey.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertStoreSafer::CCertStoreSafer ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			IGPEInformation * pGPTInformation,
			const GUID& compDataGUID,
			IConsole* pConsole)
: CCertStoreGPE (dwFlags, lpcszMachineName, objectName, pcszLogStoreName, 
        pcszPhysStoreName, pGPTInformation, compDataGUID, pConsole),
    m_policyKey (pGPTInformation, 
            L"", m_fIsComputerType)
{
}

CCertStoreSafer::~CCertStoreSafer ()
{
}

HKEY CCertStoreSafer::GetGroupPolicyKey ()
{
    return m_policyKey.GetKey ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferstore.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferStore.h
//
//  Contents:   Definition of CCertStoreSafer
//
//----------------------------------------------------------------------------
#ifndef __SAFERSTORE_H
#define __SAFERSTORE_H

#include "StoreGPE.h"
#include "PolicyKey.h"

class CCertStoreSafer : public CCertStoreGPE
{
public:
    CCertStoreSafer ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			IGPEInformation * pGPTInformation,
			const GUID& compDataGUID,
			IConsole* pConsole);
    ~CCertStoreSafer ();

    virtual HKEY GetGroupPolicyKey ();

private:
    CPolicyKey  m_policyKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\safertrustedpublisherspropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferTrustedPublishersPropertyPage.h
//
//  Contents:   Declaration of CSaferTrustedPublishersPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERTRUSTEDPUBLISHERSPROPERTYPAGE_H__B152D75D_6D04_4893_98AF_C070B66DB0E0__INCLUDED_)
#define AFX_SAFERTRUSTEDPUBLISHERSPROPERTYPAGE_H__B152D75D_6D04_4893_98AF_C070B66DB0E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferTrustedPublishersPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaferTrustedPublishersPropertyPage dialog

class CSaferTrustedPublishersPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferTrustedPublishersPropertyPage(
            bool fIsMachineType, 
            IGPEInformation* pGPEInformation,
            CCertMgrComponentData* pCompData);
	~CSaferTrustedPublishersPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferTrustedPublishersPropertyPage)
	enum { IDD = IDD_SAFER_TRUSTED_PUBLISHER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferTrustedPublishersPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferTrustedPublishersPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnTpByEndUser();
	afx_msg void OnTpByLocalComputerAdmin();
	afx_msg void OnTpByEnterpriseAdmin();
	afx_msg void OnTpRevCheckPublisher();
	afx_msg void OnTpRevCheckTimestamp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    void GetTrustedPublisherFlags();
    void RSOPGetTrustedPublisherFlags(const CCertMgrComponentData* pCompData);

private:
    IGPEInformation*    m_pGPEInformation;
    HKEY                m_hGroupPolicyKey;
    DWORD               m_dwTrustedPublisherFlags;
    bool                m_fIsComputerType;
    bool                m_bComputerIsStandAlone;
    bool                m_bRSOPValueFound;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERTRUSTEDPUBLISHERSPROPERTYPAGE_H__B152D75D_6D04_4893_98AF_C070B66DB0E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\safertrustedpublisherspropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferTrustedPublishersPropertyPage.h
//
//  Contents:   Declaration of CSaferTrustedPublishersPropertyPage
//
//----------------------------------------------------------------------------
// SaferTrustedPublishersPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certmgr.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferTrustedPublishersPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CSaferTrustedPublishersPropertyPage property page

CSaferTrustedPublishersPropertyPage::CSaferTrustedPublishersPropertyPage(
        bool fIsMachineType, IGPEInformation* pGPEInformation,
        CCertMgrComponentData* pCompData) 
    : CHelpPropertyPage(CSaferTrustedPublishersPropertyPage::IDD),
    m_pGPEInformation (pGPEInformation),
    m_hGroupPolicyKey (0),
    m_dwTrustedPublisherFlags (0),
    m_fIsComputerType (fIsMachineType),
    m_bComputerIsStandAlone (false),
    m_bRSOPValueFound (false)
{
    // NTRAID# 263969	Safer Windows:  "Enterprise Administrators" radio 
    // button should be disabled on Trusted Publishers property sheet for 
    // computers in workgroups.
    ASSERT (pCompData);
    if ( pCompData )
        m_bComputerIsStandAlone = pCompData->ComputerIsStandAlone ();

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        HRESULT hResult = m_pGPEInformation->GetRegistryKey (
                m_fIsComputerType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
        if ( SUCCEEDED (hResult) )
		    GetTrustedPublisherFlags ();
    }
    else
        RSOPGetTrustedPublisherFlags (pCompData);
  
	//{{AFX_DATA_INIT(CSaferTrustedPublishersPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSaferTrustedPublishersPropertyPage::~CSaferTrustedPublishersPropertyPage()
{
    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
    }
}

void CSaferTrustedPublishersPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferTrustedPublishersPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferTrustedPublishersPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferTrustedPublishersPropertyPage)
	ON_BN_CLICKED(IDC_TP_BY_END_USER, OnTpByEndUser)
	ON_BN_CLICKED(IDC_TP_BY_LOCAL_COMPUTER_ADMIN, OnTpByLocalComputerAdmin)
	ON_BN_CLICKED(IDC_TP_BY_ENTERPRISE_ADMIN, OnTpByEnterpriseAdmin)
	ON_BN_CLICKED(IDC_TP_REV_CHECK_PUBLISHER, OnTpRevCheckPublisher)
	ON_BN_CLICKED(IDC_TP_REV_CHECK_TIMESTAMP, OnTpRevCheckTimestamp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferTrustedPublishersPropertyPage message handlers
void CSaferTrustedPublishersPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferTrustedPublishersPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_TP_BY_END_USER, IDH_TP_BY_END_USER,
        IDC_TP_BY_LOCAL_COMPUTER_ADMIN, IDH_TP_BY_LOCAL_COMPUTER_ADMIN,
        IDC_TP_BY_ENTERPRISE_ADMIN, IDH_TP_BY_ENTERPRISE_ADMIN,
        IDC_TP_REV_CHECK_PUBLISHER, IDH_TP_REV_CHECK_PUBLISHER,
        IDC_TP_REV_CHECK_TIMESTAMP, IDH_TP_REV_CHECK_TIMESTAMP,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CSaferTrustedPublishersPropertyPage::DoContextHelp\n");
}


BOOL CSaferTrustedPublishersPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();

    if ( m_pGPEInformation || m_bRSOPValueFound )
    {
        if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG )
            SendDlgItemMessage (IDC_TP_REV_CHECK_PUBLISHER, BM_SETCHECK, BST_CHECKED);

        if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG )
            SendDlgItemMessage (IDC_TP_REV_CHECK_TIMESTAMP, BM_SETCHECK, BST_CHECKED);

        if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST )
            SendDlgItemMessage (IDC_TP_BY_ENTERPRISE_ADMIN, BM_SETCHECK, BST_CHECKED);
        else if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST )
            SendDlgItemMessage (IDC_TP_BY_LOCAL_COMPUTER_ADMIN, BM_SETCHECK, BST_CHECKED);
        else
            SendDlgItemMessage (IDC_TP_BY_END_USER, BM_SETCHECK, BST_CHECKED);
    }

    if ( !m_pGPEInformation )
    {
        // Is RSOP
        GetDlgItem (IDC_TP_REV_CHECK_PUBLISHER)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_REV_CHECK_TIMESTAMP)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_BY_ENTERPRISE_ADMIN)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_BY_LOCAL_COMPUTER_ADMIN)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_BY_END_USER)->EnableWindow (FALSE);
    }
	
    // NTRAID# 263969	Safer Windows:  "Enterprise Administrators" radio 
    // button should be disabled on Trusted Publishers property sheet for 
    // computers in workgroups.
    if ( m_bComputerIsStandAlone )
        GetDlgItem (IDC_TP_BY_ENTERPRISE_ADMIN)->EnableWindow (FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSaferTrustedPublishersPropertyPage::GetTrustedPublisherFlags()
{
    DWORD   dwDisposition = 0;

    HKEY    hKey = 0;
    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (lResult == ERROR_SUCCESS);
    if ( lResult == ERROR_SUCCESS )
    {
    // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
		        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,  // address of name of value to query
			    0,              // reserved
	        &dwType,        // address of buffer for value type
		    (LPBYTE) &dwData,       // address of data buffer
			&cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            m_dwTrustedPublisherFlags = dwData;
		}
        else
            DisplaySystemError (m_hWnd, lResult);

        RegCloseKey (hKey);
    }
    else
        DisplaySystemError (m_hWnd, lResult);
}

void CSaferTrustedPublishersPropertyPage::OnTpByEndUser() 
{
    SetModified ();	
}

void CSaferTrustedPublishersPropertyPage::OnTpByLocalComputerAdmin() 
{
	SetModified ();	
}

void CSaferTrustedPublishersPropertyPage::OnTpByEnterpriseAdmin() 
{
    SetModified ();		
}

void CSaferTrustedPublishersPropertyPage::OnTpRevCheckPublisher() 
{
    SetModified ();		
}

void CSaferTrustedPublishersPropertyPage::OnTpRevCheckTimestamp() 
{
    SetModified ();		
}

BOOL CSaferTrustedPublishersPropertyPage::OnApply() 
{
    if ( m_pGPEInformation )
    {
        DWORD   dwFlags = 0;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_REV_CHECK_PUBLISHER, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG;
            
        if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_REV_CHECK_TIMESTAMP, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_BY_ENTERPRISE_ADMIN, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST;
        else if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_BY_LOCAL_COMPUTER_ADMIN, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST;
        else
            dwFlags |= CERT_TRUST_PUB_ALLOW_END_USER_TRUST;
        
        HKEY    hKey = 0;
        DWORD   dwDisposition = 0;
        LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
                CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,     // address of subkey name
                0,       // reserved
                L"",       // address of class string
                REG_OPTION_NON_VOLATILE,      // special options flag
                KEY_ALL_ACCESS,    // desired security access
                NULL,     // address of key security structure
			    &hKey,      // address of buffer for opened handle
		        &dwDisposition);  // address of disposition value buffer
	    ASSERT (lResult == ERROR_SUCCESS);
        if ( lResult == ERROR_SUCCESS )
        {
            DWORD   cbData = sizeof (dwFlags);
            lResult = ::RegSetValueEx (hKey,
				        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, // address of value to set
				        0,              // reserved
				        REG_DWORD,          // flag for value type
				        (CONST BYTE *) &dwFlags, // address of value data
				        cbData);        // size of value data);
            ASSERT (ERROR_SUCCESS == lResult);
            if ( ERROR_SUCCESS == lResult )
		    {
			    // TRUE means we're changing the machine policy only
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
		    }
		    else
                DisplaySystemError (m_hWnd, lResult);

            RegCloseKey (hKey);
        }
    }
	
	return CHelpPropertyPage::OnApply();
}

void CSaferTrustedPublishersPropertyPage::RSOPGetTrustedPublisherFlags(const CCertMgrComponentData* pCompData)
{
    if ( pCompData )
    {
        int     nIndex = 0;
        // NOTE: rsop object array is sorted first by registry key, then by precedence
        const CRSOPObjectArray* pObjectArray = m_fIsComputerType ?
                pCompData->GetRSOPObjectArrayComputer () : pCompData->GetRSOPObjectArrayUser ();
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                if ( !_wcsicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH, pObject->GetRegistryKey ()) &&
						!_wcsicmp (CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, pObject->GetValueName ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    m_dwTrustedPublisherFlags = pObject->GetDWORDValue ();
                    m_bRSOPValueFound = true;
                    break;
                }
            }
            else
                break;

            nIndex++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferUtil.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __SAFERUTIL_H
#define __SAFERUTIL_H
#include <winsafer.h>
#include <winsaferp.h>
#include "cookie.h"
#include "storegpe.h"
#include "StoreRSOP.h"
#include "SaferStore.h"

CString SaferGetLevelFriendlyName (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer);
CString SaferGetLevelDescription (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer);


void InitializeSecurityLevelComboBox (
        CComboBox& comboBox, 
        bool bLimit, 
        DWORD dwLevelID, 
        HKEY hGroupPolicyKey,
        DWORD* pdwSaferLevels,
        bool bIsComputer);
HRESULT SaferGetLevelID (SAFER_LEVEL_HANDLE hLevel, DWORD& dwLevelID);

class CSaferEntries : public CCertMgrCookie
{
public:
	CSaferEntries (
            bool bIsMachine, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName, 
            IGPEInformation* pGPEInformation,
            IRSOPInformation* pRSOPInformation,
            CRSOPObjectArray& m_rsopObjectArray,
            LPCONSOLE   pConsole);

    virtual ~CSaferEntries ();

  	HRESULT GetDisallowedStore (CCertStore** ppStore);
	HRESULT GetTrustedPublishersStore (CCertStore** ppStore);

protected:


private:
    CCertStore*    m_pTrustedPublishersStore;
    CCertStore*    m_pDisallowedStore;
};

class CSaferRootCookie : public CCertMgrCookie
{
public:
	CSaferRootCookie (
            CertificateManagerObjectType objecttype, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName)
            : CCertMgrCookie (objecttype,
        pszMachineName, pszObjectName), 
    m_bCreateSaferNodes (true)
    {
    }

    virtual ~CSaferRootCookie ()
    {
    };

    bool    m_bCreateSaferNodes;
};

HRESULT SetRegistryScope (HKEY hKey, bool bIsComputer);


// Returns S_OK if the file has a valid signed hash
HRESULT GetSignedFileHash(
    IN LPCWSTR pwszFilename,
    OUT BYTE rgbFileHash[SAFER_MAX_HASH_SIZE],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    );
HRESULT ComputeMD5Hash(IN HANDLE hFile, BYTE hashresult[SAFER_MAX_HASH_SIZE], DWORD& dwHashSize);

CString GetURLZoneFriendlyName (DWORD dwURLZoneID);
BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString);


HRESULT SaferSetDefinedFileTypes (HWND hWnd, HKEY hGroupPolicyKey, PCWSTR pszFileTypes, int nBufLen);


#define SAFER_TRUSTED_PUBLISHER_STORE_FRIENDLY_NAME L"Safer Trusted Publisher Store"
#define SAFER_DISALLOWED_STORE_FRIENDLY_NAME        L"Safer Disallowed Store"
#define SAFER_LEVELOBJECTS_REGKEY \
            SAFER_HKLM_REGBASE SAFER_OBJECTS_REGSUBKEY

#define SAFER_COMPUTER_CODEIDS_REGKEY   SAFER_HKLM_REGBASE L"\\" SAFER_CODEIDS_REGSUBKEY
#define SAFER_USER_CODEIDS_REGKEY       SAFER_HKCU_REGBASE L"\\" SAFER_CODEIDS_REGSUBKEY

#define MD5_HASH_LEN    16
#define SHA1_HASH_LEN   20

#define NO_MORE_SAFER_LEVELS -1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\selacct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SelAcct.cpp
//
//  Contents:   Implementation of property page to allow account selection for
//				cert management
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "SelAcct.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HINSTANCE g_hInstance;
/////////////////////////////////////////////////////////////////////////////
// CSelectAccountPropPage property page

//IMPLEMENT_DYNCREATE(CSelectAccountPropPage, CAutoDeletePropPage)

CSelectAccountPropPage::CSelectAccountPropPage (const bool bIsWindowsNT) 
: CAutoDeletePropPage(CSelectAccountPropPage::IDD),
	m_pdwLocation (0),
	m_bIsWindowsNT (bIsWindowsNT)
{
	//{{AFX_DATA_INIT(CSelectAccountPropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


CSelectAccountPropPage::~CSelectAccountPropPage()
{
}

void CSelectAccountPropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectAccountPropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectAccountPropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CSelectAccountPropPage)
	ON_BN_CLICKED(IDC_PERSONAL_ACCT, OnPersonalAcct)
	ON_BN_CLICKED(IDC_SERVICE_ACCT, OnServiceAcct)
	ON_BN_CLICKED(IDC_MACHINE_ACCT, OnMachineAcct)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectAccountPropPage message handlers

BOOL CSelectAccountPropPage::OnInitDialog() 
{
	AfxSetResourceHandle (g_hInstance);
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
		*m_pdwLocation = CERT_SYSTEM_STORE_CURRENT_USER;
	CAutoDeletePropPage::OnInitDialog();
	
	GetDlgItem (IDC_PERSONAL_ACCT)->SendMessage (BM_SETCHECK, BST_CHECKED, 0);

	if ( !m_bIsWindowsNT )
	{
		GetDlgItem (IDC_SERVICE_ACCT)->EnableWindow (FALSE);
	}
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CSelectAccountPropPage::AssignLocationPtr(DWORD * pdwLocation)
{
	m_pdwLocation = pdwLocation;
}

/////////////////////////////////////////////////////////////////////////////
// MyPropertyPage message handlers

void CSelectAccountPropPage::OnPersonalAcct() 
{
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
	{
		*m_pdwLocation = CERT_SYSTEM_STORE_CURRENT_USER;
		GetParent ()->SendMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
	}
}

void CSelectAccountPropPage::OnServiceAcct()
{
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
	{
		*m_pdwLocation = CERT_SYSTEM_STORE_SERVICES;
		GetParent ()->SendMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	}
}

void CSelectAccountPropPage::OnMachineAcct()
{
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
	{
		*m_pdwLocation = CERT_SYSTEM_STORE_LOCAL_MACHINE;
		GetParent ()->SendMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	}
}

BOOL CSelectAccountPropPage::OnSetActive() 
{
	BOOL	bResult = CAutoDeletePropPage::OnSetActive();
	ASSERT (bResult);

	if ( bResult )
	{
		if ( m_bIsWindowsNT )
		{
			if ( GetDlgItem (IDC_PERSONAL_ACCT)->SendMessage (BM_GETCHECK, BST_CHECKED, 0) 
					== BST_CHECKED )
			{
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
			}
			else
			{
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
			}
		}
		else
		{
			// If Windows 95 or Windows 98, we only allow local machine
			GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
		}
	}
	
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\saferutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferUtil.cpp
//
//  Contents:   Utility methods for Software Restriction Policies extension
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include <wintrust.h>
#include <crypto\wintrustp.h>
#include <softpub.h>
#include "SaferUtil.h"
#include "SaferEntry.h"
#include <winsaferp.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HKEY g_hkeyLastSaferRegistryScope;
bool g_bIsComputer = false;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

void InitializeSecurityLevelComboBox (
        CComboBox& comboBox, 
        bool bLimit, 
        DWORD dwLevelID, 
        HKEY hGroupPolicyKey,
        DWORD* pdwSaferLevels,
        bool bIsComputer)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( !hGroupPolicyKey )  // is RSOP
    {
        CString szText = SaferGetLevelFriendlyName (dwLevelID, 
                hGroupPolicyKey, bIsComputer);
        int nItem = comboBox.AddString (szText);
        ASSERT (nItem >= 0);
        if ( nItem >= 0 )
        {
            VERIFY (CB_ERR != comboBox.SetItemData (nItem, dwLevelID));
            VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
        }

        return;
    }

    if ( pdwSaferLevels )
    {
        for (UINT nIndex = 0; 
                NO_MORE_SAFER_LEVELS != pdwSaferLevels[nIndex]; 
                nIndex++)
        {
            CString szText;
            int     nItem = 0;

            switch (pdwSaferLevels[nIndex])
            {
            case SAFER_LEVELID_FULLYTRUSTED:
                szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                        hGroupPolicyKey, bIsComputer);
                nItem = comboBox.AddString (szText);
                ASSERT (nItem >= 0);
                if ( nItem >= 0 )
                {
                    VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                    if ( pdwSaferLevels[nIndex] == dwLevelID || AUTHZ_UNKNOWN_LEVEL == dwLevelID)
                        VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                }
                break;

            case SAFER_LEVELID_CONSTRAINED:
                if ( !bLimit )
                {
                    szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                            hGroupPolicyKey, bIsComputer);
                    nItem = comboBox.AddString (szText);
                    ASSERT (nItem >= 0);
                    if ( nItem >= 0 )
                    {
                        VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                        if ( pdwSaferLevels[nIndex] == dwLevelID )
                            VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                    }
                }
                break;

            case SAFER_LEVELID_DISALLOWED:
                szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                        hGroupPolicyKey, bIsComputer);
                nItem = comboBox.AddString (szText);
                ASSERT (nItem >= 0);
                if ( nItem >= 0 )
                {
                    VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                    if ( pdwSaferLevels[nIndex] == dwLevelID )
                        VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                }
                break;

            case SAFER_LEVELID_NORMALUSER:
            case SAFER_LEVELID_UNTRUSTED:
                if ( !bLimit )
                {
                    if ( hGroupPolicyKey )
                    {
                        szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                                hGroupPolicyKey, bIsComputer);
                        nItem = comboBox.AddString (szText);
                        ASSERT (nItem >= 0);
                        if ( nItem >= 0 )
                        {
                            VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                            if ( pdwSaferLevels[nIndex] == dwLevelID )
                                VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                        }
                    }
                }
                break;

            default:
                ASSERT (0);
                break;
            }
        }
    }
}

class CLevelPair {
public:
    CLevelPair () :
        m_dwLevelID ((DWORD) -1)
    {
    }
    virtual ~CLevelPair () {}

    DWORD   m_dwLevelID;
    CString m_szLevelName;
};

CString SaferGetLevelFriendlyName (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer)
{
    CString             szLevelName;
    SAFER_LEVEL_HANDLE  hLevel = 0;
    BOOL                bRVal = FALSE;
    const int           NUM_LEVEL_PAIRS = 10;
    static CLevelPair   levelPairs[NUM_LEVEL_PAIRS];

    for (int nLevelIndex = 0; nLevelIndex < NUM_LEVEL_PAIRS; nLevelIndex++)
    {
        if ( -1 == levelPairs[nLevelIndex].m_dwLevelID )
            break;
        else if ( dwLevelID == levelPairs[nLevelIndex].m_dwLevelID )
        {
            return levelPairs[nLevelIndex].m_szLevelName;
        }
    }

    if ( hGroupPolicyKey )
    {
        if ( !g_hkeyLastSaferRegistryScope )
            SetRegistryScope (hGroupPolicyKey, bIsComputer);
        
        
        bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                hGroupPolicyKey);
    }
    else
    {
        bRVal = SaferCreateLevel (SAFER_SCOPEID_MACHINE,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                0);
    }

    if ( bRVal )
    {
        DWORD   dwBufferSize = 0;
        DWORD   dwErr = 0;
        bRVal = SaferGetLevelInformation(hLevel, 
                SaferObjectFriendlyName,
                0,
                dwBufferSize,
                &dwBufferSize);
        if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
        {
            PWSTR  pszLevelName = (PWSTR) LocalAlloc (LPTR, dwBufferSize);
            if ( pszLevelName )
            {
                bRVal = SaferGetLevelInformation(hLevel, 
                        SaferObjectFriendlyName,
                        pszLevelName,
                        dwBufferSize,
                        &dwBufferSize);
                ASSERT (bRVal);
                if ( bRVal )
                {
                    szLevelName = pszLevelName;
                }
                else
                {
                    dwErr = GetLastError ();
                    _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                            dwErr);
                }

                LocalFree (pszLevelName);
            }
        }
        else if ( !bRVal )
        {
            dwErr = GetLastError ();
            _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                    dwErr);
        }

        VERIFY (SaferCloseLevel (hLevel));
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"SaferCloseLevel (SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                dwLevelID, dwErr);
    }

    if ( nLevelIndex < NUM_LEVEL_PAIRS && !szLevelName.IsEmpty () )
    {
        levelPairs[nLevelIndex].m_dwLevelID = dwLevelID;
        levelPairs[nLevelIndex].m_szLevelName = szLevelName;
    }
    return szLevelName;
}

CString SaferGetLevelDescription (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer)
{
    CString             szDescription;
    SAFER_LEVEL_HANDLE  hLevel = 0;
    BOOL                bRVal = FALSE;

    if ( hGroupPolicyKey )
    {
        if ( !g_hkeyLastSaferRegistryScope )
            SetRegistryScope (hGroupPolicyKey, bIsComputer);
        
        bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                hGroupPolicyKey);
    }
    else
    {
        bRVal = SaferCreateLevel (SAFER_SCOPEID_MACHINE,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                0);
    }

    ASSERT (bRVal);
    if ( bRVal )
    {
        DWORD   dwBufferSize = 0;
        DWORD   dwErr = 0;
        bRVal = SaferGetLevelInformation(hLevel, 
                SaferObjectDescription,
                0,
                dwBufferSize,
                &dwBufferSize);
        if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
        {
            PWSTR  pszDescription = (PWSTR) LocalAlloc (LPTR, dwBufferSize);
            if ( pszDescription )
            {
                bRVal = SaferGetLevelInformation(hLevel, 
                        SaferObjectDescription,
                        pszDescription,
                        dwBufferSize,
                        &dwBufferSize);
                ASSERT (bRVal);
                if ( bRVal )
                {
                    szDescription = pszDescription;
                }
                else
                {
                    dwErr = GetLastError ();
                    _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                            dwErr);
                }

                LocalFree (pszDescription);
            }
        }
        else if ( !bRVal )
        {
            dwErr = GetLastError ();
            _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                    dwErr);
        }

        if ( ERROR_NOT_FOUND == dwErr || szDescription.IsEmpty () )
        {
            VERIFY (szDescription.LoadString (IDS_NOT_AVAILABLE));
        }

        VERIFY (SaferCloseLevel (hLevel));
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"SaferCloseLevel (SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                dwLevelID, dwErr);
    }

    return szDescription;
}


HRESULT SaferGetLevelID (SAFER_LEVEL_HANDLE hLevel, DWORD& dwLevelID)
{
    ASSERT (0 != g_hkeyLastSaferRegistryScope);
    DWORD   dwBufferSize = sizeof (DWORD);
    HRESULT hr = S_OK;

    BOOL bRVal = SaferGetLevelInformation(hLevel, 
        SaferObjectLevelId,
        &dwLevelID,
        dwBufferSize,
        &dwBufferSize);
    ASSERT (bRVal);
    if ( !bRVal )
    {
        DWORD dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferGetLevelInformation(SaferObjectLevelId) failed: %d\n", 
                dwErr);
    }

    return hr;
}


CSaferEntries::CSaferEntries(
        bool bIsMachine, 
        PCWSTR pszMachineName, 
        PCWSTR pszObjectName, 
        IGPEInformation* pGPEInformation,
        IRSOPInformation* pRSOPInformation,
        CRSOPObjectArray& rsopObjectArray,
        LPCONSOLE   pConsole)
: CCertMgrCookie (bIsMachine ? CERTMGR_SAFER_COMPUTER_ENTRIES : CERTMGR_SAFER_USER_ENTRIES, 
        pszMachineName, pszObjectName),
        m_pTrustedPublishersStore (0),
        m_pDisallowedStore (0)
{
    if ( pGPEInformation )
    {
        m_pTrustedPublishersStore = new CCertStoreSafer (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_TRUSTED_PUBLISHER_STORE_FRIENDLY_NAME,
			    SAFER_TRUSTED_PUBLISHER_STORE_NAME,
			    L"",
			    pGPEInformation,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    
        m_pDisallowedStore = new CCertStoreSafer (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_DISALLOWED_STORE_FRIENDLY_NAME,
			    SAFER_DISALLOWED_STORE_NAME,
			    L"",
			    pGPEInformation,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    }
    else if ( pRSOPInformation )
    {
        m_pTrustedPublishersStore = new CCertStoreRSOP (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_TRUSTED_PUBLISHER_STORE_FRIENDLY_NAME,
			    SAFER_TRUSTED_PUBLISHER_STORE_NAME,
			    L"",
			    rsopObjectArray,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    
        m_pDisallowedStore = new CCertStoreRSOP (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_DISALLOWED_STORE_FRIENDLY_NAME,
			    SAFER_DISALLOWED_STORE_NAME,
			    L"",
			    rsopObjectArray,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    }

 }

CSaferEntries::~CSaferEntries ()
{
    if ( m_pTrustedPublishersStore )
        m_pTrustedPublishersStore->Release ();

    if ( m_pDisallowedStore )
        m_pDisallowedStore->Release ();
}

HRESULT CSaferEntries::GetTrustedPublishersStore(CCertStore **ppStore)
{
    if ( !ppStore )
        return E_POINTER;

    if ( m_pTrustedPublishersStore )
    {
        m_pTrustedPublishersStore->AddRef ();
        *ppStore = m_pTrustedPublishersStore;
    }
    else
        return E_FAIL;

    return S_OK;
}

HRESULT CSaferEntries::GetDisallowedStore(CCertStore **ppStore)
{
    if ( !ppStore )
        return E_POINTER;

    if ( m_pDisallowedStore )
    {
        m_pDisallowedStore->AddRef ();
        *ppStore = m_pDisallowedStore;
    }
    else
        return E_FAIL;


    return S_OK;
}

HRESULT SetRegistryScope (HKEY hKey, bool bIsComputer)
{
    HRESULT hr = S_OK;

 
    if ( g_hkeyLastSaferRegistryScope != hKey || g_bIsComputer != bIsComputer )
    {
        BOOL bRVal = SaferiChangeRegistryScope (hKey, REG_OPTION_NON_VOLATILE);
        ASSERT (bRVal);
        if ( bRVal )
        {
            g_hkeyLastSaferRegistryScope = hKey;
            g_bIsComputer = bIsComputer;
        }
        else
        {
            DWORD dwErr = GetLastError ();
            hr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"SaferiChangeRegistryScope (%s) failed: %d\n", 
                    hKey ? L"hKey" : L"0", dwErr);
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

// Returns S_OK if the file has a valid signed hash
HRESULT GetSignedFileHash(
    IN LPCWSTR pwszFilename,
    OUT BYTE rgbFileHash[SAFER_MAX_HASH_SIZE],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    )
{
    HRESULT hr = S_OK;
    if ( !pwszFilename || !rgbFileHash || !pcbFileHash || !pHashAlgid )
        return E_POINTER;
    _TRACE (1, L"Entering GetSignedFileHash (%s)\n", pwszFilename);

    // Returns S_OK and the hash if the file was signed and contains a valid
    // hash
    *pcbFileHash = SAFER_MAX_HASH_SIZE;
    hr = WTHelperGetFileHash(
            pwszFilename,
            0,
            NULL,
            rgbFileHash,
            pcbFileHash,
            pHashAlgid);
    if ( FAILED (hr) )
    {
        _TRACE (0, L"WTHelperGetFileHash (%s) failed: 0x%x\n", pwszFilename, hr);
    }

    _TRACE (-1, L"Leaving GetSignedFileHash (%s): 0x%x\n", pwszFilename, hr);
    return hr;
}


HRESULT ComputeMD5Hash(IN HANDLE hFile, BYTE hashResult[SAFER_MAX_HASH_SIZE], DWORD& dwHashSize)
/*++

Routine Description:

    Computes the MD5 hash of a given file's contents and prints the
    resulting hash value to the screen.

Arguments:

    szFilename - filename to compute hash of.

Return Value:

    Returns 0 on success, or a non-zero exit code on failure.

--*/
{
    _TRACE (1, L"Entering ComputeMD5Hash ()\n");
    HRESULT     hr = S_OK;

    //
    // Open the specified file and map it into memory.
    //
    HANDLE  hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if ( hMapping )
    {
        DWORD dwDataLen = GetFileSize (hFile, NULL);

        if ( -1 != dwDataLen )
        {
            LPBYTE pbData = (LPBYTE) ::MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, dwDataLen);
            if ( pbData ) 
            {
                //
                // Generate the hash value of the specified file.
                //
                HCRYPTPROV  hProvider = 0;
                if ( CryptAcquireContext(&hProvider, NULL, NULL,
                      PROV_RSA_SIG, CRYPT_VERIFYCONTEXT) ||
                  CryptAcquireContext(&hProvider, NULL, NULL,
                      PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
                {
                    HCRYPTHASH  hHash = 0;
                    if ( CryptCreateHash(hProvider, CALG_MD5, 0, 0, &hHash) )
                    {
                        if ( CryptHashData (hHash, pbData, dwDataLen, 0) )
                        {
                            dwHashSize = SAFER_MAX_HASH_SIZE;
                            
                            if (!CryptGetHashParam(hHash, HP_HASHVAL, hashResult, &dwHashSize, 0))
                            {
                                dwHashSize = 0;
                                DWORD   dwErr = GetLastError ();
                                hr = HRESULT_FROM_WIN32 (dwErr);
                                _TRACE (0, L"CryptHashData () failed: 0x%x\n", hr);
                            }
                        }
                        else
                        {
                            DWORD   dwErr = GetLastError ();
                            hr = HRESULT_FROM_WIN32 (dwErr);
                            _TRACE (0, L"CryptHashData () failed: 0x%x\n", hr);
                        }
                        CryptDestroyHash(hHash);
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"CryptCreateHash () failed: 0x%x\n", hr);
                    }
                    CryptReleaseContext(hProvider, 0);
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"CryptAcquireContext () failed: 0x%x\n", hr);
                }

                ::UnmapViewOfFile(pbData);
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"MapViewOfFile () failed: 0x%x\n", dwErr);
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"GetFileSize () failed: 0x%x\n", dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }

        VERIFY (CloseHandle(hMapping));
        hMapping = 0;
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CreateFileMapping () failed: 0x%x\n", dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving ComputeMD5Hash (): 0x%x\n", hr);
    return hr;
}

CString GetURLZoneFriendlyName (DWORD dwURLZoneID)
{
    CString szFriendlyName;

    switch (dwURLZoneID)
    {
    case URLZONE_LOCAL_MACHINE:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_LOCAL_MACHINE));
        break;

    case URLZONE_INTRANET:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_INTRANET));
        break;

    case URLZONE_TRUSTED:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_TRUSTED));
        break;

    case URLZONE_INTERNET:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_INTERNET));
        break;

    case URLZONE_UNTRUSTED:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_UNTRUSTED));
        break;

    default:
        ASSERT (0);
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_UNKNOWN));
        break;
    }

    return szFriendlyName;
}

//
// Given a GUID in string format it returns a GUID struct
//
// e.g. "{00299570-246d-11d0-a768-00aa006e0529}" to a struct form
//

BOOL GuidFromString(GUID* pGuid, LPCWSTR lpszGuidString)
{
  ZeroMemory(pGuid, sizeof(GUID));
  if (lpszGuidString == NULL)
  {
    return FALSE;
  }

  int nLen = lstrlen(lpszGuidString);
  // the string length should be 38
  if (nLen != 38)
    return FALSE;

  return SUCCEEDED(::CLSIDFromString (const_cast <LPOLESTR>(lpszGuidString), pGuid));
}


HRESULT SaferSetDefinedFileTypes (
            HWND hWnd, 
            HKEY hGroupPolicyKey, 
            PCWSTR pszFileTypes, 
            int nBufLen)
{
    HRESULT hr = S_OK;
    DWORD   dwDisposition = 0;

    HKEY    hKey = 0;
    LONG lResult = ::RegCreateKeyEx (hGroupPolicyKey, // handle of an open key
            SAFER_COMPUTER_CODEIDS_REGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (ERROR_SUCCESS == lResult);
    if ( ERROR_SUCCESS == lResult )
    {
        lResult = ::RegSetValueEx (
                hKey,           // handle to key
                SAFER_EXETYPES_REGVALUE, // value name
                0,      // reserved
                REG_MULTI_SZ,        // value type
                (PBYTE) pszFileTypes,  // value data
                nBufLen);         // size of value data
        if ( ERROR_SUCCESS != lResult )
        {
            DisplaySystemError (hWnd, lResult);
            _TRACE (0, L"RegSetValueEx (SAFER_EXETYPES_REGVALUE, %s) failed: %d\n", 
                    pszFileTypes, lResult);
            hr = HRESULT_FROM_WIN32 (lResult);
        }

        RegCloseKey (hKey);
    }
    else
    {
        DisplaySystemError (hWnd, lResult);
        _TRACE (0, L"RegCreateKeyEx (SAFER_CODEID_KEY) failed: %d\n", lResult);
        hr = HRESULT_FROM_WIN32 (lResult);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\selservc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SelServc.cpp
//
//  Contents:   Implementation of Service Selection setup page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "SelServc.h"

USE_HANDLE_MACROS("CERTMGR(SelServc.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectServiceAccountPropPage property page

//IMPLEMENT_DYNCREATE(CSelectServiceAccountPropPage, CAutoDeletePropPage)

CSelectServiceAccountPropPage::CSelectServiceAccountPropPage(
		CString* pszManagedService, 
		CString* pszManagedServiceDisplayName,
		const CString& szManagedMachine) : 
	CAutoDeletePropPage(CSelectServiceAccountPropPage::IDD),
	m_pszManagedService (pszManagedService),
	m_pszManagedServiceDisplayName (pszManagedServiceDisplayName),
	m_szManagedMachine (szManagedMachine),
	m_savedManagedMachineName (_T("$uninitialized machine name$"))
{
	ASSERT (pszManagedService);
	//{{AFX_DATA_INIT(CSelectServiceAccountPropPage)
	//}}AFX_DATA_INIT
}

CSelectServiceAccountPropPage::~CSelectServiceAccountPropPage()
{
}

void CSelectServiceAccountPropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectServiceAccountPropPage)
	DDX_Control(pDX, IDC_ACCT_NAME, m_acctNameList);
	DDX_Control(pDX, IDC_INSTRUCTIONS, m_instructionsText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectServiceAccountPropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CSelectServiceAccountPropPage)
	ON_CBN_SELCHANGE(IDC_ACCT_NAME, OnSelchangeAcctName)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectServiceAccountPropPage message handlers


BOOL CSelectServiceAccountPropPage::OnSetActive() 
{
	BOOL	bResult = CAutoDeletePropPage::OnSetActive();
	ASSERT (bResult);


	if ( IsLocalComputername (m_szManagedMachine) )
	{
		CString	text;
		VERIFY (text.LoadString (IDS_SELECT_SERVICE_ON_LOCAL_MACHINE));
		m_instructionsText.SetWindowText (text);
	}
	else
	{
		CString text;
		size_t	len = m_instructionsText.GetWindowTextLength () + 1;
		m_instructionsText.GetWindowText (text.GetBufferSetLength ((int) len), (int) len);
		text.FormatMessage (text, m_szManagedMachine);
		m_instructionsText.SetWindowText (text);
	}

	if ( m_savedManagedMachineName != m_szManagedMachine )
	{
    	GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
                PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
		m_savedManagedMachineName = m_szManagedMachine;
		FreeDataPointers  ();
		EnumerateServices ();
	}
    else
    {
    	GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
                PSWIZB_BACK | PSWIZB_FINISH);
    }

	return bResult;
}

BOOL CSelectServiceAccountPropPage::OnInitDialog() 
{
	CAutoDeletePropPage::OnInitDialog();
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CSelectServiceAccountPropPage::EnumerateServices()
{
	HRESULT hResult = S_OK;
    DWORD					cbBytesNeeded = 0;
    DWORD					entriesRead = 0;
    DWORD					resumeHandle = 0;
	DWORD					dwErr = 0;
	LPCWSTR lpMachineName = (LPCWSTR) (m_szManagedMachine);

    SC_HANDLE	hScManager = ::OpenSCManager (lpMachineName,
                    SERVICES_ACTIVE_DATABASE,
                    SC_MANAGER_ENUMERATE_SERVICE);
    if ( hScManager ) 
	{
	    LPENUM_SERVICE_STATUS	enumBuffer = new ENUM_SERVICE_STATUS[32];
		DWORD					cbBufSize = sizeof (ENUM_SERVICE_STATUS) * 32;
		BOOL					bResult = FALSE;

		if ( enumBuffer )
		{
			int	nIndex = 0;
			//
			// Enumerate the ServiceStatus
			//
			dwErr = NO_ERROR;

			do 
			{
				bResult = ::EnumServicesStatus (
						hScManager,
						SERVICE_WIN32,
						SERVICE_STATE_ALL,
						enumBuffer,
						cbBufSize,
						&cbBytesNeeded,
						&entriesRead,
						&resumeHandle);
				if ( bResult || GetLastError() == ERROR_MORE_DATA )
				{
					for (UINT i = 0; i < entriesRead && SUCCEEDED (hResult); i++)
					{
						nIndex = m_acctNameList.AddString (
								enumBuffer[i].lpDisplayName);
						ASSERT (nIndex >= 0);
						switch ( nIndex )
						{
						case LB_ERR:
							hResult = E_FAIL;
							break;

						case LB_ERRSPACE:
							hResult = E_OUTOFMEMORY;
							break;

						default:
							nIndex = m_acctNameList.SetItemDataPtr (nIndex, 
									new CString (enumBuffer[i].lpServiceName));
							ASSERT (nIndex != LB_ERR);
							if ( nIndex == LB_ERR )
								hResult = E_FAIL;
							break;
						}
					}
				}
				else
				{
					dwErr = GetLastError();
					DisplaySystemError (m_hWnd, dwErr);
					hResult = HRESULT_FROM_WIN32 (dwErr);
					break;
				}
			} while (SUCCEEDED (hResult) && resumeHandle > 0);

			int nCnt = m_acctNameList.GetCount ();
			ASSERT (nCnt != LB_ERR);
			if ( nCnt > 0 )
			{	
				nIndex = m_acctNameList.SetCurSel (0);
				ASSERT (nIndex != LB_ERR);
				if ( nIndex != LB_ERR )
				{
					CopyCurrentString ();
					if ( m_pszManagedService && m_pszManagedService->IsEmpty () )
						GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
								PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
					else
						GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
								PSWIZB_BACK | PSWIZB_FINISH);
				}
			}
			
			delete [] enumBuffer;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}

		bResult = ::CloseServiceHandle (hScManager);
		ASSERT (bResult);
		if ( !bResult )
		{
			dwErr = GetLastError ();
			DisplaySystemError (m_hWnd, dwErr);
			hResult = HRESULT_FROM_WIN32 (dwErr);
		}
	}
	else
	{
        dwErr = GetLastError ();
		DisplaySystemError (m_hWnd, dwErr);
		hResult = HRESULT_FROM_WIN32 (dwErr);
/*
		switch (dwErr)
		{
		case ERROR_ACCESS_DENIED: // The requested access was denied. 
			break;

		case ERROR_DATABASE_DOES_NOT_EXIST: // The specified database does not exist. 
			break;

		case ERROR_INVALID_PARAMETER:
			break;

		case RPC_S_SERVER_UNAVAILABLE:
			break;
		}
*/
    }

	return hResult;
}

void CSelectServiceAccountPropPage::OnSelchangeAcctName() 
{
	CopyCurrentString ();
	ASSERT (m_pszManagedService);
	if ( m_pszManagedService && m_pszManagedService->IsEmpty () )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
				PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
	else
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
				PSWIZB_BACK | PSWIZB_FINISH);
}

void CSelectServiceAccountPropPage::FreeDataPointers()
{
	CString*	pStr = 0;
	int			nCnt = m_acctNameList.GetCount ();

	for (int i = nCnt-1; i >= 0; i--)
	{
		pStr = (CString*) m_acctNameList.GetItemDataPtr (i);
		ASSERT (pStr != (CString*) LB_ERR);
		ASSERT (pStr);
		if ( pStr && pStr != (CString*) LB_ERR )
			delete pStr;
		m_acctNameList.SetItemDataPtr (i, 0);
        m_acctNameList.DeleteString (i);
	}
}

void CSelectServiceAccountPropPage::OnDestroy() 
{
	CAutoDeletePropPage::OnDestroy();
	
	FreeDataPointers  ();
}

void CSelectServiceAccountPropPage::CopyCurrentString()
{
	ASSERT (m_pszManagedService);
	if ( m_pszManagedService )
	{
		int	nIndex = m_acctNameList.GetCurSel ();
		ASSERT (LB_ERR != nIndex);
		if ( LB_ERR != nIndex )
		{
			CString*	pStr = (CString*) m_acctNameList.GetItemDataPtr (nIndex);
			ASSERT (pStr && pStr != (CString*) LB_ERR);
			if ( pStr && pStr != (CString*) LB_ERR )
				*m_pszManagedService = *pStr;

			m_acctNameList.GetText (nIndex, 
					*m_pszManagedServiceDisplayName);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\snapmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SnapMgr.cpp
//
//  Contents:   implementation file for Snapin Manager property page
//
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "chooser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\selservc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SelServc.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_SELSERVC_H__9A888DAC_62BF_11D1_85BA_00C04FB94F17__INCLUDED_)
#define AFX_SELSERVC_H__9A888DAC_62BF_11D1_85BA_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelServc.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectServiceAccountPropPage dialog

class CSelectServiceAccountPropPage : public CAutoDeletePropPage
{
//	DECLARE_DYNCREATE(CSelectServiceAccountPropPage)

// Construction
public:
	CSelectServiceAccountPropPage (
			CString* pszManagedService, 
			CString* pszManagedServiceDisplayName,
			const CString& pszManagedMachine);
	virtual ~CSelectServiceAccountPropPage();

// Dialog Data
	//{{AFX_DATA(CSelectServiceAccountPropPage)
	enum { IDD = IDD_PROPPAGE_CHOOSE_SERVICE };
	CListBox	m_acctNameList;
	CStatic		m_instructionsText;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectServiceAccountPropPage)
	protected:
	virtual BOOL OnSetActive();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void CopyCurrentString ();
	void FreeDataPointers ();
	HRESULT EnumerateServices ();
	// Generated message map functions
	//{{AFX_MSG(CSelectServiceAccountPropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeAcctName();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CString		m_savedManagedMachineName;
	const CString&	m_szManagedMachine;
	CString*	m_pszManagedService;
	CString*	m_pszManagedServiceDisplayName;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELSERVC_H__9A888DAC_62BF_11D1_85BA_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\selacct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       selacct.h
//
//  Contents:   Property page to choose type of cert administration.
//
//----------------------------------------------------------------------------
#if !defined(AFX_SELACCT_H__E76F93EC_23F0_11D1_A28B_00C04FB94F17__INCLUDED_)
#define AFX_SELACCT_H__E76F93EC_23F0_11D1_A28B_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelAcct.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectAccountPropPage dialog

class CSelectAccountPropPage : public CAutoDeletePropPage
{
//	DECLARE_DYNCREATE(CSelectAccountPropPage)

// Construction
public:
	void AssignLocationPtr (DWORD* pdwLocation);
//	CSelectAccountPropPage();  // default, but don't use
	CSelectAccountPropPage(const bool m_bIsWindowsNT);
	virtual ~CSelectAccountPropPage();

// Dialog Data
	//{{AFX_DATA(CSelectAccountPropPage)
	enum { IDD = IDD_PROPPAGE_CHOOSE_ACCOUNT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectAccountPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectAccountPropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnPersonalAcct();
	afx_msg void OnServiceAcct();
	afx_msg void OnMachineAcct();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const bool m_bIsWindowsNT;
	DWORD* m_pdwLocation;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELACCT_H__E76F93EC_23F0_11D1_A28B_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\snapmgr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SnapMgr.h
//
//  Contents:   header file for Snapin Manager property page
//
//----------------------------------------------------------------------------

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#endif // ~__SNAPMGR_H__
/////////////////////////////////////////////////////////////////////////////
// CCertMgrChooseMachinePropPage dialog

class CCertMgrChooseMachinePropPage : public CChooseMachinePropPage
{
// Construction
public:
	CCertMgrChooseMachinePropPage();
	virtual ~CCertMgrChooseMachinePropPage();
	void AssignLocationPtr (DWORD* pdwLocation);

// Dialog Data
	//{{AFX_DATA(CCertMgrChooseMachinePropPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertMgrChooseMachinePropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertMgrChooseMachinePropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	virtual LRESULT OnWizardNext();
private:
	DWORD* m_pdwLocation;
};
/////////////////////////////////////////////////////////////////////////////
// CCertMgrChooseMachinePropPage property page

CCertMgrChooseMachinePropPage::CCertMgrChooseMachinePropPage() : 
	CChooseMachinePropPage(),
	m_pdwLocation (0)
{
	//{{AFX_DATA_INIT(CCertMgrChooseMachinePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCertMgrChooseMachinePropPage::~CCertMgrChooseMachinePropPage()
{
}

void CCertMgrChooseMachinePropPage::AssignLocationPtr(DWORD * pdwLocation)
{
	m_pdwLocation = pdwLocation;
}

void CCertMgrChooseMachinePropPage::DoDataExchange(CDataExchange* pDX)
{
	CChooseMachinePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertMgrChooseMachinePropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCertMgrChooseMachinePropPage, CChooseMachinePropPage)
	//{{AFX_MSG_MAP(CCertMgrChooseMachinePropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCertMgrChooseMachinePropPage message handlers
BOOL CCertMgrChooseMachinePropPage::OnSetActive() 
{
	if ( m_pdwLocation && CERT_SYSTEM_STORE_SERVICES == *m_pdwLocation )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);
	else
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH);
	
	// Do not call CChooseMachinePropPage here because it will disable the back button. 
	// Call the grandparent instead.
	return CPropertyPage::OnSetActive();
}


LRESULT CCertMgrChooseMachinePropPage::OnWizardNext()
{
	UpdateData (TRUE);
	if ( m_pstrMachineNameOut )
		// Store the machine name into its output buffer
		*m_pstrMachineNameOut = m_strMachineName;

	return CChooseMachinePropPage::OnWizardNext ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       StdAFX.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------\
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#pragma warning(push, 3)
#include <statreg.h>
#include <statreg.cpp>
#pragma warning(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\storegpe.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       StoreGPE.cpp
//
//  Contents:   Implementation of CCertStoreGPE
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "cookie.h"
#include "storegpe.h"
#include "certifct.h"

USE_HANDLE_MACROS("CERTMGR(storegpe.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

GUID g_guidExtension = { 0xb1be8d72, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a }};
GUID g_guidRegExt = REGISTRY_EXTENSION_GUID;
GUID g_guidSnapin = CLSID_CertificateManager;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertStoreGPE::Commit ()
{
    _TRACE (1, L"Entering CCertStoreGPE::Commit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    HRESULT hr = S_OK;


    if ( GetStoreType () == EFS_STORE && !m_fIsNullEFSPolicy )
    {
        if ( SUCCEEDED (hr) )
            hr = WriteEFSBlobToRegistry ();
    }

    if ( SUCCEEDED (hr) && m_bDirty )
    {
        hr = CCertStore::Commit ();
        ASSERT (SUCCEEDED (hr));
        ASSERT (m_pGPEInformation);
        if ( SUCCEEDED (hr) && m_pGPEInformation )
        {
            hr = m_pGPEInformation->PolicyChanged (
                    m_fIsComputerType ? TRUE : FALSE,
                    TRUE, &g_guidExtension, &g_guidSnapin );
             hr = m_pGPEInformation->PolicyChanged (
                    m_fIsComputerType ? TRUE : FALSE,
                    TRUE, &g_guidRegExt, &g_guidSnapin );
            ASSERT (SUCCEEDED (hr));
        }
    }


    _TRACE (-1, L"Leaving CCertStoreGPE::Commit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}



CCertStoreGPE::CCertStoreGPE (
            DWORD dwFlags,
            LPCWSTR lpcszMachineName,
            LPCWSTR objectName,
            const CString & pcszLogStoreName,
            const CString & pcszPhysStoreName,
            IGPEInformation * pGPTInformation,
            const GUID& compDataGUID,
            IConsole* pConsole)
    : CCertStore (CERTMGR_LOG_STORE_GPE,
        CERT_STORE_PROV_SYSTEM, dwFlags, lpcszMachineName, objectName,
        pcszLogStoreName, pcszPhysStoreName,
        StoreNameToType (pcszLogStoreName),
        0,
        pConsole),
    m_pGPEInformation (pGPTInformation),
    m_fIsComputerType (false),
    m_fIsNullEFSPolicy (true),       // assume NULL policy until proven otherwise
    m_hGroupPolicyKey (0)
{
    _TRACE (1, L"Entering CCertStoreGPE::CCertStoreGPE - %s\n",
            (LPCWSTR) pcszLogStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        if ( ::IsEqualGUID (compDataGUID, NODEID_User) )
        {
            m_fIsComputerType = false;
            m_dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;
        }
        else if ( ::IsEqualGUID (compDataGUID, NODEID_Machine) )
        {
            m_fIsComputerType = true;
            m_dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;
        }
        else
            ASSERT (0);
    }
    _TRACE (-1, L"Leaving CCertStoreGPE::CCertStoreGPE - %s\n",
            (LPCWSTR) pcszLogStoreName);
}


CCertStoreGPE::~CCertStoreGPE ()
{
    _TRACE (1, L"Entering CCertStoreGPE::~CCertStoreGPE - %s\n",
            (LPCWSTR) m_pcszStoreName);;
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);

    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
        m_pGPEInformation = 0;
    }

    CERT_CONTEXT_PSID_STRUCT* pCert = 0;
    while (!m_EFSCertList.IsEmpty () )
    {
        pCert = m_EFSCertList.RemoveHead ();
        ASSERT (pCert);
        if ( pCert )
            delete pCert;
    }
    _TRACE (-1, L"Leaving CCertStoreGPE::~CCertStoreGPE - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HCERTSTORE CCertStoreGPE::GetStoreHandle (BOOL bSilent /*= FALSE*/, HRESULT* phr /* = 0*/)
{
    _TRACE (1, L"Entering CCertStoreGPE::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;
    void*                           pvPara = 0;

    if ( !m_hCertStore )
    {
        DWORD   dwErr = 0;

        if ( EFS_STORE == GetStoreType () && m_fIsNullEFSPolicy )
        {
            // Test to see if EFS key exists, if not, flag this as
            // having no EFS policy and return.
            HKEY    hEFSKey = 0;
            LONG lResult = ::RegOpenKeyEx (GetGroupPolicyKey (), CERT_EFSBLOB_REGPATH, 0,
                    KEY_ALL_ACCESS, &hEFSKey);
            if ( ERROR_SUCCESS == lResult )
            {
                m_fIsNullEFSPolicy = false;
                VERIFY (ERROR_SUCCESS == ::RegCloseKey (hEFSKey));
            }
            else
                return 0;
        }
        RelocatePara.hKeyBase = GetGroupPolicyKey ();
        RelocatePara.pwszSystemStore = (LPCWSTR) m_pcszStoreName;
        pvPara = (void*) &RelocatePara;
        m_hCertStore = ::CertOpenStore (m_storeProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
                m_dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                pvPara);
        if ( !m_hCertStore )
        {
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            m_hCertStore = ::CertOpenStore (m_storeProvider,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
                    m_dwFlags | CERT_STORE_READONLY_FLAG | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                    pvPara);
            if ( m_hCertStore )
                m_bReadOnly = true;
            else
			{
                dwErr = GetLastError ();
                if ( phr )
                    *phr = HRESULT_FROM_WIN32 (dwErr);
				_TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
						(PCWSTR) m_pcszStoreName, dwErr);
			}
        }

        if ( !m_hCertStore && !m_bUnableToOpenMsgDisplayed && !bSilent && 
                (USERDS_STORE != GetStoreType ()) )
        {
            m_bUnableToOpenMsgDisplayed = true;
            CString caption;
            CString text;
            int         iRetVal = 0;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_UNABLE_TO_OPEN_STORE, GetStoreName (), 
                    GetSystemMessage (dwErr));
            if ( m_pConsole )
                m_pConsole->MessageBox (text, caption, MB_OK | MB_ICONINFORMATION, &iRetVal);
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);

    return m_hCertStore;
}

bool CCertStoreGPE::CanContain(CertificateManagerObjectType nodeType)
{
    _TRACE (1, L"Entering CCertStoreGPE::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    bool    bCanContain = false;

    switch (nodeType)
    {
    case CERTMGR_CERTIFICATE:
        if ( ROOT_STORE == GetStoreType () ||
                EFS_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    case CERTMGR_CTL:
        if ( TRUST_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bCanContain;
}


bool CCertStoreGPE::IsMachineStore()
{
    _TRACE (0, L"Entering and leaving CCertStoreGPE::IsMachineStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);

    if (m_dwFlags & CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY)
        return true;
    else
        return false;
}


HKEY CCertStoreGPE::GetGroupPolicyKey()
{
    _TRACE (1, L"Entering CCertStoreGPE::GetGroupPolicyKey - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    if ( !m_hGroupPolicyKey )
    {
        if ( m_fIsComputerType )
        {
            HRESULT hr = m_pGPEInformation->GetRegistryKey (GPO_SECTION_MACHINE,
                    &m_hGroupPolicyKey);
            ASSERT (SUCCEEDED (hr));
        }
        else
        {
            HRESULT hr = m_pGPEInformation->GetRegistryKey (GPO_SECTION_USER,
                    &m_hGroupPolicyKey);
            ASSERT (SUCCEEDED (hr));
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::GetGroupPolicyKey - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_hGroupPolicyKey;
}

IGPEInformation * CCertStoreGPE::GetGPEInformation() const
{
    _TRACE (0, L"Entering and leaving CCertStoreGPE::GetGPEInformation - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    return m_pGPEInformation;
}

HRESULT CCertStoreGPE::WriteEFSBlobToRegistry()
{
    _TRACE (1, L"Entering CCertStoreGPE::WriteEFSBlobToRegistry - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    HRESULT hr = S_OK;

    if ( !m_fIsNullEFSPolicy )
    {
        HKEY    hGroupPolicyKey = GetGroupPolicyKey ();
        if ( hGroupPolicyKey )
        {
            DWORD   dwDisposition = 0;
            HKEY    efsBlobKey = 0;
            int         nCertCnt = GetCertCount ();

            LONG lResult = ::RegCreateKeyEx (hGroupPolicyKey, // handle of an open key
                    CERT_EFSBLOB_REGPATH,     // address of subkey name
                    0,       // reserved
                    L"",       // address of class string
                    REG_OPTION_NON_VOLATILE,      // special options flag
                    KEY_ALL_ACCESS,    // desired security access
                    NULL,         // address of key security structure
                    &efsBlobKey,      // address of buffer for opened handle
                    &dwDisposition);  // address of disposition value buffer
            ASSERT (lResult == ERROR_SUCCESS);
            if ( lResult == ERROR_SUCCESS )
            {
                PEFS_PUBLIC_KEY_INFO*   pEFSPKI = new PEFS_PUBLIC_KEY_INFO[nCertCnt];
                DWORD*                  cbPKI = new DWORD[nCertCnt];
                PRECOVERY_KEY_1_1*      pRecoveryKey = new PRECOVERY_KEY_1_1[nCertCnt];
                DWORD*                  cbRecoveryKey = new DWORD[nCertCnt];
                PRECOVERY_POLICY_1_1    pRecoveryPolicy = 0;
                DWORD                   cbRecoveryPolicy = 0;
                BYTE*                   pData = 0;
                DWORD                   cbData = 0;
                int                     nActualCertCnt = 0;
                PCCERT_CONTEXT          pCertContext = 0;

                if ( !pEFSPKI || ! cbPKI || ! pRecoveryKey || !cbRecoveryKey )
                {
                    VERIFY (ERROR_SUCCESS == ::RegCloseKey (efsBlobKey));
                    hr = E_OUTOFMEMORY;
                }

                ::ZeroMemory (pEFSPKI, nCertCnt*sizeof (PEFS_PUBLIC_KEY_INFO));
                ::ZeroMemory (cbPKI, nCertCnt*sizeof (DWORD));
                ::ZeroMemory (pRecoveryKey, nCertCnt*sizeof (PRECOVERY_KEY_1_1));
                ::ZeroMemory (cbRecoveryKey, nCertCnt*sizeof (DWORD));

                while ( 1 )
                {
                    // Subsequent calls to CertEnumCertificatesInStore () free pCertContext.  If
                    // we must break prematurely out of this loop, we must CertFreeCertificateContext ()
                    // explicitly on the last pCertContext
                    pCertContext = EnumCertificates (pCertContext);
                    if ( pCertContext )
                    {
                        hr = CreatePublicKeyInformationCertificate (
                                GetPSIDFromCert (pCertContext),
                                pCertContext->pbCertEncoded,
                                pCertContext->cbCertEncoded,
                                &pEFSPKI[nActualCertCnt],
                                &cbPKI[nActualCertCnt]);
                        if ( SUCCEEDED (hr) )
                        {
                            cbRecoveryKey[nActualCertCnt] = sizeof (ULONG) + cbPKI[nActualCertCnt];
                            pRecoveryKey[nActualCertCnt] = (PRECOVERY_KEY_1_1) ::LocalAlloc (LPTR, cbRecoveryKey[nActualCertCnt]);
                            if ( pRecoveryKey[nActualCertCnt] )
                            {
                                pRecoveryKey[nActualCertCnt]->TotalLength = cbRecoveryKey[nActualCertCnt];
                                memcpy (&(pRecoveryKey[nActualCertCnt]->PublicKeyInfo),
                                        pEFSPKI[nActualCertCnt],
                                        cbPKI[nActualCertCnt]);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                                ::CertFreeCertificateContext (pCertContext);
                                break;
                            }
                        }
                        nActualCertCnt++;
                        if ( nActualCertCnt > nCertCnt )
                        {
                            ASSERT (0);
                            ::CertFreeCertificateContext (pCertContext);
                            break;
                        }
                    }
                    else
                        break;
                }
                Close ();
                ASSERT (nActualCertCnt == nCertCnt);
                if ( SUCCEEDED (hr) )
                {

                    cbRecoveryPolicy = sizeof (RECOVERY_POLICY_HEADER);
                    for (int nIndex = 0; nIndex < nActualCertCnt; nIndex++)
                        cbRecoveryPolicy += cbRecoveryKey[nIndex];
                    pRecoveryPolicy = (PRECOVERY_POLICY_1_1) ::LocalAlloc (LPTR, cbRecoveryPolicy);
                    if ( pRecoveryPolicy )
                    {
                        pRecoveryPolicy->RecoveryPolicyHeader.MajorRevision = EFS_RECOVERY_POLICY_MAJOR_REVISION_1;
                        pRecoveryPolicy->RecoveryPolicyHeader.MinorRevision = EFS_RECOVERY_POLICY_MINOR_REVISION_1;
                        pRecoveryPolicy->RecoveryPolicyHeader.RecoveryKeyCount = nActualCertCnt;

                        // Build array of variable size recovery keys.
                        BYTE* ptr = (BYTE*) pRecoveryPolicy->RecoveryKeyList;
                        for (int nIndex = 0; nIndex < nActualCertCnt; nIndex++)
                        {
                            memcpy (ptr, pRecoveryKey[nIndex], cbRecoveryKey[nIndex]);
                            ptr += cbRecoveryKey[nIndex];
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if ( pRecoveryPolicy )  // otherwise, the value is set to 0
                    {
                        pData = (BYTE*) pRecoveryPolicy;
                        cbData = cbRecoveryPolicy;
                    }
                    lResult =  RegSetValueEx (efsBlobKey,       // handle of key to set value for
                            CERT_EFSBLOB_VALUE_NAME, // address of value to set
                            0,              // reserved
                            REG_BINARY, // flag for value type
                            pData,      // address of value data
                            cbData);    // size of value data
                    if ( lResult == ERROR_SUCCESS )
                    {
                        m_bDirty = true;
                    }
                    else
                        DisplaySystemError (NULL, lResult);
                }
                VERIFY (ERROR_SUCCESS == ::RegCloseKey (efsBlobKey));
                efsBlobKey = 0;

                // Free all the allocated pointers in the arrays.
                for (int nIndex = 0; nIndex < nActualCertCnt; nIndex++)
                {
                    if ( pEFSPKI[nIndex] )
                        ::LocalFree (pEFSPKI[nIndex]);
                    if ( pRecoveryKey[nIndex] )
                        ::LocalFree (pRecoveryKey[nIndex]);
                }

                // Free the allocated arrays
                if ( pEFSPKI )
                    delete [] pEFSPKI;
                if ( cbPKI )
                    delete [] cbPKI;
                if ( cbRecoveryKey )
                    delete [] cbRecoveryKey;
                if ( pRecoveryKey )
                    delete [] pRecoveryKey;

                if ( pRecoveryPolicy )
                    ::LocalFree (pRecoveryPolicy);
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (lResult);
                DisplaySystemError (NULL, lResult);
            }
            if ( SUCCEEDED (hr) )
                m_bDirty = true;
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::WriteEFSBlobToRegistry - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}


#define POINTER_TO_OFFSET( Pointer, Base ) (((PUCHAR)(Pointer)) - ((PUCHAR)(Base)))

HRESULT CCertStoreGPE::CreatePublicKeyInformationCertificate(
    IN PSID  pUserSid OPTIONAL,
    PBYTE pbCert,
    DWORD cbCert,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation,
    DWORD*  pcbPublicKeyInfo)
{
    _TRACE (1, L"Entering CCertStoreGPE::CreatePublicKeyInformationCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    ASSERT (PublicKeyInformation && pcbPublicKeyInfo);
    if ( !PublicKeyInformation || !pcbPublicKeyInfo )
        return E_POINTER;

    DWORD       PublicKeyInformationLength = 0;
    DWORD       UserSidLength = 0;
    PWCHAR      Base = 0;

    if (pUserSid != NULL)
    {
        UserSidLength = GetLengthSid( pUserSid );
    }

    PublicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + UserSidLength + cbCert;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO) ::LocalAlloc (LPTR, PublicKeyInformationLength);

    if ( !(*PublicKeyInformation) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    (*PublicKeyInformation)->Length = PublicKeyInformationLength;
    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificate;

    //
    // Copy the string and SID data to the end of the structure.
    //

    Base = (PWCHAR)(*PublicKeyInformation);
    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_PUBLIC_KEY_INFO ));

    if (pUserSid != NULL)
    {
        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );
        CopySid( UserSidLength, (PSID)Base, pUserSid );
    }
    else
    {
        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)NULL;
    }

    Base = (PWCHAR)((PBYTE)Base + UserSidLength);

    (*PublicKeyInformation)->CertificateInfo.CertificateLength = cbCert;
    (*PublicKeyInformation)->CertificateInfo.Certificate = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );

    memcpy( (PBYTE)Base, pbCert, cbCert );
    *pcbPublicKeyInfo = PublicKeyInformationLength;

    _TRACE (-1, L"Leaving CCertStoreGPE::CreatePublicKeyInformationCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return 0;
}

void CCertStoreGPE::AddCertToList(PCCERT_CONTEXT pCertContext, PSID userPSID)
{
    _TRACE (1, L"Entering CCertStoreGPE::AddCertToList - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    if ( pCertContext && userPSID )
    {
		CERT_CONTEXT_PSID_STRUCT* pCert = new CERT_CONTEXT_PSID_STRUCT (
				pCertContext, userPSID);
		if ( pCert )
		{
            m_EFSCertList.AddTail (pCert);
            m_bDirty = true;
		}
    }
    _TRACE (-1, L"Leaving CCertStoreGPE::AddCertToList - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

PSID CCertStoreGPE::GetPSIDFromCert (PCCERT_CONTEXT pCertContext)
{
    _TRACE (1, L"Entering CCertStoreGPE::GetPSIDFromCert - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    PSID            pSID = 0;
    CERT_CONTEXT_PSID_STRUCT*   pCert = 0;
    POSITION        curPos = 0;

    for (POSITION nextPos = m_EFSCertList.GetHeadPosition (); nextPos; )
    {
        curPos = nextPos;
        pCert = m_EFSCertList.GetNext (nextPos);
        if ( CertCompareCertificate (
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                pCert->m_pCertContext->pCertInfo,
                pCertContext->pCertInfo) )
        {
            pSID = pCert->m_psid;
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::GetPSIDFromCert - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pSID;
}


void CCertStoreGPE::FinalCommit()
{
    _TRACE (1, L"Entering CCertStoreGPE::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    // Called only from destructor
    // Cannot commit here for GPT: GPT has already freed all pertinent data
    _TRACE (-1, L"Leaving CCertStoreGPE::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
}


bool CCertStoreGPE::IsNullEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreGPE::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    GetStoreHandle (); // to initialize
    Close ();
    _TRACE (-1, L"Leaving CCertStoreGPE::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_fIsNullEFSPolicy;
}

void CCertStoreGPE::AllowEmptyEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreGPE::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    m_fIsNullEFSPolicy = false;
    _TRACE (-1, L"Leaving CCertStoreGPE::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HRESULT CCertStoreGPE::AddCertificateContext(PCCERT_CONTEXT pContext, LPCONSOLE pConsole, bool bDeletePrivateKey)
{
    _TRACE (1, L"Entering CCertStoreGPE::AddCertificateContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    HRESULT hr = S_OK;
    AllowEmptyEFSPolicy ();
    hr = CCertStore::AddCertificateContext (pContext, pConsole, bDeletePrivateKey);

    _TRACE (-1, L"Leaving CCertStoreGPE::AddCertificateContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

HRESULT CCertStoreGPE::DeleteEFSPolicy(bool bCommitChanges)
{
    _TRACE (1, L"Entering CCertStoreGPE::DeleteEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (EFS_STORE == GetStoreType ());
    if ( EFS_STORE == GetStoreType () )
    {
        // If the store is open, close it first
        if ( m_hCertStore )
        {
            CERT_CONTEXT_PSID_STRUCT* pCert = 0;
            while (!m_EFSCertList.IsEmpty () )
            {
                pCert = m_EFSCertList.RemoveHead ();
                ASSERT (pCert);
                if ( pCert )
                    delete pCert;
            }

            VERIFY (::CertCloseStore (m_hCertStore, CERT_CLOSE_STORE_FORCE_FLAG)); //CERT_CLOSE_STORE_CHECK_FLAG);
            m_hCertStore = 0;
        }

        LRESULT lResult = ::RegDelnode (GetGroupPolicyKey (), CERT_EFSBLOB_REGPATH);
        if ( ERROR_SUCCESS == lResult )
        {
            m_fIsNullEFSPolicy = true;
            m_bDirty = true;

            if ( bCommitChanges )
                Commit ();
        }
        else
            DisplaySystemError (NULL, (DWORD)lResult);
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::DeleteEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return S_OK;
}


HRESULT CCertStoreGPE::PolicyChanged()
{
    _TRACE (1, L"Entering CCertStoreGPE::PolicyChanged - %s\n",
            (LPCWSTR) m_pcszStoreName);
    HRESULT hr = E_FAIL;

    if ( m_pGPEInformation )
    {
        hr = m_pGPEInformation->PolicyChanged (
                m_fIsComputerType ? TRUE : FALSE,
                TRUE, &g_guidExtension, &g_guidSnapin);
        hr = m_pGPEInformation->PolicyChanged (
                m_fIsComputerType ? TRUE : FALSE,
                TRUE, &g_guidRegExt, &g_guidSnapin);
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::PolicyChanged - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

PCCERT_CONTEXT CCertStoreGPE::EnumCertificates (PCCERT_CONTEXT pPrevCertContext)
{
    PCCERT_CONTEXT pCertContext = CCertStore::EnumCertificates (pPrevCertContext);

    if ( pCertContext )
        m_fIsNullEFSPolicy = false;

    return pCertContext;
}

CERT_CONTEXT_PSID_STRUCT::CERT_CONTEXT_PSID_STRUCT (PCCERT_CONTEXT pCertContext, PSID psid) :
    m_pCertContext (0),
    m_psid (0)
{
    if ( pCertContext && psid )
	{
        m_pCertContext = CertDuplicateCertificateContext (pCertContext);
        DWORD	dwSidSize = ::GetLengthSid (psid);
        if (  dwSidSize > 0 )
		{
            m_psid = new BYTE[dwSidSize];
            if ( m_psid )
			{
				::ZeroMemory (m_psid, dwSidSize);
				if ( !::CopySid (dwSidSize, m_psid, psid) )
				{
					ASSERT (0);
					delete [] m_psid;
					m_psid = 0;
				}
			}
		}
    } 
}

CERT_CONTEXT_PSID_STRUCT::~CERT_CONTEXT_PSID_STRUCT ()
{
	if ( m_pCertContext )
		::CertFreeCertificateContext (m_pCertContext);
	if ( m_psid )
		delete [] m_psid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once 
#endif // _MSC_VER >= 1000

#define STRICT

#pragma warning(push,3)

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage
#include <afxcmn.h>     // CSpinButtonCtrl
#include <afxext.h>
#include <afxmt.h>

//#define _WIN32_WINNT 0x0500
#define _ATL_APARTMENT_THREADED

#include <mmc.h>
#include "certmgr.h"

EXTERN_C const CLSID CLSID_CertificateManager;
EXTERN_C const CLSID CLSID_CertificateManagerPKPOLExt;
EXTERN_C const CLSID CLSID_SaferWindowsExtension;


#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlapp.h>
#include <atlwin.h>

#include <atlctrls.h>
#include <lmcons.h>

#include "stdcooki.h" // from ..\framewrk
#include "stdcmpnt.h" // from ..\framewrk
#include "stdcdata.h" // from ..\framewrk
#include "persist.h" // PersistStream   from ..\framewrk
#include "stdutils.h" // GetObjectType() utility routines from ..\corecopy
#include "stddtobj.h" // class DataObject   from ..\framewrk
#include "stdabout.h" // from ..\framewrk


#include "chooser.h" //                 from ..\chooser
#include "regkey.h" // AMC::CRegKey     from ..\corecopy
#include "safetemp.h"   // from ..\corecopy
#include "macros.h"
#include "guidhelp.h" // GuidToCString

#include <comstrm.h>

#include <strings.h>
#include <dsrole.h>
#include <lmapibuf.h>

#include <prsht.h>
#include <shlobj.h>
#include <dsclient.h>
#include <objsel.h>

#include <CertCA.h>
#include <wincrypt.h>

// For theming
#include <shfusion.h>

#include "dbg.h"

#pragma warning(pop)


#include "DisabledWarnings.h"
#include "helpids.h"
#include "CMUtils.h"
#include "debug.h"
#include "resource.h"
#include "HelpPropertyPage.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\storersop.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       StoreRSOP.h
//
//  Contents:   CertStoreRSOP class definition
//
//----------------------------------------------------------------------------

#ifndef __STORERSOP_H_INCLUDED__
#define __STORERSOP_H_INCLUDED__

#pragma warning(push, 3)
#include <wbemcli.h>
#pragma warning(pop)
#include "cookie.h"
#include "RSOPObject.h"

class CCertStoreRSOP : public CCertStore
{
public:
    virtual PCCERT_CONTEXT EnumCertificates (PCCERT_CONTEXT pPrevCertContext);
    virtual HRESULT Commit () { return S_OK; }
    virtual bool IsReadOnly () { return true; }
	void AllowEmptyEFSPolicy();
	virtual bool IsNullEFSPolicy();
    virtual bool IsMachineStore();
	virtual bool CanContain (CertificateManagerObjectType nodeType);
	virtual HCERTSTORE	GetStoreHandle (BOOL bSilent = FALSE, HRESULT* phr = 0);
	CCertStoreRSOP ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			CRSOPObjectArray& rsopObjectArray,
			const GUID& compDataGUID,
			IConsole* pConsole);

	virtual ~CCertStoreRSOP ();

protected:
    HRESULT GetBlobs ();
	virtual void FinalCommit();
	bool	m_fIsComputerType;

private:
	bool				m_fIsNullEFSPolicy;
    CRSOPObjectArray    m_rsopObjectArray;
};


#endif // ~__STORERSOP_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\storersop.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       StoreRSOP.cpp
//
//  Contents:   Implementation of CCertStoreRSOP
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "cookie.h"
#include "StoreRSOP.h"
#include "certifct.h"

USE_HANDLE_MACROS("CERTMGR(StoreRSOP.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CCertStoreRSOP::CCertStoreRSOP (
            DWORD dwFlags,
            LPCWSTR lpcszMachineName,
            LPCWSTR objectName,
            const CString & pcszLogStoreName,
            const CString & pcszPhysStoreName,
            CRSOPObjectArray& rsopObjectArray,
            const GUID& compDataGUID,
            IConsole* pConsole)
    : CCertStore (CERTMGR_LOG_STORE_RSOP,
        CERT_STORE_PROV_SYSTEM, dwFlags, lpcszMachineName, objectName,
        pcszLogStoreName, pcszPhysStoreName,
        StoreNameToType (pcszLogStoreName),        
        0,
        pConsole),
    m_fIsComputerType (false),
    m_fIsNullEFSPolicy (true)       // assume NULL policy until proven otherwise
{
    _TRACE (1, L"Entering CCertStoreRSOP::CCertStoreRSOP - %s\n",
            (LPCWSTR) pcszLogStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    if ( ::IsEqualGUID (compDataGUID, NODEID_User) )
    {
        m_fIsComputerType = false;
        m_dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;
    }
    else if ( ::IsEqualGUID (compDataGUID, NODEID_Machine) )
    {
        m_fIsComputerType = true;
        m_dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;
    }
    else
        ASSERT (0);

    int     nIndex = 0;
    INT_PTR nUpperBound = rsopObjectArray.GetUpperBound ();
    bool    bFound = false;
	CString storePath = CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH;
    storePath += L"\\";
    storePath += m_pcszStoreName;
    size_t nStoreLen = storePath.GetLength ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            // Only add if
            // 1. Precedence is 1
            // 2. The object belongs to this store
            // 3. The valueName is not empty
            if ( 1 == pObject->GetPrecedence () )
            {
                // Consider only entries from this store
                if ( !wcsncmp (storePath, pObject->GetRegistryKey (), nStoreLen) )
                {
                    bFound = true;
                    if ( !pObject->GetValueName ().IsEmpty () )
                    {
                        CRSOPObject* pNewObject = new CRSOPObject (*pObject);
                        if ( pNewObject )
                            m_rsopObjectArray.Add (pNewObject);
                    }
                }
                else if ( bFound )
                {
                    // Since the list is sorted, and we've already found the 
                    // desired RSOP objects and no longer are finding them, 
                    // there aren't any more.  We can optimize and break here.
                    break;
                }
            }
        }
        else
            break;

        nIndex++;
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::CCertStoreRSOP - %s\n",
            (LPCWSTR) pcszLogStoreName);
}


CCertStoreRSOP::~CCertStoreRSOP ()
{
    _TRACE (1, L"Entering CCertStoreRSOP::~CCertStoreRSOP - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    INT_PTR     nUpperBound = m_rsopObjectArray.GetUpperBound ();
    int         nIndex = 0;

    while (nUpperBound >= nIndex)
    {
        CRSOPObject*    pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            delete pObject;
        }
        else
            break;

        nIndex++;
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::~CCertStoreRSOP - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HCERTSTORE CCertStoreRSOP::GetStoreHandle (BOOL bSilent /*= FALSE*/, HRESULT* phr /* = 0*/)
{
    _TRACE (1, L"Entering CCertStoreRSOP::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);

    if ( !m_hCertStore )
    {
        DWORD   dwErr = 0;

		//open a generic memory store
		m_hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
				 0, NULL,
				 CERT_STORE_SET_LOCALIZED_NAME_FLAG | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
				 NULL);
		if ( m_hCertStore )
		{
            // Certificates, CTLs and other objects are either stored integrally in a
            // value called "Blob" or broken up into multiple parts. In this case, we'll 
            // first see "BlobCount", which tells us how many parts there are, then 
            // "BlobLength" which tells us the total byte length and finally
            // "Blob0", "Blob1", etc. to "Blob<BlobCount-1>"
            // Check for Certificates
            GetBlobs ();
        }
        else
        {
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"CertOpenStore (CERT_STORE_PROV_MEMORY) failed: 0x%x\n", dwErr);
        }

        if ( !m_hCertStore && !m_bUnableToOpenMsgDisplayed 
                && !bSilent && 
                (USERDS_STORE != GetStoreType ()) )
        {
            m_bUnableToOpenMsgDisplayed = true;
            CString caption;
            CString text;
            int         iRetVal = 0;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_UNABLE_TO_OPEN_STORE, GetStoreName (), 
                    GetSystemMessage (dwErr));
            if ( m_pConsole )
                m_pConsole->MessageBox (text, caption, MB_OK, &iRetVal);
        }
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);

    return m_hCertStore;
}


HRESULT CCertStoreRSOP::GetBlobs ()
{ 
    HRESULT     hr = S_OK;
    INT_PTR     nUpperBound = m_rsopObjectArray.GetUpperBound ();
    int         nIndex = 0;

    while (nUpperBound >= nIndex)
    {
        CRSOPObject*    pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            if ( STR_BLOB == pObject->GetValueName () )
            {
                // If this is a single, serialized cert, get it and
                // add it to the store
                BYTE*   pByte = pObject->GetBlob ();
                ASSERT (pByte);
                if ( pByte )
                {
				    if ( !CertAddSerializedElementToStore (
						    m_hCertStore,
						    pByte,
						    (DWORD) pObject->GetBlobLength (),
						    CERT_STORE_ADD_ALWAYS,
						    0,
						    CERT_STORE_ALL_CONTEXT_FLAG,
						    NULL,
						    NULL) )
                    {
                        _TRACE (0, L"CertAddSerializedElementToStore () failed: 0x%x\n",
                                GetLastError ());
                    }
                }
            }
            else if ( STR_BLOBCOUNT == pObject->GetValueName () )
            {
                CString szBaseRegKey = pObject->GetRegistryKey ();
                DWORD   dwBlobCount = pObject->GetDWORDValue ();
                if ( dwBlobCount > 0 )
                {
                    nIndex++;
                    if (nUpperBound >= nIndex)
                    {
                        // Get the blob length
                        pObject = m_rsopObjectArray.GetAt (nIndex);
                        if ( pObject )
                        {
                            if ( STR_BLOBLENGTH == pObject->GetValueName () )
                            {
                                DWORD dwBlobLength = pObject->GetDWORDValue ();
                                if ( dwBlobLength )
                                {
                                    BYTE* pbyLob = new BYTE[dwBlobLength];
                                    if ( pbyLob )
                                    {
                                        size_t  nTotalBlobLength = 0;
                                        BYTE*   pbyLobPtr = pbyLob;
                                        for (DWORD dwBlob = 0; dwBlob < dwBlobCount; dwBlob++)
                                        {
                                            nIndex++;
                                            if ( nUpperBound >= nIndex )
                                            {
                                                WCHAR   szName[16];
                                                wsprintf (szName, L"%s%d", STR_BLOB, dwBlob);
                                                CString szRegKey = szBaseRegKey;
                                                szRegKey += L"\\";
                                                szRegKey += szName;

                                                pObject = m_rsopObjectArray.GetAt (nIndex);
                                                if ( pObject )
                                                {
                                                    if ( szRegKey == pObject->GetRegistryKey () &&
                                                            STR_BLOB == pObject->GetValueName () )
                                                    {
                                                        BYTE* pByte = pObject->GetBlob ();
                                                        if ( pByte )
                                                        {
                                                            memcpy (pbyLobPtr, pByte, pObject->GetBlobLength ());
                                                            pbyLobPtr += pObject->GetBlobLength ();
                                                            nTotalBlobLength += pObject->GetBlobLength ();
                                                        }
                                                        else
                                                        {
                                                            ASSERT (0);
                                                            hr = E_UNEXPECTED;
                                                            break;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        ASSERT (0);
                                                        hr = E_UNEXPECTED;
                                                        break;
                                                    }
                                                }
                                                else
                                                {
                                                    ASSERT (0);
                                                    hr = E_UNEXPECTED;
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                ASSERT (0);
                                                hr = E_UNEXPECTED;
                                                break;
                                            }
                                        }

                                        if ( SUCCEEDED (hr) && nTotalBlobLength == (size_t) dwBlobLength )
                                        {
 						                    if ( !CertAddSerializedElementToStore (
								                    m_hCertStore,
								                    pbyLob,
								                    dwBlobLength,
								                    CERT_STORE_ADD_ALWAYS,
								                    0,
								                    CERT_STORE_ALL_CONTEXT_FLAG,
								                    NULL,
								                    NULL) )
                                            {
                                                _TRACE (0, L"CertAddSerializedElementToStore () failed: 0x%x\n",
                                                        GetLastError ());
                                            }
                                        }

                                        delete [] pbyLob;
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    }
                                }
                                else
                                {
                                    ASSERT (0);
                                    hr = E_UNEXPECTED;
                                    break;
                                }
                            }
                            else
                            {
                                ASSERT (0);
                                hr = E_UNEXPECTED;
                                break;
                            }
                        }
                        else
                        {
                            ASSERT (0);
                            hr = E_UNEXPECTED;
                            break;
                        }
                    }
                    else
                    {
                        ASSERT (0);
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
            }
        }
        else
            break;

        nIndex++;
    }

    return hr;
}

bool CCertStoreRSOP::CanContain(CertificateManagerObjectType nodeType)
{
    _TRACE (1, L"Entering CCertStoreRSOP::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    bool    bCanContain = false;

    switch (nodeType)
    {
    case CERTMGR_CERTIFICATE:
        if ( ROOT_STORE == GetStoreType () ||
                EFS_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    case CERTMGR_CTL:
        if ( TRUST_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bCanContain;
}


bool CCertStoreRSOP::IsMachineStore()
{
    _TRACE (0, L"Entering and leaving CCertStoreRSOP::IsMachineStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);

    if (m_dwFlags & CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY)
        return true;
    else
        return false;
}


void CCertStoreRSOP::FinalCommit()
{
    _TRACE (1, L"Entering CCertStoreRSOP::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    // Called only from destructor
    // Cannot commit here for GPT: GPT has already freed all pertinent data
    _TRACE (-1, L"Leaving CCertStoreRSOP::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
}


bool CCertStoreRSOP::IsNullEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreRSOP::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    GetStoreHandle (); // to initialize
    Close ();
    _TRACE (-1, L"Leaving CCertStoreRSOP::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_fIsNullEFSPolicy;
}

void CCertStoreRSOP::AllowEmptyEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreRSOP::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    m_fIsNullEFSPolicy = false;
    _TRACE (-1, L"Leaving CCertStoreRSOP::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

PCCERT_CONTEXT CCertStoreRSOP::EnumCertificates (PCCERT_CONTEXT pPrevCertContext)
{
    PCCERT_CONTEXT pCertContext = CCertStore::EnumCertificates (pPrevCertContext);

    if ( pCertContext )
        m_fIsNullEFSPolicy = false;

    return pCertContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\users.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Users.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Users.cpp: implementation of the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Users.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUsers::CUsers()
{
    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;
}

//////////////////////////////////////////////////////////////////////
// Walk through the chain to free the memory
//////////////////////////////////////////////////////////////////////

CUsers::~CUsers()
{
    Clear();
}

PUSERSONFILE
CUsers::RemoveItemFromHead(void)
{
    PUSERSONFILE PItem = m_UsersRoot;
    if (m_UsersRoot){
        m_UsersRoot = m_UsersRoot->m_pNext;
        if ((PItem->m_dwFlag & USERADDED) && !(PItem->m_dwFlag & USERREMOVED)){
            m_UserAddedCnt--;
        }
        if ((PItem->m_dwFlag & USERINFILE) && (PItem->m_dwFlag & USERREMOVED)){
            m_UserRemovedCnt--;
        }
    }
    return PItem;
}

DWORD
CUsers::Add( CUsers &NewUsers )
{
    PUSERSONFILE NewItem = NewUsers.RemoveItemFromHead();

    while ( NewItem )
	{
        PUSERSONFILE    TmpItem = m_UsersRoot;
        
        while ( TmpItem )
		{

            if ((NewItem->m_szUserName && TmpItem->m_szUserName && !_tcsicmp(NewItem->m_szUserName, TmpItem->m_szUserName)) ||
                 ( !NewItem->m_szUserName && !TmpItem->m_szUserName))
			{
                if ( !TmpItem->m_szUserName)
				{
					bool   bUserMatched = false;

                    if (( !NewItem->m_szDnName && !TmpItem->m_szDnName) ||
                          (NewItem->m_szDnName && TmpItem->m_szDnName && !_tcsicmp(NewItem->m_szDnName, TmpItem->m_szDnName)))
					{
						bUserMatched = true;
                    }

                    if ( !bUserMatched )
					{
                        TmpItem = TmpItem->m_pNext;
                        continue;
                    }
                }

                //
                // User exist
                //

                if ( TmpItem->m_dwFlag & USERREMOVED )
				{
                    if ( TmpItem->m_dwFlag & USERADDED )
					{
                        ASSERT(!(TmpItem->m_dwFlag & USERINFILE));

                        //
                        //    User added and removed
                        //
                        m_UserAddedCnt++;

                    } 
					else if ( TmpItem->m_dwFlag & USERINFILE )
					{
                        //
                        //    User added and removed
                        //
                        m_UserRemovedCnt--;

                    }
                    TmpItem->m_dwFlag &= ~USERREMOVED;
                }

                //
                // The caller will count on CUsers to release the memory
                //

                if (NewItem->m_szUserName)
				{
                    delete [] NewItem->m_szUserName;
                }
                if (NewItem->m_szDnName)
				{
                    delete [] NewItem->m_szDnName;
                }
                if ( NewItem->m_pCertContext ) 
				{
                    CertFreeCertificateContext(NewItem->m_pCertContext);
                }
                delete [] NewItem->m_pCert;
                if (NewItem->m_UserSid)
				{
                    delete [] NewItem->m_UserSid;
                }
                delete NewItem;
                NewItem = NULL;                
                break;
            }
            TmpItem = TmpItem->m_pNext;
        }

        if (NewItem )
		{ 
            //
            // New item. Insert into the head.
            //

            NewItem->m_pNext = m_UsersRoot;
            m_UsersRoot = NewItem;
            m_UserAddedCnt++;
        }

        NewItem = NewUsers.RemoveItemFromHead();
    }

    return ERROR_SUCCESS;
}

DWORD
CUsers::Add(
    LPWSTR pszUserName,
    LPWSTR pszDnName, 
    PVOID UserCert, 
    PSID UserSid, /* = NULL */
    DWORD dwFlag, /* = USERINFILE */
    PCCERT_CONTEXT pCertContext /* = NULL */
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Create an item for a user
// Arguments:
//      m_szUserName -- User's name
//      m_szDnName -- User's distinguished name
//      UserCert -- User's certificate blob or hash
//      m_UserSid -- User's ID. Can be NULL
//      m_dwFlag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      NO_ERROR if succeed.
//      Will throw exception if memory allocation fails. ( From new.)
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE UserItem = 0;
    PUSERSONFILE TmpUserItem = m_UsersRoot;
    PEFS_CERTIFICATE_BLOB CertBlob;
    PEFS_HASH_BLOB  CertHashBlob;
    DWORD   CertSize;
    DWORD   SidSize;

    if ( !UserCert )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT ( (( dwFlag & USERADDED ) || ( dwFlag & USERINFILE )) &&
                       ( (dwFlag & (USERADDED | USERINFILE)) != (USERADDED | USERINFILE)));


    //
    // If the user already in the memory, no new item is to be created except for unknown user
    //

    while ( TmpUserItem )
	{
        if ( (pszUserName && TmpUserItem->m_szUserName && !_tcsicmp(pszUserName, TmpUserItem->m_szUserName)) ||
              ((!pszUserName) && (TmpUserItem->m_szUserName == NULL)))
		{
            if (!pszUserName)
			{
				bool   bUserMatched = false;

                if (( !pszDnName &&  !TmpUserItem->m_szDnName) ||
                     (pszDnName && TmpUserItem->m_szDnName && !_tcsicmp(pszDnName, TmpUserItem->m_szDnName)))
				{
                    bUserMatched = true;
                }

                if ( !bUserMatched )
				{
                    TmpUserItem = TmpUserItem->m_pNext;
                    continue;
                }
            }

            //
            // User exist
            //

            if ( TmpUserItem->m_dwFlag & USERREMOVED )
			{
                if ( TmpUserItem->m_dwFlag & USERADDED )
				{
                    ASSERT(!(TmpUserItem->m_dwFlag & USERINFILE));

                    //
                    //    User added and removed
                    //
                    m_UserAddedCnt++;

                } 
				else if ( TmpUserItem->m_dwFlag & USERINFILE )
				{
                    //
                    //    User added and removed
                    //
                    m_UserRemovedCnt--;

                }
                TmpUserItem->m_dwFlag &= ~USERREMOVED;
            }

            //
            // The caller will count on CUsers to release the memory
            // for Username and the context if the call is succeeded. This is just for
            // performance reason.
            //

            if (pszUserName)
			{
                delete [] pszUserName;
            }
            if (pszDnName)
			{
                delete [] pszDnName;
            }
            if ( pCertContext ) 
			{
                ::CertFreeCertificateContext (pCertContext);
                pCertContext = NULL;
            }
            return (DWORD) CRYPT_E_EXISTS;
        }
        TmpUserItem = TmpUserItem->m_pNext;
    }
    
    try {
        UserItem = new USERSONFILE;
        if ( !UserItem )
		{
            AfxThrowMemoryException( );
        }

        UserItem->m_pNext = NULL;

        //
        // In case exception raised, we can call delete.
        // Delete NULL is OK, but random data is not OK.
        //

        UserItem->m_UserSid = NULL;
        UserItem->m_pCert = NULL;
        UserItem->m_pCertContext = NULL;

        if ( UserSid )
		{
            SidSize = GetLengthSid (UserSid );
            if (  SidSize > 0 )
			{
                UserItem->m_UserSid = new BYTE[SidSize];
                if ( !UserItem->m_UserSid )
				{
                    AfxThrowMemoryException( );
                }
                if ( !CopySid(SidSize, UserItem->m_UserSid, UserSid))
				{
                    delete [] UserItem->m_UserSid;
                    delete UserItem;
                    return GetLastError();
                }
                
            } 
			else 
			{
                delete UserItem;
                return GetLastError();
            }
        } 
		else 
		{
            UserItem->m_UserSid = NULL;
        }
 
        if ( dwFlag & USERINFILE )
		{

            //
            // The info is from the file. Use the hash structure
            //

            CertHashBlob = ( PEFS_HASH_BLOB ) UserCert;
            CertSize = sizeof(EFS_HASH_BLOB) + CertHashBlob->cbData;
            UserItem->m_pCert = new BYTE[CertSize];
            if ( !UserItem->m_pCert )
			{
                AfxThrowMemoryException( );
            }
            ((PEFS_HASH_BLOB)UserItem->m_pCert)->cbData = CertHashBlob->cbData;
            ((PEFS_HASH_BLOB)UserItem->m_pCert)->pbData = (PBYTE)(UserItem->m_pCert) + sizeof(EFS_HASH_BLOB);
            memcpy(((PEFS_HASH_BLOB)UserItem->m_pCert)->pbData, 
                   CertHashBlob->pbData,
                   CertHashBlob->cbData
                  );
        } 
		else 
		{
            //
            // The info is from the user picked cert. Use m_pCert Blob structure
            //

            CertBlob = ( PEFS_CERTIFICATE_BLOB ) UserCert;
            CertSize = sizeof(EFS_CERTIFICATE_BLOB) + CertBlob->cbData;
            UserItem->m_pCert = new BYTE[CertSize];
            if ( NULL == UserItem->m_pCert ){
                AfxThrowMemoryException( );
            }
            ((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->cbData = CertBlob->cbData;
            ((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->dwCertEncodingType = CertBlob->dwCertEncodingType;
            ((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->pbData = (PBYTE)(UserItem->m_pCert) + sizeof(EFS_CERTIFICATE_BLOB);
            memcpy(((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->pbData, 
                   CertBlob->pbData,
                   CertBlob->cbData
                  );

        }
 
        UserItem->m_szUserName = pszUserName;
        UserItem->m_szDnName = pszDnName;
        UserItem->m_pCertContext = pCertContext;
        UserItem->m_dwFlag = dwFlag;
        if ( dwFlag & USERADDED )
		{
            m_UserAddedCnt ++;
        }
    }
    catch (...) {
        delete [] UserItem->m_UserSid;
        delete [] UserItem->m_pCert;
        delete UserItem;
        AfxThrowMemoryException( );
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    //
    // Add to the head
    //

    if ( m_UsersRoot )
	{
        UserItem->m_pNext = m_UsersRoot;
    }
    m_UsersRoot = UserItem;

    return NO_ERROR;
}

DWORD
CUsers::Remove(
    LPCWSTR m_szUserName,
    LPCWSTR UserCertName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Remove a user from the list. Actually just mark for remove.
// Arguments:
//      m_szUserName -- User's name
//      UserCertName -- User's certificate name
//  Return Value:
//      NO_ERROR if succeed.
//      ERROR_NOT_FOUND if the user cannot be found.
// 
//////////////////////////////////////////////////////////////////////
{
    PUSERSONFILE	TmpUserItem = m_UsersRoot;
    bool			bUserMatched = false;

    while ( TmpUserItem ){
        if (((NULL==m_szUserName) && ( NULL == TmpUserItem->m_szUserName)) || 
            ( m_szUserName && TmpUserItem->m_szUserName && !_tcsicmp(m_szUserName, TmpUserItem->m_szUserName))){

            //
            // Make sure the CertName matches also if the user name is NULL
            //

            if (NULL==m_szUserName) 
			{ 
                 if (((NULL==UserCertName) && ( NULL == TmpUserItem->m_szDnName)) ||
                      (UserCertName && TmpUserItem->m_szDnName && !_tcsicmp(UserCertName, TmpUserItem->m_szDnName))){

                    bUserMatched = true;
                }
            } 
			else 
			{
                bUserMatched = true;
            }

            if (bUserMatched)
			{
                //
                // User exist, mark it for remove
                //

                if ( TmpUserItem->m_dwFlag & USERINFILE ){
                    m_UserRemovedCnt++;
                } else if ( TmpUserItem->m_dwFlag & USERADDED ) {
                    m_UserAddedCnt--;
                }
                TmpUserItem->m_dwFlag |= USERREMOVED;
                return NO_ERROR;
            }
        }
        TmpUserItem = TmpUserItem->m_pNext;
    }
    return ERROR_NOT_FOUND;
}

PUSERSONFILE CUsers::StartEnum()
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Prepare for GetNextUser
// Arguments:
//
//  Return Value:
//      A pointer used for GetNextUser
// 
//////////////////////////////////////////////////////////////////////
{
    return m_UsersRoot;
}

PUSERSONFILE CUsers::GetNextUser(
    PUSERSONFILE Token, 
    CString &szUserName,
    CString &CertName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get next user in the list.(Not removed).
// Arguments:
//      m_szUserName -- m_pNext User's name
//      CertName -- Certificate name
//      Token -- A pointer returned by previous GetNextUser or StartEnum. 
// Return Value:
//      A pointer for GetNextUser()
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE   TmpItem = Token;
    PUSERSONFILE   RetPointer = NULL;

    while ( TmpItem )
	{
        if ( TmpItem->m_dwFlag & USERREMOVED )
		{
            TmpItem = TmpItem->m_pNext;
            continue;
        }

        try{    
            szUserName = TmpItem->m_szUserName;
            CertName = TmpItem->m_szDnName;
            RetPointer = TmpItem->m_pNext;
        }
        catch (...){

            //
            // Out of memory
            //

            TmpItem = NULL;
            RetPointer = NULL;
        }
        break;
    }

    if ( NULL == TmpItem )
	{
        szUserName.Empty();
        CertName.Empty();
    }
    return RetPointer;

}

DWORD CUsers::GetUserAddedCnt()
{
    return m_UserAddedCnt;
}

DWORD CUsers::GetUserRemovedCnt()
{
    return m_UserRemovedCnt;
}

PVOID CUsers::GetNextChangedUser(
    PVOID Token, 
    LPWSTR * m_szUserName,
    LPWSTR * m_szDnName, 
    PSID * m_UserSid, 
    PVOID * CertData, 
    DWORD * m_dwFlag
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the info for changed users. This method is not well behaved in the
//  sense of OOP. It exposes internal pointers to the ouside world. The gain
//  is performance. At this moment, CUsers is a supporting class and used only
//  by USERLIST and CAddEFSWizSheet (single thread). We can make USERLIST a 
//  friend of CUsers if such concerns are raised in the future or reimplement this. 
//  The same issue applies to the enumerate methods.
//
// Arguments:
//      Token -- A pointer to the item returned in previous GetNextChangedUser or StartEnum.
//      m_szUserName -- User's name
//      m_szDnName -- User's Distinguished name
//      CertData -- User's certificate blob or hash
//      m_UserSid -- User's ID. Can be NULL
//      m_dwFlag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      m_pNext item pointer.
// 
//////////////////////////////////////////////////////////////////////
{
    bool    bChangedUserFound = false;

    while ( Token )
	{
        *m_dwFlag = ((PUSERSONFILE) Token)->m_dwFlag;

        if ( ( *m_dwFlag & USERADDED ) && !( *m_dwFlag & USERREMOVED ))
		{
            //
            // The user is to to be added to the file
            //

            *m_dwFlag = USERADDED;
            bChangedUserFound = true;
        } 
		else if ( ( *m_dwFlag & USERREMOVED ) && ( *m_dwFlag & USERINFILE))
		{
            //
            // The user is to be removed from the file
            //

            *m_dwFlag = USERREMOVED;
            bChangedUserFound = true;
        }

        if ( bChangedUserFound )
		{
            *m_szUserName = ((PUSERSONFILE) Token)->m_szUserName;
            *m_szDnName = ((PUSERSONFILE) Token)->m_szDnName;
            *m_UserSid = ((PUSERSONFILE) Token)->m_UserSid;
            *CertData = ((PUSERSONFILE) Token)->m_pCert;
            return ((PUSERSONFILE) Token)->m_pNext;
        } 
		else 
		{
            Token = ((PUSERSONFILE) Token)->m_pNext;
        }

    }

    *m_szUserName = NULL;
    *m_szDnName = NULL;
    *m_UserSid = NULL;
    *CertData = NULL;
    *m_dwFlag = 0;
    return NULL;
}

void CUsers::Clear()
{
    PUSERSONFILE TmpUserItem = m_UsersRoot;
    while (TmpUserItem)
	{
        m_UsersRoot = TmpUserItem->m_pNext;
        delete [] TmpUserItem->m_szUserName;
        delete [] TmpUserItem->m_szDnName;
        delete [] TmpUserItem->m_pCert;
        if (TmpUserItem->m_UserSid)
		{
            delete [] TmpUserItem->m_UserSid;
        }
        if (TmpUserItem->m_pCertContext)
		{
            ::CertFreeCertificateContext(TmpUserItem->m_pCertContext);
        }
        delete TmpUserItem;
        TmpUserItem = m_UsersRoot;
    }

    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\storegpe.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       StoreGPE.h
//
//  Contents:   CertStoreGPE class definition
//
//----------------------------------------------------------------------------

#ifndef __STOREGPE_H_INCLUDED__
#define __STOREGPE_H_INCLUDED__

#include "cookie.h"

class CERT_CONTEXT_PSID_STRUCT
{
public:
    CERT_CONTEXT_PSID_STRUCT (PCCERT_CONTEXT pCertContext, PSID psid);
    ~CERT_CONTEXT_PSID_STRUCT ();
    PCCERT_CONTEXT  m_pCertContext;
    PSID            m_psid;
};

class CCertStoreGPE : public CCertStore
{
public:
    virtual PCCERT_CONTEXT EnumCertificates (PCCERT_CONTEXT pPrevCertContext);
	HRESULT	PolicyChanged ();
	HRESULT DeleteEFSPolicy (bool bCommitChanges);
	virtual HRESULT AddCertificateContext(PCCERT_CONTEXT pContext, LPCONSOLE pConsole, bool bDeletePrivateKey);
	void AllowEmptyEFSPolicy();
	virtual bool IsNullEFSPolicy();
	void AddCertToList (PCCERT_CONTEXT pCertContext, PSID userPSID);
	virtual HKEY GetGroupPolicyKey();
	IGPEInformation* GetGPEInformation() const;
    virtual bool IsMachineStore() ;
	virtual bool CanContain (CertificateManagerObjectType nodeType);
	virtual HCERTSTORE	GetStoreHandle (BOOL bSilent = FALSE, HRESULT* phr = 0);
    virtual HRESULT Commit ();
	CCertStoreGPE ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			IGPEInformation * pGPTInformation,
			const GUID& compDataGUID,
			IConsole* pConsole);

	virtual ~CCertStoreGPE ();

private:
	bool				m_fIsNullEFSPolicy;
	IGPEInformation *	m_pGPEInformation;
	CTypedPtrList<CPtrList, CERT_CONTEXT_PSID_STRUCT*>	m_EFSCertList; 
    HKEY                m_hGroupPolicyKey;

protected:
	virtual void FinalCommit();
	PSID GetPSIDFromCert (PCCERT_CONTEXT pCertContext);
	HRESULT WriteEFSBlobToRegistry();
	HRESULT CreatePublicKeyInformationCertificate(
		IN PSID  pUserSid OPTIONAL,
		PBYTE pbCert,
		DWORD cbCert,
		OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation,
		DWORD*	pcbPublicKeyInfo);
	bool	m_fIsComputerType;
};

class CEnrollmentNodeCookie : public CCertMgrCookie
{
public:
	CEnrollmentNodeCookie (
			CertificateManagerObjectType	objecttype, 
			LPCWSTR							objectName,
			IGPEInformation*				pGPEInformation);
	virtual ~CEnrollmentNodeCookie ();

	IGPEInformation*	GetGPEInformation ();

private:
	IGPEInformation*	m_pGPEInformation;
};


#endif // ~__STOREGPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\users.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       users.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Users.h: interface for the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
#define AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#pragma warning(push, 3)
#include <winefs.h>
#pragma warning(pop)

#define USERINFILE  1
#define USERADDED   2
#define USERREMOVED 4

typedef struct USERSONFILE {
    USERSONFILE *       m_pNext;
    DWORD               m_dwFlag; // If the item is added, removed or existed in the file
    PVOID               m_pCert; // Either the hash or the Blob
    PCCERT_CONTEXT      m_pCertContext; // Cert Context. To be released when the item is deleted.
    LPWSTR              m_szUserName;
    LPWSTR				m_szDnName;
    PSID                m_UserSid;
} USERSONFILE, *PUSERSONFILE;

//
// This class supports single thread only.
//

class CUsers  
{
public:
	CUsers();
	virtual ~CUsers();

public:
	void Clear(void);
	DWORD GetUserRemovedCnt();

	DWORD GetUserAddedCnt();

    DWORD   Add(
                LPWSTR UserName,
                LPWSTR DnName, 
                PVOID UserCert, 
                PSID UserSid = NULL, 
                DWORD Flag = USERINFILE,
                PCCERT_CONTEXT pContext = NULL
              );

    DWORD   Add( CUsers &NewUsers );

    PUSERSONFILE RemoveItemFromHead(void);

    DWORD   Remove(
                LPCWSTR UserName,
                LPCWSTR CertName
                );
 
    PUSERSONFILE   StartEnum();

    PUSERSONFILE   GetNextUser(
                PUSERSONFILE Token, 
                CString &UserName,
                CString &CertName
                );

	PVOID GetNextChangedUser(
                PVOID Token, 
                LPWSTR *UserName,
                LPWSTR *DnName,  
                PSID *UserSid, 
                PVOID *CertData, 
                DWORD *Flag
                );
    

private:
	DWORD m_UserAddedCnt;
	DWORD m_UserRemovedCnt;
    PUSERSONFILE    m_UsersRoot;

};

#endif // !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\uuids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       uuids.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Nodetypes for the Certificate Management snapin
// created by GUIDGEN 8/8/97 BryanWal

#ifndef _UUIDS_CERTIFICATE_MANAGEMENT_
#define _UUIDS_CERTIFICATE_MANAGEMENT_
#include "certmgrd.h"

#define lstruuidNodetypeSnapin				L"{53D6AB16-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeCertificate			L"{53D6AB17-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeLogStore			L"{53D6AB18-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypePhysStore			L"{53D6AB19-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeUsage				L"{53D6AB1A-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeCRLContainer		L"{E3EDFDFD-D0C3-11d1-955B-0000F803A951}"
#define lstruuidNodetypeCTLContainer		L"{E3EDFDFE-D0C3-11d1-955B-0000F803A951}"
#define lstruuidNodetypeCertContainer		L"{D5CC57D2-CD78-11d1-B690-0000F803A951}"
#define lstruuidNodetypeCRL					L"{E3EDFDFF-D0C3-11d1-955B-0000F803A951}"
#define lstruuidNodetypeCTL					L"{53D6AB1F-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeAutoCertRequest		L"{FC82B00C-8872-11d1-85EF-00C04FB94F17}"
#define lstruiidNodetypeCertPoliciesUser	L"{C4A92B40-91EE-11d1-85FD-00C04FB94F17}"
#define lstruiidNodetypeCertPoliciesComputer \
                                            L"{C4A92B41-91EE-11d1-85FD-00C04FB94F17}"
#define lstruiidNodetypeLogStoreGPE			L"{82F57E23-D0B7-11d1-9559-0000F803A951}"
#define lstruiidNodetypePKPAutoenrollmentSettings \
                                            L"{8DD146E1-4687-4b4c-90DC-23F920C06355}"
#define lstruiidNodetypeSaferComputerRoot   L"{70933DB1-D9CE-4d4a-9F35-D812ED6B6E5A}"
#define lstruiidNodetypeSaferComputerLevels L"{CF7C6FD8-BF56-4058-B6F7-DEEA2D4A1570}"
#define lstruiidNodetypeSaferComputerEntries \
                                            L"{EA3D57B1-473E-463d-BD0B-05BCBAE69FC2}"
#define lstruiidNodetypeSaferUserRoot       L"{521B8639-FDA3-493f-8C5A-946D7B037931}"
#define lstruiidNodetypeSaferUserLevels     L"{CF85A487-6C7C-4708-8EE9-2BF7D23CE61D}"
#define lstruiidNodetypeSaferUserEntries    L"{91DE2E53-63B6-4b69-8B74-990FB0AC1F47}"
#define lstruiidNodetypeSaferComputerLevel  L"{4ECC4509-0356-439b-883A-6B046D5E70E9}"
#define lstruiidNodetypeSaferUserLevel      L"{9BA58619-CF80-45c3-83A4-029C76EB96BD}"
#define lstruiidNodetypeSaferComputerEntry  L"{EE376E23-6D19-49ee-B12A-83442D52C7F1}"
#define lstruiidNodetypeSaferUserEntry      L"{954A504B-33FF-4836-ADD7-E385B0AAF6AD}"
#define lstruiidNodetypeSaferTrustedPublisher L"{DE72271F-2C86-4349-A8F9-0BF3F0A1DB42}"
#define lstruiidNodetypeSaferDefinedFileTypes L"{4A0B4F37-F04A-4e5d-832A-34A035A755B3}"
#define lstruiidNodetypeSaferEnforcement    L"{14E0F120-C802-4ee0-A425-2BA2671E6848}"


#define structuuidNodetypeSnapin    \
    { 0x53d6ab16, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCertificate \
    { 0x53d6ab17, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeLogStore \
	{ 0x53d6ab18, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypePhysStore \
	{ 0x53d6ab19, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeUsage \
	{ 0x53d6ab1a, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCRLContainer \
	{ 0xe3edfdfd, 0xd0c3, 0x11d1, { 0x95, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCTLContainer \
	{ 0xe3edfdfe, 0xd0c3, 0x11d1, { 0x95, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCertContainer \
	{ 0xd5cc57d2, 0xcd78, 0x11d1, { 0xb6, 0x90, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCRL \
	{ 0xe3edfdff, 0xd0c3, 0x11d1, { 0x95, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCTL \
	{ 0x53d6ab1f, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeAutoCertRequest \
	{ 0xfc82b00c, 0x8872, 0x11d1, { 0x85, 0xef, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCertPoliciesUser \
	{ 0xc4a92b40, 0x91ee, 0x11d1, { 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCertPoliciesComputer \
	{ 0xc4a92b41, 0x91ee, 0x11d1, { 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeLogStoreGPE \
	{ 0x82f57e23, 0xd0b7, 0x11d1, { 0x95, 0x59, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypePKPAutoenrollmentSettings \
    { 0x8dd146e1, 0x4687, 0x4b4c, { 0x90, 0xdc, 0x23, 0xf9, 0x20, 0xc0, 0x63, 0x55 } }
#define structuuidNodetypeSaferComputerRoot \
    { 0x70933db1, 0xd9ce, 0x4d4a, { 0x9f, 0x35, 0xd8, 0x12, 0xed, 0x6b, 0x6e, 0x5a } }
#define structuuidNodetypeSaferComputerLevels \
    { 0xcf7c6fd8, 0xbf56, 0x4058, { 0xb6, 0xf7, 0xde, 0xea, 0x2d, 0x4a, 0x15, 0x70 } }
#define structuuidNodetypeSaferComputerEntries \
    { 0xea3d57b1, 0x473e, 0x463d, { 0xbd, 0xb, 0x5, 0xbc, 0xba, 0xe6, 0x9f, 0xc2 } }
#define structuuidNodetypeSaferUserRoot \
    { 0x521b8639, 0xfda3, 0x493f, { 0x8c, 0x5a, 0x94, 0x6d, 0x7b, 0x3, 0x79, 0x31 } }
#define structuuidNodetypeSaferUserLevels \
    { 0xcf85a487, 0x6c7c, 0x4708, { 0x8e, 0xe9, 0x2b, 0xf7, 0xd2, 0x3c, 0xe6, 0x1d } }
#define structuuidNodetypeSaferUserEntries \
    { 0x91de2e53, 0x63b6, 0x4b69, { 0x8b, 0x74, 0x99, 0xf, 0xb0, 0xac, 0x1f, 0x47 } }
#define structuuidNodetypeSaferComputerLevel \
    { 0x4ecc4509, 0x356, 0x439b, { 0x88, 0x3a, 0x6b, 0x4, 0x6d, 0x5e, 0x70, 0xe9 } }
#define structuuidNodetypeSaferUserLevel \
    { 0x9ba58619, 0xcf80, 0x45c3, { 0x83, 0xa4, 0x2, 0x9c, 0x76, 0xeb, 0x96, 0xbd } }
#define structuuidNodetypeSaferComputerEntry \
    { 0xee376e23, 0x6d19, 0x49ee, { 0xb1, 0x2a, 0x83, 0x44, 0x2d, 0x52, 0xc7, 0xf1 } }
#define structuuidNodetypeSaferUserEntry \
    { 0x954a504b, 0x33ff, 0x4836, { 0xad, 0xd7, 0xe3, 0x85, 0xb0, 0xaa, 0xf6, 0xad } }
#define structuuidNodetypeSaferTrustedPublishers \
    { 0xde72271f, 0x2c86, 0x4349, { 0xa8, 0xf9, 0xb, 0xf3, 0xf0, 0xa1, 0xdb, 0x42 } }
#define structuuidNodetypeSaferDefinedFileTypes \
    { 0x4a0b4f37, 0xf04a, 0x4e5d, { 0x83, 0x2a, 0x34, 0xa0, 0x35, 0xa7, 0x55, 0xb3 } }
#define structuuidNodetypeSaferEnforcement \
    { 0x14e0f120, 0xc802, 0x4ee0, { 0xa4, 0x25, 0x2b, 0xa2, 0x67, 0x1e, 0x68, 0x48 } }


DEFINE_GUID (NODEID_CertMgr_CERTIFICATE, 0x53d6ab17, 0x2488, 0x11d1, 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_CertMgr_CRL, 0x53d6ab1e, 0x2488, 0x11d1, 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_CertMgr_CTL, 0x53d6ab1f, 0x2488, 0x11d1, 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_CertMgr_AUTOCERT, 0xfc82b00c, 0x8872, 0x11d1, 0x85, 0xef, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_Safer_COMPUTER_ENTRY, 0xee376e23, 0x6d19, 0x49ee, 0xb1, 0x2a, 0x83, 0x44, 0x2d, 0x52, 0xc7, 0xf1);
DEFINE_GUID (NODEID_Safer_USER_ENTRY, 0x954a504b, 0x33ff, 0x4836, 0xad, 0xd7, 0xe3, 0x85, 0xb0, 0xaa, 0xf6, 0xad);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\welcome.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Welcome.cpp
//
//  Contents:   Implementation of Add EFS Agent Wizard Welcome Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Welcome.h"
#include "AddSheet.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizWelcome property page

CAddEFSWizWelcome::CAddEFSWizWelcome() : CWizard97PropertyPage(CAddEFSWizWelcome::IDD)
{
	//{{AFX_DATA_INIT(CAddEFSWizWelcome)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

CAddEFSWizWelcome::~CAddEFSWizWelcome()
{
}

void CAddEFSWizWelcome::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddEFSWizWelcome)
	DDX_Control(pDX, IDC_STATICB_BOLD, m_boldStatic);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddEFSWizWelcome, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(CAddEFSWizWelcome)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizWelcome message handlers

BOOL CAddEFSWizWelcome::OnSetActive() 
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	
	return bResult;
}

BOOL CAddEFSWizWelcome::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();
	
	m_boldStatic.SetFont (&GetBigBoldFont ());
	CString	title;
	VERIFY (title.LoadString (IDS_ADDTITLE));
	CWnd* pParent = GetParent ();
    if ( pParent )
        pParent->SendMessage (PSM_SETTITLE, 0, (LPARAM) (LPCWSTR) title);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\welcome.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       welcome.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_WELCOME_H__8C048CD7_54B2_11D1_BB63_00A0C906345D__INCLUDED_)
#define AFX_WELCOME_H__8C048CD7_54B2_11D1_BB63_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Welcome.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizWelcome dialog

class CAddEFSWizWelcome : public CWizard97PropertyPage
{

// Construction
public:
	CAddEFSWizWelcome();
	virtual ~CAddEFSWizWelcome();

// Dialog Data
	//{{AFX_DATA(CAddEFSWizWelcome)
	enum { IDD = IDD_WELCOME };
	CStatic	m_boldStatic;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAddEFSWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddEFSWizWelcome)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WELCOME_H__8C048CD7_54B2_11D1_BB63_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\wiz97ppg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       wiz97ppg.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Wiz97PPg.h : header file
//
#include "Wiz97Sht.h"

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage dialog

class CWizard97PropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CWizard97PropertyPage)
// Construction
public:
	PROPSHEETPAGE			m_psp97;
	CString					m_szHeaderTitle;
	CString					m_szHeaderSubTitle;
	CWizard97PropertySheet* m_pWiz;

	void InitWizard97(bool bHideHeader);
	CWizard97PropertyPage ();
	CWizard97PropertyPage(UINT nIDTemplate);
	virtual ~CWizard97PropertyPage();

// Dialog Data
	//{{AFX_DATA(CWizard97PropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizard97PropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizard97PropertyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	bool SetupFonts ();
	CFont& GetBigBoldFont();
	CFont& GetBoldFont();

	CFont m_boldFont;
	CFont m_bigBoldFont;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\wiz97ppg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Wiz97PPg.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Wiz97PPg.cpp : implementation file
//

#include "stdafx.h"
#include "Wiz97PPg.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage property page
IMPLEMENT_DYNCREATE(CWizard97PropertyPage, CPropertyPage)

CWizard97PropertyPage::CWizard97PropertyPage ()
	: CPropertyPage (),
	m_pWiz (0)
{
	ASSERT (0); // default constructor - should never be called
}

CWizard97PropertyPage::CWizard97PropertyPage(UINT nIDTemplate) : 
	CPropertyPage(nIDTemplate),
	m_pWiz (0)
{
	//{{AFX_DATA_INIT(CWizard97PropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWizard97PropertyPage::~CWizard97PropertyPage()
{
}

void CWizard97PropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWizard97PropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizard97PropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CWizard97PropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage message handlers

void CWizard97PropertyPage::InitWizard97(bool bHideHeader)
{
	::ZeroMemory (&m_psp97, sizeof (PROPSHEETPAGE));
	m_psp.dwFlags &= ~PSP_HASHELP;
	memcpy (&m_psp97, &m_psp, m_psp.dwSize);
	m_psp97.dwSize = sizeof (PROPSHEETPAGE);

	if ( bHideHeader )
	{
		// for first and last page of the wizard
		m_psp97.dwFlags |= PSP_HIDEHEADER;
	}
	else
	{
		// for intermediate pages
		m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
		m_psp97.pszHeaderTitle = (LPCWSTR) m_szHeaderTitle;
		m_psp97.pszHeaderSubTitle = (LPCWSTR) m_szHeaderSubTitle;
	}
}

bool CWizard97PropertyPage::SetupFonts()
{
	bool	bReturn = false;
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof (ncm);
	SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    CString	largeFontSizeString;
    INT		largeFontSize;
    CString smallFontSizeString;
    INT		smallFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if ( !::LoadString (AfxGetInstanceHandle (), IDS_LARGEFONTNAME,
			BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
		ASSERT (0);
        lstrcpy (BigBoldLogFont.lfFaceName, L"Verdana");
    }

    if ( largeFontSizeString.LoadString (IDS_LARGEFONTSIZE) ) 
    {
        largeFontSize = wcstoul ((LPCWSTR) largeFontSizeString, NULL, 10);
    } 
    else 
    {
		ASSERT (0);
        largeFontSize = 12;
    }

    if ( !::LoadString (AfxGetInstanceHandle (), IDS_SMALLFONTNAME,
			BoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
		ASSERT (0);
        lstrcpy (BoldLogFont.lfFaceName, L"Verdana");
    }

    if ( smallFontSizeString.LoadString (IDS_SMALLFONTSIZE) ) 
    {
        smallFontSize = wcstoul ((LPCWSTR) smallFontSizeString, NULL, 10);
    } 
    else 
    {
		ASSERT (0);
        smallFontSize = 8;
    }

	CDC* pdc = GetDC ();

    if ( pdc )
    {
        BigBoldLogFont.lfHeight = 0 - (pdc->GetDeviceCaps (LOGPIXELSY) * largeFontSize / 72);
        BoldLogFont.lfHeight = 0 - (pdc->GetDeviceCaps (LOGPIXELSY) * smallFontSize / 72);

        BOOL	bBigBold = m_bigBoldFont.CreateFontIndirect (&BigBoldLogFont);
		BOOL	bBold = m_boldFont.CreateFontIndirect (&BoldLogFont);

        ReleaseDC (pdc);

        if ( bBigBold && bBold )
			bReturn = true;
		else
        {
            if ( bBold )
            {
                VERIFY (m_boldFont.DeleteObject());
            }

            if ( bBigBold )
            {
                VERIFY (m_bigBoldFont.DeleteObject());
            }
        }
    }

    return bReturn;
}

CFont& CWizard97PropertyPage::GetBoldFont()
{
	return m_boldFont;
}

CFont& CWizard97PropertyPage::GetBigBoldFont()
{
	return m_bigBoldFont;
}


BOOL CWizard97PropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	LONG dwExStyle = GetWindowLong (GetParent ()->m_hWnd, GWL_EXSTYLE);
	if ( dwExStyle & WS_EX_CONTEXTHELP )
	{
		dwExStyle &= ~WS_EX_CONTEXTHELP;
		SetWindowLong (GetParent ()->m_hWnd, GWL_EXSTYLE, dwExStyle);
	}

	SetupFonts ();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\wiz97sht.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Wiz97Sht.cpp
//
//  Contents:   Base class for cert find dialog
//
//----------------------------------------------------------------------------\
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Wiz97Sht.h"
#include "Wiz97PPg.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWizard97PropertySheet::CWizard97PropertySheet(UINT nIDCaption, UINT nIDWaterMark, UINT nIDBanner)
{
	::ZeroMemory (&m_pPagePtr, sizeof (CWizard97PropertyPage*) * NUM_PAGES);
	::ZeroMemory (&m_pPageArr, sizeof (HPROPSHEETPAGE) * NUM_PAGES);

	// NOTICE: do this because of header mismatch
	memset(&m_psh, 0x0, sizeof(PROPSHEETHEADER));
	m_psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
	m_psh.pszbmWatermark = MAKEINTRESOURCE (nIDWaterMark);
	m_psh.pszbmHeader = MAKEINTRESOURCE (nIDBanner);
	m_psh.hplWatermark = NULL;
	

    m_psh.dwSize              = sizeof (m_psh);
    m_psh.hInstance           = AfxGetApp()->m_hInstance;
    m_psh.hwndParent          = NULL;

	VERIFY (m_title.LoadString (nIDCaption));
    m_psh.pszCaption          = (LPCWSTR) m_title;
    m_psh.phpage              = NULL;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = 0;

    m_nPageCount = 0;
}

CWizard97PropertySheet::~CWizard97PropertySheet()
{
}


INT_PTR CWizard97PropertySheet::DoWizard(HWND hParent)
{
    m_psh.hwndParent = hParent;
//   if ( m_nPageCount > 0 && m_pPagePtr[m_nPageCount - 1] )
//		m_pPagePtr[m_nPageCount - 1]->m_bLast = TRUE;

    m_psh.phpage              = m_pPageArr;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = m_nPageCount;

	return PropertySheet (&m_psh);
}

void CWizard97PropertySheet::AddPage(CWizard97PropertyPage * pPage)
{
	ASSERT (pPage);
	if ( pPage )
	{
		ASSERT (m_nPageCount < NUM_PAGES);
		m_pPagePtr[m_nPageCount] = pPage;
		m_pPageArr[m_nPageCount] = ::MyCreatePropertySheetPage (
                (AFX_OLDPROPSHEETPAGE*) &(pPage->m_psp97));
		ASSERT (m_pPageArr[m_nPageCount]);
		m_nPageCount++;
		pPage->m_pWiz = this;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\chooser\chooser2.h ===
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000

//+--------------------------------------------------------------------------
//
//  Function:   CHOOSER2_PickTargetComputer
//
//  Synopsis:   Bring up a standard dialog which allows users to
//              select a target computer.
//
//  Arguments:  pbstrTargetComputer - pointer to return value
//
//  Returns:    true -> OK, false -> Cancel
//
//  History:    12-06-1999   JonN       Created
//
//---------------------------------------------------------------------------


#define IDD_CHOOSER2                             5000
#define IDC_CHOOSER2_RADIO_LOCAL_MACHINE         5001
#define IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE      5002
#define IDC_CHOOSER2_EDIT_MACHINE_NAME           5003
#define IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES  5004

bool CHOOSER2_PickTargetComputer(
    IN  HINSTANCE hinstance,
    IN  HWND hwndParent,
    OUT BSTR* pbstrTargetComputer );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\chooser\chooser.cpp ===
/////////////////////////////////////////////////////////////////////
//	Chooser.cpp
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//
//	Dialog to choose a machine name.
//
//	PURPOSE
//	(Important -- Please Read)
//	This code was written for you to save you time.
//	What you have to do is to copy all the files from the
//	snapin\chooser\ directory into your project (you may add
//	\nt\private\admin\snapin\chooser\ to your include directory if
//	you prefer not copying the code).
//	If you decide to copy the code to your project, please send mail
//	to Dan Morin (T-DanM) and cc to Jon Newman (JonN) so we can
//	mail you when we have updates available.  The next update will
//	be the "Browse" button to select a machine name.
//
//
//  DYNALOADED LIBRARIES
//		$(SDK_LIB_PATH)\shell32.lib         // CommandLineToArgvW()
//		$(SDK_LIB_PATH)\netapi32.lib        // I_NetName*()
//
//	EXTRA INFO
//	If you don't know how this works, take a look at the inheritance tree
//	in chooser.h.  Then, take a look at the existing code that inherit and/or
//	uses CChooseMachinePropPage.
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//	23-May-1997		t-danm		Checkin into public tree. Comments updates.
//	25-May-1997		t-danm		Added MMCPropPageCallback().
//	31-Oct-1997		mattt			Added dynaload, fixed user <CANCEL> logic
//
/////////////////////////////////////////////////////////////////////

#include "chooser.h"
#include <lmcons.h>	  // NET_API_STATUS
#include <lmerr.h>	  // NERR_Success
#include <icanon.h>   // I_NetNameValidate(), I_NetNameCanonicalize(). Found in \nt\private\net\inc.
#include <objsel.h>
#include "stdutils.h" // IsLocalComputername

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#ifndef INOUT		
	// The following defines are found in \nt\private\admin\snapin\filemgmt\stdafx.h

	#define INOUT
	#define	Endorse(f)		// Dummy macro
	#define LENGTH(x)		(sizeof(x)/sizeof(x[0]))
	#define Assert(f)		ASSERT(f)
#endif

/////////////////////////////////////////////////////////////////////
//	CanonicalizeComputername()
//
//	Function to validate the computer name and optionally
//	add the \\ at beginning of machine name.
//


typedef
NET_API_STATUS
NET_API_FUNCTION
INETNAMEVALIDATE(
    LPTSTR  ServerName,
    LPTSTR  Name,
    DWORD   NameType,
    DWORD   Flags);

typedef
NET_API_STATUS
NET_API_FUNCTION
INETNAMECANONICALIZE(
    LPTSTR  ServerName,
    LPTSTR  Name,
    LPTSTR  Outbuf,
    DWORD   OutbufLen,
    DWORD   NameType,
    DWORD   Flags);


NET_API_STATUS
CanonicalizeComputername(
	INOUT CString& rstrMachineName,
	IN BOOL fAddWackWack = TRUE)	// TRUE => Add the \\ at beginning of name
{
	NET_API_STATUS err;
    LPTSTR pszTemp;

    rstrMachineName.TrimLeft();
	rstrMachineName.TrimRight();
	if ( rstrMachineName.IsEmpty() )
		return NERR_Success;

	if ( 2 <= rstrMachineName.GetLength() &&
		 _T('\\') == rstrMachineName[0] &&
		 _T('\\') == rstrMachineName[1] )
	{
		// Remove the \\ at the beginning of name
		CString strShorter = rstrMachineName.Right(
			rstrMachineName.GetLength() - 2 );
		rstrMachineName = strShorter;
	}

    // DYNALOAD NETAPI32.dll
    HINSTANCE hNetApiDll = NULL;
    INETNAMEVALIDATE        *pfnValidate;
    INETNAMECANONICALIZE    *pfnCanonicalize;
    if (NULL == (hNetApiDll = LoadLibrary(L"netapi32.dll")))
        return GetLastError();

    if (NULL == (pfnValidate = (INETNAMEVALIDATE*)GetProcAddress(hNetApiDll, "I_NetNameValidate")) )
    {
        err = GetLastError();
        goto Ret;
    }
    if (NULL == (pfnCanonicalize = (INETNAMECANONICALIZE*)GetProcAddress(hNetApiDll, "I_NetNameCanonicalize")) )
    {
        err = GetLastError();
        goto Ret;
    }


	err = pfnValidate(
		NULL,
        const_cast<LPTSTR>((LPCTSTR)rstrMachineName),
        NAMETYPE_COMPUTER,
        0L );
	if (NERR_Success != err)
		goto Ret;

	ASSERT( MAX_PATH > rstrMachineName.GetLength() );
	pszTemp = (LPTSTR)alloca( MAX_PATH*sizeof(TCHAR) );
	ASSERT( NULL != pszTemp );
	err = pfnCanonicalize(
		NULL,
        IN const_cast<LPTSTR>((LPCTSTR)rstrMachineName),
		OUT pszTemp,
		MAX_PATH*sizeof(TCHAR),
        NAMETYPE_COMPUTER,
        0L );
	if (NERR_Success != err)
		goto Ret;
	if (fAddWackWack && pszTemp[0] != '\0')
	{
		// Add the \\ at beginning of name
		rstrMachineName = _T("\\\\");
		rstrMachineName += pszTemp;
	}
	else
	{
		rstrMachineName = pszTemp;
	}

    err = NERR_Success;
Ret:
    if (hNetApiDll)
        FreeLibrary(hNetApiDll);

	return err;
} // CanonicalizeComputername()


/////////////////////////////////////////////////
//	Machine name override
const TCHAR szOverrideCommandLineEquals[] = _T("/Computer=");	// Not subject to localization
const TCHAR szOverrideCommandLineColon[] = _T("/Computer:");	// Not subject to localization
const TCHAR szLocalMachine[] = _T("LocalMachine");		// Not subject to localization
const int cchOverrideCommandLine = LENGTH(szOverrideCommandLineEquals) - 1;
// Assumption: both command line strings are the same length

static CString g_strOverrideMachineName;
static LPCTSTR g_pszOverrideMachineName;	// NULL => No override provided, "" => LocalMachine

///////////////////////////////////////////////////////////////////////////////
//	PchGetMachineNameOverride()
//
//	Parse the command line arguments and return a pointer to the
//	machine name override if present.
//
//	INTERFACE NOTES
//	If the machine name is other than local machine, the machine name
//	will have the \\ at the beginning of its name.
//	
//	RETURN
//	- Return NULL if no override (ie, no command line override)
//	- Return pointer to empty string if override is "local machine"
//	- Otherwise return pointer to machine name override with \\ at beginning.
//
typedef
LPWSTR * COMMANDLINETOARGVW(
                LPCWSTR lpCmdLine,  // pointer to a command-line string
                int *pNumArgs);     // pointer to a variable that receives the argument count



LPCTSTR PchGetMachineNameOverride ()
{
	static BOOL fAlreadyInitialized = FALSE;
	if (fAlreadyInitialized)
	{
		// We already have parsed the command line
		return g_pszOverrideMachineName;
	}
	fAlreadyInitialized = TRUE;
	ASSERT(g_pszOverrideMachineName == NULL);

	LPCWSTR * lpServiceArgVectors = 0;		// Array of pointers to string
	int cArgs = 0;						// Count of arguments


    // DYNALOAD Shell32
    {
        HINSTANCE hShellDll = LoadLibrary (L"shell32.dll");
        if ( !hShellDll )
            return NULL;

        COMMANDLINETOARGVW *pfnCmdToArgs = (COMMANDLINETOARGVW*) GetProcAddress (hShellDll, "CommandLineToArgvW");
        if ( !pfnCmdToArgs )
        {
            VERIFY (FreeLibrary (hShellDll));
            return NULL;
        }

        lpServiceArgVectors = (LPCWSTR *) pfnCmdToArgs (GetCommandLineW (), OUT &cArgs);

        VERIFY (FreeLibrary (hShellDll));
        pfnCmdToArgs = NULL;
    }

	if (lpServiceArgVectors == NULL)
		return NULL;
	for (int i = 1; i < cArgs; i++)
	{
		Assert(lpServiceArgVectors[i] != NULL);
		CString str = lpServiceArgVectors[i];	// Copy the string
		str = str.Left(cchOverrideCommandLine);
		if (0 != str.CompareNoCase(szOverrideCommandLineEquals) &&
				0 != str.CompareNoCase(szOverrideCommandLineColon) )
		{
			continue;
		}
		str = lpServiceArgVectors[i] + cchOverrideCommandLine;
		if (0 == str.CompareNoCase(szLocalMachine))
			str.Empty();
		if (NERR_Success != CanonicalizeComputername(INOUT str))
			continue;
		g_strOverrideMachineName = str;	// Copy the argument into the global string
		g_pszOverrideMachineName = g_strOverrideMachineName;
	}
	LocalFree(lpServiceArgVectors);
	return g_pszOverrideMachineName;
} // PchGetMachineNameOverride()


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CAutoDeletePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CAutoDeletePropPage)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : CPropertyPage(uIDD)
{
	m_prgzHelpIDs = NULL;
	m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
	m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;
	m_psp.pfnCallback = S_PropSheetPageProc;
	m_psp.lParam = reinterpret_cast<LPARAM>(this);

	// The following line is to enable MFC property pages to run under MMC.
	MMCPropPageCallback(INOUT &m_psp);
}

CAutoDeletePropPage::~CAutoDeletePropPage()
{
}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
{
	m_strCaption = pszCaption;		// Copy the caption
	m_psp.pszTitle = m_strCaption;	// Set the title
	m_psp.dwFlags |= PSP_USETITLE;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
{
	VERIFY(m_strCaption.LoadString(uStringID));
	SetCaption(m_strCaption);
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
	Endorse(szHelpFile == NULL);	// TRUE => No help file supplied (meaning no help)
	Endorse(rgzHelpIDs == NULL);	// TRUE => No help at all
	m_strHelpFile = szHelpFile;
	m_prgzHelpIDs = rgzHelpIDs;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
	Assert(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
	::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
{
	HWND hwndParent = ::GetParent(m_hWnd);
	Assert(IsWindow(hwndParent));
	::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);
	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
	if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
		return TRUE;
	const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
	if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		// Display context help for a control
		::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
			HELP_WM_HELP, (DWORD_PTR)m_prgzHelpIDs);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
	if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
		return TRUE;
	Assert(IsWindow((HWND)wParam));
	::WinHelp((HWND)wParam, m_strHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)m_prgzHelpIDs);
	return TRUE;
}


/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//
UINT CALLBACK CAutoDeletePropPage::S_PropSheetPageProc(
	HWND hwnd,	
	UINT uMsg,	
	LPPROPSHEETPAGE ppsp)
{
	Assert(ppsp != NULL);
	CChooseMachinePropPage * pThis;
	pThis = reinterpret_cast<CChooseMachinePropPage*>(ppsp->lParam);
	Assert(pThis != NULL);

	switch (uMsg)
	{
	case PSPCB_RELEASE:
		if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
			{
			// Remember callback on stack since "this" will be deleted
			LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
			delete pThis;
			return (pfnOrig)(hwnd, uMsg, ppsp);
		}
		break;
	case PSPCB_CREATE:
		// do not increase refcount, PSPCB_CREATE may or may not be called
		// depending on whether the page was created.  PSPCB_RELEASE can be
		// depended upon to be called exactly once per page however.
		break;

	} // switch
	return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
} // CAutoDeletePropPage::S_PropSheetPageProc()





/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CChooseMachinePropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CChooseMachinePropPage)
	ON_BN_CLICKED(IDC_CHOOSER_RADIO_LOCAL_MACHINE, OnRadioLocalMachine)
	ON_BN_CLICKED(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, OnRadioSpecificMachine)
	ON_BN_CLICKED(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, OnChooserButtonBrowseMachinenames)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef _DEBUG
static void AssertValidDialogTemplate(HWND hwnd)
{
	ASSERT(::IsWindow(hwnd));
	// Mandatory controls for a valid dialog template
	static const UINT rgzidDialogControl[] =
	{
		IDC_CHOOSER_RADIO_LOCAL_MACHINE,
		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,
		IDC_CHOOSER_EDIT_MACHINE_NAME,
		0
	};

	for (int i = 0; rgzidDialogControl[i] != 0; i++)
	{
		ASSERT(NULL != GetDlgItem(hwnd, rgzidDialogControl[i]) &&
			"Control ID not found in dialog template.");
	}
} // AssertValidDialogTemplate()
#else
	#define AssertValidDialogTemplate(hwnd)
#endif	// ~_DEBUG

/////////////////////////////////////////////////////////////////////
//	Constructor
CChooseMachinePropPage::CChooseMachinePropPage(UINT uIDD) : CAutoDeletePropPage(uIDD)
{
	m_fIsRadioLocalMachine = TRUE;
	m_fAllowOverrideMachineName = FALSE;
	
	m_pfAllowOverrideMachineNameOut = NULL;
	m_pstrMachineNameOut = NULL;
	m_pstrMachineNameEffectiveOut = NULL;
}

/////////////////////////////////////////////////////////////////////
CChooseMachinePropPage::~CChooseMachinePropPage()
{
}

/////////////////////////////////////////////////////////////////////
//	Load the initial state of CChooseMachinePropPage
void CChooseMachinePropPage::InitMachineName(LPCTSTR pszMachineName)
{
	Endorse(pszMachineName == NULL);
	m_strMachineName = pszMachineName;
	m_fIsRadioLocalMachine = m_strMachineName.IsEmpty();
}

/////////////////////////////////////////////////////////////////////
//	SetOutputBuffers()
//
//	- Set the pointer to the CString object to store the machine name.
//	- Set the pointer to the boolean flag for command line override.
//	- Set the pointer pointer to store the overriden machine name.
//
void CChooseMachinePropPage::SetOutputBuffers(
	OUT CString * pstrMachineNamePersist,	// Machine name the user typed.  Empty string == local machine.
	OUT BOOL * pfAllowOverrideMachineName,
	OUT CString * pstrMachineNameEffective)
{
	Assert(pstrMachineNamePersist != NULL && "Invalid output buffer");
	Endorse(pfAllowOverrideMachineName == NULL); // TRUE => Do not want to support override from command line
	Endorse(pstrMachineNameEffective == NULL);		// TRUE => Don't care of override
	
	m_pstrMachineNameOut = pstrMachineNamePersist;
	m_pfAllowOverrideMachineNameOut = pfAllowOverrideMachineName;
	m_pstrMachineNameEffectiveOut = pstrMachineNameEffective;
}

/////////////////////////////////////////////////////////////////////
void CChooseMachinePropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CChooseMachinePropPage)
	//}}AFX_DATA_MAP

	DDX_Text(pDX, IDC_CHOOSER_EDIT_MACHINE_NAME, m_strMachineName);
	DDV_MaxChars(pDX, m_strMachineName, MAX_PATH);
	if (NULL != m_hwndCheckboxOverride)
	{
		DDX_Check(pDX, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME, m_fAllowOverrideMachineName);
	}
	if (pDX->m_bSaveAndValidate)
	{
		// User clicked on OK
		if (NERR_Success != CanonicalizeComputername(INOUT m_strMachineName) )
		{
			AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxMessageBox()
			AfxMessageBox(IDS_CHOOSER_INVALID_COMPUTERNAME);
			pDX->Fail();
			Assert(FALSE && "Unreachable code");
		}
	} // if

} // DoDataExchange()


/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnInitDialog()
{
	AssertValidDialogTemplate(m_hWnd);
	CAutoDeletePropPage::OnInitDialog();
	InitRadioButtons();
	m_hwndCheckboxOverride = ::GetDlgItem(m_hWnd, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME);
	if (m_pfAllowOverrideMachineNameOut == NULL && m_hwndCheckboxOverride != NULL)
	{
		// We are not interested with the command line override
		::EnableWindow(m_hwndCheckboxOverride, FALSE);	// Disable the window
		::ShowWindow(m_hwndCheckboxOverride, SW_HIDE);	// Hide the window
	}
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnWizardFinish()
{
	if (!UpdateData())    // Do the data exchange to collect data
		return FALSE;       // don't destroy on error

	if (m_fIsRadioLocalMachine)
		m_strMachineName.Empty();

	if (m_pstrMachineNameOut != NULL)
	{
		// Store the machine name into its output buffer
		*m_pstrMachineNameOut = m_strMachineName;
		if (m_pfAllowOverrideMachineNameOut != NULL)
			*m_pfAllowOverrideMachineNameOut = m_fAllowOverrideMachineName;
		if (m_pstrMachineNameEffectiveOut != NULL)
		{
			if (m_fAllowOverrideMachineName && PchGetMachineNameOverride())
				*m_pstrMachineNameEffectiveOut = PchGetMachineNameOverride();
			else
				*m_pstrMachineNameEffectiveOut = m_strMachineName;

			// JonN 1/27/99: If the persisted name is the local computername,
			// leave the persisted name alone but make the effective name (Local).
			if ( IsLocalComputername( *m_pstrMachineNameEffectiveOut ) )
				m_pstrMachineNameEffectiveOut->Empty();

		} // if
	}
	else
		Assert(FALSE && "FYI: You have not specified any output buffer to store the machine name.");

	return CAutoDeletePropPage::OnWizardFinish();
}

void CChooseMachinePropPage::InitRadioButtons()
{
	SendDlgItemMessage(IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, m_fIsRadioLocalMachine);
	SendDlgItemMessage(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !m_fIsRadioLocalMachine);
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, !m_fIsRadioLocalMachine);
	EnableDlgItem (IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, !m_fIsRadioLocalMachine);
}

void CChooseMachinePropPage::OnRadioLocalMachine()
{
	m_fIsRadioLocalMachine = TRUE;
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, FALSE);
	EnableDlgItem (IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, FALSE);
}

void CChooseMachinePropPage::OnRadioSpecificMachine()
{
	m_fIsRadioLocalMachine = FALSE;
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, TRUE);
	EnableDlgItem (IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, TRUE);
}



void CChooseMachinePropPage::OnChooserButtonBrowseMachinenames()
{
	CString	 computerName;
	HRESULT hr = ComputerNameFromObjectPicker (m_hWnd, computerName);
	if ( S_OK == hr )  // S_FALSE means user pressed "Cancel"
	{
		SetDlgItemText (IDC_CHOOSER_EDIT_MACHINE_NAME, computerName);
	}
	else if ( FAILED (hr) )
	{
		CString	text;
		CString	caption;

		text.LoadString (IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR);
		caption.LoadString (IDS_SELECT_COMPUTER);

		MessageBox (text, caption, MB_ICONEXCLAMATION | MB_OK);
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Generic Computer Picker
///////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
	if ( !pDsObjectPicker )
		return E_POINTER;

	//
	// Prepare to initialize the object picker.
	// Set up the array of scope initializer structures.
	//

	static const int SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

	ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

	//
	// 127399: JonN 10/30/00 JOINED_DOMAIN should be starting scope
	//

	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
	                     | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
	                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
	                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_WORKGROUP
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	//
	// Put the scope init array into the object picker init array
	//

	DSOP_INIT_INFO  initInfo;
	ZeroMemory(&initInfo, sizeof(initInfo));

	initInfo.cbSize = sizeof(initInfo);
	initInfo.pwzTargetComputer = NULL;  // NULL == local machine
	initInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	initInfo.aDsScopeInfos = aScopeInit;
	initInfo.cAttributesToFetch = 1;
	static PCWSTR pwszDnsHostName = L"dNSHostName";
	initInfo.apwzAttributeNames = &pwszDnsHostName;

	//
	// Note object picker makes its own copy of initInfo.  Also note
	// that Initialize may be called multiple times, last call wins.
	//

	return pDsObjectPicker->Initialize(&initInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   ProcessSelectedObjects
//
//  Synopsis:   Retrieve the list of selected items from the data object
//              created by the object picker and print out each one.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT ProcessSelectedObjects(IDataObject *pdo, CString& computerName)
{
	if ( !pdo )
		return E_POINTER;

	HRESULT hr = S_OK;
	static UINT g_cfDsObjectPicker =
		RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		(CLIPFORMAT)g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	bool fGotStgMedium = false;

	do
	{
		hr = pdo->GetData(&formatetc, &stgmedium);
		if ( SUCCEEDED (hr) )
		{
			fGotStgMedium = true;

			PDS_SELECTION_LIST pDsSelList =
				(PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

			if (!pDsSelList)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());
				break;
			}

			ASSERT (1 == pDsSelList->cItems);
			if ( 1 == pDsSelList->cItems )
			{
				PDS_SELECTION psel = &(pDsSelList->aDsSelection[0]);
				VARIANT* pvarDnsName = &(psel->pvarFetchedAttributes[0]);
				if (   NULL == pvarDnsName
				    || VT_BSTR != pvarDnsName->vt
				    || NULL == pvarDnsName->bstrVal
				    || L'\0' == (pvarDnsName->bstrVal)[0] )
				{
					computerName = psel->pwzName;
				} else {
					computerName = pvarDnsName->bstrVal;
				}
			}
			else
				hr = E_UNEXPECTED;
			

			GlobalUnlock(stgmedium.hGlobal);
		}
	} while (0);

	if (fGotStgMedium)
	{
		ReleaseStgMedium(&stgmedium);
	}

	return hr;
}



///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//////////////////////////////////////////////////////////////////////////////
HRESULT	ComputerNameFromObjectPicker (HWND hwndParent, CString& computerName)
{
	//
	// Create an instance of the object picker.  The implementation in
	// objsel.dll is apartment model.
	//
	CComPtr<IDsObjectPicker> spDsObjectPicker;
	HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
	                              NULL,
	                              CLSCTX_INPROC_SERVER,
	                              IID_IDsObjectPicker,
	                              (void **) &spDsObjectPicker);
	if ( SUCCEEDED (hr) )
	{
		ASSERT(!!spDsObjectPicker);
		//
		// Initialize the object picker to choose computers
		//

		hr = InitObjectPickerForComputers(spDsObjectPicker);
		if ( SUCCEEDED (hr) )
		{
			//
			// Now pick a computer
			//
			CComPtr<IDataObject> spDataObject;

			hr = spDsObjectPicker->InvokeDialog(hwndParent, &spDataObject);
			if ( S_OK == hr )
			{
				ASSERT(!!spDataObject);
				hr = ProcessSelectedObjects(spDataObject, computerName);
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\certmgr\wiz97sht.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Wiz97Sht.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Wiz97Sht.h: interface for the CWizard97PropertySheet class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define NUM_PAGES 10

class CWizard97PropertyPage; // Forward definition

class CWizard97PropertySheet
{
public:
	void AddPage( CWizard97PropertyPage *pPage );
	CWizard97PropertySheet(UINT nIDCaption, UINT nIDWaterMark, UINT nIDBanner);
	virtual ~CWizard97PropertySheet();

	INT_PTR DoWizard(HWND hParent);

//private:
	CString m_title;

	PROPSHEETHEADER			m_psh;
    HPROPSHEETPAGE			m_pPageArr[NUM_PAGES];
	CWizard97PropertyPage*	m_pPagePtr[NUM_PAGES];
	int						m_nPageCount;
};

#endif // !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\chooser\chooserd.h ===
// chooserd.h - Contains default resource IDs for chooser.rc
//
// HISTORY
// 26-May-1997	t-danm		Creation.
//

//
// The _CHOOSER_BASE_RESOURCE_ID is there to allow relocatable resource IDs
//
#ifndef _CHOOSER_BASE_RESOURCE_ID
	#define _CHOOSER_BASE_RESOURCE_ID	970	// Arbitrary chosen
#endif

// Dialog ID
#ifndef IDD_CHOOSER_CHOOSE_MACHINE
	#define IDD_CHOOSER_CHOOSE_MACHINE 		_CHOOSER_BASE_RESOURCE_ID
#endif

// Dialog Controls
#ifndef IDC_CHOOSER_STATIC
	#define IDC_CHOOSER_STATIC						(_CHOOSER_BASE_RESOURCE_ID+0)
	#define IDC_CHOOSER_GROUP_TARGET_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+1)
	#define IDC_CHOOSER_RADIO_LOCAL_MACHINE			(_CHOOSER_BASE_RESOURCE_ID+2)
	#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+3)
	#define IDC_CHOOSER_EDIT_MACHINE_NAME			(_CHOOSER_BASE_RESOURCE_ID+4)
	#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES	(_CHOOSER_BASE_RESOURCE_ID+5)
	#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME (_CHOOSER_BASE_RESOURCE_ID+6)
#endif

// Strings
#ifndef IDS_CHOOSER_INVALID_COMPUTERNAME
	#define IDS_CHOOSER_INVALID_COMPUTERNAME		(_CHOOSER_BASE_RESOURCE_ID+0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\chooser\choosert.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chooser.rc
//
#define IDS_SELECT_COMPUTER             971
#define IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR 972

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);

    void Trace(LPWSTR pszfmt, ...);
    void Trace(LPSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPWSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, LPWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

private:
    unsigned long   m_InfoLevel; // must be the first data member
    LPTSTR          m_InfoLevelString;

};  // class CDbg


#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined
#define DEB_USER8           0x00800000      // User defined
#define DEB_USER9           0x01000000      // User defined
#define DEB_USER10          0x02000000      // User defined
#define DEB_USER11          0x04000000      // User defined
#define DEB_USER12          0x08000000      // User defined
#define DEB_USER13          0x10000000      // User defined
#define DEB_USER14          0x20000000      // User defined
#define DEB_USER15          0x40000000      // User defined

#define DEB_NOCOMPNAME      0x80000000      // suppress component name

#define DEB_FORCE           0x7fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\chooser\chooser2.cpp ===
//
// JonN 12/6/99 created
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000
//

#include <windows.h>
#include <windowsx.h>
#include <lmcons.h>
#include <atlbase.h>
#include <objsel.h>
#include "chooser2.h"

//+--------------------------------------------------------------------------
//
//  Function:   CHOOSER2_InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              12-08-1999   JonN       Copied from CHOOSER
//
//---------------------------------------------------------------------------

HRESULT CHOOSER2_InitObjectPickerForComputers(
    IDsObjectPicker *pDsObjectPicker)
{
	if ( !pDsObjectPicker )
		return E_POINTER;

	//
	// Prepare to initialize the object picker.
	// Set up the array of scope initializer structures.
	//

	static const int SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

	ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

	//
	// 127399: JonN 10/30/00 JOINED_DOMAIN should be starting scope
	//

	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
	                     | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
	                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
	                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_WORKGROUP
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	//
	// Put the scope init array into the object picker init array
	//

	DSOP_INIT_INFO  initInfo;
	ZeroMemory(&initInfo, sizeof(initInfo));

	initInfo.cbSize = sizeof(initInfo);
	initInfo.pwzTargetComputer = NULL;  // NULL == local machine
	initInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	initInfo.aDsScopeInfos = aScopeInit;
	initInfo.cAttributesToFetch = 1;
	static PCWSTR pwszDnsHostName = L"dNSHostName";
	initInfo.apwzAttributeNames = &pwszDnsHostName;

	//
	// Note object picker makes its own copy of initInfo.  Also note
	// that Initialize may be called multiple times, last call wins.
	//

	return pDsObjectPicker->Initialize(&initInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   CHOOSER2_ProcessSelectedObjects
//
//  Synopsis:   Retrieve the name of the selected item from the data object
//              created by the object picker
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Created
//              12-08-1999   JonN       Copied from CHOOSER
//
//---------------------------------------------------------------------------

HRESULT CHOOSER2_ProcessSelectedObjects(
    IDataObject* pdo,
    BSTR* pbstrComputerName)
{
	if ( !pdo )
		return E_POINTER;

	HRESULT hr = S_OK;
	static UINT g_cfDsObjectPicker =
		RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		(CLIPFORMAT)g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	bool fGotStgMedium = false;

	do
	{
		hr = pdo->GetData(&formatetc, &stgmedium);
		if ( SUCCEEDED (hr) )
		{
			fGotStgMedium = true;

			PDS_SELECTION_LIST pDsSelList =
				(PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

			if (!pDsSelList)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());
				break;
			}

			if ( 1 == pDsSelList->cItems )
			{
				PDS_SELECTION psel = &(pDsSelList->aDsSelection[0]);
				VARIANT* pvarDnsName = &(psel->pvarFetchedAttributes[0]);
				if (   NULL == pvarDnsName
				    || VT_BSTR != pvarDnsName->vt
				    || NULL == pvarDnsName->bstrVal
				    || L'\0' == (pvarDnsName->bstrVal)[0] )
				{
					*pbstrComputerName = SysAllocString(
                        psel->pwzName);
				} else {
					*pbstrComputerName = SysAllocString(
                        pvarDnsName->bstrVal);
				}
			}
			else
				hr = E_UNEXPECTED;
			

			GlobalUnlock(stgmedium.hGlobal);
		}
	} while (0);

	if (fGotStgMedium)
	{
		ReleaseStgMedium(&stgmedium);
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//  History:    12-08-1999   JonN       Copied from CHOOSER
//
//////////////////////////////////////////////////////////////////////////////
HRESULT	CHOOSER2_ComputerNameFromObjectPicker (
    HWND hwndParent,
    BSTR* pbstrTargetComputer)
{
	//
	// Create an instance of the object picker.  The implementation in
	// objsel.dll is apartment model.
	//
	CComPtr<IDsObjectPicker> spDsObjectPicker;
	HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
	                              NULL,
	                              CLSCTX_INPROC_SERVER,
	                              IID_IDsObjectPicker,
	                              (void **) &spDsObjectPicker);
	if ( SUCCEEDED (hr) )
	{
		//
		// Initialize the object picker to choose computers
		//

		hr = CHOOSER2_InitObjectPickerForComputers(spDsObjectPicker);
		if ( SUCCEEDED (hr) )
		{
			//
			// Now pick a computer
			//
			CComPtr<IDataObject> spDataObject;

			hr = spDsObjectPicker->InvokeDialog(
                hwndParent,
                &spDataObject);
			if ( S_OK == hr )
			{
				hr = CHOOSER2_ProcessSelectedObjects(
                    spDataObject,
                    pbstrTargetComputer);
			}
		}
	}

	return hr;
}


const ULONG g_aHelpIDs_CHOOSER2[]=
{
	IDC_CHOOSER2_RADIO_LOCAL_MACHINE,	IDC_CHOOSER2_RADIO_LOCAL_MACHINE,
	IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE,	IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE,
	IDC_CHOOSER2_EDIT_MACHINE_NAME,	IDC_CHOOSER2_EDIT_MACHINE_NAME,
	IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES,	IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES,
	IDD_CHOOSER2,	(ULONG)-1,
	0, 0
};


INT_PTR CALLBACK CHOOSER2_TargetComputerDialogFunc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            Edit_LimitText(
                GetDlgItem(hwndDlg,IDC_CHOOSER2_EDIT_MACHINE_NAME),
                MAX_PATH+2);

            // lParam is pbstrTargetComputer
            BSTR* pbstrTargetComputer = (BSTR*)lParam;
            (void) SetWindowLongPtr(
                hwndDlg,
                DWLP_USER,
                (LONG_PTR)pbstrTargetComputer );
            (void) SendMessage(
                GetDlgItem(hwndDlg,IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE),
                BM_SETCHECK,
                BST_CHECKED,
                0 );
            (void) SetFocus(
                GetDlgItem(hwndDlg,IDC_CHOOSER2_EDIT_MACHINE_NAME));
        }
        break;
    case WM_COMMAND:
            switch (LOWORD(wParam))
            {
            case IDOK:
                if (BST_CHECKED == IsDlgButtonChecked(
                        hwndDlg,
                        IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE ))
                {
                    WCHAR achTarget[MAX_PATH+3]; // allow for whackwhack
                    ZeroMemory( achTarget, sizeof(achTarget) );
                    GetDlgItemText(
                        hwndDlg,
                        IDC_CHOOSER2_EDIT_MACHINE_NAME,
                        achTarget,
                        MAX_PATH+2);
                    BSTR* pbstrTargetComputer =
                        (BSTR*)GetWindowLongPtr( hwndDlg, DWLP_USER );
                    LPCWSTR pcszTargetComputer = achTarget;
                    while (L'\\' == *pcszTargetComputer)
                        pcszTargetComputer++;
                    if (L'\0' != *pcszTargetComputer)
                        *pbstrTargetComputer = SysAllocString(pcszTargetComputer);
                }
                EndDialog( hwndDlg, 1 );
                break;
            case IDCANCEL:
                EndDialog( hwndDlg, 0 );
                break;
            case IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES:
                {
                    CComBSTR sbstrTargetComputer;
                    HRESULT hr = CHOOSER2_ComputerNameFromObjectPicker(
                        hwndDlg,
                        &sbstrTargetComputer );
                    if ( SUCCEEDED(hr) )
                    {
                        LPCWSTR pcszTargetComputer =
                            (!sbstrTargetComputer)
                                ? NULL
                                : (LPCWSTR)sbstrTargetComputer;
                        SetDlgItemText(
                            hwndDlg,
                            IDC_CHOOSER2_EDIT_MACHINE_NAME,
                            pcszTargetComputer );
                    }
                }
                break;
            case IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE:
            case IDC_CHOOSER2_RADIO_LOCAL_MACHINE:
                (void) EnableWindow(
                    GetDlgItem(hwndDlg,IDC_CHOOSER2_EDIT_MACHINE_NAME),
                    (IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE == LOWORD(wParam))
                        ? TRUE
                        : FALSE );
                (void) EnableWindow(
                    GetDlgItem(hwndDlg,
                               IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES),
                    (IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE == LOWORD(wParam))
                        ? TRUE
                        : FALSE );
                break;
            default:
                break;
            }
        break;
    case WM_HELP:
        if (NULL != lParam)
        {
            const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            if (pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
                const HWND hwnd = (HWND)pHelpInfo->hItemHandle;
                (void) WinHelp(
                    hwnd,
                    _T("chooser.hlp"),
                    HELP_WM_HELP,
                    (ULONG_PTR)g_aHelpIDs_CHOOSER2);
            }
        }
        break;
    default:
        break;
    }
    return FALSE;
}
 

bool CHOOSER2_PickTargetComputer(
    IN  HINSTANCE hinstance,
    IN  HWND hwndParent,
    OUT BSTR* pbstrTargetComputer )
{
    if (NULL == pbstrTargetComputer)
        return false;
    INT_PTR nReturn = ::DialogBoxParam(
        hinstance,
        MAKEINTRESOURCE(IDD_CHOOSER2),
        hwndParent,
        CHOOSER2_TargetComputerDialogFunc,
        (LPARAM)pbstrTargetComputer );
    return (0 < nReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\chooser\chooser.h ===
/////////////////////////////////////////////////////////////////////
//	Chooser.h
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHOOSER_H_INCLUDED__
#define __CHOOSER_H_INCLUDED__

LPCTSTR PchGetMachineNameOverride();


#include "choosert.h"	// Temporary IDs
#include "chooserd.h"	// Default IDs


///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//////////////////////////////////////////////////////////////////////////////
HRESULT	ComputerNameFromObjectPicker (HWND hwndParent, CString& computerName);


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//	INHERITANCE TREE (so far)
//	CAutoDeletePropPage - Base object
//		CChooseMachinePropPage - Dialog to select a machine name
//			CFileMgmtGeneral - Dialog to select "File Services" (snapin\filemgmt\snapmgr.h)
//			CMyComputerGeneral - Dialog for the "My Computer" (snapin\mycomput\snapmgr.h)
//		CChoosePrototyperPropPage - Dialog to select prototyper demo (NYI)
//	
//	HISTORY
//	15-May-1997		t-danm		Creation. Split of CChooseMachinePropPage
//					to allow property pages to have more flexible dialog
//					templates.
//
class CAutoDeletePropPage : public CPropertyPage
{
public:
// Construction
	CAutoDeletePropPage(UINT uIDD);
	virtual ~CAutoDeletePropPage();

protected:
// Dialog Data
	//{{AFX_DATA(CAutoDeletePropPage)
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAutoDeletePropPage)
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAutoDeletePropPage)
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// This mechanism deletes the CAutoDeletePropPage object
	// when the wizard is finished
	struct
		{
		INT cWizPages;	// Number of pages in wizard
		LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
		} m_autodeleteStuff;

	static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);


protected:
	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
	
public:
	/////////////////////////////////////////////////////////////////////	
	void SetCaption(UINT uStringID);
	void SetCaption(LPCTSTR pszCaption);
	void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);
}; // CAutoDeletePropPage


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CChooseMachinePropPage
//
//	This object is a stand-alone property page used to
//	select a computer name.
//
//	The object CChooseMachinePropPage can have its dialog
//	template replaced to allow a new wizard without any new code.
//	The object can also be inherited, allowing easy extentionability.
//
//	RESTRICTIONS:
//	If the user wishes to provide its own dialog template, here
//	are the dialog IDs that must present:
//		IDC_CHOOSER_RADIO_LOCAL_MACHINE - Select local machine.
//		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE - Select a specific machine.
//		IDC_CHOOSER_EDIT_MACHINE_NAME - Edit field to enter the machine name.
//	There are also optional IDs:
//		IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES - Browse to select a machine name.
//		IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME - Checkbox to allow the machine name to be overriden by command line.
//
class CChooseMachinePropPage : public CAutoDeletePropPage
{
public:
	enum { IID_DEFAULT = IDD_CHOOSER_CHOOSE_MACHINE };

public:
// Construction
	CChooseMachinePropPage(UINT uIDD = IID_DEFAULT);
	virtual ~CChooseMachinePropPage();

protected:
	void InitRadioButtons();

// Dialog Data
	//{{AFX_DATA(CChooseMachinePropPage)
	enum { IDD = IDD_CHOOSER_CHOOSE_MACHINE };
	BOOL m_fIsRadioLocalMachine;		// TRUE => Local Machine is selected
	BOOL m_fAllowOverrideMachineName;	// TRUE => Machine name can be overriden from command line
	CString	m_strMachineName;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseMachinePropPage)
	public:
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseMachinePropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioLocalMachine();
	afx_msg void OnRadioSpecificMachine();
	afx_msg void OnChooserButtonBrowseMachinenames();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	HWND m_hwndCheckboxOverride;

protected:
	BOOL * m_pfAllowOverrideMachineNameOut;	// OUT: Pointer to BOOL receiving flag wherever to override machine name
	CString * m_pstrMachineNameOut;	// OUT: Pointer to the CString object to store the machine name
	CString * m_pstrMachineNameEffectiveOut;	// OUT: Pointer to the CString object to store the effective machine name

public:
	void InitMachineName(LPCTSTR pszMachineName);
	void SetOutputBuffers(
		OUT CString * pstrMachineNamePersist,
		OUT OPTIONAL BOOL * pfAllowOverrideMachineName,
		OUT OPTIONAL CString * pstrMachineNameEffective);

}; // CChooseMachinePropPage


#endif // ~__CHOOSER_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\amcpriv.h ===
#ifndef __AMC_PRIV_H__
#define __AMC_PRIV_H__



#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


#include "ndmgr.h"

//
//  TVOWNED_MAGICWORD
//

const COMPONENTID TVOWNED_MAGICWORD = (long)(0x03951589);



#define MMCNODE_NO_CHANGE          0
#define MMCNODE_NAME_CHANGE        1
#define MMCNODE_TARGET_CHANGE      2


//////////////////////////////////////////////////////////////////////////////
//
// SViewUpdateInfo and related defines.
//

typedef CList<HMTNODE, HMTNODE> CHMTNODEList;

struct SViewUpdateInfo
{
    SViewUpdateInfo() : newNode(0), insertAfter(0), flag(0) {}

    CHMTNODEList    path;
    HMTNODE         newNode;
    HMTNODE         insertAfter;
    DWORD           flag;
};


// The following are values of params sent to the views OnUpdate(lHint, pHint)
// lHint will be one of the VIEW_UPDATE_xxx's defined below.
// pHint will be a ptr to SViewUpdateInfo struct.

// VIEW_UPDATE_ADD is sent when a new node needs to be added.
// SViewUpdateInfo.flag         - unused
// SViewUpdateInfo.newNode      - the new node to be added
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_ADD             786


// VIEW_UPDATE_SELFORDELETE is sent when a node needs to ABOUT to be deleted.
// SViewUpdateInfo.flag         - 0 => delete only child items.
//                              - DELETE_THIS => delete this item.
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_SELFORDELETE    787

// VIEW_UPDATE_DELETE is sent when a node needs to be deleted.
// SViewUpdateInfo.flag         - 0 => delete only child items.
//                              - DELETE_THIS => delete this item.
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_DELETE          788
#define VUI_DELETE_THIS             1
#define VUI_DELETE_SETAS_EXPANDABLE 2


// VIEW_UPDATE_DELETE_EMPTY_VIEW is sent after the VIEW_UPDATE_DELETE is sent.
// No parameters.
#define VIEW_UPDATE_DELETE_EMPTY_VIEW   789


// VIEW_UPDATE_MODIFY is sent when a node needs to be modified.
// SViewUpdateInfo.flag         - REFRESH_NODE => Only node needs to be refreshed
//                                REFRESH_RESULTVIEW => Both node and result view need refresh. 
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_MODIFY          790
#define VUI_REFRESH_NODE            1
#define VUI_REFRESH_RESULTVIEW      2



#define VIEW_RESELECT               791


#endif // __AMC_PRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\amcmsgid.h ===
#ifndef _AMCMSGID_H
#define _AMCMSGID_H

// Base message starting
#define MMC_MSG_START                       WM_USER + 1100

#define MMC_MSG_STAT_POP                    MMC_MSG_START+1
#define MMC_MSG_STAT_PUSH                   MMC_MSG_START+2
#define MMC_MSG_STAT_UPDATE                 MMC_MSG_START+3
#define MMC_MSG_STAT_3D                     MMC_MSG_START+4
#define MMC_MSG_UPDATEALLSCOPES             MMC_MSG_START+5
#define MMC_MSG_PROP_SHEET_NOTIFY           MMC_MSG_START+6

// MMC_MMCNODE_UPDATE: Sent when a property sheet is closed for MMC nodes.
//
#define MMC_MSG_MMCNODE_UPDATE              MMC_MSG_START+7

// MMC_MSG_GETFOCUSED_ITEM: This msg is sent to the AMCView. 
// The return value is the currently selected scope items HNODE.
// long* plResultItemCookie = (long*)WPARAM;
// LPARAM is unsed.
// If the SCOPE item has focus lResultItemCookie & lResultItemComponentID
// should be set to 0.
//
#define MMC_MSG_GETFOCUSED_ITEM             MMC_MSG_START+8


// Message to set temporary selection. Used to set selection to the tree ctrl
// item that was right clicked. 
// HTREEITEM htiRClicked = (HTREEITEM)wParam;
// lParam unused
#define MMC_MSG_SETTEMPSEL                  MMC_MSG_START+8

// Message to remove temporary selection. Used when the context menu is just
// destroyed to set selection back to the selected item.
// wParam unused
// lParam unused
#define MMC_MSG_REMOVETEMPSEL               MMC_MSG_START+9


// Message is sent when ever the list view gets a focus change
// 
// wParam unused
// lParam unused
#define MMC_MSG_FOCUSCHANGE               MMC_MSG_START+10


// Message returns a pointer IFramePrivate IConsoleVerb for the view
// 
// wParam unused
// lParam unused
#define MMC_MSG_GETCONSOLE_VERB           MMC_MSG_START+11


// Message returns a pointer handle to the Description bar window
// 
// wParam unused
// lParam unused
#define MMC_MSG_GETDESCRIPTION_CTRL       MMC_MSG_START+12


// Message returns the HWND of the current SCOPE pane. 
// 
// wParam unused
// lParam unused
#define MMC_MSG_GETFOCUSEDSCOPEPANE       MMC_MSG_START+13


// Message to reselect the curr selection. 
// 
// wParam unused
// lParam unused
#define MMC_MSG_RESELECT                  MMC_MSG_START+14


// Message to reselect the curr selection. 
// 
// wParam unused
// lParam unused
#define MMC_MSG_COMPARE_IDATAOBJECT       MMC_MSG_START+15

// Message to show action or view menu (TEMPTEMP) WayneSc
// 
// wParam - Action 1 or View 2
// lParam - Loword x and hiword y
#define MMC_MSG_SHOWCONUI_MENUS           MMC_MSG_START+16

// Message to get hold of an interface to pass back to a 
//         control within a html page
// 
// wParam - unknown
// lParam - pointer to interface
#define MMC_MSG_GETHTMLINTERFACE          MMC_MSG_START+17


#define MMC_MSG_GET_SELECTED_COUNT        MMC_MSG_START+18


#define MMC_MSG_SAVE_TREE                 MMC_MSG_START+19


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\bitmap.h ===
// bitmap.h : definition file
//


#ifndef __BITMAP__H__
#define __BITMAP__H__

    HBITMAP CopyBitmap(HBITMAP hbm);

#endif //__BITMAP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\atlimpl.cpp ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLBASE_H__
	#error atlimpl.cpp requires atlbase.h to be included first
#endif

const IID IID_IRegister = {0xCC118C81,0xB379,0x11CF,{0x84,0xE3,0x00,0xAA,0x00,0x21,0xF3,0x37}};
const CLSID CLSID_Register = {0xCC118C85,0xB379,0x11CF,{0x84,0xE3,0x00,0xAA,0x00,0x21,0xF3,0x37}};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

CComBSTR& CComBSTR::operator=(const CComBSTR& src)
{
	if (m_str != src.m_str)
	{
		if (m_str)
			::SysFreeString(m_str);
		m_str = src.Copy();
	}
	return *this;
}

CComBSTR& CComBSTR::operator=(LPCOLESTR pSrc)
{
	if (m_str)
		::SysFreeString(m_str);

	m_str = ::SysAllocString(pSrc);
	return *this;
}

#ifndef OLE2ANSI
CComBSTR::CComBSTR(LPCSTR pSrc)
{
	USES_CONVERSION;
	m_str = ::SysAllocString(A2COLE(pSrc));
}

CComBSTR::CComBSTR(int nSize, LPCSTR sz)
{
	USES_CONVERSION;
	m_str = ::SysAllocStringLen(A2COLE(sz), nSize);
}

CComBSTR& CComBSTR::operator=(LPCSTR pSrc)
{
	USES_CONVERSION;
	if (m_str)
		::SysFreeString(m_str);

	m_str = ::SysAllocString(A2COLE(pSrc));
	return *this;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CComVariant

#ifndef OLE2ANSI
CComVariant::CComVariant(LPCSTR lpsz)
{
	USES_CONVERSION;
	VariantInit(this);
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpsz));
}

CComVariant& CComVariant::operator=(LPCSTR lpsz)
{
	USES_CONVERSION;
	VariantClear(this);
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpsz));
	return *this;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

IUnknown* WINAPI _AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

IUnknown* WINAPI _AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

void WINAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
}

HRESULT WINAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

HRESULT WINAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

HRESULT AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// CComTypeInfoHolder

void CComTypeInfoHolder::AddRef()
{
	_Module.m_csTypeInfoHolder.Lock();
	m_dwRef++;
	_Module.m_csTypeInfoHolder.Unlock();
}

void CComTypeInfoHolder::Release()
{
	_Module.m_csTypeInfoHolder.Lock();
	if (--m_dwRef == 0)
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	_Module.m_csTypeInfoHolder.Unlock();
}

HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't initialize properly
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	_ASSERTE(ppInfo != NULL);
	*ppInfo = NULL;

	HRESULT hRes = E_FAIL;
	_Module.m_csTypeInfoHolder.Lock();
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			ITypeInfo* pTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
			if (SUCCEEDED(hRes))
				m_pInfo = pTypeInfo;
			pTypeLib->Release();
		}
	}
	*ppInfo = m_pInfo;
	if (m_pInfo != NULL)
	{
		m_pInfo->AddRef();
		hRes = S_OK;
	}
	_Module.m_csTypeInfoHolder.Unlock();
	return hRes;
}

HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = E_POINTER;
	if (pptinfo != NULL)
		hRes = GetTI(lcid, pptinfo);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		pInfo->Release();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		pInfo->Release();
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes)
{
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	_ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
	if (LoadString(_Module.GetResourceInstance(), nID, szDesc, 1024) == 0)
	{
		_ASSERTE(FALSE);
		lstrcpy(szDesc, _T("Unknown Error"));
	}
	AtlReportError(clsid, szDesc, iid, hRes);
	if (hRes == 0)
		hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	return hRes;
}

#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	USES_CONVERSION;
	return AtlReportError(clsid, A2CW(lpszDesc), iid, hRes);
}
#endif

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// QI implementation

#ifdef _ATL_DEBUG_QI
#define _DUMPIID(iid, name, hr) DumpIID(iid, name, hr)
#else
#define _DUMPIID(iid, name, hr) hr
#endif

HRESULT WINAPI CComObjectRoot::InternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	_ASSERTE(pThis != NULL);
	// First entry should be an offset (pFunc == 1)
	_ASSERTE(pEntries->pFunc == (_ATL_CREATORARGFUNC*)1);
#ifdef _ATL_DEBUG_QI
	LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
#endif // _ATL_DEBUG_QI
	if (ppvObject == NULL)
		return _DUMPIID(iid, pszClassName, E_POINTER);
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return _DUMPIID(iid, pszClassName, S_OK);
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == (_ATL_CREATORARGFUNC*)1) //offset
			{
				_ASSERTE(!bBlind);
				IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return _DUMPIID(iid, pszClassName, S_OK);
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return _DUMPIID(iid, pszClassName, hRes);
			}
		}
		pEntries++;
	}
	return _DUMPIID(iid, pszClassName, E_NOINTERFACE);
}

#ifdef _ATL_DEBUG_QI

HRESULT CComObjectRoot::DumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	USES_CONVERSION;
	CRegKey key;
	TCHAR szName[100];
	DWORD dwType,dw = sizeof(szName);

	LPOLESTR pszGUID = NULL;
	StringFromCLSID(iid, &pszGUID);
	OutputDebugString(pszClassName);
	OutputDebugString(_T(" - "));

	// Attempt to find it in the interfaces section
	key.Open(HKEY_CLASSES_ROOT, _T("Interface"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(szName);
		goto cleanup;
	}
	// Attempt to find it in the clsid section
	key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(_T("(CLSID\?\?\?) "));
		OutputDebugString(szName);
		goto cleanup;
	}
	OutputDebugString(OLE2T(pszGUID));
cleanup:
	if (hr != S_OK)
		OutputDebugString(_T(" - failed"));
	OutputDebugString(_T("\n"));
	CoTaskMemFree(pszGUID);
	return hr;
}
#endif

HRESULT WINAPI CComObjectRoot::_Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	HRESULT hRes = E_NOINTERFACE;
	_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
	IUnknown** pp = (IUnknown**)((DWORD)pv + pcd->dwOffsetVar);
	if (*pp == NULL)
	{
		_ThreadModel::CriticalSection* pcs =
			(_ThreadModel::CriticalSection*)((int)pv + pcd->dwOffsetCS);
		pcs->Lock();
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
		pcs->Unlock();
	}
	if (*pp != NULL)
		hRes = (*pp)->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRoot::_Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
	return pcd->pFunc(pv, iid, ppvObject);
}

HRESULT WINAPI CComObjectRoot::_Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	HRESULT hRes = E_NOINTERFACE;
	IUnknown* p = *(IUnknown**)((DWORD)pv + dw);
	if (p != NULL)
		hRes = p->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRoot::_Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
	void* p = (void*)((DWORD)pv + pcd->dwOffset);
	return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
}

/////////////////////////////////////////////////////////////////////////////
// CComClassFactory

STDMETHODIMP CComClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
	REFIID riid, void** ppvObj)
{
	_ASSERTE(m_pfnCreateInstance != NULL);
	HRESULT hRes = E_POINTER;
	if (ppvObj != NULL)
	{
		*ppvObj = NULL;
		// can't ask for anything other than IUnknown when aggregating
		_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid));
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			hRes = CLASS_E_NOAGGREGATION;
		else
			hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	return hRes;
}

STDMETHODIMP CComClassFactory::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

STDMETHODIMP CComClassFactory2Base::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

CComConnectionPointBase* CComConnectionPointContainerImpl::
	FindConnPoint(REFIID riid)
{
	const _ATL_CONNMAP_ENTRY* pEntry = GetConnMap();
	while (pEntry->dwOffset != (DWORD)-1)
	{
		CComConnectionPointBase* pCP =
			(CComConnectionPointBase*)((int)this+pEntry->dwOffset);
		if (InlineIsEqualGUID(riid, *pCP->GetIID()))
			return pCP;
		pEntry++;
	}
	return NULL;
}


void CComConnectionPointContainerImpl::InitCloneVector(
	CComConnectionPointBase** ppCP)
{
	const _ATL_CONNMAP_ENTRY* pEntry = GetConnMap();
	while (pEntry->dwOffset != (DWORD)-1)
	{
		*ppCP = (CComConnectionPointBase*)((int)this+pEntry->dwOffset);
		ppCP++;
		pEntry++;
	}
}


STDMETHODIMP CComConnectionPointContainerImpl::EnumConnectionPoints(
	IEnumConnectionPoints** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComEnumConnectionPoints* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;

	// count the entries in the map
	_ATL_CONNMAP_ENTRY* pEntry = (_ATL_CONNMAP_ENTRY*)GetConnMap();
	int nCPCount=0;
	while (pEntry->dwOffset != (DWORD)-1)
	{
		nCPCount++;
		pEntry++;
	}
	_ASSERTE(nCPCount > 0);

	// allocate an initialize a vector of connection point object pointers
	CComConnectionPointBase** ppCP = (CComConnectionPointBase**)alloca(sizeof(CComConnectionPointBase*)*nCPCount);
	InitCloneVector(ppCP);

	// copy the pointers: they will AddRef this object
	HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
		(IConnectionPoint**)&ppCP[nCPCount], this, AtlFlagCopy);
	if (FAILED(hRes))
	{
		delete pEnum;
		return hRes;
	}
	hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}


STDMETHODIMP CComConnectionPointContainerImpl::FindConnectionPoint(
	REFIID riid, IConnectionPoint** ppCP)
{
	if (ppCP == NULL)
		return E_POINTER;
	*ppCP = NULL;
	HRESULT hRes = CONNECT_E_NOCONNECTION;
	CComConnectionPointBase* pCP = FindConnPoint(riid);
	if (pCP != NULL)
	{
		pCP->AddRef();
		*ppCP = pCP;
		hRes = S_OK;
	}
	return hRes;
}


BOOL CComDynamicArrayCONNECTDATA::Add(IUnknown* pUnk)
{
	if (m_nSize == 0) // no connections
	{
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		m_nSize = 1;
		return TRUE;
	}
	else if (m_nSize == 1)
	{
		//create array
		m_pCD = (CONNECTDATA*)malloc(sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		memset(m_pCD, 0, sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		m_pCD[0] = m_cd;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	int nAlloc = m_nSize*2;
	m_pCD = (CONNECTDATA*)realloc(m_pCD, sizeof(CONNECTDATA)*nAlloc);
	memset(&m_pCD[m_nSize], 0, sizeof(CONNECTDATA)*m_nSize);
	m_pCD[m_nSize].pUnk = pUnk;
	m_pCD[m_nSize].dwCookie = (DWORD)pUnk;
	m_nSize = nAlloc;
	return TRUE;
}

BOOL CComDynamicArrayCONNECTDATA::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	if (m_nSize == 1)
	{
		if (m_cd.dwCookie == dwCookie)
		{
			m_nSize = 0;
			return TRUE;
		}
		return FALSE;
	}
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionInterface(IID* piid)
{
	if (piid == NULL)
		return E_POINTER;
	*piid = *(IID*)GetIID();
	return S_OK;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
	if (ppCPC == NULL)
		return E_POINTER;
	_ASSERTE(m_pContainer != NULL);
	*ppCPC = m_pContainer;
	m_pContainer->AddRef();
	return S_OK;
}

#endif //!_ATL_NO_CONNECTION_POINTS

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	_ASSERTE(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return lpszTemp-lpszPathName;
}

/////////////////////////////////////////////////////////////////////////////
// Object Registry Support

static HRESULT WINAPI AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

HRESULT WINAPI CComModule::UpdateRegistryFromResource(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CComPtr<IRegister> p;
	HRESULT hRes = CoCreateInstance(CLSID_Register, NULL,
		CLSCTX_INPROC_SERVER, IID_IRegister, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
		p->AddReplacement(CComBSTR(OLESTR("Module")), CComBSTR(szModule));
		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);

				CComBSTR bstrKey(pMapEntries->szKey);
				CComBSTR bstrValue(pMapEntries->szData);
				p->AddReplacement(bstrKey, bstrValue);
				pMapEntries++;
			}
		}

		CComVariant varRes;
		varRes.vt = VT_I2;
		varRes.iVal = (short)nResID;
		CComVariant varReg(OLESTR("REGISTRY"));
		GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
		CComBSTR bstrModule = szModule;
		if (bRegister)
		{
			hRes = p->ResourceRegister(bstrModule, varRes, varReg);
		}
		else
		{
			hRes = p->ResourceUnregister(bstrModule, varRes, varReg);
		}
	}
	return hRes;
}

HRESULT WINAPI CComModule::UpdateRegistryFromResource(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CComPtr<IRegister> p;
	HRESULT hRes = CoCreateInstance(CLSID_Register, NULL,
		CLSCTX_INPROC_SERVER, IID_IRegister, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
		p->AddReplacement(CComBSTR(OLESTR("Module")), CComBSTR(szModule));
		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);

				CComBSTR bstrKey(pMapEntries->szKey);
				CComBSTR bstrValue(pMapEntries->szData);

				p->AddReplacement(bstrKey, bstrValue);
				pMapEntries++;
			}
		}
		CComVariant varRes(lpszRes);
		CComVariant varReg(OLESTR("REGISTRY"));
		GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
		CComBSTR bstrModule = szModule;
		if (bRegister)
		{
			hRes = p->ResourceRegister(bstrModule, varRes, varReg);
		}
		else
		{
			hRes = p->ResourceUnregister(bstrModule, varRes, varReg);
		}
	}
	return hRes;
}

#ifdef _ATL_STATIC_REGISTRY
// Statically linking to Registry Ponent
HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CRegObject      ro;
	CRegException   re;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	ro.AddReplacement(OLESTR("Module"), CComBSTR(szModule));
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(CComBSTR(pMapEntries->szKey),
				CComBSTR(pMapEntries->szData));
			pMapEntries++;
		}
	}

	CComVariant varRes;
	varRes.vt = VT_I2;
	varRes.iVal = (short)nResID;
	CComVariant varReg(OLESTR("REGISTRY"));
	GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
	CComBSTR bstrModule = szModule;
	return (bRegister) ? ro.ResourceRegister(bstrModule, varRes, varReg, re) :
		ro.ResourceUnregister(bstrModule, varRes, varReg, re);
}

HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CRegObject      ro;
	CRegException   re;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	ro.AddReplacement(OLESTR("Module"), CComBSTR(szModule));
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(CComBSTR(pMapEntries->szKey),
				CComBSTR(pMapEntries->szData));
			pMapEntries++;
		}
	}

	CComVariant varRes(lpszRes);
	CComVariant varReg(OLESTR("REGISTRY"));
	GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
	CComBSTR bstrModule = szModule;
	return (bRegister) ? ro.ResourceRegister(bstrModule, varRes, varReg, re) :
		ro.ResourceUnregister(bstrModule, varRes, varReg, re);
}
#endif // _ATL_STATIC_REGISTRY

HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

	hRes = AtlRegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					key.SetKeyValue(szLS32, szModule);
				else
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;
	key.Attach(HKEY_CLASSES_ROOT);
	key.RecurseDeleteKey(lpszProgID);
	key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID")) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

HRESULT CComModule::RegisterTypeLib(LPCTSTR lpszIndex)
{
	USES_CONVERSION;
	_ASSERTE(m_hInst != NULL);
	TCHAR szModule[_MAX_PATH+10];
	OLECHAR szDir[_MAX_PATH];
	GetModuleFileName(GetTypeLibInstance(), szModule, _MAX_PATH);
	if (lpszIndex != NULL)
		lstrcat(szModule, lpszIndex);
	ITypeLib* pTypeLib;
	LPOLESTR lpszModule = T2OLE(szModule);
	HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, &pTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		ocscpy(szDir, lpszModule);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, lpszModule, szDir);
	}
	if (pTypeLib != NULL)
		pTypeLib->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifndef _ATL_NO_SECURITY

CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	m_pSD = new SECURITY_DESCRIPTOR;
	if (!m_pSD)
		return E_OUTOFMEMORY;
	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		_ASSERTE(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (!m_pOwner)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (!m_pGroup)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (!ptkUser)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (!ptkGroup)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pszRefDomain = new TCHAR[dwDomainSize];
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			if (!(m_pDACL = (PACL) malloc(pDACL->AclSize)))
				goto failed;

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			if (!(m_pSACL = (PACL) malloc(pSACL->AclSize)))
				goto failed;

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSD)
		free(m_pSD);
	return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	newACL = (PACL) new BYTE[aclSize];

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	newACL = (PACL) new BYTE[aclSize];

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	PSID principalSID;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			free(principalSID);
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		}
	}
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID luid;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			return hr;
		}
	}

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	return S_OK;
}


#endif //_ATL_NO_SECURITY

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
void _cdecl AtlTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = _vstprintf(szBuffer, lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer));

	OutputDebugString(szBuffer);
	va_end(args);
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MIN_CRT

#ifdef _ATL_MIN_CRT
/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

int __cdecl _purecall()
{
	DebugBreak();
	return 0;
}

extern "C" const int _fltused = 0;

void* __cdecl malloc(size_t n)
{
	if (_Module.m_hHeap == NULL)
	{
		_Module.m_hHeap = HeapCreate(0, 0, 0);
		if (_Module.m_hHeap == NULL)
			return NULL;
	}
	_ASSERTE(_Module.m_hHeap != NULL);

#ifdef _MALLOC_ZEROINIT
	void* p = HeapAlloc(_Module.m_hHeap, 0, n);
	if (p != NULL)
		memset(p, 0, n);
	return p;
#else
	return HeapAlloc(_Module.m_hHeap, 0, n);
#endif
}

void* __cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
	return malloc(n * s);
#else
	void* p = malloc(n * s);
	if (p != NULL)
		memset(p, 0, n * s);
	return p;
#endif
}

void* __cdecl realloc(void* p, size_t n)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, 0, p, n);
}

void __cdecl free(void* p)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	if (p != NULL)
		HeapFree(_Module.m_hHeap, 0, p);
}

void* __cdecl operator new(size_t n)
{
	return malloc(n);
}

void __cdecl operator delete(void* p)
{
	free(p);
}

#endif  //_DEBUG

#endif //_ATL_MIN_CRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\autosnap.h ===
#ifndef AUTOSNAP_H
#define AUTOSNAP_H
// This header contains _TEMPORARY_ support allowing automation hooks into the
// console.  This file will eventually go away!
// See dburg before changing, or modifying.

#ifndef COMPTR_H
#include "comptr.h"
#endif

class IAutoSnapInInit : public IUnknown
{
public:
    STDMETHOD(InitAutoSnapIn)(const CLSID&, IUnknown*)=0;
}; // class IAutoSnapInInit

extern IID IID_IAutoSnapInInit;
DEFINE_CIP(IAutoSnapInInit)
#define CLSID_AutoSnapIn IID_IAutoSnapInInit

#ifndef __mmc_h__
struct IComponentData;
#endif
HRESULT CreateSnapIn(const CLSID&, IComponentData**);

#endif // AUTOSNAP_H

#ifdef IMPLEMENT_AUTOSNAP_GUIDS
// {32A0B2B8-90C5-11d0-8F54-00A0C91ED3C8}
IID IID_IAutoSnapInInit = 
{ 0x32a0b2b8, 0x90c5, 0x11d0, { 0x8f, 0x54, 0x0, 0xa0, 0xc9, 0x1e, 0xd3, 0xc8 } };
#endif // IMPLEMENT_AUTOSNAP_GUIDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\bitmap.cpp ===
// bitmap.cpp : implementation file
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:      bitmap.cpp
//
//  Contents:  Helper functions to copy bitmaps
//
//  History:   27-Feb-97 WayneSc    Created
//             
//
//--------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>


HBITMAP CopyBitmap(HBITMAP hbm)
{
    HDC     hMemDCsrc;
    HDC     hMemDCdst;
    HDC     hdc;
    HBITMAP hNewBm;
    BITMAP  bm;

    if (!hbm)
         return NULL;

    hdc = GetDC (NULL);
    hMemDCsrc = CreateCompatibleDC (hdc);
    hMemDCdst = CreateCompatibleDC (hdc);

    GetObject (hbm, sizeof(BITMAP), (LPSTR)&bm);

    /*hNewBm = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++ (dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL);*/
    hNewBm = CreateBitmap(bm.bmWidth, bm.bmHeight, bm.bmPlanes, bm.bmBitsPixel, NULL);
    if (hNewBm){
        SelectObject (hMemDCsrc, hbm);
        SelectObject (hMemDCdst, hNewBm);

        BitBlt (hMemDCdst,
                0,
                0,
                bm.bmWidth,
                bm.bmWidth,
                hMemDCsrc,
                0,
                0,
                SRCCOPY);
    }

    ReleaseDC (NULL,hdc);
    DeleteDC (hMemDCsrc);
    DeleteDC (hMemDCdst);
    return hNewBm;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\assert.cpp ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>
#include <shlwapi.h> // wvnsprintf

#if DBG==1

#define new DEBUG_NEW

#include "admindbg.h"
#include "malloc.h" // alloca

//
//  Globals
//

ULONG AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//
//  Forward declaration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
int   w4dprintf(LPTSTR format, ...);
int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

int w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

int w4smprintf(LPTSTR  format, va_list arglist)
{
    TCHAR szMessageBuf[500];        // this is the message buffer
    int ret;

    ret = wvnsprintf(szMessageBuf, 500, format, arglist);
    OutputDebugString(szMessageBuf);
    return ret;
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        (ulCompMask | (DEB_ERROR | DEB_WARN)))
    {
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if (((DEB_ERROR | DEB_WARN) & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
            }
            w4smprintf(ppszfmt, pargs);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
#define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADMINDEBUGKEY, 0,
                                            KEY_ALL_ACCESS, &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                                                    KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                   REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = (DEB_ERROR | DEB_WARN);

            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                        (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}


// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':')
                            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return (LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static CHAR szModuleName[128];
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    wsprintf(szAssertCaption, _T("%hs: Assertion Failed"), pProcess);


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    wsprintf(szDetails, _T(" Assertion:\t %s\n\n")       \
                        _T(" File:   \t\t %hs\n")        \
                        _T(" Line:   \t\t %d\n\n")       \
                        _T(" Module:   \t %hs\n")        \
                        _T(" Thread ID:\t %d.%d\n"),
                        szMsg, szFile, iLine, pszModuleName, pid, tid);


    int id = MessageBox(NULL,
                    szDetails,
                    szAssertCaption,
                    MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
            szMessage, pszFileName, iLine, tid);
    }

    if (AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (AdminAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________

CDbg::CDbg(LPTSTR  str)
    :
    m_InfoLevelString(str),
    m_InfoLevel(DEB_ERROR | DEB_WARN)
{
    CheckInit(m_InfoLevelString, &m_InfoLevel);
}

void CDbg::Trace(LPSTR pszfmt, ...)
{
#ifdef UNICODE
    size_t convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, (int) convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::Trace(LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    size_t convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, (int) convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    size_t convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, (int) convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                                                      err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    ptcMsg = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcMsg[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\cclv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0106 */
/* at Thu Jun 19 11:53:57 1997
 */
/* Compiler settings for cclv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __cclv_h__
#define __cclv_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef ___DCCListView_FWD_DEFINED__
#define ___DCCListView_FWD_DEFINED__
typedef interface _DCCListView _DCCListView;
#endif 	/* ___DCCListView_FWD_DEFINED__ */


#ifndef ___DCCListViewEvents_FWD_DEFINED__
#define ___DCCListViewEvents_FWD_DEFINED__
typedef interface _DCCListViewEvents _DCCListViewEvents;
#endif 	/* ___DCCListViewEvents_FWD_DEFINED__ */


#ifndef __CCListView_FWD_DEFINED__
#define __CCListView_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCListView CCListView;
#else
typedef struct CCListView CCListView;
#endif /* __cplusplus */

#endif 	/* __CCListView_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_cclv_0000
 * at Thu Jun 19 11:53:57 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [local] */ 


typedef long CCLVItemID;



extern RPC_IF_HANDLE __MIDL_itf_cclv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cclv_0000_v0_0_s_ifspec;


#ifndef __CCLISTVIEWLib_LIBRARY_DEFINED__
#define __CCLISTVIEWLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: CCLISTVIEWLib
 * at Thu Jun 19 11:53:57 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [control][helpstring][version][uuid] */ 


#define	CCLV_HEADERPAD	( 15 )


EXTERN_C const IID LIBID_CCLISTVIEWLib;

#ifndef ___DCCListView_DISPINTERFACE_DEFINED__
#define ___DCCListView_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DCCListView
 * at Thu Jun 19 11:53:57 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [hidden][helpstring][uuid] */ 



EXTERN_C const IID DIID__DCCListView;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1B3C1392-D68B-11CF-8C2B-00AA003CA9F6")
    _DCCListView : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DCCListViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DCCListView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DCCListView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DCCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DCCListView __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DCCListView __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DCCListView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DCCListView __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DCCListViewVtbl;

    interface _DCCListView
    {
        CONST_VTBL struct _DCCListViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DCCListView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DCCListView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DCCListView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DCCListView_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DCCListView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DCCListView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DCCListView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DCCListView_DISPINTERFACE_DEFINED__ */


#ifndef ___DCCListViewEvents_DISPINTERFACE_DEFINED__
#define ___DCCListViewEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DCCListViewEvents
 * at Thu Jun 19 11:53:57 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [helpstring][uuid] */ 



EXTERN_C const IID DIID__DCCListViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1B3C1393-D68B-11CF-8C2B-00AA003CA9F6")
    _DCCListViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DCCListViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DCCListViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DCCListViewEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DCCListViewEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DCCListViewEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DCCListViewEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DCCListViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DCCListViewEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DCCListViewEventsVtbl;

    interface _DCCListViewEvents
    {
        CONST_VTBL struct _DCCListViewEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DCCListViewEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DCCListViewEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DCCListViewEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DCCListViewEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DCCListViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DCCListViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DCCListViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DCCListViewEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CCListView;

#ifdef __cplusplus

class DECLSPEC_UUID("1B3C1394-D68B-11CF-8C2B-00AA003CA9F6")
CCListView;
#endif
#endif /* __CCLISTVIEWLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\bool.h ===
#ifndef BOOL_H
#define BOOL_H

#ifndef ASSERT
#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif // _INC_CRTDBG
#define ASSERT(x) _ASSERT(x)
#endif // ASSERT

template<typename _PtrType> class AutoPtrDeleter {
public:
    typedef _PtrType PtrType;
    static void Delete(PtrType* p) {
        delete p;
        }
    }; // class AutoPtrDelete

template<typename _PtrType, typename _Deleter = AutoPtrDeleter<_PtrType> > class AutoPtr {
    public:
    typedef _PtrType PtrType;
    typedef _Deleter Deleter;
    AutoPtr() throw() : m_ptr(NULL) {}
    explicit AutoPtr(PtrType* p) throw() : m_ptr(p) {}
    ~AutoPtr() throw() {
        Delete();
        }
    PtrType* Detach() throw() {
        PtrType* const p = m_ptr;
        m_ptr = NULL;
        return p;
        }
    PtrType& operator*() const throw() {
        ASSERT(m_ptr != NULL);
        return *m_ptr;
        }
    PtrType* operator->() const throw() {
        ASSERT(m_ptr != NULL);
        return m_ptr;
        }
    operator PtrType*() const throw() {
        return m_ptr;
        }
    template<typename _PtrType2> bool operator==(_PtrType2 p) const throw() {
        return m_ptr == dynamic_cast<PtrType*>(p);
        }
    template<typename _PtrType2> bool operator!=(_PtrType2 p) const throw() {
        return m_ptr != dynamic_cast<PtrType*>(p);
        }
    bool operator==(int p) const throw() {
        ASSERT(p == NULL);
        return m_ptr == NULL;
        }
    bool operator!=(int p) const throw() {
        ASSERT(p == NULL);
        return m_ptr != NULL;
        }
    template<typename _PtrType2> bool operator<(_PtrType2 p) const throw() {
        return m_ptr < dynamic_cast<PtrType*>(p);
        }
    template<typename _PtrType2> bool operator>(_PtrType2 p) const throw() {
        return m_ptr > dynamic_cast<PtrType*>(p);
        }
    template<typename _PtrType2> bool operator<=(_PtrType2 p) const throw() {
        return m_ptr <= dynamic_cast<PtrType*>(p);
        }
    template<typename _PtrType2> bool operator>=(_PtrType2 p) const throw() {
        return m_ptr >= dynamic_cast<PtrType*>(p);
        }
    private:
    PtrType* m_ptr;
    explicit AutoPtr(const AutoPtr<PtrType>& p) throw();
    void Delete() throw() {
        if (m_ptr != NULL) {
            Deleter deleter;
            deleter.Delete(m_ptr);
            m_ptr = NULL;
            }
        }
    }; // class AutoPtr
        
#endif // BOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\comptrs.h ===
#ifndef COMPTRS_H
#define COMPTRS_H

#ifndef COMPTR_H
#include <comptr.h>
#endif

#if _MSC_VER < 1100

// Includes for Common IIDs
//REVIEW: these should probably be ifdefed so that all of these includes needn't be included.
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPISPI_H
#include <MAPISPI.H>
#endif
#ifndef _INC_VFW
#include <VFW.H>
#endif
//REVIEW: #ifndef __activscp_h__
//REVIEW: #include <ACTIVSCP.H>
//REVIEW: #endif
#ifndef __urlmon_h__
#include <URLMON.H>
#endif
#ifndef __datapath_h__
#include <DATAPATH.h>
#endif
#ifndef __RECONCIL_H__
#include <RECONCIL.H>
#endif
#ifndef _DAOGETRW_H_
#include <DAOGETRW.H>
#endif
#include <DBDAOID.H>
//REVIEW: #ifndef __comcat_h__
//REVIEW: #include <COMCAT.H>
//REVIEW: #endif
#include <SHLGUID.H>
#ifndef _SHLOBJ_H_
#include <SHLOBJ.H>
#endif
#ifndef __docobj_h__
#include <DOCOBJ.H>
#endif
#include <DBDAOID.H>
#ifndef __DDRAW_INCLUDED__
#include <DDRAW.H>
#endif
#ifndef __DPLAY_INCLUDED__
#include <DPLAY.H>
#endif
#ifndef __DSOUND_INCLUDED__
#include <DSOUND.H>
#endif
//REVIEW: #ifndef __hlink_h__
//REVIEW: #include <HLINK.H>
//REVIEW: #endif
//REVIEW: #ifndef _SHDocVw_H_
//REVIEW: #include <EXDISP.H>
//REVIEW: #endif
#ifndef MAPIFORM_H
#include <MAPIFORM.H>
#endif
#ifndef MAPIX_H
#include <MAPIX.H>
#endif
//REVIEW: #ifndef __objsafe_h__
//REVIEW: #include <OBJSAFE.H>
//REVIEW: #endif
#include <OLECTLID.H>
#ifndef _RICHEDIT_
#include <RICHEDIT.H>
#endif
#ifndef _RICHOLE_
#include <RICHOLE.H>
#endif
//REVIEW: #ifndef __INTSHCUT_H__
//REVIEW: #include <INTSHCUT.H>
//REVIEW: #endif
//REVIEW: #ifndef _WPObj_H_
//REVIEW: #include <WPOBJ.H>
//REVIEW: #endif
//REVIEW: #ifndef _wpapi_h_
//REVIEW: #include <WPAPI.H>
//REVIEW: #endif
//REVIEW: #ifndef _wpspi_h_
//REVIEW: #include <WPSPI.H>
//REVIEW: #endif
#ifndef EXCHEXT_H
#include <EXCHEXT.h>
#endif

// Standard cip's
DEFINE_CIP(IABContainer);
DEFINE_CIP(IABLogon);
DEFINE_CIP(IABProvider);
DEFINE_CIP(IAVIEditStream);
DEFINE_CIP(IAVIFile);
DEFINE_CIP(IAVIStream);
DEFINE_CIP(IAVIStreaming);
//REVIEW: DEFINE_CIP(IActiveScript);
//REVIEW: DEFINE_CIP(IActiveScriptError);
//REVIEW: DEFINE_CIP(IActiveScriptParse);
//REVIEW: DEFINE_CIP(IActiveScriptSite);
//REVIEW: DEFINE_CIP(IActiveScriptSiteWindow);
DEFINE_CIP(IAddrBook);
DEFINE_CIP(IAdviseSink);
DEFINE_CIP(IAdviseSink2);
DEFINE_CIP(IAdviseSinkEx);
//REVIEW: DEFINE_CIP(IAsyncMoniker);
//REVIEW: DEFINE_CIP(IAttachment);
DEFINE_CIP(IAuthenticate);
DEFINE_CIP(IBindCtx);
DEFINE_CIP(IBindHost);
DEFINE_CIP(IBindProtocol);
DEFINE_CIP(IBindStatusCallback);
DEFINE_CIP(IBinding);
DEFINE_CIP(IBriefcaseInitiator);
DEFINE_CIP(ICDAORecordset);
//REVIEW: DEFINE_CIP(ICatInformation);
//REVIEW: DEFINE_CIP(ICatRegister);
DEFINE_CIP(IChannelHook);
DEFINE_CIP(IClassActivator);
DEFINE_CIP(IClassFactory);
DEFINE_CIP(IClassFactory2);
DEFINE_CIP(IClientSecurity);
DEFINE_CIP(ICodeInstall);
DEFINE_CIP(ICommDlgBrowser);
DEFINE_CIP(IConnectionPoint);
DEFINE_CIP(IConnectionPointContainer);
DEFINE_CIP(IContextMenu);
DEFINE_CIP(IContextMenu2);
DEFINE_CIP(IContinue);
DEFINE_CIP(IContinueCallback);
DEFINE_CIP(ICreateErrorInfo);
DEFINE_CIP(ICreateTypeInfo);
DEFINE_CIP(ICreateTypeInfo2);
DEFINE_CIP(ICreateTypeLib);
DEFINE_CIP(ICreateTypeLib2);
//REVIEW: DEFINE_CIP(IDAOContainer);
//REVIEW: DEFINE_CIP(IDAOContainerW);
//REVIEW: DEFINE_CIP(IDAOContainers);
//REVIEW: DEFINE_CIP(IDAOContainersW);
//REVIEW: DEFINE_CIP(IDAODBEngine);
//REVIEW: DEFINE_CIP(IDAODBEngineW);
//REVIEW: DEFINE_CIP(IDAODatabase);
//REVIEW: DEFINE_CIP(IDAODatabaseW);
//REVIEW: DEFINE_CIP(IDAODatabases);
//REVIEW: DEFINE_CIP(IDAODatabasesW);
//REVIEW: DEFINE_CIP(IDAODocument);
//REVIEW: DEFINE_CIP(IDAODocumentW);
//REVIEW: DEFINE_CIP(IDAODocuments);
//REVIEW: DEFINE_CIP(IDAODocumentsW);
//REVIEW: DEFINE_CIP(IDAOError);
//REVIEW: DEFINE_CIP(IDAOErrorW);
//REVIEW: DEFINE_CIP(IDAOErrors);
//REVIEW: DEFINE_CIP(IDAOErrorsW);
//REVIEW: DEFINE_CIP(IDAOField);
//REVIEW: DEFINE_CIP(IDAOFieldW);
//REVIEW: DEFINE_CIP(IDAOFields);
//REVIEW: DEFINE_CIP(IDAOFieldsW);
//REVIEW: DEFINE_CIP(IDAOGroup);
//REVIEW: DEFINE_CIP(IDAOGroupW);
//REVIEW: DEFINE_CIP(IDAOGroups);
//REVIEW: DEFINE_CIP(IDAOGroupsW);
//REVIEW: DEFINE_CIP(IDAOIndex);
//REVIEW: DEFINE_CIP(IDAOIndexFields);
//REVIEW: DEFINE_CIP(IDAOIndexFieldsW);
//REVIEW: DEFINE_CIP(IDAOIndexW);
//REVIEW: DEFINE_CIP(IDAOIndexes);
//REVIEW: DEFINE_CIP(IDAOIndexesW);
//REVIEW: DEFINE_CIP(IDAOParameter);
//REVIEW: DEFINE_CIP(IDAOParameterW);
//REVIEW: DEFINE_CIP(IDAOParameters);
//REVIEW: DEFINE_CIP(IDAOParametersW);
//REVIEW: DEFINE_CIP(IDAOProperties);
//REVIEW: DEFINE_CIP(IDAOPropertiesW);
//REVIEW: DEFINE_CIP(IDAOProperty);
//REVIEW: DEFINE_CIP(IDAOPropertyW);
//REVIEW: DEFINE_CIP(IDAOQueryDef);
//REVIEW: DEFINE_CIP(IDAOQueryDefW);
//REVIEW: DEFINE_CIP(IDAOQueryDefs);
//REVIEW: DEFINE_CIP(IDAOQueryDefsW);
//REVIEW: DEFINE_CIP(IDAORecordset);
//REVIEW: DEFINE_CIP(IDAORecordsetW);
//REVIEW: DEFINE_CIP(IDAORecordsets);
//REVIEW: DEFINE_CIP(IDAORecordsetsW);
//REVIEW: DEFINE_CIP(IDAORelation);
//REVIEW: DEFINE_CIP(IDAORelationW);
//REVIEW: DEFINE_CIP(IDAORelations);
//REVIEW: DEFINE_CIP(IDAORelationsW);
//REVIEW: DEFINE_CIP(IDAOStdCollection);
//REVIEW: DEFINE_CIP(IDAOStdObject);
//REVIEW: DEFINE_CIP(IDAOTableDef);
//REVIEW: DEFINE_CIP(IDAOTableDefW);
//REVIEW: DEFINE_CIP(IDAOTableDefs);
//REVIEW: DEFINE_CIP(IDAOTableDefsW);
//REVIEW: DEFINE_CIP(IDAOUser);
//REVIEW: DEFINE_CIP(IDAOUserW);
//REVIEW: DEFINE_CIP(IDAOUsers);
//REVIEW: DEFINE_CIP(IDAOUsersW);
//REVIEW: DEFINE_CIP(IDAOWorkspace);
//REVIEW: DEFINE_CIP(IDAOWorkspaceW);
//REVIEW: DEFINE_CIP(IDAOWorkspaces);
//REVIEW: DEFINE_CIP(IDAOWorkspacesW);
DEFINE_CIP(IDataAdviseHolder);
DEFINE_CIP(IDataObject);
DEFINE_CIP(IDataPathBrowser);
//REVIEW: DEFINE_CIP(IDebug);
//REVIEW: DEFINE_CIP(IDebugStream);
//REVIEW: DEFINE_CIP(IDfReserved1);
//REVIEW: DEFINE_CIP(IDfReserved2);
//REVIEW: DEFINE_CIP(IDfReserved3);
DEFINE_CIP(IDirectDraw);
DEFINE_CIP(IDirectDraw2);
DEFINE_CIP(IDirectDrawClipper);
DEFINE_CIP(IDirectDrawPalette);
DEFINE_CIP(IDirectDrawSurface);
DEFINE_CIP(IDirectDrawSurface2);
DEFINE_CIP(IDirectPlay);
DEFINE_CIP(IDirectSound);
DEFINE_CIP(IDirectSoundBuffer);
DEFINE_CIP(IDispatch);
DEFINE_CIP(IDistList);
DEFINE_CIP(IDropSource);
DEFINE_CIP(IDropTarget);
//REVIEW: DEFINE_CIP(IEnumCATEGORYINFO);
//REVIEW: DEFINE_CIP(IEnumCATID);
//REVIEW: DEFINE_CIP(IEnumCLSID);
//REVIEW: DEFINE_CIP(IEnumCallback);
DEFINE_CIP(IEnumConnectionPoints);
DEFINE_CIP(IEnumConnections);
DEFINE_CIP(IEnumFORMATETC);
//REVIEW: DEFINE_CIP(IEnumGUID);
//REVIEW: DEFINE_CIP(IEnumGeneric);
//REVIEW: DEFINE_CIP(IEnumHLITEM);
//REVIEW: DEFINE_CIP(IEnumHolder);
DEFINE_CIP(IEnumIDList);
//REVIEW: DEFINE_CIP(IEnumMAPIFormProp);
DEFINE_CIP(IEnumMoniker);
DEFINE_CIP(IEnumMsoView);
DEFINE_CIP(IEnumOLEVERB);
DEFINE_CIP(IEnumOleDocumentViews);
DEFINE_CIP(IEnumOleUndoUnits);
DEFINE_CIP(IEnumSTATDATA);
DEFINE_CIP(IEnumSTATPROPSETSTG);
DEFINE_CIP(IEnumSTATPROPSTG);
DEFINE_CIP(IEnumSTATSTG);
DEFINE_CIP(IEnumString);
DEFINE_CIP(IEnumUnknown);
DEFINE_CIP(IEnumVARIANT);
DEFINE_CIP(IErrorInfo);
DEFINE_CIP(IErrorLog);
DEFINE_CIP(IExchExt);
DEFINE_CIP(IExchExtAdvancedCriteria);
DEFINE_CIP(IExchExtAttachedFileEvents);
DEFINE_CIP(IExchExtCallback);
DEFINE_CIP(IExchExtCommands);
DEFINE_CIP(IExchExtMessageEvents);
DEFINE_CIP(IExchExtModeless);
DEFINE_CIP(IExchExtModelessCallback);
DEFINE_CIP(IExchExtPropertySheets);
DEFINE_CIP(IExchExtSessionEvents);
DEFINE_CIP(IExchExtUserEvents);
DEFINE_CIP(IExternalConnection);
DEFINE_CIP(IExtractIcon);
DEFINE_CIP(IExtractIconA);
DEFINE_CIP(IExtractIconW);
DEFINE_CIP(IFileViewer);
DEFINE_CIP(IFileViewerA);
DEFINE_CIP(IFileViewerSite);
DEFINE_CIP(IFileViewerW);
DEFINE_CIP(IFillLockBytes);
DEFINE_CIP(IFont);
DEFINE_CIP(IFontDisp);
DEFINE_CIP(IGetFrame);
//REVIEW: DEFINE_CIP(IHTMLDocument);
//REVIEW: DEFINE_CIP(IHlink);
//REVIEW: DEFINE_CIP(IHlinkBrowseContext);
//REVIEW: DEFINE_CIP(IHlinkFrame);
//REVIEW: DEFINE_CIP(IHlinkSite);
//REVIEW: DEFINE_CIP(IHlinkSource);
//REVIEW: DEFINE_CIP(IHlinkTarget);
DEFINE_CIP(IHttpNegotiate);
DEFINE_CIP(IHttpSecurity);
//REVIEW: DEFINE_CIP(IInternalMoniker);
//REVIEW: DEFINE_CIP(IInternetExplorer);
DEFINE_CIP(ILayoutStorage);
DEFINE_CIP(ILockBytes);
DEFINE_CIP(IMAPIAdviseSink);
DEFINE_CIP(IMAPIContainer);
DEFINE_CIP(IMAPIControl);
DEFINE_CIP(IMAPIFolder);
DEFINE_CIP(IMAPIForm);
DEFINE_CIP(IMAPIFormAdviseSink);
DEFINE_CIP(IMAPIFormContainer);
DEFINE_CIP(IMAPIFormFactory);
DEFINE_CIP(IMAPIFormInfo);
DEFINE_CIP(IMAPIFormMgr);
//REVIEW: DEFINE_CIP(IMAPIFormProp);
DEFINE_CIP(IMAPIMessageSite);
DEFINE_CIP(IMAPIProgress);
DEFINE_CIP(IMAPIProp);
//REVIEW: DEFINE_CIP(IMAPIPropData);
DEFINE_CIP(IMAPISession);
//REVIEW: DEFINE_CIP(IMAPISpoolerInit);
//REVIEW: DEFINE_CIP(IMAPISpoolerService);
//REVIEW: DEFINE_CIP(IMAPISpoolerSession);
DEFINE_CIP(IMAPIStatus);
//REVIEW: DEFINE_CIP(IMAPISup);
DEFINE_CIP(IMAPITable);
//REVIEW: DEFINE_CIP(IMAPITableData);
DEFINE_CIP(IMAPIViewAdviseSink);
DEFINE_CIP(IMAPIViewContext);
DEFINE_CIP(IMSLogon);
DEFINE_CIP(IMSProvider);
DEFINE_CIP(IMailUser);
DEFINE_CIP(IMalloc);
DEFINE_CIP(IMallocSpy);
DEFINE_CIP(IMarshal);
DEFINE_CIP(IMessage);
DEFINE_CIP(IMessageFilter);
DEFINE_CIP(IMoniker);
DEFINE_CIP(IMsgServiceAdmin);
DEFINE_CIP(IMsgStore);
DEFINE_CIP(IMsoCommandTarget);
DEFINE_CIP(IMsoDocument);
DEFINE_CIP(IMsoDocumentSite);
DEFINE_CIP(IMsoView);
//REVIEW: DEFINE_CIP(IMultiQC);
DEFINE_CIP(INewShortcutHook);
DEFINE_CIP(INewShortcutHookA);
DEFINE_CIP(INewShortcutHookW);
DEFINE_CIP(INotifyReplica);
//REVIEW: DEFINE_CIP(IObjectSafety);
DEFINE_CIP(IObjectWithSite);
DEFINE_CIP(IOleAdviseHolder);
DEFINE_CIP(IOleCache);
DEFINE_CIP(IOleCache2);
DEFINE_CIP(IOleCacheControl);
DEFINE_CIP(IOleClientSite);
DEFINE_CIP(IOleCommandTarget);
DEFINE_CIP(IOleContainer);
DEFINE_CIP(IOleControl);
DEFINE_CIP(IOleControlSite);
DEFINE_CIP(IOleDocument);
DEFINE_CIP(IOleDocumentSite);
DEFINE_CIP(IOleDocumentView);
DEFINE_CIP(IOleInPlaceActiveObject);
DEFINE_CIP(IOleInPlaceFrame);
DEFINE_CIP(IOleInPlaceObject);
DEFINE_CIP(IOleInPlaceObjectWindowless);
DEFINE_CIP(IOleInPlaceSite);
DEFINE_CIP(IOleInPlaceSiteEx);
DEFINE_CIP(IOleInPlaceSiteWindowless);
DEFINE_CIP(IOleInPlaceUIWindow);
DEFINE_CIP(IOleItemContainer);
DEFINE_CIP(IOleLink);
//REVIEW: DEFINE_CIP(IOleManager);
DEFINE_CIP(IOleObject);
DEFINE_CIP(IOleParentUndoUnit);
//REVIEW: DEFINE_CIP(IOlePresObj);
DEFINE_CIP(IOleUndoManager);
DEFINE_CIP(IOleUndoUnit);
DEFINE_CIP(IOleWindow);
//REVIEW: DEFINE_CIP(IPSFactory);
DEFINE_CIP(IPSFactoryBuffer);
DEFINE_CIP(IParseDisplayName);
DEFINE_CIP(IPerPropertyBrowsing);
DEFINE_CIP(IPersist);
DEFINE_CIP(IPersistFile);
DEFINE_CIP(IPersistFolder);
DEFINE_CIP(IPersistMemory);
DEFINE_CIP(IPersistMessage);
DEFINE_CIP(IPersistMoniker);
DEFINE_CIP(IPersistPropertyBag);
DEFINE_CIP(IPersistStorage);
DEFINE_CIP(IPersistStream);
DEFINE_CIP(IPersistStreamInit);
DEFINE_CIP(IPicture);
DEFINE_CIP(IPictureDisp);
DEFINE_CIP(IPointerInactive);
DEFINE_CIP(IPrint);
DEFINE_CIP(IProfAdmin);
DEFINE_CIP(IProfSect);
DEFINE_CIP(IProgressNotify);
//REVIEW: DEFINE_CIP(IPropSheetPage);
DEFINE_CIP(IPropertyBag);
//REVIEW: DEFINE_CIP(IPropertyFrame);
DEFINE_CIP(IPropertyNotifySink);
DEFINE_CIP(IPropertyPage);
DEFINE_CIP(IPropertyPage2);
DEFINE_CIP(IPropertyPageSite);
DEFINE_CIP(IPropertySetStorage);
DEFINE_CIP(IPropertyStorage);
DEFINE_CIP(IProvideClassInfo);
DEFINE_CIP(IProvideClassInfo2);
DEFINE_CIP(IProvideClassInfo3);
DEFINE_CIP(IProviderAdmin);
//REVIEW: DEFINE_CIP(IProxy);
//REVIEW: DEFINE_CIP(IProxyManager);
DEFINE_CIP(IQuickActivate);
DEFINE_CIP(IROTData);
DEFINE_CIP(IReconcilableObject);
DEFINE_CIP(IReconcileInitiator);
DEFINE_CIP(IRichEditOle);
DEFINE_CIP(IRichEditOleCallback);
DEFINE_CIP(IRootStorage);
//REVIEW: DEFINE_CIP(IRpcChannel);
DEFINE_CIP(IRpcChannelBuffer);
//REVIEW: DEFINE_CIP(IRpcProxy);
DEFINE_CIP(IRpcProxyBuffer);
//REVIEW: DEFINE_CIP(IRpcStub);
DEFINE_CIP(IRpcStubBuffer);
DEFINE_CIP(IRunnableObject);
DEFINE_CIP(IRunningObjectTable);
//REVIEW: DEFINE_CIP(ISHItemOC);
DEFINE_CIP(ISequentialStream);
DEFINE_CIP(IServerSecurity);
DEFINE_CIP(IServiceProvider);
DEFINE_CIP(IShellBrowser);
//REVIEW: DEFINE_CIP(IShellCopyHook);
//REVIEW: DEFINE_CIP(IShellCopyHookA);
//REVIEW: DEFINE_CIP(IShellCopyHookW);
DEFINE_CIP(IShellExecuteHook);
DEFINE_CIP(IShellExecuteHookA);
DEFINE_CIP(IShellExecuteHookW);
DEFINE_CIP(IShellExtInit);
DEFINE_CIP(IShellFolder);
DEFINE_CIP(IShellIcon);
DEFINE_CIP(IShellLink);
DEFINE_CIP(IShellLinkA);
DEFINE_CIP(IShellLinkW);
DEFINE_CIP(IShellPropSheetExt);
DEFINE_CIP(IShellView);
DEFINE_CIP(IShellView2);
DEFINE_CIP(ISimpleFrameSite);
DEFINE_CIP(ISpecifyPropertyPages);
//REVIEW: DEFINE_CIP(ISpoolerHook);
DEFINE_CIP(IStdMarshalInfo);
DEFINE_CIP(IStorage);
DEFINE_CIP(IStream);
//REVIEW: DEFINE_CIP(IStreamDocfile);
//REVIEW: DEFINE_CIP(IStreamTnef);
//REVIEW: DEFINE_CIP(IStub);
//REVIEW: DEFINE_CIP(IStubManager);
DEFINE_CIP(ISupportErrorInfo);
//REVIEW: DEFINE_CIP(ITNEF);
DEFINE_CIP(ITypeChangeEvents);
DEFINE_CIP(ITypeComp);
DEFINE_CIP(ITypeInfo);
DEFINE_CIP(ITypeInfo2);
DEFINE_CIP(ITypeLib);
DEFINE_CIP(ITypeLib2);
//REVIEW: DEFINE_CIP(IUniformResourceLocator);
DEFINE_CIP(IViewObject);
DEFINE_CIP(IViewObject2);
DEFINE_CIP(IViewObjectEx);
//REVIEW: DEFINE_CIP(IWPObj);
//REVIEW: DEFINE_CIP(IWPProvider);
//REVIEW: DEFINE_CIP(IWPSite);
//REVIEW: DEFINE_CIP(IWebBrowser);
DEFINE_CIP(IWinInetHttpInfo);
DEFINE_CIP(IWinInetInfo);
DEFINE_CIP(IWindowForBindingUI);
DEFINE_CIP(IXPLogon);
DEFINE_CIP(IXPProvider);

#endif // _MSC_VER < 1100
#endif // COMPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\comdbg.h ===
#ifndef COMDBG_H
#define COMDBG_H

//#define COMDBG
#ifdef COMDBG
inline void DumpStorage(IStorage* pStorage)
{
    ASSERT(pStorage != NULL);
    if (pStorage == NULL)
        return;

    STATSTG s;
    HRESULT hr = pStorage->Stat(&s, STATFLAG_DEFAULT);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return;
    TRACE(L"%s->\n", s.pwcsName);
    CoTaskMemFree(s.pwcsName);

    IEnumSTATSTGPtr spElements;
    hr = pStorage->EnumElements(0, NULL, 0, &spElements);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return;
    do
    {
        ULONG numberReturned;
        hr = spElements->Next(1, &s, &numberReturned);
        if (hr != S_OK || numberReturned != 1)
            return;
        if (s.type == STGTY_STORAGE)
            TRACE(L" [%s]\n", s.pwcsName);
        else 
            TRACE(L" %s %u\n", s.pwcsName, s.cbSize.LowPart);
        CoTaskMemFree(s.pwcsName);
    } while (true);
}

class ProxyReporter
{
public:
    ProxyReporter()
        : m_LastName(L"Unnamed"), m_LastInterface(L"Unknown"), m_LastThis(unsigned(this))
    {
        TRACE(L"<PR>(%s(%s:%X)) is crowning.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    virtual ~ProxyReporter()
    {
        TRACE(L"<PR>(%s(%s:%X)) is dead.\n", GetLastInterface(), GetLastName(), m_LastThis);
    }

protected:
    void Born() const
    {
        TRACE(L"<PR>(%s(%s:%X)) is alive.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    void Dying() const
    {
        TRACE(L"<PR>(%s(%s:%X)) is dying.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    void CallHome(const wchar_t* from) const
    {
        TRACE(L"<PR>(%s(%s:%X)#%u) calling home from: %s\n", GetLastInterface(), GetLastName(), GetLastThis(), GetRefCount(), from);
    }

    virtual const void* GetThis() const
    {
        return this;
    }

    virtual const wchar_t* GetInstanceName() const
    {
        return m_LastName;
    }

    virtual const wchar_t* GetInterfaceName() const
    {
        return m_LastInterface;
    }

    virtual unsigned GetRefCount() const
    {
        return 0;
    }

private:
    mutable const wchar_t* m_LastName;
    mutable const wchar_t* m_LastInterface;
    mutable unsigned m_LastThis;

    const const wchar_t* GetLastName() const
    {
        return m_LastName = GetInstanceName();
    }

    const const wchar_t* GetLastInterface() const
    {
        return m_LastInterface = GetInterfaceName();
    }

    unsigned GetLastThis() const
    {
        return m_LastThis = unsigned(GetThis());
    }

}; // class ProxyReporter

template<typename Base> 
    class ATLProxyReporter : public Base
{
public:
    ATLProxyReporter()
        : m_InstanceName(L"Unnamed")
    {
        Born();
    }

    virtual ~ATLProxyReporter()
    {
        Dying();
    }

    void InitATLProxyReporter(const wchar_t* instanceName)
    {
        ASSERT(instanceName != NULL);
        m_InstanceName = instanceName;
        CallHome(L"InitATLProxyReporter");
    }

protected:
    ULONG InternalAddRef()
    {
        const ULONG r = Base::InternalAddRef();
        CallHome(L"InternalAddRef(after)");
        return r;
    }

    ULONG InternalRelease()
    {
        CallHome(L"InternalRelease(before)");
        return Base::InternalRelease();
    }

    virtual const void* GetThis() const
    {
        return this;
    }

    virtual const wchar_t* GetInstanceName() const
    {
        ASSERT(m_InstanceName != NULL);
        return m_InstanceName;
    }

    virtual unsigned GetRefCount() const
    {
        return unsigned(m_dwRef);
    }

private:
    const wchar_t* m_InstanceName;

}; // class ATLProxyReporter

class __declspec(uuid("B425E0EC-A086-11d0-8F59-00A0C91ED3C8")) DebugStream : 
    public IStream, public CComObjectRoot, public ProxyReporter
{
public:
    DebugStream()
    {
    }

    virtual ~DebugStream()
    {
    }

    void InitDebugStream(IStream* pStream)
    {
        ASSERT(m_spStream == NULL);
        ASSERT(pStream != NULL);
        m_spStream = pStream;
    }

    BEGIN_COM_MAP(DebugStream)
        COM_INTERFACE_ENTRY_IID(__uuidof(DebugStream), DebugStream)
        COM_INTERFACE_ENTRY_IID(__uuidof(IStream), IStream)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(DebugStream)

// IStream
public:
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Read(pv, cb, pcbRead);
        CallHome(SUCCEEDED(hr) ? L"Read" : L"Read(failed!)");
        return hr;
    }
    
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Write(pv, cb, pcbWritten);
        CallHome(SUCCEEDED(hr) ? L"Write" : L"Write(failed!)");
        return hr;
    }

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Seek(dlibMove, dwOrigin, plibNewPosition);
        CallHome(SUCCEEDED(hr) ? L"Seek" : L"Seek(failed!)");
        return hr;
    }
        
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->SetSize(libNewSize);
        CallHome(SUCCEEDED(hr) ? L"SetSize" : L"SetSize(failed!)");
        return hr;
    }
        
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
        CallHome(SUCCEEDED(hr) ? L"CopyTo" : L"CopyTo(failed!)");
        return hr;
    }
        
    STDMETHOD(Commit)(DWORD grfCommitFlags)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Commit(grfCommitFlags);
        CallHome(SUCCEEDED(hr) ? L"Commit" : L"Commit(failed!)");
        return hr;
    }
        
    STDMETHOD(Revert)()
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Revert();
        CallHome(SUCCEEDED(hr) ? L"Revert" : L"Revert(failed!)");
        return hr;
    }
        
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->LockRegion(libOffset, cb, dwLockType);
        CallHome(SUCCEEDED(hr) ? L"LockRegion" : L"LockRegion(failed!)");
        return hr;
    }
        
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->UnlockRegion(libOffset, cb, dwLockType);
        CallHome(SUCCEEDED(hr) ? L"UnlockRegion" : L"UnlockRegion(failed!)");
        return hr;
    }
        
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Stat(pstatstg, grfStatFlag);
        CallHome(SUCCEEDED(hr) ? L"Stat" : L"Stat(failed!)");
        return hr;
    }
        
    STDMETHOD(Clone)(IStream** ppstm)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Clone(ppstm);
        CallHome(SUCCEEDED(hr) ? L"Clone" : L"Clone(failed!)");
        return hr;
    }

protected:
    virtual const wchar_t* GetInterfaceName() const
    {
        return L"DebugStream";
    }

private:
    IStreamCIP m_spStream;
}; // class DebugStream

#endif // COMDBG

inline HRESULT CreateDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStream** ppStream)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStream != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->CreateStream(name, grfMode, NULL, NULL, ppStream);
    return hr;

    #else // COMDBG
    IStreamCIP spStream;
    HRESULT hr = pStorage->CreateStream(name, grfMode, NULL, NULL, &spStream);
    ASSERT(SUCCEEDED(hr) && spStream != NULL);

    if (FAILED(hr))
        return E_FAIL;
    typedef CComObject<ATLProxyReporter<DebugStream> > ProxyStreamObject;
    ProxyStreamObject* pObject;
    hr = ProxyStreamObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStream(spStream);
    hr = pObject->QueryInterface(IID_IStream, reinterpret_cast<void**>(ppStream));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStream** ppStream)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStream != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->OpenStream(name, NULL, grfMode, NULL, ppStream);
    return hr;

    #else // COMDBG
    IStreamCIP spStream;
    HRESULT hr = pStorage->OpenStream(name, NULL, grfMode, NULL, &spStream);
    if (FAILED(hr))
        return E_FAIL;

    typedef CComObject<ATLProxyReporter<DebugStream> > ProxyStreamObject;
    ProxyStreamObject* pObject;
    hr = ProxyStreamObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStream(spStream);
    hr = pObject->QueryInterface(IID_IStream, reinterpret_cast<void**>(ppStream));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

#ifdef COMDBG
class __declspec(uuid("B6E77CAC-A0AC-11d0-8F59-00A0C91ED3C8")) DebugStorage : 
    public IStorage, public CComObjectRoot, public ProxyReporter
{
public:
    DebugStorage()
    {
    }

    virtual ~DebugStorage()
    {
        ASSERT(m_spStorage != NULL);
        CallHome(L"~DebugStorage, elements:");
        DumpStorage(m_spStorage);
    }

    void InitDebugStorage(IStorage* pStorage)
    {
        ASSERT(m_spStorage == NULL);
        ASSERT(pStorage != NULL);
        m_spStorage = pStorage;
    }

    BEGIN_COM_MAP(DebugStorage)
        COM_INTERFACE_ENTRY_IID(__uuidof(DebugStorage), DebugStorage)
        COM_INTERFACE_ENTRY_IID(__uuidof(IStorage), IStorage)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(DebugStorage)

// IStorage
public:
    STDMETHOD(CreateStream)(const OLECHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream** ppstm)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CreateStream(pwcsName, grfMode, reserved1, reserved2, ppstm);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CreateStream" : L"CreateStream(failed!)");
        return hr;
    }
        
    STDMETHOD(OpenStream)(const OLECHAR *pwcsName, void *reserved1, DWORD grfMode, DWORD reserved2, IStream** ppstm)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->OpenStream(pwcsName, reserved1, grfMode, reserved2, ppstm);
        CallHomeAndDump(SUCCEEDED(hr) ? L"OpenStream" : L"OpenStream(failed!)");
        return hr;
    }
    
    STDMETHOD(CreateStorage)(const OLECHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage** ppstg)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CreateStorage(pwcsName, grfMode, reserved1, reserved2, ppstg);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CreateStorage" : L"CreateStorage(failed!)");
        return hr;
    }
    
    STDMETHOD(OpenStorage)(const OLECHAR *pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage** ppstg)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg);
        CallHomeAndDump(SUCCEEDED(hr) ? L"OpenStorage, elements:" : L"OpenStorage(failed!)");
        return hr;
    }
    
    STDMETHOD(CopyTo)(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CopyTo(ciidExclude, rgiidExclude, snbExclude, pstgDest);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CopyTo" : L"CopyTo(failed!)");
        return hr;
    }
    
    STDMETHOD(MoveElementTo)(const OLECHAR *pwcsName, IStorage *pstgDest, const OLECHAR *pwcsNewName, DWORD grfFlags)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->MoveElementTo(pwcsName, pstgDest, pwcsNewName, grfFlags);
        CallHomeAndDump(SUCCEEDED(hr) ? L"MoveElementTo" : L"MoveElementTo(failed!)");
        return hr;
    }
    
    STDMETHOD(Commit)(DWORD grfCommitFlags)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Commit(grfCommitFlags);
        CallHomeAndDump(SUCCEEDED(hr) ? L"Commit" : L"Commit(failed!)");
        return hr;
    }
    
    STDMETHOD(Revert)()
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Revert();
        CallHomeAndDump(SUCCEEDED(hr) ? L"Revert" : L"Revert(failed!)");
        return hr;
    }
    
    STDMETHOD(EnumElements)(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG** ppenum)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->EnumElements(reserved1, reserved2, reserved3, ppenum);
        CallHomeAndDump(SUCCEEDED(hr) ? L"EnumElements" : L"EnumElements(failed!)");
        return hr;
    }
    
    STDMETHOD(DestroyElement)(const OLECHAR* pwcsName)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->DestroyElement(pwcsName);
        CallHomeAndDump(SUCCEEDED(hr) ? L"DestroyElement" : L"DestroyElement(failed!)");
        return hr;
    }
    
    STDMETHOD(RenameElement)(const OLECHAR *pwcsOldName, const OLECHAR *pwcsNewName)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->RenameElement(pwcsOldName, pwcsNewName);
        CallHomeAndDump(SUCCEEDED(hr) ? L"RenameElement" : L"RenameElement(failed!)");
        return hr;
    }
    
    STDMETHOD(SetElementTimes)(const OLECHAR *pwcsName, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetElementTimes(pwcsName, pctime, patime, pmtime);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetElementTimes" : L"SetElementTimes(failed!)");
        return hr;
    }
    
    STDMETHOD(SetClass)(REFCLSID clsid)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetClass(clsid);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetClass" : L"SetClass(failed!)");
        return hr;
    }
    
    STDMETHOD(SetStateBits)(DWORD grfStateBits, DWORD grfMask)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetStateBits(grfStateBits, grfMask);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetStateBits" : L"SetStateBits(failed!)");
        return hr;
    }
    
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Stat(pstatstg, grfStatFlag);
        CallHomeAndDump(SUCCEEDED(hr) ? L"Stat" : L"Stat(failed!)");
        return hr;
    }

// ProxyReporter
protected:
    virtual const wchar_t* GetInterfaceName() const
    {
        return L"DebugStorage";
    }

private:
    IStorageCIP m_spStorage;

    void CallHomeAndDump(const wchar_t* from) const
    {
        CallHome(from);
        DumpStorage(m_spStorage);
    }

}; // class DebugStorage

#endif // COMDBG

inline HRESULT CreateDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->CreateStorage(name, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStorageCIP spStorage;
    HRESULT hr = pStorage->CreateStorage(name, grfMode, NULL, NULL, &spStorage);
    ASSERT(SUCCEEDED(hr) && spStorage != NULL);

    if (FAILED(hr))
        return E_FAIL;
    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->OpenStorage(name, NULL, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStorageCIP spStorage;
    HRESULT hr = pStorage->OpenStorage(name, NULL, grfMode, NULL, NULL, &spStorage);
    if (FAILED(hr))
        return E_FAIL;

    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

#endif // COMDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\comstrm.h ===
#ifndef COMSTRM_H
#define COMSTRM_H

//
// JonN 12/01/99
// 384722: compmgmt: GetDataHere is not returning an error
//         if buffer is too small
// The callers routinely assume that if stream_ptr is initialized
// using a STGMEDIUM with TYMED_GLOBAL, that STGMEDIUM.hGlobal will
// be kept up to date with each Write().  This is not strictly true
// of a normal IStream, but we will build in this behavior in order
// to avoid changing too much client code.  However, since GetDataHere
// (MSDN) specifies that the HGLOBAL should not be changed, we return
// STG_E_MEDIUMFULL if it changes; but we do still replace the HGLOBAL,
// since the old one is implicitly freed and the new one needs to be freed.
//

#ifndef COMPTRS_H
#include <comptrs.h>
#endif
#ifndef COMBSTR_H
#include <combstr.h>
#endif

namespace microsoft	{
namespace com {

class stream_ptr
	{
	// Construction
	public: stream_ptr() throw()
		// Sets the stream to NULL
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		}

	public: explicit stream_ptr(const stream_ptr& pStream) throw()
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(pStream.m_pStream);
		}

	public: explicit stream_ptr(IStream* pStream) throw()
		// Saves the stream
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(pStream);
		}

	//REVIEW: add template constructors

	public: explicit stream_ptr(HGLOBAL global) throw()
		// Creates a stream on top of the global
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(global);
		}

	public: explicit stream_ptr(LPCOLESTR filename) throw()
		// Creates a stream on top of the specified file
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(filename);
		}

	public: explicit stream_ptr(STGMEDIUM& stgMedium) throw()
		// Saves the provided stream.
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(stgMedium);
		}

	public: explicit stream_ptr(STGMEDIUM* pStgMedium) throw()
		// Saves the provided stream.
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		if (pStgMedium)
			Initialize(*pStgMedium);
		}
	
	//REVIEW: Add Create and Open functions
	//REVIEW: Add all of the assignment operators, cast operators, attach, detach, ->, *, etc.
	
	public: operator IStream*() const throw()
		{
		//REVIEW: trace on null would be helpful
		return m_pStream;
		}

	public: IStream* operator->() const throw()
		{
		//REVIEW: trace on null would be helpful
		return m_pStream;
		}

	public: IStream& operator*() const throw()
		{
		//REVIEW: trace on null would be helpful
		return *m_pStream;
		}

	// Write interfaces
	public: HRESULT Write(
		const void* pBuffer, unsigned long writeCount, unsigned long& written) throw()
		// Write the data contained in the buffer
		{
		if (m_pStream == NULL)
			return E_FAIL; //REVIEW: correct failure code?
		HRESULT hr = m_pStream->Write(pBuffer, writeCount, &written);
		if (SUCCEEDED(hr) && NULL != m_pWritebackHGlobal)
		{
			HGLOBAL hgNew = NULL;
			hr = GetHGlobalFromStream(m_pStream, &hgNew);
			if (SUCCEEDED(hr))
			{
				if (NULL == m_hgOriginalHGlobal)
					*m_pWritebackHGlobal = hgNew;
				else if (m_hgOriginalHGlobal != hgNew)
				{
					//
					// When this occurs, the old HGLOBAL has already been freed
					//
					*m_pWritebackHGlobal = hgNew;
					hr = STG_E_MEDIUMFULL;
				}
			}
		}
		return hr;
		}

	public: HRESULT Write(const void* pBuffer, unsigned long writeCount) throw()
		{
		unsigned long written;
		return Write(pBuffer, writeCount, written);
		}

	public: HRESULT Write(const wchar_t* string) throw()
		{
		unsigned long len=(unsigned long)(wcslen(string)+1);
		return Write(string, len*sizeof(wchar_t), len);
		}

	public: HRESULT Write(const char* string) throw()
		{
		unsigned long len=(unsigned long)(strlen(string)+1);
		return Write(string, len, len);
		}
	
	public: HRESULT Write(const bstr& bstr) throw()
		{
		return Write(static_cast<const wchar_t*>(bstr));
		}

	//REVIEW: Read interfaces
	//REVIEW: Seek
	//REVIEW: Stat - broken out
	
	// Initialization.  May be used by derived classes to setup the stream for
	// different types of storage mediums.  These functions are all re-entrant,
	// and may be called at any time.  They perform all of the appropriate
	// clean up and releasing of any resources in previous use.
	protected: void Initialize(HGLOBAL hg) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		HRESULT const hr = CreateStreamOnHGlobal(hg, FALSE, &m_pStream);
		ASSERT(SUCCEEDED(hr));
		}

	protected: void Initialize(IStream* pStream) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		m_pStream = pStream;
		}

	protected: void Initialize(LPCOLESTR filename) throw()
		{
        UNREFERENCED_PARAMETER (filename);
		//REVIEW: make re-entrant and bullet proof
		#if 0 //REVIEW:  need to create FileStream before this can be enabled
		if (!filename || !*filename)
			return false;

		cip<FileStream> fs = new CComObject<FileStream>;
		if (!fs)
			return false;

		HRESULT hr = fs->Open(filename);
		if (FAILED(hr))
			return false;

		m_pStream = fs;
		return true;
		#endif // 0
		}

	protected: void Initialize(STGMEDIUM& storage) throw()
		// Initializes the read/write functions based on the type of storage
		// medium.  If there is a problem, the reader/writer is not set.
		{
		//REVIEW: make re-entrant and bullet proof
		switch (storage.tymed)
			{
			case TYMED_HGLOBAL:
				Initialize(storage.hGlobal);
				m_hgOriginalHGlobal = storage.hGlobal;
				m_pWritebackHGlobal = &(storage.hGlobal);
				return;

			case TYMED_FILE:
				Initialize(storage.lpszFileName);
				return;

			case TYMED_ISTREAM:
				Initialize(storage.pstm);
				return;
			}
		}

	// Implementation
	private: IStreamCIP m_pStream;
		// This stream is created and used when the TYMED type is HGLOBAL.

		 //
		 // JonN 12/01/99 384722: see comments at top of file
		 //
		 HGLOBAL m_hgOriginalHGlobal;
		 HGLOBAL* m_pWritebackHGlobal;

	}; // class streamptr

} // namespace com
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef COM_NAMESPACE_ON
using namespace com;
#endif // COM_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // COMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\combstr.h ===
#ifndef COMBSTR_H
#define COMBSTR_H

#ifndef BOOL_H
#include <bool.h>
#endif
#ifndef STRCONV_H
#include <strconv.h>
#endif

namespace microsoft	{
namespace com {

class bstr
	//REVIEW: need to add support for copy-on-write iterators.
	{
	public: bstr() throw()
		: m_Data(NULL)
		{
		}

	public: bstr(const bstr& s) throw()
		: m_Data(s.m_Data)
		{
		_AddRef();
		}

	public: bstr(const char* s) throw()
		: m_Data(new Data(s))
		{
		ASSERT(m_Data);
		}

	public: bstr(const wchar_t* s) throw()
		: m_Data(new Data(s))
		{
		}

	public: ~bstr() throw()
		{
		_Free();
		}

	public: bstr& operator=(const bstr& s) throw()
		{
		_Free();
		m_Data = s.m_Data;
		_AddRef();
		return *this;
		}

	public: bstr& operator=(const char* s) throw()
		{
		_Free();
		m_Data = new Data(s);
		return *this;
		}

	public: bstr& operator=(const wchar_t* s) throw()
		{
		_Free();
		m_Data = new Data(s);
		return *this;
		}

	public: bstr& operator+=(const bstr& s) throw()
		{
		Data* newData = new Data(*this, s);
		ASSERT(newData);
		_Free();
		m_Data = newData;
		return *this;
		}

	public: bstr operator+(const bstr& s) const throw()
		{
		bstr b = *this;
		b += s;
		return b;
		}

	public: operator const wchar_t*() const throw()
		{
		return m_Data ? m_Data->GetWString() : NULL;
		}

	public: operator const char*() const throw()
		{
		return m_Data ? m_Data->GetString() : NULL;
		}

	public: bool operator!() const throw()
		{
		return m_Data ? !m_Data->GetWString() : true;
		}

	public: bool operator==(const bstr& str) const throw()
		{
		return _Compare(str) == 0;
		}

	public: bool operator!=(const bstr& str) const throw()
		{
		return _Compare(str) != 0;
		}

	public: bool operator<(const bstr& str) const throw()
		{
		return _Compare(str) < 0;
		}

	public: bool operator>(const bstr& str) const throw()
		{
		return _Compare(str) > 0;
		}

	public: bool operator<=(const bstr& str) const throw()
		{
		return _Compare(str) <= 0;
		}

	public: bool operator>=(const bstr& str) const throw()
		{
		return _Compare(str) >= 0;
		}

	public: BSTR copy() const throw()
		{
		return m_Data ? m_Data->Copy() : NULL;
		}

	public: unsigned int length() const throw()
		{
		return m_Data ? m_Data->length() : 0;
		}

	//REVIEW: create size(of)()

	private: class Data
		{
		public: Data(const char* s) throw()
			: m_str(NULL), m_RefCount(1)
			{
			if (s)
				{
				m_wstr = str2BSTR(s);
				ASSERT(m_wstr);
				}
			else m_wstr = NULL;
			}

		public: Data(const wchar_t* s) throw()
			: m_str(NULL), m_RefCount(1)
			{
			if (s)
				{
				m_wstr = wcs2BSTR(s);
				ASSERT(m_wstr);
				}
			else m_wstr = NULL;
			}

		public: Data(const bstr& s1, const bstr& s2)
			: m_str(NULL), m_RefCount(1)
			{
			const unsigned int l1 = s1.length();
			const unsigned int l2 = s2.length();
			m_wstr=SysAllocStringLen(s1, l1+l2);
			ASSERT(m_wstr);
			memcpy(m_wstr+l1, static_cast<const wchar_t*>(s2), l2+1);
			}

		public: unsigned long AddRef() throw()
			{
			ASSERT(m_RefCount);
			InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
			return m_RefCount;
			}

		public: unsigned long Release() throw()
			{
			ASSERT(m_RefCount);
			//REVIEW: may not want InterlockedDecrement for simple speed cases?
			if (!InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)))
				delete this;
			return m_RefCount;
			}

		public: operator const wchar_t*() const throw()
			{
			return m_wstr;
			}

		public: operator const char*() const throw()
			{
			return GetString();
			}
				
		public: const wchar_t* GetWString() const throw()
			{
			return m_wstr;
			}

		public: const char* GetString() const throw()
			{
			if (!m_str && m_wstr)
				{
				USES_STRCONV;
				const unsigned int len=SysStringLen(m_wstr)+1;
				#if _MSC_VER >= 1100
				m_str = new char[len];
				ASSERT(m_str);
				memcpy(m_str, WCS2STR(m_wstr), len);
				#else //REVIEW: Strip after v5 ships
				const_cast<Data*>(this)->m_str = new char[len];
				ASSERT(m_str);
				memcpy(const_cast<Data*>(this)->m_str, WCS2STR(m_wstr), len);
				#endif // _MSC_VER >= 1100
				}
			return m_str;
			}

		public: BSTR Copy() const throw()
			{
			return m_wstr ? SysAllocStringLen(m_wstr, SysStringLen(m_wstr)) : NULL;
			}

		public: unsigned int length()
			{
			return m_wstr ? SysStringLen(m_wstr) : 0;
			}

		private: wchar_t* m_wstr;
		private: mutable char* m_str;
		private: unsigned long m_RefCount;

		private: Data()
			// Never allow default construction
			{
			}

		private: Data(const Data& s) throw()
			// Never allow copy
			: m_str(NULL), m_RefCount(1)
			{
			if (s.m_wstr)
				{
				m_wstr = SysAllocStringLen(s.m_wstr, SysStringLen(s.m_wstr));
				ASSERT(m_wstr);
				}
			else m_wstr = NULL;
			}

		private: ~Data()
			// Prevent deletes from outside.  Release() must be used.
			// ASSERT if the count is not 0
			{
			ASSERT(!m_RefCount);
			_Free();
			}

		private: void _Free()
			{
			if (m_wstr)
				SysFreeString(m_wstr);
			if (m_str)
				delete m_str;
			}
		}; // class Data

	private: Data* m_Data;

	private: void _AddRef()
		{
		if (m_Data)
			m_Data->AddRef();
		}

	private: void _Free() throw()
		{
		if (m_Data)
			{
			m_Data->Release();
			m_Data = NULL;
			}
		}

	private: int _Compare(const bstr& str) const throw()
		{
		if (m_Data == str.m_Data)
			return 0;
		if (!m_Data && str.m_Data)
			return -1;
		if (m_Data && !str.m_Data)
			return 1;
		#ifndef OLE2ANSI
		return wcscmp(*m_Data, str);
		#else
		return strcmp(*m_Data, str);
		#endif
		}
	}; // class bstr

} // namespace com
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef COM_NAMESPACE_ON
using namespace com;
#endif // COM_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // COMBSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\comptr.h ===
#ifndef COMPTR_H
#define COMPTR_H
#if _MSC_VER >= 1100
#pragma warning(disable:4800)
#include <comdef.h>
#define CIP_RETYPEDEF(I) typedef I##Ptr I##CIP;
#define CIP_TYPEDEF(I) _COM_SMARTPTR_TYPEDEF(I, IID_##I); CIP_RETYPEDEF(I);
#define DEFINE_CIP(x)\
	CIP_TYPEDEF(x)

#define DECLARE_CIP(x) DEFINE_CIP(x) x##CIP

CIP_RETYPEDEF(IUnknown);
CIP_RETYPEDEF(IDataObject);
CIP_RETYPEDEF(IStorage);
CIP_RETYPEDEF(IStream);
CIP_RETYPEDEF(IPersistStorage);
CIP_RETYPEDEF(IPersistStream);
CIP_RETYPEDEF(IPersistStreamInit);
CIP_RETYPEDEF(IDispatch);

#else // _MSC_VER < 1100

#define USE_OLD_COMPILER (_MSC_VER<1100)
#define USE_INTERMEDIATE_COMPILER (USE_OLD_COMPILER && (_MSC_VER>1020))

// This avoids "warning C4290: C++ Exception Specification ignored"
// JonN 12/16/96
#pragma warning(4:4290)

#ifndef BOOL_H
#include <bool.h>
#endif
#ifndef __wtypes_h__
#include <wtypes.h>
#endif

template<typename _Interface, const IID* _IID/*=&__uuidof(_Interface)*/>
	class CIID
	// Provide Interface to IID association
	{
	public: typedef _Interface Interface;

	public: static _Interface* GetInterfacePtr() throw()
			{
			return NULL;
			}

	public: static _Interface& GetInterface() throw()
			{
			return *GetInterfacePtr();
			}

	public: static const IID& GetIID() throw()
			{
			return *_IID;
			}
	}; // class CIID

template<typename _CIID> class CIP
	{
	#if USE_OLD_COMPILER
	private: class _IUnknown: public IUnknown {};
		// Unique type used to provide for operations between different pointer
		// types.
	#endif // USE_OLD_COMPILER

	// Declare interface type so that the type may be available outside
	// the scope of this template.
	public: typedef _CIID ThisCIID;
	public: typedef _CIID::Interface Interface;

	public: static const IID& GetIID() throw()
		// When the compiler supports references in template params,
		// _CLSID will be changed to a reference.  To avoid conversion
		// difficulties this function should be used to obtain the
		// CLSID.
		{
		return ThisCIID::GetIID();
		}

	//REVIEW: add support for assignment of nonpointer interfaces
	// i.e. IUnknown, instead of simple IUnknown*

	public: CIP()  throw()
		// Construct empty in preperation for assignment.
		: _pInterface(NULL)
		{
		}

	public: CIP(int null) throw()
		// This constructor is provided to allow NULL assignment.  It will assert
		// if any value other than null is assigned to the object.
		: _pInterface(NULL)
		{
		ASSERT(!null);
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	template<typename _InterfacePtr> CIP(_InterfacePtr p) throw()
		// Queries for this interface.
	#else
	public: CIP(_IUnknown& p) throw()
		: _pInterface(NULL)
		{
		if (&p)
			{
			const HRESULT hr = _QueryInterface(&p);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			}
		else _pInterface = NULL;
		}

	public: CIP(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		: _pInterface(NULL)
		{
		if (p)
			{
			const HRESULT hr = _QueryInterface(p);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			}
		else _pInterface = NULL;
		}

	public: CIP(const CIP& cp)  throw()
		// Copy the pointer and AddRef().
		: _pInterface(cp._pInterface)
		{
		_AddRef();
		}

	public: CIP(Interface* pInterface)  throw()
		// Saves the interface
		: _pInterface(pInterface)
		{
		_AddRef();
		}

	public: CIP(Interface* pInterface, bool bAddRef) throw()
		// Copies the pointer.  If bAddRef is TRUE, the interface will
		// be AddRef()ed.
		: _pInterface(pInterface)
		{
		if (bAddRef)
			{
			ASSERT(!pInterface);
			if (pInterface)
				_AddRef();
			}
		}

	public: CIP(const CLSID& clsid, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		// Calls CoCreateClass with the provided CLSID.
		: _pInterface(NULL)
		{
		const HRESULT hr = CreateInstance(clsid, dwClsContext);
		ASSERT(SUCCEEDED(hr));
		}

	public: CIP(LPOLESTR str, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		// Calls CoCreateClass with the provided CLSID retrieved from
		// the string.
		: _pInterface(NULL)
		{
		const HRESULT hr = CreateInstance(str, dwClsContext);
		ASSERT(SUCCEEDED(hr));
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> CIP& operator=(_InterfacePtr& p) throw()
		// Queries for interface.
	#else
	public: CIP& operator=(_IUnknown& p) throw()
		{
		return operator=(static_cast<IUnknown*>(&p));
		}

	public: CIP& operator=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		const HRESULT hr = _QueryInterface(p);
		ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
		return *this;
		}

	public: CIP& operator=(Interface* pInterface) throw()
		// Saves the interface.
		{
		if (_pInterface != pInterface)
			{
			Interface* pOldInterface = _pInterface;
			_pInterface = pInterface;
			_AddRef();
			if (pOldInterface)
				pOldInterface->Release();
			}
		return *this;
		}

	public: CIP& operator=(const CIP& cp) throw()
		// Copies and AddRef()'s the interface.
		{
		return operator=(cp._pInterface);
		}

	public: CIP& operator=(int null) throw()
		// This operator is provided to permit the assignment of NULL to the class.
		// It will assert if any value other than NULL is assigned to it.
		{
		ASSERT(!null);
		return operator=(reinterpret_cast<Interface*>(NULL));
		}

	public: ~CIP() throw()
		// If we still have an interface then Release() it.  The interface
		// may be NULL if Detach() has previosly been called, or if it was
		// never set.
		{
		_Release();
		}

	public: void Attach(Interface* pInterface) throw()
		// Saves/sets the interface without AddRef()ing.  This call
		// will release any previously aquired interface.
		{
		_Release();
		_pInterface = pInterface;
		}

	public: void Attach(Interface* pInterface, bool bAddRef) throw()
		// Saves/sets the interface only AddRef()ing if bAddRef is TRUE.
		// This call will release any previously aquired interface.
		{
		_Release();
		_pInterface = pInterface;
		if (bAddRef)
			{
			ASSERT(pInterface);
			if (pInterface)
				pInterface->AddRef();
			}
		}

	public: Interface* Detach() throw()
		// Simply NULL the interface pointer so that it isn't Released()'ed.
		{
		Interface* const old=_pInterface;
		_pInterface = NULL;
		return old;
		}

	public: operator Interface*() const throw()
		// Return the interface.  This value may be NULL
		{
		return _pInterface;
		}

	public: Interface& operator*() const throw()
		// Allows an instance of this class to act as though it were the
		// actual interface.  Also provides minimal assertion verification.
		{
		ASSERT(_pInterface);
		return *_pInterface;
		}

	public: Interface** operator&() throw()
		// Returns the address of the interface pointer contained in this
		// class.  This is useful when using the COM/OLE interfaces to create
		// this interface.
		{
		_Release();
		_pInterface = NULL;
		return &_pInterface;
		}

	public: Interface* operator->() const throw()
		// Allows this class to be used as the interface itself.
		// Also provides simple assertion verification.
		{
		ASSERT(_pInterface);
		return _pInterface;
		}

	public: operator bool() const throw()
		// This operator is provided so that simple boolean expressions will
		// work.  For example: "if (p) ...".
		// Returns TRUE if the pointer is not NULL.
		{
		return _pInterface;
		}

	public: bool operator!() throw()
		// Returns TRUE if the interface is NULL.
		// This operator will be removed when support for type bool
		// is added to the compiler.
		{
		return !_pInterface;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator==(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator==(_IUnknown& p) throw()
		{
		return operator==(static_cast<IUnknown*>(&p));
		}

	public: bool operator==(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return !_CompareUnknown(p);
		}

	public: bool operator==(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface == p) ? true : !_CompareUnknown(p);
		}

	public: bool operator==(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator==(p._pInterface);
		}

	public: bool operator==(int null) throw()
		// For comparison to NULL
		{
		ASSERT(!null);
		return !_pInterface;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator!=(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator!=(_IUnknown& p) throw()
		{
		return operator!=(static_cast<IUnknown*>(&p));
		}

	public: bool operator!=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p);
		}

	public: bool operator!=(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface!=p)?true:_CompareUnknown(p);
		}

	public: bool operator!=(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator!=(p._pInterface);
		}

	public: bool operator!=(int null) throw()
		// For comparison to NULL
		{
		ASSERT(!null);
		return _pInterface;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator<(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator<(_IUnknown& p) throw()
		{
		return operator<(static_cast<IUnknown*>(&p));
		}

	public: bool operator<(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p)<0;
		}

	public: bool operator<(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface<p) ? true : _CompareUnknown(p) < 0;
		}

	public: bool operator<(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator<(p._pInterface);
		}

	public: bool operator<(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface<NULL;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator>(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator>(_IUnknown& p) throw()
		{
		return operator>(static_cast<IUnknown*>(&p));
		}

	public: bool operator>(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p) > 0;
		}

	public: bool operator>(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface>p) ? true : _CompareUnknown(p) > 0;
		}

	public: bool operator>(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator>(p._pInterface);
		}

	public: bool operator>(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface > NULL;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator<=(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator<=(_IUnknown& p) throw()
		{
		return operator<=(static_cast<IUnknown*>(&p));
		}

	public: bool operator<=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p)<=0;
		}

	public: bool operator<=(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface<=p) ? true : _CompareUnknown(p) <= 0;
		}

	public: bool operator<=(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator<=(p._pInterface);
		}

	public: bool operator<=(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface <= NULL;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator>=(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator>=(_IUnknown& p) throw()
		{
		return operator>=(static_cast<IUnknown*>(&p));
		}

	public: bool operator>=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p) >= 0;
		}

	public: bool operator>=(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface>=p) ? true : _CompareUnknown(p) >= 0;
		}

	public: bool operator>=(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator>=(p._pInterface);
		}

	public: bool operator>=(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface >= NULL;
		}

	#if USE_OLD_COMPILER
	public: operator _IUnknown&() const throw()
		// Provided for casts between different pointer types.
		{
		return *reinterpret_cast<_IUnknown*>(static_cast<IUnknown*>(_pInterface));
		}
	#endif // USE_OLD_COMPILER

	public: void Release() throw()
		// Provides assertion verified, Release()ing of this interface.
		{
		ASSERT(_pInterface);
		if (_pInterface)
			{
			_pInterface->Release();
			_pInterface = NULL;
			}
		}

	public: void AddRef() throw()
		// Provides assertion verified AddRef()ing of this interface.
		{
		ASSERT(_pInterface);
		if (_pInterface)
			_pInterface->AddRef();
		}

	public: Interface* GetInterfacePtr() const throw()
		// Another way to get the interface pointer without casting.
		{
		return _pInterface;
		}

	public: HRESULT CreateInstance(
		const CLSID& clsid, DWORD dwClsContext=CLSCTX_ALL) throw()
		// Loads an interface for the provided CLSID.
		// Returns an HRESULT.  Any previous interface is released.
		{
		_Release();
		const HRESULT hr = CoCreateInstance(clsid, NULL, dwClsContext,
			GetIID(), reinterpret_cast<void**>(&_pInterface));
		ASSERT(SUCCEEDED(hr));
		return hr;
		}

	public: HRESULT CreateInstance(
		LPOLESTR clsidString, DWORD dwClsContext=CLSCTX_ALL) throw()
		// Creates the class specified by clsidString.  clsidString may
		// contain a class id, or a prog id string.
		{
		ASSERT(clsidString);
		CLSID clsid;
		HRESULT hr;
		if (clsidString[0] == '{')
			hr = CLSIDFromString(clsidString, &clsid);
		else
			hr = CLSIDFromProgID(clsidString, &clsid);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		return CreateInstance(clsid, dwClsContext);
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType*& p) throw()
		// Perfoms the QI for the specified IID and returns it in p.
		// As with all QIs, the interface will be AddRef'd.
	#else
	public: HRESULT QueryInterface(const IID& iid, IUnknown*& p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _pInterface ?
			_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p)) :
			E_NOINTERFACE;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType** p) throw()
		// Perfoms the QI for the specified IID and returns it in p.
		// As with all QIs, the interface will be AddRef'd.
	#else
	public: HRESULT QueryInterface(const IID& iid, IUnknown** p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return QueryInterface(iid, *p);
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfaceType> _InterfaceType* QueryInterface(const IID& iid) throw()
		// Perfoms the QI for the specified IID and returns it.
		// As with all QIs, the interface will be AddRef'd.
	#else
	public: IUnknown* QueryInterface(const IID& iid) throw()
	#endif // !USE_OLD_COMPILER
		{
		#if USE_OLD_COMPILER
		typedef IUnknown _InterfaceType;
		#endif // USE_OLD_COMPILER
		_InterfaceType* pInterface;
		QueryInterface(iid, pInterface);
		return pInterface;
		}

	private: Interface* _pInterface;
		// The Interface.

	private: void _Release() throw()
		// Releases only if the interface is not null.
		// The interface is not set to NULL.
		{
		if (_pInterface)
			_pInterface->Release();
		}

	private: void _AddRef() throw()
		// AddRefs only if the interface is not NULL
		{
		if (_pInterface)
			_pInterface->AddRef();
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	private: template<typename _InterfacePtr> HRESULT _QueryInterface(_InterfacePtr p) throw()
		// Performs a QI on pUnknown for the interface type returned
		// for this class.  The interface is stored.  If pUnknown is
		// NULL, or the QI fails, E_NOINTERFACE is returned and
		// _pInterface is set to NULL.
	#else
	private: HRESULT _QueryInterface(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		if (!p) // Can't QI NULL
			{
			operator=(static_cast<Interface*>(NULL));
			return E_NOINTERFACE;
			}

		// Query for this interface
		Interface* pInterface;
		const HRESULT hr = p->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		if (FAILED(hr))
			{
			// If failed intialize interface to NULL and return HRESULT.
			Attach(NULL);
			return hr;
			}

		// Save the interface without AddRef()ing.
		Attach(pInterface);
		return hr;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	private: template<typename _InterfacePtr> int _CompareUnknown(_InterfacePtr& p) throw()
		// Compares the provided pointer with this by obtaining IUnknown interfaces
		// for each pointer and then returning the difference.
	#else
	private: int _CompareUnknown(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		IUnknown* pu1;
		if (_pInterface)
			{
			const HRESULT hr = QueryInterface(IID_IUnknown, pu1);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu1)
				pu1->Release();
			}
		else pu1=NULL;

		IUnknown* pu2;
		if (p)
			{
			const HRESULT hr = p->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&pu2));
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu2)
				pu2->Release();
			}
		else pu2 = NULL;
		return pu1 - pu2;
		}
	}; // class CIP

// Reverse comparison operators for CIP
template<typename _Interface> bool operator==(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p == NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator==(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p == i;
	}

template<typename _Interface> bool operator!=(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p != NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator!=(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p != i;
	}

template<typename _Interface> bool operator<(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p < NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator<(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p < i;
	}

template<typename _Interface> bool operator>(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p > NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator>(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p > i;
	}

template<typename _Interface> bool operator<=(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p <= NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator<=(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p <= i;
	}

template<typename _Interface> bool operator>=(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p >= NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator>=(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p >= i;
	}

#define DEFINE_CIP(x)\
	typedef CIID<x, &IID_##x> x##IID;\
	typedef CIP<x##IID> x##CIP;

#define DECLARE_CIP(x) DEFINE_CIP(x) x##CIP

DEFINE_CIP(IUnknown);

#if USE_OLD_COMPILER
#if USE_INTERMEDIATE_COMPILER
template<>
#endif
class CIP<IUnknownIID>
{
private:
	#if USE_OLD_COMPILER
	// Unique type used to provide for operations between different pointer
	// types.
	class _IUnknown: public IUnknown {};
	#endif // USE_OLD_COMPILER

public:
	// Declare interface type so that the type may be available outside
	// the scope of this template.
	typedef IUnknownIID ThisCIID;
	typedef IUnknown Interface;

	// When the compiler supports references in template params,
	// _CLSID will be changed to a reference.  To avoid conversion
	// difficulties this function should be used to obtain the
	// CLSID.
	static const IID& GetIID() throw()
	{
		return ThisCIID::GetIID();
	}

	// Construct empty in preperation for assignment.
	CIP()  throw()
		: _pInterface(NULL)
	{
	}

	// This constructor is provided to allow NULL assignment.  It will assert
	// if any value other than null is assigned to the object.
	CIP(int null) throw()
		: _pInterface(NULL)
	{
		ASSERT(!null);
	}

	CIP(_IUnknown& p) throw()
		: _pInterface(NULL)
	{
		if (&p)
		{
			const HRESULT hr=_QueryInterface(&p);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
		}
		else _pInterface=NULL;
	}

	// Copy the pointer and AddRef().
	CIP(const CIP& cp)  throw()
		: _pInterface(cp._pInterface)
	{
		_AddRef();
	}

	// Saves the interface
	CIP(Interface* pInterface)  throw()
		: _pInterface(pInterface)
	{
		_AddRef();
	}

	// Copies the pointer.  If bAddRef is TRUE, the interface will
	// be AddRef()ed.
	CIP(Interface* pInterface, bool bAddRef) throw()
		: _pInterface(pInterface)
	{
		if (bAddRef)
		{
			ASSERT(!pInterface);
			_AddRef();
		}
	}

	// Calls CoCreateClass with the provided CLSID.
	CIP(const CLSID& clsid, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		: _pInterface(NULL)
	{
		const HRESULT hr = CreateInstance(clsid, dwClsContext);
		ASSERT(SUCCEEDED(hr));
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	CIP(LPOLESTR str, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		: _pInterface(NULL)
	{
		const HRESULT hr = CreateInstance(str, dwClsContext);
		ASSERT(SUCCEEDED(hr));
	}

	CIP& operator=(_IUnknown& p) throw()
	{
		return operator=(static_cast<IUnknown*>(&p));
	}

	// Saves the interface.
	CIP& operator=(Interface* pInterface) throw()
	{
		if (_pInterface != pInterface)
		{
			Interface* pOldInterface = _pInterface;
			_pInterface = pInterface;
			_AddRef();
			if (pOldInterface)
				pOldInterface->Release();
		}
		return *this;
	}

	// Copies and AddRef()'s the interface.
	CIP& operator=(const CIP& cp) throw()
	{
		return operator=(cp._pInterface);
	}

	// This operator is provided to permit the assignment of NULL to the class.
	// It will assert if any value other than NULL is assigned to it.
	CIP& operator=(int null) throw()
	{
		ASSERT(!null);
		return operator=(reinterpret_cast<Interface*>(NULL));
	}

	// If we still have an interface then Release() it.  The interface
	// may be NULL if Detach() has previosly been called, or if it was
	// never set.
	~CIP() throw()
	{
		_Release();
	}

	// Saves/sets the interface without AddRef()ing.  This call
	// will release any previously aquired interface.
	void Attach(Interface* pInterface) throw()
	{
		_Release();
		_pInterface = pInterface;
	}

	// Saves/sets the interface only AddRef()ing if bAddRef is TRUE.
	// This call will release any previously aquired interface.
	void Attach(Interface* pInterface, bool bAddRef) throw()
	{
		_Release();
		_pInterface = pInterface;
		if (bAddRef)
		{
			ASSERT(pInterface);
			if (pInterface)
				pInterface->AddRef();
		}
	}

	// Simply NULL the interface pointer so that it isn't Released()'ed.
	IUnknown* Detach() throw()
	{
		ASSERT(_pInterface);
        IUnknown* const old = _pInterface;
		_pInterface = NULL;
        return old;
	}

	// Return the interface.  This value may be NULL
	operator Interface*() const throw()
	{
		return _pInterface;
	}

	// Queries for the unknown and return it
	// Provides minimal level assertion before use.
	operator Interface&() const throw()
	{
		ASSERT(_pInterface);
		return *_pInterface;
	}

	// Allows an instance of this class to act as though it were the
	// actual interface.  Also provides minimal assertion verification.
	Interface& operator*() const throw()
	{
		ASSERT(_pInterface);
		return *_pInterface;
	}

	// Returns the address of the interface pointer contained in this
	// class.  This is useful when using the COM/OLE interfaces to create
	// this interface.
	Interface** operator&() throw()
	{
		_Release();
		_pInterface = NULL;
		return &_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple assertion verification.
	Interface* operator->() const throw()
	{
		ASSERT(_pInterface);
		return _pInterface;
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	operator bool() const throw()
	{
		return _pInterface;
	}

	// Returns TRUE if the interface is NULL.
	// This operator will be removed when support for type bool
	// is added to the compiler.
	bool operator!() throw()
	{
		return !_pInterface;
	}

	bool operator==(_IUnknown& p) throw()
	{
		return operator==(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator==(Interface* p) throw()
	{
		return (_pInterface==p)?true:!_CompareUnknown(p);
	}

	// Compares 2 CIPs
	bool operator==(CIP& p) throw()
	{
		return operator==(p._pInterface);
	}

	// For comparison to NULL
	bool operator==(int null) throw()
	{
		ASSERT(!null);
		return !_pInterface;
	}

	bool operator!=(_IUnknown& p) throw()
	{
		return operator!=(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator!=(Interface* p) throw()
	{
		return (_pInterface!=p)?true:_CompareUnknown(p);
	}

	// Compares 2 CIPs
	bool operator!=(CIP& p) throw()
	{
		return operator!=(p._pInterface);
	}

	// For comparison to NULL
	bool operator!=(int null) throw()
	{
		ASSERT(!null);
		return _pInterface;
	}

	bool operator<(_IUnknown& p) throw()
	{
		return operator<(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator<(Interface* p) throw()
	{
		return (_pInterface<p)?true:_CompareUnknown(p)<0;
	}

	// Compares 2 CIPs
	bool operator<(CIP& p) throw()
	{
		return operator<(p._pInterface);
	}

	// For comparison with NULL
	bool operator<(int null) throw()
	{
		ASSERT(!null);
		return _pInterface<NULL;
	}

	bool operator>(_IUnknown& p) throw()
	{
		return operator>(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator>(Interface* p) throw()
	{
		return (_pInterface>p)?true:_CompareUnknown(p)>0;
	}

	// Compares 2 CIPs
	bool operator>(CIP& p) throw()
	{
		return operator>(p._pInterface);
	}

	// For comparison with NULL
	bool operator>(int null) throw()
	{
		ASSERT(!null);
		return _pInterface>NULL;
	}

	bool operator<=(_IUnknown& p) throw()
	{
		return operator<=(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator<=(Interface* p) throw()
	{
		return (_pInterface<=p)?true:_CompareUnknown(p)<=0;
	}

	// Compares 2 CIPs
	bool operator<=(CIP& p) throw()
	{
		return operator<=(p._pInterface);
	}

	// For comparison with NULL
	bool operator<=(int null) throw()
	{
		ASSERT(!null);
		return _pInterface<=NULL;
	}

	bool operator>=(_IUnknown& p) throw()
	{
		return operator>=(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator>=(Interface* p) throw()
	{
		return (_pInterface>=p)?true:_CompareUnknown(p)>=0;
	}

	// Compares 2 CIPs
	bool operator>=(CIP& p) throw()
	{
		return operator>=(p._pInterface);
	}

	// For comparison with NULL
	bool operator>=(int null) throw()
	{
		ASSERT(!null);
		return _pInterface>=NULL;
	}

	// Provided for casts between different pointer types.
	operator _IUnknown&() const throw()
	{
		return *reinterpret_cast<_IUnknown*>(static_cast<IUnknown*>(_pInterface));
	}

	// Provides assertion verified, Release()ing of this interface.
	void Release() throw()
	{
		ASSERT(_pInterface);
		if (_pInterface)
			{
			_pInterface->Release();
			_pInterface = NULL;
			}
	}

	// Provides assertion verified AddRef()ing of this interface.
	void AddRef() throw()
	{
		ASSERT(_pInterface);
		if (_pInterface)
			_pInterface->AddRef();
	}

	// Another way to get the interface pointer without casting.
	Interface* GetInterfacePtr() const throw()
	{
		return _pInterface;
	}

	// Loads an interface for the provided CLSID.
	// Returns an HRESULT.  Any previous interface is released.
	HRESULT CreateInstance(
		const CLSID& clsid, DWORD dwClsContext=CLSCTX_ALL) throw()
	{
		_Release();
		const HRESULT hr = CoCreateInstance(clsid, NULL, dwClsContext,
			GetIID(), reinterpret_cast<void**>(&_pInterface));
		ASSERT(SUCCEEDED(hr));
		return hr;
	}

	// Creates the class specified by clsidString.  clsidString may
	// contain a class id, or a prog id string.
	HRESULT CreateInstance(
		LPOLESTR clsidString, DWORD dwClsContext=CLSCTX_ALL) throw()
	{
		ASSERT(clsidString);
		CLSID clsid;
		HRESULT hr;
		if (clsidString[0] == '{')
			hr = CLSIDFromString(clsidString, &clsid);
		else
			hr = CLSIDFromProgID(clsidString, &clsid);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		return CreateInstance(clsid, dwClsContext);
	}

	HRESULT QueryInterface(const IID& iid, IUnknown*& p) throw()
	{
		return _pInterface ?
			_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p)) :
			E_NOINTERFACE;
	}

	HRESULT QueryInterface(const IID& iid, IUnknown** p) throw()
	{
		return QueryInterface(iid, *p);
	}

	// Perfoms the QI for the specified IID and returns it.
	// As with all QIs, the interface will be AddRef'd.
	IUnknown* QueryInterface(const IID& iid) throw()
	{
		typedef IUnknown _InterfaceType;
		_InterfaceType* pInterface;
		QueryInterface(iid, pInterface);
		return pInterface;
	}

private:
	// The Interface.
	Interface* _pInterface;

	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	void _Release() throw()
	{
		if (_pInterface)
			_pInterface->Release();
	}

	// AddRefs only if the interface is not NULL
	void _AddRef() throw()
	{
		if (_pInterface)
			_pInterface->AddRef();
	}

	// Performs a QI on pUnknown for the interface type returned
	// for this class.  The interface is stored.  If pUnknown is
	// NULL, or the QI fails, E_NOINTERFACE is returned and
	// _pInterface is set to NULL.
	HRESULT _QueryInterface(IUnknown* p) throw()
	{
		if (!p) // Can't QI NULL
		{
			operator=(static_cast<Interface*>(NULL));
			return E_NOINTERFACE;
		}

		// Query for this interface
		Interface* pInterface;
		const HRESULT hr = p->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		if (FAILED(hr))
		{
			// If failed intialize interface to NULL and return HRESULT.
			Attach(NULL);
			return hr;
		}

		// Save the interface without AddRef()ing.
		Attach(pInterface);
		return hr;
	}

	// Compares the provided pointer with this by obtaining IUnknown interfaces
	// for each pointer and then returning the difference.
	int _CompareUnknown(IUnknown* p) throw()
	{
		IUnknown* pu1;
		if (_pInterface)
		{
			const HRESULT hr=QueryInterface(IID_IUnknown, pu1);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu1)
				pu1->Release();
		}
		else pu1=NULL;

		IUnknown* pu2;
		if (p)
		{
			const HRESULT hr=p->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&pu2));
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu2)
				pu2->Release();
		}
		else pu2=NULL;
		return pu1-pu2;
	}
}; // class CIP
#endif // USE_OLD_COMPILER

#endif // _MSC_VER < 1100
#endif // COMPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(AMCCore)
    #define DBG_COMP    AMCCoreInfoLevel

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\coremfc.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       mfccore.cpp
//
//  Contents:   put functions that use mfc in here.
//
//  Classes:
//
//  Functions:
//
//  History:   
//
//____________________________________________________________________________

#include <afx.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "ndmgr.h"
#include "safetemp.h"
#include "guidhelp.h"

#include "macros.h"
USE_HANDLE_MACROS("GUIDHELP(guidhelp.cpp)")

#include <basetyps.h>
#include "cstr.h"
#include "regkey.h"
#include "bitmap.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CLIPFORMAT g_CFNodeType = 0;
static CLIPFORMAT g_CFSnapInCLSID = 0;  
static CLIPFORMAT g_CFDisplayName = 0;

HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CString*     pstr,           // OUT: Pointer to CStr to store data
                       DWORD        cchMaxLength)
{
	if (pstr == NULL)
		return E_POINTER;

	CStr cstr(*pstr);

	HRESULT hr = ExtractString(piDataObject, cfClipFormat, &cstr, cchMaxLength);
	
	*pstr = cstr;

	return hr;
} 


HRESULT GuidToCString( CString* pstr, const GUID& guid )
{
	if (pstr == NULL)
		return E_POINTER;

	CStr cstr(*pstr);

	HRESULT hr = GuidToCStr(&cstr, guid);
	
	*pstr = cstr;

	return S_OK;
}


HRESULT LoadRootDisplayName(IComponentData* pIComponentData, 
                            CString& strDisplayName)
{
	CStr cstr = strDisplayName;

	HRESULT hr = LoadRootDisplayName(pIComponentData, cstr);
	
	strDisplayName = cstr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\dispid.h ===
#ifndef _DISP_ID_H
#define _DISP_ID_H

// CCListView dispIDs
#define DISPID_CCLV_LISTSTYLE           0x0001
#define DISPID_CCLV_INSERTITEM          0x0002
#define DISPID_CCLV_DELETEITEM          0x0003
#define DISPID_CCLV_FINDITEMBYSTRING    0x0004
#define DISPID_CCLV_FINDITEMBYLPARAM    0x0005
#define DISPID_CCLV_INSERTCOLUMN        0x0006
#define DISPID_CCLV_DELETECOLUMN        0x0007
#define DISPID_CCLV_FINDCOLUMNBYSTRING  0x0008
#define DISPID_CCLV_DELETEALLITEMS      0x0009
#define DISPID_CCLV_SETCOLUMN           0x000A
#define DISPID_CCLV_GETCOLUMN           0x000B
#define DISPID_CCLV_SETITEM             0x000C
#define DISPID_CCLV_GETITEM             0x000D
#define DISPID_CCLV_GETNEXTITEM         0x000E
#define DISPID_CCLV_GETLPARAM           0x000F
#define DISPID_CCLV_SETICON             0x0010
#define DISPID_CCLV_SETIMAGESTRIP       0x0011
#define DISPID_CCLV_MAPIMAGE            0x0012
#define DISPID_CCLV_RESET               0x0013
#define DISPID_CCLV_HITTEST             0x0014
#define DISPID_CCLV_ARRANGE             0x0015
#define DISPID_CCLV_UPDATEITEM          0x0016
#define DISPID_CCLV_SORT                0x0017
#define DISPID_CCLV_MODIFYITEMSTATE     0x0018

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\cstr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include <stdio.h>
#include <objbase.h>

#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"


/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
TCHAR strChNil = '\0';

// for creating empty key strings
const CStr strEmptyString;

void CStr::Init()
{
	m_nDataLength = m_nAllocLength = 0;
	m_pchData = (LPTSTR)&strChNil;
}

// declared static
void CStr::SafeDelete(LPTSTR lpch)
{
	if (lpch != (LPTSTR)&strChNil)
		delete[] lpch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStr::CStr()
{
	Init();
}

CStr::CStr(const CStr& stringSrc)
{
	// if constructing a String from another String, we make a copy of the
	// original string data to enforce value semantics (i.e. each string
	// gets a copy of its own

	stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CStr::AllocBuffer(size_t nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
	if (nLen == 0)
	{
		Init();
	}
	else
	{
		m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception
		m_pchData[nLen] = '\0';
		m_nDataLength = nLen;
		m_nAllocLength = nLen;
	}
}

void CStr::Empty()
{
	SafeDelete(m_pchData);
	Init();
	ASSERT(m_nDataLength == 0);
	ASSERT(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
	SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline size_t SafeStrlen(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, size_t nCopyLen, size_t nCopyIndex,
	 size_t nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	size_t nNewLen = nCopyLen + nExtraLen;

	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
	size_t nLen;
	if ((nLen = SafeStrlen(lpsz)) == 0)
		Init();
	else
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef UNICODE
CStr::CStr(LPCSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen == 0)
		Init();
	else
	{
		AllocBuffer(nSrcLen);
		mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	}
}
#else //UNICODE
CStr::CStr(LPCWSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen == 0)
		Init();
	else
	{
		AllocBuffer(nSrcLen*2);
		mmc_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!UNICODE


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(size_t nSrcLen, LPCTSTR lpszSrcData)
{
	// check if it will fit
	if (nSrcLen > m_nAllocLength)
	{
		// it won't fit, allocate another one
		Empty();
		AllocBuffer(nSrcLen);
	}
	if (nSrcLen != 0)
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	m_nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
	AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
	return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef UNICODE
const CStr& CStr::operator=(LPCSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	// check if it will fit
	if (nSrcLen > m_nAllocLength)
	{
		// it won't fit, allocate another one
		Empty();
		AllocBuffer(nSrcLen);
	}
	if (nSrcLen != 0)
		mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	m_nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
	return *this;
}
#else //!UNICODE
const CStr& CStr::operator=(LPCWSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	nSrcLen *= 2;
	// check if it will fit
	if (nSrcLen > m_nAllocLength)
	{
		// it won't fit, allocate another one
		Empty();
		AllocBuffer(nSrcLen);
	}
	if (nSrcLen != 0)
	{
		mmc_wcstombsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = TCHAR, LPCTSTR
//          String + ?
//          ? + String

void CStr::ConcatCopy(size_t nSrc1Len, LPCTSTR lpszSrc1Data,
	size_t nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

	size_t nNewLen = nSrc1Len + nSrc2Len;
	AllocBuffer(nNewLen);
	memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
	memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
}

CStr STRAPI operator+(const CStr& string1, const CStr& string2)
{
	CStr s;
	s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
		string2.m_nDataLength, string2.m_pchData);
	return s;
}

CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	CStr s;
	s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlen(lpsz), lpsz);
	return s;
}

CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	CStr s;
	s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStr::ConcatInPlace(size_t nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (m_nDataLength + nSrcLen > m_nAllocLength)
	{
		// we have to grow the buffer, use the Concat in place routine
		LPTSTR lpszOldData = m_pchData;
		ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
		ASSERT(lpszOldData != NULL);
		SafeDelete(lpszOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(TCHAR));
		m_nDataLength += nSrcLen;
	}
	ASSERT(m_nDataLength <= m_nAllocLength);
	m_pchData[m_nDataLength] = '\0';
}

const CStr& CStr::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CStr& CStr::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CStr& CStr::operator+=(const CStr& string)
{
	ConcatInPlace(string.m_nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CStr::GetBuffer(size_t nMinBufLength)
{
	if (nMinBufLength > m_nAllocLength)
	{
		// we have to grow the buffer
		LPTSTR lpszOldData = m_pchData;
		size_t nOldLen = m_nDataLength;        // AllocBuffer will tromp it

		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, lpszOldData, nOldLen*sizeof(TCHAR));
		m_nDataLength = nOldLen;
		m_pchData[m_nDataLength] = '\0';

		SafeDelete(lpszOldData);
	}

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CStr::ReleaseBuffer(size_t nNewLength)
{
	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= m_nAllocLength);
	m_nDataLength = nNewLength;
	m_pchData[m_nDataLength] = '\0';
}

LPTSTR CStr::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	m_nDataLength = nNewLength;
	m_pchData[m_nDataLength] = '\0';
	return m_pchData;
}

void CStr::FreeExtra()
{
	ASSERT(m_nDataLength <= m_nAllocLength);
	if (m_nDataLength != m_nAllocLength)
	{
		LPTSTR lpszOldData = m_pchData;
		AllocBuffer(m_nDataLength);
		memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[m_nDataLength] == '\0');
		SafeDelete(lpszOldData);
	}
	ASSERT(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStr::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStr::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(IsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
// String conversion helpers (these use the current system locale)

size_t mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	size_t result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (int) count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

size_t mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	size_t result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (int) count);
	ASSERT(wcstr == NULL || result <= count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStr::LoadString(HINSTANCE hInst, UINT nID)
{
	ASSERT(nID != 0);       // 0 is an illegal string ID

	// Note: resource strings limited to 511 characters
	TCHAR szBuffer[512];
	UINT nSize = StrLoadString(hInst, nID, szBuffer);
	AssignCopy(nSize, szBuffer);
	return nSize > 0;
}


int STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf)
{
	ASSERT(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //DBG
	int nLen = ::LoadString(hInst, nID, lpszBuf, 511);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


BOOL STRAPI IsValidString(LPCSTR lpsz, UINT_PTR nLength)
{
	if (lpsz == NULL)
		return FALSE;
	return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, UINT_PTR nLength)
{
	if (lpsz == NULL)
		return FALSE;

	return ::IsBadStringPtrW(lpsz, nLength) == 0;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStr::AllocSysString()
{
	BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
	if (bstr == NULL)
		;//REVIEW AfxThrowMemoryException();

	return bstr;
}

BSTR CStr::SetSysString(BSTR* pbstr)
{
	ASSERT(IsValidAddressz(pbstr, sizeof(BSTR)));

	if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
		; //REVIEW AfxThrowMemoryException();

	ASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp 


CStr::CStr(TCHAR ch, int nLength)
{
#ifndef UNICODE
	ASSERT(!IsDBCSLeadByte(ch));    // can't create a lead byte string
#endif
	if (nLength < 1)
	{
		// return empty string if invalid repeat count
		Init();
	}
	else
	{
		AllocBuffer(nLength);
#ifdef UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CStr::CStr(LPCTSTR lpch, int nLength)
{
	if (nLength == 0)
		Init();
	else
	{
		ASSERT(IsValidAddressz(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStr& CStr::operator=(TCHAR ch)
{
#ifndef UNICODE
	ASSERT(!IsDBCSLeadByte(ch));    // can't set single lead byte
#endif
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStr STRAPI operator+(const CStr& string1, TCHAR ch)
{
	CStr s;
	s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CStr STRAPI operator+(TCHAR ch, const CStr& string)
{
	CStr s;
	s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStr CStr::Mid(size_t nFirst) const
{
	return Mid(nFirst, m_nDataLength - nFirst);
}

CStr CStr::Mid(size_t nFirst, size_t nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst + nCount > m_nDataLength)
		nCount = m_nDataLength - nFirst;
	if (nFirst > m_nDataLength)
		nCount = 0;

	CStr dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CStr CStr::Right(size_t nCount) const
{
	if (nCount > m_nDataLength)
		nCount = m_nDataLength;

	CStr dest;
	AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
	return dest;
}

CStr CStr::Left(size_t nCount) const
{
	if (nCount > m_nDataLength)
		nCount = m_nDataLength;

	CStr dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CStr CStr::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(IsValidString(lpszCharSet, FALSE));
	return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStr CStr::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(IsValidString(lpszCharSet, FALSE));
	return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStr::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStr::Find(LPCTSTR lpszSub) const
{
	ASSERT(IsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStr::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(IsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);

	// make a guess at the maximum length of the resulting string
	size_t nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, char);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR);
			break;

		// strings
		case 's':
		case 'S':
			nItemLen = lstrlen(va_arg(argList, LPCTSTR));
			nItemLen = __max(1, nItemLen);
			break;
		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			nItemLen = lstrlenA(va_arg(argList, LPCSTR));
			nItemLen = __max(1, nItemLen);
			break;
#ifndef _MAC
		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			nItemLen = (int) wcslen(va_arg(argList, LPWSTR));
			nItemLen = __max(1, nItemLen);
			break;
#endif
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = __max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = __min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = __max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, _STR_DOUBLE);
				nItemLen = 128;
				nItemLen = __max(nItemLen, nWidth+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = __max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}
	va_end(argList);

	// finally, set the buffer length and format the string
	va_start(argList, lpszFormat);  // restart the arg list
	GetBuffer(nMaxLen);
	VERIFY(_vstprintf(m_pchData, lpszFormat, argList) <= (int) nMaxLen);
	ReleaseBuffer();
	va_end(argList);
}

void CStr::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		m_nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CStr::TrimLeft()
{
	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	size_t nDataLength = m_nDataLength - (int)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	m_nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

void STRAPI ConstructElements(CStr* pElements, int nCount)
{
	ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

	for (; nCount--; ++pElements)
		memcpy(pElements, &strEmptyString, sizeof(*pElements));
}

void STRAPI DestructElements(CStr* pElements, int nCount)
{
	ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

	for (; nCount--; ++pElements)
		pElements->Empty();
}

UINT STRAPI HashKey(LPCTSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\guidhelp.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       guidhelp.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/18/1996   JonN    Created
//
//____________________________________________________________________________


#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"


#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "ndmgr.h"
#include "safetemp.h"
#include "guidhelp.h"

#include "atlbase.h" // USES_CONVERSION

#include "macros.h"
USE_HANDLE_MACROS("GUIDHELP(guidhelp.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static CLIPFORMAT g_CFNodeType = 0;
static CLIPFORMAT g_CFSnapInCLSID = 0;  
static CLIPFORMAT g_CFDisplayName = 0;


HRESULT ExtractData( IDataObject* piDataObject,
                     CLIPFORMAT cfClipFormat,
                     PVOID        pbData,
                     DWORD        cbData )
{
    TEST_NONNULL_PTR_PARAM( piDataObject );
    TEST_NONNULL_PTR_PARAM( pbData );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            // JonN Jan 7 1999: don't assert here, some errors are perfectly reasonable
            break;
        }
        
        PVOID pbNewData = reinterpret_cast<PVOID>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
        //VERIFY( stgmedium.hGlobal);
        VERIFY( NULL == ::GlobalFree(stgmedium.hGlobal) );
    }
    return hr;
} // ExtractData()


HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CStr*     pstr,           // OUT: Pointer to CStr to store data
                       DWORD        cchMaxLength)
{
    TEST_NONNULL_PTR_PARAM( piDataObject );
    TEST_NONNULL_PTR_PARAM( pstr );
    ASSERT( cchMaxLength > 0 );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, sizeof(WCHAR)*cchMaxLength);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            // This failure happens when 'searching' for
            // clipboard format supported by the IDataObject.
            // t-danmo (24-Oct-96)
            // Skipping ASSERT( FALSE );
            break;
        }
        
        LPWSTR pszNewData = reinterpret_cast<LPWSTR>(stgmedium.hGlobal);
        if (NULL == pszNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        pszNewData[cchMaxLength-1] = L'\0'; // just to be safe
        USES_CONVERSION;
        *pstr = OLE2T(pszNewData);
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
        VERIFY(NULL == ::GlobalFree(stgmedium.hGlobal));
    }
    return hr;
} // ExtractString()


HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
	if( !g_CFSnapInCLSID )
	{
		USES_CONVERSION;
		g_CFSnapInCLSID = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID));
	}

    return ExtractData( piDataObject, g_CFSnapInCLSID, (PVOID)pclsidSnapin, sizeof(CLSID) );
}

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
	if( !g_CFNodeType )
	{
		USES_CONVERSION;
		g_CFNodeType = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_NODETYPE));
	}

    return ExtractData( piDataObject, g_CFNodeType, (PVOID)pguidObjectType, sizeof(GUID) );
}

HRESULT GuidToCStr( CStr* pstr, const GUID& guid )
{
    WCHAR awch[MAX_PATH];
    HRESULT hr = StringFromGUID2(guid, awch, MAX_PATH); // JonN 11/21/00 PREFIX 226769
    ASSERT(SUCCEEDED(hr));
    USES_CONVERSION;
    LPTSTR lptstr = OLE2T(awch);
    *pstr = lptstr;
    return hr;
}

HRESULT CStrToGuid( const CStr& str, GUID* pguid )
{
    USES_CONVERSION;
    LPOLESTR lpolestr = T2OLE(((LPTSTR)(LPCTSTR)str));
    HRESULT hr = CLSIDFromString(lpolestr, pguid);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

#if 0
HRESULT bstrToGuid( const bstr& str, GUID* pguid )
{
    HRESULT hr = CLSIDFromString(const_cast<LPOLESTR>((LPCWSTR)str), pguid);
    ASSERT(SUCCEEDED(hr));
    return hr;
}
#endif

HRESULT LoadRootDisplayName(IComponentData* pIComponentData, 
                            CStr& strDisplayName)
{
    IDataObject* pIDataObject = NULL;
    HRESULT hr = pIComponentData->QueryDataObject(NULL, CCT_SNAPIN_MANAGER, &pIDataObject);
    CHECK_HRESULT(hr);
    if ( FAILED(hr) )
        return hr;
    XSafeInterfacePtr<IDataObject> safeDataObject( pIDataObject, FALSE );

    if( !g_CFDisplayName )
	{
		USES_CONVERSION;
		g_CFDisplayName = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME));
	}

    hr = ExtractString( pIDataObject,
                        g_CFDisplayName,
                        &strDisplayName,
                        MAX_PATH); // CODEWORK maximum length
    CHECK_HRESULT(hr);
    return hr;
}


HRESULT LoadAndAddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    UINT nResourceID, // contains text and status text seperated by '\n'
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst)
{
    ASSERT( pIContextMenuCallback != NULL );

    // load the resource
    CStr strText;
    strText.LoadString(hInst,  nResourceID );
    ASSERT( !strText.IsEmpty() );

    // split the resource into the menu text and status text
    CStr strStatusText;
    int iSeparator = strText.Find(_T('\n'));
    if (0 > iSeparator)
    {
        ASSERT( FALSE );
        strStatusText = strText;
    }
    else
    {
        strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
        strText = strText.Left( iSeparator );
    }

    // add the menu item
    USES_CONVERSION;
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
    contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = fFlags;
    contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L);
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);

    return hr;
}

HRESULT AddSpecialSeparator(
    IContextMenuCallback* pIContextMenuCallback,
    long lInsertionPointID )
{
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = 0;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = MF_SEPARATOR;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);

    return hr;
}

HRESULT AddSpecialInsertionPoint(
    IContextMenuCallback* pIContextMenuCallback,
    long lCommandID,
    long lInsertionPointID )
{
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = 0;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\cstr.h ===
#ifndef __STR_H__
#define __STR_H__

#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, UINT_PTR nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, UINT_PTR nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 

class CStr
{
public:

// Constructors
	CStr();
	CStr(const CStr& stringSrc);
	CStr(TCHAR ch, int nRepeat = 1);
	CStr(LPCSTR lpsz);
	CStr(LPCWSTR lpsz);
	CStr(LPCTSTR lpch, int nLength);
	CStr(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	size_t GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(size_t nIndex) const;      // 0 based
	TCHAR operator[](size_t nIndex) const; // same as GetAt
	void SetAt(size_t nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CStr& operator=(const CStr& stringSrc);
	const CStr& operator=(TCHAR ch);
#ifdef UNICODE
	const CStr& operator=(char ch);
#endif
	const CStr& operator=(LPCSTR lpsz);
	const CStr& operator=(LPCWSTR lpsz);
	const CStr& operator=(const unsigned char* psz);

	// string concatenation
	const CStr& operator+=(const CStr& string);
	const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
	const CStr& operator+=(char ch);
#endif
	const CStr& operator+=(LPCTSTR lpsz);

	friend CStr STRAPI operator+(const CStr& string1,
			const CStr& string2);
	friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
	friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
	friend CStr STRAPI operator+(const CStr& string, char ch);
	friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
	friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
	friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CStr Mid(size_t nFirst, size_t nCount) const;
	CStr Mid(size_t nFirst) const;
	CStr Left(size_t nCount) const;
	CStr Right(size_t nCount) const;

	CStr SpanIncluding(LPCTSTR lpszCharSet) const;
	CStr SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void Format(LPCTSTR lpszFormat, ...);

	// Windows support
	BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
										// 255 chars max
#ifndef UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif
	BSTR AllocSysString();
	BSTR SetSysString(BSTR* pbstr);

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(size_t nMinBufLength);
	void ReleaseBuffer(size_t nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

// Implementation
public:
	~CStr();
	size_t GetAllocLength() const;

protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	LPTSTR m_pchData;           // actual string (zero terminated)
	size_t m_nDataLength;          // does not include terminating 0
	size_t m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CStr& dest, size_t nCopyLen, size_t nCopyIndex, size_t nExtraLen) const;
	void AllocBuffer(size_t nLen);
	void AssignCopy(size_t nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(size_t nSrc1Len, LPCTSTR lpszSrc1Data, size_t nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(size_t nSrcLen, LPCTSTR lpszSrcData);
	static void SafeDelete(LPTSTR lpch);
	static size_t SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL STRAPI operator==(const CStr& s1, const CStr& s2);
BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
size_t mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
size_t mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyString;
extern TCHAR strChNil;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline size_t CStr::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? NULL : _tcslen(lpsz); }
inline CStr::CStr(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
	{ return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
	{ return (TCHAR)ch + string; }
#endif

inline size_t CStr::GetLength() const
	{ return m_nDataLength; }
inline size_t CStr::GetAllocLength() const
	{ return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
	{ return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
	{ return (LPCTSTR)m_pchData; }

// String support (windows specific)
inline int CStr::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStr::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStr::MakeUpper()
	{ ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
	{ ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
	{ _tcsrev(m_pchData); }
inline TCHAR CStr::GetAt(size_t nIndex) const
	{
		ASSERT(nIndex < m_nDataLength);

		return m_pchData[nIndex];
	}
inline TCHAR CStr::operator[](size_t nIndex) const
	{
		// same as GetAt

		ASSERT(nIndex < m_nDataLength);

		return m_pchData[nIndex];
	}
inline void CStr::SetAt(size_t nIndex, TCHAR ch)
	{
		ASSERT(nIndex < m_nDataLength);
		ASSERT(ch != 0);

		m_pchData[nIndex] = ch;
	}
inline BOOL STRAPI operator==(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) == 0; }
inline BOOL STRAPI operator!=(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) != 0; }
inline BOOL STRAPI operator<(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) < 0; }
inline BOOL STRAPI operator<=(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) <= 0; }

#ifndef UNICODE
inline void CStr::AnsiToOem()
	{ ::AnsiToOem(m_pchData, m_pchData); }
inline void CStr::OemToAnsi()
	{ ::OemToAnsi(m_pchData, m_pchData); }

#endif // UNICODE

// General Exception for memory
class MemoryException
{
public:
	MemoryException(){}
	void DisplayMessage()
	{
	::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
	}
};

// General Exception for memory
class ResourceException
{
public:
	ResourceException()
	{
	::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
	}
};

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmcptrs.h ===
#ifndef MMCPTRS_H
#define MMCPTRS_H

#ifndef COMPTRS_H
#pragma warning(disable:4800)
#include <comptr.h>
//DEFINE_CIP(IPersistStorage);
#endif

DEFINE_CIP(IScopeTree);
DEFINE_CIP(IScopeTreeIter);
DEFINE_CIP(INodeCallback);
DEFINE_CIP(IResultDataCompare);
DEFINE_CIP(IComponent);
DEFINE_CIP(IComponentData);
DEFINE_CIP(IContextMenuProvider);
DEFINE_CIP(IControlbar);
DEFINE_CIP(IControlbarsCache);
DEFINE_CIP(IExtendContextMenu);
DEFINE_CIP(IExtendControlbar);
DEFINE_CIP(IExtendPropertySheet);
DEFINE_CIP(IFramePrivate);
DEFINE_CIP(IHeaderCtrl);
DEFINE_CIP(IImageListPrivate);
DEFINE_CIP(IPropertySheetCallback);
DEFINE_CIP(IPropertySheetProvider);
DEFINE_CIP(IResultDataPrivate);
DEFINE_CIP(IScopeDataPrivate);
DEFINE_CIP(IConsoleVerb);
DEFINE_CIP(ISnapinAbout);
DEFINE_CIP(IPropertySheetProviderPrivate);
DEFINE_CIP(IMenuButton);
DEFINE_CIP(IMMCListView);
DEFINE_CIP(IResultOwnerData);

#endif // MMCPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmcplex_.h ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __MMCPLEX_H__
#define __MMCPLEX_H__


struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__MMCPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmclv.h ===
#ifndef MMCLV_H
#define MMCLV_H


class IListViewPrivate : public IUnknown
    {
    public: virtual long GetListStyle()=0;
    public: virtual void SetListStyle(long nNewValue)=0;
    public: virtual HRESULT InsertItem(LPCOLESTR str, long iconNdx, 
        long lParam, long state, COMPONENTID ownerID, CCLVItemID *pItemID)=0;
    public: virtual HRESULT DeleteItem(CCLVItemID itemID, long nCol)=0;
    public: virtual HRESULT FindItemByString(LPCOLESTR str, long nCol, 
                long occurrence, COMPONENTID ownerID, CCLVItemID *pItemID)=0;
    public: virtual HRESULT FindItemByLParam(COMPONENTID ownerID, 
                                        long lParam, CCLVItemID *pItemID)=0;
    public: virtual HRESULT InsertColumn(long nCol, LPCOLESTR str, long nFormat, 
                                                                long width)=0;
    public: virtual HRESULT DeleteColumn(long subIndex)=0;
    public: virtual HRESULT FindColumnByString(LPCOLESTR str, long occurrence, 
                                                        long* pResult)=0;
    public: virtual HRESULT DeleteAllItems(COMPONENTID ownerID)=0;
    public: virtual HRESULT SetColumn(long nCol, LPCOLESTR str, long nFormat, 
                                                                int width)=0;
    public: virtual HRESULT GetColumn(long nCol, LPOLESTR* str, LPLONG nFormat, 
                                                                int* width)=0;
    public: virtual HRESULT SetItem(int nIndex, CCLVItemID itemID, 
                long nCol, LPCOLESTR str, int nImage, long lParam, 
                unsigned int nState, COMPONENTID ownerID)=0;
    public: virtual HRESULT GetItem(int nIndex, CCLVItemID itemID, 
            long nCol, LPOLESTR* str, int* nImage, LPLONG lParam, 
            unsigned int* nState, COMPONENTID ownerID)=0;
    public: virtual HRESULT GetNextItem(COMPONENTID ownerID, long nIndex, 
                              UINT nState, LPLONG plParam, long* pnIndex)=0;
    public: virtual HRESULT GetLParam(long nItem, LPLONG pLParam)=0;
    public: virtual HRESULT ModifyItemState(long nItem, CCLVItemID itemID, UINT add, UINT remove)=0;
    public: virtual HRESULT SetIcon(long nID, LPLONG hIcon, long nLoc)=0;
    public: virtual HRESULT SetImageStrip(long nID, LPLONG pBMapSm, 
            LPLONG pBMapLg, long nStartLoc, COLORREF cMask, long nEntries)=0;
    public: virtual HRESULT MapImage(COMPONENTID nID, int nLoc, int *pResult)=0;
    public: virtual HRESULT Reset()=0;
    public: virtual HRESULT HitTest(int nX, int nY, int *piItem, UINT *flags, 
                                                        CCLVItemID *pItemID)=0;
    public: virtual HRESULT Arrange(long style)=0;
    public: virtual HRESULT UpdateItem(CCLVItemID itemID)=0;
    public: public: virtual HRESULT Sort(LPARAM lUserParam, long* lCompareFunction)=0;
    }; // class IListViewPrivate

extern const IID IID_IListViewPrivate;

#ifdef DEFINE_CIP
DEFINE_CIP(IListViewPrivate)
#endif // DEFINE_CIP

#endif // MMCLV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmcdata.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       MMCData.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2/27/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef __MMCDATA__H__
#define __MMCDATA__H__

#include "ndmgr.h"

#ifndef MMCPTRS_H
#include <mmcptrs.h>
#endif 

class CToolBarCtrlEx;
class CMultiSelection;


//////////////////////////////////////////////////////////////////////////////
//
// SConsoleData structure.
//


struct SConsoleData
{
    IScopeTreeCIP           m_spScopeTree;

    HWND                    m_hwndMainFrame;
};


//////////////////////////////////////////////////////////////////////////////
//
// SViewData structure.
//

struct SViewData
{
/*
    HWND GetFrameHandle() 
    {
        if (m_pConsoleData)
            return m_pConsoleData->m_hwndMainFrame;

        return NULL;
    }
*/
    HWND GetViewHandle()
    {
        return m_hwndView;
    }

    SConsoleData*           m_pConsoleData;

    int                     m_nViewID;
    
    IFramePrivateCIP        m_spNodeManager;
    IResultDataPrivateCIP   m_spResultData;
    IImageListPrivateCIP    m_spRsltImageList;

    IConsoleVerbCIP         m_spConsoleVerb;

    HWND                    m_hwndView;
    HWND                    m_hwndTreeCtrl;
    HWND                    m_hwndListCtrl;
    HWND                    m_hwndDescriptionBar;
    HWND                    m_hwndControlbar;
    HWND                    m_hwndRebar;  
    HWND                    m_hwndStandardTB;

    long                    m_lViewOptions;
    BOOL                    m_bVirtualList;

    IControlbarsCacheCIP    m_spControlbarsCache;
    IExtendControlbarCIP    m_spMMCBands;
    CToolBarCtrlEx*         m_pMenuBarCtrl;

    CMultiSelection*        m_pMultiSelection;
};



#endif // __MMCDATA__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\guidhelp.h ===
// GUID support functions
#ifndef _GUIDHELP_H
#define _GUIDHELP_H

class CStr;
class CString;

struct IContextMenuCallback;
struct IComponent;

HRESULT ExtractData(   IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       PVOID        pbData,
                       DWORD        cbData );

HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CStr*     pstr,
                       DWORD        cchMaxLength );
HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CString*     pstr,
                       DWORD        cchMaxLength );

HRESULT GuidToCStr( CStr* pstr, const GUID& guid );
HRESULT GuidToCString(CString* pstr, const GUID& guid );

HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );

HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CStr& strDisplayName);
HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CString& strDisplayName);

HRESULT LoadAndAddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    UINT nResourceID, // contains text and status text seperated by '\n'
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst);
HRESULT AddSpecialSeparator(
    IContextMenuCallback* pIContextMenuCallback,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );
HRESULT AddSpecialInsertionPoint(
    IContextMenuCallback* pIContextMenuCallback,
    long lCommandID,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\macros.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       macros.h
//
//  Contents:   Useful macros
//
//  Macros:     ARRAYLEN
//
//              BREAK_ON_FAIL(hresult)
//              BREAK_ON_FAIL(hresult)
//
//              DECLARE_IUNKNOWN_METHODS
//              DECLARE_STANDARD_IUNKNOWN
//              IMPLEMENT_STANDARD_IUNKNOWN
//
//              SAFE_RELEASE
//
//              DECLARE_SAFE_INTERFACE_PTR_MEMBERS
//
//  History:    6/3/1996   RaviR   Created
//              7/23/1996  JonN    Added exception handling macros
//
//____________________________________________________________________________

#ifndef _MACROS_H_
#define _MACROS_H_


//____________________________________________________________________________
//
//  Macro:      ARRAYLEN
//
//  Purpose:    To determine the length of an array.
//____________________________________________________________________________
//

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


//____________________________________________________________________________
//
//  Macros:     BREAK_ON_FAIL(hresult), BREAK_ON_ERROR(lastError)
//
//  Purpose:    To break out of a loop on error.
//____________________________________________________________________________
//

#define BREAK_ON_FAIL(hr)   if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr)  if (lr != ERROR_SUCCESS) { break; } else 1;


//____________________________________________________________________________
//
//  Macros:     DwordAlign(n)
//____________________________________________________________________________
//

#define DwordAlign(n)  (((n) + 3) & ~3)


//____________________________________________________________________________
//
//  Macros:     SAFE_RELEASE
//____________________________________________________________________________
//

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(punk) \
                if (punk != NULL) \
                { \
                    punk##->Release(); \
                    punk = NULL; \
                } \
                else \
                { \
                    TRACE(_T("Release called on NULL interface ptr")); \
                }
#endif // SAFE_RELEASE



//____________________________________________________________________________
//
//  Macro:      DECLARE_IUNKNOWN_METHODS
//
//  Purpose:    This declares the set of IUnknown methods and is for
//              general-purpose use inside classes that inherit from IUnknown
//____________________________________________________________________________
//

#define DECLARE_IUNKNOWN_METHODS                                    \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);    \
    STDMETHOD_(ULONG,AddRef) (void);                                \
    STDMETHOD_(ULONG,Release) (void)

//____________________________________________________________________________
//
//  Macro:      DECLARE_STANDARD_IUNKNOWN
//
//  Purpose:    This is for use in declaring non-aggregatable objects. It
//              declares the IUnknown methods and reference counter, m_ulRefs.
//              m_ulRefs should be initialized to 1 in the constructor of
//              the object
//____________________________________________________________________________
//

#define DECLARE_STANDARD_IUNKNOWN           \
    DECLARE_IUNKNOWN_METHODS;               \
    ULONG m_ulRefs


//____________________________________________________________________________
//
//  Macro:      IMPLEMENT_STANDARD_IUNKNOWN
//
//  Purpose:    Partial implementaion of standard IUnknown.
//
//  Note:       This does NOT implement QueryInterface, which must be
//              implemented by each object
//____________________________________________________________________________
//

#define IMPLEMENT_STANDARD_IUNKNOWN(cls)                        \
    STDMETHODIMP_(ULONG) cls##::AddRef()                        \
        { return InterlockedIncrement((LONG*)&m_ulRefs); }      \
    STDMETHODIMP_(ULONG) cls##::Release()                       \
        { ULONG ulRet = InterlockedDecrement((LONG*)&m_ulRefs); \
          if (0 == ulRet) { delete this; }                      \
          return ulRet; }







//____________________________________________________________________________
//
//  Macro:      DECLARE_SAFE_INTERFACE_PTR_MEMBERS(cls, Interface, m_iptr)
//
//  Purpose:    Make the interface ptr 'm_iptr' of interface type 'Interface'
//              a safe pointer for the given class 'cls', by adding methods and
//              overloading operators to manipulate the pointer m_iptr.
//
//  History:    6/3/1996   RaviR   Created
//
//  Notes:      Adds safe interface pointer member functions to the given
//              class for the given OLE interface. 'm_iptr' is the member
//              variable name of the interface ptr in the given class.
//
//              The Copy function creates a valid additional copy of
//              the captured pointer (following the AddRef/Release protocol)
//              so can be used to hand out copies from a safe pointer declared
//              as a member of some other class.
//
//              The 'Transfer' function transfers the interface pointer, and
//              invalidates its member value (by setting it to NULL).
//
//              To release the existing interface ptr and set it to a new
//              instance use the 'Set' member fuction. This method takes a
//              parameter which specifies whether the new pointer should be
//              AddRef'd, defaulting to TRUE.
//
//              The following methods manipulate the interface pointer with
//              out following the AddRef/Release protocol: Transfer, Attach
//              and Detach.
//____________________________________________________________________________
//

#define DECLARE_SAFE_INTERFACE_PTR_MEMBERS(cls, Interface, m_iptr)  \
                                                                    \
public:                                                             \
    cls##(Interface * iptr=NULL, BOOL fInc=TRUE) : m_iptr(iptr)     \
    {                                                               \
        if (fInc && (m_iptr != NULL))                               \
        {                                                           \
            m_iptr->AddRef();                                       \
        }                                                           \
    }                                                               \
                                                                    \
    ~##cls##()                                                      \
    {                                                               \
        if (m_iptr != NULL)                                         \
        {                                                           \
            m_iptr->Release();                                      \
            m_iptr = NULL;                                          \
        }                                                           \
    }                                                               \
                                                                    \
    inline BOOL IsNull(void)                                        \
    {                                                               \
        return (m_iptr == NULL);                                    \
    }                                                               \
                                                                    \
    void Transfer(Interface **piptr)                                \
    {                                                               \
        *piptr = m_iptr;                                            \
        m_iptr = NULL;                                              \
    }                                                               \
                                                                    \
    void Copy(Interface **piptr)                                    \
    {                                                               \
        *piptr = m_iptr;                                            \
        if (m_iptr != NULL)                                         \
            m_iptr->AddRef();                                       \
    }                                                               \
                                                                    \
    void Set(Interface* iptr, BOOL fInc = TRUE)                     \
    {                                                               \
        if (m_iptr)                                                 \
        {                                                           \
            m_iptr->Release();                                      \
        }                                                           \
        m_iptr = iptr;                                              \
        if (fInc && m_iptr)                                         \
        {                                                           \
            m_iptr->AddRef();                                       \
        }                                                           \
    }                                                               \
                                                                    \
    void SafeRelease(void)                                          \
    {                                                               \
        if (m_iptr)                                                 \
        {                                                           \
            m_iptr->Release();                                      \
            m_iptr = NULL;                                          \
        }                                                           \
    }                                                               \
                                                                    \
    void SimpleRelease(void)                                        \
    {                                                               \
        ASSERT(m_iptr != NULL);                                     \
        m_iptr->Release();                                          \
        m_iptr = NULL;                                              \
    }                                                               \
                                                                    \
    void Attach(Interface* iptr)                                    \
    {                                                               \
        ASSERT(m_iptr == NULL);                                     \
        m_iptr = iptr;                                              \
    }                                                               \
                                                                    \
    void Detach(void)                                               \
    {                                                               \
        m_iptr = NULL;                                              \
    }                                                               \
                                                                    \
    Interface * operator-> () { return m_iptr; }                    \
    Interface& operator * () { return *m_iptr; }                    \
    operator Interface *() { return m_iptr; }                       \
                                                                    \
    Interface ** operator &()                                       \
    {                                                               \
        ASSERT(m_iptr == NULL);                                     \
        return &m_iptr;                                             \
    }                                                               \
                                                                    \
    Interface *Self(void) { return m_iptr; }                        \
                                                                    \
private:                                                            \
    void operator= (const cls &) {;}                                \
    cls(const cls &){;}




//____________________________________________________________________________
//
//  Macro:      EXCEPTION HANDLING MACROS
//
//  Purpose:    Provide standard macros for exception-handling in
//              OLE servers.
//
//  History:    7/23/1996   JonN    Created
//
//  Notes:      Declare USE_HANDLE_MACROS("Component name") in each source
//              file before these are used.
//
//              These macros can only be used in function calls which return
//              type HRESULT.
//
//              Bracket routines which can generate exceptions
//              with STANDARD_TRY and STANDARD_CATCH.
//
//              Where these routines are COM methods requiring MFC
//              support, use MFC_TRY and MFC_CATCH instead.
//____________________________________________________________________________
//


#define USE_HANDLE_MACROS(component)                                        \
    static TCHAR* You_forgot_to_declare_USE_HANDLE_MACROS = _T(component);

#define STANDARD_TRY                                                        \
    try {

#define MFC_TRY                                                             \
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));                           \
    STANDARD_TRY

//
// CODEWORK don't quite have ENDMETHOD_READBLOCK working yet
//
#ifdef DEBUG
#define ENDMETHOD_STRING                                                    \
    "%s: The unexpected error can be identified as \"%s\" context %n\n"
#define ENDMETHOD_READBLOCK                                                 \
    {                                                                       \
        TCHAR szError[MAX_PATH];                                            \
        UINT nHelpContext = 0;                                              \
        if ( e->GetErrorMessage( szError, MAX_PATH, &nHelpContext ) )       \
        {                                                                   \
            TRACE( ENDMETHOD_STRING,                                        \
                You_forgot_to_declare_USE_HANDLE_MACROS,                    \
                szError,                                                    \
                nHelpContext );                                             \
        }                                                                   \
    }
#else
#define ENDMETHOD_READBLOCK
#endif

#define ERRSTRING_MEMORY       "%s: An out-of-memory error occurred\n"
#define ERRSTRING_FILE         "%s: File error 0x%lx occurred on file \"%s\"\n"
#define ERRSTRING_OLE          "%s: OLE error 0x%lx occurred\n"
#define ERRSTRING_UNEXPECTED   "%s: An unexpected error occurred\n"
#define BADPARM_STRING         "%s: Bad string parameter\n"
#define BADPARM_POINTER        "%s: Bad pointer parameter\n"

#define TRACEERR(s) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS )
#define TRACEERR1(s,a) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a )
#define TRACEERR2(s,a,b) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a,b )

// Note that it is important to use "e->Delete();" and not "delete e;"
#define STANDARD_CATCH                                                      \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_OUTOFMEMORY;                                               \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
		HRESULT hr = (HRESULT)e->Process(e);								\
        TRACEERR1( ERRSTRING_OLE, hr );										\
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
		ASSERT( FAILED(hr) );												\
        return hr;															\
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
		HRESULT hr = (HRESULT)e->m_lOsError;								\
        TRACEERR2( ERRSTRING_FILE, hr, e->m_strFileName );					\
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
		ASSERT( FAILED(hr) );												\
        return hr;															\
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_UNEXPECTED;                                                \
    }

#define MFC_CATCH                                                           \
    STANDARD_CATCH

#define TEST_STRING_PARAM(x)                                                \
    if ( (x) != NULL && !AfxIsValidString(x) ) {                            \
        TRACEERR( BADPARM_STRING ); return E_POINTER; }
#define TEST_NONNULL_STRING_PARAM(x)                                        \
    if ( !AfxIsValidString(x) ) {                                           \
        TRACEERR( BADPARM_STRING ); return E_POINTER; }
#define TEST_NONNULL_PTR_PARAM(x)                                           \
    if ( (x) == NULL || IsBadWritePtr((x),sizeof(x)) ) {                    \
        TRACEERR( BADPARM_POINTER ); return E_POINTER; }

#endif // _MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmcutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       MMCUtil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:  WriteToStream
//              ReadFromStream
//              ListView_GetItemData
//
//  History:    12/4/1996   RaviR   Created
//____________________________________________________________________________
//

#ifndef _MMCUTIL_H_
#define _MMCUTIL_H_

#define MMC_CLSCTX_INPROC (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)


inline void WriteToStream(IStream& stream, void const* pv, ULONG cbToWrite)
{
    ULONG bytesWritten;
    HRESULT hr = stream.Write(pv, cbToWrite, &bytesWritten);
    ANT(SUCCEEDED(hr) && bytesWritten == cbToWrite,
                                        COMEX(hr, UnableToWriteToStream));
}


inline void ReadFromStream(IStream& stream, void* pv, ULONG cbToRead)
{
    unsigned long bytesRead;
    HRESULT hr = stream.Read(pv, cbToRead, &bytesRead);
    ANT(SUCCEEDED(hr) && bytesRead == cbToRead, COMEX(hr, UnableToLoad));
}


inline ListView_GetItemData(HWND hwnd, int iItem)
{
    LV_ITEM lvi; 
    ZeroMemory(&lvi, sizeof(lvi));

    if (iItem >= 0)
    {
        lvi.iItem  = iItem;
        lvi.mask = LVIF_PARAM;
        VERIFY(::SendMessage(hwnd, LVM_GETITEM, 0, (LPARAM)&lvi) == TRUE);
    }

    return lvi.lParam;
}




#endif // _MMCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\olemisc.h ===
// OLE helper macros and definitions for container support
#ifndef _OLE_MISC_H
#define _OLE_MISC_H

#define SAFE_RELEASE(pObject) \
	if ((pObject) != NULL) \
	{ \
		(pObject)->Release(); \
		(pObject) = NULL; \
	} \
	else \
	{ \
		TRACE(_T("Releasing of NULL pointer ignored!\n")); \
	} \


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmctempl.h ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __MMCTEMPL_H__
#define __MMCTEMPL_H__

#ifndef __MMCPLEX_H__
	#include <mmcplex_.h>
#endif

#ifdef ASSERT_VALID
#undef ASSERT_VALID
#endif

#define ASSERT_VALID(pOb)  


#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)


#ifndef _INC_NEW
	#include <new.h>
#endif


#ifndef __AFX_H__
struct __POSITION {};
typedef __POSITION *POSITION;
#endif

#define BEFORE_START_POSITION ((POSITION)-1L)


inline				
BOOL IsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite = TRUE )
{
	return TRUE;
}


template<class TYPE>
inline void ConstructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		IsValidAddress(pElements, nCount * sizeof(TYPE)));

	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void DestructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		IsValidAddress(pElements, nCount * sizeof(TYPE)));

	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		IsValidAddress(pDest, nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		IsValidAddress(pSrc, nCount * sizeof(TYPE)));

	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}


template<class TYPE, class ARG_TYPE>
BOOL CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ASSERT(IsValidAddress(pElement1, sizeof(TYPE), FALSE));
	ASSERT(IsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return ((UINT)(void*)(DWORD)key) >> 4;
}



/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}



/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(IsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(IsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(IsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(IsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(IsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(IsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(IsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(IsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(int nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(int nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	int Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	CTypedPtrList(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};


#endif //__MCTEMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\npd.h ===
#ifndef NPD_H
#define NPD_H

#ifndef COMPTR_H
#include <comptrs.h>
#endif

#ifndef COMDBG_H
#include <comdbg.h>
#endif

// {118B559C-6D8C-11d0-B503-00C04FD9080A}
extern const GUID IID_PersistData;

#if _MSC_VER < 1100
class PersistData : public IUnknown, public CComObjectRoot
#else
class __declspec(uuid("118B559C-6D8C-11d0-B503-00C04FD9080A")) PersistData : 
                                      public IUnknown, public CComObjectRoot
#endif
{
public:
    BEGIN_COM_MAP(PersistData)
        COM_INTERFACE_ENTRY(PersistData)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(PersistData)

    HRESULT Initialize(IStorage* pRoot, BOOL bSameAsLoad)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = bSameAsLoad;

        if (bSameAsLoad)
            return Open();
        return Create();
    }

    HRESULT Create(IStorage* pRoot)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = TRUE;

        return Create();
    }

    HRESULT Open(IStorage* pRoot)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = TRUE;

        return Open();
    }

    IStorage* GetRoot()
    {
        return m_spRoot;
    }

    BOOL SameAsLoad()
    {
        return m_bSameAsLoad;
    }

    void SetSameAsLoad(BOOL bSame = TRUE)
    {
        m_bSameAsLoad = bSame;
    }

    void ClearSameAsLoad()
    {
        m_bSameAsLoad = FALSE;
    }
                                     
    IStream* GetTreeStream()
    {
        return m_spTreeStream;
    }

    IStorage* GetNodeStorage()
    {
        return m_spNodeStorage;
    }

protected:
    PersistData() explicit
        : m_bSameAsLoad(TRUE)
    {
    }

    virtual ~PersistData()
    {
    }

private:
    IStorageCIP m_spRoot;
    BOOL m_bSameAsLoad;
    IStreamCIP m_spTreeStream;
    IStorageCIP m_spNodeStorage;

    PersistData(const PersistData&) explicit;
        // No copy.

    PersistData& operator=(const PersistData&);
        // No copy.

    HRESULT Create()
    {
        ASSERT(m_bSameAsLoad || (!m_bSameAsLoad && m_spRoot != NULL));
        if (!m_bSameAsLoad && m_spRoot == NULL)
            return E_INVALIDARG;

        // Create the stream for the tree
		HRESULT hr = CreateDebugStream(m_spRoot, L"tree",
			STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\tree",
															&m_spTreeStream);
        ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
        if (FAILED(hr))
            return hr;

        // Create the storage for the nodes
		hr = CreateDebugStorage(m_spRoot, L"nodes",
			STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\nodes",
															&m_spNodeStorage);
        ASSERT(SUCCEEDED(hr) && m_spNodeStorage != NULL);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }

    HRESULT Open()
    {
        ASSERT(m_bSameAsLoad || (!m_bSameAsLoad && m_spRoot != NULL));
        if (!m_bSameAsLoad && m_spRoot == NULL)
            return E_INVALIDARG;

        // Open the stream for the trees persistent data.
		HRESULT hr = OpenDebugStream(m_spRoot, L"tree",
				STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\tree", &m_spTreeStream);
        ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
        if (FAILED(hr))
            return hr;

		// Open the storage for the nodes
        hr = OpenDebugStorage(m_spRoot, L"nodes",
			            STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\nodes", 
                                                            &m_spNodeStorage);
        ASSERT(SUCCEEDED(hr) && m_spNodeStorage != NULL);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }
}; // class PersistData

DEFINE_CIP(PersistData);

#if 0
class PersistData
	{
	public: PersistData() explicit throw()
		: m_bFailed(false)
		{
		}
	private: PersistData(const PersistData& pd) explicit throw();
		// Copying is currently not allowed.
	public: void Initialize(IStorage& root)
		// Saves the root storage and creates the standard streams and
		// storages.
		{
		ASSERT(&root);
		ASSERT(!static_cast<bool>(m_pRoot));
			// An assertion here would indicate that this function has been
			// previously called.		
		m_pRoot = &root;
		CreateTreeStorage();
		CreateTreeStream();
		CreateStorageForStreams();
		CreateStorageForStorages();
		}
	public: void Open(IStorage& root)
		// Saves the root, and opens the standard streams and storages.
		{
		ASSERT(&root);
		ASSERT(m_pRoot == NULL);
			// An assertion here would indicate that this function has been
			// previously called.		
		m_pRoot = &root;
		OpenTreeStorage();
		OpenTreeStream();
		OpenStorageForStreams();
		OpenStorageForStorages();
		}
	public: bool IsOpen()
		{
		return m_pRoot;
		}
	public: IStorage& GetRootStorage() const
		{
		ANT(m_pRoot, MMCEX(InvalidInstanceData));
		return *m_pRoot;
		}
	public: IStorage& GetTreeStorage() const
		{
		ANT(m_pTreeStorage, MMCEX(InvalidInstanceData));
			// This will assert if this object hasn't been initialized, or
			// opened.
		return *m_pTreeStorage;
		}
	public: IStream& GetTreeStream() const
		{
		ANT(m_pTreeStream, MMCEX(InvalidInstanceData));
			// This will assert if this object hasn't been initialized, or
			// opened.
		return *m_pTreeStream;
		}
	public: IStorage& GetStorageForStreams() const
		{
		ANT(m_pStreams, MMCEX(InvalidInstanceData));
			// This will assert if this object hasn't been initialized, or
			// opened.
		return *m_pStreams;
		}
	public: IStorage& GetStorageForStorages() const
		{
		ANT(m_pStorages, MMCEX(InvalidInstanceData));
			// This will assert if this object hasn't been initialized, or
			// opened.
		return *m_pStorages;
		}
	public: bool Failed()
		// Returns true if any of the persist operations failed without
		// throwing an exception.
		{
		return m_bFailed;
		}
	public: void SetFailed(bool bFailed = true)
		// Sets the failed flag in the event of a failure.
		{
		m_bFailed = bFailed;
		}
	public: void Delete(const wchar_t* name)
		{
		ANT(static_cast<bool>(m_pStorages) && static_cast<bool>(m_pStreams), MMCEX(InvalidInstanceData));
		try {
			Delete(*m_pStorages, name);
			return;
			}
		catch(const MMCX& e)
			{
			}
		Delete(*m_pStreams, name);
		}
	private: IStorageCIP m_pRoot;
		// This is the most parent storage, which immediately contains all
		// of the other required storages.  Most especially the others
		// contained in this class.
	private: IStorageCIP m_pTreeStorage;
		// The storage which contains a stream for each node.  This stream is
		// used by the console to persist the information unique to each
		// particular type of node.
	private: IStorageCIP m_pStreams;
		// This storage contains a stream for each component, which implements
		// IPersistSteam, or IPersistStreamInit.
	private: IStorageCIP m_pStorages;
		// This storage contains a storage for each component, which
		// implements IPersistStorage.
	private: IStreamCIP m_pTreeStream;
		// The stream containing the tree reconstruction data.
	private: bool m_bFailed;
		// Set to true if any of the persistant operations failed without
		// throwing an exception.
	private: static const wchar_t* GetTreeStorageName()
		// Returns the name of the tree's storage.
		{
		return L"treessorage";
		}
	private: static const wchar_t* GetTreeStreamName()
		// Returns the name of the tree's storage.
		{
		return L"treesdream";
		}
	private: static const wchar_t* GetStorageNameForStreams()
		// Returns the name of the Streams storage.
		{
		return L"smreams";
		}
	private: static const wchar_t* GetStorageNameForStorages()
		// Returns the name of the storages storage.
		{
		return L"sborages";
		}
	private: void CreateStorage(const wchar_t* name,  const wchar_t* instanceName, IStorage** ppStorage)
		// First attempt to open the storage.  If one is not found, the
		// storage is then created.
		{
		ASSERT(name && *name && ppStorage);
		try {
			OpenStorage(name, instanceName, ppStorage);
			return;
			}
		catch (const MMCX& e)
			{
			}
		ANT(m_pRoot, MMCEX(InvalidInstanceData));
		const HRESULT hr = CreateDebugStorage(m_pRoot, name,
			STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, instanceName,
																ppStorage);
		ANT(SUCCEEDED(hr), COMEX(hr, UnableToCreateStorage));
		ASSERT(*ppStorage);
		}
	private: void OpenStorage(const wchar_t* name,  const wchar_t* instanceName, IStorage** ppStorage)
		{
		ASSERT(name && *name && ppStorage);
		ANT(m_pRoot, MMCEX(InvalidInstanceData));
		const HRESULT hr = OpenDebugStorage(m_pRoot, name,
				STGM_SHARE_EXCLUSIVE | STGM_READWRITE, instanceName, ppStorage);
		if (FAILED(hr) || !*ppStorage)
			throw COMEX(hr, UnableToOpenStorage);
		}
	private: void CreateStream(const wchar_t* name, const wchar_t* instanceName, IStream** ppStream)
		{
		ASSERT(name && *name && ppStream);
		ANT(m_pRoot, MMCEX(InvalidInstanceData));
		const HRESULT hr = CreateDebugStream(m_pRoot, name,
			STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, instanceName,
																ppStream);
		ANT(SUCCEEDED(hr), COMEX(hr, UnableToCreateStream));	
		ASSERT(*ppStream);
		}
	private: void OpenStream(const wchar_t* name,  const wchar_t* instanceName, IStream** ppStream)
		{
		ASSERT(name && *name && ppStream);
		ANT(m_pRoot, MMCEX(InvalidInstanceData));
		const HRESULT hr = OpenDebugStream(m_pRoot, name,
					STGM_SHARE_EXCLUSIVE | STGM_READWRITE, instanceName, ppStream);
		ANT(SUCCEEDED(hr), COMEX(hr, UnableToOpenStream));	
		ASSERT(*ppStream);
		}
	private: void CreateTreeStorage()
		// Creates the storage for the primary tree data.  This function
		// will assert if called more than once.
		{
		ASSERT(m_pTreeStorage == NULL);
		CreateStorage(GetTreeStorageName(), L"PrimaryTree", &m_pTreeStorage);
		}
	private: void CreateTreeStream()
		{
		ASSERT(m_pTreeStream == NULL);
		CreateStream(GetTreeStreamName(), L"PrimaryTree", &m_pTreeStream);
		}
	private: void CreateStorageForStreams()
		// Creates the storage for the primary tree data.  This function
		// will assert if called more than once.
		{
		ASSERT(m_pStreams == NULL);
		CreateStorage(GetStorageNameForStreams(), L"Nodes", &m_pStreams);
		}
	private: void CreateStorageForStorages()
		// Creates the storage for the primary tree data.  This function
		// will assert if called more than once.
		{
		ASSERT(m_pStorages == NULL);
		CreateStorage(GetStorageNameForStorages(), L"Nodes", &m_pStorages);
		}
	private: void OpenTreeStorage()
		// Opens the storage for the primary tree data.  This function
		// will assert if called more than once.
		{
		ASSERT(m_pTreeStorage == NULL);
		OpenStorage(GetTreeStorageName(), L"PrimaryTree", &m_pTreeStorage);
		}
	private: void OpenTreeStream()
		// Opens the stream containing the primary tree data.  This function
		// asserts if called more than once.
		{
		ASSERT(m_pTreeStream == NULL);
		OpenStream(GetTreeStreamName(), L"PrimaryTree", &m_pTreeStream);
		}
	private: void OpenStorageForStreams()
		// Creates the storage for the primary tree data.  This function
		// will assert if called more than once.
		{
		ASSERT(m_pStreams == NULL);
		OpenStorage(GetStorageNameForStreams(), L"Nodes", &m_pStreams);
		}
	private: void OpenStorageForStorages()
		// Creates the storage for the primary tree data.  This function
		// will assert if called more than once.
		{
		ASSERT(m_pStorages == NULL);
		OpenStorage(GetStorageNameForStorages(), L"Nodes", &m_pStorages);
		}
	private: void Delete(IStorage& storage, const wchar_t* name)
		// Deletes the element with the specified name from the provided
		// storage.
		{
		ASSERT(name && *name);
        const HRESULT hr = storage.DestroyElement(name);
		if (FAILED(hr))
			throw COMEX(hr, UnableToDestroyElement);
		}
	}; // PersistData
#endif // 0
#endif // NPD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\regkey.cpp ===
#include <afxdisp.h>        // AfxThrowOleException

#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"

#include "regkey.h"
#include "util.h"
#include "macros.h"

USE_HANDLE_MACROS("GUIDHELP(regkey.cpp)")

using namespace AMC;

DECLARE_INFOLEVEL(AMCCore);
DECLARE_HEAPCHECKING;



//____________________________________________________________________________
//
//  Member:     CRegKey::CreateKeyEx
//
//  Synopsis:   Same meaning as for RegCreateKeyEx API.
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//              [pdwDisposition] -- OUT
//              [dwOption] -- IN
//              [pSecurityAttributes] -- OUT
//
//  Returns:    void
//
//  History:    5/24/1996   RaviR   Created
//____________________________________________________________________________
//

void
CRegKey::CreateKeyEx(
    HKEY                    hKeyAncestor,
    LPCTSTR                 lpszKeyName,
    REGSAM                  security,
    DWORD                 * pdwDisposition,
    DWORD                   dwOption,
    LPSECURITY_ATTRIBUTES   pSecurityAttributes)
{
    ASSERT(lpszKeyName != NULL);
    ASSERT(m_hKey == 0);         // already called CreateEx on this object

    DWORD dwDisposition;

    m_lastError = ::RegCreateKeyEx(hKeyAncestor, lpszKeyName, 0, _T(""),
                                   dwOption, security, pSecurityAttributes,
                                   &m_hKey, &dwDisposition);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld creating key \"%s\" under ancestor 0x%x\n",
            m_lastError, lpszKeyName, hKeyAncestor );
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    if (pdwDisposition != NULL)
    {
        *pdwDisposition = dwDisposition;
    }
}

//____________________________________________________________________________
//
//  Member:     CRegKey::OpenKeyEx
//
//  Synopsis:   Same meaning as RegOpenKeyEx
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//
//  Returns:    BOOL (FALSE if key not found, TRUE otherwise.)
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
CRegKey::OpenKeyEx(
    HKEY        hKeyAncestor,
    LPCTSTR     lpszKeyName,
    REGSAM      security)
{
    ASSERT(m_hKey == 0);

    m_lastError = ::RegOpenKeyEx(hKeyAncestor, lpszKeyName,
                                 0, security, &m_hKey);

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_FILE_NOT_FOUND)
    {
        TRACE("CRegKey error %ld opening key \"%s\" under ancestor 0x%x\n",
            m_lastError, lpszKeyName, hKeyAncestor );
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}



//____________________________________________________________________________
//
//  Member:     CRegKey::GetKeySecurity
//
//  Synopsis:   Same meaning as for RegGetKeySecurity API.
//
//  Arguments:  [SecInf] -- IN descriptor contents
//              [pSecDesc] -- OUT address of descriptor for key
//              [lpcbSecDesc] -- IN/OUT address of size of buffer for descriptor
//
//  Returns:    HRESULT.
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

BOOL
CRegKey::GetKeySecurity(
    SECURITY_INFORMATION  SecInf,
    PSECURITY_DESCRIPTOR  pSecDesc,
    LPDWORD               lpcbSecDesc)
{
    ASSERT(pSecDesc != NULL);
    ASSERT(lpcbSecDesc != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegGetKeySecurity(m_hKey, SecInf, pSecDesc, lpcbSecDesc);

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_INSUFFICIENT_BUFFER)
    {
        TRACE("CRegKey error %ld reading security of key 0x%x\n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}

//____________________________________________________________________________
//
//  Member:     CRegKey::CloseKey
//
//  Synopsis:   Same meaning as for RegCloseKey API.
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::CloseKey()
{
    ASSERT(m_hKey != 0);

    m_lastError = ::RegCloseKey(m_hKey);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld closing key 0x%x\n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
    else
    {
        // reset the object
        m_hKey = 0;
        m_lastError = ERROR_SUCCESS;
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::DeleteKey
//
//  Synopsis:   Delete all the keys and subkeys
//
//  Arguments:  [lpszKeyName] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

void
CRegKey::DeleteKey(
    LPCTSTR lpszKeyName)
{
    ASSERT(m_hKey != NULL);
    ASSERT(lpszKeyName != NULL);

    m_lastError = NTRegDeleteKey(m_hKey , lpszKeyName);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld recursively deleting key \"%s\" under key 0x%x\n",
            m_lastError, lpszKeyName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}

//____________________________________________________________________________
//
//  Member:     CRegKey::SetValueEx
//
//  Synopsis:   Same meaning as for RegSetValueEx API.
//
//  Arguments:  [lpszValueName] -- IN
//              [dwType] -- IN
//              [pData] -- OUT
//              [nLen] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::SetValueEx(
    LPCTSTR     lpszValueName,
    DWORD       dwType,
    const void *pData,
    DWORD       nLen)
{
    ASSERT(lpszValueName != NULL);
    ASSERT(pData != NULL);
    ASSERT(m_hKey != NULL);

#if DBG==1
    switch (dwType)
    {
    case REG_BINARY:
    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
    case REG_EXPAND_SZ:
    case REG_LINK:
    case REG_MULTI_SZ:
    case REG_NONE:
    case REG_RESOURCE_LIST:
    case REG_SZ:
        break;

    default:
        ASSERT(FALSE);  // unknown type
    }
#endif

    m_lastError = ::RegSetValueEx(m_hKey, lpszValueName, 0, dwType,
                                        (CONST BYTE *)pData, nLen);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld setting value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     IsValuePresent
//
//  Arguments:  [lpszValueName] -- IN
//
//  Returns:    BOOL.
//
//  History:    3/21/1997   RaviR   Created
//____________________________________________________________________________
//

BOOL CRegKey::IsValuePresent(LPCTSTR lpszValueName)
{
    DWORD cbData;
    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, NULL, 
                                    NULL, &cbData);

    return (m_lastError == ERROR_SUCCESS);
}

//____________________________________________________________________________
//
//  Member:     CRegKey::QueryValueEx
//
//  Synopsis:   Same meaning as for RegQueryValueEx API.
//
//  Arguments:  [lpszValueName] -- IN
//              [pType] -- IN
//              [pData] -- IN
//              [pLen] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryValueEx(
    LPCTSTR lpszValueName,
    LPDWORD pType,
    PVOID   pData,
    LPDWORD pLen)
{
    ASSERT(pLen != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, pType,
                                                  (LPBYTE)pData, pLen);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %d querying data value \"%ws\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}

//____________________________________________________________________________
//
//  Member:     CRegKey::QueryDword
//
//  Synopsis:   Query's for DWORD type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [pdwData] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryDword(
    LPCTSTR lpszValueName,
    LPDWORD pdwData)
{
    ASSERT(m_hKey);

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, &dwType,
                                                  (LPBYTE)pdwData, &dwSize);

    if (m_lastError != ERROR_FILE_NOT_FOUND && dwType != REG_DWORD)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
    }

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld querying dword value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::QueryGUID
//
//  Synopsis:   Query's for GUID type data, stored as REG_SZ.
//
//  Arguments:  [lpszValueName] -- IN
//              [pguid] -- OUT
//
//  Returns:    void
//
//  History:    8/27/1996   JonN    Created
//
//____________________________________________________________________________

void
CRegKey::QueryGUID(
    LPCTSTR lpszValueName,
    GUID* pguid)
{
    ASSERT(m_hKey);
    ASSERT( NULL != pguid );

    CStr str;
    QueryString( lpszValueName, str );

     // CODEWORK m_lastError should not be HRESULT
    m_lastError = GUIDFromCStr( str, pguid );

    if (FAILED(m_lastError))
    {
        TRACE("CRegKey error %ld querying guid value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        ////AfxThrowOleException( m_lastError );
    }
}


void
CRegKey::SetGUID(
    LPCTSTR lpszValueName,
    const GUID& guid)
{
    ASSERT(m_hKey);

    CStr str;

     // CODEWORK m_lastError should not be HRESULT
    m_lastError = GUIDToCStr( str, guid );

    if (FAILED(m_lastError))
    {
        TRACE("CRegKey error %ld setting guid value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        ////AfxThrowOleException( m_lastError );
    }

    SetString( lpszValueName, str );
}


//____________________________________________________________________________
//
//  Member:     CRegKey::QueryString
//
//  Synopsis:   Query's for string type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [pBuffer] -- OUT
//              [pdwBufferByteLen] -- IN/OUT
//              [pdwType] -- OUT
//
//  Returns:    BOOL, returns FALSE if the buffer provided is insufficient.
//
//  History:    5/24/1996   RaviR   Created
//
//____________________________________________________________________________


BOOL
CRegKey::QueryString(
    LPCTSTR     lpszValueName,
    LPTSTR      pBuffer,
    DWORD     * pdwBufferByteLen,
    DWORD     * pdwType)
{
    ASSERT(pBuffer != NULL);
    ASSERT(pdwBufferByteLen != NULL);
    ASSERT(m_hKey != NULL);

    DWORD dwType = REG_NONE; // JonN 11/21/00 PREFIX 179991

    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, &dwType,
                                    (LPBYTE)pBuffer, pdwBufferByteLen);
    if (pdwType != NULL)
    {
        *pdwType = dwType;
    }

    if (m_lastError != ERROR_FILE_NOT_FOUND &&
        dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
    }

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_MORE_DATA)
    {
        TRACE("CRegKey error %ld querying bufferstring value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}

//____________________________________________________________________________
//
//  Member:     CRegKey::QueryString
//
//  Synopsis:   Query's for string type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [ppStrValue] -- OUT
//              [pdwType] -- OUT
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryString(
    LPCTSTR     lpszValueName,
    LPTSTR    * ppStrValue,
    DWORD     * pdwType)
{
    DWORD dwType = REG_SZ;
    DWORD dwLen = 0;

    // Determine how big the data is
    this->QueryValueEx(lpszValueName, &dwType, NULL, &dwLen);

    if (pdwType != NULL)
    {
        *pdwType = dwType;
    }

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
        TRACE("CRegKey error %ld querying allocstring value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    DWORD charLen = dwLen/sizeof(TCHAR);
    LPTSTR pBuffer = new TCHAR[charLen + 1];

    if (dwLen != 0)
    {
#if DBG==1
        try
        {
            this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);
        }
        catch ( HRESULT result )
        {
            CHECK_HRESULT( result );
        }

#else   // ! DBG==1

        this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);

#endif  // ! DBG==1
    }

    pBuffer[charLen] = TEXT('\0');

    *ppStrValue = pBuffer;
}


//____________________________________________________________________________
//
//  Member:     CRegKey::QueryString
//
//  Synopsis:   Query's for string type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [str] -- OUT
//              [pdwType] -- OUT
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryString(
    LPCTSTR     lpszValueName,
    CStr&    str,
    DWORD     * pdwType)
{
    DWORD dwType = REG_SZ;
    DWORD dwLen=0;

    // Determine how big the data is
    this->QueryValueEx(lpszValueName, &dwType, NULL, &dwLen);

    if (pdwType != NULL)
    {
        *pdwType = dwType;
    }

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
        TRACE("CRegKey error %ld querying CString value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    DWORD charLen = dwLen/sizeof(TCHAR);
    LPTSTR pBuffer = str.GetBuffer(charLen + 1);

    if (dwLen != 0)
    {
#if DBG==1
        try
        {
            this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);
        }
        catch ( HRESULT result )
        {
            CHECK_HRESULT( result );
        }
#else   // ! DBG==1

        this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);

#endif  // ! DBG==1
    }

    pBuffer[charLen] = TEXT('\0');

    str.ReleaseBuffer();
}



//____________________________________________________________________________
//
//  Member:     CRegKey::EnumKeyEx
//
//  Synopsis:   Same meaning as for RegEnumKeyEx API.
//
//  Arguments:  [iSubkey] -- IN
//              [lpszName] -- OUT place to store the name
//              [dwLen] -- IN
//              [lpszLastModified] -- IN
//
//  Returns:    BOOL. Returns FALSE if no more items found.
//
//  History:    5/22/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
CRegKey::EnumKeyEx(
    DWORD       iSubkey,
    LPTSTR      lpszName,
    LPDWORD     lpcchName,
    PFILETIME   lpszLastModified)
{
    ASSERT(lpszName != NULL);
    ASSERT(lpcchName != NULL);
    ASSERT(*lpcchName != 0);
    ASSERT(m_hKey != NULL);     // key probably not opened

    m_lastError = ::RegEnumKeyEx(m_hKey, iSubkey, lpszName, lpcchName,
                                 NULL, NULL, NULL, lpszLastModified);

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_NO_MORE_ITEMS)
    {
        TRACE("CRegKey error %ld enumerating child %i of key 0x%x\n",
            m_lastError, iSubkey, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}

//____________________________________________________________________________
//
//  Member:     CRegKey::EnumValue
//
//  Synopsis:   Same meaning as for RegEnumValue API.
//
//  Arguments:  [iValue] -- IN
//              [lpszValue] -- OUT
//              [lpcchValue] -- OUT
//              [lpdwType] -- OUT
//              [lpbData] -- OUT
//              [lpcbData] -- OUT
//
//  Returns:    BOOL. Returns FALSE if no more items found.
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
CRegKey::EnumValue(
    DWORD   iValue,
    LPTSTR  lpszValue,
    LPDWORD lpcchValue,
    LPDWORD lpdwType,
    LPBYTE  lpbData,
    LPDWORD lpcbData)
{
    ASSERT(m_hKey != NULL);
    ASSERT(lpszValue != NULL);
    ASSERT(lpcchValue != NULL);
    ASSERT(lpcbData != NULL || lpbData == NULL);

    m_lastError = ::RegEnumValue(m_hKey, iValue, lpszValue, lpcchValue,
                                       NULL, lpdwType, lpbData, lpcbData);
    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_NO_MORE_ITEMS)
    {
        TRACE("CRegKey error %ld enumerating value %i of key 0x%x\n",
            m_lastError, iValue, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}


//____________________________________________________________________________
//
//  Member:     CRegKey::SaveKey
//
//  Synopsis:   Same meaning as for RegSaveKey API.
//
//  Arguments:  [lpszFile] -- IN filename to save to.
//              [lpsa] -- IN security structure
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

void
CRegKey::SaveKey(
    LPCTSTR                lpszFile,
    LPSECURITY_ATTRIBUTES  lpsa)
{
    ASSERT(lpszFile != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegSaveKey(m_hKey, lpszFile, lpsa);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld saving key 0x%x to file \"%s\"\n",
            m_lastError, m_hKey, lpszFile);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::RestoreKey
//
//  Synopsis:   Same meaning as for RegRestoreKey API.
//
//  Arguments:  [lpszFile] -- IN filename containing saved tree
//              [fdw] -- IN optional flags
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

void
CRegKey::RestoreKey(
    LPCTSTR     lpszFile,
    DWORD       fdw)
{
    ASSERT(lpszFile != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegRestoreKey(m_hKey, lpszFile, fdw);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld restoring key 0x%x from file \"%s\"\n",
            m_lastError, m_hKey, lpszFile);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::NTRegDeleteKey, static
//
//  Synopsis:   Recursively deletes all the sub keys & finally the
//              given start key itself.
//
//  Arguments:  [hStartKey] -- IN
//              [pKeyName] -- IN
//
//  Returns:    LONG.
//
//  History:    5/22/1996   RaviR   Created
//
//____________________________________________________________________________

LONG
CRegKey::NTRegDeleteKey(
    HKEY        hStartKey,
    LPCTSTR     pKeyName)
{
    ASSERT(pKeyName != NULL);
    ASSERT(*pKeyName != TEXT('\0'));

    DWORD        dwSubKeyLength;
    TCHAR        szSubKey[MAX_PATH+2];
    HKEY         hKey;
    LONG         lr = ERROR_SUCCESS;

    lr = ::RegOpenKeyEx(hStartKey, pKeyName, 0, KEY_ALL_ACCESS, &hKey);

    if (lr != ERROR_SUCCESS)
    {
        return lr;
    }

    while (lr == ERROR_SUCCESS)
    {
        dwSubKeyLength = MAX_PATH;

        lr = ::RegEnumKeyEx(hKey, 0, szSubKey, &dwSubKeyLength,
                            NULL, NULL, NULL, NULL);

        if (lr == ERROR_NO_MORE_ITEMS)
        {
            lr = ::RegCloseKey(hKey);

            if (lr == ERROR_SUCCESS)
            {
                lr = ::RegDeleteKey(hStartKey, pKeyName);
                break;
            }
        }
        else if (lr == ERROR_SUCCESS)
        {
            lr = NTRegDeleteKey(hKey, szSubKey);
        }
        else
        {
            // Dont reset lr here!
            ::RegCloseKey(hKey);
        }
    }

    return lr;
}



////////////////////////////////////////////////////////////////////////////
//
//      CRegKey formerly inline methods
//


CRegKey::CRegKey(HKEY hKey)
    :
    m_hKey(hKey),
    m_lastError(ERROR_SUCCESS)
{
    ;
}


CRegKey::~CRegKey()
{
    if (m_hKey != NULL)
    {
        this->CloseKey();
    }
}


HKEY CRegKey::AttachKey(HKEY hKey)
{
    HKEY hKeyOld = m_hKey;

    m_hKey = hKey;
    m_lastError = ERROR_SUCCESS;

    return hKeyOld;
}


void CRegKey::DeleteValue(LPCTSTR lpszValueName)
{
    ASSERT(m_hKey); // Key probably not opened or failed to open

    m_lastError = ::RegDeleteValue(m_hKey, lpszValueName);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld deleting value \"%s\" from key 0x%x \n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


void CRegKey::FlushKey(void)
{
    ASSERT(m_hKey);

    m_lastError = ::RegFlushKey(m_hKey);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld flushing key 0x%x \n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


void CRegKey::SetString(LPCTSTR lpszValueName, LPCTSTR lpszString)
{
    ASSERT(lpszString);

// NATHAN CHECK
#ifndef UNICODE
//#error This will not work without UNICODE
#endif
    this->SetValueEx(lpszValueName, REG_SZ, lpszString, lstrlen(lpszString)*sizeof(TCHAR));
}


void CRegKey::SetString(LPCTSTR lpszValueName, CStr& str)
{
    this->SetValueEx(lpszValueName, REG_SZ, (LPCTSTR)str, (DWORD) str.GetLength());
}


void CRegKey::SetDword(LPCTSTR lpszValueName, DWORD dwData)
{
    this->SetValueEx(lpszValueName, REG_DWORD, &dwData, sizeof(DWORD));
}


void CRegKey::ConnectRegistry(LPTSTR pszComputerName, HKEY hKey)
{
    ASSERT(pszComputerName != NULL);
    ASSERT(hKey == HKEY_LOCAL_MACHINE || hKey == HKEY_USERS);
    ASSERT(m_hKey == NULL);

    m_lastError = ::RegConnectRegistry(pszComputerName, hKey, &m_hKey);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld connecting to key 0x%x on remote machine \"%s\"\n",
            m_lastError, m_hKey, pszComputerName);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


void CRegKey::SetKeySecurity(SECURITY_INFORMATION SecInf,
                             PSECURITY_DESCRIPTOR pSecDesc)
{
    ASSERT(pSecDesc != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegSetKeySecurity(m_hKey, SecInf, pSecDesc);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld setting security on key 0x%x \n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\regkey.h ===
#ifndef __REGKEY__H__
#define __REGKEY__H__
#include "cstr.h"

#define PACKAGE_NOT_FOUND HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

namespace AMC
{

//____________________________________________________________________________
//
//  Class:      CRegKey
//
//  Purpose:    A wrapper around the RegXXX APIs. Most of the RegXXX APIs
//              have been wrapped in this class.
//
//              The RegXXX APIs NOT wrapped in this class are:
//                      RegLoadKey()
//                      RegNotifyChangeKeyValue()
//                      RegReplaceKey()
//                      RegUnLoadKey()
//
//  History:    5/22/1996   RaviR   Created
//
//  Notes:      This class uses C++ exception handling mechanism to throw
//              most of the errors returned by the RegXXX APIs.  It can throw
//              CMemoryException
//              COleException
//
//  Method          RegXXX API          Comment
//  -----------     ----------------    -------------------------
//
//  CreateKeyEx     RegCreateKeyEx      By default creates a non
//                                      volatile key, with all access
//
//  OpenKeyEx       RegOpenKeyEx        By default opens key with all access.
//                                      Returns FALSE if specified key not
//                                      present.
//
//  ConnectRegistry RegConnectRegistry  By default connects to the given
//                                      computer's HKEY_LOCAL_MACHINE.
//
//  CloseKey        RegCloseKey         -
//
//  DeleteKey           -               Delete all the keys and subkeys,
//                                      using RegDeleteKey.
//
//  SetValueEx      RegSetValueEx       Sets any type of data.
//  SetString           -               Sets string type data.
//  SetDword            -               Sets DWORD type data.
//
//  QueryValueEx    RegQueryValueEx     Query's for any type of data.
//  QueryString         -               Query's for string type data.
//  QueryDword          -               Query's for DWORD type data.
//
//  EnumKeyEx       RegEnumKeyEx        Returns FALSE if no more items present.
//
//  EnumValue       RegEnumValue        Returns FALSE if no more items present.
//
//  GetKeySecurity  RegGetKeySecurity   Returns FALSE on insufficent buffer.
//
//  SetKeySecurity  RegSetKeySecurity   -
//
//  SaveKey         RegSaveKey          -
//
//  RestoreKey      RegRestoreKey       -
//
//____________________________________________________________________________
//

class CRegKey
{
public:
// Constructor & Destructor
    CRegKey(HKEY hKey = NULL);
    ~CRegKey(void);

    BOOL IsNull() { return (m_hKey == NULL); }

// Attributes
    operator    HKEY() { ASSERT(m_hKey); return m_hKey; }
    LONG        GetLastError() { return m_lastError; }

// Operations
    // Attach/Detach
    HKEY AttachKey(HKEY hKey);
    HKEY DetachKey(void) { return AttachKey(NULL); }

    // Open & Create Operations
    void CreateKeyEx(
            HKEY                    hKeyAncestor,
            LPCTSTR                 lpszKeyName,
            REGSAM                  security = KEY_ALL_ACCESS,
            DWORD                 * pdwDisposition = NULL,
            DWORD                   dwOption = REG_OPTION_NON_VOLATILE,
            LPSECURITY_ATTRIBUTES   pSecurityAttributes = NULL);

    BOOL OpenKeyEx(
            HKEY        hKey,
            LPCTSTR     lpszKeyName = NULL,
            REGSAM      security = KEY_ALL_ACCESS);

    // Connect to another machine
    void ConnectRegistry(LPTSTR pszComputerName,
                         HKEY hKey = HKEY_LOCAL_MACHINE);

    // Close & Delete Operations
    void CloseKey(void);

    void DeleteKey(LPCTSTR lpszKeyName);
    void DeleteValue(LPCTSTR lpszValueName);

    // Flush operation
    void FlushKey();

    // Main Access Operations
    void SetValueEx(LPCTSTR lpszValueName, DWORD dwType,
                    const void * pData, DWORD nLen);
    void QueryValueEx(LPCTSTR lpszValueName, LPDWORD pType,
                      PVOID pData, LPDWORD pLen);
    BOOL IsValuePresent(LPCTSTR lpszValueName);

    // Additional string access Operations
    void SetString(LPCTSTR lpszValueName, LPCTSTR lpszString);
    void SetString(LPCTSTR lpszValueName, CStr& str);

    BOOL QueryString(LPCTSTR lpszValueName, LPTSTR pBuffer,
                     DWORD *pdwBufferByteLen, DWORD *pdwType = NULL);
    void QueryString(LPCTSTR lpszValueName, LPTSTR * ppStrValue,
                                        DWORD * pdwType = NULL);
    void QueryString(LPCTSTR lpszValueName, CStr& str,
                                        DWORD * pdwType = NULL);

    // Additional DWORD access Operations
    void SetDword(LPCTSTR lpszValueName, DWORD dwData);
    void QueryDword(LPCTSTR lpszValueName, LPDWORD pdwData);

    // Additional GUID access Operations
    void SetGUID(LPCTSTR lpszValueName, const GUID& guid);
    void QueryGUID(LPCTSTR lpszValueName, GUID* pguid);

    // Iteration Operations
    BOOL EnumKeyEx(DWORD iSubkey, LPTSTR lpszName, LPDWORD lpcchName,
                                        PFILETIME lpszLastModified = NULL);

    BOOL EnumValue(DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue,
                   LPDWORD lpdwType = NULL, LPBYTE lpbData = NULL,
                   LPDWORD lpcbData = NULL);

    // Key Security access
    BOOL GetKeySecurity(SECURITY_INFORMATION SecInf,
                        PSECURITY_DESCRIPTOR pSecDesc, LPDWORD lpcbSecDesc);
    void SetKeySecurity(SECURITY_INFORMATION SecInf,
                        PSECURITY_DESCRIPTOR pSecDesc);

    // Save/Restore to/from a file
    void SaveKey(LPCTSTR lpszFile, LPSECURITY_ATTRIBUTES lpsa = NULL);
    void RestoreKey(LPCTSTR lpszFile, DWORD fdw = 0);


protected:

    // Data
    HKEY    m_hKey;
    LONG    m_lastError;    // error code from last function call

    // implementation helpers
    static LONG  NTRegDeleteKey(HKEY hStartKey, LPCTSTR pKeyName);

}; // class CRegKey

} // AMC namespace

#endif // __REGKEY__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\mmcx.h ===
#ifndef MMCX_H
#define MMCX_H
#include <bool.h>

// This avoids "warning C4290: C++ Exception Specification ignored"
// JonN 12/16/96
#pragma warning(4:4290)

class MMCX
	{
	public: enum Code
		{
		InvalidInstanceData,
		InvalidParameter,
		InvalidPointer,
		InvalidVersion,
		UnableToCreateStorage,
		UnableToCreateStream,
		UnableToDestroyElement,
		UnableToSave,
		UnableToLoad,
		UnableToLoadSomePortionOfTheTree,
		UnableToOpenStorage,
		UnableToOpenStream,
		UnableToWriteToStream,
		Unknown,
		};

	public: MMCX() throw()
		: m_Code(Unknown)
			#ifdef _DEBUG
			, m_File(_T(__FILE__)), m_Line(__LINE__)
			#endif
		{
		Trace();
		}

	public: MMCX(Code c, const TCHAR* file, int line) throw()
		: m_Code(c)
			#ifdef _DEBUG
			, m_File(file), m_Line(line)
			#endif
		{
		Trace();
		}

	public: MMCX(Code c) throw()
		: m_Code(c)
			#ifdef _DEBUG
			, m_File(_T(__FILE__)), m_Line(__LINE__)
			#endif
		{
		Trace();
		}

	public: MMCX(const MMCX& e) throw()
		: m_Code(e.m_Code)
			#ifdef _DEBUG
			, m_File(e.m_File), m_Line(e.m_Line)
			#endif
		{
		Trace();
		}

	public: ~MMCX() throw()
		{
		}

	public: MMCX& operator=(const MMCX& e) throw()
		{
		m_Code = e.m_Code;
		#ifdef _DEBUG
		m_File = e.m_File;
		m_Line = e.m_Line;
		#endif
		return *this;
		}

	public: bool operator==(Code c) const throw()
		{
		return m_Code == c;
		}

	public: bool operator==(const MMCX& m) const throw()
		{
		return operator==(m.m_Code);
		}

	public: bool operator!=(Code c) const throw()
		{
		return m_Code != c;
		}

	public: bool operator!=(const MMCX& m) const throw()
		{
		return operator!=(m.m_Code);
		}

	public: Code GetCode() const throw()
		// Returns the error code.
		{
		return m_Code;
		}

	public: const _TCHAR* GetDescription() const throw()
		{
		// This may be less efficeint than a lookup table, but is
		// only used in debug builds, and is much more maintainable (the
		// table doesn't have to be kept in exact sync with the code
		// enumerations).
		switch (m_Code)
			{
			case InvalidInstanceData:
				return _T("Invalid instance data");
			case InvalidParameter:
				return _T("Invalid parameters passed to a function");
			case InvalidPointer:
				return _T("Pointer found in invalid state");
			case InvalidVersion:
				return _T("This version of MMC is not compatible with the ")
														_T("file opened");
			case UnableToCreateStorage:
				return _T("Unable to create storage");
			case UnableToCreateStream:
				return _T("Unable to create stream in storage");
			case UnableToDestroyElement:
				return _T("Unable to destroy an element in a docfile");
			case UnableToSave:
				return _T("Unable to save");
			case UnableToLoad:
				return _T("Unable to load from storage");
			case UnableToLoadSomePortionOfTheTree:
				return _T("Unable to load some of the tree");
			case UnableToOpenStorage:
				return _T("Unable to open a storage");
			case UnableToOpenStream:
				return _T("Unable to open a stream");
			case UnableToWriteToStream:
				return _T("Unable to write to stream");
			case Unknown:
				return _T("Unknown");
			}
		return _T("Unknown");
		}

	private: Code m_Code;
	#ifdef _DEBUG
	private: const TCHAR* m_File;
	private: int m_Line;
	#endif

	private: void Trace() const throw()
		{
		#ifdef _DEBUG
		ASSERT(m_File);
		const TCHAR* const description = GetDescription();
		const int maxLength = lstrlen(description) + lstrlen(m_File) + 32;
		TCHAR* const str = reinterpret_cast<TCHAR*>(alloca(maxLength*2));
		wsprintf(str, _T("%s(%d): exception: %s.\n"), m_File, m_Line, description);
		OutputDebugString(str);
		#endif
		}
	}; // class MMCException

template<typename MoreInfoT> class MMCXPlus : public MMCX
	{
	public: MMCXPlus() throw()
		{
		}

	public: MMCXPlus(const MoreInfoT& m, Code c, const TCHAR* file, int line) throw()
		: MMCX(c, file, line), m_MoreInfo(m)
		{
		}

	public: MMCXPlus(const MoreInfoT& m, Code c) throw()
		: MMCX(c), m_MoreInfo(m)
		{
		}

	public: MMCXPlus(const MMCXPlus& e) throw()
		: MMCX(e), m_MoreInfo(e.m_MoreInfo)
		{
		}

	public: ~MMCXPlus() throw()
		{
		}

	public: MMCXPlus& operator=(const MMCXPlus& e) throw()
		{
		MMCX::operator=(e);
		m_MoreInfo = e.m_MoreInfo;
		return *this;
		}

	public: const MoreInfoT& GetMoreInfo() const throw()
		{
		return m_MoreInfo;
		}

	private: MoreInfoT m_MoreInfo;
	}; // class MMCXPlus

typedef MMCXPlus<HRESULT> COMX;

#ifdef _DEBUG
#define XCODE(x) MMCX::Code::x, _T(__FILE__), __LINE__
#else
#define XCODE(x) MMCX::Code::x
#endif

// Assert 'n throw macros
#define ANT(test, exception) \
	if (!static_cast<bool>(test)) { ASSERT(static_cast<bool>(test)); throw exception; }

#define AssertThenThrow(test, exception) ANT(test, exception)

#define ANTIfNot(exception, acceptableException) \
	if (exception != acceptableException) \
		{ ASSERT(exception != acceptableException); throw exception; }

#define AssertThenThrowIfNot(exception, acceptableException) \
	ANTIfNot(exception, acceptableException)

#define MMCEX(x) MMCX(XCODE(x))
#define COMEX(hr, x) COMX(hr, XCODE(x))
#endif // MMCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\ndmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Jul 22 18:22:13 1997
 */
/* Compiler settings for ndmgr.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ndmgr_h__
#define __ndmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IComponentData_FWD_DEFINED__
#define __IComponentData_FWD_DEFINED__
typedef interface IComponentData IComponentData;
#endif 	/* __IComponentData_FWD_DEFINED__ */


#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


#ifndef __IResultDataCompare_FWD_DEFINED__
#define __IResultDataCompare_FWD_DEFINED__
typedef interface IResultDataCompare IResultDataCompare;
#endif 	/* __IResultDataCompare_FWD_DEFINED__ */


#ifndef __IResultOwnerData_FWD_DEFINED__
#define __IResultOwnerData_FWD_DEFINED__
typedef interface IResultOwnerData IResultOwnerData;
#endif 	/* __IResultOwnerData_FWD_DEFINED__ */


#ifndef __IConsole_FWD_DEFINED__
#define __IConsole_FWD_DEFINED__
typedef interface IConsole IConsole;
#endif 	/* __IConsole_FWD_DEFINED__ */


#ifndef __IHeaderCtrl_FWD_DEFINED__
#define __IHeaderCtrl_FWD_DEFINED__
typedef interface IHeaderCtrl IHeaderCtrl;
#endif 	/* __IHeaderCtrl_FWD_DEFINED__ */


#ifndef __IContextMenuCallback_FWD_DEFINED__
#define __IContextMenuCallback_FWD_DEFINED__
typedef interface IContextMenuCallback IContextMenuCallback;
#endif 	/* __IContextMenuCallback_FWD_DEFINED__ */


#ifndef __IContextMenuProvider_FWD_DEFINED__
#define __IContextMenuProvider_FWD_DEFINED__
typedef interface IContextMenuProvider IContextMenuProvider;
#endif 	/* __IContextMenuProvider_FWD_DEFINED__ */


#ifndef __IExtendContextMenu_FWD_DEFINED__
#define __IExtendContextMenu_FWD_DEFINED__
typedef interface IExtendContextMenu IExtendContextMenu;
#endif 	/* __IExtendContextMenu_FWD_DEFINED__ */


#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __IResultData_FWD_DEFINED__
#define __IResultData_FWD_DEFINED__
typedef interface IResultData IResultData;
#endif 	/* __IResultData_FWD_DEFINED__ */


#ifndef __IConsoleNameSpace_FWD_DEFINED__
#define __IConsoleNameSpace_FWD_DEFINED__
typedef interface IConsoleNameSpace IConsoleNameSpace;
#endif 	/* __IConsoleNameSpace_FWD_DEFINED__ */


#ifndef __IPropertySheetCallback_FWD_DEFINED__
#define __IPropertySheetCallback_FWD_DEFINED__
typedef interface IPropertySheetCallback IPropertySheetCallback;
#endif 	/* __IPropertySheetCallback_FWD_DEFINED__ */


#ifndef __IPropertySheetProvider_FWD_DEFINED__
#define __IPropertySheetProvider_FWD_DEFINED__
typedef interface IPropertySheetProvider IPropertySheetProvider;
#endif 	/* __IPropertySheetProvider_FWD_DEFINED__ */


#ifndef __IExtendPropertySheet_FWD_DEFINED__
#define __IExtendPropertySheet_FWD_DEFINED__
typedef interface IExtendPropertySheet IExtendPropertySheet;
#endif 	/* __IExtendPropertySheet_FWD_DEFINED__ */


#ifndef __IControlbar_FWD_DEFINED__
#define __IControlbar_FWD_DEFINED__
typedef interface IControlbar IControlbar;
#endif 	/* __IControlbar_FWD_DEFINED__ */


#ifndef __IExtendControlbar_FWD_DEFINED__
#define __IExtendControlbar_FWD_DEFINED__
typedef interface IExtendControlbar IExtendControlbar;
#endif 	/* __IExtendControlbar_FWD_DEFINED__ */


#ifndef __IToolbar_FWD_DEFINED__
#define __IToolbar_FWD_DEFINED__
typedef interface IToolbar IToolbar;
#endif 	/* __IToolbar_FWD_DEFINED__ */


#ifndef __IConsoleVerb_FWD_DEFINED__
#define __IConsoleVerb_FWD_DEFINED__
typedef interface IConsoleVerb IConsoleVerb;
#endif 	/* __IConsoleVerb_FWD_DEFINED__ */


#ifndef __ISnapinAbout_FWD_DEFINED__
#define __ISnapinAbout_FWD_DEFINED__
typedef interface ISnapinAbout ISnapinAbout;
#endif 	/* __ISnapinAbout_FWD_DEFINED__ */


#ifndef __IMenuButton_FWD_DEFINED__
#define __IMenuButton_FWD_DEFINED__
typedef interface IMenuButton IMenuButton;
#endif 	/* __IMenuButton_FWD_DEFINED__ */


#ifndef __ISnapinHelp_FWD_DEFINED__
#define __ISnapinHelp_FWD_DEFINED__
typedef interface ISnapinHelp ISnapinHelp;
#endif 	/* __ISnapinHelp_FWD_DEFINED__ */


#ifndef __IPropertySheetChange_FWD_DEFINED__
#define __IPropertySheetChange_FWD_DEFINED__
typedef interface IPropertySheetChange IPropertySheetChange;
#endif 	/* __IPropertySheetChange_FWD_DEFINED__ */


#ifndef __IFramePrivate_FWD_DEFINED__
#define __IFramePrivate_FWD_DEFINED__
typedef interface IFramePrivate IFramePrivate;
#endif 	/* __IFramePrivate_FWD_DEFINED__ */


#ifndef __IScopeDataPrivate_FWD_DEFINED__
#define __IScopeDataPrivate_FWD_DEFINED__
typedef interface IScopeDataPrivate IScopeDataPrivate;
#endif 	/* __IScopeDataPrivate_FWD_DEFINED__ */


#ifndef __IImageListPrivate_FWD_DEFINED__
#define __IImageListPrivate_FWD_DEFINED__
typedef interface IImageListPrivate IImageListPrivate;
#endif 	/* __IImageListPrivate_FWD_DEFINED__ */


#ifndef __IResultDataPrivate_FWD_DEFINED__
#define __IResultDataPrivate_FWD_DEFINED__
typedef interface IResultDataPrivate IResultDataPrivate;
#endif 	/* __IResultDataPrivate_FWD_DEFINED__ */


#ifndef __IScopeTree_FWD_DEFINED__
#define __IScopeTree_FWD_DEFINED__
typedef interface IScopeTree IScopeTree;
#endif 	/* __IScopeTree_FWD_DEFINED__ */


#ifndef __IScopeTreeIter_FWD_DEFINED__
#define __IScopeTreeIter_FWD_DEFINED__
typedef interface IScopeTreeIter IScopeTreeIter;
#endif 	/* __IScopeTreeIter_FWD_DEFINED__ */


#ifndef __INodeCallback_FWD_DEFINED__
#define __INodeCallback_FWD_DEFINED__
typedef interface INodeCallback INodeCallback;
#endif 	/* __INodeCallback_FWD_DEFINED__ */


#ifndef __IControlbarsCache_FWD_DEFINED__
#define __IControlbarsCache_FWD_DEFINED__
typedef interface IControlbarsCache IControlbarsCache;
#endif 	/* __IControlbarsCache_FWD_DEFINED__ */


#ifndef __INodeType_FWD_DEFINED__
#define __INodeType_FWD_DEFINED__
typedef interface INodeType INodeType;
#endif 	/* __INodeType_FWD_DEFINED__ */


#ifndef __INodeTypesCache_FWD_DEFINED__
#define __INodeTypesCache_FWD_DEFINED__
typedef interface INodeTypesCache INodeTypesCache;
#endif 	/* __INodeTypesCache_FWD_DEFINED__ */


#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumNodeTypes_FWD_DEFINED__
#define __IEnumNodeTypes_FWD_DEFINED__
typedef interface IEnumNodeTypes IEnumNodeTypes;
#endif 	/* __IEnumNodeTypes_FWD_DEFINED__ */


#ifndef __NodeInit_FWD_DEFINED__
#define __NodeInit_FWD_DEFINED__

#ifdef __cplusplus
typedef class NodeInit NodeInit;
#else
typedef struct NodeInit NodeInit;
#endif /* __cplusplus */

#endif 	/* __NodeInit_FWD_DEFINED__ */


#ifndef __ScopeTree_FWD_DEFINED__
#define __ScopeTree_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScopeTree ScopeTree;
#else
typedef struct ScopeTree ScopeTree;
#endif /* __cplusplus */

#endif 	/* __ScopeTree_FWD_DEFINED__ */


#ifndef __IPropertySheetProviderPrivate_FWD_DEFINED__
#define __IPropertySheetProviderPrivate_FWD_DEFINED__
typedef interface IPropertySheetProviderPrivate IPropertySheetProviderPrivate;
#endif 	/* __IPropertySheetProviderPrivate_FWD_DEFINED__ */


#ifndef __IMMCListView_FWD_DEFINED__
#define __IMMCListView_FWD_DEFINED__
typedef interface IMMCListView IMMCListView;
#endif 	/* __IMMCListView_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0000
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 























typedef IConsole __RPC_FAR *LPCONSOLE;

typedef IHeaderCtrl __RPC_FAR *LPHEADERCTRL;

typedef IToolbar __RPC_FAR *LPTOOLBAR;

typedef IImageList __RPC_FAR *LPIMAGELIST;

typedef IResultData __RPC_FAR *LPRESULTDATA;

typedef IConsoleNameSpace __RPC_FAR *LPCONSOLENAMESPACE;

typedef IPropertySheetProvider __RPC_FAR *LPPROPERTYSHEETPROVIDER;

typedef IPropertySheetCallback __RPC_FAR *LPPROPERTYSHEETCALLBACK;

typedef IContextMenuProvider __RPC_FAR *LPCONTEXTMENUPROVIDER;

typedef IContextMenuCallback __RPC_FAR *LPCONTEXTMENUCALLBACK;

typedef IControlbar __RPC_FAR *LPCONTROLBAR;

typedef IConsoleVerb __RPC_FAR *LPCONSOLEVERB;

typedef IMenuButton __RPC_FAR *LPMENUBUTTON;

typedef IComponent __RPC_FAR *LPCOMPONENT;

typedef IComponentData __RPC_FAR *LPCOMPONENTDATA;

typedef IExtendPropertySheet __RPC_FAR *LPEXTENDPROPERTYSHEET;

typedef IExtendContextMenu __RPC_FAR *LPEXTENDCONTEXTMENU;

typedef IExtendControlbar __RPC_FAR *LPEXTENDCONTROLBAR;

typedef IResultDataCompare __RPC_FAR *LPRESULTDATACOMPARE;

typedef ISnapinAbout __RPC_FAR *LPSNAPABOUT;

typedef IResultOwnerData __RPC_FAR *LPRESULTOWNERDATA;

#define	MMCLV_AUTO	( -1 )

#define	MMCLV_NOPARAM	( -2 )

#define	MMCLV_NOICON	( -1 )

#define	MMCLV_VIEWSTYLE_ICON	( 0 )

#define	MMCLV_VIEWSTYLE_SMALLICON	( 0x2 )

#define	MMCLV_VIEWSTYLE_LIST	( 0x3 )

#define	MMCLV_VIEWSTYLE_REPORT	( 0x1 )

#define	MMCLV_NOPTR	( 0 )

#define	MMCLV_UPDATE_NOINVALIDATEALL	( 0x1 )

#define	MMCLV_UPDATE_NOSCROLL	( 0x2 )

static unsigned short __RPC_FAR *MMC_CALLBACK	=	( unsigned short __RPC_FAR * )-1;

typedef long HSCOPEITEM;

typedef long COMPONENTID;

typedef long HRESULTITEM;

#define	RDI_STR	( 0x2 )

#define	RDI_IMAGE	( 0x4 )

#define	RDI_STATE	( 0x8 )

#define	RDI_PARAM	( 0x10 )

#define	RDI_INDEX	( 0x20 )

#define	RDI_INDENT	( 0x40 )

typedef 
enum _MMC_RESULT_VIEW_STYLE
    {	MMC_SINGLESEL	= 0x1,
	MMC_SHOWSELALWAYS	= 0x2,
	MMC_NOSORTHEADER	= 0x4
    }	MMC_RESULT_VIEW_STYLE;

#define	MMC_VIEW_OPTIONS_NONE	( 0 )

#define	MMC_VIEW_OPTIONS_NOLISTVIEWS	( 0x1 )

#define	MMC_VIEW_OPTIONS_MULTISELECT	( 0x2 )

#define	MMC_VIEW_OPTIONS_OWNERDATALIST	( 0x4 )

typedef 
enum _MMC_CONTROL_TYPE
    {	TOOLBAR	= 0,
	MENUBUTTON	= TOOLBAR + 1,
	COMBOBOXBAR	= MENUBUTTON + 1
    }	MMC_CONTROL_TYPE;

typedef 
enum _MMC_CONSOLE_VERB
    {	MMC_VERB_CUT	= 0x8000,
	MMC_VERB_COPY	= 0x8001,
	MMC_VERB_PASTE	= 0x8002,
	MMC_VERB_DELETE	= 0x8003,
	MMC_VERB_PROPERTIES	= 0x8004,
	MMC_VERB_RENAME	= 0x8005,
	MMC_VERB_REFRESH	= 0x8006,
	MMC_VERB_PRINT	= 0x8007
    }	MMC_CONSOLE_VERB;

typedef struct  _MMCButton
    {
    int nBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsType;
    LPOLESTR lpButtonText;
    LPOLESTR lpTooltipText;
    }	MMCBUTTON;

typedef MMCBUTTON __RPC_FAR *LPMMCBUTTON;

typedef 
enum _MMC_BUTTON_STATE
    {	ENABLED	= 0,
	CHECKED	= ENABLED + 1,
	HIDDEN	= CHECKED + 1,
	INDETERMINATE	= HIDDEN + 1,
	BUTTONPRESSED	= INDETERMINATE + 1
    }	MMC_BUTTON_STATE;

typedef struct  _RESULTDATAITEM
    {
    DWORD mask;
    BOOL bScopeItem;
    HRESULTITEM itemID;
    int nIndex;
    int nCol;
    LPOLESTR str;
    int nImage;
    UINT nState;
    LPARAM lParam;
    int iIndent;
    }	RESULTDATAITEM;

typedef RESULTDATAITEM __RPC_FAR *LPRESULTDATAITEM;

#define	RFI_PARTIAL	( 0x1 )

#define	RFI_WRAP	( 0x2 )

typedef struct  _RESULTFINDINFO
    {
    LPOLESTR psz;
    int nStart;
    DWORD dwOptions;
    }	RESULTFINDINFO;

typedef RESULTFINDINFO __RPC_FAR *LPRESULTFINDINFO;

#define	RSI_DESCENDING	( 0x1 )

#define	SDI_STR	( 0x2 )

#define	SDI_IMAGE	( 0x4 )

#define	SDI_OPENIMAGE	( 0x8 )

#define	SDI_STATE	( 0x10 )

#define	SDI_PARAM	( 0x20 )

#define	SDI_CHILDREN	( 0x40 )

#define	SDI_PARENT	( 0 )

#define	SDI_PREVIOUS	( 0x10000000 )

#define	SDI_NEXT	( 0x20000000 )

#define	SDI_FIRST	( 0x8000000 )

#define	SDI_ROOT	( ( COMPONENTID  )0xffff0000 )

typedef struct  _SCOPEDATAITEM
    {
    DWORD mask;
    LPOLESTR displayname;
    int nImage;
    int nOpenImage;
    UINT nState;
    int cChildren;
    LPARAM lParam;
    HSCOPEITEM relativeID;
    HSCOPEITEM ID;
    }	SCOPEDATAITEM;

typedef SCOPEDATAITEM __RPC_FAR *LPSCOPEDATAITEM;

typedef 
enum _MMC_SCOPE_ITEM_STATE
    {	MMC_SCOPE_ITEM_STATE_NORMAL	= 0x1,
	MMC_SCOPE_ITEM_STATE_BOLD	= 0x2,
	MMC_SCOPE_ITEM_STATE_EXPANDEDONCE	= 0x3
    }	MMC_SCOPE_ITEM_STATE;

typedef struct  _CONTEXTMENUITEM
    {
    LPWSTR strName;
    LPWSTR strStatusBarText;
    LONG lCommandID;
    LONG lInsertionPointID;
    LONG fFlags;
    LONG fSpecialFlags;
    }	CONTEXTMENUITEM;

typedef CONTEXTMENUITEM __RPC_FAR *LPCONTEXTMENUITEM;

typedef 
enum _MMC_MENU_COMMAND_IDS
    {	MMCC_STANDARD_VIEW_SELECT	= -1
    }	MMC_MENU_COMMAND_IDS;

typedef struct  _MENUBUTTONDATA
    {
    int idCommand;
    int x;
    int y;
    }	MENUBUTTONDATA;

typedef MENUBUTTONDATA __RPC_FAR *LPMENUBUTTONDATA;

#define	MMC_MULTI_SELECT_COOKIE	( -2 )

typedef 
enum _MMC_NOTIFY_TYPE
    {	MMCN_ACTIVATE	= 0x8001,
	MMCN_ADD_IMAGES	= 0x8002,
	MMCN_BTN_CLICK	= 0x8003,
	MMCN_CLICK	= 0x8004,
	MMCN_DBLCLICK	= 0x8005,
	MMCN_DELETE	= 0x8006,
	MMCN_EXPAND	= 0x8007,
	MMCN_MINIMIZED	= 0x8008,
	MMCN_PROPERTY_CHANGE	= 0x8009,
	MMCN_REMOVE_CHILDREN	= 0x800a,
	MMCN_RENAME	= 0x800b,
	MMCN_SELECT	= 0x800c,
	MMCN_SHOW	= 0x800d,
	MMCN_VIEW_CHANGE	= 0x800e,
	MMCN_CONTEXTMENU	= 0x800f,
	MMCN_MENU_BTNCLICK	= 0x8010,
	MMCN_HELP	= 0x8011,
	MMCN_MULTI_SELECT	= 0x8012,
	MMCN_REFRESH	= 0x8013,
	MMCN_DESELECT_ALL	= 0x8014
    }	MMC_NOTIFY_TYPE;

typedef 
enum _DATA_OBJECT_TYPES
    {	CCT_SCOPE	= 0x8000,
	CCT_RESULT	= 0x8001,
	CCT_SNAPIN_MANAGER	= 0x8002,
	CCT_UNINITIALIZED	= 0xffff
    }	DATA_OBJECT_TYPES;

#define	CCF_NODETYPE	( L"CCF_NODETYPE" )

#define	CCF_SZNODETYPE	( L"CCF_SZNODETYPE" )

#define	CCF_DISPLAY_NAME	( L"CCF_DISPLAY_NAME" )

#define	CCF_SNAPIN_CLASSID	( L"CCF_SNAPIN_CLASSID" )

#define	CCF_MULTI_SELECT_SNAPINS	( L"CCF_MULTI_SELECT_SNAPINS" )

#define	CCF_OBJECT_TYPES_IN_MULTI_SELECT	( L"CCF_OBJECT_TYPES_IN_MULTI_SELECT" )

STDAPI MMCPropertyChangeNotify(long lNotifyHandle, long param);
STDAPI MMCFreeNotifyHandle(long lNotifyHandle);
STDAPI MMCPropPageCallback(void* vpsp);


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0000_v0_0_s_ifspec;

#ifndef __IComponentData_INTERFACE_DEFINED__
#define __IComponentData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponentData
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponentData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("955AB28A-5218-11D0-A985-00C04FD8D565")
    IComponentData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateComponent )( 
            IComponentData __RPC_FAR * This,
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponentData __RPC_FAR * This,
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentDataVtbl;

    interface IComponentData
    {
        CONST_VTBL struct IComponentDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentData_Initialize(This,pUnknown)	\
    (This)->lpVtbl -> Initialize(This,pUnknown)

#define IComponentData_CreateComponent(This,ppComponent)	\
    (This)->lpVtbl -> CreateComponent(This,ppComponent)

#define IComponentData_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponentData_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#define IComponentData_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponentData_GetDisplayInfo(This,pScopeDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pScopeDataItem)

#define IComponentData_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IComponentData_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);


void __RPC_STUB IComponentData_CreateComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Notify_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB IComponentData_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Destroy_Proxy( 
    IComponentData __RPC_FAR * This);


void __RPC_STUB IComponentData_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_QueryDataObject_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponentData_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);


void __RPC_STUB IComponentData_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponentData_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentData_INTERFACE_DEFINED__ */


#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB2-D36C-11CF-ADBC-00AA00A80033")
    IComponent : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ long cookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ long cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPCONSOLE lpConsole);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponent __RPC_FAR * This,
            /* [in] */ long cookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponent __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultViewType )( 
            IComponent __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponent __RPC_FAR * This,
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponent_Initialize(This,lpConsole)	\
    (This)->lpVtbl -> Initialize(This,lpConsole)

#define IComponent_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponent_Destroy(This,cookie)	\
    (This)->lpVtbl -> Destroy(This,cookie)

#define IComponent_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponent_GetResultViewType(This,cookie,ppViewType,pViewOptions)	\
    (This)->lpVtbl -> GetResultViewType(This,cookie,ppViewType,pViewOptions)

#define IComponent_GetDisplayInfo(This,pResultDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pResultDataItem)

#define IComponent_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Initialize_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPCONSOLE lpConsole);


void __RPC_STUB IComponent_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Notify_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB IComponent_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Destroy_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ long cookie);


void __RPC_STUB IComponent_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_QueryDataObject_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponent_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetResultViewType_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB IComponent_GetResultViewType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Proxy( 
    IComponent __RPC_FAR * This,
    /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);


void __RPC_STUB IComponent_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponent_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponent_INTERFACE_DEFINED__ */


#ifndef __IResultDataCompare_INTERFACE_DEFINED__
#define __IResultDataCompare_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultDataCompare
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultDataCompare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8315A52-7A1A-11D0-A2D2-00C04FD909DD")
    IResultDataCompare : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ long lUserParam,
            /* [in] */ long cookieA,
            /* [in] */ long cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataCompareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataCompare __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataCompare __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compare )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ long lUserParam,
            /* [in] */ long cookieA,
            /* [in] */ long cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult);
        
        END_INTERFACE
    } IResultDataCompareVtbl;

    interface IResultDataCompare
    {
        CONST_VTBL struct IResultDataCompareVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataCompare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataCompare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataCompare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataCompare_Compare(This,lUserParam,cookieA,cookieB,pnResult)	\
    (This)->lpVtbl -> Compare(This,lUserParam,cookieA,cookieB,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataCompare_Compare_Proxy( 
    IResultDataCompare __RPC_FAR * This,
    /* [in] */ long lUserParam,
    /* [in] */ long cookieA,
    /* [in] */ long cookieB,
    /* [out][in] */ int __RPC_FAR *pnResult);


void __RPC_STUB IResultDataCompare_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataCompare_INTERFACE_DEFINED__ */


#ifndef __IResultOwnerData_INTERFACE_DEFINED__
#define __IResultOwnerData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultOwnerData
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultOwnerData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C")
    IResultOwnerData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultOwnerDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultOwnerData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultOwnerData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItem )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CacheHint )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortItems )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ long lUserParam);
        
        END_INTERFACE
    } IResultOwnerDataVtbl;

    interface IResultOwnerData
    {
        CONST_VTBL struct IResultOwnerDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultOwnerData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultOwnerData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultOwnerData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultOwnerData_FindItem(This,pFindInfo,pnFoundIndex)	\
    (This)->lpVtbl -> FindItem(This,pFindInfo,pnFoundIndex)

#define IResultOwnerData_CacheHint(This,nStartIndex,nEndIndex)	\
    (This)->lpVtbl -> CacheHint(This,nStartIndex,nEndIndex)

#define IResultOwnerData_SortItems(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> SortItems(This,nColumn,dwSortOptions,lUserParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_FindItem_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ LPRESULTFINDINFO pFindInfo,
    /* [out] */ int __RPC_FAR *pnFoundIndex);


void __RPC_STUB IResultOwnerData_FindItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_CacheHint_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nStartIndex,
    /* [in] */ int nEndIndex);


void __RPC_STUB IResultOwnerData_CacheHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_SortItems_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ long lUserParam);


void __RPC_STUB IResultOwnerData_SortItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultOwnerData_INTERFACE_DEFINED__ */


#ifndef __IConsole_INTERFACE_DEFINED__
#define __IConsole_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConsole
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IConsole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB1-D36C-11CF-ADBC-00AA00A80033")
    IConsole : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHeader( 
            /* [in] */ LPHEADERCTRL pHeader) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetToolbar( 
            /* [in] */ LPTOOLBAR pToolbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultView( 
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateAllViews( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ long data,
            /* [in] */ long hint) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MessageBox( 
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryConsoleVerb( 
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectScopeItem( 
            /* [in] */ HSCOPEITEM hScopeItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMainWindow( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsole __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ long data,
            /* [in] */ long hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IConsole __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        END_INTERFACE
    } IConsoleVtbl;

    interface IConsole
    {
        CONST_VTBL struct IConsoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsole_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IConsole_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IConsole_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IConsole_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IConsole_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IConsole_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IConsole_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IConsole_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IConsole_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IConsole_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetHeader_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPHEADERCTRL pHeader);


void __RPC_STUB IConsole_SetHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetToolbar_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPTOOLBAR pToolbar);


void __RPC_STUB IConsole_SetToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultView_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);


void __RPC_STUB IConsole_QueryResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryScopeImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryResultImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_UpdateAllViews_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ long data,
    /* [in] */ long hint);


void __RPC_STUB IConsole_UpdateAllViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_MessageBox_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPCWSTR lpszText,
    /* [in] */ LPCWSTR lpszTitle,
    /* [in] */ UINT fuStyle,
    /* [out] */ int __RPC_FAR *piRetval);


void __RPC_STUB IConsole_MessageBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryConsoleVerb_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);


void __RPC_STUB IConsole_QueryConsoleVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SelectScopeItem_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem);


void __RPC_STUB IConsole_SelectScopeItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_GetMainWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IConsole_GetMainWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsole_INTERFACE_DEFINED__ */


#ifndef __IHeaderCtrl_INTERFACE_DEFINED__
#define __IHeaderCtrl_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHeaderCtrl
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


#define	AUTO_WIDTH	( -1 )


EXTERN_C const IID IID_IHeaderCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB3-D36C-11CF-ADBC-00AA00A80033")
    IHeaderCtrl : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnText( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnText( 
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnWidth( 
            /* [in] */ int nCol,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnWidth( 
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderCtrl __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth);
        
        END_INTERFACE
    } IHeaderCtrlVtbl;

    interface IHeaderCtrl
    {
        CONST_VTBL struct IHeaderCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCtrl_InsertColumn(This,nCol,title,nFormat,nWidth)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,title,nFormat,nWidth)

#define IHeaderCtrl_DeleteColumn(This,nCol)	\
    (This)->lpVtbl -> DeleteColumn(This,nCol)

#define IHeaderCtrl_SetColumnText(This,nCol,title)	\
    (This)->lpVtbl -> SetColumnText(This,nCol,title)

#define IHeaderCtrl_GetColumnText(This,nCol,pText)	\
    (This)->lpVtbl -> GetColumnText(This,nCol,pText)

#define IHeaderCtrl_SetColumnWidth(This,nCol,nWidth)	\
    (This)->lpVtbl -> SetColumnWidth(This,nCol,nWidth)

#define IHeaderCtrl_GetColumnWidth(This,nCol,pWidth)	\
    (This)->lpVtbl -> GetColumnWidth(This,nCol,pWidth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_InsertColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title,
    /* [in] */ int nFormat,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_DeleteColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol);


void __RPC_STUB IHeaderCtrl_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title);


void __RPC_STUB IHeaderCtrl_SetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ LPOLESTR __RPC_FAR *pText);


void __RPC_STUB IHeaderCtrl_GetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_SetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ int __RPC_FAR *pWidth);


void __RPC_STUB IHeaderCtrl_GetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCtrl_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0099
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



enum __MIDL___MIDL_itf_ndmgr_0099_0001
    {	CCM_INSERTIONPOINTID_MASK_SPECIAL	= 0xffff0000,
	CCM_INSERTIONPOINTID_MASK_SHARED	= 0x80000000,
	CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY	= 0x40000000,
	CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY	= 0x20000000,
	CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY	= 0x10000000,
	CCM_INSERTIONPOINTID_MASK_RESERVED	= 0xfff0000,
	CCM_INSERTIONPOINTID_MASK_FLAGINDEX	= 0x1f,
	CCM_INSERTIONPOINTID_PRIMARY_TOP	= 0xa0000000,
	CCM_INSERTIONPOINTID_PRIMARY_NEW	= 0xa0000001,
	CCM_INSERTIONPOINTID_PRIMARY_TASK	= 0xa0000002,
	CCM_INSERTIONPOINTID_PRIMARY_VIEW	= 0xa0000003,
	CCM_INSERTIONPOINTID_3RDPARTY_NEW	= 0x90000001,
	CCM_INSERTIONPOINTID_3RDPARTY_TASK	= 0x90000002,
	CCM_INSERTIONPOINTID_ROOT_MENU	= 0x80000000
    };

enum __MIDL___MIDL_itf_ndmgr_0099_0002
    {	CCM_INSERTIONALLOWED_TOP	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TOP & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_NEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_NEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_TASK	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TASK & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_VIEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_VIEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX)
    };

enum __MIDL___MIDL_itf_ndmgr_0099_0003
    {	CCM_COMMANDID_MASK_RESERVED	= 0xffff0000
    };

enum __MIDL___MIDL_itf_ndmgr_0099_0004
    {	CCM_SPECIAL_SEPARATOR	= 0x1,
	CCM_SPECIAL_SUBMENU	= 0x2,
	CCM_SPECIAL_DEFAULT_ITEM	= 0x4,
	CCM_SPECIAL_INSERTION_POINT	= 0x8,
	CCM_SPECIAL_TESTONLY	= 0x10
    };


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0099_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0099_v0_0_s_ifspec;

#ifndef __IContextMenuCallback_INTERFACE_DEFINED__
#define __IContextMenuCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextMenuCallback
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IContextMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB7-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        END_INTERFACE
    } IContextMenuCallbackVtbl;

    interface IContextMenuCallback
    {
        CONST_VTBL struct IContextMenuCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuCallback_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuCallback_AddItem_Proxy( 
    IContextMenuCallback __RPC_FAR * This,
    /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);


void __RPC_STUB IContextMenuCallback_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuCallback_INTERFACE_DEFINED__ */


#ifndef __IContextMenuProvider_INTERFACE_DEFINED__
#define __IContextMenuProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextMenuProvider
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][object][uuid][object] */ 



EXTERN_C const IID IID_IContextMenuProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB6-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuProvider : public IContextMenuCallback
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EmptyMenuList( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryExtensionItems( 
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddThirdPartyExtensionItems( 
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyMenuList )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddThirdPartyExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected);
        
        END_INTERFACE
    } IContextMenuProviderVtbl;

    interface IContextMenuProvider
    {
        CONST_VTBL struct IContextMenuProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuProvider_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)


#define IContextMenuProvider_EmptyMenuList(This)	\
    (This)->lpVtbl -> EmptyMenuList(This)

#define IContextMenuProvider_AddPrimaryExtensionItems(This,piExtension,piDataObject)	\
    (This)->lpVtbl -> AddPrimaryExtensionItems(This,piExtension,piDataObject)

#define IContextMenuProvider_AddThirdPartyExtensionItems(This,piDataObject)	\
    (This)->lpVtbl -> AddThirdPartyExtensionItems(This,piDataObject)

#define IContextMenuProvider_ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)	\
    (This)->lpVtbl -> ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_EmptyMenuList_Proxy( 
    IContextMenuProvider __RPC_FAR * This);


void __RPC_STUB IContextMenuProvider_EmptyMenuList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddPrimaryExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPUNKNOWN piExtension,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddPrimaryExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddThirdPartyExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddThirdPartyExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_ShowContextMenu_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ long xPos,
    /* [in] */ long yPos,
    /* [retval][out] */ long __RPC_FAR *plSelected);


void __RPC_STUB IContextMenuProvider_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendContextMenu_INTERFACE_DEFINED__
#define __IExtendContextMenu_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendContextMenu
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExtendContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0")
    IExtendContextMenu : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendContextMenu __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendContextMenu __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMenuItems )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Command )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        END_INTERFACE
    } IExtendContextMenuVtbl;

    interface IExtendContextMenu
    {
        CONST_VTBL struct IExtendContextMenuVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendContextMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendContextMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendContextMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendContextMenu_AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)	\
    (This)->lpVtbl -> AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)

#define IExtendContextMenu_Command(This,lCommandID,piDataObject)	\
    (This)->lpVtbl -> Command(This,lCommandID,piDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);


void __RPC_STUB IExtendContextMenu_AddMenuItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IExtendContextMenu_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendContextMenu_INTERFACE_DEFINED__ */


#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImageList
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB8-D36C-11CF-ADBC-00AA00A80033")
    IImageList : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetIcon( 
            /* [in] */ long __RPC_FAR *pIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetStrip( 
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageList __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageList __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageList __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList_ImageListSetIcon(This,pIcon,nLoc)	\
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageList_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)	\
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ long __RPC_FAR *pIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IImageList_ImageListSetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ long __RPC_FAR *pBMapSm,
    /* [in] */ long __RPC_FAR *pBMapLg,
    /* [in] */ long nStartLoc,
    /* [in] */ COLORREF cMask);


void __RPC_STUB IImageList_ImageListSetStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList_INTERFACE_DEFINED__ */


#ifndef __IResultData_INTERFACE_DEFINED__
#define __IResultData_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultData
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6")
    IResultData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAllRsltItems( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyViewStyle( 
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetViewMode( 
            /* [in] */ long lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetViewMode( 
            /* [out] */ long __RPC_FAR *lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ HRESULTITEM itemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ long lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDescBarText( 
            /* [in] */ LPOLESTR DescText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultData __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultData __RPC_FAR * This,
            /* [in] */ long lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        END_INTERFACE
    } IResultDataVtbl;

    interface IResultData
    {
        CONST_VTBL struct IResultDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultData_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultData_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultData_FindItemByLParam(This,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultData_DeleteAllRsltItems(This)	\
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultData_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IResultData_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IResultData_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultData_ModifyItemState(This,nIndex,itemID,uAdd,uRemove)	\
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultData_ModifyViewStyle(This,add,remove)	\
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultData_SetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultData_GetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultData_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultData_Sort(This,lUserParam)	\
    (This)->lpVtbl -> Sort(This,lUserParam)

#define IResultData_SetDescBarText(This,DescText)	\
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultData_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ int nCol);


void __RPC_STUB IResultData_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_FindItemByLParam_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPARAM lParam,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID);


void __RPC_STUB IResultData_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteAllRsltItems_Proxy( 
    IResultData __RPC_FAR * This);


void __RPC_STUB IResultData_DeleteAllRsltItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyItemState_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ UINT uAdd,
    /* [in] */ UINT uRemove);


void __RPC_STUB IResultData_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyViewStyle_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ MMC_RESULT_VIEW_STYLE add,
    /* [in] */ MMC_RESULT_VIEW_STYLE remove);


void __RPC_STUB IResultData_ModifyViewStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ long lViewMode);


void __RPC_STUB IResultData_SetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *lViewMode);


void __RPC_STUB IResultData_GetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_UpdateItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID);


void __RPC_STUB IResultData_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_Sort_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ long lUserParam);


void __RPC_STUB IResultData_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetDescBarText_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPOLESTR DescText);


void __RPC_STUB IResultData_SetDescBarText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItemCount_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IResultData_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultData_INTERFACE_DEFINED__ */


#ifndef __IConsoleNameSpace_INTERFACE_DEFINED__
#define __IConsoleNameSpace_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConsoleNameSpace
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IConsoleNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEDEB620-F24D-11cf-8AFC-00AA003CA9F6")
    IConsoleNameSpace : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ long __RPC_FAR *plCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ long __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IConsoleNameSpaceVtbl;

    interface IConsoleNameSpace
    {
        CONST_VTBL struct IConsoleNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleNameSpace_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IConsoleNameSpace_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IConsoleNameSpace_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IConsoleNameSpace_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IConsoleNameSpace_GetChildItem(This,item,pItemChild,plCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,plCookie)

#define IConsoleNameSpace_GetNextItem(This,item,pItemNext,plCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,plCookie)

#define IConsoleNameSpace_GetParentItem(This,item,pItemParent,plCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,plCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_DeleteItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ long fDeleteThis);


void __RPC_STUB IConsoleNameSpace_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetChildItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IConsoleNameSpace_GetChildItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetNextItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IConsoleNameSpace_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetParentItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
    /* [out] */ long __RPC_FAR *plCookie);


void __RPC_STUB IConsoleNameSpace_GetParentItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleNameSpace_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0106
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 



typedef struct _PSP __RPC_FAR *HPROPSHEETPAGE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0106_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0106_v0_0_s_ifspec;

#ifndef __IPropertySheetCallback_INTERFACE_DEFINED__
#define __IPropertySheetCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetCallback
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object][local] */ 



EXTERN_C const IID IID_IPropertySheetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DD-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        END_INTERFACE
    } IPropertySheetCallbackVtbl;

    interface IPropertySheetCallback
    {
        CONST_VTBL struct IPropertySheetCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetCallback_AddPage(This,hPage)	\
    (This)->lpVtbl -> AddPage(This,hPage)

#define IPropertySheetCallback_RemovePage(This,hPage)	\
    (This)->lpVtbl -> RemovePage(This,hPage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_AddPage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_AddPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_RemovePage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_RemovePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetCallback_INTERFACE_DEFINED__ */


#ifndef __IPropertySheetProvider_INTERFACE_DEFINED__
#define __IPropertySheetProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetProvider
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IPropertySheetProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DE-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertySheet( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPropertySheet( 
            /* [in] */ long cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryPages( 
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddExtensionPages( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ long window,
            /* [in] */ int page) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProvider __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ long window,
            /* [in] */ int page);
        
        END_INTERFACE
    } IPropertySheetProviderVtbl;

    interface IPropertySheetProvider
    {
        CONST_VTBL struct IPropertySheetProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProvider_CreatePropertySheet(This,title,type,cookie,pIDataObject)	\
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObject)

#define IPropertySheetProvider_FindPropertySheet(This,cookie,lpComponent,lpDataObject)	\
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProvider_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)	\
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProvider_AddExtensionPages(This)	\
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProvider_Show(This,window,page)	\
    (This)->lpVtbl -> Show(This,window,page)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ long cookie,
    /* [in] */ LPDATAOBJECT pIDataObject);


void __RPC_STUB IPropertySheetProvider_CreatePropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ long cookie,
    /* [in] */ LPCOMPONENT lpComponent,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IPropertySheetProvider_FindPropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddPrimaryPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    LPUNKNOWN lpUnknown,
    BOOL bCreateHandle,
    HWND hNotifyWindow,
    BOOL bScopePane);


void __RPC_STUB IPropertySheetProvider_AddPrimaryPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddExtensionPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This);


void __RPC_STUB IPropertySheetProvider_AddExtensionPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_Show_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ long window,
    /* [in] */ int page);


void __RPC_STUB IPropertySheetProvider_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendPropertySheet_INTERFACE_DEFINED__
#define __IExtendPropertySheet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendPropertySheet
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExtendPropertySheet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DC-EF21-11cf-A285-00C04FD8DBE6")
    IExtendPropertySheet : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ long handle,
            /* [in] */ LPDATAOBJECT lpIDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendPropertySheetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ long handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        END_INTERFACE
    } IExtendPropertySheetVtbl;

    interface IExtendPropertySheet
    {
        CONST_VTBL struct IExtendPropertySheetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendPropertySheet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendPropertySheet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendPropertySheet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendPropertySheet_CreatePropertyPages(This,lpProvider,handle,lpIDataObject)	\
    (This)->lpVtbl -> CreatePropertyPages(This,lpProvider,handle,lpIDataObject)

#define IExtendPropertySheet_QueryPagesFor(This,lpDataObject)	\
    (This)->lpVtbl -> QueryPagesFor(This,lpDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ long handle,
    /* [in] */ LPDATAOBJECT lpIDataObject);


void __RPC_STUB IExtendPropertySheet_CreatePropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IExtendPropertySheet_QueryPagesFor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendPropertySheet_INTERFACE_DEFINED__ */


#ifndef __IControlbar_INTERFACE_DEFINED__
#define __IControlbar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IControlbar
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69FB811E-6C1C-11D0-A2CB-00C04FD909DD")
    IControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Detach( 
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        END_INTERFACE
    } IControlbarVtbl;

    interface IControlbar
    {
        CONST_VTBL struct IControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlbar_Create(This,nType,pExtendControlbar,ppUnknown)	\
    (This)->lpVtbl -> Create(This,nType,pExtendControlbar,ppUnknown)

#define IControlbar_Attach(This,nType,lpUnknown)	\
    (This)->lpVtbl -> Attach(This,nType,lpUnknown)

#define IControlbar_Detach(This,lpUnknown)	\
    (This)->lpVtbl -> Detach(This,lpUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Create_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
    /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);


void __RPC_STUB IControlbar_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Attach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Detach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlbar_INTERFACE_DEFINED__ */


#ifndef __IExtendControlbar_INTERFACE_DEFINED__
#define __IExtendControlbar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IExtendControlbar
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IExtendControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49506520-6F40-11D0-A98B-00C04FD8D565")
    IExtendControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControlbar )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ LPCONTROLBAR pControlbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlbarNotify )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        END_INTERFACE
    } IExtendControlbarVtbl;

    interface IExtendControlbar
    {
        CONST_VTBL struct IExtendControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendControlbar_SetControlbar(This,pControlbar)	\
    (This)->lpVtbl -> SetControlbar(This,pControlbar)

#define IExtendControlbar_ControlbarNotify(This,event,arg,param)	\
    (This)->lpVtbl -> ControlbarNotify(This,event,arg,param)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ LPCONTROLBAR pControlbar);


void __RPC_STUB IExtendControlbar_SetControlbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB IExtendControlbar_ControlbarNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendControlbar_INTERFACE_DEFINED__ */


#ifndef __IToolbar_INTERFACE_DEFINED__
#define __IToolbar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IToolbar
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IToolbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB9-D36C-11CF-ADBC-00AA00A80033")
    IToolbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBitmap( 
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButtons( 
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertButton( 
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteButton( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToolbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IToolbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IToolbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBitmap )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButtons )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IToolbarVtbl;

    interface IToolbar
    {
        CONST_VTBL struct IToolbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToolbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IToolbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IToolbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IToolbar_AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)	\
    (This)->lpVtbl -> AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)

#define IToolbar_AddButtons(This,nButtons,lpButtons)	\
    (This)->lpVtbl -> AddButtons(This,nButtons,lpButtons)

#define IToolbar_InsertButton(This,nIndex,lpButton)	\
    (This)->lpVtbl -> InsertButton(This,nIndex,lpButton)

#define IToolbar_DeleteButton(This,nIndex)	\
    (This)->lpVtbl -> DeleteButton(This,nIndex)

#define IToolbar_GetButtonState(This,idCommand,nState,pState)	\
    (This)->lpVtbl -> GetButtonState(This,idCommand,nState,pState)

#define IToolbar_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddBitmap_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nImages,
    /* [in] */ HBITMAP hbmp,
    /* [in] */ int cxSize,
    /* [in] */ int cySize,
    /* [in] */ COLORREF crMask);


void __RPC_STUB IToolbar_AddBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddButtons_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nButtons,
    /* [in] */ LPMMCBUTTON lpButtons);


void __RPC_STUB IToolbar_AddButtons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_InsertButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ LPMMCBUTTON lpButton);


void __RPC_STUB IToolbar_InsertButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_DeleteButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex);


void __RPC_STUB IToolbar_DeleteButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_GetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IToolbar_GetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_SetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IToolbar_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IToolbar_INTERFACE_DEFINED__ */


#ifndef __IConsoleVerb_INTERFACE_DEFINED__
#define __IConsoleVerb_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IConsoleVerb
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IConsoleVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E49F7A60-74AF-11D0-A286-00C04FD8FE93")
    IConsoleVerb : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB m_eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB m_eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleVerb __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleVerb __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB m_eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB m_eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IConsoleVerbVtbl;

    interface IConsoleVerb
    {
        CONST_VTBL struct IConsoleVerbVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleVerb_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleVerb_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleVerb_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleVerb_GetVerbState(This,m_eCmdID,nState,pState)	\
    (This)->lpVtbl -> GetVerbState(This,m_eCmdID,nState,pState)

#define IConsoleVerb_SetVerbState(This,m_eCmdID,nState,bState)	\
    (This)->lpVtbl -> SetVerbState(This,m_eCmdID,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB m_eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IConsoleVerb_GetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB m_eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IConsoleVerb_SetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleVerb_INTERFACE_DEFINED__ */


#ifndef __ISnapinAbout_INTERFACE_DEFINED__
#define __ISnapinAbout_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISnapinAbout
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ISnapinAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1245208C-A151-11D0-A7D7-00C04FD909DD")
    ISnapinAbout : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ LPOLESTR __RPC_FAR *lpName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
            /* [out] */ HICON __RPC_FAR *hAppIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinAbout __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinAbout __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinAbout __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinDescription )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvider )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinVersion )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HICON __RPC_FAR *hAppIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticFolderImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask);
        
        END_INTERFACE
    } ISnapinAboutVtbl;

    interface ISnapinAbout
    {
        CONST_VTBL struct ISnapinAboutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinAbout_GetSnapinDescription(This,lpDescription)	\
    (This)->lpVtbl -> GetSnapinDescription(This,lpDescription)

#define ISnapinAbout_GetProvider(This,lpName)	\
    (This)->lpVtbl -> GetProvider(This,lpName)

#define ISnapinAbout_GetSnapinVersion(This,lpVersion)	\
    (This)->lpVtbl -> GetSnapinVersion(This,lpVersion)

#define ISnapinAbout_GetSnapinImage(This,hAppIcon)	\
    (This)->lpVtbl -> GetSnapinImage(This,hAppIcon)

#define ISnapinAbout_GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)	\
    (This)->lpVtbl -> GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinDescription_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpDescription);


void __RPC_STUB ISnapinAbout_GetSnapinDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetProvider_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpName);


void __RPC_STUB ISnapinAbout_GetProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinVersion_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpVersion);


void __RPC_STUB ISnapinAbout_GetSnapinVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HICON __RPC_FAR *hAppIcon);


void __RPC_STUB ISnapinAbout_GetSnapinImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetStaticFolderImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
    /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
    /* [out] */ COLORREF __RPC_FAR *cMask);


void __RPC_STUB ISnapinAbout_GetStaticFolderImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinAbout_INTERFACE_DEFINED__ */


#ifndef __IMenuButton_INTERFACE_DEFINED__
#define __IMenuButton_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMenuButton
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IMenuButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("951ED750-D080-11d0-B197-000000000000")
    IMenuButton : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMenuButton __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMenuButton __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IMenuButtonVtbl;

    interface IMenuButton
    {
        CONST_VTBL struct IMenuButtonVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMenuButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMenuButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMenuButton_AddButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> AddButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> SetButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_AddButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_AddButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_SetButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButtonState_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IMenuButton_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMenuButton_INTERFACE_DEFINED__ */


#ifndef __ISnapinHelp_INTERFACE_DEFINED__
#define __ISnapinHelp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISnapinHelp
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ISnapinHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6B15ACE-DF59-11D0-A7DD-00C04FD909DD")
    ISnapinHelp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinHelp __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpTopic )( 
            ISnapinHelp __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
        END_INTERFACE
    } ISnapinHelpVtbl;

    interface ISnapinHelp
    {
        CONST_VTBL struct ISnapinHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinHelp_GetHelpTopic(This,lpCompiledHelpFile)	\
    (This)->lpVtbl -> GetHelpTopic(This,lpCompiledHelpFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinHelp_GetHelpTopic_Proxy( 
    ISnapinHelp __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);


void __RPC_STUB ISnapinHelp_GetHelpTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinHelp_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0116
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 















typedef IFramePrivate __RPC_FAR *LPFRAMEPRIVATE;

typedef IScopeDataPrivate __RPC_FAR *LPSCOPEDATAPRIVATE;

typedef IResultDataPrivate __RPC_FAR *LPRESULTDATAPRIVATE;

typedef IImageListPrivate __RPC_FAR *LPIMAGELISTPRIVATE;

typedef IPropertySheetChange __RPC_FAR *LPPROPERTYSHEETCHANGE;

typedef INodeCallback __RPC_FAR *LPNODECALLBACK;

typedef IScopeTreeIter __RPC_FAR *LPSCOPETREEITER;

typedef IScopeTree __RPC_FAR *LPSCOPETREE;

typedef INodeType __RPC_FAR *LPNODETYPE;

typedef INodeTypesCache __RPC_FAR *LPNODETYPESCACHE;

typedef IEnumGUID __RPC_FAR *LPENUMGUID;

typedef IEnumNodeTypes __RPC_FAR *LPENUMNODETYPES;

typedef IPropertySheetProviderPrivate __RPC_FAR *LPPROPERTYSHEETPROVIDERPRIVATE;

STDAPI MMCIsMTNodeValid(void* pMTNode, BOOL bReset);
#define DATAWINDOW_CLASS_NAME L"MMCDataWindow"
#define WINDOW_DATA_SIZE (sizeof(long) * 4)
#define PROPERTY_SHEET_SLOT          0
#define COOKIE_SLOT                  4
#define MASTERTREE_PTR_SLOT          8
#define ORIGINAL_DATA_OBJECT_SLOT    12
typedef 
enum _MID_LIST
    {	MID_VIEW	= 1,
	MID_VIEW_LARGE	= MID_VIEW + 1,
	MID_VIEW_SMALL	= MID_VIEW_LARGE + 1,
	MID_VIEW_LIST	= MID_VIEW_SMALL + 1,
	MID_VIEW_DETAIL	= MID_VIEW_LIST + 1,
	MID_VIEW_HTML	= MID_VIEW_DETAIL + 1,
	MID_ARRANGE_ICONS	= MID_VIEW_HTML + 1,
	MID_LINE_UP_ICONS	= MID_ARRANGE_ICONS + 1,
	MID_PROPERTIES	= MID_LINE_UP_ICONS + 1,
	MID_CREATE_NEW	= MID_PROPERTIES + 1,
	MID_CREATE_NEW_FOLDER	= MID_CREATE_NEW + 1,
	MID_CREATE_NEW_SHORTCUT	= MID_CREATE_NEW_FOLDER + 1,
	MID_CREATE_NEW_HTML	= MID_CREATE_NEW_SHORTCUT + 1,
	MID_CREATE_NEW_OCX	= MID_CREATE_NEW_HTML + 1,
	MID_CREATE_NEW_MONITOR	= MID_CREATE_NEW_OCX + 1,
	MID_CREATE_NEW_TASKPADITEM	= MID_CREATE_NEW_MONITOR + 1,
	MID_TASK	= MID_CREATE_NEW_TASKPADITEM + 1,
	MID_SCOPE_PANE	= MID_TASK + 1,
	MID_SELECT_ALL	= MID_SCOPE_PANE + 1,
	MID_EXPLORE	= MID_SELECT_ALL + 1,
	MID_PRINT	= MID_EXPLORE + 1,
	MID_RENAME	= MID_PRINT + 1,
	MID_DOCKING	= MID_RENAME + 1,
	MID_ARRANGE_NAME	= MID_DOCKING + 1,
	MID_ARRANGE_TYPE	= MID_ARRANGE_NAME + 1,
	MID_ARRANGE_SIZE	= MID_ARRANGE_TYPE + 1,
	MID_ARRANGE_DATE	= MID_ARRANGE_SIZE + 1,
	MID_ARRANGE_AUTO	= MID_ARRANGE_DATE + 1,
	MID_SNAPINMANAGER	= MID_ARRANGE_AUTO + 1,
	MID_DESC_BAR	= MID_SNAPINMANAGER + 1,
	MID_LAST	= MID_DESC_BAR + 1
    }	MID_LIST;

typedef struct  _CCLVLParam_tag
    {
    DWORD flags;
    LPARAM lParam;
    COMPONENTID ID;
    int nIndex;
    }	CCLVLParam_tag;

typedef struct  _CCLVSortParams
    {
    BOOL bAscending;
    int nCol;
    HWND hListview;
    LPRESULTDATACOMPARE lpSnapinCallback;
    long lUserParam;
    }	CCLVSortParams;

#define	MMC_S_INCOMPLETE	( 0xff0001 )

#define	MMC_E_INVALID_FILE	( 0x80ff0002 )

typedef struct  _PROPERTYCHANGEINFO
    {
    LPCOMPONENTDATA pComponentData;
    LPCOMPONENT pComponent;
    BOOL fScopePane;
    HWND hwnd;
    }	PROPERTYCHANGEINFO;

typedef 
enum _CONTEXT_MENU_TYPES
    {	CONTEXT_MENU_DEFAULT	= 0,
	CONTEXT_MENU_VIEW	= 1
    }	CONTEXT_MENU_TYPES;

typedef struct  _CONTEXTMENUNODEINFO
    {
    POINT m_displayPoint;
    POINT m_listviewPoint;
    BOOL m_bDisplaySnapinMgr;
    BOOL m_bScopeVisible;
    CONTEXT_MENU_TYPES m_eContextMenuType;
    DATA_OBJECT_TYPES m_eDataObjectType;
    BOOL m_bBackground;
    HWND m_hWnd;
    HWND m_hStatus;
    HWND m_hScopePane;
    long m_lSelected;
    long m_listviewStyle;
    long m_lParam;
    long m_nViewMode;
    long m_resultItemParam;
    BOOL m_bDescBarVisible;
    }	CONTEXTMENUNODEINFO;

typedef CONTEXTMENUNODEINFO __RPC_FAR *LPCONTEXTMENUNODEINFO;

typedef PROPERTYCHANGEINFO __RPC_FAR *LPPROPERTYCHANGEINFO;

typedef long HMTNODE;

typedef unsigned long MTNODEID;

typedef long HNODE;

#define	ROOTNODEID	( 1 )

typedef struct  _SELECTIONINFO
    {
    BOOL m_bScope;
    IUnknown __RPC_FAR *m_pView;
    long m_lCookie;
    MMC_CONSOLE_VERB m_eCmdID;
    }	SELECTIONINFO;

typedef 
enum _NCLBK_NOTIFY_TYPE
    {	NCLBK_ACTIVATE	= 0x9001,
	NCLBK_BTN_CLICK	= 0x9002,
	NCLBK_CLICK	= 0x9003,
	NCLBK_CONTEXTMENU	= 0x9004,
	NCLBK_DBLCLICK	= 0x9005,
	NCLBK_DELETE	= 0x9006,
	NCLBK_EXPAND	= 0x9007,
	NCLBK_EXPANDED	= 0x9008,
	NCLBK_FOCUS_CHANGE	= 0x9009,
	NCLBK_FOLDER	= 0x900a,
	NCLBK_MINIMIZED	= 0x900b,
	NCLBK_PROPERTIES	= 0x900c,
	NCLBK_PROPERTY_CHANGE	= 0x900d,
	NCLBK_NEW_NODE_UPDATE	= 0x900e,
	NCLBK_RENAME	= 0x900f,
	NCLBK_SELECT	= 0x9010,
	NCLBK_SHOW	= 0x9011,
	NCLBK_SORT	= 0x9012,
	NCLBK_MULTI_SELECT	= 0x9013,
	NCLBK_FINDITEM	= 0x9014,
	NCLBK_CACHEHINT	= 0x9015
    }	NCLBK_NOTIFY_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0116_v0_0_s_ifspec;

#ifndef __IPropertySheetChange_INTERFACE_DEFINED__
#define __IPropertySheetChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetChange
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][local][object] */ 



EXTERN_C const IID IID_IPropertySheetChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d700dd8e-2646-11d0-a2a7-00c04fd909dd")
    IPropertySheetChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ long handle,
            /* [in] */ long param) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IPropertySheetChange __RPC_FAR * This,
            /* [in] */ long handle,
            /* [in] */ long param);
        
        END_INTERFACE
    } IPropertySheetChangeVtbl;

    interface IPropertySheetChange
    {
        CONST_VTBL struct IPropertySheetChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetChange_Update(This,handle,param)	\
    (This)->lpVtbl -> Update(This,handle,param)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySheetChange_Update_Proxy( 
    IPropertySheetChange __RPC_FAR * This,
    /* [in] */ long handle,
    /* [in] */ long param);


void __RPC_STUB IPropertySheetChange_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetChange_INTERFACE_DEFINED__ */


#ifndef __IFramePrivate_INTERFACE_DEFINED__
#define __IFramePrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IFramePrivate
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IFramePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d71d1f2a-1ba2-11d0-a29b-00c04fd909dd")
    IFramePrivate : public IConsole
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetResultView( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatusBar( 
            /* [in] */ long hwndStatusBar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetComponentID( 
            /* [out] */ COMPONENTID __RPC_FAR *lpComponentID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetComponentID( 
            /* [in] */ COMPONENTID id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ long lMTNode,
            /* [in] */ long lNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ LPCOMPONENT lpComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeTree( 
            /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetScopeTree( 
            /* [in] */ IScopeTree __RPC_FAR *pScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateScopeImageList( 
            /* [in] */ REFCLSID refClsidSnapIn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUsedByExtension( 
            /* [in] */ BOOL bExtension) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CleanupViewData( 
            /* [in] */ long lViewData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFramePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFramePrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFramePrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ long data,
            /* [in] */ long hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResultView )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusBar )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long hwndStatusBar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentID )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ COMPONENTID __RPC_FAR *lpComponentID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentID )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ COMPONENTID id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNode )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long lMTNode,
            /* [in] */ long lNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPCOMPONENT lpComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeTree )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScopeTree )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ IScopeTree __RPC_FAR *pScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateScopeImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ REFCLSID refClsidSnapIn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUsedByExtension )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ BOOL bExtension);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupViewData )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ long lViewData);
        
        END_INTERFACE
    } IFramePrivateVtbl;

    interface IFramePrivate
    {
        CONST_VTBL struct IFramePrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFramePrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFramePrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFramePrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFramePrivate_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IFramePrivate_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IFramePrivate_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IFramePrivate_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IFramePrivate_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IFramePrivate_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IFramePrivate_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IFramePrivate_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IFramePrivate_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IFramePrivate_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)


#define IFramePrivate_SetResultView(This,pUnknown)	\
    (This)->lpVtbl -> SetResultView(This,pUnknown)

#define IFramePrivate_SetStatusBar(This,hwndStatusBar)	\
    (This)->lpVtbl -> SetStatusBar(This,hwndStatusBar)

#define IFramePrivate_GetComponentID(This,lpComponentID)	\
    (This)->lpVtbl -> GetComponentID(This,lpComponentID)

#define IFramePrivate_SetComponentID(This,id)	\
    (This)->lpVtbl -> SetComponentID(This,id)

#define IFramePrivate_SetNode(This,lMTNode,lNode)	\
    (This)->lpVtbl -> SetNode(This,lMTNode,lNode)

#define IFramePrivate_SetComponent(This,lpComponent)	\
    (This)->lpVtbl -> SetComponent(This,lpComponent)

#define IFramePrivate_QueryScopeTree(This,ppScopeTree)	\
    (This)->lpVtbl -> QueryScopeTree(This,ppScopeTree)

#define IFramePrivate_SetScopeTree(This,pScopeTree)	\
    (This)->lpVtbl -> SetScopeTree(This,pScopeTree)

#define IFramePrivate_CreateScopeImageList(This,refClsidSnapIn)	\
    (This)->lpVtbl -> CreateScopeImageList(This,refClsidSnapIn)

#define IFramePrivate_SetUsedByExtension(This,bExtension)	\
    (This)->lpVtbl -> SetUsedByExtension(This,bExtension)

#define IFramePrivate_CleanupViewData(This,lViewData)	\
    (This)->lpVtbl -> CleanupViewData(This,lViewData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetResultView_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IFramePrivate_SetResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetStatusBar_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long hwndStatusBar);


void __RPC_STUB IFramePrivate_SetStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_GetComponentID_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [out] */ COMPONENTID __RPC_FAR *lpComponentID);


void __RPC_STUB IFramePrivate_GetComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetComponentID_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ COMPONENTID id);


void __RPC_STUB IFramePrivate_SetComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetNode_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long lMTNode,
    /* [in] */ long lNode);


void __RPC_STUB IFramePrivate_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetComponent_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPCOMPONENT lpComponent);


void __RPC_STUB IFramePrivate_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_QueryScopeTree_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree);


void __RPC_STUB IFramePrivate_QueryScopeTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetScopeTree_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ IScopeTree __RPC_FAR *pScopeTree);


void __RPC_STUB IFramePrivate_SetScopeTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_CreateScopeImageList_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ REFCLSID refClsidSnapIn);


void __RPC_STUB IFramePrivate_CreateScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetUsedByExtension_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ BOOL bExtension);


void __RPC_STUB IFramePrivate_SetUsedByExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_CleanupViewData_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ long lViewData);


void __RPC_STUB IFramePrivate_CleanupViewData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFramePrivate_INTERFACE_DEFINED__ */


#ifndef __IScopeDataPrivate_INTERFACE_DEFINED__
#define __IScopeDataPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopeDataPrivate
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IScopeDataPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60BD2FE0-F7C5-11cf-8AFD-00AA003CA9F6")
    IScopeDataPrivate : public IConsoleNameSpace
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IScopeDataPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeDataPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ long __RPC_FAR *plCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ long __RPC_FAR *plCookie);
        
        END_INTERFACE
    } IScopeDataPrivateVtbl;

    interface IScopeDataPrivate
    {
        CONST_VTBL struct IScopeDataPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeDataPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeDataPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopeDataPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopeDataPrivate_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IScopeDataPrivate_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IScopeDataPrivate_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IScopeDataPrivate_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IScopeDataPrivate_GetChildItem(This,item,pItemChild,plCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,plCookie)

#define IScopeDataPrivate_GetNextItem(This,item,pItemNext,plCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,plCookie)

#define IScopeDataPrivate_GetParentItem(This,item,pItemParent,plCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,plCookie)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScopeDataPrivate_INTERFACE_DEFINED__ */


#ifndef __IImageListPrivate_INTERFACE_DEFINED__
#define __IImageListPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImageListPrivate
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IImageListPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7538C620-0083-11d0-8B00-00AA003CA9F6")
    IImageListPrivate : public IImageList
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapRsltImage( 
            COMPONENTID id,
            /* [in] */ int nIndex,
            /* [out] */ int __RPC_FAR *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageListPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageListPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapRsltImage )( 
            IImageListPrivate __RPC_FAR * This,
            COMPONENTID id,
            /* [in] */ int nIndex,
            /* [out] */ int __RPC_FAR *retVal);
        
        END_INTERFACE
    } IImageListPrivateVtbl;

    interface IImageListPrivate
    {
        CONST_VTBL struct IImageListPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageListPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageListPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageListPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageListPrivate_ImageListSetIcon(This,pIcon,nLoc)	\
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageListPrivate_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)	\
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)


#define IImageListPrivate_MapRsltImage(This,id,nIndex,retVal)	\
    (This)->lpVtbl -> MapRsltImage(This,id,nIndex,retVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageListPrivate_MapRsltImage_Proxy( 
    IImageListPrivate __RPC_FAR * This,
    COMPONENTID id,
    /* [in] */ int nIndex,
    /* [out] */ int __RPC_FAR *retVal);


void __RPC_STUB IImageListPrivate_MapRsltImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageListPrivate_INTERFACE_DEFINED__ */


#ifndef __IResultDataPrivate_INTERFACE_DEFINED__
#define __IResultDataPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResultDataPrivate
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IResultDataPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EBA2300-0854-11d0-8B03-00AA003CA9F6")
    IResultDataPrivate : public IResultData
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListStyle( 
            /* [out] */ long __RPC_FAR *pStyle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetListStyle( 
            /* [in] */ long Style) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Arrange( 
            long style) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InternalSort( 
            long lpHeaderCtl,
            long lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetResultData( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResultHitTest( 
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [out] */ int __RPC_FAR *piIndex,
            /* [out] */ unsigned int __RPC_FAR *pflags,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
            /* [out] */ COMPONENTID __RPC_FAR *pComponentID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pStyle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long Style);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Arrange )( 
            IResultDataPrivate __RPC_FAR * This,
            long style);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InternalSort )( 
            IResultDataPrivate __RPC_FAR * This,
            long lpHeaderCtl,
            long lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetResultData )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResultHitTest )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [out] */ int __RPC_FAR *piIndex,
            /* [out] */ unsigned int __RPC_FAR *pflags,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
            /* [out] */ COMPONENTID __RPC_FAR *pComponentID);
        
        END_INTERFACE
    } IResultDataPrivateVtbl;

    interface IResultDataPrivate
    {
        CONST_VTBL struct IResultDataPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataPrivate_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultDataPrivate_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultDataPrivate_FindItemByLParam(This,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultDataPrivate_DeleteAllRsltItems(This)	\
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultDataPrivate_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IResultDataPrivate_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IResultDataPrivate_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultDataPrivate_ModifyItemState(This,nIndex,itemID,uAdd,uRemove)	\
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultDataPrivate_ModifyViewStyle(This,add,remove)	\
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultDataPrivate_SetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultDataPrivate_GetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultDataPrivate_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultDataPrivate_Sort(This,lUserParam)	\
    (This)->lpVtbl -> Sort(This,lUserParam)

#define IResultDataPrivate_SetDescBarText(This,DescText)	\
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultDataPrivate_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)


#define IResultDataPrivate_GetListStyle(This,pStyle)	\
    (This)->lpVtbl -> GetListStyle(This,pStyle)

#define IResultDataPrivate_SetListStyle(This,Style)	\
    (This)->lpVtbl -> SetListStyle(This,Style)

#define IResultDataPrivate_Arrange(This,style)	\
    (This)->lpVtbl -> Arrange(This,style)

#define IResultDataPrivate_InternalSort(This,lpHeaderCtl,lUserParam)	\
    (This)->lpVtbl -> InternalSort(This,lpHeaderCtl,lUserParam)

#define IResultDataPrivate_ResetResultData(This)	\
    (This)->lpVtbl -> ResetResultData(This)

#define IResultDataPrivate_ResultHitTest(This,nX,nY,piIndex,pflags,pItemID,pComponentID)	\
    (This)->lpVtbl -> ResultHitTest(This,nX,nY,piIndex,pflags,pItemID,pComponentID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_GetListStyle_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pStyle);


void __RPC_STUB IResultDataPrivate_GetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_SetListStyle_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [in] */ long Style);


void __RPC_STUB IResultDataPrivate_SetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_Arrange_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    long style);


void __RPC_STUB IResultDataPrivate_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_InternalSort_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    long lpHeaderCtl,
    long lUserParam);


void __RPC_STUB IResultDataPrivate_InternalSort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_ResetResultData_Proxy( 
    IResultDataPrivate __RPC_FAR * This);


void __RPC_STUB IResultDataPrivate_ResetResultData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_ResultHitTest_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [in] */ int nX,
    /* [in] */ int nY,
    /* [out] */ int __RPC_FAR *piIndex,
    /* [out] */ unsigned int __RPC_FAR *pflags,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
    /* [out] */ COMPONENTID __RPC_FAR *pComponentID);


void __RPC_STUB IResultDataPrivate_ResultHitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataPrivate_INTERFACE_DEFINED__ */


#ifndef __IScopeTree_INTERFACE_DEFINED__
#define __IScopeTree_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopeTree
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IScopeTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8dbf067-5fb2-11d0-a986-00c04fd8d565")
    IScopeTree : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ long lFrameWindow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryIterator( 
            /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryNodeCallback( 
            /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ HMTNODE hMTNode,
            /* [in] */ long lViewData,
            /* [in] */ BOOL fRootNode,
            /* [out] */ HNODE __RPC_FAR *phNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteView( 
            /* [in] */ int nView) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyView( 
            /* [in] */ int nDestView,
            /* [in] */ int nSrcView) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DestroyNode( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bDestroyStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ MTNODEID mID,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImageList( 
            /* [out] */ long __RPC_FAR *plImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RunSnapIn( 
            /* [in] */ long hwndParent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidDocFile( 
            /* [in] */ IStorage __RPC_FAR *pStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidDocFileName( 
            /* [in] */ LPOLESTR filename) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIDFromPath( 
            /* [in] */ UINT idStatic,
            /* [in] */ LPTSTR pszPath,
            /* [out] */ ULONG __RPC_FAR *pID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScopeTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeTree __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeTree __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ long lFrameWindow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIterator )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNodeCallback )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HMTNODE hMTNode,
            /* [in] */ long lViewData,
            /* [in] */ BOOL fRootNode,
            /* [out] */ HNODE __RPC_FAR *phNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteView )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ int nView);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyView )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ int nDestView,
            /* [in] */ int nSrcView);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyNode )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bDestroyStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Find )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ MTNODEID mID,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageList )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *plImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RunSnapIn )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ long hwndParent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidDocFile )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ IStorage __RPC_FAR *pStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidDocFileName )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ LPOLESTR filename);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDFromPath )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ UINT idStatic,
            /* [in] */ LPTSTR pszPath,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        END_INTERFACE
    } IScopeTreeVtbl;

    interface IScopeTree
    {
        CONST_VTBL struct IScopeTreeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopeTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopeTree_Initialize(This,lFrameWindow)	\
    (This)->lpVtbl -> Initialize(This,lFrameWindow)

#define IScopeTree_QueryIterator(This,lpIter)	\
    (This)->lpVtbl -> QueryIterator(This,lpIter)

#define IScopeTree_QueryNodeCallback(This,ppNodeCallback)	\
    (This)->lpVtbl -> QueryNodeCallback(This,ppNodeCallback)

#define IScopeTree_CreateNode(This,hMTNode,lViewData,fRootNode,phNode)	\
    (This)->lpVtbl -> CreateNode(This,hMTNode,lViewData,fRootNode,phNode)

#define IScopeTree_DeleteView(This,nView)	\
    (This)->lpVtbl -> DeleteView(This,nView)

#define IScopeTree_CopyView(This,nDestView,nSrcView)	\
    (This)->lpVtbl -> CopyView(This,nDestView,nSrcView)

#define IScopeTree_DestroyNode(This,hNode,bDestroyStorage)	\
    (This)->lpVtbl -> DestroyNode(This,hNode,bDestroyStorage)

#define IScopeTree_Find(This,mID,phMTNode)	\
    (This)->lpVtbl -> Find(This,mID,phMTNode)

#define IScopeTree_GetImageList(This,plImageList)	\
    (This)->lpVtbl -> GetImageList(This,plImageList)

#define IScopeTree_RunSnapIn(This,hwndParent)	\
    (This)->lpVtbl -> RunSnapIn(This,hwndParent)

#define IScopeTree_IsValidDocFile(This,pStorage)	\
    (This)->lpVtbl -> IsValidDocFile(This,pStorage)

#define IScopeTree_IsValidDocFileName(This,filename)	\
    (This)->lpVtbl -> IsValidDocFileName(This,filename)

#define IScopeTree_GetIDFromPath(This,idStatic,pszPath,pID)	\
    (This)->lpVtbl -> GetIDFromPath(This,idStatic,pszPath,pID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_Initialize_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ long lFrameWindow);


void __RPC_STUB IScopeTree_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_QueryIterator_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter);


void __RPC_STUB IScopeTree_QueryIterator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_QueryNodeCallback_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback);


void __RPC_STUB IScopeTree_QueryNodeCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_CreateNode_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HMTNODE hMTNode,
    /* [in] */ long lViewData,
    /* [in] */ BOOL fRootNode,
    /* [out] */ HNODE __RPC_FAR *phNode);


void __RPC_STUB IScopeTree_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_DeleteView_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ int nView);


void __RPC_STUB IScopeTree_DeleteView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_CopyView_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ int nDestView,
    /* [in] */ int nSrcView);


void __RPC_STUB IScopeTree_CopyView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_DestroyNode_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bDestroyStorage);


void __RPC_STUB IScopeTree_DestroyNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_Find_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ MTNODEID mID,
    /* [out] */ HMTNODE __RPC_FAR *phMTNode);


void __RPC_STUB IScopeTree_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetImageList_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *plImageList);


void __RPC_STUB IScopeTree_GetImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_RunSnapIn_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ long hwndParent);


void __RPC_STUB IScopeTree_RunSnapIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_IsValidDocFile_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ IStorage __RPC_FAR *pStorage);


void __RPC_STUB IScopeTree_IsValidDocFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_IsValidDocFileName_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ LPOLESTR filename);


void __RPC_STUB IScopeTree_IsValidDocFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetIDFromPath_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ UINT idStatic,
    /* [in] */ LPTSTR pszPath,
    /* [out] */ ULONG __RPC_FAR *pID);


void __RPC_STUB IScopeTree_GetIDFromPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScopeTree_INTERFACE_DEFINED__ */


#ifndef __IScopeTreeIter_INTERFACE_DEFINED__
#define __IScopeTreeIter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScopeTreeIter
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IScopeTreeIter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d779f8d1-6057-11d0-a986-00c04fd8d565")
    IScopeTreeIter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCurrent( 
            /* [in] */ HMTNODE hStartMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT nRequested,
            /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
            /* [out] */ UINT __RPC_FAR *pnFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Child( 
            /* [out] */ HMTNODE __RPC_FAR *phsiChild) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Parent( 
            /* [out] */ HMTNODE __RPC_FAR *phsiParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScopeTreeIterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeTreeIter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeTreeIter __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrent )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ HMTNODE hStartMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ UINT nRequested,
            /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
            /* [out] */ UINT __RPC_FAR *pnFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Child )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [out] */ HMTNODE __RPC_FAR *phsiChild);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Parent )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [out] */ HMTNODE __RPC_FAR *phsiParent);
        
        END_INTERFACE
    } IScopeTreeIterVtbl;

    interface IScopeTreeIter
    {
        CONST_VTBL struct IScopeTreeIterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeTreeIter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeTreeIter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScopeTreeIter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScopeTreeIter_SetCurrent(This,hStartMTNode)	\
    (This)->lpVtbl -> SetCurrent(This,hStartMTNode)

#define IScopeTreeIter_Next(This,nRequested,rghScopeItems,pnFetched)	\
    (This)->lpVtbl -> Next(This,nRequested,rghScopeItems,pnFetched)

#define IScopeTreeIter_Child(This,phsiChild)	\
    (This)->lpVtbl -> Child(This,phsiChild)

#define IScopeTreeIter_Parent(This,phsiParent)	\
    (This)->lpVtbl -> Parent(This,phsiParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_SetCurrent_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [in] */ HMTNODE hStartMTNode);


void __RPC_STUB IScopeTreeIter_SetCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Next_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [in] */ UINT nRequested,
    /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
    /* [out] */ UINT __RPC_FAR *pnFetched);


void __RPC_STUB IScopeTreeIter_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Child_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [out] */ HMTNODE __RPC_FAR *phsiChild);


void __RPC_STUB IScopeTreeIter_Child_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Parent_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [out] */ HMTNODE __RPC_FAR *phsiParent);


void __RPC_STUB IScopeTreeIter_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScopeTreeIter_INTERFACE_DEFINED__ */


#ifndef __INodeCallback_INTERFACE_DEFINED__
#define __INodeCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INodeCallback
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_INodeCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b241fced-5fb3-11d0-a986-00c04fd8d565")
    INodeCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IScopeTree __RPC_FAR *pIScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImages( 
            /* [in] */ HNODE hNode,
            /* [out] */ int __RPC_FAR *iImage,
            int __RPC_FAR *iSelectedImage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDispInfo( 
            /* [in] */ HNODE hNode,
            /* [in] */ long dispInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultPane( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetControl( 
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [out] */ long __RPC_FAR *plControl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControl( 
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [in] */ long lControl,
            /* [in] */ long destroyer,
            /* [in] */ IUnknown __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItemID( 
            /* [in] */ HNODE hNode,
            /* [in] */ UINT nID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemID( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID,
            /* [out] */ LPTSTR __RPC_FAR *ppszPath,
            /* [out] */ UINT __RPC_FAR *pcch) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticParentID( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HNODE hNode,
            /* [in] */ NCLBK_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNode( 
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNodePath( 
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
            /* [out] */ long __RPC_FAR *plLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsExpandable( 
            /* [in] */ HNODE hNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConsoleVerb( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ IScopeTree __RPC_FAR *pIScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImages )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ int __RPC_FAR *iImage,
            int __RPC_FAR *iSelectedImage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispInfo )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ long dispInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultPane )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetControl )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [out] */ long __RPC_FAR *plControl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControl )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [in] */ long lControl,
            /* [in] */ long destroyer,
            /* [in] */ IUnknown __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ UINT nID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPath )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID,
            /* [out] */ LPTSTR __RPC_FAR *ppszPath,
            /* [out] */ UINT __RPC_FAR *pcch);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticParentID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ NCLBK_NOTIFY_TYPE event,
            /* [in] */ long arg,
            /* [in] */ long param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNode )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNodePath )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
            /* [out] */ long __RPC_FAR *plLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsExpandable )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConsoleVerb )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        END_INTERFACE
    } INodeCallbackVtbl;

    interface INodeCallback
    {
        CONST_VTBL struct INodeCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodeCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodeCallback_Initialize(This,pIScopeTree)	\
    (This)->lpVtbl -> Initialize(This,pIScopeTree)

#define INodeCallback_GetImages(This,hNode,iImage,iSelectedImage)	\
    (This)->lpVtbl -> GetImages(This,hNode,iImage,iSelectedImage)

#define INodeCallback_GetDisplayName(This,hNode,pName)	\
    (This)->lpVtbl -> GetDisplayName(This,hNode,pName)

#define INodeCallback_GetDispInfo(This,hNode,dispInfo)	\
    (This)->lpVtbl -> GetDispInfo(This,hNode,dispInfo)

#define INodeCallback_GetState(This,hNode,pnState)	\
    (This)->lpVtbl -> GetState(This,hNode,pnState)

#define INodeCallback_GetResultPane(This,hNode,ppszResultPane,pViewOptions)	\
    (This)->lpVtbl -> GetResultPane(This,hNode,ppszResultPane,pViewOptions)

#define INodeCallback_GetControl(This,hNode,clsid,plControl)	\
    (This)->lpVtbl -> GetControl(This,hNode,clsid,plControl)

#define INodeCallback_SetControl(This,hNode,clsid,lControl,destroyer,pUnknown)	\
    (This)->lpVtbl -> SetControl(This,hNode,clsid,lControl,destroyer,pUnknown)

#define INodeCallback_SetItemID(This,hNode,nID)	\
    (This)->lpVtbl -> SetItemID(This,hNode,nID)

#define INodeCallback_GetItemID(This,hNode,pnID)	\
    (This)->lpVtbl -> GetItemID(This,hNode,pnID)

#define INodeCallback_GetID(This,hNode,pnID)	\
    (This)->lpVtbl -> GetID(This,hNode,pnID)

#define INodeCallback_GetPath(This,hNode,pnID,ppszPath,pcch)	\
    (This)->lpVtbl -> GetPath(This,hNode,pnID,ppszPath,pcch)

#define INodeCallback_GetStaticParentID(This,hNode,pnID)	\
    (This)->lpVtbl -> GetStaticParentID(This,hNode,pnID)

#define INodeCallback_Notify(This,hNode,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,hNode,event,arg,param)

#define INodeCallback_GetMTNode(This,hNode,phMTNode)	\
    (This)->lpVtbl -> GetMTNode(This,hNode,phMTNode)

#define INodeCallback_GetMTNodePath(This,hNode,pphMTNode,plLength)	\
    (This)->lpVtbl -> GetMTNodePath(This,hNode,pphMTNode,plLength)

#define INodeCallback_IsExpandable(This,hNode)	\
    (This)->lpVtbl -> IsExpandable(This,hNode)

#define INodeCallback_GetConsoleVerb(This,hNode,ppConsoleVerb)	\
    (This)->lpVtbl -> GetConsoleVerb(This,hNode,ppConsoleVerb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Initialize_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ IScopeTree __RPC_FAR *pIScopeTree);


void __RPC_STUB INodeCallback_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetImages_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ int __RPC_FAR *iImage,
    int __RPC_FAR *iSelectedImage);


void __RPC_STUB INodeCallback_GetImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetDisplayName_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *pName);


void __RPC_STUB INodeCallback_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetDispInfo_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ long dispInfo);


void __RPC_STUB INodeCallback_GetDispInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetState_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnState);


void __RPC_STUB INodeCallback_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetResultPane_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB INodeCallback_GetResultPane_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetControl_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ CLSID clsid,
    /* [out] */ long __RPC_FAR *plControl);


void __RPC_STUB INodeCallback_GetControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetControl_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ CLSID clsid,
    /* [in] */ long lControl,
    /* [in] */ long destroyer,
    /* [in] */ IUnknown __RPC_FAR *pUnknown);


void __RPC_STUB INodeCallback_SetControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetItemID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ UINT nID);


void __RPC_STUB INodeCallback_SetItemID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetItemID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetItemID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetPath_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID,
    /* [out] */ LPTSTR __RPC_FAR *ppszPath,
    /* [out] */ UINT __RPC_FAR *pcch);


void __RPC_STUB INodeCallback_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetStaticParentID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetStaticParentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Notify_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ NCLBK_NOTIFY_TYPE event,
    /* [in] */ long arg,
    /* [in] */ long param);


void __RPC_STUB INodeCallback_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNode_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HMTNODE __RPC_FAR *phMTNode);


void __RPC_STUB INodeCallback_GetMTNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNodePath_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
    /* [out] */ long __RPC_FAR *plLength);


void __RPC_STUB INodeCallback_GetMTNodePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_IsExpandable_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode);


void __RPC_STUB INodeCallback_IsExpandable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetConsoleVerb_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);


void __RPC_STUB INodeCallback_GetConsoleVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodeCallback_INTERFACE_DEFINED__ */


#ifndef __IControlbarsCache_INTERFACE_DEFINED__
#define __IControlbarsCache_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IControlbarsCache
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IControlbarsCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9fcd38-b9a0-11d0-a79d-00c04fd8d565")
    IControlbarsCache : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DetachControlbars( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlbarsCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbarsCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbarsCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbarsCache __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachControlbars )( 
            IControlbarsCache __RPC_FAR * This);
        
        END_INTERFACE
    } IControlbarsCacheVtbl;

    interface IControlbarsCache
    {
        CONST_VTBL struct IControlbarsCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbarsCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbarsCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlbarsCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlbarsCache_DetachControlbars(This)	\
    (This)->lpVtbl -> DetachControlbars(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbarsCache_DetachControlbars_Proxy( 
    IControlbarsCache __RPC_FAR * This);


void __RPC_STUB IControlbarsCache_DetachControlbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlbarsCache_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0125
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef 
enum _EXTESION_TYPE
    {	EXTESION_NAMESPACE	= 0x1,
	EXTESION_CONTEXTMENU	= 0x2,
	EXTESION_TOOLBAR	= 0x3,
	EXTESION_PROPERTYSHEET	= 0x4
    }	EXTESION_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0125_v0_0_s_ifspec;

#ifndef __INodeType_INTERFACE_DEFINED__
#define __INodeType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INodeType
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_INodeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B08A8368-967F-11D0-A799-00C04FD8D565")
    INodeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNodeTypeID( 
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtension( 
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveExtension( 
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtensions( 
            /* [in] */ EXTESION_TYPE extnType,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNodeTypeID )( 
            INodeType __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtension )( 
            INodeType __RPC_FAR * This,
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveExtension )( 
            INodeType __RPC_FAR * This,
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtensions )( 
            INodeType __RPC_FAR * This,
            /* [in] */ EXTESION_TYPE extnType,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID);
        
        END_INTERFACE
    } INodeTypeVtbl;

    interface INodeType
    {
        CONST_VTBL struct INodeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodeType_GetNodeTypeID(This,pGUID)	\
    (This)->lpVtbl -> GetNodeTypeID(This,pGUID)

#define INodeType_AddExtension(This,guidSnapIn,extnType)	\
    (This)->lpVtbl -> AddExtension(This,guidSnapIn,extnType)

#define INodeType_RemoveExtension(This,guidSnapIn,extnType)	\
    (This)->lpVtbl -> RemoveExtension(This,guidSnapIn,extnType)

#define INodeType_EnumExtensions(This,extnType,ppEnumGUID)	\
    (This)->lpVtbl -> EnumExtensions(This,extnType,ppEnumGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INodeType_GetNodeTypeID_Proxy( 
    INodeType __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB INodeType_GetNodeTypeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_AddExtension_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ GUID guidSnapIn,
    /* [in] */ EXTESION_TYPE extnType);


void __RPC_STUB INodeType_AddExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_RemoveExtension_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ GUID guidSnapIn,
    /* [in] */ EXTESION_TYPE extnType);


void __RPC_STUB INodeType_RemoveExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_EnumExtensions_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ EXTESION_TYPE extnType,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID);


void __RPC_STUB INodeType_EnumExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodeType_INTERFACE_DEFINED__ */


#ifndef __INodeTypesCache_INTERFACE_DEFINED__
#define __INodeTypesCache_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: INodeTypesCache
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_INodeTypesCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE40436E-9671-11D0-A799-00C04FD8D565")
    INodeTypesCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateNodeType( 
            /* [in] */ GUID guidNodeType,
            /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteNodeType( 
            /* [in] */ GUID guidNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNodeTypes( 
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INodeTypesCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeTypesCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeTypesCache __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNodeType )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ GUID guidNodeType,
            /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteNodeType )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ GUID guidNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNodeTypes )( 
            INodeTypesCache __RPC_FAR * This,
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes);
        
        END_INTERFACE
    } INodeTypesCacheVtbl;

    interface INodeTypesCache
    {
        CONST_VTBL struct INodeTypesCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeTypesCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeTypesCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INodeTypesCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INodeTypesCache_CreateNodeType(This,guidNodeType,ppNodeType)	\
    (This)->lpVtbl -> CreateNodeType(This,guidNodeType,ppNodeType)

#define INodeTypesCache_DeleteNodeType(This,guidNodeType)	\
    (This)->lpVtbl -> DeleteNodeType(This,guidNodeType)

#define INodeTypesCache_EnumNodeTypes(This,ppEnumNodeTypes)	\
    (This)->lpVtbl -> EnumNodeTypes(This,ppEnumNodeTypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INodeTypesCache_CreateNodeType_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [in] */ GUID guidNodeType,
    /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType);


void __RPC_STUB INodeTypesCache_CreateNodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeTypesCache_DeleteNodeType_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [in] */ GUID guidNodeType);


void __RPC_STUB INodeTypesCache_DeleteNodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeTypesCache_EnumNodeTypes_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes);


void __RPC_STUB INodeTypesCache_EnumNodeTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INodeTypesCache_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0127
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0127_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0127_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0128
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0128_v0_0_s_ifspec;

#ifndef __IEnumNodeTypes_INTERFACE_DEFINED__
#define __IEnumNodeTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumNodeTypes
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumNodeTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABBD61E6-9686-11D0-A799-00C04FD8D565")
    IEnumNodeTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNodeTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumNodeTypesVtbl;

    interface IEnumNodeTypes
    {
        CONST_VTBL struct IEnumNodeTypesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNodeTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNodeTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNodeTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNodeTypes_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumNodeTypes_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNodeTypes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNodeTypes_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Next_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumNodeTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Skip_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumNodeTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Reset_Proxy( 
    IEnumNodeTypes __RPC_FAR * This);


void __RPC_STUB IEnumNodeTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Clone_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumNodeTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNodeTypes_INTERFACE_DEFINED__ */



#ifndef __NODEMGRLib_LIBRARY_DEFINED__
#define __NODEMGRLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: NODEMGRLib
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_NODEMGRLib;

EXTERN_C const CLSID CLSID_NodeInit;

#ifdef __cplusplus

class DECLSPEC_UUID("43136EB5-D36C-11CF-ADBC-00AA00A80033")
NodeInit;
#endif

EXTERN_C const CLSID CLSID_ScopeTree;

#ifdef __cplusplus

class DECLSPEC_UUID("7F1899DA-62A6-11d0-A2C6-00C04FD909DD")
ScopeTree;
#endif
#endif /* __NODEMGRLib_LIBRARY_DEFINED__ */

#ifndef __IPropertySheetProviderPrivate_INTERFACE_DEFINED__
#define __IPropertySheetProviderPrivate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertySheetProviderPrivate
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPropertySheetProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FEF554F8-A55A-11D0-A7D7-00C04FD909DD")
    IPropertySheetProviderPrivate : public IPropertySheetProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowEx( 
            /* [in] */ long window,
            /* [in] */ int page,
            /* [in] */ BOOL bModalPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertySheetEx( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject,
            /* [in] */ long lpMasterTreeNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ long cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ long window,
            /* [in] */ int page);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowEx )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ long window,
            /* [in] */ int page,
            /* [in] */ BOOL bModalPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheetEx )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ long cookie,
            /* [in] */ LPDATAOBJECT pIDataObject,
            /* [in] */ long lpMasterTreeNode);
        
        END_INTERFACE
    } IPropertySheetProviderPrivateVtbl;

    interface IPropertySheetProviderPrivate
    {
        CONST_VTBL struct IPropertySheetProviderPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProviderPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProviderPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProviderPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProviderPrivate_CreatePropertySheet(This,title,type,cookie,pIDataObject)	\
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObject)

#define IPropertySheetProviderPrivate_FindPropertySheet(This,cookie,lpComponent,lpDataObject)	\
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProviderPrivate_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)	\
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProviderPrivate_AddExtensionPages(This)	\
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProviderPrivate_Show(This,window,page)	\
    (This)->lpVtbl -> Show(This,window,page)


#define IPropertySheetProviderPrivate_ShowEx(This,window,page,bModalPage)	\
    (This)->lpVtbl -> ShowEx(This,window,page,bModalPage)

#define IPropertySheetProviderPrivate_CreatePropertySheetEx(This,title,type,cookie,pIDataObject,lpMasterTreeNode)	\
    (This)->lpVtbl -> CreatePropertySheetEx(This,title,type,cookie,pIDataObject,lpMasterTreeNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_ShowEx_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    /* [in] */ long window,
    /* [in] */ int page,
    /* [in] */ BOOL bModalPage);


void __RPC_STUB IPropertySheetProviderPrivate_ShowEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_CreatePropertySheetEx_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ long cookie,
    /* [in] */ LPDATAOBJECT pIDataObject,
    /* [in] */ long lpMasterTreeNode);


void __RPC_STUB IPropertySheetProviderPrivate_CreatePropertySheetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetProviderPrivate_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_ndmgr_0131
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


typedef long CCLVItemID;

#define	CCLV_HEADERPAD	( 15 )



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0131_v0_0_s_ifspec;

#ifndef __IMMCListView_INTERFACE_DEFINED__
#define __IMMCListView_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMMCListView
 * at Tue Jul 22 18:22:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IMMCListView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1B3C1392-D68B-11CF-8C2B-00AA003CA9F6")
    IMMCListView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetListStyle( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetListStyle( 
            /* [in] */ long nNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long iconNdx,
            /* [in] */ long lParam,
            /* [in] */ long state,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByString( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long nCol,
            /* [in] */ long occurrence,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ long owner,
            /* [in] */ long lParam,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ long subIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindColumnByString( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long occurrence,
            /* [out] */ long __RPC_FAR *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAllItems( 
            /* [in] */ long ownerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumn( 
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumn( 
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ long __RPC_FAR *nFormat,
            /* [out] */ int __RPC_FAR *width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nImage,
            /* [in] */ long lParam,
            /* [in] */ long nState,
            /* [in] */ long ownerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ int __RPC_FAR *nImage,
            /* [in] */ long __RPC_FAR *lParam,
            /* [out] */ unsigned int __RPC_FAR *nState,
            /* [in] */ long ownerID,
            /* [out] */ BOOL __RPC_FAR *pbScopeItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ COMPONENTID ownerID,
            /* [in] */ long nIndex,
            /* [in] */ UINT nState,
            /* [out] */ long __RPC_FAR *plParam,
            /* [out] */ long __RPC_FAR *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLParam( 
            /* [in] */ long nItem,
            /* [out] */ long __RPC_FAR *pLParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ long nItem,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ UINT add,
            /* [in] */ UINT remove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *hIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageStrip( 
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ long cMask,
            /* [in] */ long nEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapImage( 
            /* [in] */ long nID,
            /* [in] */ long nLoc,
            /* [out] */ int __RPC_FAR *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [in] */ int __RPC_FAR *piItem,
            /* [out] */ UINT __RPC_FAR *flags,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Arrange( 
            /* [in] */ long style) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ CCLVItemID itemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ LPARAM lUserParam,
            /* [in] */ long __RPC_FAR *pParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualMode( 
            /* [in] */ BOOL bVirtual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repaint( 
            /* [in] */ BOOL bErase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMCListViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMMCListView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStyle )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStyle )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nNewValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long iconNdx,
            /* [in] */ long lParam,
            /* [in] */ long state,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByString )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nCol,
            /* [in] */ long occurrence,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long owner,
            /* [in] */ long lParam,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long subIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindColumnByString )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long occurrence,
            /* [out] */ long __RPC_FAR *pResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllItems )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long ownerID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ long __RPC_FAR *nFormat,
            /* [out] */ int __RPC_FAR *width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nImage,
            /* [in] */ long lParam,
            /* [in] */ long nState,
            /* [in] */ long ownerID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ int __RPC_FAR *nImage,
            /* [in] */ long __RPC_FAR *lParam,
            /* [out] */ unsigned int __RPC_FAR *nState,
            /* [in] */ long ownerID,
            /* [out] */ BOOL __RPC_FAR *pbScopeItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ COMPONENTID ownerID,
            /* [in] */ long nIndex,
            /* [in] */ UINT nState,
            /* [out] */ long __RPC_FAR *plParam,
            /* [out] */ long __RPC_FAR *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLParam )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nItem,
            /* [out] */ long __RPC_FAR *pLParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nItem,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ UINT add,
            /* [in] */ UINT remove);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIcon )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *hIcon,
            /* [in] */ long nLoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImageStrip )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long __RPC_FAR *pBMapSm,
            /* [in] */ long __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ long cMask,
            /* [in] */ long nEntries);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapImage )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long nLoc,
            /* [out] */ int __RPC_FAR *pResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HitTest )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [in] */ int __RPC_FAR *piItem,
            /* [out] */ UINT __RPC_FAR *flags,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Arrange )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long style);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ long __RPC_FAR *pParams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVirtualMode )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ BOOL bVirtual);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Repaint )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ BOOL bErase);
        
        END_INTERFACE
    } IMMCListViewVtbl;

    interface IMMCListView
    {
        CONST_VTBL struct IMMCListViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMCListView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMMCListView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMMCListView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMMCListView_GetListStyle(This)	\
    (This)->lpVtbl -> GetListStyle(This)

#define IMMCListView_SetListStyle(This,nNewValue)	\
    (This)->lpVtbl -> SetListStyle(This,nNewValue)

#define IMMCListView_InsertItem(This,str,iconNdx,lParam,state,ownerID,pItemID)	\
    (This)->lpVtbl -> InsertItem(This,str,iconNdx,lParam,state,ownerID,pItemID)

#define IMMCListView_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IMMCListView_FindItemByString(This,str,nCol,occurrence,ownerID,pItemID)	\
    (This)->lpVtbl -> FindItemByString(This,str,nCol,occurrence,ownerID,pItemID)

#define IMMCListView_FindItemByLParam(This,owner,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,owner,lParam,pItemID)

#define IMMCListView_InsertColumn(This,nCol,str,nFormat,width)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,str,nFormat,width)

#define IMMCListView_DeleteColumn(This,subIndex)	\
    (This)->lpVtbl -> DeleteColumn(This,subIndex)

#define IMMCListView_FindColumnByString(This,str,occurrence,pResult)	\
    (This)->lpVtbl -> FindColumnByString(This,str,occurrence,pResult)

#define IMMCListView_DeleteAllItems(This,ownerID)	\
    (This)->lpVtbl -> DeleteAllItems(This,ownerID)

#define IMMCListView_SetColumn(This,nCol,str,nFormat,width)	\
    (This)->lpVtbl -> SetColumn(This,nCol,str,nFormat,width)

#define IMMCListView_GetColumn(This,nCol,str,nFormat,width)	\
    (This)->lpVtbl -> GetColumn(This,nCol,str,nFormat,width)

#define IMMCListView_SetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID)	\
    (This)->lpVtbl -> SetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID)

#define IMMCListView_GetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID,pbScopeItem)	\
    (This)->lpVtbl -> GetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID,pbScopeItem)

#define IMMCListView_GetNextItem(This,ownerID,nIndex,nState,plParam,pnIndex)	\
    (This)->lpVtbl -> GetNextItem(This,ownerID,nIndex,nState,plParam,pnIndex)

#define IMMCListView_GetLParam(This,nItem,pLParam)	\
    (This)->lpVtbl -> GetLParam(This,nItem,pLParam)

#define IMMCListView_ModifyItemState(This,nItem,itemID,add,remove)	\
    (This)->lpVtbl -> ModifyItemState(This,nItem,itemID,add,remove)

#define IMMCListView_SetIcon(This,nID,hIcon,nLoc)	\
    (This)->lpVtbl -> SetIcon(This,nID,hIcon,nLoc)

#define IMMCListView_SetImageStrip(This,nID,pBMapSm,pBMapLg,nStartLoc,cMask,nEntries)	\
    (This)->lpVtbl -> SetImageStrip(This,nID,pBMapSm,pBMapLg,nStartLoc,cMask,nEntries)

#define IMMCListView_MapImage(This,nID,nLoc,pResult)	\
    (This)->lpVtbl -> MapImage(This,nID,nLoc,pResult)

#define IMMCListView_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMMCListView_HitTest(This,nX,nY,piItem,flags,pItemID)	\
    (This)->lpVtbl -> HitTest(This,nX,nY,piItem,flags,pItemID)

#define IMMCListView_Arrange(This,style)	\
    (This)->lpVtbl -> Arrange(This,style)

#define IMMCListView_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IMMCListView_Sort(This,lUserParam,pParams)	\
    (This)->lpVtbl -> Sort(This,lUserParam,pParams)

#define IMMCListView_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#define IMMCListView_SetVirtualMode(This,bVirtual)	\
    (This)->lpVtbl -> SetVirtualMode(This,bVirtual)

#define IMMCListView_Repaint(This,bErase)	\
    (This)->lpVtbl -> Repaint(This,bErase)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMMCListView_GetListStyle_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_GetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetListStyle_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nNewValue);


void __RPC_STUB IMMCListView_SetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_InsertItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long iconNdx,
    /* [in] */ long lParam,
    /* [in] */ long state,
    /* [in] */ long ownerID,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol);


void __RPC_STUB IMMCListView_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindItemByString_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long nCol,
    /* [in] */ long occurrence,
    /* [in] */ long ownerID,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_FindItemByString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindItemByLParam_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long owner,
    /* [in] */ long lParam,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_InsertColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [in] */ LPCOLESTR str,
    /* [in] */ long nFormat,
    /* [in] */ long width);


void __RPC_STUB IMMCListView_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long subIndex);


void __RPC_STUB IMMCListView_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindColumnByString_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long occurrence,
    /* [out] */ long __RPC_FAR *pResult);


void __RPC_STUB IMMCListView_FindColumnByString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteAllItems_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long ownerID);


void __RPC_STUB IMMCListView_DeleteAllItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [in] */ LPCOLESTR str,
    /* [in] */ long nFormat,
    /* [in] */ long width);


void __RPC_STUB IMMCListView_SetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [out] */ LPOLESTR __RPC_FAR *str,
    /* [out] */ long __RPC_FAR *nFormat,
    /* [out] */ int __RPC_FAR *width);


void __RPC_STUB IMMCListView_GetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol,
    /* [in] */ LPOLESTR str,
    /* [in] */ long nImage,
    /* [in] */ long lParam,
    /* [in] */ long nState,
    /* [in] */ long ownerID);


void __RPC_STUB IMMCListView_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol,
    /* [out] */ LPOLESTR __RPC_FAR *str,
    /* [out] */ int __RPC_FAR *nImage,
    /* [in] */ long __RPC_FAR *lParam,
    /* [out] */ unsigned int __RPC_FAR *nState,
    /* [in] */ long ownerID,
    /* [out] */ BOOL __RPC_FAR *pbScopeItem);


void __RPC_STUB IMMCListView_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetNextItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ COMPONENTID ownerID,
    /* [in] */ long nIndex,
    /* [in] */ UINT nState,
    /* [out] */ long __RPC_FAR *plParam,
    /* [out] */ long __RPC_FAR *pnIndex);


void __RPC_STUB IMMCListView_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetLParam_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nItem,
    /* [out] */ long __RPC_FAR *pLParam);


void __RPC_STUB IMMCListView_GetLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_ModifyItemState_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nItem,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ UINT add,
    /* [in] */ UINT remove);


void __RPC_STUB IMMCListView_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetIcon_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long __RPC_FAR *hIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IMMCListView_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetImageStrip_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long __RPC_FAR *pBMapSm,
    /* [in] */ long __RPC_FAR *pBMapLg,
    /* [in] */ long nStartLoc,
    /* [in] */ long cMask,
    /* [in] */ long nEntries);


void __RPC_STUB IMMCListView_SetImageStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_MapImage_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long nLoc,
    /* [out] */ int __RPC_FAR *pResult);


void __RPC_STUB IMMCListView_MapImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Reset_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_HitTest_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nX,
    /* [in] */ int nY,
    /* [in] */ int __RPC_FAR *piItem,
    /* [out] */ UINT __RPC_FAR *flags,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Arrange_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long style);


void __RPC_STUB IMMCListView_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_UpdateItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID);


void __RPC_STUB IMMCListView_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Sort_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPARAM lUserParam,
    /* [in] */ long __RPC_FAR *pParams);


void __RPC_STUB IMMCListView_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetItemCount_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IMMCListView_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetVirtualMode_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ BOOL bVirtual);


void __RPC_STUB IMMCListView_SetVirtualMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Repaint_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ BOOL bErase);


void __RPC_STUB IMMCListView_Repaint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMMCListView_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long __RPC_FAR *, HBITMAP __RPC_FAR * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long __RPC_FAR *, HICON __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\stattext.h ===
#ifndef _STATTEXT_H
#define _STATTEXT_H

#include "amcmsgid.h"

//
// lpszStatusText==NULL -> remove this status text item
// lpszStatusText==L"" -> force status text to blank string
//
class CAMCStatusBarText
{
public:
	CAMCStatusBarText( HWND hwndStatusBar );
	CAMCStatusBarText( HWND hwndStatusBar, LPCTSTR lpszStatusText );
	~CAMCStatusBarText();

	void Change( LPCTSTR lpszStatusText, BOOL fMoveToTop = FALSE );
	void Set3DTo(BOOL bState);

private:
	HWND m_hwndStatusBar;
	PVOID m_hText;
};

inline CAMCStatusBarText::CAMCStatusBarText( HWND hwndStatusBar )
:	m_hwndStatusBar( hwndStatusBar ),
	m_hText( NULL )
{
	ASSERT( m_hwndStatusBar != NULL );
}

inline CAMCStatusBarText::CAMCStatusBarText( HWND hwndStatusBar, LPCTSTR lpszStatusText )
:	m_hwndStatusBar( hwndStatusBar ),
	m_hText( NULL )
{
	ASSERT( m_hwndStatusBar != NULL );
	Change( lpszStatusText );
}

inline CAMCStatusBarText::~CAMCStatusBarText()
{
	Change( NULL );
}

inline void CAMCStatusBarText::Set3DTo(BOOL bState)
{
    ::SendMessage(m_hwndStatusBar, MMC_MSG_STAT_3D, (WPARAM)bState, 0);
}

inline void CAMCStatusBarText::Change( LPCTSTR lpszStatusText, BOOL fMoveToTop )
{
	if ( NULL == lpszStatusText )
	{
		if ( NULL != m_hText )
		{
			(void) ::SendMessage( m_hwndStatusBar, MMC_MSG_STAT_POP, (LPARAM)NULL, (WPARAM)m_hText );
			m_hText = NULL;
		}
	}
	else if ( NULL == m_hText )
	{
		m_hText = (PVOID)::SendMessage( m_hwndStatusBar, MMC_MSG_STAT_PUSH, (WPARAM)lpszStatusText, (LPARAM)NULL );
		ASSERT( m_hText != NULL );
	}
	else
	{
        if ( fMoveToTop )
        {
			(void) ::SendMessage( m_hwndStatusBar, MMC_MSG_STAT_POP, (LPARAM)NULL, (WPARAM)m_hText );
    		m_hText = (PVOID)::SendMessage( m_hwndStatusBar, MMC_MSG_STAT_PUSH, (WPARAM)lpszStatusText, (LPARAM)NULL );
        }
        else
        {
       		(void) ::SendMessage( m_hwndStatusBar, MMC_MSG_STAT_UPDATE, (WPARAM)lpszStatusText, (LPARAM)m_hText );
        }
	}
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\stgutil.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       stgutil.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/3/1996   RaviR   Created
//
//____________________________________________________________________________

#include "headers.hxx"
#pragma hdrstop

#include <afxconv.h>
#include "stgutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//____________________________________________________________________________
//
//  Member:     CIStream::Read
//
//  Synopsis:   Reads cb count of bytes from the stream passed into the
//              buffer, pv.  Insures the count read equals the count
//              requested.
//
//  Arguments:  [pv]   -- buffer to read into.
//              [cb]   -- read request byte count.
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes read != bytes expected>.
//____________________________________________________________________________

void
CIStream::Read(VOID * pv, ULONG cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pv != NULL);

    ULONG cbRead = 0;

    HRESULT hr = m_pstm->Read(pv, cb, &cbRead);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cb != cbRead)
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}


//____________________________________________________________________________
//
//  Member:     CIStream::Write
//
//  Synopsis:   Writes cb count of bytes from the stream passed from the
//              buffer, pv.  Insures the count written equals the count
//              specified.
//
//  Arguments:  [pv]   -- buffer to write from.
//              [cb]   -- write request byte count.
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes written != bytes expected>.
//____________________________________________________________________________

void
CIStream::Write(
    const VOID * pv,
    ULONG        cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pv != NULL);

    ULONG cbWritten = 0;

    HRESULT hr = m_pstm->Write(pv, cb, &cbWritten);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cb != cbWritten)
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}



//____________________________________________________________________________
//
//  Member:     CIStream::CopyTo
//
//  Synopsis:   Copies cb number of bytes from the current seek pointer in
//              the stream to the current seek pointer in another stream
//
//  Arguments:  [pstm] -- Points to the destination stream
//              [cb]   -- Specifies the number of bytes to copy
//
//  Returns:    void
//
//  Notes:      Throws CFileException(IStream error value) if the read fails,
//				or CFileException(E_FAIL) if <bytes read != bytes written>.
//____________________________________________________________________________

void
CIStream::CopyTo(
    IStream * pstm,
    ULARGE_INTEGER cb)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pstm != NULL);

    ULARGE_INTEGER cbRead = {0};
    ULARGE_INTEGER cbWritten = {0};

    HRESULT hr = m_pstm->CopyTo(pstm, cb, &cbRead, &cbWritten);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
		THROW_FILE_ERROR( hr );
    }
    else if (cbWritten.LowPart != cbRead.LowPart ||
             cbWritten.HighPart != cbRead.HighPart )
    {
        CHECK_HRESULT(E_FAIL);
		THROW_FILE_ERROR( E_FAIL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#define DEB_RESOURCE    DEB_USER10      // Constructor/Destructor
#define DEB_METHOD      DEB_USER11
#define DEB_FUNCTION    DEB_USER12

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1


    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_DESTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this);

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n"));

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __DummyDbg(ULONG, LPCWSTR, ...) { }
    inline void __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __DummyTrace(LPCWSTR, ...) { }
    inline void __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   (e)

    #define ASSERT(e)
    #define VERIFY(e)   (e)

#endif // DBG==1


#if DBG==1 && defined(_NODEMGR_DLL_)

    // Debug instance counter
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "MMC: Memory Leak!!!", MB_OK);
}

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#endif





#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }


#ifdef DBX
#define DbxAssert(x)    ASSERT(x)
#else
#define DbxAssert(x)
#endif

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\stgutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StgUtil.h
//
//  Contents:   Classes to simplify dealing with storage objects.
//
//  Classes:    CDocFile,
//              CIStorage
//              CIStream
//
//  History:    6/3/1996   RaviR   Created
//
//
//  Sample:     Code sample using the above three classes & their safe ptrs.
//
//              Objective: Create a doc file this will be the root storage.
//                         Create a sub storage under this root storage.
//
//              Code:
//                  HRESULT
//                  CerateADocFileWithSubStorage(
//                      WCHAR      wszDocFileName[],
//                      WCHAR      wszSubStgName[],
//                      LPSTORAGE *ppstg)
//                  {
//                      try
//                      {
//                          CDocFile docFile;
//                          docFile.Create(wszDocFileName);
//
//                          CIStorage stgRoot;
//                          docFile.Transfer(&stgRoot);
//
//                          CIStorage stgSub;
//                          stgRoot.CreateStorage(&stgSub, wszSubStgName);
//
//                          stgRoot.Transfer(ppstg);
//                      }
//                      CATCH_FILE_ERROR(hr,cfe)
//							delete cfe;
//                          return hr;
//                      END_CATCH_FILE_ERROR;
//
//                      return S_OK;
//                  }
//
//____________________________________________________________________________
//


#ifndef __STGUTIL__H__
#define __STGUTIL__H__

#include "macros.h"

//
// CDocFile, CIStorage and CIStream throw errors of type CFileException.
// Note, however, that m_cause is always CFileException::generic and
// m_lOsError is an HRESULT rather than a Windows error code.
//

#define THROW_FILE_ERROR2(hr,psz) AfxThrowFileException( CFileException::generic, hr, psz );
#define THROW_FILE_ERROR(hr) THROW_FILE_ERROR2( hr, NULL )

#define CATCH_FILE_ERROR(hr)							\
	catch(CFileException* cfe)							\
	{													\
		if (cfe.m_cause != CFileException::generic)		\
			throw;										\
		HRESULT hr = cfe.m_IOsError;

#define END_CATCH_FILE_ERROR }
		
//____________________________________________________________________________
//
//  Class:      CDocFile
//
//  Synopsis:   CDocFile can be used to create, open & close a docfile.
//              It has one data member, a pointer to the root IStorage
//              interface of the document. Safe interface pointer member
//              functions are created for this data member. (Please see
//              macros.h for description of Safe interface pointer member
//              functions)
//
//  Members:    Create:
//                  Creates/opens a docfile with the given name. The default
//                  mode is to create a docfile with read-write and share
//                  exclusive flags. Throws CFileException on error.
//
//              CreateTemporary:
//                  Creates a temporary docfile, which will be deleted on
//                  release. Throws CFileException on error.
//
//              Open:
//                  Opens an existing docfile. The default mode is read-write
//                  and share exclusive. Throws CFileException on error.
//
//              Safe Interface Pointer Member functions:
//                  Used to access the IStorage interface ptr. (see macros.h)
//
//
//  History:    5/31/1996   RaviR   Created
//
//____________________________________________________________________________
//


class CDocFile
{
public:

    void Create(LPWSTR pwszName,
            DWORD grfMode = STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE);

    void CreateTemporary(void) { this->Create(NULL, STGM_DELETEONRELEASE); }

    void Open(LPWSTR pwszName,
            DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CDocFile, IStorage, m_pstg)

private:
    LPSTORAGE       m_pstg;

}; // class CDocFile



inline
void
CDocFile::Create(
    LPWSTR pswzName,
    DWORD  grfMode)
{
    ASSERT(m_pstg == NULL);

    HRESULT hr = StgCreateDocfile(pswzName, grfMode, 0, &m_pstg);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        m_pstg = NULL;
		USES_CONVERSION;
        THROW_FILE_ERROR2( hr, W2T(pswzName) );
    }
}


inline
void
CDocFile::Open(
    LPWSTR pwszName,
    DWORD  grfMode)
{
    ASSERT(m_pstg == NULL);

    HRESULT hr = StgOpenStorage(pwszName, NULL, grfMode, NULL, NULL, &m_pstg);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        m_pstg = NULL;
		USES_CONVERSION;
        THROW_FILE_ERROR2( hr, W2T(pwszName) );
    }
}


//____________________________________________________________________________
//
//  Class:      CIStorage
//
//  Synopsis:   Represents an IStorage instance - top level or embedded.
//
//  History:    5/29/1996   RaviR   Created
//
//  Notes:      1) This is a simple wrapper around the Docfile implementaion
//                 of IStorage.
//
//              2) Instead of returning errors we use the C++ exception
//                 handling mechanism and throw CFileException.
//
//              3) Most of the methods have default values for arguments.
//
//              4) Safe Interface Pointer methods have been added for
//                 the IStorage interface ptr.
//
//
//              CIStorage
//                  |
//                  |
//              IStorage
//
//____________________________________________________________________________
//

class CIStorage
{
public:

    void CreateStream(LPSTREAM *ppstm, LPCOLESTR pszName,
                      DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstm != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_TRANSACTED) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->CreateStream(pszName, grfMode, NULL, NULL, ppstm);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStream(LPSTREAM *ppstm, LPCOLESTR pszName,
                       DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstm != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_TRANSACTED) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStream(pszName, NULL, grfMode, 0, ppstm);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void CreateStorage(LPSTORAGE *ppstg, LPCOLESTR pszName,
                          DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);

        HRESULT hr = m_pstg->CreateStorage(pszName, grfMode, NULL, NULL, ppstg);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStorage(LPSTORAGE *ppstg, LPCOLESTR pszName,
                        DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_PRIORITY) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStorage(pszName, NULL, grfMode, NULL, 0, ppstg);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStorage(LPSTORAGE *ppstg, LPSTORAGE pstgPriority,
                        DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_PRIORITY) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStorage(NULL, pstgPriority, grfMode, NULL, 0, ppstg);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void CopyTo(LPSTORAGE pstgDest)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pstgDest != NULL);

        HRESULT hr = m_pstg->CopyTo(0, NULL, NULL, pstgDest);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void MoveElementTo(LPCOLESTR pszName, LPSTORAGE pstgDest,
                          LPCOLESTR pszNewName, DWORD grfFlags = STGMOVE_MOVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pstgDest != NULL);
        ASSERT(m_pstg != pstgDest);

        HRESULT hr = m_pstg->MoveElementTo(pszName, pstgDest, pszNewName, grfFlags);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void Commit(DWORD grfCommitFlags = STGC_ONLYIFCURRENT)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Commit(grfCommitFlags);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void Revert(void)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Revert();

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void EnumElements(IEnumSTATSTG ** ppenum)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppenum != NULL);

        HRESULT hr = m_pstg->EnumElements(0, NULL, 0, ppenum);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void DestroyElement(LPCOLESTR pszName)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->DestroyElement(pszName);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void RenameElement(LPCOLESTR pszOldName, LPCOLESTR pszNewName)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pszOldName != NULL);
        ASSERT(pszNewName != NULL);

        HRESULT hr = m_pstg->RenameElement(pszOldName, pszNewName);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetElementTimes(LPCOLESTR pszName, LPFILETIME pctime,
                        LPFILETIME patime = NULL, LPFILETIME pmtime = NULL)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetElementTimes(pszName, pctime, patime, pmtime);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetClass(REFCLSID clsid)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetClass(clsid);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetStateBits(DWORD grfStateBits, DWORD grfMask)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetStateBits(grfStateBits, grfMask);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void Stat(STATSTG * pstatstg, DWORD grfStatFlag = STATFLAG_NONAME)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Stat(pstatstg, grfStatFlag);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CIStorage, IStorage, m_pstg)

private:
    IStorage * m_pstg;

}; // class CIStorage




//____________________________________________________________________________
//
//  Class:      CIStream
//
//  Synopsis:   Represents an IStream instance
//
//  History:    5/31/1996   RaviR   Created
//
//  Notes:      1) This is a simple wrapper around the Docfile implementaion
//                 of IStream.
//
//              2) Instead of returning errors we use the C++ exception
//                 handling mechanism and throw the error(hresult).
//
//              4) Safe Interface Pointer methods have been added for
//                 the IStream interface ptr.
//
//
//              CIStream
//                 |
//                 |
//              IStream
//
//____________________________________________________________________________
//

class CIStream
{
public:

    void Commit(DWORD grfCommitFlags = STGC_ONLYIFCURRENT);
    void Clone(IStream ** ppstm);
    void Read(PVOID pv, ULONG cb);
    void Write(const VOID * pv, ULONG cb);
    void CopyTo(IStream * pstm, ULARGE_INTEGER cb);
    void GetCurrentSeekPosition(ULARGE_INTEGER * plibCurPosition);
    void Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin = STREAM_SEEK_CUR,
                                ULARGE_INTEGER * plibNewPosition = NULL);
    void SetSize(ULARGE_INTEGER libNewSize);
    void Stat(STATSTG * pstatstg, DWORD grfStatFlag = STATFLAG_NONAME);

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CIStream, IStream, m_pstm);

private:
    LPSTREAM    m_pstm;

}; // class CIStream


inline
void
CIStream::Clone(
    IStream ** ppstm)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Clone(ppstm);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::Commit(
    DWORD grfCommitFlags)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Commit(grfCommitFlags);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Seek(dlibMove, dwOrigin, plibNewPosition);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



//____________________________________________________________________________
//
//  Member:     CIStream::GetCurrentSeekPosition
//
//  Synopsis:   Returns the current seek position.
//
//  Arguments:  [plibCurPosition] -- IN
//
//  Returns:    void
//____________________________________________________________________________
//

inline
void
CIStream::GetCurrentSeekPosition(
    ULARGE_INTEGER * plibCurPosition)
{
    ASSERT(m_pstm != NULL);
    ASSERT(plibCurPosition != NULL);

    LARGE_INTEGER li = {0};

    HRESULT hr = m_pstm->Seek(li, STREAM_SEEK_CUR, plibCurPosition);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::SetSize(
    ULARGE_INTEGER libNewSize)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->SetSize(libNewSize);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



inline
void
CIStream::Stat(
    STATSTG   * pstatstg,
    DWORD       grfStatFlag)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pstatstg != NULL);

    HRESULT hr = m_pstm->Stat(pstatstg, grfStatFlag);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



#endif // __STGUTIL__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\strings.cpp ===
#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

EXTERN_C const TCHAR g_szCLSID[] = TEXT("CLSID");
EXTERN_C const TCHAR g_szContextMenu[] = TEXT("ContextMenu");
EXTERN_C const TCHAR g_szDynamicExtensions[] = TEXT("DynamicExtensions");
EXTERN_C const TCHAR g_szImage[] = TEXT("Image");
EXTERN_C const TCHAR g_szImageOpen[] = TEXT("ImageOpen");
EXTERN_C const TCHAR g_szImageClosed[] = TEXT("ImageClosed");
EXTERN_C const TCHAR g_szName[] = TEXT("Name");
EXTERN_C const TCHAR g_szNameString[] = TEXT("NameString");
EXTERN_C const TCHAR g_szObject[] = TEXT("Object");
EXTERN_C const TCHAR g_szObjects[] = TEXT("Objects");
EXTERN_C const TCHAR g_szObjectType[] = TEXT("ObjectType");
EXTERN_C const TCHAR g_szObjectTypes[] = TEXT("ObjectTypes");
EXTERN_C const TCHAR g_szObjectTypeGUID[] = TEXT("ObjectTypeGUID");
EXTERN_C const TCHAR g_szObjectContext[] = TEXT("ObjectContext");
EXTERN_C const TCHAR g_szPackage[] = TEXT("Package");
EXTERN_C const TCHAR g_szResultPane[] = TEXT("ResultPane");
EXTERN_C const TCHAR g_szStatus[] = TEXT("Status");
EXTERN_C const TCHAR g_szStatusString[] = TEXT("StatusString");
EXTERN_C const TCHAR g_szTree[] = TEXT("Tree");
EXTERN_C const TCHAR g_szNameSpace[] = TEXT("NameSpace");
EXTERN_C const TCHAR g_szNodeType[] = TEXT("NodeType");
EXTERN_C const TCHAR g_szNodeTypes[] = TEXT("NodeTypes");
EXTERN_C const TCHAR g_szPropertySheet[] = TEXT("PropertySheet");
EXTERN_C const TCHAR g_szStandAlone[] = TEXT("StandAlone");
EXTERN_C const TCHAR g_szToolbar[] = TEXT("Toolbar");
EXTERN_C const TCHAR g_szExtensions[] = TEXT("Extensions");

EXTERN_C const TCHAR CURRENT_VER_KEY[] = _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
EXTERN_C const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
EXTERN_C const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\strconv.h ===
// This header contains macros and functions for performing various types of
// string conversions, in most cases, these functions are duplicate of others
// found in both MFC, and ATL.  Unfortunately, when both MFC and ATL are
// included within the same translation unit, all of the conversion functions
// available in ATL are made unavailable.  This file should work in all settings!
// The functions, though, in many cases to functions elsewhere have been renamed
// to avoid name colisions.  The naming convention is similar to the naming
// convention used in the C++ standard library.  ANSI strings are abbreviated to
// str, while wide character strings are abbreviated to wcs.

#ifndef STRCONV_H
#define STRCONV_H

#ifndef __wtypes_h__
#include <wtypes.h>
#endif
#ifndef _INC_MALLOC
#include <malloc.h>
#endif

namespace microsoft	{
namespace string_conversion {

inline BSTR wcs2BSTR(const wchar_t* ws) throw()
	// Converts a wide character string to a BSTR.  The callee is responsible
	// for releasing the returned BSTR.  A BSTR is always returned, even if ws
	// is NULL.  When ws is NULL, an empty BSTR is returned.  This is done so
	// that the behaviour of this function is similar to those found below.
	{
	return ws ? SysAllocString(ws) : SysAllocString(L"");
	}

inline BSTR str2BSTR(const char* s) throw()
	// Converts the provided narrow string to a BSTR.  The BSTR must be released
	// by the callee.
	{
	if (!s)
		return wcs2BSTR(NULL);
	const int len = lstrlenA(s)+1;
	wchar_t* ws = reinterpret_cast<wchar_t*>(alloca((len)*2));
	*ws=0;
	MultiByteToWideChar(CP_ACP, 0, s, -1, ws, len);
	return wcs2BSTR(ws);
	}

inline char* wcs2str(char* s, const wchar_t* ws) throw()
	// Converts the provided wcs to a narrrow string, which will be stored in
	// the provided space.  No overrun checking is done!  The narrow string
	// is returned.
	{
	*s=0;
	WideCharToMultiByte(CP_ACP, 0, ws, -1, s, lstrlenW(ws)+1, NULL, NULL);
	return s;
	}

inline char* wcs2str(char* s, const wchar_t* ws, int wslen) throw()
	// Converts the provided wcs to a narrow string, which will be stored
	// in the provided space.  Overrun checking is performed.
	{
	*s=0;
	WideCharToMultiByte(CP_ACP, 0, ws, -1, s, wslen, NULL, NULL);
	return s;
	}

#define USES_STRCONV int _strconv_length;

#define WCS2STR(ws) \
	(ws ? (_strconv_length = lstrlenW(ws)+1,\
	wcs2str(reinterpret_cast<char*>(alloca(_strconv_length)),\
	ws, _strconv_length)) : NULL)

} // namespace string_conversion
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef STRING_CONVERSION_NAMESPACE_ON
using namespace string_conversion;
#endif // STRING_CONVERSION_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // STRCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\safetemp.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SafeTemp.h
//
//  Contents:   A template for safe pointers.
//
//  Classes:    XSafeInterfacePtr<ISome>
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


//____________________________________________________________________________
//
//  Template:   XSafeInterfacePtr
//
//  Purpose:    Safe pointer to any interface that supports AddRef/Release
//
//  Notes:      This works for classes that define AddRef/Release, or for
//              OLE interfaces. It is not necessary that the class
//              be a derivative of IUnknown, so long as it supports
//              AddRef and Release methods which have the same semantics as
//              those in IUnknown.
//
//              The constructor takes a parameter which specifies whether
//              the captured pointer should be AddRef'd, defaulting to TRUE.
//
//              The Copy function creates a valid additional copy of
//              the captured pointer (following the AddRef/Release protocol)
//              so can be used to hand out copies from a safe pointer declared
//              as a member of some other class.
//
//              The 'Transfer' function transfers the interface pointer, and
//              invalidates its member value (by setting it to NULL).
//
//              To release the existing interface ptr and set it to a new
//              instance use the 'Set' member fuction. This method takes a
//              parameter which specifies whether the new pointer should be
//              AddRef'd, defaulting to TRUE.
//
//              The following methods manipulate the interface pointer with
//              out following the AddRef/Release protocol: Transfer, Attach
//              and Detach.
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


template<class ISome>
class XSafeInterfacePtr
{
public:

    inline XSafeInterfacePtr(ISome * pinter=NULL, BOOL fInc=TRUE)
        : _p ( pinter )
    {
        if (fInc && (_p != NULL))
        {
            _p->AddRef();
        }
    }

    inline ~XSafeInterfacePtr()
    {
        if (_p != NULL)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline BOOL IsNull(void)
    {
        return (_p == NULL);
    }

    inline void Copy(ISome **pxtmp)
    {
        *pxtmp = _p;
        if (_p != NULL)
            _p->AddRef();
    }

    inline void Transfer(ISome **pxtmp)
    {
        *pxtmp = _p;
        _p = NULL;
    }

    inline void Set(ISome* p, BOOL fInc = TRUE)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
        if (fInc && _p)
        {
            _p->AddRef();
        }
    }

    inline void SafeRelease(void)
    {
        if (_p)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline void SimpleRelease(void)
    {
        ASSERT(_p != NULL);
        _p->Release();
        _p = NULL;
    }

    inline void Attach(ISome* p)
    {
        ASSERT(_p == NULL);
        _p = p;
    }

    inline void Detach(void)
    {
        _p = NULL;
    }

    inline ISome * operator-> () { return _p; }

    inline ISome& operator * () { return *_p; }

    inline operator ISome *() { return _p; }

    inline ISome ** operator &()
    {
        ASSERT( _p == NULL );
        return &_p;
    }

    inline ISome *Self(void) { return _p; }

private:

    ISome * _p;

    inline  void operator= (const XSafeInterfacePtr &) {;}

    inline  XSafeInterfacePtr(const XSafeInterfacePtr &){;}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\util.h ===
#include "cstr.h"

HRESULT GUIDToCStr(CStr& str, const GUID& guid);
HRESULT GUIDFromCStr(const CStr& str, GUID* pguid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\strings.h ===
EXTERN_C const TCHAR g_szCLSID[];
EXTERN_C const TCHAR g_szContextMenu[];
EXTERN_C const TCHAR g_szDynamicExtensions[];
EXTERN_C const TCHAR g_szImage[];
EXTERN_C const TCHAR g_szImageOpen[];
EXTERN_C const TCHAR g_szImageClosed[];
EXTERN_C const TCHAR g_szName[];
EXTERN_C const TCHAR g_szNameString[];
EXTERN_C const TCHAR g_szObject[];
EXTERN_C const TCHAR g_szObjects[];
EXTERN_C const TCHAR g_szObjectType[];
EXTERN_C const TCHAR g_szObjectTypes[];
EXTERN_C const TCHAR g_szObjectTypeGUID[];
EXTERN_C const TCHAR g_szObjectContext[];
EXTERN_C const TCHAR g_szPackage[];
EXTERN_C const TCHAR g_szResultPane[];
EXTERN_C const TCHAR g_szStatus[];
EXTERN_C const TCHAR g_szStatusString[];
EXTERN_C const TCHAR g_szTree[];
EXTERN_C const TCHAR g_szNameSpace[];
EXTERN_C const TCHAR g_szNodeType[];
EXTERN_C const TCHAR g_szNodeTypes[];
EXTERN_C const TCHAR g_szPropertySheet[];
EXTERN_C const TCHAR g_szStandAlone[];
EXTERN_C const TCHAR g_szToolbar[];
EXTERN_C const TCHAR g_szExtensions[];


EXTERN_C const TCHAR NODE_TYPES_KEY[];
EXTERN_C const TCHAR SNAPINS_KEY[];
EXTERN_C const TCHAR CURRENT_VER_KEY[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\sources.inc ===
#
# This sources file is included in every sources file for this
#  project

INCLUDES=$(BASE_INCLUDES);  \
         $(SHELL_INC_PATH); \
         $(DS_INC_PATH);    \
         $(NET_INC_PATH);   \
         $(WINDOWS_INC_PATH)

C_DEFINES=  $(C_DEFINES) -DUNICODE -D_UNICODE

USE_NATIVE_EH=1
USE_MSVCRT=1
USE_ATL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\websnk.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Jul 22 18:22:15 1997
 */
/* Compiler settings for websnk.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __websnk_h__
#define __websnk_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWebSink_FWD_DEFINED__
#define __IWebSink_FWD_DEFINED__
typedef interface IWebSink IWebSink;
#endif 	/* __IWebSink_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WebOcx_LIBRARY_DEFINED__
#define __WebOcx_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: WebOcx
 * at Tue Jul 22 18:22:15 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [version][helpstring][uuid] */ 



EXTERN_C const IID LIBID_WebOcx;

#ifndef __IWebSink_INTERFACE_DEFINED__
#define __IWebSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebSink
 * at Tue Jul 22 18:22:15 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][helpstring][uuid] */ 



EXTERN_C const IID IID_IWebSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("734A2304-C927-11cf-ADA7-00AA00A80033")
    IWebSink : public IDispatch
    {
    public:
        virtual /* [id] */ void STDMETHODCALLTYPE BeforeNavigate( 
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *Cancel) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE CommandStateChange( 
            /* [in] */ int Command,
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE DownloadBegin( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE DownloadComplete( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE FrameBeforeNavigate( 
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *Cancel) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE FrameNavigateComplete( 
            /* [in] */ BSTR URL) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE FrameNewWindow( 
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *Processed) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE NavigateComplete( 
            /* [in] */ BSTR URL) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE NewWindow( 
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [in] */ BSTR Referrer) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Progress( 
            /* [in] */ long Progress,
            /* [in] */ long ProgressMax) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PropertyChange( 
            /* [in] */ BSTR szProperty) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Quit( 
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *pCancel) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE StatusTextChange( 
            /* [in] */ BSTR bstrText) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE TitleChange( 
            /* [in] */ BSTR Text) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE WindowActivate( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE WindowMove( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE WindowResize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebSink __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *BeforeNavigate )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *Cancel);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *CommandStateChange )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ int Command,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *DownloadBegin )( 
            IWebSink __RPC_FAR * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *DownloadComplete )( 
            IWebSink __RPC_FAR * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *FrameBeforeNavigate )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *Cancel);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *FrameNavigateComplete )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR URL);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *FrameNewWindow )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *Processed);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *NavigateComplete )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR URL);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR URL,
            /* [in] */ long Flags,
            /* [in] */ BSTR TargetFrameName,
            /* [in] */ VARIANT __RPC_FAR *PostData,
            /* [in] */ BSTR Headers,
            /* [in] */ BSTR Referrer);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *Progress )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ long Progress,
            /* [in] */ long ProgressMax);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *PropertyChange )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR szProperty);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *Quit )( 
            IWebSink __RPC_FAR * This,
            /* [out][in] */ VARIANT_BOOL __RPC_FAR *pCancel);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *StatusTextChange )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR bstrText);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *TitleChange )( 
            IWebSink __RPC_FAR * This,
            /* [in] */ BSTR Text);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *WindowActivate )( 
            IWebSink __RPC_FAR * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *WindowMove )( 
            IWebSink __RPC_FAR * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE __RPC_FAR *WindowResize )( 
            IWebSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWebSinkVtbl;

    interface IWebSink
    {
        CONST_VTBL struct IWebSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebSink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebSink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebSink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebSink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebSink_BeforeNavigate(This,URL,Flags,TargetFrameName,PostData,Headers,Cancel)	\
    (This)->lpVtbl -> BeforeNavigate(This,URL,Flags,TargetFrameName,PostData,Headers,Cancel)

#define IWebSink_CommandStateChange(This,Command,Enable)	\
    (This)->lpVtbl -> CommandStateChange(This,Command,Enable)

#define IWebSink_DownloadBegin(This)	\
    (This)->lpVtbl -> DownloadBegin(This)

#define IWebSink_DownloadComplete(This)	\
    (This)->lpVtbl -> DownloadComplete(This)

#define IWebSink_FrameBeforeNavigate(This,URL,Flags,TargetFrameName,PostData,Headers,Cancel)	\
    (This)->lpVtbl -> FrameBeforeNavigate(This,URL,Flags,TargetFrameName,PostData,Headers,Cancel)

#define IWebSink_FrameNavigateComplete(This,URL)	\
    (This)->lpVtbl -> FrameNavigateComplete(This,URL)

#define IWebSink_FrameNewWindow(This,URL,Flags,TargetFrameName,PostData,Headers,Processed)	\
    (This)->lpVtbl -> FrameNewWindow(This,URL,Flags,TargetFrameName,PostData,Headers,Processed)

#define IWebSink_NavigateComplete(This,URL)	\
    (This)->lpVtbl -> NavigateComplete(This,URL)

#define IWebSink_NewWindow(This,URL,Flags,TargetFrameName,PostData,Headers,Referrer)	\
    (This)->lpVtbl -> NewWindow(This,URL,Flags,TargetFrameName,PostData,Headers,Referrer)

#define IWebSink_Progress(This,Progress,ProgressMax)	\
    (This)->lpVtbl -> Progress(This,Progress,ProgressMax)

#define IWebSink_PropertyChange(This,szProperty)	\
    (This)->lpVtbl -> PropertyChange(This,szProperty)

#define IWebSink_Quit(This,pCancel)	\
    (This)->lpVtbl -> Quit(This,pCancel)

#define IWebSink_StatusTextChange(This,bstrText)	\
    (This)->lpVtbl -> StatusTextChange(This,bstrText)

#define IWebSink_TitleChange(This,Text)	\
    (This)->lpVtbl -> TitleChange(This,Text)

#define IWebSink_WindowActivate(This)	\
    (This)->lpVtbl -> WindowActivate(This)

#define IWebSink_WindowMove(This)	\
    (This)->lpVtbl -> WindowMove(This)

#define IWebSink_WindowResize(This)	\
    (This)->lpVtbl -> WindowResize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ void STDMETHODCALLTYPE IWebSink_BeforeNavigate_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ long Flags,
    /* [in] */ BSTR TargetFrameName,
    /* [in] */ VARIANT __RPC_FAR *PostData,
    /* [in] */ BSTR Headers,
    /* [out][in] */ VARIANT_BOOL __RPC_FAR *Cancel);


void __RPC_STUB IWebSink_BeforeNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_CommandStateChange_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ int Command,
    /* [in] */ VARIANT_BOOL Enable);


void __RPC_STUB IWebSink_CommandStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_DownloadBegin_Proxy( 
    IWebSink __RPC_FAR * This);


void __RPC_STUB IWebSink_DownloadBegin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_DownloadComplete_Proxy( 
    IWebSink __RPC_FAR * This);


void __RPC_STUB IWebSink_DownloadComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_FrameBeforeNavigate_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ long Flags,
    /* [in] */ BSTR TargetFrameName,
    /* [in] */ VARIANT __RPC_FAR *PostData,
    /* [in] */ BSTR Headers,
    /* [out][in] */ VARIANT_BOOL __RPC_FAR *Cancel);


void __RPC_STUB IWebSink_FrameBeforeNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_FrameNavigateComplete_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR URL);


void __RPC_STUB IWebSink_FrameNavigateComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_FrameNewWindow_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ long Flags,
    /* [in] */ BSTR TargetFrameName,
    /* [in] */ VARIANT __RPC_FAR *PostData,
    /* [in] */ BSTR Headers,
    /* [out][in] */ VARIANT_BOOL __RPC_FAR *Processed);


void __RPC_STUB IWebSink_FrameNewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_NavigateComplete_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR URL);


void __RPC_STUB IWebSink_NavigateComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_NewWindow_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR URL,
    /* [in] */ long Flags,
    /* [in] */ BSTR TargetFrameName,
    /* [in] */ VARIANT __RPC_FAR *PostData,
    /* [in] */ BSTR Headers,
    /* [in] */ BSTR Referrer);


void __RPC_STUB IWebSink_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_Progress_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ long Progress,
    /* [in] */ long ProgressMax);


void __RPC_STUB IWebSink_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_PropertyChange_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR szProperty);


void __RPC_STUB IWebSink_PropertyChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_Quit_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [out][in] */ VARIANT_BOOL __RPC_FAR *pCancel);


void __RPC_STUB IWebSink_Quit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_StatusTextChange_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR bstrText);


void __RPC_STUB IWebSink_StatusTextChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_TitleChange_Proxy( 
    IWebSink __RPC_FAR * This,
    /* [in] */ BSTR Text);


void __RPC_STUB IWebSink_TitleChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_WindowActivate_Proxy( 
    IWebSink __RPC_FAR * This);


void __RPC_STUB IWebSink_WindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_WindowMove_Proxy( 
    IWebSink __RPC_FAR * This);


void __RPC_STUB IWebSink_WindowMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ void STDMETHODCALLTYPE IWebSink_WindowResize_Proxy( 
    IWebSink __RPC_FAR * This);


void __RPC_STUB IWebSink_WindowResize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebSink_INTERFACE_DEFINED__ */

#endif /* __WebOcx_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\dfsdebug.h ===
#ifndef _DFSDEBUG_H_
#define _DFSDEBUG_H_

#ifdef DEBUG

#include <stdio.h>
#include <stdarg.h>

#define DECLARE_INFOLEVEL(comp) \
        extern unsigned long comp##InfoLevel = DEF_INFOLEVEL;

#define DECLARE_DEBUG(comp) \
    extern unsigned long comp##InfoLevel; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, TCHAR *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            TCHAR acsString[1000];\
            va_list va; \
            va_start(va, pszfmt);\
            _vstprintf(acsString, pszfmt, va); \
            va_end(va);\
            OutputDebugString(acsString);\
        } \
    }\
    _inline void \
    comp##InlineDebugOut( TCHAR *pszfmt, ...) \
    { \
        if ( TRUE ) \
        { \
            TCHAR acsString[1000];\
            va_list va; \
            va_start(va, pszfmt);\
            _vstprintf(acsString, pszfmt, va); \
            va_end(va);\
            OutputDebugString(acsString);\
        } \
    }

#else  // DEBUG

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DEBUG

DECLARE_DEBUG(dfs);

#ifdef DEBUG
    #define dfsDebugOut( x ) dfsInlineDebugOut x
#else  // DEBUG
    #define dfsDebugOut( x ) ((void)0)
#endif // DEBUG

int
mylstrncmp(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
);

int
mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
);

#define PROPSTRNOCHNG(str1, str2)   (str1 && str2 && !lstrcmpi(str1, str2) || \
                                    !str1 && str2 && !*str2 || \
                                     str1 && !*str1 && !str2 || \
                                    !str1 && !str2)

#define RETURN_OUTOFMEMORY_IF_NULL(ptr)         if (NULL == (ptr)) return E_OUTOFMEMORY
#define BREAK_OUTOFMEMORY_IF_NULL(ptr, phr)     if (NULL == (ptr)) { *phr = E_OUTOFMEMORY; break; }
#define RETURN_INVALIDARG_IF_TRUE(bVal)         if (bVal) return E_INVALIDARG
#define RETURN_INVALIDARG_IF_NULL(ptr)          if (NULL == (ptr)) return E_INVALIDARG
#define RETURN_IF_FAILED(hr)                    if (FAILED(hr)) return (hr)
#define BREAK_IF_FAILED(hr)                     if (FAILED(hr)) break
#define RETURN_IF_NOT_S_OK(hr)                  if (S_OK != hr) return (hr)
#define BREAK_IF_NOT_S_OK(hr)                   if (S_OK != hr) break

#define GET_BSTR(i_ccombstr, o_pbstr)       \
    RETURN_INVALIDARG_IF_NULL(o_pbstr);    \
	*o_pbstr = i_ccombstr.Copy();           \
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstr);   \
    return S_OK

#endif // _DFSDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\corecopy\util.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       util.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7/8/1996   RaviR   Created
//
//____________________________________________________________________________

#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"
#include <Atlbase.h>
#include <winnls.h>

//+---------------------------------------------------------------------------
//
//  Function:   GUIDToString
//              GUIDFromString
//
//  Synopsis:   Converts between GUID& and CStr
//
//  Returns:    FALSE for invalid string, or CMemoryException
//
//+---------------------------------------------------------------------------

HRESULT GUIDToCStr(CStr& str, const GUID& guid)
{
	LPOLESTR lpolestr = NULL;
	HRESULT hr = StringFromIID( guid, &lpolestr );
    if (FAILED(hr))
	{
		TRACE("GUIDToString error %ld\n", hr);
		return hr;
	}
	else
	{
		str = lpolestr;
		CoTaskMemFree(lpolestr);
	}
	return hr;
}

HRESULT GUIDFromCStr(const CStr& str, GUID* pguid)
{
	USES_CONVERSION;

	HRESULT hr = IIDFromString( T2OLE( const_cast<LPTSTR>((LPCTSTR)str) ), pguid );
    if (FAILED(hr))
	{
		TRACE("GUIDFromString error %ld\n", hr);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\dfsenums.h ===
#ifndef _DFS_ENUMS_H
#define _DFS_ENUMS_H

#define WM_PARENT_NODE_CLOSING  (WM_USER + 1)

//Snapin Object Type Enums
enum SNAPIN_OBJECTS_TYPE
{
	CTX_DFS_UNASSIGNED = 0,
	CTX_DFS_SNAPIN_NODE,	
	CTX_DFS_ROOT,      
	CTX_DFS_JUNCTION_POINT,	
	CTX_DFS_REPLICA		
};

//Dfs Root State Enums
enum DFS_STATE {				DFS_STATE_REACHABLE = 0,
						DFS_STATE_UNREACHABLE
					};

//Dfs Root Type Enums
enum DFS_TYPE	{	DFS_TYPE_UNASSIGNED = 0, 
					DFS_TYPE_FTDFS,
					DFS_TYPE_STANDALONE
				};



//Dfs JunctionPoint State Enums
enum DFS_JUNCTION_STATE {	DFS_JUNCTION_STATE_UNASSIGNED = 0,
							DFS_JUNCTION_STATE_ALL_REP_OK,
							DFS_JUNCTION_STATE_NOT_ALL_REP_OK,
							DFS_JUNCTION_STATE_UNREACHABLE
						};

//Dfs Junction Type Enums
enum DFS_JUNCTION_TYPE  {	DFS_JUNCTION_TYPE_UNASSIGNED = 0,
							DFS_JUNCTION_TYPE_LEAF,
							DFS_JUNCTION_INTER_DFS
						};


//Dfs Replica State Enums
enum DFS_REPLICA_STATE	{	DFS_REPLICA_STATE_UNASSIGNED = 0,
							DFS_REPLICA_STATE_ONLINE,
							DFS_REPLICA_STATE_OFFLINE,
							DFS_REPLICA_STATE_UNREACHABLE
						};

enum FILTERDFSLINKS_TYPE {
        FILTERDFSLINKS_TYPE_NO_FILTER = 0,
        FILTERDFSLINKS_TYPE_BEGINWITH,
        FILTERDFSLINKS_TYPE_CONTAIN
};

#define FILTERDFSLINKS_MAXLIMIT_DEFAULT		100

#define KEYTWORDS_UPPER_RANGER          256
#define DNSNAMELIMIT                    2048   // as defined in AD schema UpperRange for dnsHostName

#define ATTR_SCHEMANAMINGCONTEXT        _T("schemaNamingContext")
#define DN_PREFIX_SCHEMA_REPLICASET     _T("CN=NTFRS-Replica-Set,")

#define FRS_STAGE_PATH                  _T("Frs-Staging")

enum FRSSHARE_TYPE
{
    FRSSHARE_TYPE_OK = 0,
    FRSSHARE_TYPE_NONTFRS,
    FRSSHARE_TYPE_NOTDISKTREE,
    FRSSHARE_TYPE_NOTNTFS,
    FRSSHARE_TYPE_CONFLICTSTAGING,
    FRSSHARE_TYPE_NODOMAIN,
    FRSSHARE_TYPE_NOTSMBDISK,
    FRSSHARE_TYPE_OVERLAPPING,
    FRSSHARE_TYPE_UNKNOWN
};

//
// replica set types
//
#define FRS_RSTYPE_ENTERPRISE_SYSVOL    _T("1")
#define FRS_RSTYPE_DOMAIN_SYSVOL        _T("2")
#define FRS_RSTYPE_DFS                  _T("3")
#define FRS_RSTYPE_OTHER                _T("4")

//
// replica set topology preference
//
#define FRS_RSTOPOLOGYPREF_RING         _T("1")
#define FRS_RSTOPOLOGYPREF_HUBSPOKE     _T("2")
#define FRS_RSTOPOLOGYPREF_FULLMESH     _T("3")
#define FRS_RSTOPOLOGYPREF_CUSTOM       _T("4")

//
// enabledConnection values
//
#define CONNECTION_ENABLED_TRUE         _T("TRUE")
#define CONNECTION_ENABLED_FALSE        _T("FALSE")

//
// FRS attribute names
//
#define ATTR_OBJCLASS                           _T("objectClass")
#define ATTR_DNSHOSTNAME                        _T("dNSHostName")
#define ATTR_OBJECTGUID                         _T("objectGUID")
#define ATTR_DISTINGUISHEDNAME                  _T("distinguishedName")
#define ATTR_SYSTEMMAYCONTAIN                   _T("systemMayContain")

#define ATTR_FRS_REPSET_TYPE                    _T("fRSReplicaSetType")
#define ATTR_FRS_REPSET_TOPOLOGYPREF            _T("msFRS-Topology-Pref")
#define ATTR_FRS_REPSET_HUBSERVER               _T("msFRS-Hub-Member")
#define ATTR_FRS_REPSET_PRIMARYMEMBER           _T("fRSPrimaryMember")
#define ATTR_FRS_REPSET_FILEFILTER              _T("fRSFileFilter")
#define ATTR_FRS_REPSET_DIRFILTER               _T("fRSDirectoryFilter")

#define ATTR_FRS_MEMBER_COMPUTERREF             _T("frsComputerReference")

#define ATTR_NTDS_CONNECTION_FROMSERVER         _T("fromServer")
#define ATTR_NTDS_CONNECTION_ENABLEDCONNECTION  _T("enabledConnection")
#define ATTR_NTDS_CONNECTION_OPTIONS            _T("options")
#define ATTR_NTDS_CONNECTION_SCHEDULE           _T("schedule")

#define ATTR_FRS_SUBSCRIBER_MEMBERREF           _T("fRSMemberReference")
#define ATTR_FRS_SUBSCRIBER_ROOTPATH            _T("fRSRootPath")
#define ATTR_FRS_SUBSCRIBER_STAGINGPATH         _T("fRSStagingPath")

#define ATTR_SHRPUB_UNCNAME                     _T("uNCName")
#define ATTR_SHRPUB_DESCRIPTION                 _T("description")
#define ATTR_SHRPUB_KEYWORDS                    _T("keywords")
#define ATTR_SHRPUB_MANAGEDBY                   _T("managedBy")

//
// values for objectClass
//
#define OBJCLASS_NTFRSSETTINGS          _T("nTFRSSettings")
#define OBJCLASS_NTFRSREPLICASET        _T("nTFRSReplicaSet")
#define OBJCLASS_NTFRSMEMBER            _T("nTFRSMember")
#define OBJCLASS_NTDSCONNECTION         _T("nTDSConnection")
#define OBJCLASS_NTFRSSUBSCRIPTIONS     _T("nTFRSSubscriptions")
#define OBJCLASS_NTFRSSUBSCRIBER        _T("nTFRSSubscriber")
#define OBJCLASS_VOLUME                 _T("volume")

//
// search filter on objectClass
//
#define OBJCLASS_SF_ALL                     _T("(objectClass=*)")
#define OBJCLASS_SF_CLASSSCHEMA             _T("(objectCategory=classSchema)")
#define OBJCLASS_SF_COMPUTER                _T("(objectCategory=computer)")
#define OBJCLASS_SF_NTFRSSETTINGS           _T("(objectCategory=nTFRSSettings)")
#define OBJCLASS_SF_NTFRSREPLICASET         _T("(objectCategory=nTFRSReplicaSet)")
#define OBJCLASS_SF_NTFRSMEMBER             _T("(objectCategory=nTFRSMember)")
#define OBJCLASS_SF_NTDSCONNECTION          _T("(objectCategory=nTDSConnection)")
#define OBJCLASS_SF_NTFRSSUBSCRIPTIONS      _T("(objectCategory=nTFRSSubscriptions)")
#define OBJCLASS_SF_NTFRSSUBSCRIBER         _T("(objectCategory=nTFRSSubscriber)")
#define OBJCLASS_SF_FTDFS                   _T("(objectCategory=fTDfs)")
#define OBJCLASS_SF_VOLUME                  _T("(objectCategory=volume)")

#define DEFAULT_FILEFILTER                  _T("*.bak,*.tmp,~*")
#define DEFAULT_CONNECTION_OPTIONS          _T("0")

#define NUM_OF_FRSMEMBER_ATTRS          9
#define NUM_OF_FRSCONNECTION_ATTRS      4

enum CONNECTION_OPTYPE {
        CONNECTION_OPTYPE_OTHERS = 0,
        CONNECTION_OPTYPE_ADD,
        CONNECTION_OPTYPE_DEL
};

#endif //_DFS_ENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\ldaputils.cpp ===
/*++
Module Name:

LDAPUtils.h

Abstract:
  This is the header file for the LDAP utility functions.

*/
//--------------------------------------------------------------------

#include <stdafx.h>
#include "LDAPUtils.h"
#include <dsgetdc.h>
#include <stdio.h>
#include <ntdsapi.h>
#include <lm.h>
#include <ntldap.h>
#include <winber.h>
#include "dfsenums.h"
#include "netutils.h"

//----------------------------------------------------------------------------------
HRESULT FreeLDAPNamesList
(
  IN PLDAPNAME    i_pLDAPNames        // pointer to list to be freed.
)
{
/*++

Routine Description:

  Helper funciton used to free the NETNAME linked list retrurned by 
    LDAP helper functions.

Arguments:

  i_pLDAPNames - Pointer to the first node in the list to be freed.


Return value:

    S_OK, on Success.
  E_POINTER, Illegal pointer was passed.

--*/

  PLDAPNAME   pNodeToFree = NULL;
  try
  {
    while (NULL != i_pLDAPNames)      
    {                    
      pNodeToFree  = i_pLDAPNames;
      i_pLDAPNames = i_pLDAPNames->Next;
      delete pNodeToFree;
    }
  }  //  try
  catch (...)
  {
    return E_POINTER;
  }
  return S_OK;
}  //  HRESULT FreeDomainList



HRESULT FreeAttrValList
(
  IN PLDAP_ATTR_VALUE    i_pAttrVals        
)
{
/*++

Routine Description:

  Helper funciton used to free the LDAP_ATTR_VALUE linked list retrurned by 
    LDAP helper functions.

Arguments:

  i_pLDAPNames - Pointer to the first node in the list to be freed.


Return value:

    S_OK, on Success.
  E_POINTER, Illegal pointer was passed.

--*/

  PLDAP_ATTR_VALUE   pNodeToFree = NULL;
  try
  {
    while (NULL != i_pAttrVals)      
    {                    
      pNodeToFree  = i_pAttrVals;
      i_pAttrVals = i_pAttrVals->Next;
      if (NULL != pNodeToFree->vpValue)
      {
        free(pNodeToFree->vpValue);
      }
      delete pNodeToFree;
    }
  }  //  try
  catch (...)
  {
    return E_POINTER;
  }
  return S_OK;
}


//----------------------------------------------------------------------------------
HRESULT ConnectToDS
(
  IN  PCTSTR    i_lpszDomainName,  // DNS or non DNS format.
  OUT PLDAP    *o_ppldap,
  OUT BSTR*     o_pbstrDC // = NULL
)
{
/*++

Routine Description:

  Opens an LDAP connection to a valid DC (DC re-fetched if down).

Arguments:

  i_lpszDomainName - Name of the domain, DNS or Non Dns format.
  
  o_ppldap     - Pointer to LDAP handle in returned here.
             NULL on failure.

Return value:

    S_OK, on Success.
  E_INVALIDARG, Illegal pointer was passed.
  E_FAIL, if connection could not be established.
  Any Other error code returned by ldap or Net apis.

--*/

    RETURN_INVALIDARG_IF_NULL(o_ppldap);

    *o_ppldap = NULL;

    //
    // open a ldap connection to a valid DC
    //
    HRESULT     hr = S_OK;
    DWORD       dwErr = 0; 
    CComBSTR    bstrDCName;
    PLDAP       pldap = NULL;
    BOOL        bRetry = FALSE;
    do {
#ifdef DEBUG
        SYSTEMTIME time0 = {0};
        GetSystemTime(&time0);
#endif // DEBUG

        //
        // pick a DC
        //
        PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
        if (bRetry)
            dwErr = DsGetDcName(NULL, i_lpszDomainName, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, &pDCInfo);
        else
            dwErr = DsGetDcName(NULL, i_lpszDomainName, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
        SYSTEMTIME time1 = {0};
        GetSystemTime(&time1);
        PrintTimeDelta(_T("ConnectToDS-DsGetDcName"), &time0, &time1);
#endif // DEBUG

        if (ERROR_SUCCESS != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

        if ( !mylstrncmpi(pDCInfo->DomainControllerName, _T("\\\\"), 2) )
            bstrDCName = pDCInfo->DomainControllerName + 2;
        else
            bstrDCName = pDCInfo->DomainControllerName;
    
        NetApiBufferFree(pDCInfo);

        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDCName, &hr);

        //
        // make ldap connection to this DC
        //
        pldap = ldap_init(bstrDCName, LDAP_PORT);
        if (!pldap)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Making ldap_open/ldap_connect with a server name without first setting 
        // LDAP_OPT_AREC_EXCLUSIVE (for ldap interfaces) or 
        // ADS_SERVER_BIND (for ADSI interfaces) will result in bogus DNS queries 
        // consuming bandwidth and potentially bringing up remote links that are 
        // costly or demand dial.
        //
        // ignore the return of ldap_set_option
        ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

        ULONG ulRet = ldap_connect(pldap, NULL); // NULL for the default timeout

#ifdef DEBUG
        SYSTEMTIME time2 = {0};
        GetSystemTime(&time2);
        PrintTimeDelta(_T("ConnectToDS-ldap_connect"), &time1, &time2);
#endif // DEBUG

        if (LDAP_SERVER_DOWN == ulRet && !bRetry)
        {
            ldap_unbind(pldap);
            bRetry = TRUE; // retry once to pick another DC
        } else
        {
             if (LDAP_SUCCESS != ulRet)
             {
                ldap_unbind(pldap);
                hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ulRet));
             }

             break;
        }
    } while (1);

    RETURN_IF_FAILED(hr);

    //
    // bind to this ldap connection
    //
    dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (LDAP_SUCCESS != dwErr) 
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        DebugOutLDAPError(pldap, dwErr, _T("ldap_bind_s"));
        ldap_unbind(pldap);
        hr = HRESULT_FROM_WIN32(dwErr);
    } else
    {
        *o_ppldap = pldap;

        if (o_pbstrDC)
        {
            *o_pbstrDC = bstrDCName.Copy();
            if (!*o_pbstrDC)
            {
                ldap_unbind(pldap);
                *o_ppldap = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}



HRESULT CloseConnectionToDS
(
  IN PLDAP    i_pldap      
)
{
/*++

Routine Description:

  Closes an open LDAP connection.

Arguments:

  i_pldap - Open LDAP connection handle.

Return value:

    S_OK, on Success.
  E_FAIL, if connection could not be established.
  Any Other error code returned by ldap or Net apis.

--*/

  if (NULL == i_pldap)
  {
    return(E_INVALIDARG);
  }

  DWORD dwErr = ldap_unbind(i_pldap);
  if (LDAP_SUCCESS != dwErr) 
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    return(HRESULT_FROM_WIN32(dwErr));
  }
  else
  {
    return(S_OK);
  }
}


      // Gets Values for an attribute from an LDAP Object.
HRESULT GetValues 
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_lpszBase,
    IN PCTSTR               i_lpszSearchFilter,
    IN ULONG                i_ulScope,
    IN ULONG                i_ulAttrCount,
    IN LDAP_ATTR_VALUE      i_pAttributes[],
    OUT PLDAP_ATTR_VALUE    o_ppValues[]
)
{

/*++
Routine Description:

    Gets Values for an attribute from an LDAP Object given Object class.
  Object Class can be "*" etc.

Arguments:

    i_pldap        - An open, bound ldap port.
    i_lpszBase      - The base path of a DS object, can be "".
  i_lpszSearchFilter  - LDAP Search Filter.
  i_ulScope      - The search scope.
  i_ulAttrCount    - Count of attributes passed in i_lpszAttributes.
    i_pAttributes    - Attributes for which to get values. The bBerValue has to be set.
  o_ppValues      - Array of pointers, size = i_ulAttrCount, each pointer to a list
              of values corresponding to the respective attribute in i_pAttributes.
              The bstrAttribute is not set for values. For BerVal types the
              bBerValue and ulLength are set.

Return Value:

    S_OK, on Success.
  E_INVALIDARG, Illegal pointer was passed.
  E_OUTOFMEMORY on memory allocation failure.
  E_FAIL, if connection could not be established.
  Any Other error code returned by ldap or Net apis.
    
  
--*/
  DWORD           dwErr;      
  LPTSTR          lpszCurrentAttr = NULL;   
  BerElement      *BerElm = NULL;       
  PLDAPMessage    pMsg = NULL;       
  PLDAPMessage    pEntry = NULL;     
  HRESULT         hr = S_OK;

  if (!i_pldap ||
      !i_lpszBase || 
      !i_lpszSearchFilter ||
      (i_ulAttrCount < 1) ||
      !i_pAttributes ||
      !o_ppValues)
  {
    return(E_INVALIDARG);
  }

                // Prepare the list of attributes to be sent to ldap_search.
  LPTSTR *lpszAttributes = new LPTSTR[i_ulAttrCount + 1];
  if (!lpszAttributes)
    return E_OUTOFMEMORY;

  lpszAttributes[i_ulAttrCount] = NULL;
  for (ULONG i = 0; i < i_ulAttrCount; i++)
    lpszAttributes[i] = i_pAttributes[i].bstrAttribute;

                // Execute the search.
  dwErr = ldap_search_s  (i_pldap, 
            (PTSTR)i_lpszBase, 
            i_ulScope,
            (PTSTR)i_lpszSearchFilter, 
            lpszAttributes, 
            0, 
            &pMsg
            );
  delete [] lpszAttributes;

  if (LDAP_SUCCESS != dwErr) 
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
    hr = HRESULT_FROM_WIN32(dwErr);
  } else
  {
    LPTSTR lpszCurrentAttr = ldap_first_attribute(i_pldap, pMsg, &BerElm);
    if (!lpszCurrentAttr)
    {
      dfsDebugOut((_T("GetValues of %s returned NULL attributes.\n"), i_lpszBase));
      hr = HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED);
    } else
    {
                // For each attribute, build a list of values 
                // by scanning each entry for the given attribute.
      for (i = 0; i < i_ulAttrCount && SUCCEEDED(hr); i++)
      {
        PLDAP_ATTR_VALUE  *ppCurrent = &(o_ppValues[i]);

                    // Scan each attribute of the entry for an exact match
        for(lpszCurrentAttr = ldap_first_attribute(i_pldap, pMsg, &BerElm);
          lpszCurrentAttr != NULL && SUCCEEDED(hr);
          lpszCurrentAttr = ldap_next_attribute(i_pldap, pMsg, BerElm))
        {
                  // Is there a match?
          if (0 == lstrcmpi(i_pAttributes[i].bstrAttribute, lpszCurrentAttr)) 
          {
                  // Add the value to the linked list for this attribute.
            LPTSTR      *lpszCurrentValue = NULL, *templpszValue = NULL;
            LDAP_BERVAL    **ppBerVal = NULL, **tempBerVal = NULL;

            if (i_pAttributes[i].bBerValue)
            {
              tempBerVal = ppBerVal =  ldap_get_values_len(i_pldap, pMsg, lpszCurrentAttr);
              while(*ppBerVal && SUCCEEDED(hr))
              {
                *ppCurrent = new LDAP_ATTR_VALUE;
                if (!*ppCurrent)
                {
                   hr = E_OUTOFMEMORY;
                } else
                {
                  (*ppCurrent)->ulLength = (*ppBerVal)->bv_len;
                  (*ppCurrent)->bBerValue = true;
                  (*ppCurrent)->vpValue = malloc((*ppBerVal)->bv_len);
              
                  if (!(*ppCurrent)->vpValue)
                  {
                    delete *ppCurrent;
                    hr = E_OUTOFMEMORY;
                  } else
                  {
                    memcpy(
                        (*ppCurrent)->vpValue,
                        (void *)(*ppBerVal)->bv_val,
                        (*ppBerVal)->bv_len
                        );

                    (*ppCurrent)->Next = NULL;

                    ppBerVal++;
                    ppCurrent = &((*ppCurrent)->Next);
                  }
                }
              } // while
              if (NULL != tempBerVal)
                ldap_value_free_len(tempBerVal);
            }
            else
            {
              templpszValue = lpszCurrentValue = ldap_get_values(i_pldap, pMsg, lpszCurrentAttr);
              while(*lpszCurrentValue && SUCCEEDED(hr))
              {
                *ppCurrent = new LDAP_ATTR_VALUE;
                if (NULL == *ppCurrent)
                {
                  hr = E_OUTOFMEMORY;
                } else
                {
                  (*ppCurrent)->bBerValue = false;
                  (*ppCurrent)->vpValue = (void *)_tcsdup(*lpszCurrentValue);
                  (*ppCurrent)->Next = NULL;

                  if (NULL == (*ppCurrent)->vpValue)
                  {
                    delete *ppCurrent;
                    hr = E_OUTOFMEMORY;
                  } else
                  {
                    lpszCurrentValue++;
                    ppCurrent = &((*ppCurrent)->Next);
                  }
                }
              } // while
              if (NULL != templpszValue)
                ldap_value_free(templpszValue);
            }              
          }
        }
      }
    }
  }

  // free pMsg because ldap_search_s always allocates pMsg
  if (pMsg)
    ldap_msgfree(pMsg);

  if (FAILED(hr))
  {
    for (i = 0; i < i_ulAttrCount; i++)
      FreeAttrValList(o_ppValues[i]);
  }

  return hr;
}

void FreeLListElem(LListElem* pElem)
{
    LListElem* pCurElem = NULL;
    LListElem* pNextElem = pElem;

    while (pCurElem = pNextElem)
    {
        pNextElem = pCurElem->Next;
        delete pCurElem;
    }
}

HRESULT GetValuesEx
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_pszBase,
    IN ULONG                i_ulScope,
    IN PCTSTR               i_pszSearchFilter,
    IN PCTSTR               i_pszAttributes[],
    OUT LListElem**         o_ppElem
)
{
    if (!i_pldap ||
        !i_pszBase || 
        !i_pszSearchFilter ||
        !i_pszAttributes ||
        !o_ppElem)
    {
        return(E_INVALIDARG);
    }

    *o_ppElem = NULL;

    //
    // count number of attributes
    //
    ULONG   ulNumOfAttributes = 0;
    PTSTR*  ppszAttr = (PTSTR *)i_pszAttributes;
    while (*ppszAttr++)
        ulNumOfAttributes++;
    if (!ulNumOfAttributes)
        return E_INVALIDARG;

    HRESULT         hr = S_OK;
    PLDAPMessage    pMsg = NULL;       
    DWORD           dwErr = ldap_search_s(i_pldap, 
                                (PTSTR)i_pszBase, 
                                i_ulScope,
                                (PTSTR)i_pszSearchFilter, 
                                (PTSTR *)i_pszAttributes, 
                                0, 
                                &pMsg
                                );

    if (LDAP_SUCCESS != dwErr) 
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
        hr = HRESULT_FROM_WIN32(dwErr);
    } else
    {
        PLDAPMessage    pMsgEntry = NULL;     
        BerElement*     pBerElm = NULL;       
        PTSTR           pszCurrentAttr = NULL;   
        LListElem*      pHeadElem = NULL;
        LListElem*      pCurElem = NULL;

        // Scan each entry to find the value set for the DN attribute.
        for(pMsgEntry = ldap_first_entry(i_pldap, pMsg); pMsgEntry; pMsgEntry = ldap_next_entry(i_pldap, pMsgEntry)) 
        {
            PTSTR** pppszValueArray = (PTSTR **)calloc(ulNumOfAttributes + 1, sizeof(PTSTR **));
            BREAK_OUTOFMEMORY_IF_NULL(pppszValueArray, &hr);

            // Read each attribute of the entry into the array
            for(pszCurrentAttr = ldap_first_attribute(i_pldap, pMsgEntry, &pBerElm); pszCurrentAttr; pszCurrentAttr = ldap_next_attribute(i_pldap, pMsgEntry, pBerElm))
            {
                PTSTR* ppszValues = ldap_get_values(i_pldap, pMsgEntry, pszCurrentAttr);

                for (ULONG i = 0; i < ulNumOfAttributes; i++)
                {
                    if (!lstrcmpi(i_pszAttributes[i], pszCurrentAttr))
                    {
                        pppszValueArray[i] = ppszValues;
                        break;
                    }
                }
            } // end of attribute enumeration

            LListElem* pNewElem = new LListElem(pppszValueArray);
            if (!pNewElem)
            {
                free(pppszValueArray);
                hr = E_OUTOFMEMORY;
                break;
            }

            if (!pCurElem)
            {
                pHeadElem = pCurElem = pNewElem;
            } else
            {
                pCurElem->Next = pNewElem;
                pCurElem = pNewElem;
            }
        } // end of entry enumeration

        if (FAILED(hr))
            FreeLListElem(pHeadElem);
        else
            *o_ppElem = pHeadElem;
    }

    // free pMsg because ldap_search_s always allocates pMsg
    if (pMsg)
        ldap_msgfree(pMsg);

    return hr;
}

HRESULT GetLDAPRootPath
(
    IN PLDAP    i_pldap,
    OUT LPTSTR*    o_ppszRootPath
)
/*++
Routine Description:

    Return the DS pathname of the global configuration container.
  
Arguments:

    pldap      - An open and bound ldap handle.
  
  lpszRootPath  - The LDAP path us returned here.

Return Value:
  
  S_OK on success.
  E_FAIL on failure.
  E_OUTOFMEORY if memory allocation fails.
  E_INVALIDARG if null pointer arguments were passed.

--*/
{
    LPTSTR        *ppszValues = NULL;
    PLDAP_ATTR_VALUE pDNName[1] = {0};
    PLDAP_ATTR_VALUE pCurrent = NULL;
  
  
  if (NULL == i_pldap || NULL == o_ppszRootPath)
  {
    return(E_INVALIDARG);
  }

  LPTSTR        lpszCoDN = NULL;

  *o_ppszRootPath = NULL;

  LDAP_ATTR_VALUE  pAttributes[1];

  pAttributes[0].bstrAttribute = _T("namingContexts");
  pAttributes[0].bBerValue = false;
  
  HRESULT hr = GetValues(  i_pldap, 
            _T(""),        // LDAP Root.
            OBJCLASS_SF_ALL,      // All Objects
            LDAP_SCOPE_BASE,
            1,          // Only 1 attribute
            pAttributes,    // namingContexts Attribute.
            pDNName        // List of all values at Root for namingContexts.
            );

  if (FAILED(hr))
    return(hr);

                // Find the naming context that begins with CN=Configuration

  pCurrent = pDNName[0];
  while (pCurrent)
  {
    if (0 == mylstrncmpi((LPTSTR)pCurrent->vpValue, _T("DC="), 3))
    {
      *o_ppszRootPath= _tcsdup((LPTSTR)pCurrent->vpValue);
      hr = (*o_ppszRootPath) ? S_OK : E_OUTOFMEMORY;

      break;
    }
    pCurrent = pCurrent->Next;
  }
  FreeAttrValList(pDNName[0]);

  return(hr);
}


HRESULT GetChildrenDN
(
    IN PLDAP        i_pldap,
    IN LPCTSTR      i_lpszBase,
    IN ULONG        i_ulScope,
    IN LPTSTR       i_lpszChildObjectClassSF,
    OUT PLDAPNAME*  o_ppDistNames
)
/*++
Routine Description:
    
  Return the Distinguished Name of all children of a given objectClass
  as a linked list of LDAPNAME structures.
  
Arguments:
    
  pldap          - An open and bound ldap handle.

    i_lpszBase        - The base path of a DS object, can be "".

  o_ppDistNames      - The linked of child DNs is returned here.

    i_lpszChildObjectClassSF  - The objectClass of the children to list.
                E.g fTDfs, User.

Return Value:
  
  S_OK on success.
  E_FAIL on failure.
  E_OUTOFMEORY if memory allocation fails.
  E_INVALIDARG if null pointer arguments were passed.

--*/
{

  DWORD           dwErr;      
  LPTSTR          lpszCurrentAttr = NULL;   
  LPTSTR      *plpszValues  = NULL;
  BerElement      *BerElm = NULL;       
  PLDAPMessage    pMsg = NULL; 
  PLDAPMessage    pEntry = NULL;     
  PLDAPNAME    *ppCurrent;
  HRESULT      hr = S_OK;

  if (!i_pldap || !i_lpszBase || !o_ppDistNames ||
    !i_lpszChildObjectClassSF || !*i_lpszChildObjectClassSF)
  {
    return(E_INVALIDARG);
  }

  *o_ppDistNames = NULL;
  ppCurrent = o_ppDistNames;

  LPTSTR lpszAttributes[2] = {0,0};
  lpszAttributes[0] = _T("distinguishedName");

                // Execute the search.
  dwErr = ldap_search_s  (i_pldap, 
            (LPTSTR)i_lpszBase, 
            i_ulScope,
            i_lpszChildObjectClassSF, 
            lpszAttributes, 
            0, 
            &pMsg
            );
  if (LDAP_SUCCESS != dwErr)
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
    hr = HRESULT_FROM_WIN32(dwErr);
  } else
  {
                // Scan each entry to find the value set for the DN attribute.
    for(pEntry = ldap_first_entry(i_pldap, pMsg);
      pEntry != NULL;
      pEntry = ldap_next_entry(i_pldap, pEntry)) 
    {
      CComBSTR bstrCN;

                  // Scan each attribute of the entry for DN
      for(lpszCurrentAttr = ldap_first_attribute(i_pldap, pEntry, &BerElm);
          lpszCurrentAttr != NULL;
          lpszCurrentAttr = ldap_next_attribute(i_pldap, pEntry, BerElm))
      {

        plpszValues = ldap_get_values(  i_pldap, 
                        pEntry, 
                        lpszCurrentAttr
                       );
                // Is there a match for CN?
        if (0 == lstrcmpi(_T("distinguishedName"), lpszCurrentAttr)) 
        {
          bstrCN = plpszValues[0];
        }    
      }

                // LDAP object does not have valid fields.
      if (!bstrCN)
        continue;

      // Add to list.

      *ppCurrent = new LDAPNAME;
      if (NULL == *ppCurrent)
      {
        hr = E_OUTOFMEMORY;
        break;
      }

      (*ppCurrent)->Next = NULL;
      (*ppCurrent)->bstrLDAPName = bstrCN.m_str;

      if (!(*ppCurrent)->bstrLDAPName)
      {
        delete *ppCurrent;
        *ppCurrent = NULL;
        hr = E_OUTOFMEMORY;
        break;
      }

      ppCurrent = &((*ppCurrent)->Next);
    }

    if (NULL == *o_ppDistNames)
    {
      hr = E_FAIL;
    }
    
    if (S_OK != hr)
    {
      FreeLDAPNamesList(*ppCurrent);
      *ppCurrent = NULL;
      hr = E_OUTOFMEMORY;
    }
  }

  // free pMsg because ldap_search_s always allocates pMsg
  if (pMsg)
    ldap_msgfree(pMsg);

  return(hr);
}

HRESULT GetConnectionDNs
(
    IN PLDAP        i_pldap,
    IN LPCTSTR      i_lpszBase,
    IN LPTSTR       i_lpszChildObjectClassSF,
    OUT PLDAPNAME*  o_ppDistNames
)
{

  DWORD           dwErr;      
  LPTSTR          lpszCurrentAttr = NULL;   
  LPTSTR      *plpszValues  = NULL;
  BerElement      *BerElm = NULL;       
  PLDAPMessage    pMsg = NULL; 
  PLDAPMessage    pEntry = NULL;     
  PLDAPNAME    *ppCurrent;
  HRESULT      hr = S_OK;

  if (!i_pldap || !i_lpszBase || !o_ppDistNames ||
    !i_lpszChildObjectClassSF || !*i_lpszChildObjectClassSF)
  {
    return(E_INVALIDARG);
  }

  *o_ppDistNames = NULL;
  ppCurrent = o_ppDistNames;

  LPTSTR lpszAttributes[2] = {0,0};
  lpszAttributes[0] = _T("distinguishedName");

                // Execute the search.
  dwErr = ldap_search_s  (i_pldap, 
            (LPTSTR)i_lpszBase, 
            LDAP_SCOPE_ONELEVEL,
            i_lpszChildObjectClassSF, 
            lpszAttributes, 
            0, 
            &pMsg
            );
  if (LDAP_SUCCESS != dwErr)
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
    hr = HRESULT_FROM_WIN32(dwErr);
  } else
  {
                // Scan each entry to find the value set for the DN attribute.
    for(pEntry = ldap_first_entry(i_pldap, pMsg);
      pEntry != NULL;
      pEntry = ldap_next_entry(i_pldap, pEntry)) 
    {
      CComBSTR bstrCN;

                  // Scan each attribute of the entry for DN
      for(lpszCurrentAttr = ldap_first_attribute(i_pldap, pEntry, &BerElm);
          lpszCurrentAttr != NULL;
          lpszCurrentAttr = ldap_next_attribute(i_pldap, pEntry, BerElm))
      {

        plpszValues = ldap_get_values(  i_pldap, 
                        pEntry, 
                        lpszCurrentAttr
                       );
                // Is there a match for CN?
        if (0 == lstrcmpi(_T("distinguishedName"), lpszCurrentAttr)) 
        {
          bstrCN = plpszValues[0];
        }    
      }

                // LDAP object does not have valid fields.
      if (!bstrCN)
        continue;

      // Add to list.

      *ppCurrent = new LDAPNAME;
      if (NULL == *ppCurrent)
      {
        hr = E_OUTOFMEMORY;
        break;
      }

      (*ppCurrent)->Next = NULL;
      (*ppCurrent)->bstrLDAPName = bstrCN.m_str;

      if (!(*ppCurrent)->bstrLDAPName)
      {
        delete *ppCurrent;
        *ppCurrent = NULL;
        hr = E_OUTOFMEMORY;
        break;
      }

      ppCurrent = &((*ppCurrent)->Next);
    }

    if (NULL == *o_ppDistNames)
    {
      hr = E_FAIL;
    }
    
    if (S_OK != hr)
    {
      FreeLDAPNamesList(*ppCurrent);
      *ppCurrent = NULL;
      hr = E_OUTOFMEMORY;
    }
  }

  // free pMsg because ldap_search_s always allocates pMsg
  if (pMsg)
    ldap_msgfree(pMsg);

  return(hr);
}

HRESULT PrepareLDAPMods
(
  IN LDAP_ATTR_VALUE    i_pAttrValue[],
  IN LDAP_ENTRY_ACTION  i_AddModDel,
  IN ULONG        i_ulCountOfVals,
  OUT LDAPMod*      o_ppModVals[]
)
{
/*++

Routine Description:

  Fills up a LPDAMod pointer array given a array of attribute value pairs.
  The mod_op field of all LPDAMod structures returned depends on the value of i_AddModDel.

Arguments:

  i_pAttrValue  -  An array of LDAP_ATTR_VALUE structures containing 
  the attribute and name value pairs.

  i_AddModDel    -  One of LDAP_ENTRY_ACTION enum value.

    i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

    o_ppModVals    -  Pointer to a pre-allocated (and NULL terminated) array of pointers to 
             LPDAPMod structures. The LPDAMod structures and allocated and returned here.
             Size of this should be i_ulCountOfVals.

Return value:
    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.

--*/

  if (NULL == i_pAttrValue || NULL == o_ppModVals)
  {
    return(E_INVALIDARG);
  }

  for (ULONG i = 0, k = 0; k < i_ulCountOfVals; i++, k++)
  {

    //
    // have to skip objectClass attribute in case of modify/delete,
    // otherwise, ldap_modify_xxx will return LDAP_UNWILLING_TO_PERFORM 
    //
    if (ADD_VALUE != i_AddModDel &&
        !lstrcmpi(i_pAttrValue[k].bstrAttribute, ATTR_OBJCLASS))
    {
        k++;
    }

    o_ppModVals[i] = new LDAPMod;
    o_ppModVals[i]->mod_type = _tcsdup(i_pAttrValue[k].bstrAttribute);
    
    switch (i_AddModDel)
    {
    case ADD_VALUE:
      o_ppModVals[i]->mod_op = LDAP_MOD_ADD;
      break;
    case MODIFY_VALUE:
      o_ppModVals[i]->mod_op = LDAP_MOD_REPLACE;
      break;
    case DELETE_VALUE:
      o_ppModVals[i]->mod_op = LDAP_MOD_DELETE;
      break;
    }

            // Count the number of values for this attribute.
    PLDAP_ATTR_VALUE  pAttrVal = &(i_pAttrValue[k]);
    ULONG        ulCountOfVals = 0;
    while (pAttrVal)
    {
      ulCountOfVals++;
      pAttrVal = pAttrVal->Next;
    }

    pAttrVal = &(i_pAttrValue[k]);
    ULONG  j = 0;

    if (i_pAttrValue[k].bBerValue)
    {
      PLDAP_BERVAL* ppBerValues = NULL;
      ppBerValues = new PLDAP_BERVAL[ulCountOfVals + 1];
      ppBerValues[ulCountOfVals] = NULL;

      while (pAttrVal)
      {
        ppBerValues[j] = new LDAP_BERVAL;

        if (!pAttrVal->vpValue)
        {
            ppBerValues[j]->bv_len = 0;
            ppBerValues[j]->bv_val = NULL;
        } else
        {
            ppBerValues[j]->bv_len = pAttrVal->ulLength;
            ppBerValues[j]->bv_val = new char[pAttrVal->ulLength];
            memcpy(
                (void *)ppBerValues[j]->bv_val, 
                pAttrVal->vpValue,
                pAttrVal->ulLength
                );
        }
      
        pAttrVal = pAttrVal->Next;
        j++;
      }
      o_ppModVals[i]->mod_bvalues = ppBerValues;
      o_ppModVals[i]->mod_op |= LDAP_MOD_BVALUES;
    }
    else
    {
      LPTSTR*  plpszValues = NULL;
      plpszValues = new LPTSTR[ulCountOfVals + 1];
      plpszValues[ulCountOfVals] = NULL;

      while (pAttrVal)
      {
        if (pAttrVal->vpValue)
            plpszValues[j] = _tcsdup((LPTSTR)(pAttrVal->vpValue));
        else
            plpszValues[j] = NULL;

        pAttrVal = pAttrVal->Next;
        j++;
      }

      o_ppModVals[i]->mod_values = plpszValues;

    }
  }

  return(S_OK);
}

HRESULT AddValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR        i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE    i_pAttrValue[],
  IN BSTR               i_bstrDC // = NULL
)
{
/*++

Routine Description:
  
  This method add an attribute value (and a new LDAP object if it does not exist)
  in the DS. The parent of the given DN must exist. This can be used to add a new object
  and also to add new values for attributes of an existing object in which case
  the DN must exist.

Arguments:
  
  i_pldap  - Open LDAP connection context.

  i_DN  - Distinguished name of the (new) object.

  i_pAttrValue - Array of pointers to LDAP_ATTR_VALUE containing attribue and value.

  i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

Return value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.
--*/

  if (NULL == i_pldap || NULL == i_DN || NULL == i_pAttrValue)
  {
    return(E_INVALIDARG);
  }
  
  LDAPMod**    ppModVals = NULL;
  HRESULT      hr = S_FALSE;

  ppModVals = new LDAPMod*[i_ulCountOfVals + 1];
  if (NULL == ppModVals)
  {
    return(E_OUTOFMEMORY);
  }

  for (ULONG i = 0; i <= i_ulCountOfVals; i++)
  {
    ppModVals[i] = NULL;
  }

  do
  {
    hr = PrepareLDAPMods(
                i_pAttrValue,
                ADD_VALUE,
                i_ulCountOfVals,
                ppModVals
              );

    if (FAILED(hr))
    {
      break;
    }

    DWORD dwStatus = LDAP_SUCCESS;

    if (!i_bstrDC)
    {
      dwStatus = ldap_add_s(
                    i_pldap,
                    (LPTSTR)i_DN,
                    ppModVals
                   );
    } else
    {
      //
      // prepare the server hint
      //
      LDAPControl   simpleControl;
      PLDAPControl  controlArray[2];
      INT           rc;
      BERVAL*       pBerVal = NULL;
      BerElement*   pBer;

      pBer = ber_alloc_t(LBER_USE_DER);
      if (!pBer)
      {
        hr = E_OUTOFMEMORY;
        break;
      }
      rc = ber_printf(pBer,"{io}", 0, i_bstrDC, wcslen(i_bstrDC) * sizeof(WCHAR));
      if ( rc == -1 ) {
        hr = E_FAIL;
        break;
      }
      rc = ber_flatten(pBer, &pBerVal);
      if (rc == -1)
      {
        hr = E_FAIL;
        break;
      }
      ber_free(pBer,1);

      controlArray[0] = &simpleControl;
      controlArray[1] = NULL;

      simpleControl.ldctl_oid = LDAP_SERVER_VERIFY_NAME_OID_W;
      simpleControl.ldctl_iscritical = TRUE;
      simpleControl.ldctl_value = *pBerVal;

      dwStatus = ldap_add_ext_s(
              i_pldap, 
              (LPTSTR)i_DN, 
              ppModVals, 
              (PLDAPControl *)&controlArray, //ServerControls,
              NULL         //ClientControls,
              );

      ber_bvfree(pBerVal);

    }

    if (LDAP_SUCCESS == dwStatus)
    { 
      hr = S_OK;
    } else if (LDAP_ALREADY_EXISTS == dwStatus)
    {
        hr = ModifyValues(i_pldap, i_DN, i_ulCountOfVals, i_pAttrValue);
    }
    else
    {
      dwStatus = LdapMapErrorToWin32(dwStatus);
      DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_add_ext_s"));
      hr = HRESULT_FROM_WIN32(dwStatus);
    }

  } while (false);

  FreeModVals(&ppModVals);
  delete[] ppModVals;

  return(hr);
}


      // Modifies an existing record or values.
HRESULT ModifyValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR        i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE    i_pAttrValue[]
)
{
/*++

Routine Description:
  
  This method modifies attribute values of a DS object given its DN. 
  The DN object must exist.

Arguments:
  
  i_pldap  - Open LDAP connection context.

  i_DN  - Distinguished name of the object.

  i_pAttrValue - Array of pointers to LDAP_ATTR_VALUE containing attribue and value.

  i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

Return value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.
--*/
  if (NULL == i_pldap || NULL == i_DN || NULL == i_pAttrValue)
  {
    return(E_INVALIDARG);
  }

  LDAPMod**    ppModVals = NULL;
  HRESULT      hr = S_FALSE;
  
  ppModVals = new LDAPMod*[i_ulCountOfVals + 1];
  if (NULL == ppModVals)
  {
    return(E_OUTOFMEMORY);
  }

  for (ULONG i = 0; i <= i_ulCountOfVals; i++)
  {
    ppModVals[i] = NULL;
  }

  do
  {
    hr = PrepareLDAPMods(
                    i_pAttrValue,
                    MODIFY_VALUE,
                    i_ulCountOfVals,
                    ppModVals
                  );
    if (FAILED(hr))
    {
      break;
    }

    //
    // With this server side control, ldap_modify will return success
    // if modifying an existing attribute with same value, or deleting
    // an attribute with no value
    //
    BERVAL        berVal = {0};
    LDAPControl   permissiveControl;
    PLDAPControl  controlArray[2];

    controlArray[0] = &permissiveControl;
    controlArray[1] = NULL;

    permissiveControl.ldctl_oid = LDAP_SERVER_PERMISSIVE_MODIFY_OID_W;
    permissiveControl.ldctl_iscritical = FALSE;
    permissiveControl.ldctl_value = berVal;

    DWORD dwStatus = ldap_modify_ext_s(
                    i_pldap,
                    (LPTSTR)i_DN,
                    ppModVals,
                    (PLDAPControl *)&controlArray,  //ServerControls,
                    NULL                            //ClientControls,
                   );

    if (LDAP_SUCCESS == dwStatus || LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwStatus)
    { 
      hr = S_OK;
      break;
    }
    else
    {
      dwStatus = LdapMapErrorToWin32(dwStatus);
      DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_modify_ext_s"));
      hr = HRESULT_FROM_WIN32(dwStatus);
      break;
    }
  }
  while (false);

  FreeModVals(&ppModVals);
  delete[] ppModVals;

  return(hr);
}

      // Deletes values from an existing record or values.
HRESULT DeleteValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE    i_pAttrValue[]
)
{
/*++

Routine Description:
  
  This method deletes attribute values of a DS object given its DN. 
  The DN object must exist.

Arguments:
  
  i_pldap  - Open LDAP connection context.

  i_DN  - Distinguished name of the object.

  i_pAttrValue - Array of pointers to LDAP_ATTR_VALUE containing attribue and value.

  i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

Return value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.
--*/

  if (NULL == i_pldap || NULL == i_DN || NULL == i_pAttrValue)
  {
    return(E_INVALIDARG);
  }

  LDAPMod**    ppModVals = NULL;
  HRESULT      hr = S_FALSE;
  
  ppModVals = new LDAPMod*[i_ulCountOfVals + 1];
  if (NULL == ppModVals)
  {
    return(E_OUTOFMEMORY);
  }

  for (ULONG i = 0; i <= i_ulCountOfVals; i++)
  {
    ppModVals[i] = NULL;
  }

  do
  {
    hr = PrepareLDAPMods(
                    i_pAttrValue,
                    DELETE_VALUE,
                    i_ulCountOfVals,
                    ppModVals
                  );
    if (FAILED(hr))
    {
      break;
    }

    //
    // With this server side control, ldap_modify will return success
    // if modifying an existing attribute with same value, or deleting
    // an attribute with no value
    //
    BERVAL        berVal = {0};
    LDAPControl   permissiveControl;
    PLDAPControl  controlArray[2];

    controlArray[0] = &permissiveControl;
    controlArray[1] = NULL;

    permissiveControl.ldctl_oid = LDAP_SERVER_PERMISSIVE_MODIFY_OID_W;
    permissiveControl.ldctl_iscritical = FALSE;
    permissiveControl.ldctl_value = berVal;

    DWORD dwStatus = ldap_modify_ext_s(
                    i_pldap,
                    (LPTSTR)i_DN,
                    ppModVals,
                    (PLDAPControl *)&controlArray,  //ServerControls,
                    NULL                            //ClientControls,
                   );

    if (LDAP_SUCCESS == dwStatus || LDAP_NO_SUCH_ATTRIBUTE == dwStatus)
    { 
      hr = S_OK;
      break;
    }
    else
    {
      dwStatus = LdapMapErrorToWin32(dwStatus);
      DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_modify_ext_s"));
      hr = HRESULT_FROM_WIN32(dwStatus);
      break;
    }
  }
  while (false);

  FreeModVals(&ppModVals);
  delete[] ppModVals;

  return(hr);
}

      // Deletes an object, recursive or non-recursive.
HRESULT DeleteDSObject
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN bool         i_bDeleteRecursively //= true
)
{
  if (i_bDeleteRecursively)
  {
    PLDAPNAME   pDNs = NULL;
    PLDAPNAME   pTemp = NULL;

    HRESULT hr = GetChildrenDN(
                  i_pldap,
                  i_DN,
                  LDAP_SCOPE_ONELEVEL,
                  OBJCLASS_SF_ALL,
                  &pDNs
                  );

    if (S_OK == hr)
    {  
      pTemp = pDNs;
      while (pTemp)
      {
        DeleteDSObject(i_pldap, pTemp->bstrLDAPName);
        pTemp = pTemp->Next;      
      }

      FreeLDAPNamesList(pDNs);
    }
  }

  DWORD dwStatus = ldap_delete_s(
                  i_pldap,
                  (LPTSTR)i_DN
                  );

  if ( LDAP_NO_SUCH_OBJECT == dwStatus ||
      (!i_bDeleteRecursively && LDAP_NOT_ALLOWED_ON_NONLEAF == dwStatus) )
    return S_FALSE;

  if ( LDAP_SUCCESS != dwStatus)
  {
    dwStatus = LdapMapErrorToWin32(dwStatus);
    DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_delete_s"));
  }

  return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT FreeModVals
(
    IN OUT LDAPMod ***pppMod
)
/*++
Routine Description:
    
  Free the LPDAMod structures. Frees all LDAPMod values and pointers.

Arguments:
    
  pppMod  - Address of a null-terminated array of LPDAMod.

Return Value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.

--*/
{
  if (NULL == pppMod)
  {
    return(E_INVALIDARG);
  }

  DWORD   i, j;
  LDAPMod **ppMod;


  if (NULL == *pppMod) 
  {
          // Nothing to do.
    return(S_OK);
  }

    
  ppMod = *pppMod;

            // For each attribute entry, free all its values.
  for (i = 0; ppMod[i] != NULL; i++) 
  {
    for (j = 0; (ppMod[i])->mod_values[j] != NULL; j++) 
    {
      if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) 
      {
          delete (ppMod[i]->mod_bvalues[j]->bv_val);
      }
            
      delete ((ppMod[i])->mod_values[j]);
    }
    delete ((ppMod[i])->mod_values);   // Free the array of pointers to values
    delete ((ppMod[i])->mod_type);     // Free the string identifying the attribute
    delete (ppMod[i]);                 // Free the attribute
  }
    
  return(S_OK);
}


LPTSTR ErrorString
(
  DWORD          i_ldapErrCode
)
{
/*++
Routine Description:
    
  Gets a string corresponding to the ldap error code.

Arguments:
    
  i_ldapErrCode  - The ldap error code to map to an error string.

Return Value:

  The pointer to the error string.

--*/
  return(ldap_err2string(i_ldapErrCode));
}


HRESULT IsValidObject
(
  IN PLDAP    i_pldap,
  IN BSTR      i_bstrObjectDN
)
{
/*++

Routine Description:

  Checks if an object with given DN exists.

Arguments:

  i_bstrObjectDN    -  The DN of the object.

Return value:

  S_OK, Object exist
  S_FALSE, no such object
  Others, error occurred
--*/


  if (NULL == i_bstrObjectDN)
  {
    return(E_INVALIDARG);
  }

  PLDAP_ATTR_VALUE  pValues[2] = {0,0}, pCurrent = NULL;

  LDAP_ATTR_VALUE  pAttributes[1];

  pAttributes[0].bstrAttribute = _T("Name");
  pAttributes[0].bBerValue = false;
  
  HRESULT hr = GetValues(  
            i_pldap, 
            i_bstrObjectDN,
            OBJCLASS_SF_ALL,
            LDAP_SCOPE_BASE,
            1,          
            pAttributes,    
            pValues        
            );

  if (SUCCEEDED(hr))
    FreeAttrValList(pValues[0]);
  else
      hr = S_FALSE;

  return(hr);

}

HRESULT  CrackName(
  IN  HANDLE            i_hDS,
  IN  LPTSTR            i_lpszOldTypeName,
  IN  DS_NAME_FORMAT    i_formatIn,
  IN  DS_NAME_FORMAT    i_formatdesired,
  OUT BSTR*             o_pbstrResult
)
{
  if (!i_hDS || !i_lpszOldTypeName || !*i_lpszOldTypeName || !o_pbstrResult)
    return E_INVALIDARG;

  *o_pbstrResult = NULL;

  HRESULT         hr = S_OK;
  DS_NAME_RESULT* pDsNameResult = NULL;
  
  DWORD dwErr = DsCrackNames(
            i_hDS,
            DS_NAME_NO_FLAGS,
            i_formatIn,
            i_formatdesired,
            1,
            &i_lpszOldTypeName,
            &pDsNameResult
          );
  if (ERROR_SUCCESS != dwErr)
    hr = HRESULT_FROM_WIN32(dwErr);
  else
  {
    if (DS_NAME_NO_ERROR != pDsNameResult->rItems->status)
      hr = HRESULT_FROM_WIN32(pDsNameResult->rItems->status);
    else
    {
      *o_pbstrResult = SysAllocString(pDsNameResult->rItems->pName);
      if (!*o_pbstrResult)
        hr = E_OUTOFMEMORY;
    }

    DsFreeNameResult(pDsNameResult);
  }

  return hr;
}

void RemoveBracesOnGuid(IN OUT BSTR bstrGuid)
{
    if (!bstrGuid || !*bstrGuid)
        return;

    TCHAR *p = bstrGuid + lstrlen(bstrGuid) - 1;
    if (_T('}') == *p)
        *p = _T('\0');

    p = bstrGuid;
    if (_T('{') == *p)
    {
        while (*++p)
            *(p-1) = *p;

        *(p-1) = _T('\0');
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDomainInfo
//
//  Synopsis:   return DC Dns name, DomainDN, and/or LDAP://<DC>/<DomainDN> 
//
//--------------------------------------------------------------------------
HRESULT  GetDomainInfo(
  IN  LPCTSTR         i_bstrDomain,
  OUT BSTR*           o_pbstrDC,            // return DC's Dns name
  OUT BSTR*           o_pbstrDomainDnsName, // return Domain's Dns name
  OUT BSTR*           o_pbstrDomainDN,      // return DC=nttest,DC=microsoft,DC=com
  OUT BSTR*           o_pbstrLDAPDomainPath,// return LDAP://<DC>/<DomainDN>
  OUT BSTR*           o_pbstrDomainGuid     // return Domain's guid in string without {}
)
{
  if (o_pbstrDC)                *o_pbstrDC = NULL;
  if (o_pbstrDomainDnsName)     *o_pbstrDomainDnsName = NULL;
  if (o_pbstrDomainDN)          *o_pbstrDomainDN = NULL;
  if (o_pbstrLDAPDomainPath)    *o_pbstrLDAPDomainPath = NULL;
  if (o_pbstrDomainGuid)        *o_pbstrDomainGuid = NULL;

  HRESULT   hr = S_OK;
  BOOL      bRetry = FALSE;
  BOOL      b50Domain = FALSE;
  CComBSTR  bstrDCName;
  CComBSTR  bstrDomainDnsName;
  CComBSTR  bstrDomainDN;
  CComBSTR  bstrLDAPDomainPath;
  CComBSTR  bstrDomainGuid;

  HANDLE hDS = NULL;
  DWORD dwErr = ERROR_SUCCESS;
  do {
#ifdef DEBUG
    SYSTEMTIME time0 = {0};
    GetSystemTime(&time0);
#endif // DEBUG

    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    if (bRetry)
        dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
            DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, &pDCInfo);
    else
        dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
            DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
    SYSTEMTIME time1 = {0};
    GetSystemTime(&time1);
    PrintTimeDelta(_T("GetDomainInfo-DsGetDcName"), &time0, &time1);
#endif // DEBUG

    if (ERROR_SUCCESS != dwErr)
      return HRESULT_FROM_WIN32(dwErr);

    b50Domain = pDCInfo->Flags & DS_DS_FLAG;

    if ( !mylstrncmpi(pDCInfo->DomainControllerName, _T("\\\\"), 2) )
      bstrDCName = pDCInfo->DomainControllerName + 2;
    else
      bstrDCName = pDCInfo->DomainControllerName;

    // remove the ending dot
    int len = _tcslen(pDCInfo->DomainName);
    if ( _T('.') == *(pDCInfo->DomainName + len - 1) )
        *(pDCInfo->DomainName + len - 1) = _T('\0');
    bstrDomainDnsName = pDCInfo->DomainName;

    NetApiBufferFree(pDCInfo);

    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDCName, &hr);
    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainDnsName, &hr);

    hr = b50Domain ? S_OK : S_FALSE;

    if (!b50Domain || 
        !o_pbstrDC &&
        !o_pbstrDomainDnsName &&
        !o_pbstrDomainDN &&
        !o_pbstrLDAPDomainPath &&
        !o_pbstrDomainGuid)
      return hr;

    if (!o_pbstrDomainDN && !o_pbstrLDAPDomainPath && !o_pbstrDomainGuid)
      break;

    dwErr = DsBind(bstrDCName,  bstrDomainDnsName, &hDS);
    hr = HRESULT_FROM_WIN32(dwErr);

#ifdef DEBUG
    SYSTEMTIME time2 = {0};
    GetSystemTime(&time2);
    PrintTimeDelta(_T("GetDomainInfo-DsBind"), &time1, &time2);
#endif // DEBUG

    if ((RPC_S_SERVER_UNAVAILABLE == dwErr || RPC_S_CALL_FAILED == dwErr) && !bRetry)
        bRetry = TRUE; // only retry once
    else
        break;

  } while (1);

  if (FAILED(hr))
      return hr;

  if (hDS)
  {
    do {
        CComBSTR bstrDomainTrailing = bstrDomainDnsName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainTrailing, &hr);
        bstrDomainTrailing += _T("/");   // add the trailing slash
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainTrailing, &hr);

        hr = CrackName(
                  hDS,
                  bstrDomainTrailing,
                  DS_CANONICAL_NAME,
                  DS_FQDN_1779_NAME,
                  &bstrDomainDN
                );
        BREAK_IF_FAILED(hr);

        if (o_pbstrLDAPDomainPath)
        {
            bstrLDAPDomainPath = _T("LDAP://");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
            bstrLDAPDomainPath += bstrDCName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
            bstrLDAPDomainPath += _T("/");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
            bstrLDAPDomainPath += bstrDomainDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
        }

        if (o_pbstrDomainGuid)
        {
            hr = CrackName(
                      hDS,
                      bstrDomainTrailing,
                      DS_CANONICAL_NAME,
                      DS_UNIQUE_ID_NAME,
                      &bstrDomainGuid
                    );
            BREAK_IF_FAILED(hr);
            RemoveBracesOnGuid(bstrDomainGuid);
        }
    } while (0);

    DsUnBind(&hDS);

  } while (0);

  if (SUCCEEDED(hr))
  {
    if (o_pbstrDC)
      *o_pbstrDC = bstrDCName.Detach();

    if (o_pbstrDomainDnsName)
      *o_pbstrDomainDnsName = bstrDomainDnsName.Detach();

    if (o_pbstrDomainDN)
      *o_pbstrDomainDN = bstrDomainDN.Detach();

    if (o_pbstrLDAPDomainPath)
      *o_pbstrLDAPDomainPath = bstrLDAPDomainPath.Detach();

    if (o_pbstrDomainGuid)
      *o_pbstrDomainGuid = bstrDomainGuid.Detach();
  }

  return hr;
}

HRESULT GetRootDomainName(
    IN  LPCTSTR i_bstrDomainName,
    OUT BSTR*   o_pbstrRootDomainName
    )
{
#ifdef DEBUG
    SYSTEMTIME time0 = {0};
    GetSystemTime(&time0);
#endif // DEBUG

    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    DWORD dwErr = DsGetDcName(NULL, i_bstrDomainName, NULL, NULL,
            DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
    SYSTEMTIME time1 = {0};
    GetSystemTime(&time1);
    PrintTimeDelta(_T("GetRootDomainName-DsGetDcName"), &time0, &time1);
#endif // DEBUG

    if (ERROR_SUCCESS != dwErr)
      return HRESULT_FROM_WIN32(dwErr);

    // remove the ending dot
    int len = _tcslen(pDCInfo->DnsForestName);
    if ( _T('.') == *(pDCInfo->DnsForestName + len - 1) )
        *(pDCInfo->DnsForestName + len - 1) = _T('\0');

    *o_pbstrRootDomainName = SysAllocString(pDCInfo->DnsForestName);

    NetApiBufferFree(pDCInfo);

    if (!*o_pbstrRootDomainName)
        return E_OUTOFMEMORY;

    return S_OK;
}

void
DebugOutLDAPError(
    IN PLDAP  i_pldap,
    IN ULONG  i_ulError,
    IN PCTSTR i_pszLDAPFunctionName
)
{
#ifdef DEBUG
  if (i_pldap && LDAP_SUCCESS != i_ulError)
  {
    TCHAR *pszExtendedError = NULL;
    DWORD dwErrorEx = ldap_get_optionW(
                        i_pldap,
                        LDAP_OPT_SERVER_ERROR,
                        (void *) &pszExtendedError);
    if (LDAP_SUCCESS == dwErrorEx)
    {
      dfsDebugOut((_T("%s returns error: %x, extended error: %s\n"), 
        i_pszLDAPFunctionName, i_ulError, pszExtendedError)); 
      ldap_memfree(pszExtendedError); 
    } else
    {
      dfsDebugOut((_T("%s returns error: %x\n"), 
        i_pszLDAPFunctionName, i_ulError)); 
    }
  }
#endif // DEBUG
}

int
MyCompareStringN(
    IN LPCTSTR  lpString1,
    IN LPCTSTR  lpString2,
    IN UINT     cchCount,
    IN DWORD    dwCmpFlags
)
{
  UINT  nLen1 = (lpString1 ? lstrlen(lpString1) : 0);
  UINT  nLen2 = (lpString2 ? lstrlen(lpString2) : 0);
  int   nRet = CompareString(
                LOCALE_USER_DEFAULT,
                dwCmpFlags,
                lpString1,
                min(cchCount, nLen1),
                lpString2,
                min(cchCount, nLen2)
              );

  return (nRet - CSTR_EQUAL);
}

int
mylstrncmp(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
)
{
  return MyCompareStringN(lpString1, lpString2, cchCount, 0);
}

int
mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
)
{
  return MyCompareStringN(lpString1, lpString2, cchCount, NORM_IGNORECASE);
}

HRESULT ExtendDN
(
    IN  LPTSTR    i_lpszCN,
    IN  LPTSTR    i_lpszDN,
    OUT BSTR      *o_pbstrNewDN
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrNewDN);
    RETURN_INVALIDARG_IF_TRUE(!i_lpszCN || !*i_lpszCN);

    CComBSTR bstrNewDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
    bstrNewDN += i_lpszCN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
    if (i_lpszDN && *i_lpszDN)
    {
        bstrNewDN += _T(",");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
        bstrNewDN += i_lpszDN;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
    }

    *o_pbstrNewDN = bstrNewDN.Detach();

    return S_OK;
}

HRESULT ExtendDNIfLongJunctionName(
    IN  LPTSTR    i_lpszJunctionName,
    IN  LPCTSTR   i_lpszBaseDN,
    OUT BSTR      *o_pbstrNewDN
)
{
  RETURN_INVALIDARG_IF_NULL(o_pbstrNewDN);
  RETURN_INVALIDARG_IF_TRUE(!i_lpszJunctionName || !*i_lpszJunctionName);

  HRESULT hr = S_OK;

  if (_tcslen(i_lpszJunctionName) > MAX_RDN_KEY_SIZE)
  {
    // junction name is too long to be fit into one CN= name,
    // we need to break it down into several CN= names
    LPTSTR  *paStrings = NULL;
    DWORD   dwEntries = 0;
    hr = GetJunctionPathPartitions((PVOID *)&paStrings, &dwEntries, i_lpszJunctionName);
    if (SUCCEEDED(hr))
    {
      CComBSTR    bstrIn = i_lpszBaseDN;
      CComBSTR    bstrOut;

      for (DWORD i=0; i<dwEntries; i++)
      {
        hr = ExtendDN(paStrings[i], bstrIn, &bstrOut);
        if (FAILED(hr)) break;

        bstrIn = bstrOut;
        bstrOut.Empty();
      }

      free(paStrings);

      if (SUCCEEDED(hr))
        *o_pbstrNewDN = bstrIn.Detach();
    }
  
  } else {
    // junction name can fit into one CN= name
    ReplaceChar(i_lpszJunctionName, _T('\\'), _T('|'));
    hr = ExtendDN(i_lpszJunctionName, (PTSTR)i_lpszBaseDN, o_pbstrNewDN);
  }

  return hr;
}

HRESULT ReplaceChar
(
  IN OUT BSTR    io_bstrString, 
  TCHAR      i_cOldChar,
  TCHAR      i_cNewChar
)
/*++
Routine Description:
  Replace all occurences of a char ("\") with another char ("_") in 
  the given string.
Arguments:
  io_bstrString  - The string which needs to be converted.
  i_cOldChar    - The original character.
  i_cNewChar    - The character to replace the old one with.
--*/
{
  RETURN_INVALIDARG_IF_NULL(io_bstrString);

                    // Replace i_cOldChar by i_cNewChar
                    // allowed in DN.
  LPTSTR lpszTempPtr = _tcschr(io_bstrString, i_cOldChar);

  while (lpszTempPtr)
  {
    *lpszTempPtr = i_cNewChar;
    lpszTempPtr = _tcschr(lpszTempPtr +1,i_cOldChar);
  }

  return S_OK;
}

HRESULT GetJunctionPathPartitions(
    OUT PVOID       *o_ppBuffer,
    OUT DWORD       *o_pdwEntries,
    IN  LPCTSTR      i_pszJunctionPath
)
{
  _ASSERT(o_ppBuffer && o_pdwEntries && i_pszJunctionPath && *i_pszJunctionPath);

  if (!o_ppBuffer || !o_pdwEntries || !i_pszJunctionPath || !(*i_pszJunctionPath))
    return(E_INVALIDARG);

  HRESULT hr = S_OK;
  int     nLength = _tcslen(i_pszJunctionPath);
  DWORD   dwCount = nLength / MAX_RDN_KEY_SIZE + ((nLength % MAX_RDN_KEY_SIZE) ? 1 : 0);
  PBYTE   pBuffer = NULL;

  pBuffer = (PBYTE)calloc(dwCount, sizeof(LPTSTR *) + (MAX_RDN_KEY_SIZE + 1) * sizeof(TCHAR));
  if (!pBuffer)
  {
    hr = E_OUTOFMEMORY;
  } else
  {
    DWORD   i = 0;
    LPTSTR *ppsz = NULL;
    LPTSTR  pString = NULL;

    for (i=0; i<dwCount; i++)
    {
      ppsz = (LPTSTR *)(pBuffer + i * sizeof(LPTSTR *));
      pString = (LPTSTR)(pBuffer + dwCount * sizeof(LPTSTR *) + i * (MAX_RDN_KEY_SIZE + 1) * sizeof(TCHAR));

      _tcsncpy(pString, i_pszJunctionPath, MAX_RDN_KEY_SIZE);
      ReplaceChar(pString, _T('\\'), _T('|'));

      *ppsz = pString;

      i_pszJunctionPath += MAX_RDN_KEY_SIZE;
    }

    *o_ppBuffer = pBuffer;
    *o_pdwEntries = dwCount;

  }

  return hr;
}

HRESULT CreateExtraNodesIfLongJunctionName(
    IN PLDAP   i_pldap,
    IN LPCTSTR i_lpszJunctionName,
    IN LPCTSTR i_lpszBaseDN,
    IN LPCTSTR i_lpszObjClass
)
{
  _ASSERT(i_pldap && 
          i_lpszJunctionName && *i_lpszJunctionName &&
          i_lpszBaseDN && *i_lpszBaseDN &&
          i_lpszObjClass && *i_lpszObjClass);

  HRESULT hr = S_OK;

  if (_tcslen(i_lpszJunctionName) > MAX_RDN_KEY_SIZE)
  {
    // junction name is too long to be fit into one CN= name,
    // we need to break it down into several CN= names
    LPTSTR  *paStrings = NULL;
    DWORD   dwEntries = 0;

    hr = GetJunctionPathPartitions((PVOID *)&paStrings, &dwEntries, i_lpszJunctionName);
    if (SUCCEEDED(hr))
    {
      DWORD       i = 0;
      CComBSTR    bstrIn = i_lpszBaseDN;
      CComBSTR    bstrOut;

      for (i=0; i<(dwEntries-1); i++)
      {
        hr = ExtendDN(paStrings[i], bstrIn, &bstrOut);
        if (SUCCEEDED(hr))
          hr = CreateObjectSimple(i_pldap, bstrOut, i_lpszObjClass);
        if (FAILED(hr)) break;

        bstrIn = bstrOut;
        bstrOut.Empty();
      }

      free(paStrings);
    }

  }  // > MAX_RDN_KEY_SIZE

  return hr;
}

HRESULT CreateObjectSimple(
    IN PLDAP    i_pldap,
    IN LPCTSTR  i_lpszDN,
    IN LPCTSTR  i_lpszObjClass
)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_lpszDN);
    RETURN_INVALIDARG_IF_NULL(i_lpszObjClass);

    LDAP_ATTR_VALUE  pAttrVals[1];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)i_lpszObjClass;
    pAttrVals[0].bBerValue = false;

    return AddValues(
                    i_pldap,
                    i_lpszDN,
                    1,
                    pAttrVals
                    );
}

HRESULT DeleteExtraNodesIfLongJunctionName(
    IN PLDAP   i_pldap,
    IN LPCTSTR i_lpszJunctionName,
    IN LPCTSTR i_lpszDN
)
{
  _ASSERT(i_pldap &&
          i_lpszJunctionName && *i_lpszJunctionName &&
          i_lpszDN && *i_lpszDN);

  DWORD   nLength = _tcslen(i_lpszJunctionName);
  if (nLength > MAX_RDN_KEY_SIZE)
  {
    DWORD   dwEntries = nLength / MAX_RDN_KEY_SIZE + ((nLength % MAX_RDN_KEY_SIZE) ? 1 : 0); 

    (void) DeleteAncestorNodesIfEmpty(i_pldap, i_lpszDN+3, dwEntries-1);
  }

  return S_OK;
}

HRESULT
CreateObjectsRecursively(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrDN,
    IN UINT         i_nLenPrefix,
    IN LPCTSTR      i_lpszObjClass)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDN);
    RETURN_INVALIDARG_IF_NULL(i_lpszObjClass);

    if (0 == i_nLenPrefix)
        return S_OK;

    HRESULT hr = IsValidObject(i_pldap, i_bstrDN);
    if (S_OK == hr)
        return S_OK;

    CComBSTR  bstrPrefix = CComBSTR(i_nLenPrefix, i_bstrDN);
    PTSTR     pszNextPrefix = _tcsstr(bstrPrefix + 3, _T("CN="));
    UINT      nLengthNext = (pszNextPrefix ? _tcslen(pszNextPrefix) : 0);
    UINT      nLengthThis = (pszNextPrefix ? (pszNextPrefix - bstrPrefix) : _tcslen(bstrPrefix));

    hr = CreateObjectsRecursively(
                                    i_pldap,
                                    i_bstrDN + nLengthThis,
                                    nLengthNext,
                                    i_lpszObjClass);

    if (SUCCEEDED(hr))
        hr = CreateObjectSimple(
                            i_pldap, 
                            i_bstrDN, 
                            i_lpszObjClass);

    return hr;
}

HRESULT DeleteAncestorNodesIfEmpty(
    IN PLDAP   i_pldap,
    IN LPCTSTR i_lpszDN,
    IN DWORD   i_dwCount
)
{
  _ASSERT(i_pldap &&
          i_lpszDN && *i_lpszDN &&
          i_dwCount > 0);

  DWORD   i = 0;
  LPTSTR  p = NULL;

  for (i=0; i<i_dwCount; i++)
  {
    p = _tcsstr(i_lpszDN, _T("CN="));
    if (p)
    {
      (void) DeleteDSObject(i_pldap, p, false);

      i_lpszDN = p+3;
    }
  }

  return S_OK;
}

HRESULT GetDfsLinkNameFromDN(
    IN  BSTR    i_bstrReplicaSetDN, 
    OUT BSTR*   o_pbstrDfsLinkName)
{
    if (!i_bstrReplicaSetDN || !*i_bstrReplicaSetDN || !o_pbstrDfsLinkName)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    PTSTR   pszReplicaSetDN = NULL;

    do {
        //
        // make a copy of the string
        //
        pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
        BREAK_OUTOFMEMORY_IF_NULL(pszReplicaSetDN, &hr);

        //
        // change the string to all upper cases
        //
        _tcsupr(pszReplicaSetDN);

        //
        // get rid of suffix: Dfs Volumes\File Replication Service\system\.....
        //
        TCHAR* p = _tcsstr(pszReplicaSetDN, _T(",CN=DFS VOLUMES"));
        if (!p)
        {
            hr = E_INVALIDARG;
            break;
        }
        *p = _T('\0'); 

        //
        // reverse the string
        //
        _tcsrev(pszReplicaSetDN);

        //
        // get rid of the CN= clause about the DfsRoot container
        //
        PTSTR pszCN = _tcsstr(pszReplicaSetDN, _T("=NC,"));
        if (!pszCN)
        {
            hr = E_INVALIDARG;
            break;
        }
        pszCN += 4; // after this tep, pszCN points at the delta

        //
        // Now, the left over CN= clauses are all related to Dfs Link name
        //
        p = _tcsstr(pszCN, _T("=NC"));
        if (!p)
        {
            hr = E_INVALIDARG;  // there must be at least one CN= clause
            break;
        }

        CComBSTR bstrLinkName;
        do {
            *p = _T('\0');
            _tcsrev(pszCN);
            bstrLinkName += pszCN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLinkName, &hr);

            pszCN = p + 3; // points to the next CN= clause
            if (*pszCN && *pszCN == _T(','))
                pszCN++;

            if (!*pszCN)
                break;      // no more CN= clauses

            p = _tcsstr(pszCN, _T("=NC"));
        } while (p);

        if (SUCCEEDED(hr))
        {
            ReplaceChar(bstrLinkName, _T('|'), _T('\\'));
            *o_pbstrDfsLinkName = bstrLinkName.Detach();
        }
    } while (0);

    if (pszReplicaSetDN)
        free(pszReplicaSetDN);

    return hr;
}

HRESULT GetReplicaSetContainer(
    PLDAP   i_pldap,
    BSTR    i_bstrDfsName,
    BSTR*   o_pbstrContainerDN)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDfsName);
    RETURN_INVALIDARG_IF_NULL(o_pbstrContainerDN);

    CComBSTR bstrDfsRootDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);
    bstrDfsRootDN += i_bstrDfsName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);
    bstrDfsRootDN += CN_DFSVOLUMES_PREFIX_COMMA;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);

    LPTSTR lpszDomainDN = NULL;
    HRESULT hr = GetLDAPRootPath(i_pldap, &lpszDomainDN);
    RETURN_IF_FAILED(hr);

    bstrDfsRootDN += lpszDomainDN;
    
    free(lpszDomainDN);
    
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);

    *o_pbstrContainerDN = bstrDfsRootDN.Detach();

    return S_OK;
}

HRESULT GetSubscriberDN(
    IN  BSTR    i_bstrReplicaSetDN,
    IN  BSTR    i_bstrDomainGuid,
    IN  BSTR    i_bstrComputerDN,
    OUT BSTR*   o_pbstrSubscriberDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrDomainGuid);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(o_pbstrSubscriberDN);

    HRESULT hr = S_OK;

    CComBSTR bstrSubscriberDN;

    PTSTR pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
    RETURN_OUTOFMEMORY_IF_NULL(pszReplicaSetDN);

    _tcsupr(pszReplicaSetDN); // change to all upper case

    do {
        TCHAR* p = _tcsstr(pszReplicaSetDN, _T(",CN=DFS VOLUMES"));
        if (!p)
        {
            hr = E_INVALIDARG;
            break;
        }

        bstrSubscriberDN = CComBSTR((int)(p - pszReplicaSetDN) + 4, i_bstrReplicaSetDN);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
        bstrSubscriberDN += i_bstrDomainGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
        bstrSubscriberDN += _T(",CN=DFS Volumes,CN=NTFRS Subscriptions,");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
        bstrSubscriberDN += i_bstrComputerDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
    } while (0);

    free(pszReplicaSetDN);

    if (SUCCEEDED(hr))
        *o_pbstrSubscriberDN = bstrSubscriberDN.Detach();

    return hr;
}


HRESULT CreateNtfrsMemberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrComputerDN,
    IN BSTR     i_bstrDCofComputerObj
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);

    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[2];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)OBJCLASS_NTFRSMEMBER;
    pAttrVals[0].bBerValue = false;

    pAttrVals[1].bstrAttribute = ATTR_FRS_MEMBER_COMPUTERREF;
    pAttrVals[1].vpValue = (void *)i_bstrComputerDN;
    pAttrVals[1].bBerValue = false;

    hr = AddValues(
            i_pldap,
            i_bstrMemberDN,
            2,
            pAttrVals,
            i_bstrDCofComputerObj
            );
    
    return hr;
}

HRESULT CreateNtfrsSubscriberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrRootPath,
    IN BSTR     i_bstrStagingPath,
    IN BSTR     i_bstrDC            // validate MemberDN against this DC
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrRootPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrStagingPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrDC);

    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[4];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)OBJCLASS_NTFRSSUBSCRIBER;
    pAttrVals[0].bBerValue = false;

    pAttrVals[1].bstrAttribute = ATTR_FRS_SUBSCRIBER_MEMBERREF;
    pAttrVals[1].vpValue = (void *)i_bstrMemberDN;
    pAttrVals[1].bBerValue = false;

    pAttrVals[2].bstrAttribute = ATTR_FRS_SUBSCRIBER_ROOTPATH;
    pAttrVals[2].vpValue = (void *)i_bstrRootPath;
    pAttrVals[2].bBerValue = false;

    pAttrVals[3].bstrAttribute = ATTR_FRS_SUBSCRIBER_STAGINGPATH;
    pAttrVals[3].vpValue = (void *)i_bstrStagingPath;
    pAttrVals[3].bBerValue = false;

    hr = AddValues(
            i_pldap,
            i_bstrSubscriberDN,
            4,
            pAttrVals,
            i_bstrDC
            );
    
    return hr;
}

HRESULT CreateNtdsConnectionObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrConnectionDN,
    IN BSTR     i_bstrFromMemberDN,
    IN BOOL     i_bEnable
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);

    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[4];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)OBJCLASS_NTDSCONNECTION;
    pAttrVals[0].bBerValue = false;

    pAttrVals[1].bstrAttribute = ATTR_NTDS_CONNECTION_FROMSERVER;
    pAttrVals[1].vpValue = (void *)i_bstrFromMemberDN;
    pAttrVals[1].bBerValue = false;

    pAttrVals[2].bstrAttribute = ATTR_NTDS_CONNECTION_ENABLEDCONNECTION;
    pAttrVals[2].vpValue = (void *)(i_bEnable ? CONNECTION_ENABLED_TRUE : CONNECTION_ENABLED_FALSE);
    pAttrVals[2].bBerValue = false;

    pAttrVals[3].bstrAttribute = ATTR_NTDS_CONNECTION_OPTIONS;
    pAttrVals[3].vpValue = (void *)DEFAULT_CONNECTION_OPTIONS;
    pAttrVals[3].bBerValue = false;

    hr = AddValues(
            i_pldap,
            i_bstrConnectionDN,
            4,
            pAttrVals
            );

    return hr;
}

#define CN_SEARCH_UPR_DFSVOL_FRS_SYS    _T(",CN=DFS VOLUMES,CN=FILE REPLICATION SERVICE,CN=SYSTEM")
#define CN_SEARCH_UPR_SYS               _T(",CN=SYSTEM")
#define CN_SEARCH_UPR_FRS_SYS           _T(",CN=FILE REPLICATION SERVICE,CN=SYSTEM")

HRESULT CreateNtfrsSettingsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);

    HRESULT hr = S_OK;

    //
    // The first CN= clause is a nTFRSReplicaSet object.
    // The clauses from the 2nd to the CN=System clause should be created
    // as nTFRSSettings objects
    //
    PTSTR pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
    RETURN_OUTOFMEMORY_IF_NULL(pszReplicaSetDN);

    _tcsupr(pszReplicaSetDN);

    TCHAR *pszNtfrsSettingsDN = NULL;
    int lenPrefix = 0;
    do {
        // have pStart point at the 2nd CN=
        TCHAR *pStart = _tcsstr(pszReplicaSetDN, _T(",CN="));
        if (!pStart)
        {
            hr = E_INVALIDARG;
            break;
        }
        pStart++;

        // have pEnd points at the CN=SYSTEM
        TCHAR *pEnd = _tcsstr(pszReplicaSetDN, CN_SEARCH_UPR_DFSVOL_FRS_SYS);
        if (!pEnd)
        {
            hr = E_INVALIDARG;
            break;
        }
        pEnd += lstrlen(CN_SEARCH_UPR_DFSVOL_FRS_SYS) - lstrlen(CN_SEARCH_UPR_SYS) + 1;

        //
        // calculate
        //
        pszNtfrsSettingsDN = i_bstrReplicaSetDN + ((BYTE*)pStart - (BYTE*)pszReplicaSetDN) / sizeof(TCHAR);
        lenPrefix = (int)((BYTE*)pEnd - (BYTE*)pStart) / sizeof(TCHAR);
    } while (0);

    free(pszReplicaSetDN);

    RETURN_IF_FAILED(hr);

    hr = CreateObjectsRecursively(
                                i_pldap,
                                pszNtfrsSettingsDN,
                                lenPrefix,
                                OBJCLASS_NTFRSSETTINGS
                                );
    return hr;
}
        
HRESULT CreateNtfrsSubscriptionsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);

    //
    // The first CN= clause is a nTFRSSubscriber object.
    // The clauses from the 2nd to the CN=<computer> clause should be created
    // as nTFRSSubscriptions objects
    //

    // have pStart point at the 2nd CN=
    TCHAR *pStart = _tcsstr(i_bstrSubscriberDN, _T(",CN="));
    RETURN_INVALIDARG_IF_NULL(pStart);
    pStart++;

    //
    // calculate
    //
    TCHAR *pszNtfrsSubscriptionsDN = pStart;
    int lenPrefix = lstrlen(pszNtfrsSubscriptionsDN) - lstrlen(i_bstrComputerDN);

    HRESULT hr = CreateObjectsRecursively(
                                i_pldap,
                                pszNtfrsSubscriptionsDN,
                                lenPrefix,
                                OBJCLASS_NTFRSSUBSCRIPTIONS
                                );
    return hr;
}

HRESULT DeleteNtfrsReplicaSetObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);

    HRESULT hr = S_OK;

    //
    // The first CN= clause is a nTFRSReplicaSet object.
    // The clauses from the 2nd to the CN=File Replication Service clause should 
    // be deleted if empty
    //
    PTSTR pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
    RETURN_OUTOFMEMORY_IF_NULL(pszReplicaSetDN);

    _tcsupr(pszReplicaSetDN);

    int lenPrefix = 0;
    TCHAR *pStart = NULL;
    do {
        // have pStart point at the 2nd CN=
        pStart = _tcsstr(pszReplicaSetDN, _T(",CN="));
        if (!pStart)
        {
            hr = E_INVALIDARG;
            break;
        }
        pStart++;

        // have pEnd points at the CN=FILE REPLICATION SERVICE
        TCHAR *pEnd = _tcsstr(pszReplicaSetDN, CN_SEARCH_UPR_DFSVOL_FRS_SYS);
        if (!pEnd)
        {
            hr = E_INVALIDARG;
            break;
        }
        pEnd += lstrlen(CN_SEARCH_UPR_DFSVOL_FRS_SYS) - lstrlen(CN_SEARCH_UPR_FRS_SYS) + 1;

        //
        // calculate
        //
        lenPrefix = (int)((BYTE*)pEnd - (BYTE*)pStart) / sizeof(TCHAR);
    } while (0);

    if (SUCCEEDED(hr))
    {
        // forcibly blow away the replicaset object
        hr = DeleteDSObject(i_pldap, i_bstrReplicaSetDN, true);
        if (SUCCEEDED(hr))
        {
            // delete replicasettings objects if empty
            hr = DeleteDSObjectsIfEmpty(
                                        i_pldap,
                                        pStart,
                                        lenPrefix
                                        );
        }
    }

    free(pszReplicaSetDN);

    return hr;
}

HRESULT DeleteNtfrsSubscriberObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);

    //
    // The first CN= clause is a nTFRSSubscriber object.
    // The clauses from the 1st to the CN=<computer> clause should 
    // be deleted if empty
    //

    //
    // calculate
    //
    int lenPrefix = lstrlen(i_bstrSubscriberDN) - lstrlen(i_bstrComputerDN);

    HRESULT hr = DeleteDSObjectsIfEmpty(
                                i_pldap,
                                i_bstrSubscriberDN,
                                lenPrefix
                                );
    return hr;
}

HRESULT DeleteDSObjectsIfEmpty(
    IN PLDAP    i_pldap,
    IN LPCTSTR  i_lpszDN,
    IN int      i_nPrefixLength
)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_lpszDN);
    RETURN_INVALIDARG_IF_NULL(i_nPrefixLength);

    HRESULT hr = S_OK;
    TCHAR   *p = (PTSTR)i_lpszDN;

    while (p < i_lpszDN + i_nPrefixLength)
    {
        hr = DeleteDSObject(i_pldap, p, false);
        BREAK_IF_FAILED(hr);

        p = _tcsstr(p, _T(",CN="));
        if (!p)
            break;
        p++;
    }

  return hr;
}

HRESULT SetConnectionSchedule(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrConnectionDN,
    IN SCHEDULE*    i_pSchedule)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_pSchedule);

    //
    // set attribute schedule of this nTDSConnection object
    //
    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_SCHEDULE;
    pAttrVals[0].vpValue = (void *)i_pSchedule;
    pAttrVals[0].ulLength = i_pSchedule->Size;
    pAttrVals[0].bBerValue = true;

    return ::ModifyValues(i_pldap, i_bstrConnectionDN, 1, pAttrVals);
}

HRESULT UuidToStructuredString(
    UUID*  i_pUuid,
    BSTR*  o_pbstr
)
{
    if (!i_pUuid || !o_pbstr)
        return E_INVALIDARG;

    TCHAR szString[40];

    _stprintf( szString,
           _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
           i_pUuid->Data1,
           i_pUuid->Data2,
           i_pUuid->Data3,
           i_pUuid->Data4[0],
           i_pUuid->Data4[1],
           i_pUuid->Data4[2],
           i_pUuid->Data4[3],
           i_pUuid->Data4[4],
           i_pUuid->Data4[5],
           i_pUuid->Data4[6],
           i_pUuid->Data4[7] );

    *o_pbstr = SysAllocString(szString);
    if (!*o_pbstr)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT ScheduleToVariant(
    IN  SCHEDULE*   i_pSchedule,
    OUT VARIANT*    o_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_pSchedule);
    RETURN_INVALIDARG_IF_NULL(o_pVar);

    VariantInit(o_pVar);
    o_pVar->vt = VT_ARRAY | VT_VARIANT;
    o_pVar->parray = NULL;

    int nItems = i_pSchedule->Size;

    SAFEARRAYBOUND  bounds = {nItems, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    for (int i = 0; i < nItems; i++)
    {
        varArray[i].vt = VT_UI1;
        varArray[i].cVal = *((BYTE *)i_pSchedule + i);
    }

    SafeArrayUnaccessData(psa);

    o_pVar->parray = psa;

    return S_OK;
}

HRESULT VariantToSchedule(
    IN  VARIANT*    i_pVar,
    OUT PSCHEDULE*  o_ppSchedule    // freed by caller
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pVar);
    RETURN_INVALIDARG_IF_NULL(o_ppSchedule);

    HRESULT hr = S_OK;

    if (V_VT(i_pVar) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa = V_ARRAY(i_pVar);
    long        lLowerBound = 0;
    long        lUpperBound = 0;
    long        lCount = 0;

    SafeArrayGetLBound(psa, 1, &lLowerBound );
    SafeArrayGetUBound(psa, 1, &lUpperBound );
    lCount = lUpperBound - lLowerBound + 1;

    BYTE *pSchedule = (BYTE *)calloc(lCount, 1);
    RETURN_OUTOFMEMORY_IF_NULL(pSchedule);

    VARIANT HUGEP *pArray;
    SafeArrayAccessData(psa, (void HUGEP **) &pArray);

    for (int i = 0; i < lCount; i++)
    {
        if (VT_UI1 != pArray[i].vt)
        {
            hr = E_INVALIDARG;
            break;
        }

        pSchedule[i] = pArray[i].cVal;
    }

    SafeArrayUnaccessData(psa);

    if (FAILED(hr))
        free(pSchedule);
    else
        *o_ppSchedule = (SCHEDULE *)pSchedule;

    return hr;
}

HRESULT CompareSchedules(
    IN  SCHEDULE*  i_pSchedule1,
    IN  SCHEDULE*  i_pSchedule2
    )
{
    if (!i_pSchedule1 && !i_pSchedule2)
        return S_OK;
    else if (!i_pSchedule1 || !i_pSchedule2)
        return S_FALSE;
    else if (i_pSchedule1->Size != i_pSchedule2->Size)
        return S_FALSE;

    HRESULT hr = S_OK;
    for (ULONG i = 0; i < i_pSchedule1->Size; i++)
    {
        if (*((BYTE *)i_pSchedule1 + i) != *((BYTE *)i_pSchedule2 + i))
        {
            hr = S_FALSE;
            break;
        }
    }

    return hr;
}

HRESULT CopySchedule(
    IN  SCHEDULE*  i_pSrcSchedule,
    OUT PSCHEDULE* o_ppDstSchedule
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pSrcSchedule);
    RETURN_INVALIDARG_IF_NULL(o_ppDstSchedule);

    *o_ppDstSchedule = (SCHEDULE *)calloc(i_pSrcSchedule->Size, 1);
    RETURN_OUTOFMEMORY_IF_NULL(*o_ppDstSchedule);

    memcpy(*o_ppDstSchedule, i_pSrcSchedule, i_pSrcSchedule->Size);

    return S_OK;
}

HRESULT GetDefaultSchedule(
    OUT PSCHEDULE* o_ppSchedule
    )
{
    RETURN_INVALIDARG_IF_NULL(o_ppSchedule);

    SCHEDULE* pSchedule = (SCHEDULE *)calloc(20 + SCHEDULE_DATA_ENTRIES, 1);
    RETURN_OUTOFMEMORY_IF_NULL(pSchedule);

    pSchedule->Size = 20 + SCHEDULE_DATA_ENTRIES;
    pSchedule->Bandwidth = 0; // not used
    pSchedule->NumberOfSchedules = 1;
    pSchedule->Schedules->Type = SCHEDULE_INTERVAL;
    pSchedule->Schedules->Offset = 20;
    memset((BYTE *)pSchedule + 20, 1, SCHEDULE_DATA_ENTRIES);

    *o_ppSchedule = pSchedule;

    return S_OK;
}

//
// S_OK: Whistler version
// S_FALSE: Windows2000 version
// others: error occurred
//
HRESULT GetSchemaVersion(IN PLDAP    i_pldap)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);

    LDAP_ATTR_VALUE  pAttributes[1];
    pAttributes[0].bstrAttribute = ATTR_SCHEMANAMINGCONTEXT;
    pAttributes[0].bBerValue = false;

    PLDAP_ATTR_VALUE pDNName[1] = {0};
    HRESULT hr = GetValues(  i_pldap, 
            _T(""),             // LDAP Root.
            OBJCLASS_SF_ALL,    // All Objects
            LDAP_SCOPE_BASE,
            1,                  // Only 1 attribute
            pAttributes,        // schemaNamingContext Attribute.
            pDNName             // List of all values at Root for schemaNamingContext.
            );

    if (FAILED(hr))
        return(hr);

    if (!(pDNName[0]))
        return S_FALSE;

    if (!(pDNName[0]->vpValue) || !*((LPTSTR)pDNName[0]->vpValue))
    {
        FreeAttrValList(pDNName[0]);
        return S_FALSE;
    }

    CComBSTR bstrSchemaNamingContext = (LPTSTR)pDNName[0]->vpValue;

    FreeAttrValList(pDNName[0]);

    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSchemaNamingContext);

    CComBSTR bstrReplicaSetSchemaDN = DN_PREFIX_SCHEMA_REPLICASET;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrReplicaSetSchemaDN);
    bstrReplicaSetSchemaDN += bstrSchemaNamingContext;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrReplicaSetSchemaDN);

    BOOL        bFound = FALSE;
    PCTSTR      ppszAttributes[] = {ATTR_SYSTEMMAYCONTAIN, 0};
    LListElem*  pElem = NULL;
    hr = GetValuesEx(
                    i_pldap,
                    bstrReplicaSetSchemaDN,
                    LDAP_SCOPE_BASE,
                    OBJCLASS_SF_CLASSSCHEMA,
                    ppszAttributes,
                    &pElem);

    if (SUCCEEDED(hr) && pElem && pElem->pppszAttrValues)
    {
        PTSTR* ppszValues = *(pElem->pppszAttrValues);
        if (ppszValues)
        {
            while (*ppszValues)
            {
                if (!lstrcmpi(ATTR_FRS_REPSET_TOPOLOGYPREF, *ppszValues))
                {
                    bFound = TRUE;
                    break;
                }
                ppszValues++;
            }
        }

        FreeLListElem(pElem);
    }

    RETURN_IF_FAILED(hr);

    return (bFound ? S_OK : S_FALSE);
}

//
// S_OK: Whistler version
// S_FALSE: Windows2000 version
// others: error occurred
//
HRESULT GetSchemaVersionEx(
    IN BSTR i_bstrName,
    IN BOOL i_bServer // =TRUE if i_bstrName is a server, FALSE if i_bstrName is a domain
    )
{
    HRESULT hr = S_OK;

    PTSTR pszDomain = NULL;

    do {
        CComBSTR bstrDomain;
        if (i_bServer)
        {
            hr = GetServerInfo(i_bstrName, &bstrDomain);
            if (S_OK != hr)
                break;
            pszDomain = bstrDomain;
        } else
        {
            pszDomain = i_bstrName;
        }

        PLDAP pldap = NULL;
        hr = ConnectToDS(pszDomain, &pldap, NULL);
        if (SUCCEEDED(hr))
        {
            hr = GetSchemaVersion(pldap);
            CloseConnectionToDS(pldap);
        }
    } while (0);

    return hr;
}

//
// This function doesn't refetch DC in case of LDAP_SERVER_DOWN
//
HRESULT LdapConnectToDC(IN LPCTSTR i_pszDC, OUT PLDAP* o_ppldap)
{
    if (!i_pszDC || !*i_pszDC || !o_ppldap)
        return E_INVALIDARG;

    *o_ppldap = NULL;

    PLDAP pldap = ldap_init((LPTSTR)i_pszDC, LDAP_PORT);
    if (!pldap)
        return HRESULT_FROM_WIN32(GetLastError());

    //
    // Making ldap_open/ldap_connect with a server name without first setting 
    // LDAP_OPT_AREC_EXCLUSIVE (for ldap interfaces) or 
    // ADS_SERVER_BIND (for ADSI interfaces) will result in bogus DNS queries 
    // consuming bandwidth and potentially bringing up remote links that are 
    // costly or demand dial.
    //
    // ignore the return of ldap_set_option
    ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

    ULONG ulRet = ldap_connect(pldap, NULL); // NULL for the default timeout
    if (LDAP_SUCCESS != ulRet)
    {
        ldap_unbind(pldap);
        return HRESULT_FROM_WIN32(LdapMapErrorToWin32(ulRet));
    }

    *o_ppldap = pldap;

    return S_OK;

}

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT BSTR*        o_pbstrErrorMsg
)
{
  if (0 == i_dwError || !o_pbstrErrorMsg)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;
  LPTSTR       lpBuffer = NULL;

  DWORD dwRet = ::FormatMessage(
              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
              (LPTSTR)&lpBuffer, 0, NULL);
  if (0 == dwRet)
  {
    // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
        0x80070000 == (i_dwError & 0xffff0000) ||
        0 == (i_dwError & 0xffff0000) )
    { // Try locating the message from NetMsg.dll.
      hr = S_OK;
      DWORD dwNetError = i_dwError & 0x0000ffff;
      
      HINSTANCE  hLib = LoadLibrary(_T("netmsg.dll"));
      if (!hLib)
        hr = HRESULT_FROM_WIN32(GetLastError());
      else
      {
        dwRet = ::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            hLib, dwNetError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR)&lpBuffer, 0, NULL);

        if (0 == dwRet)
          hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hLib);
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    *o_pbstrErrorMsg = SysAllocString(lpBuffer);
    LocalFree(lpBuffer);
  }
  else
  {
    // we failed to retrieve the error message from system/netmsg.dll,
    // report the error code directly to user
    hr = S_OK;
    TCHAR szString[32];
    _stprintf(szString, _T("0x%x"), i_dwError); 
    *o_pbstrErrorMsg = SysAllocString(szString);
  }

  if (!*o_pbstrErrorMsg)
    hr = E_OUTOFMEMORY;

  return hr;
}

HRESULT
FormatMessageString(
  OUT BSTR *o_pbstrMsg,
  IN  DWORD dwErr,
  IN  UINT  iStringId, // OPTIONAL: String resource Id
  ...)        // Optional arguments
{
  _ASSERT(dwErr != 0 || iStringId != 0);    // One of the parameter must be non-zero

  HRESULT hr = S_OK;
  CComBSTR bstrErrorMsg, bstrMsg;

  if (dwErr)
    hr = GetErrorMessage(dwErr, &bstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      bstrMsg = bstrErrorMsg;
      RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrMsg);
    }
    else
    {
      TCHAR szString[1024];
      ::LoadString(_Module.GetModuleInstance(), iStringId, 
                   szString, sizeof(szString)/sizeof(TCHAR));

      va_list arglist;
      va_start(arglist, iStringId);

      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        &arglist);
      va_end(arglist);

      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        bstrMsg = lpBuffer;
        LocalFree(lpBuffer);

        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrMsg);

        if (dwErr)
        {
          bstrMsg += bstrErrorMsg;
          RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrMsg);
        }
      }
    }
  }

  if (SUCCEEDED(hr))
    *o_pbstrMsg = bstrMsg.Detach();

  return hr;
}

//
// This function will DsBind to a valid DC (DC is re-fetched if down)
//
HRESULT DsBindToDS(BSTR i_bstrDomain, BSTR *o_pbstrDC, HANDLE *o_phDS)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrDC);
    RETURN_INVALIDARG_IF_NULL(o_phDS);

    HRESULT     hr = S_OK;
    BOOL        bRetry = FALSE;
    HANDLE      hDS = NULL;
    DWORD       dwErr = ERROR_SUCCESS;
    CComBSTR    bstrDCName;
    CComBSTR    bstrDomainDnsName;

    do {
#ifdef DEBUG
        SYSTEMTIME time0 = {0};
        GetSystemTime(&time0);
#endif // DEBUG

        PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
        if (bRetry)
            dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, &pDCInfo);
        else
            dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
        SYSTEMTIME time1 = {0};
        GetSystemTime(&time1);
        PrintTimeDelta(_T("DsBindToDS-DsGetDcName"), &time0, &time1);
#endif // DEBUG

        if (ERROR_SUCCESS != dwErr)
            return HRESULT_FROM_WIN32(dwErr);

        if ( !mylstrncmpi(pDCInfo->DomainControllerName, _T("\\\\"), 2) )
            bstrDCName = pDCInfo->DomainControllerName + 2;
        else
            bstrDCName = pDCInfo->DomainControllerName;
    
        // remove the ending dot
        int len = _tcslen(pDCInfo->DomainName);
        if ( _T('.') == *(pDCInfo->DomainName + len - 1) )
            *(pDCInfo->DomainName + len - 1) = _T('\0');
        bstrDomainDnsName = pDCInfo->DomainName;

        NetApiBufferFree(pDCInfo);

        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDCName, &hr);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainDnsName, &hr);

        dwErr = DsBind(bstrDCName, bstrDomainDnsName, &hDS);
        hr = HRESULT_FROM_WIN32(dwErr);

#ifdef DEBUG
        SYSTEMTIME time2 = {0};
        GetSystemTime(&time2);
        PrintTimeDelta(_T("DsBindToDS-DsBind"), &time1, &time2);
#endif // DEBUG

        if ((RPC_S_SERVER_UNAVAILABLE == dwErr || RPC_S_CALL_FAILED == dwErr) && !bRetry)
        {
            bRetry = TRUE; // only retry once
        } else
        {
            if (SUCCEEDED(hr))
            {
                *o_phDS = hDS;

                *o_pbstrDC = bstrDCName.Copy();
                if (!*o_pbstrDC)
                {
                    hr = E_OUTOFMEMORY;
                    DsUnBind(&hDS);
                    *o_phDS = NULL;
                }
            }

            break;
        }
    } while (1);

    return hr;
}

#ifdef DEBUG
void PrintTimeDelta(LPCTSTR pszMsg, SYSTEMTIME* pt0, SYSTEMTIME* pt1)
{
    if (!pt0 || !pt1)
        return;

    dfsDebugOut((_T("%s took %d milliseconds.\n"), (pszMsg ? pszMsg : _T("")), 
        ((pt1->wMinute - pt0->wMinute) * 60 +
         (pt1->wSecond - pt0->wSecond)) * 1000 +
         (pt1->wMilliseconds - pt0->wMilliseconds)
         ));
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <oleauto.h>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\ldaputils.h ===
/*++
Module Name:

LDAPUtils.h

Abstract:
  This is the header file for the LDAP utility functions.

*/


#ifndef _LDAPUTILS_H
#define _LDAPUTILS_H

#include <stdafx.h>
#include <winldap.h>    // For LDAP APIs.
#include <ntdsapi.h>
#include <schedule.h>

              // Defines Values;

#define MAX_RDN_KEY_SIZE            64   // ds\src\inc\ntdsa.h
#define CN_SYSTEM                       _T("System")
#define CN_FRS                          _T("File Replication Service")
#define CN_DFSVOLUMES                   _T("DFS Volumes")
#define CN_NTFRSSUBSCRIPTIONS           _T("NTFRS Subscriptions")
#define CN_DFSCONFIGURATION             _T("Dfs-Configuration")
#define CN_COMPUTERS                    _T("Computers")
#define CN_DFSVOLUMES_PREFIX            _T(",CN=DFS Volumes,CN=File Replication Service,CN=System")
#define CN_DFSVOLUMES_PREFIX_COMMA      _T(",CN=DFS Volumes,CN=File Replication Service,CN=System,")

#define OBJCLASS_ATTRIBUTENAME          _T("objectClass")

typedef enum  LDAP_ENTRY_ACTION
{
  ADD_VALUE    = 0,
  MODIFY_VALUE,
  DELETE_VALUE
};

typedef struct _LDAPNAME
{
  CComBSTR    bstrLDAPName;
  _LDAPNAME    *Next;

  _LDAPNAME():Next(NULL)
  {
  }

}  LDAPNAME,    *PLDAPNAME;

              // This holds a linked list of LDAP attributes and value.
              // Used in ldap_add, ldap_modify etc.
typedef struct _LDAP_ATTR_VALUE
{
  CComBSTR      bstrAttribute;    // Attribute name.
  void*        vpValue;      // Pointer to value buffer, void pointer to handle char as
                      // well as binary values.
  BOOLEAN        bBerValue;      // Is this a BerValue?
  ULONG        ulLength;      // Size of a BerValue;
  _LDAP_ATTR_VALUE*  Next;        // The bBerValue fields of the structures other than 
                      // the head of the list are ignored.

  _LDAP_ATTR_VALUE():
    vpValue(NULL),
    bBerValue(false),
    ulLength(0),
    Next(NULL)
  {
  }

}  LDAP_ATTR_VALUE, *PLDAP_ATTR_VALUE;

typedef struct _LDAPLLIST
{
  PLDAP_ATTR_VALUE  pAttrValues;
  _LDAPLLIST        *Next;

  _LDAPLLIST():Next(NULL)
  {
  }

}  LDAPLLIST,    *PLDAPLLIST;

typedef struct _LLISTELEM
{
  PTSTR**            pppszAttrValues;
  _LLISTELEM        *Next;

  _LLISTELEM(PTSTR** pppszValues):
        pppszAttrValues(pppszValues),
        Next(NULL)
  {
  }

  ~_LLISTELEM()
  {
      PTSTR** pppszValues = pppszAttrValues;
      while (*pppszValues)
          ldap_value_free(*pppszValues++);

      free(pppszAttrValues);
  }
} LListElem;

HRESULT FreeLDAPNamesList
(
  IN PLDAPNAME    i_pLDAPNames        // pointer to list to be freed.
);  

HRESULT FreeAttrValList
(
  IN PLDAP_ATTR_VALUE    i_pAttrVals        // pointer to list to be freed.
);  
      // Connect To DS (LDAP)
HRESULT ConnectToDS
(
  IN  PCTSTR    i_lpszDomainName,  // DNS or non DNS format.
  OUT PLDAP    *o_ppldap,
  OUT BSTR*     o_pbstrDC = NULL
);

      // Close connection to DS
HRESULT CloseConnectionToDS
(
  IN PLDAP    i_pldap      
);

      // Gets Values for an attribute from an LDAP Object.
HRESULT GetValues 
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_lpszBase,
    IN PCTSTR               i_lpszSearchFilter,
    IN ULONG                i_ulScope,
    IN ULONG                i_ulAttrCount,
    IN LDAP_ATTR_VALUE      i_pAttributes[],
    OUT PLDAP_ATTR_VALUE    o_ppValues[]
);

void FreeLListElem(LListElem* pElem);

HRESULT GetValuesEx 
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_pszBase,
    IN ULONG                i_ulScope,
    IN PCTSTR               i_pszSearchFilter,
    IN PCTSTR               i_pszAttributes[],
    OUT LListElem**         o_ppElem
);
      // Gets the root path of a DS.
HRESULT GetLDAPRootPath
(
    IN PLDAP      pldap,
    OUT LPTSTR*   ppszRootPath
);

      //  Gets the DNs of all children of a DS object.
HRESULT GetChildrenDN
(
    IN PLDAP        i_pldap,
    IN LPCTSTR      i_lpszBase,
    IN ULONG        i_ulScope,
    IN LPTSTR       i_lpszChildObjectClass,
    OUT PLDAPNAME*  o_ppDistNames
);


      // Internal function to prepare LDAPMod
HRESULT PrepareLDAPMods
(
  IN LDAP_ATTR_VALUE    i_pAttrValue[],
  IN LDAP_ENTRY_ACTION  i_AddModDel,
  IN ULONG        i_ulCountOfVals,
  OUT LDAPMod*      o_ppModVals[]
);


      // Adds a new record or values.
HRESULT AddValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  OUT LDAP_ATTR_VALUE  i_pAttrValue[],
  IN BSTR               i_bstrDC = NULL
);

      // Modifies an existing record or values.
HRESULT ModifyValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  OUT LDAP_ATTR_VALUE  i_pAttrValue[]
);

      // Deletes values from an existing record or values.
HRESULT DeleteValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE  i_pAttrValue[]
);

      // Deletes an object from DS.
HRESULT DeleteDSObject
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN bool         i_bDeleteRecursively = true
);

      // Free ModVals.
HRESULT FreeModVals
(
    IN OUT LDAPMod ***io_pppMod
);

      // Gets a string corresponding to the ldap error code.
LPTSTR ErrorString
(
  DWORD          i_ldapErrCode
);

// Checks if an object with given DN exists.
HRESULT IsValidObject
(
  IN PLDAP        i_pldap,
  IN BSTR          i_bstrObjectDN
);

// Gets the DN of an object given old style name.
HRESULT  CrackName(
  IN  HANDLE          i_hDS,
  IN  LPTSTR          i_lpszOldTypeName,
  IN  DS_NAME_FORMAT  i_formatIn,
  IN  DS_NAME_FORMAT  i_formatdesired,
  OUT BSTR*           o_pbstrResult
);

// return S_FALSE if it's not NT5 domain
HRESULT  GetDomainInfo(
  IN  LPCTSTR         i_bstrDomain,
  OUT BSTR*           o_pbstrDC = NULL,            // return DC's Dns name
  OUT BSTR*           o_pbstrDomainDnsName = NULL, // return Domain's Dns name
  OUT BSTR*           o_pbstrDomainDN = NULL,      // return DC=nttest,DC=microsoft,DC=com
  OUT BSTR*           o_pbstrLDAPDomainPath = NULL,// return LDAP://<DC>/<DomainDN>
  OUT BSTR*           o_pbstrDomainGuid = NULL     // return Domain's guid
);

HRESULT GetRootDomainName(
    IN  LPCTSTR i_bstrDomainName,
    OUT BSTR*   o_pbstrRootDomainName
    );

void
DebugOutLDAPError(
    IN PLDAP  i_pldap,
    IN ULONG  i_ulError,
    IN PCTSTR i_pszLDAPFunctionName
);

HRESULT ExtendDN
(
  IN  LPTSTR            i_lpszCN,
  IN  LPTSTR            i_lpszDN,
  OUT BSTR              *o_pbstrNewDN
);

HRESULT ExtendDNIfLongJunctionName
(
  IN  LPTSTR            i_lpszJunctionName,
  IN  LPCTSTR           i_lpszBaseDN,
  OUT BSTR              *o_pbstrNewDN
);

HRESULT GetJunctionPathPartitions
(
  OUT PVOID             *o_ppBuffer,
  OUT DWORD             *o_pdwEntries,
  IN  LPCTSTR           i_pszJunctionPath
);

HRESULT CreateExtraNodesIfLongJunctionName
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszJunctionName,
  IN LPCTSTR            i_lpszBaseDN,
  IN LPCTSTR            i_lpszObjClass
);

HRESULT DeleteExtraNodesIfLongJunctionName
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszJunctionName,
  IN LPCTSTR            i_lpszDN
);

HRESULT CreateObjectSimple
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszDN,
  IN LPCTSTR            i_lpszObjClass
);

HRESULT CreateObjectsRecursively
(
  IN PLDAP              i_pldap,
  IN BSTR               i_bstrDN,
  IN UINT               i_nLenPrefix,
  IN LPCTSTR            i_lpszObjClass
);

HRESULT DeleteAncestorNodesIfEmpty
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszDN,
  IN DWORD              i_dwCount
);

// Replace all occurences of '\' with '|' in the given string.
HRESULT ReplaceChar
(
  IN OUT  BSTR          io_bstrString, 
  IN      TCHAR         i_cOldChar,
  IN      TCHAR         i_cNewChar
);

HRESULT GetDfsLinkNameFromDN(
    IN  BSTR    i_bstrReplicaSetDN, 
    OUT BSTR*   o_pbstrDfsLinkName
    );

HRESULT GetReplicaSetContainer(
    PLDAP   i_pldap,
    BSTR    i_bstrDfsName,
    BSTR*   o_pbstrContainerDN
    );

HRESULT GetSubscriberDN(
    IN  BSTR    i_bstrReplicaSetDN,
    IN  BSTR    i_bstrDomainGuid,
    IN  BSTR    i_bstrComputerDN,
    OUT BSTR*   o_pbstrSubscriberDN
    );

HRESULT CreateNtfrsMemberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrComputerDN,
    IN BSTR     i_bstrDCofComputerObj
    );

HRESULT CreateNtfrsSubscriberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrRootPath,
    IN BSTR     i_bstrStagingPath,
    IN BSTR     i_bstrDC
    );

HRESULT CreateNtdsConnectionObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrConnectionDN,
    IN BSTR     i_bstrFromMemberDN,
    IN BOOL     i_bEnable
    );

HRESULT CreateNtfrsSettingsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    );

HRESULT DeleteNtfrsReplicaSetObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    );

HRESULT CreateNtfrsSubscriptionsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    );

HRESULT DeleteNtfrsSubscriberObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    );

HRESULT DeleteDSObjectsIfEmpty(
    IN PLDAP    i_pldap,
    IN LPCTSTR  i_lpszDN,
    IN int      i_nPrefixLength
);

HRESULT SetConnectionSchedule(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrConnectionDN,
    IN SCHEDULE*    i_pSchedule);

HRESULT UuidToStructuredString(
    UUID*  i_pUuid,
    BSTR*  o_pbstr
);

HRESULT ScheduleToVariant(
    IN  SCHEDULE*   i_pSchedule,
    OUT VARIANT*    o_pVar
    );

HRESULT VariantToSchedule(
    IN  VARIANT*    i_pVar,
    OUT PSCHEDULE*  o_ppSchedule
    );

HRESULT CompareSchedules(
    IN  SCHEDULE*  i_pSchedule1,
    IN  SCHEDULE*  i_pSchedule2
    );

HRESULT CopySchedule(
    IN  SCHEDULE*  i_pSrcSchedule,
    OUT PSCHEDULE* o_ppDstSchedule
    );

HRESULT GetDefaultSchedule(
    OUT PSCHEDULE* o_ppSchedule
    );

HRESULT GetSchemaVersion(IN PLDAP    i_pldap);

HRESULT GetSchemaVersionEx(
    IN BSTR i_bstrName,
    IN BOOL i_bServer = TRUE // TRUE if i_bstrName is a server, FALSE if i_bstrName is a domain
    );

HRESULT LdapConnectToDC(IN LPCTSTR i_pszDC, OUT PLDAP* o_ppldap);

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT BSTR*        o_pbstrErrorMsg
);

HRESULT
FormatMessageString(
  OUT BSTR *o_pbstrMsg,
  IN  DWORD dwErr,
  IN  UINT  iStringId,
  ...);

HRESULT DsBindToDS(BSTR i_bstrDomain, BSTR *o_pbstrDC, HANDLE *o_phDS);

#ifdef DEBUG
void PrintTimeDelta(LPCTSTR pszMsg, SYSTEMTIME* pt0, SYSTEMTIME* pt1);
#endif // DEBUG

#endif //#ifndef _LDAPUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\netutils.cpp ===
/**
Module Name:

NetUtils.cpp

Abstract:
  This is the implementation file for the utility functions for Network APIs.

*/

#include "NetUtils.h"
#include <winsock2.h>
#include <stack>
#include <ntdsapi.h>
#include <ldaputils.h>
#include <lmdfs.h>
#include <dsrole.h>
#include <dns.h>  //DNS_MAX_NAME_BUFFER_LENGTH
//----------------------------------------------------------------------------------

HRESULT FlatAdd
(
  DOMAIN_DESC*      i_pDomDesc,      // Pointer to the Domain Description Structure returned by IBrowserDomainTree::GetDomains()
  OUT NETNAMELIST*  o_pDomainList    // Pointer to the list of NETNAME is returned here.
)
/*++

Routine Description:

  This function flattens the domain tree returned by GetDomains() method
  of IBrowserDomainTree into a NETNAME list.
  This code produces a preorder traversal method.

Arguments:

  i_pDomDesc    -  Pointer to the Domain Description Structure returned by IBrowserDomainTree::GetDomains()  
  o_pDomainList  -  Pointer to the list of NETNAME is returned here.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pDomDesc);
    RETURN_INVALIDARG_IF_NULL(o_pDomainList);

    HRESULT             hr = S_OK;
    stack<DOMAIN_DESC*> Stack;  

    Stack.push(i_pDomDesc);
    while (!Stack.empty())
    {
        DOMAIN_DESC* pDomDesc = Stack.top();
        Stack.pop();

        NETNAME* pCurrent = new NETNAME;
        BREAK_OUTOFMEMORY_IF_NULL(pCurrent, &hr);

        pCurrent->bstrNetName = pDomDesc->pszName;
        if (!(pCurrent->bstrNetName))
        {
            delete pCurrent;
            hr = E_OUTOFMEMORY;
            break;
        }

                          // Add to the output list.
        o_pDomainList->push_back(pCurrent);

        if (pDomDesc->pdNextSibling)
            Stack.push(pDomDesc->pdNextSibling);

        if (pDomDesc->pdChildList)
            Stack.push(pDomDesc->pdChildList);
    }

    if (FAILED(hr))
        FreeNetNameList(o_pDomainList);

    return hr;
}

HRESULT Get50Domains
(
  OUT NETNAMELIST*  o_pDomains        // List of NETNAME structures.
)
/*++

Routine Description:

  Returns a list of all NT 5.0 domains in a list of NETNAME structures

Arguments:

  o_pDomains   -  Pointer to list of NETNAME structures is returned.

--*/

//  This method uses the DsDomainTreeBrowser COM Object to get the list
//  of domain names from the DS. The Domain tree returned is then flatened out
//  by using preorder traversal algorithm.
{
    RETURN_INVALIDARG_IF_NULL(o_pDomains);

    FreeNetNameList(o_pDomains);
  
    CComPtr<IDsBrowseDomainTree>  pDsDomTree;
    HRESULT       hr = CoCreateInstance(
                                      CLSID_DsDomainTreeBrowser, 
                                      NULL, 
                                      CLSCTX_INPROC_SERVER,
                                      IID_IDsBrowseDomainTree,
                                      (void **)&pDsDomTree
                                     );    
    RETURN_IF_FAILED(hr);
  
    PDOMAIN_TREE  pDomTree = NULL;
    hr = pDsDomTree->GetDomains(&pDomTree, DBDTF_RETURNEXTERNAL | DBDTF_RETURNINBOUND);
    RETURN_IF_FAILED(hr);

             // Flaten the tree in to a list.
    hr = FlatAdd(&(pDomTree->aDomains[0]), o_pDomains);

    pDsDomTree->FreeDomains(&pDomTree);
  
    return hr;
}

//----------------------------------------------------------------------------------
HRESULT Is50Domain
(
  IN BSTR      i_bstrDomain,
  OUT BSTR*    o_pbstrDnsDomainName    
)
{
  return GetDomainInfo(i_bstrDomain, NULL, o_pbstrDnsDomainName);
}

//----------------------------------------------------------------------------------
HRESULT GetServerInfo
(
  IN  BSTR    i_bstrServer,
  OUT BSTR    *o_pbstrDomain, // = NULL     
  OUT BSTR    *o_pbstrNetbiosName, // = NULL
  OUT BOOL    *o_pbValidDSObject, // = NULL
  OUT BSTR    *o_pbstrDnsName, // = NULL
  OUT BSTR    *o_pbstrGuid, // = NULL
  OUT BSTR    *o_pbstrFQDN, // = NULL
  OUT SUBSCRIBERLIST *o_pFRSRootList, // NULL
  OUT long    *o_lMajorNo, // = NULL
  OUT long    *o_lMinorNo // = NULL
)
{
//  This function uses NetWkstaGetInfo to get the server informaiton.

  if (!o_pbstrDomain && 
      !o_pbstrNetbiosName &&
      !o_pbValidDSObject &&
      !o_pbstrDnsName &&
      !o_pbstrGuid &&
      !o_pbstrFQDN &&
      !o_pFRSRootList &&
      !o_lMajorNo && 
      !o_lMinorNo
     )
    return(E_INVALIDARG);

  if (o_pbstrDomain)      *o_pbstrDomain = NULL;
  if (o_pbstrNetbiosName) *o_pbstrNetbiosName = NULL;
  if (o_pbValidDSObject)  *o_pbValidDSObject = FALSE;
  if (o_pbstrDnsName)     *o_pbstrDnsName = NULL;
  if (o_pbstrGuid)        *o_pbstrGuid = NULL;
  if (o_pbstrFQDN)        *o_pbstrFQDN = NULL;
  if (o_pFRSRootList)     FreeSubscriberList(o_pFRSRootList);
  if (o_lMajorNo)         *o_lMajorNo = 0;
  if (o_lMinorNo)         *o_lMinorNo = 0;

  HRESULT           hr = S_OK;
  PWKSTA_INFO_100   wki100 = NULL;
  NET_API_STATUS    NetStatus = NetWkstaGetInfo(i_bstrServer, 100, (LPBYTE *) &wki100 );
  if (ERROR_SUCCESS != NetStatus) 
    hr = HRESULT_FROM_WIN32(NetStatus);
  else
  {
    if (o_lMajorNo)
      *o_lMajorNo = wki100->wki100_ver_major;

    if (o_lMinorNo)
      *o_lMinorNo = wki100->wki100_ver_minor;

    if (SUCCEEDED(hr) && o_pbstrNetbiosName && wki100->wki100_computername)
    {
      *o_pbstrNetbiosName = SysAllocString(wki100->wki100_computername);
      if (!*o_pbstrNetbiosName) 
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr) &&
        (o_pbstrDomain || o_pbValidDSObject || o_pbstrDnsName || o_pbstrGuid || o_pbstrFQDN || o_pFRSRootList) &&
        wki100->wki100_langroup && 
        wki100->wki100_computername)
    {
      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuffer = NULL;
      DWORD dwErr = DsRoleGetPrimaryDomainInformation(
                        i_bstrServer,
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE *)&pBuffer);
      if (ERROR_SUCCESS != dwErr)
        hr = HRESULT_FROM_WIN32(dwErr);
      else
      {
        CComBSTR bstrDomain;

        //
        // Verify if this is really a server name.
        // NetWkstaGetInfo and DsRoleGetPrimaryDomainInformation work with domain name,
        // they return info of a DC.
        //
        if (i_bstrServer && *i_bstrServer && 
            (pBuffer->DomainNameFlat && !lstrcmpi(i_bstrServer, pBuffer->DomainNameFlat) || 
             pBuffer->DomainNameDns && !lstrcmpi(i_bstrServer, pBuffer->DomainNameDns)))
        {
            // we're seeing a domain name, not what we expect, return S_FALSE.
            hr = S_FALSE; // server not in a domain or cannot find an appropriate computer obj.
        } else
        {
            bstrDomain = (pBuffer->DomainNameDns ? pBuffer->DomainNameDns : pBuffer->DomainNameFlat);
            if (!bstrDomain)
            {
                hr = E_OUTOFMEMORY;
            } else if (!*bstrDomain)
            {
                hr = S_FALSE; // server not in a domain or cannot find an appropriate computer obj.
            } else
            {
                //
                // In case the DNS name is in absolute form, remove the ending dot
                //
                int nlen = _tcslen(bstrDomain);
                if ( *(bstrDomain + nlen - 1) == _T('.') )
                  *(bstrDomain + nlen - 1) = _T('\0');
            }
        }

        DsRoleFreeMemory(pBuffer);

        if (S_OK == hr && o_pbstrDomain)
        {
            *o_pbstrDomain = SysAllocString(bstrDomain);
            if (!*o_pbstrDomain) 
                hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr &&
            (o_pbValidDSObject || o_pbstrDnsName || o_pbstrGuid || o_pbstrFQDN || o_pFRSRootList) )
        {
            CComBSTR bstrDC;
            HANDLE   hDS = NULL;
            hr = DsBindToDS(bstrDomain, &bstrDC, &hDS);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrOldName = wki100->wki100_langroup;
                bstrOldName += _T("\\");
                bstrOldName += wki100->wki100_computername;
                bstrOldName += _T("$");

                if (o_pbstrGuid)
                    hr = CrackName(hDS, bstrOldName, DS_NT4_ACCOUNT_NAME, DS_UNIQUE_ID_NAME, o_pbstrGuid);

                if (SUCCEEDED(hr) && (o_pbValidDSObject || o_pbstrDnsName || o_pbstrFQDN || o_pFRSRootList))
                {
                    CComBSTR bstrComputerDN;
                    hr = CrackName(hDS, bstrOldName, DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME, &bstrComputerDN);
                    if (SUCCEEDED(hr) && o_pbstrFQDN)
                    {
                        *o_pbstrFQDN = bstrComputerDN.Copy();
                        if (!*o_pbstrFQDN)
                            hr = E_OUTOFMEMORY;
                    }
                    if (SUCCEEDED(hr) && (o_pbValidDSObject || o_pbstrDnsName || o_pFRSRootList))
                    {
                        PLDAP pldap = NULL;
                        hr = LdapConnectToDC(bstrDC, &pldap);
                        if (SUCCEEDED(hr))
                        {
                            dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
                            if (LDAP_SUCCESS != dwErr)
                            {
                                DebugOutLDAPError(pldap, dwErr, _T("ldap_bind_s"));
                                hr = HRESULT_FROM_WIN32(dwErr);
                            } else
                            {
                                if (o_pbValidDSObject)
                                {
                                    hr = IsValidObject(pldap, bstrComputerDN);
                                    *o_pbValidDSObject = (S_OK == hr);
                                }

                                if (SUCCEEDED(hr) && o_pbstrDnsName)
                                {
                                    PLDAP_ATTR_VALUE  pValues[2] = {0,0};
                                    LDAP_ATTR_VALUE  pAttributes[1];
                                    pAttributes[0].bstrAttribute = _T("dNSHostName");

                                    hr = GetValues(  
                                            pldap, 
                                            bstrComputerDN,
                                            OBJCLASS_SF_COMPUTER,
                                            LDAP_SCOPE_BASE,
                                            1,          
                                            pAttributes,    
                                            pValues        
                                            );

                                    if (SUCCEEDED(hr))
                                    {
                                        *o_pbstrDnsName = SysAllocString((LPTSTR)(pValues[0]->vpValue));
                                        if (!*o_pbstrDnsName)
                                            hr = E_OUTOFMEMORY;

                                        FreeAttrValList(pValues[0]);

                                    } else
                                    {
                                        hr = S_OK; // ignore failure, since dNSHostName might not be set
                                    }

                                }

                                if (SUCCEEDED(hr) && o_pFRSRootList)
                                {
                                    PCTSTR ppszAttributes[] = {ATTR_FRS_SUBSCRIBER_MEMBERREF, ATTR_FRS_SUBSCRIBER_ROOTPATH, 0};

                                    LListElem* pElem = NULL;
                                    hr = GetValuesEx(pldap,
                                                    bstrComputerDN,
                                                    LDAP_SCOPE_SUBTREE,
                                                    OBJCLASS_SF_NTFRSSUBSCRIBER,
                                                    ppszAttributes,
                                                    &pElem);
                                    if (SUCCEEDED(hr) && pElem)
                                    {
                                        LListElem* pCurElem = pElem;
                                        while (pCurElem)
                                        {
                                            PTSTR** pppszValues = pCurElem->pppszAttrValues;

                                            if (!pppszValues ||
                                                !pppszValues[0] || !*(pppszValues[0]) ||
                                                !pppszValues[1] || !*(pppszValues[1]))
                                            {
                                                pCurElem = pCurElem->Next;
                                                continue; // corrupted subscriber object, ignore it
                                            }

                                            SUBSCRIBER* pCurrent = new SUBSCRIBER;
                                            BREAK_OUTOFMEMORY_IF_NULL(pCurrent, &hr);

                                            pCurrent->bstrMemberDN = *(pppszValues[0]);  // frsMemberReference
                                            pCurrent->bstrRootPath = *(pppszValues[1]);  // frsRootPath
                                            if (!(pCurrent->bstrMemberDN) || !(pCurrent->bstrRootPath))
                                            {
                                                delete pCurrent;
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }

                                            o_pFRSRootList->push_back(pCurrent);

                                            pCurElem = pCurElem->Next;
                                        }

                                        FreeLListElem(pElem);

                                        if (FAILED(hr))
                                            FreeSubscriberList(o_pFRSRootList);
                                    }
                                }
                            }

                            ldap_unbind(pldap);
                        }
                    }
                }
                DsUnBind(&hDS);
            }
        }
      } // DsRoleGetPrimaryDomainInformation
    }

    NetApiBufferFree((LPBYTE)wki100);
  }  //NetWkstaGetInfo 

  return hr;
}


//----------------------------------------------------------------------------------

HRESULT  IsServerRunningDfs
(
  IN BSTR      i_bstrServer
)
/*++

Routine Description:

  Contacts the machine and determines if service Dfs is running.

Arguments:

  i_bstrServer -   The server name.

--*/
{
    SC_HANDLE       SCMHandle = NULL;
    SC_HANDLE       DFSHandle = NULL;
    SERVICE_STATUS  SStatus;
    HRESULT         hr = S_FALSE;

    if ((SCMHandle = OpenSCManager(i_bstrServer, NULL, GENERIC_READ)) &&
        (DFSHandle = OpenService(SCMHandle, _T("Dfs"), SERVICE_QUERY_STATUS)) &&
        QueryServiceStatus(DFSHandle, &SStatus) &&
        (SERVICE_RUNNING == SStatus.dwCurrentState) )
    {
        hr = S_OK;
    }  

    if (DFSHandle)
        CloseServiceHandle(DFSHandle);
    if (SCMHandle)
        CloseServiceHandle(SCMHandle);

    return hr;
}

//
// TRUE: support NTFS 5 reparse point
// FALSE: doesn't support
//
BOOL CheckReparsePoint(IN BSTR i_bstrServer, IN BSTR i_bstrShare)
{
    if (!i_bstrServer || !*i_bstrServer || !i_bstrShare || !*i_bstrShare)
        return FALSE;

    TCHAR  szFileSystemName[MAX_PATH + 1] = {0};
    DWORD  dwMaxCompLength = 0, dwFileSystemFlags = 0;

    CComBSTR bstrRootPath = _T("\\\\");
    bstrRootPath += i_bstrServer;
    bstrRootPath += _T("\\");
    bstrRootPath += i_bstrShare;
    bstrRootPath += _T("\\"); // a trailing backslash is required
    
    BOOL bRet = GetVolumeInformation(bstrRootPath, NULL, 0, NULL, &dwMaxCompLength,
                         &dwFileSystemFlags, szFileSystemName, MAX_PATH);

    return (bRet && !lstrcmpi(_T("NTFS"), szFileSystemName) && 
            (dwFileSystemFlags & FILE_SUPPORTS_REPARSE_POINTS));
}

//----------------------------------------------------------------------------------
//
// S_OK: o_pbFound is valid
// S_FALSE: share is not eligible to host dfs root
// hr: other errors
//
HRESULT  CheckShare 
(
  IN  BSTR          i_bstrServer,
  IN  BSTR          i_bstrShare,
  OUT BOOL*         o_pbFound
)
{
    if (!i_bstrServer || !*i_bstrServer || !i_bstrShare || !*i_bstrShare || !o_pbFound)
        return E_INVALIDARG;

    *o_pbFound = FALSE;

    if (!lstrcmpi(i_bstrShare, _T("SYSVOL")) ||
        !lstrcmpi(i_bstrShare, _T("NETLOGON")) ||
        _istspace(i_bstrShare[0]) ||                        // exclude share with leading space
        _istspace(i_bstrShare[lstrlen(i_bstrShare) - 1])    // exclude share with trailing space
        )
        return S_FALSE;

    LPSHARE_INFO_1  lpBuffer = NULL;
    DWORD           dwNumEntries = 0;
    DWORD           dwTotalEntries = 0;
    DWORD           dwResumehandle = NULL;
    NET_API_STATUS  nstatRetVal = NetShareEnum(
                                                i_bstrServer,
                                                1L,          
                                                (LPBYTE*) &lpBuffer,
                                                0xFFFFFFFF,
                                                &dwNumEntries,
                                                &dwTotalEntries,
                                                &dwResumehandle 
                                              );
    if (NERR_Success != nstatRetVal)
    {
        if (ERROR_NO_MORE_ITEMS == nstatRetVal)
            return S_OK;
        else
            return HRESULT_FROM_WIN32(nstatRetVal);
    }

    HRESULT hr = S_OK;
    for (DWORD i = 0; i < dwNumEntries; i++)
    {
        if (!lstrcmpi(lpBuffer[i].shi1_netname, i_bstrShare))
        {
            if (lpBuffer[i].shi1_type != STYPE_DISKTREE)
                hr = S_FALSE;
            else
                *o_pbFound = TRUE;
            break;
        }
    }

    NetApiBufferFree ((LPVOID) lpBuffer);

    return hr;
}

HRESULT  CreateShare
(
  IN BSTR      i_bstrServerName,
  IN BSTR      i_bstrShareName, 
  IN BSTR      i_bstrComment,
  IN BSTR      i_bstrPath
)
/*++

Routine Description:

  This function creates an share of the specified name on the specified computer.

Arguments:

  i_bstrServerName  -  The machine on which the new share is to be created.
  i_bstrShareName    -  The name of the new share to be created.
  i_bstrComment    -  Comment to be given for the share.
  i_bstrPath      -  The physical path of the share.
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
  RETURN_INVALIDARG_IF_NULL(i_bstrShareName);
  RETURN_INVALIDARG_IF_NULL(i_bstrComment);
  RETURN_INVALIDARG_IF_NULL(i_bstrPath);

  SHARE_INFO_2  NewShareInfo;
  NewShareInfo.shi2_netname = i_bstrShareName;
  NewShareInfo.shi2_type = STYPE_DISKTREE;
  NewShareInfo.shi2_remark = i_bstrComment;
  NewShareInfo.shi2_permissions = ACCESS_ALL;
  NewShareInfo.shi2_max_uses = (DWORD)-1;
  NewShareInfo.shi2_current_uses = 0;
  NewShareInfo.shi2_path = i_bstrPath;
  NewShareInfo.shi2_passwd = NULL;

  DWORD dwError = 0;
  NET_API_STATUS nstatRetVal = NetShareAdd(i_bstrServerName, 2, (LPBYTE) &NewShareInfo, &dwError);

  return HRESULT_FROM_WIN32(nstatRetVal);
}


//----------------------------------------------------------------------------------
// Checks if \\<server>\<share>\x\y\z is on a valid disktree share
// and return the path local to the server
HRESULT GetFolderInfo
(
  IN  BSTR      i_bstrServerName,   // <server>
  IN  BSTR      i_bstrFolder,       // <share>\x\y\z
  OUT BSTR      *o_bstrPath         // return <share path>\x\y\z 
)
{
  if (!i_bstrServerName || !*i_bstrServerName || !i_bstrFolder || !*i_bstrFolder)
  {
    return(E_INVALIDARG);
  }

  //
  // first, test if folder \\<server>\<share>\x\y\z can be reached
  //
  CComBSTR bstrUNC;
  if (0 != mylstrncmp(i_bstrServerName, _T("\\\\"), 2))
  {
      bstrUNC = _T("\\\\");
      RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);
  }

  bstrUNC += i_bstrServerName;
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);
  bstrUNC += _T("\\");
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);
  bstrUNC += i_bstrFolder;
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);

  if (-1 == GetFileAttributes(bstrUNC))
      return HRESULT_FROM_WIN32(GetLastError());

  CComBSTR bstrShareName;
  CComBSTR bstrRestOfPath;
  TCHAR *p = _tcschr(i_bstrFolder, _T('\\'));
  if (p && *(p+1))
  {
    bstrRestOfPath = p+1;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrRestOfPath);

    bstrShareName = CComBSTR(p - i_bstrFolder, i_bstrFolder);
  } else
  {
    bstrShareName = i_bstrFolder;
  }
    
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrShareName);

  HRESULT        hr = S_OK;
  SHARE_INFO_2   *pShareInfo = NULL;
  NET_API_STATUS nstatRetVal = NetShareGetInfo (i_bstrServerName, bstrShareName, 2, (LPBYTE *)&pShareInfo);

  if (nstatRetVal != NERR_Success)
  {
    hr = HRESULT_FROM_WIN32(nstatRetVal);
  }
  else
  {
    if (STYPE_DISKTREE != pShareInfo->shi2_type &&
        STYPE_SPECIAL != pShareInfo->shi2_type) // we allow ADMIN$, C$ to be configured in Dfs/Frs
      hr = STG_E_NOTFILEBASEDSTORAGE;

    while (NULL != o_bstrPath)
    {
      CComBSTR bstrPath = pShareInfo->shi2_path;
      BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPath, &hr);

      if (!!bstrRestOfPath)
      {
        if ( _T('\\') != *(bstrPath + _tcslen(bstrPath) - 1) )
        {
          bstrPath += _T("\\");
          BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPath, &hr);
        }
        bstrPath += bstrRestOfPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPath, &hr);
      }
      *o_bstrPath = bstrPath.Detach();
      break;
    }

    NetApiBufferFree(pShareInfo);
  }

  return(hr);
}

void FreeNetNameList(NETNAMELIST *pList)
{
  if (pList && !pList->empty()) {
    for (NETNAMELIST::iterator i = pList->begin(); i != pList->end(); i++)
        delete (*i);
    pList->clear();
  }
}

void FreeRootInfoList(ROOTINFOLIST *pList)
{
  if (pList && !pList->empty()) {
    for (ROOTINFOLIST::iterator i = pList->begin(); i != pList->end(); i++)
        delete (*i);
    pList->clear();
  }
}

void FreeSubscriberList(SUBSCRIBERLIST *pList)
{
  if (pList && !pList->empty()) {
    for (SUBSCRIBERLIST::iterator i = pList->begin(); i != pList->end(); i++)
        delete (*i);
    pList->clear();
  }
}

HRESULT GetLocalComputerName(OUT BSTR* o_pbstrComputerName)
{
  _ASSERT(o_pbstrComputerName);

  DWORD   dwErr = 0;
  TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
  DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

  if ( !GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize) )
  {
    dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
    if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
      dwErr = GetLastError();
  }

  if (0 == dwErr)
  {
    *o_pbstrComputerName = SysAllocString(szBuffer);
    if (!*o_pbstrComputerName)
      dwErr = ERROR_OUTOFMEMORY;
  }

  return HRESULT_FROM_WIN32(dwErr);
}

HRESULT
GetDomainDfsRoots(
    OUT NETNAMELIST*  o_pDfsRootList,
    IN  LPCTSTR       i_lpszDomainName
)
{
  HRESULT hr = S_OK;

  FreeNetNameList(o_pDfsRootList);

  do {
    DFS_INFO_200 *pBuffer = NULL;
    DWORD   dwEntriesRead = 0;
    DWORD   dwResumeHandle = 0;
    DWORD   dwErr = NetDfsEnum(
                        const_cast<LPTSTR>(i_lpszDomainName),
                        200,            // Level,
                        (DWORD)-1,             // PrefMaxLen,
                        (LPBYTE *)&pBuffer,
                        &dwEntriesRead,
                        &dwResumeHandle
                    );

    if (NERR_Success != dwErr)
    {
        hr = (ERROR_NO_MORE_ITEMS == dwErr || ERROR_NOT_FOUND == dwErr) ? S_FALSE : HRESULT_FROM_WIN32(dwErr);
        break;
    }

    NETNAME *pCurrent = NULL;
    for (DWORD i = 0; i < dwEntriesRead; i++)
    {
      pCurrent = new NETNAME;
      if (!pCurrent)
      {
        hr = E_OUTOFMEMORY;
        break;
      }

      pCurrent->bstrNetName = pBuffer[i].FtDfsName;
      if (!pCurrent->bstrNetName)
      {
        delete pCurrent;
        hr = E_OUTOFMEMORY;
        break;
      }

      o_pDfsRootList->push_back(pCurrent);
    }

    NetApiBufferFree(pBuffer);

  } while (0);

  if (FAILED(hr))
    FreeNetNameList(o_pDfsRootList);

  return hr;
}

HRESULT
GetMultiDfsRoots(
    OUT ROOTINFOLIST* o_pDfsRootList,
    IN  LPCTSTR       i_lpszScope
)
{
    if (!i_lpszScope || !*i_lpszScope)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    FreeRootInfoList(o_pDfsRootList);

    do {
        DFS_INFO_200 *pBuffer = NULL;
        DWORD   dwEntriesRead = 0;
        DWORD   dwResumeHandle = 0;
        DWORD   dwErr = NetDfsEnum(
                                const_cast<LPTSTR>(i_lpszScope),
                                200,            // Level,
                                (DWORD)-1,             // PrefMaxLen,
                                (LPBYTE *)&pBuffer,
                                &dwEntriesRead,
                                &dwResumeHandle
                                );

        if (NERR_Success != dwErr)
        {
            hr = (ERROR_NO_MORE_ITEMS == dwErr || ERROR_NOT_FOUND == dwErr) ? S_FALSE : HRESULT_FROM_WIN32(dwErr);
            break;
        }

        ROOTINFO *pCurrent = NULL;
        for (DWORD i = 0; i < dwEntriesRead; i++)
        {
            CComBSTR bstrEntryPath = _T("\\\\");
            bstrEntryPath += i_lpszScope;
            bstrEntryPath += _T("\\");
            bstrEntryPath += pBuffer[i].FtDfsName;

            PDFS_INFO_2     pDfsInfo = NULL;
            NET_API_STATUS  nRet = NetDfsGetInfo(
                                      bstrEntryPath,
                                      NULL,
                                      NULL,
                                      2,
                                      (LPBYTE*) &pDfsInfo
                                    );
            if (NERR_Success != nRet)
                continue;

            pCurrent = new ROOTINFO;
            if (pCurrent)
            {
                if ((pDfsInfo->State & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_AD_BLOB)
                    pCurrent->enumRootType = DFS_TYPE_FTDFS;
                else
                    pCurrent->enumRootType = DFS_TYPE_STANDALONE;

                pCurrent->bstrRootName = pBuffer[i].FtDfsName;
            }

            NetApiBufferFree(pDfsInfo);

            if (!pCurrent)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (!pCurrent->bstrRootName)
            {
                delete pCurrent;
                hr = E_OUTOFMEMORY;
                break;
            }

            o_pDfsRootList->push_back(pCurrent);
        }

        NetApiBufferFree(pBuffer);

    } while (0);

    if (FAILED(hr))
        FreeRootInfoList(o_pDfsRootList);

    return hr;
}

/*
bool 
IsDfsPath
(
     LPTSTR                i_lpszNetPath
)
{
    if ( S_OK != CheckUNCPath(i_lpszNetPath) )
        return false;

    CComBSTR bstrPath = i_lpszNetPath;
    if (!bstrPath)
        return false; // out of memory

    TCHAR   *s = _tcschr(bstrPath + 2, _T('\\'));   // points to the 3rd backslash
    TCHAR   *p = bstrPath + bstrPath.Length();      // points to the ending char '\0'
    bool    bIsDfsPath = false;

    do
    {
        *p = _T('\0');

        PDFS_INFO_1 pDfsInfo1 = NULL;
        DWORD       dwStatus = NetDfsGetClientInfo (
                                    bstrPath,            // dir path as entrypath
                                    NULL,                    // No server name required
                                    NULL,                    // No share required
                                    1,                        // level 1
                                    (LPBYTE *)&pDfsInfo1    // out buffer.
                                 );

        if (NERR_Success == dwStatus)
        {
            bIsDfsPath = true;
            NetApiBufferFree(pDfsInfo1);
            break;
        }

        p--;

        while (_T('\\') != *p && p > s)
        {
            p--;
        }
    } while (p > s);

    return bIsDfsPath;
}
*/

HRESULT CheckUNCPath(
  IN LPCTSTR i_lpszPath
  )
/*++

Routine Description:

  Checks if path is of UNC format.
--*/  
{
  //"someserver\someshare\somedir\.."    - Invalid
  //"\\Server                - Invalid
  //"\\someserver\someshare\..      - Valid
  //"\\someserver\someshare\Somedir\..  - Valid
  
  RETURN_INVALIDARG_IF_NULL(i_lpszPath);
    
  DWORD             dwRetFlags = 0;
  NET_API_STATUS    nStatus = I_NetPathType(NULL, (LPTSTR)i_lpszPath, &dwRetFlags, 0);
  if (NERR_Success != nStatus)
    return HRESULT_FROM_WIN32(nStatus);

  return (ITYPE_UNC == dwRetFlags) ? S_OK : S_FALSE;
}

HRESULT GetUNCPathComponent(
    IN  LPCTSTR i_lpszPath,
    OUT BSTR*   o_pbstrComponent,
    IN  UINT    i_nStartBackslashes,  // index starting from 1
    IN  UINT    i_nEndBackslashes     // index starting from 1
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrComponent);
    RETURN_INVALIDARG_IF_TRUE(i_nStartBackslashes < 2);
    RETURN_INVALIDARG_IF_TRUE(0 != i_nEndBackslashes && i_nEndBackslashes <= i_nStartBackslashes);

    *o_pbstrComponent = NULL;

    HRESULT hr = CheckUNCPath(i_lpszPath);
    RETURN_INVALIDARG_IF_TRUE(S_OK != hr);

    UINT nDeltaBackslashes = i_nEndBackslashes ? (i_nEndBackslashes - i_nStartBackslashes) : 0;
    
    TCHAR *p = (LPTSTR)i_lpszPath + 2;    // skip the first 2 backslashes
    i_nStartBackslashes -= 2;

    // locate the starting backslash
    while (*p && i_nStartBackslashes)
    {
        if (_T('\\') == *p)
            i_nStartBackslashes--;

        p++;
    }
    if (!*p)
        return hr;

    // locate the ending backslash
    TCHAR *s = p;
    if (!nDeltaBackslashes)
    {
        s += _tcslen(p);
    } else
    {
        while (*s && nDeltaBackslashes)
        {
            if (_T('\\') == *s)
                nDeltaBackslashes--;

            s++;
        }
        if (*s)
            s--;
    }

    // p points at the first char after the starting backslash, and
    // s points at the ending backslash or the ending char '\0'

    *o_pbstrComponent = SysAllocStringLen(p, s - p);    
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrComponent);

    return S_OK;
}

// return TRUE if string matches the filter string, case-insensitive match
BOOL FilterMatch(LPCTSTR lpszString, FILTERDFSLINKS_TYPE lLinkFilterType, LPCTSTR lpszFilter)
{
    BOOL bResult = TRUE;

    switch (lLinkFilterType)
    {
    case FILTERDFSLINKS_TYPE_BEGINWITH:
        if (!lpszString || !lpszFilter)
            return FALSE;
        bResult = !mylstrncmpi(lpszString, lpszFilter, lstrlen(lpszFilter));
        break;
    case FILTERDFSLINKS_TYPE_CONTAIN:
        {
            if (!lpszString || !lpszFilter)
                return FALSE;
            TCHAR* pszStringLower = _tcsdup(lpszString);
            TCHAR* pszFilterLower = _tcsdup(lpszFilter);
            if (!pszStringLower || !pszFilterLower)
                bResult = FALSE;
            else
                bResult = (NULL != _tcsstr(_tcslwr(pszStringLower), _tcslwr(pszFilterLower)));

            if (pszStringLower)
                free(pszStringLower);
            if (pszFilterLower)
                free(pszFilterLower);
        }
        break;
    default:
        break;
    }
    
    return bResult;
}

HRESULT IsHostingDfsRoot(IN BSTR i_bstrServer, OUT BSTR* o_pbstrRootEntryPath)
{
  if (o_pbstrRootEntryPath)
    *o_pbstrRootEntryPath = NULL;

  DWORD        dwEntriesRead = 0;
  DWORD        dwResumeHandle = 0;
  DFS_INFO_1*  pDfsInfoLevel1 = NULL;

  NET_API_STATUS dwRet = NetDfsEnum(
                  i_bstrServer,
                  1,
                  sizeof(DFS_INFO_1), // get 1 entry
                  (LPBYTE *)&pDfsInfoLevel1,
                  &dwEntriesRead,
                  &dwResumeHandle
                );

  if (ERROR_NO_MORE_ITEMS == dwRet || ERROR_NOT_FOUND == dwRet)
    return S_FALSE;

  HRESULT hr = S_OK;
  if (NERR_Success == dwRet)
  {
    if (o_pbstrRootEntryPath)
    {
      *o_pbstrRootEntryPath = SysAllocString(pDfsInfoLevel1->EntryPath);
      if (!*o_pbstrRootEntryPath)
        hr = E_OUTOFMEMORY;
    }
    NetApiBufferFree(pDfsInfoLevel1);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}

/*
void GetTimeDelta(LPCTSTR str, SYSTEMTIME* ptime0, SYSTEMTIME* ptime1)
{
    dfsDebugOut((_T("%s, delta = %d millisec \n"), str,
        ((ptime1->wMinute - ptime0->wMinute) * 60 +
         (ptime1->wSecond - ptime0->wSecond)) * 1000 +
        (ptime1->wMilliseconds - ptime0->wMilliseconds)
        ));
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\netutils.h ===
/*++
Module Name:

NetUtils.h

Abstract:
  This is the header file for the utility functions for Network APIs.

*/


#ifndef _NETUTILS_H
#define _NETUTILS_H

#include "stdafx.h"
#include <wtypes.h>      // For define types like DWORD, HANDLE etc.
#include <oleauto.h>    // For SysAllocString().
#include <lmerr.h>      // For Lan Manager API error codes and return value types.
#include <lmcons.h>      // For Lan Manager API constants.
#include <lmserver.h>    // For Server specific Lan Manager APIs.  
#include <lmaccess.h>    // For NetGetDCInfo.
#include <lmapibuf.h>    // For NetApiBufferFree.
#include <shlobj.h>
#include <dsclient.h>
#include <lmwksta.h>
#include <lmshare.h>
#include <icanon.h>      // I_Net
#include "dfsenums.h"

#include <list>
using namespace std;

class NETNAME                // Structure to store and send a list of names
{
public:
  CComBSTR    bstrNetName;      // To store Name of Domain, Server, Share etc.
};

typedef list<NETNAME*>      NETNAMELIST;

class ROOTINFO
{
public:
    CComBSTR      bstrRootName;
    enum DFS_TYPE enumRootType;
};

typedef list<ROOTINFO*>      ROOTINFOLIST;

class SUBSCRIBER 
{
public:
  CComBSTR    bstrMemberDN; 
  CComBSTR    bstrRootPath;
};

typedef list<SUBSCRIBER*>      SUBSCRIBERLIST;

/*----------------------------------------------------------------------
          H E L P E R   F U N C T I O N S 
------------------------------------------------------------------------*/

            //  Recursive function to flatten the domain tree returned by GetDomains() method
            //  of IBrowserDomainTree into a NETNAME list.
            //  This is done by using a depth first algorithm.
            //  Used in Get50Domains().

HRESULT FlatAdd
(
  IN DOMAIN_DESC*    i_pDomDesc,        // Pointer to the Domain Description Structure returned by IBrowserDomainTree::GetDomains()
  OUT NETNAMELIST*  o_pDomainList      // Pointer to the list of NETNAME is returned here.
);

/*----------------------------------------------------------------------
      D O M A I N    R E L A T E D   F U N C T I O N S 
------------------------------------------------------------------------*/

            // Returns the list of all 5.0 domains  present in the DS Domain Tree only.
            // The domain names will be in DNS forms
HRESULT Get50Domains
(
  OUT NETNAMELIST*  o_pDomains        // List of NETNAME structures.
);

            // Contacts the domain and determines if it is 5.0 Domain.
            // The domain name can be in DNS form.
            // returns the netbios name if second parameter is not null.
HRESULT Is50Domain
(
  IN BSTR      i_bstrDomain,
  OUT BSTR*    o_bstrDnsDomainName = NULL    
);

/*----------------------------------------------------------------------
      S E R V E R   R E L A T E D   F U N C T I O N S 
------------------------------------------------------------------------*/

            // Gets the domain, and OS version of a machine.
            // If the last parameter in not null the the current
            // machine name is returned in it.
HRESULT GetServerInfo
(
  IN  BSTR    i_bstrServer,      // NULL means use current server.
  OUT BSTR    *o_pbstrDomain = NULL,      
  OUT BSTR    *o_pbstrNetbiosName = NULL,
  OUT BOOL    *o_pbValidDSObject = NULL,
  OUT BSTR    *o_pbstrDnsName = NULL,
  OUT BSTR    *o_pbstrGuid = NULL,
  OUT BSTR    *o_pbstrFQDN = NULL,
  OUT SUBSCRIBERLIST *o_pFRSRootList = NULL,
  OUT long    *o_lMajorNo = NULL,
  OUT long    *o_lMinorNo = NULL
);

HRESULT  IsServerRunningDfs
(
  IN BSTR      i_bstrServer
);

BOOL CheckReparsePoint(IN BSTR i_bstrServer, IN BSTR i_bstrShare);

HRESULT  CheckShare 
(
  IN  BSTR      i_bstrServer,
  IN  BSTR      i_bstrShare,
  OUT BOOL*     o_pbFound
);

HRESULT  CreateShare
(
  IN BSTR      i_bstrServerName,
  IN BSTR      i_bstrShareName, 
  IN BSTR      i_bstrComment,
  IN BSTR      i_bstrPath
);

// Checks if \\<server>\<share>\x\y\z is on a valid disktree share
// and return the path local to the server
HRESULT GetFolderInfo
(
  IN  BSTR      i_bstrServerName,   // <server>
  IN  BSTR      i_bstrFolder,       // <share>\x\y\z
  OUT BSTR      *o_bstrPath = NULL // return <share path>\x\y\z 
);

void FreeNetNameList(NETNAMELIST *pList);
void FreeRootInfoList(ROOTINFOLIST *pList);
void FreeSubscriberList(SUBSCRIBERLIST *pList);

HRESULT GetLocalComputerName(OUT BSTR* o_pbstrComputerName);

HRESULT
GetDomainDfsRoots(
    OUT NETNAMELIST*  o_pDfsRootList,
    IN  LPCTSTR       i_lpszDomainName
);

HRESULT
GetMultiDfsRoots(
    OUT ROOTINFOLIST* o_pDfsRootList,
    IN  LPCTSTR       i_lpszScope
);

/*
bool 
IsDfsPath
(
 	LPTSTR				i_lpszNetPath
);
*/

HRESULT CheckUNCPath(
  IN LPCTSTR i_lpszPath
);

HRESULT GetUNCPathComponent(
    IN  LPCTSTR i_lpszPath,
    OUT BSTR*   o_pbstrComponent,
    IN  UINT    i_nStartBackslashes,  // index starting from 1
    IN  UINT    i_nEndBackslashes     // index starting from 1
);

BOOL FilterMatch(LPCTSTR lpszString, FILTERDFSLINKS_TYPE lLinkFilterType, LPCTSTR lpszFilter);

HRESULT IsHostingDfsRoot(IN BSTR i_bstrServer, OUT BSTR* o_pbstrRootEntryPath = NULL);

/*
void GetTimeDelta(LPCTSTR str, SYSTEMTIME* ptime0, SYSTEMTIME* ptime1);
*/
#endif  //#ifndef _NETUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\common\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_)
#define AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "dfsDebug.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfscore.cpp ===
// DfsCore.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f DfsCoreps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DfsCore.h"

#include "DfsCore_i.c"
#include "DfsRoot.h"
#include "DfsRep.h"
#include "DfsJP.h"
#include "RepSet.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DfsRoot, CDfsRoot)
    OBJECT_ENTRY(CLSID_DfsReplica, CDfsReplica)
    OBJECT_ENTRY(CLSID_DfsJunctionPoint, CDfsJunctionPoint)
    OBJECT_ENTRY(CLSID_ReplicaSet, CReplicaSet)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfsjp.h ===
/*++
Module Name:
    DfsJP.h

Abstract:
    This module contains the declaration of the DfsJunctionPoint COM Class. This class
    provides methods to get information of a junction point and to enumerate 
    Replicas of the junction point. It implements IDfsJunctionPoint and provides
    an enumerator through get__NewEnum().
--*/


#ifndef _DFSJP_H
#define _DFSJP_H


#include "resource.h"                                                // main symbols
#include "dfsenums.h"

#include <list>
using namespace std;

class REPLICAINFO
{
public:
    CComBSTR m_bstrServerName;
    CComBSTR m_bstrShareName;

    HRESULT Init(BSTR bstrServerName, BSTR bstrShareName)
    {
        ReSet();

        RETURN_INVALIDARG_IF_TRUE(!bstrServerName);
        RETURN_INVALIDARG_IF_TRUE(!bstrShareName);

        HRESULT hr = S_OK;
        do {
            m_bstrServerName = bstrServerName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServerName, &hr);
            m_bstrShareName = bstrShareName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrShareName, &hr);
        } while (0);

        if (FAILED(hr))
            ReSet();

        return hr;
    }

    void ReSet()
    {
        if (m_bstrServerName)    m_bstrServerName.Empty();
        if (m_bstrShareName)    m_bstrShareName.Empty();
    }

    REPLICAINFO* Copy()
    {
        REPLICAINFO* pNew = new REPLICAINFO;
        
        if (pNew)
        {
            HRESULT hr = S_OK;
            do {
                pNew->m_bstrServerName = m_bstrServerName;
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrServerName, &hr);

                pNew->m_bstrShareName = m_bstrShareName;
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrShareName, &hr);
            } while (0);

            if (FAILED(hr))
            {
                delete pNew;
                pNew = NULL;
            }
        }

        return pNew;
    }
};

typedef list<REPLICAINFO*>        REPLICAINFOLIST;

class ATL_NO_VTABLE CDfsJunctionPoint : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsJunctionPoint, &CLSID_DfsJunctionPoint>,
    public IDispatchImpl<IDfsJunctionPoint, &IID_IDfsJunctionPoint, &LIBID_DFSCORELib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DFSJP)

BEGIN_COM_MAP(CDfsJunctionPoint)
    COM_INTERFACE_ENTRY(IDfsJunctionPoint)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDfsJunctionPoint
public:
    //Contructor.
    CDfsJunctionPoint();

    //Destructor.
    ~CDfsJunctionPoint();

                                                            // Returns a DfsReplica Enumerator.
    STDMETHOD(get__NewEnum)
    (
        /*[out, retval]*/ 
        LPUNKNOWN *pVal                                        // The IEnumVARIANT Pointer is returned in this.
    );

                                                            // Returns the number of replicas for 
    STDMETHOD(get_CountOfDfsReplicas)                        // this Junction Point
    (
        /*[out, retval]*/ long *pVal                        // The number of replicas.
    );

                                                            // Intialises a DfsJunctionPoint COM 
    STDMETHOD(Initialize)                                    // Object. Should be called after CoCreateInstance.
    (
        /*[in]*/ IUnknown *i_piDfsRoot,
        /*[in]*/ BSTR i_szEntryPath,                        // The junction point Dfs Path. Eg. "//DOM/Dfs/JP".
        /*[in]*/ BOOL i_bReplicaSetExist,
        /*[in]*/ BSTR i_bstrReplicaSetDN
    );
    
                                                             // Gets the comment associated with 
    STDMETHOD(get_Comment)                                    // the Junctionpoint.
    (
        /*[out, retval]*/ BSTR *pVal                        // The Comment.
    );
    
                                                            // Sets the comment. Sets in memory as 
    STDMETHOD(put_Comment)                                    // well in the network PKT.
    (
        /*[in]*/ BSTR newVal
    );
    
                                                            // Gets the Junction Name. Justs gets 
                                                            // the last part of the entry path.
    STDMETHOD(get_JunctionName)                                // E.g "usa\Products" for "\\DOM\Dfs\usa\Products".
    (
        /*[in]*/ BOOL i_bDfsNameIncluded,
        /*[out, retval]*/ BSTR *pVal                        // The junction name.
    );

                                                            // Gets the entry path of the junction 
    STDMETHOD(get_EntryPath)                                // point. Eg. "\\Dom\Dfs\usa\Products".
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
                                                            // Get Dfs JuncitonPoint State.
    STDMETHOD(get_State)
    (
        /*[out, retval]*/ long *pVal                        // The state of the junction point.
    );

    STDMETHOD(get_ReplicaSetDN)                             // get the prefix DN of the corresponding replica set.
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_ReplicaSetExist)
    (
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(get_ReplicaSetExistEx)
    (
        /*[out]*/ BSTR* o_pbstrDC,
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(put_ReplicaSetExist)
    (
        /*[in]*/ BOOL newVal
    );

    STDMETHOD( AddReplica )                                    // Adds a new replica to the junction point.
    (
        /* [in]*/ BSTR i_szServerName,
        /* [in]*/ BSTR i_szShareName,
        /* [out, retval]*/ VARIANT* o_pvarReplicaObject
    );

    STDMETHOD( RemoveReplica )                                // Removes a Replica from the Junction Point.
    (
        /* [in]*/ BSTR i_szServerName,
        /* [in]*/ BSTR i_szShareName
    );

    STDMETHOD( RemoveAllReplicas )                                // Delete the Junction Point.
    (
    );

    STDMETHOD( get_Timeout )
    (
        /*[out, retval]*/    long*        pVal
    );
                                                            // Sets the time out for the junction point.
    STDMETHOD( put_Timeout )
    (
        /*[in]*/    long        newVal
    );

    STDMETHOD( DeleteRootReplica )
    (
        /*[in]*/ BSTR i_bstrDomainName,
        /*[in]*/ BSTR i_bstrDfsName,
        /*[in]*/ BSTR i_bstrServerName,
        /*[in]*/ BSTR i_bstrShareName,
        /*[in]*/ BOOL i_bForce
    );

    STDMETHOD( GetOneRootReplica )
    (
        /*[out]*/ BSTR* o_pbstrServerName,
        /*[out]*/ BSTR* o_pbstrShareName
    );

    STDMETHOD(InitializeEx)
    (
        /*[in]*/ IUnknown   *piDfsRoot,
        /*[in]*/ VARIANT    *pVar,
        /*[in]*/ BOOL       bReplicaSetExist,
        /*[in]*/ BSTR       bstrReplicaSetDN
    );
    
protected:
    //Member Variables
    CComPtr<IDfsRoot> m_spiDfsRoot;
    CComBSTR        m_bstrEntryPath;
    CComBSTR        m_bstrJunctionName;   // given \\ntbuilds\release\dir1\dir2, it's dir1\dir2
    CComBSTR        m_bstrJunctionNameEx; // given \\ntbuilds\release\dir1\dir2, it's release\dir1\dir2
    CComBSTR        m_bstrReplicaSetDN;
    BOOL            m_bReplicaSetExist;
    REPLICAINFOLIST m_Replicas;                            // List of Replicas.

protected:
    //Helper Functions
    void _FreeMemberVariables();

    HRESULT _GetReplicaSetDN
    (
        BSTR i_szEntryPath
    );
    
    HRESULT _GetDfsType(
        OUT DFS_TYPE* o_pdwDfsType,
        OUT BSTR*     o_pbstrDomainName,
        OUT BSTR*     o_pbstrDomainDN
    );

    HRESULT _Init(
        PDFS_INFO_3 pDfsInfo,
        BOOL        bReplicaSetExist,
        BSTR        bstrReplicaSetDN
        );

    HRESULT _AddToReplicaList
    (
        BSTR bstrServerName,
        BSTR bstrShareName
    );

    void _DeleteFromReplicaList(BSTR bstrServerName, BSTR bstrShareName);
};

#endif //_DFSJP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfsrep.h ===
/*++
Module Name:
    DfsRep.h

Abstract:
    This file contains the declaration of the CDfsReplica COM Class. This class
    provides methods to get information of a Dfs replica.
--*/


#ifndef __DFSREP_H_
#define __DFSREP_H_

#include "resource.h"       // main symbols
#include "dfsenums.h"

class ATL_NO_VTABLE CDfsReplica : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsReplica, &CLSID_DfsReplica>,
    public IDispatchImpl<IDfsReplica, &IID_IDfsReplica, &LIBID_DFSCORELib>
{

public:                                                                
    CDfsReplica();
    ~CDfsReplica();

DECLARE_REGISTRY_RESOURCEID(IDR_DFSREP)

BEGIN_COM_MAP(CDfsReplica)
    COM_INTERFACE_ENTRY(IDfsReplica)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


// IDfsReplica
                                                        // Gets the entry path of junction point 
    STDMETHOD(get_EntryPath)                            // for which the replica is providing storage.
    (
        /*[out, retval]*/ BSTR *pVal
    );

                                                        // Initialize DfsReplica object. Should 
    STDMETHOD(Initialize)                                // be called after CoCreateInstance
    (
        /*[in]*/ BSTR i_szEntryPath,                    // Entry path of junction point.
        /*[in]*/ BSTR i_szStorageServerName,            // server hosting share.
        /*[in]*/ BSTR i_szStorageShareName                // share name for replica.
    );
    
                                                        // Get the storage share name.
    STDMETHOD(get_StorageShareName)
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
                                                        // Get the storage share name.
    STDMETHOD(get_StorageServerName)
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
                                                        // Get the dfs replica state.
    STDMETHOD( get_State )
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD( put_State )                                // Set the state of the Dfs Replica.
    (
        /*[in]*/ long        newVal
    );

    STDMETHOD( FindTarget )                             // verify this target's existence
    (
    );

// Member variables.
protected:

    void        _FreeMemberVariables();
    CComBSTR    m_bstrStorageShareName;
    CComBSTR    m_bstrStorageServerName;
    CComBSTR    m_bstrEntryPath;
};

#endif //__DFSREP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfsjp.cpp ===
/*++
Module Name:

    DfsJP.cpp

Abstract:

  This COM Class provides method to get information of Dfs 
  Junction Points and to enumerate replica of a junction point.
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "DfsJP.h"
#include "DfsRep.h"
#include "JPEnum.h"
#include "RepEnum.h"
#include "netutils.h"
#include "ldaputils.h"
#include <dsgetdc.h>

/////////////////////////////////////////////////////////////////////////////////////////////////
// CDfsJuntionPoint

/////////////////////////////////////////////////////////////////////////////////////////////////


CDfsJunctionPoint :: CDfsJunctionPoint ()
{
  dfsDebugOut((_T("CDfsJunctionPoint::CDfsJunctionPoint this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////


CDfsJunctionPoint :: ~CDfsJunctionPoint ()
{  
  _FreeMemberVariables();
  dfsDebugOut((_T("CDfsJunctionPoint::~CDfsJunctionPoint this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_State
(
  long*        pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  //
  // See if the DFS entry path can be reached on the network.
  // which has nothing to do with its targets states
  //
  DWORD dwErr = GetFileAttributes(m_bstrEntryPath);
  if (0xffffffff == dwErr)    // We failed to get the file attributes for entry path
  {
    *pVal = DFS_STATE_UNREACHABLE;
  } else
  {
    *pVal = DFS_STATE_REACHABLE;
  }

  return(S_OK);
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_EntryPath
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  *pVal = m_bstrEntryPath.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_JunctionName
(
  BOOL           i_bDfsNameIncluded,
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  if (i_bDfsNameIncluded)
    *pVal = m_bstrJunctionNameEx.Copy ();
  else
    *pVal = m_bstrJunctionName.Copy ();

  if (!*pVal)
    return E_OUTOFMEMORY;
  
  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_Comment
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  DFS_INFO_100*  pInfoBuffer = NULL;
  NET_API_STATUS nRet = NetDfsGetInfo(
                            m_bstrEntryPath,
                            NULL,
                            NULL,
                            100,
                            (LPBYTE*)&pInfoBuffer
                        );
  if (NERR_Success == nRet)
  {
      *pVal = SysAllocString(pInfoBuffer->Comment);

      NetApiBufferFree(pInfoBuffer);

      if (!*pVal)
        return E_OUTOFMEMORY;
  }

  return HRESULT_FROM_WIN32(nRet);
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: put_Comment
(
  BSTR          newVal
)
{
  DFS_INFO_100   InfoBuffer = {(newVal ? newVal : _T(""))};
  NET_API_STATUS nRet = NetDfsSetInfo  (
                            m_bstrEntryPath,
                            NULL,
                            NULL,
                            100,
                            (LPBYTE) &InfoBuffer
                        );

  return HRESULT_FROM_WIN32(nRet);
}


/////////////////////////////////////////////////////////////////////////////
// get_Timeout


STDMETHODIMP CDfsJunctionPoint :: get_Timeout
(
  long*          pVal
)
{
  if (!pVal || !m_bstrEntryPath)
    return E_INVALIDARG;

  DFS_INFO_4*  pInfoBuffer = NULL;
  NET_API_STATUS nRet = NetDfsGetInfo(
                            m_bstrEntryPath,
                            NULL,
                            NULL,
                            4,
                            (LPBYTE*)&pInfoBuffer
                        );
  if (NERR_Success == nRet)
  {
      *pVal = pInfoBuffer->Timeout;

      NetApiBufferFree(pInfoBuffer);
  }

  return HRESULT_FROM_WIN32(nRet);
}


/////////////////////////////////////////////////////////////////////////////
// put_Timeout


STDMETHODIMP CDfsJunctionPoint :: put_Timeout
(
  long          newVal
)
{
    if (!m_bstrEntryPath)
        return E_INVALIDARG;

    DFS_INFO_102    DfsInfoLevel102 = {newVal};
    NET_API_STATUS    nRet = NetDfsSetInfo  (
                              m_bstrEntryPath,
                              NULL,
                              NULL,
                              102,
                              (LPBYTE) &DfsInfoLevel102
                            );

    return HRESULT_FROM_WIN32(nRet);
}

/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_ReplicaSetDN
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  if (!m_bstrReplicaSetDN)
  {
    hr = _GetReplicaSetDN(m_bstrEntryPath);
    RETURN_IF_FAILED(hr);
  }

  *pVal = m_bstrReplicaSetDN.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_ReplicaSetExist
(
  BOOL*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  *pVal = m_bReplicaSetExist;

  return S_OK;
}

STDMETHODIMP CDfsJunctionPoint :: get_ReplicaSetExistEx
(
  BSTR*          o_pbstrDC,
  BOOL*          pVal
)
{
  if (!pVal || !o_pbstrDC)
    return E_INVALIDARG;

  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  if (!m_bstrReplicaSetDN)
  {
    hr = _GetReplicaSetDN(m_bstrEntryPath);
    RETURN_IF_FAILED(hr);
  }

  DFS_TYPE dwDfsType = DFS_TYPE_UNASSIGNED;
  CComBSTR bstrDomainName;
  CComBSTR bstrDomainDN;
  hr = _GetDfsType(&dwDfsType, &bstrDomainName, &bstrDomainDN);
  RETURN_IF_FAILED(hr);

  m_bReplicaSetExist = FALSE;
  if (dwDfsType == DFS_TYPE_FTDFS)
  {
    CComBSTR bstrDN = m_bstrReplicaSetDN;
    if ((BSTR)bstrDN) bstrDN += _T(",");
    if ((BSTR)bstrDN) bstrDN += bstrDomainDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDN);

    PLDAP pldap = NULL;
    CComBSTR bstrDC;
    hr = ConnectToDS(bstrDomainName, &pldap, &bstrDC);
    if (SUCCEEDED(hr))
    {
        m_bReplicaSetExist = (S_OK == IsValidObject(pldap, bstrDN));

        CloseConnectionToDS(pldap);

        *o_pbstrDC = bstrDC.Copy();
        if (!*o_pbstrDC)
            hr = E_OUTOFMEMORY;

    }
  }

  *pVal = m_bReplicaSetExist;

  return hr;
}

HRESULT CDfsJunctionPoint :: _GetDfsType(
    OUT DFS_TYPE* o_pdwDfsType,
    OUT BSTR*     o_pbstrDomainName,
    OUT BSTR*     o_pbstrDomainDN
)
{
    if (!o_pdwDfsType)
        return E_INVALIDARG;

    if (!m_spiDfsRoot)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    m_spiDfsRoot->get_DfsType((long *)o_pdwDfsType);
    if (*o_pdwDfsType == DFS_TYPE_FTDFS)
    {
        if (o_pbstrDomainName)
            hr = m_spiDfsRoot->get_DomainName(o_pbstrDomainName);

        if (SUCCEEDED(hr) && o_pbstrDomainDN)
            hr = m_spiDfsRoot->get_DomainDN(o_pbstrDomainDN);
    }

    return hr;
}

STDMETHODIMP CDfsJunctionPoint :: put_ReplicaSetExist
(
  BOOL          newVal
)
{
  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  m_bReplicaSetExist = newVal;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT CDfsJunctionPoint::_Init(
    PDFS_INFO_3 pDfsInfo, 
    BOOL        bReplicaSetExist,
    BSTR        bstrReplicaSetDN
)
{
    _FreeMemberVariables();

    if (bReplicaSetExist && (!bstrReplicaSetDN || !*bstrReplicaSetDN))
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    do {
        m_bstrEntryPath = pDfsInfo->EntryPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath, &hr);

        hr = GetUNCPathComponent(m_bstrEntryPath, &m_bstrJunctionName, 4, 0);
        BREAK_IF_FAILED(hr);

        hr = GetUNCPathComponent(m_bstrEntryPath, &m_bstrJunctionNameEx, 3, 0);
        BREAK_IF_FAILED(hr);

        PDFS_STORAGE_INFO pStorage = pDfsInfo->Storage;

        for (DWORD i = 0; i < pDfsInfo->NumberOfStorages && pStorage; i++, pStorage++)
        {
            hr = _AddToReplicaList(pStorage->ServerName, pStorage->ShareName);
            BREAK_IF_FAILED(hr);
        }
        
        m_bReplicaSetExist = bReplicaSetExist;

        if (m_bReplicaSetExist)
        {
            m_bstrReplicaSetDN = bstrReplicaSetDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        }
    } while (0);

    if (FAILED(hr))
        _FreeMemberVariables();

    return hr;
}

STDMETHODIMP CDfsJunctionPoint :: Initialize
(
  IUnknown *i_piDfsRoot,
  BSTR i_szEntryPath,
  BOOL i_bReplicaSetExist,
  BSTR i_bstrReplicaSetDN
)
{
/*++

Routine Description:
  
  This initializes the junction point. Before this method is called the 
  data stored by DfsJunctionPoint is NULL. If initialization fails the
  properties will be NULL.

Arguments:

  i_szEntryPath - The the Entry Path to the Junction Point.
--*/

    RETURN_INVALIDARG_IF_NULL(i_piDfsRoot);
    RETURN_INVALIDARG_IF_NULL(i_szEntryPath);

    if ((IDfsRoot *)m_spiDfsRoot)
        m_spiDfsRoot.Release();
    i_piDfsRoot->QueryInterface(IID_IDfsRoot, (void **)&m_spiDfsRoot);

    PDFS_INFO_3     pDfsInfo = NULL;
    NET_API_STATUS  nRet = NetDfsGetInfo(
                              i_szEntryPath,
                              NULL,
                              NULL,
                              3,
                              (LPBYTE*) &pDfsInfo
                            );

    if (NERR_Success != nRet)
    {
        if (NERR_DfsNoSuchVolume == nRet)
            return S_FALSE; // no such link
        else
            return HRESULT_FROM_WIN32(nRet);
    }

    HRESULT hr = _Init(pDfsInfo, i_bReplicaSetExist, i_bstrReplicaSetDN);

    NetApiBufferFree(pDfsInfo);

    return hr;
}

#define ARRAY_COUNT_FOR_DFS_INFO_3          2
#define ARRAY_COUNT_FOR_DFS_STORAGE_INFO    2

// Note: not all fields of pDfsInfo is filled in, e.g., comment/timeout are not filled in
HRESULT VariantToDfsInfoLevel3(VARIANT *pVar, OUT PDFS_INFO_3 *ppDfsInfo)
{
    *ppDfsInfo = NULL;

    if (V_VT(pVar) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa_2 = V_ARRAY(pVar);
    long        lLowerBound = 0;
    long        lUpperBound = 0;
    long        lCount = 0;

    if (!psa_2)
        return E_INVALIDARG;

    SafeArrayGetLBound(psa_2, 1, &lLowerBound );
    SafeArrayGetUBound(psa_2, 1, &lUpperBound );
    lCount = lUpperBound - lLowerBound + 1;
    if (lCount != ARRAY_COUNT_FOR_DFS_INFO_3)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    VARIANT HUGEP *pArray_2;
    SafeArrayAccessData(psa_2, (void HUGEP **) &pArray_2);
    do {
        if (V_VT(&(pArray_2[0])) != VT_BSTR   ||
            V_VT(&(pArray_2[1])) != (VT_ARRAY | VT_VARIANT))
        {
            hr = E_INVALIDARG;
            break;
        }

        SAFEARRAY *psa_1 = V_ARRAY(&(pArray_2[1]));
        if (!psa_1)
        {
            lCount = 0;  // empty root/link container
        } else
        {
            SafeArrayGetLBound(psa_1, 1, &lLowerBound );
            SafeArrayGetUBound(psa_1, 1, &lUpperBound );
            lCount = lUpperBound - lLowerBound + 1;
        }
        
        *ppDfsInfo = (PDFS_INFO_3)calloc(
                    sizeof(DFS_INFO_3) + lCount * sizeof(DFS_STORAGE_INFO),
                    1);
        BREAK_OUTOFMEMORY_IF_NULL(*ppDfsInfo, &hr);

        LPDFS_STORAGE_INFO pStorage = (LPDFS_STORAGE_INFO)((BYTE*)*ppDfsInfo + sizeof(DFS_INFO_3));

        (*ppDfsInfo)->EntryPath           = pArray_2[0].bstrVal;
        (*ppDfsInfo)->NumberOfStorages    = lCount;
        (*ppDfsInfo)->Storage             = pStorage;

        VARIANT HUGEP *pArray_1;
        SafeArrayAccessData(psa_1, (void HUGEP **)&pArray_1);
        for (long i = 0; i < lCount; i++, pStorage++)
        {
            if (V_VT(&(pArray_1[i])) != (VT_ARRAY | VT_VARIANT))
            {
                hr = E_INVALIDARG;
                break;
            }

            SAFEARRAY *psa_0 = V_ARRAY(&(pArray_1[i]));
            SafeArrayGetLBound(psa_0, 1, &lLowerBound );
            SafeArrayGetUBound(psa_0, 1, &lUpperBound );
            if (ARRAY_COUNT_FOR_DFS_STORAGE_INFO != (lUpperBound - lLowerBound + 1))
            {
                hr = E_INVALIDARG;
                break;
            }
            VARIANT HUGEP *pArray_0;
            SafeArrayAccessData(psa_0, (void HUGEP **)&pArray_0);
            if (V_VT(&(pArray_0[0])) != VT_BSTR ||
                V_VT(&(pArray_0[1])) != VT_BSTR)
            {
                hr = E_INVALIDARG;
            } else
            {
                pStorage->ServerName    = pArray_0[0].bstrVal;
                pStorage->ShareName     = pArray_0[1].bstrVal;
            }
            SafeArrayUnaccessData(psa_0);
        }
        SafeArrayUnaccessData(psa_1);

    } while (0);

    SafeArrayUnaccessData(psa_2);

    if (FAILED(hr) && *ppDfsInfo)
        free((void *)*ppDfsInfo);

    return hr;
}

STDMETHODIMP CDfsJunctionPoint :: InitializeEx
(
  IUnknown  *piDfsRoot,
  VARIANT   *pVar,
  BOOL      bReplicaSetExist,
  BSTR      bstrReplicaSetDN
)
{
    RETURN_INVALIDARG_IF_NULL(piDfsRoot);
    RETURN_INVALIDARG_IF_NULL(pVar);

    if ((IDfsRoot *)m_spiDfsRoot)
        m_spiDfsRoot.Release();
    piDfsRoot->QueryInterface(IID_IDfsRoot, (void **)&m_spiDfsRoot);

    PDFS_INFO_3 pDfsInfo = NULL;
    HRESULT hr = VariantToDfsInfoLevel3(pVar, &pDfsInfo);
    if (SUCCEEDED(hr))
    {
        hr = _Init(pDfsInfo, bReplicaSetExist, bstrReplicaSetDN);

        free((void *)pDfsInfo);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_CountOfDfsReplicas
(
  long*          pVal
)
{
  if (!pVal)
    return(E_INVALIDARG);

  *pVal = m_Replicas.size();
    
  return S_OK;
}



/////////////////////////////////////////////////////////////////////////////////////////////////


void CDfsJunctionPoint :: _FreeMemberVariables
(
)
{
  m_bstrEntryPath.Empty();
  m_bstrJunctionName.Empty();
  m_bstrJunctionNameEx.Empty();
  m_bstrReplicaSetDN.Empty();

  m_bReplicaSetExist = FALSE;

  FreeReplicas(&m_Replicas);
}



/////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT CDfsJunctionPoint :: _GetReplicaSetDN
(  
  BSTR          i_szEntryPath
)
{
    // as an example, given an entry path \\dom\public\dir1\dir2

    // set m_bstrReplicaSetDN to be: 
    // "CN=public|dir1|dir2,CN=public,CN=DFS Volumes,
    // CN=File Replication Service,CN=System"

    CComBSTR    bstrDfsName;  // e.g., "public"
    HRESULT     hr = GetUNCPathComponent(i_szEntryPath, &bstrDfsName, 3, 4);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrDfsRootDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);
    bstrDfsRootDN += bstrDfsName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);
    bstrDfsRootDN += CN_DFSVOLUMES_PREFIX;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);

    hr = ExtendDNIfLongJunctionName(m_bstrJunctionNameEx, bstrDfsRootDN, &m_bstrReplicaSetDN);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get__NewEnum
(
  LPUNKNOWN*        pVal
)
{
/*++

Routine Description:

  This property gets a new replica enumerator pointer.

Arguments:

  pVal - Pointer in which the pointer to IEnumVARIANT pointer will be returned.

--*/

      if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

                // Create a new ReplicaEnum object which implements IEnumVARIANT 
                // and return the pointer to IEnumVARIANT.
    CComObject<CReplicaEnum> *pReplicaEnum = new CComObject<CReplicaEnum>();
    if (!pReplicaEnum)
        return E_OUTOFMEMORY;
    
                // Initialize the enumerator with the list of replicas and the entrypath.
    HRESULT hr = pReplicaEnum->Initialize(&m_Replicas, m_bstrEntryPath);

                // Get the enumerator pointer.
    if (SUCCEEDED(hr))
        hr = pReplicaEnum->QueryInterface(IID_IEnumVARIANT, (void **)pVal);

    if (FAILED(hr))
    {
      delete pReplicaEnum;
      return hr;
    }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////
// AddReplica

HRESULT CDfsJunctionPoint::_AddToReplicaList(BSTR bstrServerName, BSTR bstrShareName)
{
    REPLICAINFO*   pDfsReplica = new REPLICAINFO;
    RETURN_OUTOFMEMORY_IF_NULL(pDfsReplica);

    HRESULT hr = pDfsReplica->Init(bstrServerName, bstrShareName);
    if (FAILED(hr))
    {
        delete pDfsReplica;
        return hr;
    }

    m_Replicas.push_back(pDfsReplica);

    return S_OK;
}

void CDfsJunctionPoint::_DeleteFromReplicaList(BSTR bstrServerName, BSTR bstrShareName)
{
  for (REPLICAINFOLIST::iterator i = m_Replicas.begin(); i != m_Replicas.end(); i++)
  {
      if (0 == lstrcmpi(bstrServerName, (*i)->m_bstrServerName) &&
          0 == lstrcmpi(bstrShareName, (*i)->m_bstrShareName))
      {
          delete (*i);
          m_Replicas.erase(i);
          break;
      }
  }
}

STDMETHODIMP CDfsJunctionPoint :: AddReplica
(
  BSTR          i_szServerName,
  BSTR          i_szShareName,
  VARIANT*      o_pvarReplicaObject
)
{
/*++

Routine Description:

  This method adds a Replica to an existing Junction Point.

Arguments:

  i_szServerName - The name of the server which hosts the share that the junction point should point to.
  i_szShareName - The name of the share that the junction point should point to.
  o_pvarReplicaObject - The Newly Created Replica's Object is returned here.
--*/

    if (!i_szServerName || !i_szShareName || !o_pvarReplicaObject)
        return E_INVALIDARG;

    NET_API_STATUS nstatRetVal = NetDfsAdd  (
                                    m_bstrEntryPath,
                                    i_szServerName,
                                    i_szShareName,
                                    NULL,
                                    DFS_RESTORE_VOLUME
                                  );

    if (NERR_Success != nstatRetVal)
        return HRESULT_FROM_WIN32 (nstatRetVal);

                            // Gets the IReplica interface pointer.
    IDfsReplica* pIReplicaPtr = NULL;
    HRESULT hr = CoCreateInstance(CLSID_DfsReplica, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDfsReplica, (void **)&pIReplicaPtr);
    RETURN_IF_FAILED(hr);

                            // Initialize the replica object.
    hr = pIReplicaPtr->Initialize(
                                m_bstrEntryPath, 
                                i_szServerName,
                                i_szShareName
                              );

    if (SUCCEEDED(hr))
        hr = _AddToReplicaList(i_szServerName, i_szShareName);

    if (SUCCEEDED(hr))
    {
        o_pvarReplicaObject->vt = VT_DISPATCH;
        o_pvarReplicaObject->pdispVal = (IDispatch*)pIReplicaPtr;
    } else
    {
        pIReplicaPtr->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// RemoveReplica


STDMETHODIMP CDfsJunctionPoint :: RemoveReplica
(
  BSTR          i_szServerName,
  BSTR          i_szShareName
)
{
/*++

Routine Description:

  This method removes a replica for the Junction point.

Arguments:

  i_szServerName  - The name of the server hosting the share that the replica is representing.
  i_szShareName  - The name of the share that the replica is representing
--*/
    if (!i_szServerName || !i_szShareName)
        return E_INVALIDARG;

    NET_API_STATUS nstatRetVal = NetDfsRemove(
                                        m_bstrEntryPath,
                                        i_szServerName,
                                        i_szShareName
                                    );
    if (NERR_Success == nstatRetVal)
        _DeleteFromReplicaList(i_szServerName, i_szShareName);

    return HRESULT_FROM_WIN32 (nstatRetVal);
}

STDMETHODIMP CDfsJunctionPoint::RemoveAllReplicas()
{
/*++

Routine Description:

  This method deletes the Junction point.

--*/
/*    HRESULT hr = S_OK;

    while (!m_Replicas.empty())
    {
        REPLICAINFOLIST::iterator i = m_Replicas.begin();
        hr = RemoveReplica((*i)->m_bstrServerName, (*i)->m_bstrShareName);
        BREAK_IF_FAILED(hr);
    }

    return hr; */

    //
    // DFS DCR: allow link deletion happen at once
    //
    NET_API_STATUS nstatRetVal = NetDfsRemove(
                                        m_bstrEntryPath,
                                        NULL,
                                        NULL
                                    );
    if (NERR_Success == nstatRetVal)
          FreeReplicas(&m_Replicas);

    return HRESULT_FROM_WIN32 (nstatRetVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// DeleteRootReplica

STDMETHODIMP CDfsJunctionPoint::DeleteRootReplica
(
    BSTR i_bstrDomainName,
    BSTR i_bstrDfsName,
    BSTR i_bstrServerName,
    BSTR i_bstrShareName,
    BOOL i_bForce
)
{
    RETURN_INVALIDARG_IF_TRUE(!i_bstrServerName || !*i_bstrServerName);
    RETURN_INVALIDARG_IF_TRUE(!i_bstrShareName || !*i_bstrShareName);

    NET_API_STATUS  nStatus = NERR_Success;

    if (!i_bstrDfsName || !*i_bstrDfsName)  // standalone Dfs
    {
        nStatus = NetDfsRemoveStdRoot(
                        i_bstrServerName,
                        i_bstrShareName,
                        0          // No Flags.
                    );
    } else
    {
        if (!i_bForce)
            nStatus = NetDfsRemoveFtRoot(
                        i_bstrServerName,
                        i_bstrShareName,
                        i_bstrDfsName,
                        0          // No Flags.
                    );
        else
            nStatus = NetDfsRemoveFtRootForced(
                        i_bstrDomainName,
                        i_bstrServerName,
                        i_bstrShareName,
                        i_bstrDfsName,
                        0          // No Flags.
                    );
    }

    if (NERR_Success == nStatus)
        _DeleteFromReplicaList(i_bstrServerName, i_bstrShareName);

    return HRESULT_FROM_WIN32(nStatus);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// GetOneRootReplica

// always return the first entry in the m_Replicas list.
STDMETHODIMP CDfsJunctionPoint::GetOneRootReplica
(
    OUT BSTR* o_pbstrServerName,
    OUT BSTR* o_pbstrShareName
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrServerName);
    RETURN_INVALIDARG_IF_NULL(o_pbstrShareName);

    *o_pbstrServerName = NULL;
    *o_pbstrShareName = NULL;

    if (m_Replicas.empty())
        return E_INVALIDARG;

    REPLICAINFOLIST::iterator i = m_Replicas.begin();
    *o_pbstrServerName = SysAllocString((*i)->m_bstrServerName);
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrServerName);
    *o_pbstrShareName = SysAllocString((*i)->m_bstrShareName);
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrShareName);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfsrep.cpp ===
/*++
Module Name:
    DfsRep.cpp

Abstract:
  This COM Class provides method to get information of Dfs replica.
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "DfsRep.h"

/////////////////////////////////////////////////////////////////////////////
// CDfsReplica

CDfsReplica::CDfsReplica()
{
    dfsDebugOut((_T("CDfsReplica::CDfsReplica this=%p\n"), this));
}

CDfsReplica::~CDfsReplica()
{
    dfsDebugOut((_T("CDfsReplica::~CDfsReplica this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////
// get_State

STDMETHODIMP CDfsReplica :: get_State
(
  long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;
  
    *pVal = DFS_REPLICA_STATE_UNREACHABLE;

    CComBSTR  bstrPath = _T("\\\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrPath);
    bstrPath += m_bstrStorageServerName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrPath);
    bstrPath += _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrPath);
    bstrPath += m_bstrStorageShareName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrPath);

    DWORD dwErr = GetFileAttributes(bstrPath);
    if (0xffffffff == dwErr)    // We failed to get the file attributes for entry path
    {
        return S_OK;
    }

    PDFS_INFO_3    pDfsInfo = NULL;
    NET_API_STATUS nstatRetVal = NetDfsGetInfo  (
                                  m_bstrEntryPath,
                                  m_bstrStorageServerName,
                                  m_bstrStorageShareName,
                                  3,
                                  (LPBYTE*)&pDfsInfo
                                );

    if (nstatRetVal != NERR_Success)
    {
        if (nstatRetVal == NERR_DfsNoSuchVolume)
            return S_FALSE;
        else
            return HRESULT_FROM_WIN32 (nstatRetVal);
    }

    BOOL                bFound = FALSE;
    LPDFS_STORAGE_INFO  pStorageInfo = pDfsInfo->Storage;
    ULONG               State = DFS_STORAGE_STATE_OFFLINE;

    for (UINT i=0; i < pDfsInfo->NumberOfStorages; i++, pStorageInfo++)
    {
        if ( !lstrcmpi(pStorageInfo->ServerName, m_bstrStorageServerName) &&
            !lstrcmpi(pStorageInfo->ShareName, m_bstrStorageShareName) )
        {
            bFound = TRUE;
            State = pStorageInfo->State;
            break;
        }
    }

    NetApiBufferFree(pDfsInfo);

    if (bFound)
    {
        *pVal = ((DFS_STORAGE_STATE_OFFLINE == State) ?
                        DFS_REPLICA_STATE_OFFLINE :
                        DFS_REPLICA_STATE_ONLINE);
        return S_OK;
    }

    return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// put_State


STDMETHODIMP CDfsReplica :: put_State
(
  long          newVal
)
{
    DFS_INFO_101          DfsInfoLevel101 = {0};

    if (DFS_REPLICA_STATE_OFFLINE == newVal)
        DfsInfoLevel101.State = DFS_STORAGE_STATE_OFFLINE;
    else
        DfsInfoLevel101.State = DFS_STORAGE_STATE_ONLINE;

    NET_API_STATUS nstatRetVal = NetDfsSetInfo  (
                                      m_bstrEntryPath,
                                      m_bstrStorageServerName,
                                      m_bstrStorageShareName,
                                      101,
                                      (LPBYTE) &DfsInfoLevel101
                                    );

    return HRESULT_FROM_WIN32 (nstatRetVal);
}


/////////////////////////////////////////////////////////////////////////////
// get_StorageServerName


STDMETHODIMP CDfsReplica :: get_StorageServerName
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;
  
  *pVal = m_bstrStorageServerName.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// get_StorageShareName


STDMETHODIMP CDfsReplica :: get_StorageShareName
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;
  
  *pVal = m_bstrStorageShareName.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Initialize


STDMETHODIMP CDfsReplica :: Initialize
(
  BSTR          i_szEntryPath,
  BSTR          i_szStorageServerName, 
  BSTR          i_szStorageShareName
)
{
/*++

Routine Description:

  Initializes the  DfsReplica object. Should be called after CoCreateInstance.
  If initialisation fails all properties will be NULL.

Arguments:

  i_szEntryPath - The entry path to the Replica.
  i_szStorageServerName - The name of the server which hosts the share the replica exists on.
  i_szStorageShareName - The name of the share.
--*/

    if (!i_szEntryPath || !i_szStorageServerName || !i_szStorageShareName)
        return E_INVALIDARG;

    _FreeMemberVariables ();

    HRESULT hr = S_OK;

    do {
        m_bstrEntryPath = i_szEntryPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath, &hr);
        m_bstrStorageServerName = i_szStorageServerName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStorageServerName, &hr);
        m_bstrStorageShareName = i_szStorageShareName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStorageShareName, &hr);
    } while (0);

    if (FAILED(hr))
        _FreeMemberVariables ();

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// get_EntryPath


STDMETHODIMP CDfsReplica :: get_EntryPath
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;
  
  *pVal = m_bstrEntryPath.Copy ();

  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// FindTarget


STDMETHODIMP CDfsReplica::FindTarget
(
)
{
    PDFS_INFO_3    pDfsInfo = NULL;
    NET_API_STATUS nstatRetVal = NetDfsGetInfo  (
                                  m_bstrEntryPath,
                                  m_bstrStorageServerName,
                                  m_bstrStorageShareName,
                                  3,
                                  (LPBYTE*)&pDfsInfo
                                );

    if (nstatRetVal != NERR_Success)
    {
        if (nstatRetVal == NERR_DfsNoSuchVolume)
            return S_FALSE;
        else
            return HRESULT_FROM_WIN32(nstatRetVal);
    }

    BOOL                bFound = FALSE;
    LPDFS_STORAGE_INFO  pStorageInfo = pDfsInfo->Storage;

    for (UINT i=0; i < pDfsInfo->NumberOfStorages; i++, pStorageInfo++)
    {
        if ( !lstrcmpi(pStorageInfo->ServerName, m_bstrStorageServerName) &&
            !lstrcmpi(pStorageInfo->ShareName, m_bstrStorageShareName) )
        {
            bFound = TRUE;
            break;
        }
    }

    NetApiBufferFree(pDfsInfo);

    return (bFound ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// _FreeMemberVariables


void CDfsReplica :: _FreeMemberVariables ()
{
  m_bstrEntryPath.Empty();
  m_bstrStorageServerName.Empty();
  m_bstrStorageShareName.Empty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfsroot.h ===
/*++
Module Name:
    DfsRoot.h

Abstract:

    This module contains the declaration of the CDfsRoot COM Class. This class
    provides methods to get information of a junction point and to enumerate 
    junction points.It implements IDfsRoot and provides
    an enumerator through get__NewEnum().
--*/


#ifndef __DFSROOT_H_
#define __DFSROOT_H_

#include "resource.h"       // main symbols
#include "dfsenums.h"
#include "dfsjp.h"
#include "netutils.h"

#include <list>
#include <map>
using namespace std;

                        // Helper Structures
                        // To store list of junction point info
class JUNCTIONNAME
{
public:
    CComPtr<IDfsJunctionPoint>  m_piDfsJunctionPoint;
    CComBSTR                    m_bstrEntryPath;
    CComBSTR                    m_bstrJPName;

    HRESULT Init(IDfsJunctionPoint *i_piDfsJunctionPoint)
    {
        ReSet();

        RETURN_INVALIDARG_IF_TRUE(!i_piDfsJunctionPoint);

        m_piDfsJunctionPoint = i_piDfsJunctionPoint;

        HRESULT hr = S_OK;
        do {
            hr = m_piDfsJunctionPoint->get_EntryPath(&m_bstrEntryPath);
            BREAK_IF_FAILED(hr);
            hr = GetUNCPathComponent(m_bstrEntryPath, &m_bstrJPName, 4, 0);
            BREAK_IF_FAILED(hr);
        } while (0);

        if (FAILED(hr))
            ReSet();

        return S_OK;
    }

    void ReSet()
    {
        m_piDfsJunctionPoint = NULL;
        m_bstrEntryPath.Empty();
        m_bstrJPName.Empty();
    }

    JUNCTIONNAME* Copy()
    {
        JUNCTIONNAME* pNew = new JUNCTIONNAME;
        
        if (pNew)
        {
            HRESULT hr = pNew->Init(m_piDfsJunctionPoint);

            if (FAILED(hr))
            {
                delete pNew;
                pNew = NULL;
            }
        }

        return pNew;
    }
};

typedef list<JUNCTIONNAME*>        JUNCTIONNAMELIST;

void FreeJunctionNames (JUNCTIONNAMELIST* pJPList);    // To free the list of junction point names.
void FreeReplicas (REPLICAINFOLIST* pRepList);        // To free the list of junction point names.

struct strmapcmpfn
{
   bool operator()(PTSTR p1, PTSTR p2) const
   {
       return lstrcmpi(p1, p2) < 0;
   }
};

typedef map<PTSTR, PTSTR, strmapcmpfn> StringMap;

class ATL_NO_VTABLE CDfsRoot : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsRoot, &CLSID_DfsRoot>,
    public IDispatchImpl<IDfsRoot, &IID_IDfsRoot, &LIBID_DFSCORELib>
{
public:
    CDfsRoot();

    ~CDfsRoot ();
    
DECLARE_REGISTRY_RESOURCEID(IDR_DFSROOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDfsRoot)
    COM_INTERFACE_ENTRY(IDfsRoot)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDfsRoot
                                                            // This is a string values which determines
                                                            // what get__NewEnum() will enumerate.
    STDMETHOD(get_EnumFilterType)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(put_EnumFilterType)
    (
        /*[in]*/ long newVal
    );
                                                            // Intializes the newly created object 
    STDMETHOD(get_EnumFilter)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(put_EnumFilter)
    (
        /*[in]*/ BSTR newVal
    );
                                                            // Intializes the newly created object 
    STDMETHOD(Initialize)                                    // and previously initialised DfsRoot object. 
    (
        BSTR i_szDfsName                                    // Dfs Name (i.e \\domain\ftdfs, \\server\share)
                                                            // or Server name hosting Dfs.
    );

    STDMETHOD(get_CountOfDfsJunctionPoints)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_CountOfDfsJunctionPointsFiltered)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_CountOfDfsRootReplicas)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_DfsName)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_State)
    (
        /*[out, retval]*/ long *pVal
    );
    
    STDMETHOD(get_DfsType)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_DomainName)
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
    STDMETHOD(get_DomainGuid)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_DomainDN)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_ReplicaSetDN)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_ReplicaSetExist)
    (
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(get_ReplicaSetExistEx)
    (
        /*[out]*/ BSTR* o_pbstrDC,
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(put_ReplicaSetExist)
    (
        /*[in]*/ BOOL newVal
    );

    STDMETHOD(get__NewEnum)
    (
        /*[out, retval]*/ LPUNKNOWN *pVal
    );

    STDMETHOD(get_RootReplicaEnum)
    (
        /*[out, retval]*/ LPUNKNOWN *pVal
    );

    STDMETHOD(get_RootEntryPath)                // Returns the root entry path
    (
        /*[out, retval]*/ BSTR *pVal
    );
                                                // Get the DfsRoot Comment
    STDMETHOD(get_Comment)
    (
        /*[out, retval]*/ BSTR*    o_pbstrComment
    );

    STDMETHOD(put_Comment)
    (
        /*[in]*/ BSTR    i_bstrComment
    );

    
    STDMETHOD(get_Timeout)
    (
        /*[out, retval]*/ long *pVal
    );
    
    STDMETHOD(put_Timeout)
    (
        /*[in]*/ long newVal
    );

    STDMETHOD( DeleteJunctionPoint )
    (
        /*[in]*/ BSTR i_szEntryPath
    );

    STDMETHOD( CreateJunctionPoint )
    (
        /*[in]*/    BSTR i_szJPName,
        /*[in]*/    BSTR i_szServerName,
        /*[in]*/    BSTR i_szShareName,
        /*[in]*/    BSTR i_szComment,
        /*[in]*/    long i_lTimeout,
        /*[out]*/   VARIANT *o_pIDfsJunctionPoint
    );

    STDMETHOD( DeleteDfsHost )
    (
        /*[in]*/ BSTR i_bstrServerName,
        /*[in]*/ BSTR i_bstrShareName,
        /*[in]*/ BOOL i_bForce
    );

    STDMETHOD( GetOneDfsHost )
    (
        /*[out]*/ BSTR* o_pbstrServerName,
        /*[out]*/ BSTR* o_pbstrShareName
    );

    STDMETHOD( IsJPExisted )
    (
        /*[in]*/  BSTR i_bstrJPName
    );

    STDMETHOD( RefreshRootReplicas )
    (
    );

    STDMETHOD( GetRootJP )
    (
        /*[out]*/   VARIANT *o_pIDfsJunctionPoint
    );

    STDMETHOD( DeleteAllReplicaSets )
    (
    );

//Protected Member Functions
protected:
    void _FreeMemberVariables ();           //Member function to free internal string variables.
    
    HRESULT _GetDfsName                  // set m_bstrDfsName
    (
        BSTR i_szRootEntryPath
    );

    HRESULT _Init(
        PDFS_INFO_3 pDfsInfo,
        StringMap*  pMap
        );

    HRESULT _AddToJPList(
        PDFS_INFO_3 pDfsInfo,
        BOOL        bReplicaSetExist,
        BSTR        bstrReplicaSetDN
        );

    HRESULT _AddToJPListEx(
        IDfsJunctionPoint * piDfsJunctionPoint,
        BOOL                bSort = FALSE
        );

    HRESULT _GetAllReplicaSets(
        OUT StringMap*  pMap
    );

    HRESULT RemoveAllReplicas               // Removes all the Replicas for a Junction Point
    (
            IDfsJunctionPoint*        i_JPObject
    );


    HRESULT DeleteAllJunctionPoints();      // Deletes all the Junction Points.


//Protected Member Variables
protected:
    IDfsJunctionPoint*  m_pDfsJP;               // pointer to the inner object

    // To Store Properties

    CComBSTR            m_bstrDfsName;
    CComBSTR            m_bstrDomainName;
    CComBSTR            m_bstrDomainGuid;
    CComBSTR            m_bstrDomainDN;
    FILTERDFSLINKS_TYPE m_lLinkFilterType;
    CComBSTR            m_bstrEnumFilter;
    DFS_TYPE            m_dwDfsType;
    JUNCTIONNAMELIST    m_JunctionPoints;
    long                m_lCountOfDfsJunctionPointsFiltered;
};


#endif //__DFSROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\jpenum.h ===
/*++

Module Name:

    JPENum.h

Abstract:

     This file contains the Declaration of the CJunctionPointEnum Class.
     This class implements IEnumVARIANT for DfsJunctionPoint enumeration.

--*/


#ifndef __JPENUM_H_
#define __JPENUM_H_

#include "resource.h"       // main symbols
#include "DfsRoot.h"

class ATL_NO_VTABLE CJunctionPointEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CJunctionPointEnum, &CLSID_JunctionPointEnum>,
    public IEnumVARIANT
{
public:
    CJunctionPointEnum()
    {
    }

    ~CJunctionPointEnum();

// DECLARE_REGISTRY_RESOURCEID(IDR_JPENUM)

BEGIN_COM_MAP(CJunctionPointEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

public:
                                                                // Call this to initialise.
    STDMETHOD( Initialize )
    (
        JUNCTIONNAMELIST*   i_pjiList,
        FILTERDFSLINKS_TYPE i_lLinkFilterType,
        BSTR                i_bstrEnumFilter, // Filtering string expresseion
        ULONG*              o_pulCount = NULL // count of links that matches the filter 
    );

// IEnumVariant
public:
                                                                //Get next Junction point
    STDMETHOD(Next)
    (
        ULONG i_ulNumOfJunctionPoints, 
        VARIANT * o_pIJunctionPointArray, 
        ULONG * o_ulNumOfJunctionPointsFetched
    );

                                                                //Skip  junction points
    STDMETHOD(Skip)
    (
        unsigned long i_ulJunctionPointsToSkip
    );

                                                                //Reset enumeration.
    STDMETHOD(Reset)();

                                                                //Clone a Enumerator.
    STDMETHOD(Clone)
    (
        IEnumVARIANT FAR* FAR* ppenum
    );

protected:
    void _FreeMemberVariables() {
        FreeJunctionNames(&m_JunctionPoints);
    }
    JUNCTIONNAMELIST::iterator  m_iCurrentInEnumOfJunctionPoints;   // Current pointer.
    JUNCTIONNAMELIST            m_JunctionPoints;                   // Stores the list of junction point entry path.
};

#endif //__JPENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\dfsroot.cpp ===
/*++
Module Name:
    DfsRoot.cpp
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "DfsRoot.h"
#include "JPEnum.h"
#include <dsgetdc.h>
#include <dsrole.h>   // DsRoleGetPrimaryDomainInformation
#include "netutils.h"
#include "ldaputils.h"

/////////////////////////////////////////////////////////////////////////////////////////////////
// CDfsRoot constructor

CDfsRoot::CDfsRoot() : 
            m_pDfsJP(NULL), 
            m_dwDfsType(DFS_TYPE_UNASSIGNED),
            m_lCountOfDfsJunctionPointsFiltered(0),
            m_lLinkFilterType(FILTERDFSLINKS_TYPE_NO_FILTER)
{
    dfsDebugOut((_T("CDfsRoot::CDfsRoot this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// CDfsRoot destructor 


CDfsRoot::~CDfsRoot()
{
    _FreeMemberVariables();
    dfsDebugOut((_T("CDfsRoot::~CDfsRoot this=%p\n"), this));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DomainName


STDMETHODIMP CDfsRoot :: get_DomainName
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_bstrDomainName.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DomainGuid


STDMETHODIMP CDfsRoot :: get_DomainGuid
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_bstrDomainGuid.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DomainDN


STDMETHODIMP CDfsRoot :: get_DomainDN
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_bstrDomainDN.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DfsType


STDMETHODIMP CDfsRoot :: get_DfsType
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_dwDfsType;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_State


STDMETHODIMP CDfsRoot :: get_State
(
    long*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_State(pVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DfsName


STDMETHODIMP CDfsRoot :: get_DfsName
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG ;

    *pVal = m_bstrDfsName.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_ReplicaSetDN


STDMETHODIMP CDfsRoot :: get_ReplicaSetDN
(
    BSTR*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_ReplicaSetDN(pVal);
}

STDMETHODIMP CDfsRoot :: get_ReplicaSetExist
(
  BOOL*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_ReplicaSetExist(pVal);
}

STDMETHODIMP CDfsRoot :: get_ReplicaSetExistEx
(
  BSTR*          o_pbstrDC,
  BOOL*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_ReplicaSetExistEx(o_pbstrDC, pVal);
}

STDMETHODIMP CDfsRoot :: put_ReplicaSetExist
(
  BOOL          newVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->put_ReplicaSetExist(newVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_CountOfDfsJunctionPoints


STDMETHODIMP CDfsRoot :: get_CountOfDfsJunctionPoints
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_JunctionPoints.size();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_CountOfDfsJunctionPointsFiltered


STDMETHODIMP CDfsRoot :: get_CountOfDfsJunctionPointsFiltered
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_lCountOfDfsJunctionPointsFiltered;

    return S_OK;
}

HRESULT DfsInfo3ToVariant(PDFS_INFO_3 pDfsInfo, OUT VARIANT *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pDfsInfo);
    RETURN_INVALIDARG_IF_NULL(pVal);

    HRESULT hr = S_OK;

    int cStorages = pDfsInfo->NumberOfStorages;

    // create an array of array of variants to hold all storage data
    SAFEARRAY*      psa_1 = NULL;

    if (cStorages > 0 )
    {
        SAFEARRAYBOUND  bounds_1 = {cStorages, 0};
        psa_1 = SafeArrayCreate(VT_VARIANT, 1, &bounds_1);
        RETURN_OUTOFMEMORY_IF_NULL(psa_1);

        VARIANT*        varArray_1 = NULL;
        SafeArrayAccessData(psa_1, (void**)&varArray_1);
        for (int i = 0; i < cStorages; i++)
        {
            // create an array of variants to hold each Storage data (2 elements)
            SAFEARRAYBOUND  bounds_0 = {2, 0};
            SAFEARRAY*      psa_0 = SafeArrayCreate(VT_VARIANT, 1, &bounds_0);
            BREAK_OUTOFMEMORY_IF_NULL(psa_0, &hr);

            VARIANT*        varArray_0 = NULL;
            SafeArrayAccessData(psa_0, (void**)&varArray_0);
            do
            {
                varArray_0[0].vt        = VT_BSTR;
                varArray_0[0].bstrVal   = SysAllocString(pDfsInfo->Storage[i].ServerName);
                BREAK_OUTOFMEMORY_IF_NULL(varArray_0[0].bstrVal, &hr);

                varArray_0[1].vt        = VT_BSTR;
                varArray_0[1].bstrVal   = SysAllocString(pDfsInfo->Storage[i].ShareName);
                BREAK_OUTOFMEMORY_IF_NULL(varArray_0[1].bstrVal, &hr);
            } while (0);
            SafeArrayUnaccessData(psa_0);

            if (FAILED(hr))
            {
                SafeArrayDestroy(psa_0);
                break;
            }

            // add this array to be an element
            varArray_1[i].vt        = VT_ARRAY | VT_VARIANT;
            varArray_1[i].parray    = psa_0;
        }
        SafeArrayUnaccessData(psa_1);
    }

    if (SUCCEEDED(hr))
    {
        // now create an array of variants to hold DfsInfoLevel4
        SAFEARRAYBOUND  bounds_2 = {2, 0};
        SAFEARRAY*      psa_2 = SafeArrayCreate(VT_VARIANT, 1, &bounds_2);
        if (!psa_2)
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            VARIANT*        varArray_2 = NULL;
            SafeArrayAccessData(psa_2, (void**)&varArray_2);
            do
            {
                varArray_2[0].vt        = VT_BSTR;
                varArray_2[0].bstrVal   = SysAllocString(pDfsInfo->EntryPath);
                BREAK_OUTOFMEMORY_IF_NULL(varArray_2[0].bstrVal, &hr);

                varArray_2[1].vt        = VT_ARRAY | VT_VARIANT;
                varArray_2[1].parray    = psa_1;

            } while (0);
            SafeArrayUnaccessData(psa_2);

            if (FAILED(hr))
                SafeArrayDestroy(psa_2);
        }

        if (SUCCEEDED(hr))
        {
            VariantInit(pVal);
            pVal->vt = VT_ARRAY | VT_VARIANT;
            pVal->parray = psa_2;
        }
    }

    if (FAILED(hr))
        SafeArrayDestroy(psa_1);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  Initialize

HRESULT CDfsRoot::_Init(
    PDFS_INFO_3 pDfsInfo,
    StringMap*  pMap)
{
    RETURN_INVALIDARG_IF_NULL(pDfsInfo);
    RETURN_INVALIDARG_IF_NULL(pMap);

    HRESULT hr = S_OK;

    do {
        hr = GetUNCPathComponent(pDfsInfo->EntryPath, &m_bstrDfsName, 3, 4);
        BREAK_IF_FAILED(hr);

        // decide whether it's a domain-based or standalone
        CComBSTR bstrScope;
        hr = GetUNCPathComponent(pDfsInfo->EntryPath, &bstrScope, 2, 3);
        BREAK_IF_FAILED(hr);

        if ((pDfsInfo->State & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_STANDALONE)
        {
            m_dwDfsType = DFS_TYPE_STANDALONE;
        } else if ((pDfsInfo->State & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_AD_BLOB)
        {
            m_dwDfsType = DFS_TYPE_FTDFS;
        } else
        {
            // flavor flag is not set, we're dealing with old version of metadata blob

            // see if bstrScope is a domain name
#ifdef DEBUG
            SYSTEMTIME time0 = {0};
            GetSystemTime(&time0);
#endif // DEBUG
            PDOMAIN_CONTROLLER_INFO   pDCInfo = NULL;
            DWORD nRet = DsGetDcName(
                      NULL,
                      bstrScope,
                      NULL,
                      NULL,
                      DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                      &pDCInfo
                    );
#ifdef DEBUG
            SYSTEMTIME time1 = {0};
            GetSystemTime(&time1);
            PrintTimeDelta(_T("CDfsRoot::_Init-DsGetDcName"), &time0, &time1);
#endif // DEBUG
            if (ERROR_SUCCESS == nRet)
            { 
                NetApiBufferFree(pDCInfo);

                m_dwDfsType = DFS_TYPE_FTDFS;
            } else
            { // check to see if it's a valid server name
                PWKSTA_INFO_100     wki100 = NULL;
                nRet = NetWkstaGetInfo(bstrScope, 100, (LPBYTE *)&wki100 );
                if (ERROR_SUCCESS == nRet)
                {
                    m_dwDfsType = DFS_TYPE_STANDALONE;
                    NetApiBufferFree((LPVOID)wki100);
                } else
                {
                    hr = HRESULT_FROM_WIN32(nRet);
                }
    
            }
        }

        if (SUCCEEDED(hr) && m_dwDfsType == DFS_TYPE_FTDFS)
        {
            hr = GetDomainInfo( bstrScope,
                                NULL, // DC
                                &m_bstrDomainName,
                                &m_bstrDomainDN,
                                NULL, // LDAPDomainPath
                                &m_bstrDomainGuid);
        }

        BREAK_IF_FAILED(hr);

        if (m_dwDfsType == DFS_TYPE_FTDFS)
        {
            (void) _GetAllReplicaSets(pMap);
        }

        CComVariant varData;
        hr = DfsInfo3ToVariant(pDfsInfo, &varData);
        BREAK_IF_FAILED(hr);

        hr = CoCreateInstance(CLSID_DfsJunctionPoint, NULL, CLSCTX_INPROC_SERVER,
            IID_IDfsJunctionPoint, (void **)&m_pDfsJP);
        BREAK_IF_FAILED(hr);

        if (m_dwDfsType == DFS_TYPE_FTDFS)
        {
            CComBSTR bstrDfsLinkName;
            hr = GetUNCPathComponent(pDfsInfo->EntryPath, &bstrDfsLinkName, 3, 0);
            BREAK_IF_FAILED(hr);

            StringMap::iterator it = pMap->find(bstrDfsLinkName);
            if (it != pMap->end())
                hr = m_pDfsJP->InitializeEx((IUnknown *)this, &varData, TRUE, (*it).second);
            else
                hr = m_pDfsJP->InitializeEx((IUnknown *)this, &varData, FALSE, NULL);
        } else
        {
            hr = m_pDfsJP->InitializeEx((IUnknown *)this, &varData, FALSE, NULL);
        }

    } while (0);

    return hr;
}

int __cdecl CompareJPs(const void *arg1, const void *arg2 )
{
   return lstrcmpi( (*(PDFS_INFO_3 *)arg1)->EntryPath, (*(PDFS_INFO_3 *)arg2)->EntryPath );
}


STDMETHODIMP CDfsRoot :: Initialize
(
    BSTR          i_szDfsName
)
{
/*++

Routine Description:
  
  This method intializes the newly created object and previously initialised 
  DfsRoot object.

Arguments:

  i_szDfsName - The Dfs name which can be any of the following type:
  1.  \\domain.dns.name\FtDfs,
  2.  \\domain\FtDfs,
  3.  \\server\share,
  4.  \\server,
  5.  server.

Notes:
  Initialize performs the following:
  1.  Gets the name of the domain for the server hosting / participating in the Dfs Root.
  2.  Gets all child junction points and root level replicas for this Dfs.
  3.  Gets the type (standalone or fault tolerant) of the DFS.
  4.  Gets the display name of the DFS, \\domain.dns.name\FtDfs or \\server\share and Dfs Name which
    is FtDfs or server..

Return:
  S_FALSE if i_szDfsName doesn't host any dfs root
--*/

    RETURN_INVALIDARG_IF_NULL(i_szDfsName);

    _FreeMemberVariables();

    LPBYTE      pBuffer = NULL;
    DWORD        dwEntriesRead = 0;
    DWORD        dwResumeHandle = 0;

    NET_API_STATUS  nRet = NetDfsEnum(
                                i_szDfsName,
                                3,  // level 3
                                0xffffffff,
                                &pBuffer,
                                &dwEntriesRead,
                                &dwResumeHandle);

    if (NERR_Success != nRet)
    {
        return (ERROR_NO_MORE_ITEMS == nRet || ERROR_NOT_FOUND == nRet) ? S_FALSE : HRESULT_FROM_WIN32(nRet);
    }

    HRESULT hr = S_OK;
    do {
        DWORD            i = 0;
        PDFS_INFO_3        pDfsInfo = (PDFS_INFO_3)pBuffer;

        //
        // root may not be the 1st entry, find the root entry, switch it to the top
        //
        for (i = 0; i < dwEntriesRead; i++)
        {
            if (pDfsInfo[i].State & DFS_VOLUME_FLAVORS)
                break; // the i-th entry is the root entry
        }

        if (i != 0 && i != dwEntriesRead)
        {
            DFS_INFO_3 tmpInfo = {0};
            memcpy(&tmpInfo, pDfsInfo, sizeof(DFS_INFO_3));
            memcpy(pDfsInfo, pDfsInfo + i, sizeof(DFS_INFO_3));
            memcpy(pDfsInfo + i, &tmpInfo, sizeof(DFS_INFO_3));
        }

        // i=0 is the Root info
        StringMap mapReplicaSets;
        hr = _Init(pDfsInfo, &mapReplicaSets);
        BREAK_IF_FAILED(hr);

        if (dwEntriesRead > 1)
        {
            pDfsInfo++;

            PDFS_INFO_3 *pArray = (PDFS_INFO_3 *)calloc(dwEntriesRead - 1, sizeof(PDFS_INFO_3));
            BREAK_OUTOFMEMORY_IF_NULL(pArray, &hr);

            PDFS_INFO_3 *pArrayElem = NULL;
            for (i = 1, pArrayElem = pArray; i < dwEntriesRead; i++, pDfsInfo++, pArrayElem++)
                *pArrayElem = pDfsInfo;

            qsort((void *)pArray, dwEntriesRead - 1, sizeof(PDFS_INFO_3), CompareJPs);

            StringMap::iterator it;
            for (i = 1, pArrayElem = pArray; i < dwEntriesRead; i++, pArrayElem++)
            {
                if (m_dwDfsType == DFS_TYPE_FTDFS)
                {
                    CComBSTR bstrDfsLinkName;
                    hr = GetUNCPathComponent((*pArrayElem)->EntryPath, &bstrDfsLinkName, 3, 0);
                    BREAK_IF_FAILED(hr);

                    it = mapReplicaSets.find(bstrDfsLinkName);
                    if (it != mapReplicaSets.end())
                        hr = _AddToJPList(*pArrayElem, TRUE, (*it).second);
                    else
                        hr = _AddToJPList(*pArrayElem, FALSE, NULL);
                } else
                {
                    hr = _AddToJPList(*pArrayElem, FALSE, NULL);
                }

                BREAK_IF_FAILED(hr);
            }

            free((void *)pArray);
        }
    } while (0);

    NetApiBufferFree(pBuffer);

    if (FAILED(hr))
        _FreeMemberVariables();

    return hr;
}

void _FreeStringMap(IN StringMap* pMap)
{
    if (pMap && !pMap->empty()) {
        for (StringMap::iterator i = pMap->begin(); i != pMap->end(); i++)
        {
            if ((*i).first)
                free( (void *)((*i).first) );
            if ((*i).second)
                free( (void *)((*i).second) );
        }
        pMap->clear();
    }
}

HRESULT CDfsRoot :: _GetAllReplicaSets(
    OUT StringMap*  pMap
    )
{
    _FreeStringMap(pMap);

    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDomainName);

    HRESULT hr = S_OK;

    PLDAP pldap = NULL;
    do {
        hr = ConnectToDS(m_bstrDomainName, &pldap);
        BREAK_IF_FAILED(hr);

        CComBSTR bstrContainerDN;
        hr = GetReplicaSetContainer(pldap, m_bstrDfsName, &bstrContainerDN);
        BREAK_IF_FAILED(hr);

        //
        // get all the replica sets under the container
        //
        PCTSTR      ppszAttributes[] = {ATTR_DISTINGUISHEDNAME, 0};
        LListElem*  pElem = NULL;
        hr = GetValuesEx(
                        pldap,
                        bstrContainerDN,
                        LDAP_SCOPE_SUBTREE,
                        _T("(&(objectCategory=nTFRSReplicaSet)(frsReplicaSetType=3))"),
                        ppszAttributes,
                        &pElem);
        BREAK_IF_FAILED(hr);

        LListElem* pCurElem = pElem;
        while (pCurElem)
        {
            PTSTR** pppszValues = pCurElem->pppszAttrValues;
            if (!pppszValues ||
                !pppszValues[0] || !*(pppszValues[0]))
            {
                hr = E_FAIL;
                break;
            }

            PTSTR  pszDN = *(pppszValues[0]);

            PTSTR  p = _tcsstr(pszDN, _T(",DC="));
            if (!p)
            {
                hr = E_INVALIDARG;
                break;
            }
            *p = _T('\0');
            PTSTR  pszReplicaSetDN = _tcsdup(pszDN);
            *p = _T(',');
            BREAK_OUTOFMEMORY_IF_NULL(pszReplicaSetDN, &hr);

            CComBSTR bstrDfsLinkName;
            hr = GetDfsLinkNameFromDN(pszReplicaSetDN, &bstrDfsLinkName);

            PTSTR  pszDfsLinkName = NULL;
            if (SUCCEEDED(hr))
            {
                pszDfsLinkName = _tcsdup(bstrDfsLinkName);
                if (!pszDfsLinkName)
                    hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                free(pszReplicaSetDN);
                break;
            }

            pMap->insert(StringMap::value_type(pszDfsLinkName, pszReplicaSetDN));

            pCurElem = pCurElem->Next;
        }

        FreeLListElem(pElem);

        BREAK_IF_FAILED(hr);

    } while (0);

    if (pldap)
        CloseConnectionToDS(pldap);

    if (FAILED(hr))
        _FreeStringMap(pMap);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  CreateJunctionPoint


STDMETHODIMP CDfsRoot :: CreateJunctionPoint
(
    BSTR            i_szJPName,
    BSTR            i_szServerName,
    BSTR            i_szShareName,
    BSTR            i_szComment,
    long            i_lTimeout,
    VARIANT*        o_pIDfsJunctionPoint
)
{
    if (!i_szJPName || !i_szServerName || !i_szShareName || !o_pIDfsJunctionPoint)
        return E_INVALIDARG;

    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    CComBSTR bstrEntryPath;      // Start with the root entry path.
    HRESULT hr = m_pDfsJP->get_EntryPath(&bstrEntryPath);
    RETURN_IF_FAILED(hr);

    bstrEntryPath += _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);
    bstrEntryPath += i_szJPName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);

    NET_API_STATUS nstatRetVal = NetDfsAdd(
                                    bstrEntryPath,
                                    i_szServerName,
                                    i_szShareName,
                                    i_szComment,
                                    DFS_ADD_VOLUME | DFS_RESTORE_VOLUME
                                  );

    if (nstatRetVal != NERR_Success)
        return HRESULT_FROM_WIN32 (nstatRetVal);

                              // Get the interface pointer
    IDfsJunctionPoint*    pIJunctionPointPtr = NULL;
    hr = CoCreateInstance(CLSID_DfsJunctionPoint, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDfsJunctionPoint, (void **)&pIJunctionPointPtr);
    RETURN_IF_FAILED(hr);

    hr = pIJunctionPointPtr->Initialize((IUnknown *)this, bstrEntryPath, FALSE, NULL);

    if (SUCCEEDED(hr))
    {
        hr = pIJunctionPointPtr->put_Timeout(i_lTimeout);
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr)
        {
            // we're most probably managing NT4 here, which doesn't support Timeout
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
        hr = _AddToJPListEx(pIJunctionPointPtr, TRUE);

    if (SUCCEEDED(hr))
    {
        o_pIDfsJunctionPoint->vt = VT_DISPATCH;
        o_pIDfsJunctionPoint->pdispVal = pIJunctionPointPtr;
    } else
    {
        pIJunctionPointPtr->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteJunctionPoint


STDMETHODIMP CDfsRoot::DeleteJunctionPoint
(
    BSTR          i_szJPName
)
{
    if (!i_szJPName)
        return E_INVALIDARG;

    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    CComBSTR bstrEntryPath;      // Start with the root entry path.
    HRESULT hr = m_pDfsJP->get_EntryPath(&bstrEntryPath);
    RETURN_IF_FAILED(hr);

    bstrEntryPath += _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);
    bstrEntryPath += i_szJPName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);

                              // Get the interface pointer
    JUNCTIONNAMELIST::iterator  i;
    for (i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        if (!lstrcmpi((*i)->m_bstrJPName, i_szJPName))
            break;
    }

    if (i != m_JunctionPoints.end())
    {
        hr = ((*i)->m_piDfsJunctionPoint)->RemoveAllReplicas();

        if (SUCCEEDED(hr))
        {
            delete (*i);
            m_JunctionPoints.erase(i);
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteDfsHost

STDMETHODIMP CDfsRoot::DeleteDfsHost
(
    BSTR i_bstrServerName,
    BSTR i_bstrShareName,
    BOOL i_bForce
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    switch (m_dwDfsType)
    {
    case DFS_TYPE_STANDALONE:
        return m_pDfsJP->DeleteRootReplica(NULL, NULL, i_bstrServerName, i_bstrShareName, i_bForce);
    case DFS_TYPE_FTDFS:
        return m_pDfsJP->DeleteRootReplica(m_bstrDomainName, m_bstrDfsName, i_bstrServerName, i_bstrShareName, i_bForce);
    default:
        return E_INVALIDARG;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  GetOneDfsHost

STDMETHODIMP CDfsRoot::GetOneDfsHost
(
    OUT BSTR* o_pbstrServerName,
    OUT BSTR* o_pbstrShareName
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->GetOneRootReplica(o_pbstrServerName, o_pbstrShareName);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  _FreeMemberVariables


void CDfsRoot :: _FreeMemberVariables
(
)
{
    m_bstrDfsName.Empty();
    m_bstrDomainName.Empty();
    m_bstrDomainGuid.Empty();
    m_bstrDomainDN.Empty();

    m_lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER;
    m_bstrEnumFilter.Empty();

    FreeJunctionNames(&m_JunctionPoints);

    if (m_pDfsJP)
    {
        m_pDfsJP->Release();
        m_pDfsJP = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get__NewEnum


STDMETHODIMP CDfsRoot :: get__NewEnum
(
    LPUNKNOWN*        pVal
)
{
/*++

Routine Description:
  
  Returns a new enumerator interface (IEnumVARIANT) to enumerate Junction points.
  This depends upon the EnumFilter value.

Arguments:

  pVal - Pointer to a Variant in which the enumerator will be returned.

--*/

    if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

                //Create a Junction point enumerator and initialize it with
                //the internal list.    
    CComObject<CJunctionPointEnum> *pJunctionPointEnum = new CComObject<CJunctionPointEnum>();
    if (!pJunctionPointEnum)
        return E_OUTOFMEMORY;

    HRESULT hr = pJunctionPointEnum->Initialize(&m_JunctionPoints, m_lLinkFilterType, m_bstrEnumFilter, (ULONG*)&m_lCountOfDfsJunctionPointsFiltered);
    if (SUCCEEDED(hr))
        hr = pJunctionPointEnum->QueryInterface(IID_IEnumVARIANT, (void **)pVal);

    if (FAILED(hr))
        delete pJunctionPointEnum;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_RootReplicaEnum


STDMETHODIMP CDfsRoot :: get_RootReplicaEnum
(
    LPUNKNOWN*        pVal
)
{
/*++

Routine Description:
  
  Call the inner junction point to return a new enumerator interface (IEnumVARIANT) 
  to enumerate root replicas.

Arguments:

  pVal - Pointer to a Variant in which the enumerator will be returned.

--*/

    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get__NewEnum(pVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  GetRootJP


STDMETHODIMP CDfsRoot :: GetRootJP
(
    VARIANT*        o_pIDfsJunctionPoint
)
{
    RETURN_INVALIDARG_IF_NULL(o_pIDfsJunctionPoint);
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    m_pDfsJP->AddRef();

    o_pIDfsJunctionPoint->vt = VT_DISPATCH;
    o_pIDfsJunctionPoint->pdispVal = m_pDfsJP;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_RootEntryPath


STDMETHODIMP CDfsRoot :: get_RootEntryPath
(
    BSTR*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_EntryPath(pVal);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//  Comment

STDMETHODIMP CDfsRoot :: get_Comment(BSTR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_Comment(pVal);
}

STDMETHODIMP CDfsRoot :: put_Comment(BSTR newVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->put_Comment(newVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  Timeout

STDMETHODIMP CDfsRoot::get_Timeout(long *pVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_Timeout(pVal);
}

STDMETHODIMP CDfsRoot::put_Timeout(long newVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->put_Timeout(newVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteAllJunctionPoints

HRESULT CDfsRoot :: DeleteAllJunctionPoints()
{
/*++

Routine Description:
  
  Deletes all Junction junction points.

--*/

    HRESULT hr = S_OK;

    for (JUNCTIONNAMELIST::iterator i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        hr = DeleteJunctionPoint((*i)->m_bstrJPName);
        BREAK_IF_FAILED(hr);
    }

    return hr;
}

//
//  gets/puts the type of Enumerator Filter.
//
STDMETHODIMP CDfsRoot::get_EnumFilterType
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_lLinkFilterType;

    return S_OK;
}

STDMETHODIMP CDfsRoot::put_EnumFilterType
(
    long          newVal
)
{
    m_lLinkFilterType = (FILTERDFSLINKS_TYPE)newVal;

    return S_OK;
}

//
// gets/puts the Enumerator Filter
//
STDMETHODIMP CDfsRoot::get_EnumFilter
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

    if ((BSTR)m_bstrEnumFilter)
    {
        *pVal = m_bstrEnumFilter.Copy ();
        if (!*pVal)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CDfsRoot::put_EnumFilter
(
    BSTR          newVal
)
{
    // we require newVal points to a non-empty string
    if (!newVal || !*newVal)
        return E_INVALIDARG;

    m_bstrEnumFilter = newVal;
    if (!m_bstrEnumFilter)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_CountOfDfsRootReplicas

STDMETHODIMP CDfsRoot :: get_CountOfDfsRootReplicas
(
    long*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_CountOfDfsReplicas(pVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  IsJPExisted

STDMETHODIMP CDfsRoot :: IsJPExisted
(
    BSTR    i_bstrJPName
)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrJPName);

    for (JUNCTIONNAMELIST::iterator i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        if (!lstrcmpi((*i)->m_bstrJPName, i_bstrJPName))
            return S_OK;
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  RefreshRootReplicas: used to pick up new Dfs hosts

STDMETHODIMP CDfsRoot :: RefreshRootReplicas
(
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    CComBSTR bstrEntryPath;
    HRESULT hr = m_pDfsJP->get_EntryPath(&bstrEntryPath);
    RETURN_IF_FAILED(hr);

    BOOL bReplicaSetExist = FALSE;
    hr = m_pDfsJP->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrReplicaSetDN;
    hr = m_pDfsJP->get_ReplicaSetDN(&bstrReplicaSetDN);
    RETURN_IF_FAILED(hr);

    hr = m_pDfsJP->Initialize((IUnknown *)this, bstrEntryPath, bReplicaSetExist, bstrReplicaSetDN);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteAllReplicaSets: delete all replica sets related to this Dfs root

STDMETHODIMP CDfsRoot :: DeleteAllReplicaSets
(
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    if (m_dwDfsType != DFS_TYPE_FTDFS)
        return S_OK;

    //
    // delete replica sets associated with this Dfs root
    //
    HRESULT hr = S_OK;
    BOOL bReplicaSetExist = FALSE;
    JUNCTIONNAMELIST::iterator  i;
    for (i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        bReplicaSetExist = FALSE;
        (void)(*i)->m_piDfsJunctionPoint->get_ReplicaSetExist(&bReplicaSetExist);

        if (bReplicaSetExist)
        {
            CComBSTR bstrReplicaSetDN;
            hr = (*i)->m_piDfsJunctionPoint->get_ReplicaSetDN(&bstrReplicaSetDN);
            BREAK_IF_FAILED(hr);

            CComPtr<IReplicaSet> piReplicaSet;
            hr = CoCreateInstance(CLSID_ReplicaSet, NULL, CLSCTX_INPROC_SERVER, IID_IReplicaSet, (void**)&piReplicaSet);
            BREAK_IF_FAILED(hr);

            hr = piReplicaSet->Initialize(m_bstrDomainName, bstrReplicaSetDN);
            if (SUCCEEDED(hr))
                piReplicaSet->Delete();
        }
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  FreeJunctionNames


void FreeJunctionNames (JUNCTIONNAMELIST* pJPList)
{
    if (NULL == pJPList)
        return;

    if (!pJPList->empty())
    {
        for (JUNCTIONNAMELIST::iterator i = pJPList->begin(); i != pJPList->end(); i++)
        {
            delete (*i);
        }

        pJPList->clear();
    }
    _ASSERT(pJPList->empty());
}


/////////////////////////////////////////////////////////////////////////////////////////////////


void FreeReplicas(REPLICAINFOLIST* pRepList)
{
    if (NULL == pRepList)
        return;

    if (!pRepList->empty())
    {
        for (REPLICAINFOLIST::iterator i = pRepList->begin(); i != pRepList->end(); i++)
        {
            delete (*i);
        }

        pRepList->clear();
    }
    _ASSERT(pRepList->empty());
}

HRESULT CDfsRoot::_AddToJPList(
    PDFS_INFO_3 pDfsInfo,
    BOOL        bReplicaSetExist,
    BSTR        bstrReplicaSetDN)
{
    HRESULT hr = S_OK;

    CComPtr<IDfsJunctionPoint> piDfsJunctionPoint;
    hr = CoCreateInstance(CLSID_DfsJunctionPoint, NULL, CLSCTX_INPROC_SERVER,
        IID_IDfsJunctionPoint, (void **)&piDfsJunctionPoint);
    RETURN_IF_FAILED(hr);

    CComVariant varData;
    hr = DfsInfo3ToVariant(pDfsInfo, &varData);
    RETURN_IF_FAILED(hr);

    hr = piDfsJunctionPoint->InitializeEx((IUnknown *)this, &varData, bReplicaSetExist, bstrReplicaSetDN);
    RETURN_IF_FAILED(hr);

    return _AddToJPListEx(piDfsJunctionPoint);
}

HRESULT CDfsRoot::_AddToJPListEx(
    IDfsJunctionPoint * piDfsJunctionPoint,
    BOOL                bSort)
{
    JUNCTIONNAME*   pDfsJP = new JUNCTIONNAME;
    RETURN_OUTOFMEMORY_IF_NULL(pDfsJP);

    HRESULT hr = pDfsJP->Init(piDfsJunctionPoint);
    if (FAILED(hr))
    {
        delete pDfsJP;
        return hr;
    }

    if (bSort)
    {
        JUNCTIONNAMELIST::iterator i;
        for (i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
        {
            if (lstrcmpi(pDfsJP->m_bstrJPName, (*i)->m_bstrJPName) < 0)
                break;
        }
        m_JunctionPoints.insert(i, pDfsJP);
    } else
    {
        m_JunctionPoints.push_back(pDfsJP);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\jpenum.cpp ===
/*++
Module Name:

    JPEnum.cpp

Abstract:

   This file contains the Implementation of the Class CJunctionPointEnum.
   This class implements IEnumVARIANT for DfsJunctionPoint enumeration.
--*/


#include "stdafx.h"
#include "DfsCore.h"
#include "DfsJP.h"
#include "JPEnum.h"


/////////////////////////////////////////////////////////////////////////////
// ~CJunctionPointEnum


CJunctionPointEnum :: ~CJunctionPointEnum ()
{
    _FreeMemberVariables();
}


/////////////////////////////////////////////////////////////////////////////
// Initialize


STDMETHODIMP CJunctionPointEnum :: Initialize
(
  JUNCTIONNAMELIST* i_pjiList,      // Pointer to the list of junction points.
  FILTERDFSLINKS_TYPE i_lLinkFilterType,
  BSTR              i_bstrEnumFilter, // Filtering string expresseion
  ULONG*            o_pulCount       // count of links that matches the filter 
)
{
/*++

Routine Description:

  Initializes the JunctionPointEnum object.
  It copies the JunctionPoint list passed to it by the junction point
  object.

Arguments:

  i_pjiList    -  Pointer to the list of junction points.
  i_lLinkFilterType  - The type of link filtering.
  i_bstrEnumFilter  - The string expression to do prefix filtering.
  o_pulCount - to hold the count of links that matches the specified filter.

--*/

    if (!i_pjiList)
        return E_INVALIDARG;

    if (i_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER &&
        (!i_bstrEnumFilter || !*i_bstrEnumFilter))
        return E_INVALIDARG;

    if (o_pulCount)
        *o_pulCount = 0;

    HRESULT                     hr = S_OK;
    JUNCTIONNAMELIST::iterator  i;
    JUNCTIONNAMELIST::iterator  j;

    for (i = i_pjiList->begin(); i != i_pjiList->end(); i++)
    {                   // Copy filtered junctions to its own internal list
        if (i_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
        {
            if ( !FilterMatch((*i)->m_bstrJPName, i_lLinkFilterType, i_bstrEnumFilter) )
                continue;
        }

        JUNCTIONNAME*  pTemp = (*i)->Copy();
        BREAK_OUTOFMEMORY_IF_NULL(pTemp, &hr);

        m_JunctionPoints.push_back(pTemp);
    }

    if (SUCCEEDED(hr))
    {
        m_iCurrentInEnumOfJunctionPoints = m_JunctionPoints.begin();
        *o_pulCount = m_JunctionPoints.size();
    } else
        _FreeMemberVariables();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IEnumVariant Methods


/////////////////////////////////////////////////////////////////////////////
// Next


STDMETHODIMP CJunctionPointEnum::Next
(
  ULONG     i_ulNumOfJunctionPoints,        //To fetch.
  VARIANT*  o_pIJunctionPointArray,         //Array to fetch into.
  ULONG*    o_ulNumOfJunctionPointsFetched  //The number of values fetched, (Arg can be NULL)
)
{
/*++

Routine Description:

  Gets the next object in the list.

Arguments:

  i_ulNumOfJunctionPoints      - the number of objects to return
  o_pIJunctionPointArray      - an array of variants in which to return the objects
  o_ulNumOfJunctionPointsFetched  - the number of objects that are actually returned

Return value:

  S_OK, On success
  S_FALSE if the end of the list has been reached
--*/

    if (!o_pIJunctionPointArray || !i_ulNumOfJunctionPoints)
        return E_INVALIDARG;

    HRESULT       hr = S_OK;
    ULONG         nCount = 0;

    for (nCount = 0; 
        nCount < i_ulNumOfJunctionPoints && m_iCurrentInEnumOfJunctionPoints != m_JunctionPoints.end();
        m_iCurrentInEnumOfJunctionPoints++)
    {
        IDfsJunctionPoint *pIJunctionPointPtr = (*m_iCurrentInEnumOfJunctionPoints)->m_piDfsJunctionPoint;
        pIJunctionPointPtr->AddRef();

        o_pIJunctionPointArray[nCount].vt = VT_DISPATCH;
        o_pIJunctionPointArray[nCount].pdispVal = pIJunctionPointPtr;

        nCount++;
    }

    if (o_ulNumOfJunctionPointsFetched)
        *o_ulNumOfJunctionPointsFetched = nCount;

    if (SUCCEEDED(hr) && !nCount)
        return S_FALSE;
    else
        return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Skip


STDMETHODIMP CJunctionPointEnum :: Skip
(
    unsigned long i_ulJunctionPointsToSkip    //Items to skip
)
{
/*++

Routine Description:

  Skips the next 'n' objects in the list.

Arguments:

  i_ulJunctionPointsToSkip - the number of objects to skip over

Return value:

    S_OK, On success
  S_FALSE, if the end of the list is reached

--*/

    for (unsigned int j = 0; j < i_ulJunctionPointsToSkip && 
        m_iCurrentInEnumOfJunctionPoints != m_JunctionPoints.end(); j++)
    {
        m_iCurrentInEnumOfJunctionPoints++;
    }

    return (m_iCurrentInEnumOfJunctionPoints != m_JunctionPoints.end()) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Reset


STDMETHODIMP CJunctionPointEnum :: Reset()
{
/*++

Routine Description:

  Resets the current enumeration pointer to the start of the list

--*/

    m_iCurrentInEnumOfJunctionPoints = m_JunctionPoints.begin();
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Clone


STDMETHODIMP CJunctionPointEnum :: Clone
(
    IEnumVARIANT FAR* FAR* ppenum
)
{
/*++

Routine Description:

  Creates a clone of the enumerator object

Arguments:

  ppenum  -  address of the pointer to the IEnumVARIANT interface 
        of the newly created enumerator object

Notes:

  This has not been implemented.
--*/

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\repenum.h ===
/*++

Module Name:

    RepEnum.h

Abstract:

     This file contains the declaration of the CReplicaEnum Class.
     This class implements the IEnumVARIANT which enumerates DfsReplicas.
--*/


#ifndef __REPENUM_H_
#define __REPENUM_H_

#include "resource.h"       // main symbols
#include "DfsRoot.h"

class ATL_NO_VTABLE CReplicaEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CReplicaEnum, &CLSID_ReplicaEnum>,
    IEnumVARIANT
{
public:
    CReplicaEnum()
    {
    }
virtual    ~CReplicaEnum();
// DECLARE_REGISTRY_RESOURCEID(IDR_REPLICAENUM)

BEGIN_COM_MAP(CReplicaEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()


//IEnumVARIANT Methods
public:
                                                        // Get next replica.
    STDMETHOD(Next)
    (
        ULONG i_ulNumOfReplicas, 
        VARIANT *o_pIReplicaArray, 
        ULONG *o_ulNumOfReplicasFetched
    );

                                                        // Skip the next element in the enumeratio.
    STDMETHOD(Skip)
    (
        ULONG i_ulReplicasToSkip
    );

                                                        // Reset enumeration and start afresh.
    STDMETHOD(Reset)();
    
                                                        // Create a new enumerator.
    STDMETHOD(Clone)
    (
        IEnumVARIANT **o_ppEnum                            // Pointer to IEnum.
    );

                                                        // Intialise the Enumerator.
    STDMETHOD(Initialize)
    (
        REPLICAINFOLIST* i_priList, 
        BSTR i_bstrEntryPath
    );


protected:    
    void _FreeMemberVariables() {
        m_bstrEntryPath.Empty();
        FreeReplicas(&m_Replicas);
    }

    //Member variable for enumeraiton.
    REPLICAINFOLIST::iterator   m_iCurrentInEnumOfReplicas;    
    REPLICAINFOLIST             m_Replicas;
    CComBSTR                    m_bstrEntryPath;
};

#endif //__REPENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\repenum.cpp ===
/*++

Module Name:

    RepEnum.cpp

Abstract:

   This file contains the Implementation of the Class CReplicaEnum.
   This class implements the IEnumVARIANT which enumerates DfsReplicas.

--*/


#include "stdafx.h"
#include "DfsCore.h"
#include "DfsRep.h"
#include "RepEnum.h"


/////////////////////////////////////////////////////////////////////////////
// ~CReplicaEnum


CReplicaEnum :: ~CReplicaEnum()
{
    _FreeMemberVariables();
}


/////////////////////////////////////////////////////////////////////////////
// Initialize


STDMETHODIMP CReplicaEnum :: Initialize
(
    REPLICAINFOLIST*    i_priList,
    BSTR                i_bstrEntryPath
)
{
/*++

Routine Description:

  Initializes the ReplicaEnum object.
  It copies the replica list passed to it by the junction point
  object. Sorting is done during the copying.

--*/

    if (!i_priList || !i_bstrEntryPath)
        return E_INVALIDARG;

    _FreeMemberVariables();

    HRESULT hr = S_OK;

    do {
        m_bstrEntryPath = i_bstrEntryPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath, &hr);

        REPLICAINFOLIST::iterator i;
        REPLICAINFOLIST::iterator j;

        for (i = i_priList->begin(); i != i_priList->end(); i++)
        {
                    // Find insertion position.
            for (j = m_Replicas.begin(); j != m_Replicas.end(); j++)
            {
                if (lstrcmpi((*i)->m_bstrServerName, (*j)->m_bstrServerName) < 0 ||
                    lstrcmpi((*i)->m_bstrShareName, (*j)->m_bstrShareName) <= 0)
                    break;
            }

            REPLICAINFO* pTemp = (*i)->Copy();
            BREAK_OUTOFMEMORY_IF_NULL(pTemp, &hr);

            m_Replicas.insert(j, pTemp);
        }
    } while (0);

    if (SUCCEEDED(hr))
        m_iCurrentInEnumOfReplicas = m_Replicas.begin();
    else
        _FreeMemberVariables();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IEnumVariant Methods


/////////////////////////////////////////////////////////////////////////////
// Next


STDMETHODIMP CReplicaEnum :: Next
(
    ULONG       i_ulNumOfReplicas,          // Number of replicas to fetch
    VARIANT *   o_pIReplicaArray,           // VARIANT array to return fetched replicas.
    ULONG *     o_ulNumOfReplicasFetched    // Return the number of replicas fetched.
)
{
/*++

Routine Description:

  Gets the next object in the list.

Arguments:

  i_ulNumOfReplicas      - the number of replicas to return
  o_pIReplicaArray      - an array of variants in which to return the replicas
  o_ulNumOfReplicasFetched  - the number of replicas that are actually returned

--*/

    if (!i_ulNumOfReplicas || !o_pIReplicaArray)
        return E_INVALIDARG;

    HRESULT       hr = S_OK;
    ULONG         nCount = 0;      //Count of Elements Fetched.
    IDfsReplica   *pIReplicaPtr = NULL;

                      // Create replica object using the internal replica list.
    for (nCount = 0; 
        nCount < i_ulNumOfReplicas && m_iCurrentInEnumOfReplicas != m_Replicas.end();
        m_iCurrentInEnumOfReplicas++)
    {
                      // Create a replica object.
        hr = CoCreateInstance(CLSID_DfsReplica, NULL, CLSCTX_INPROC_SERVER,
                            IID_IDfsReplica, (void **)&pIReplicaPtr);
        BREAK_IF_FAILED(hr);

                                  //Initialize the replica object.
        hr = pIReplicaPtr->Initialize(m_bstrEntryPath, 
                       (*m_iCurrentInEnumOfReplicas)->m_bstrServerName,
                       (*m_iCurrentInEnumOfReplicas)->m_bstrShareName);
        BREAK_IF_FAILED(hr);

        V_VT (&o_pIReplicaArray[nCount]) = VT_DISPATCH;
        o_pIReplicaArray[nCount].pdispVal = pIReplicaPtr; 

        nCount++;
    }

                //VB does not send o_ulNumOfReplicasFetched;
    if (o_ulNumOfReplicasFetched)
        *o_ulNumOfReplicasFetched = nCount;

    if (SUCCEEDED(hr) && !nCount)
        return S_FALSE;
    else
        return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Skip


STDMETHODIMP CReplicaEnum :: Skip
(
    ULONG i_ulReplicasToSkip        //Number of items to skip.
)
{
/*++

Routine Description:

  Skips the next 'n' objects in the list.

Arguments:

  i_ulReplicasToSkip - the number of objects to skip over

Return value:

  S_OK, On success
  S_FALSE, if the end of the list is reached

--*/

    for (unsigned int j = 0; j < i_ulReplicasToSkip && m_iCurrentInEnumOfReplicas != m_Replicas.end(); j++)
    {
        m_iCurrentInEnumOfReplicas++;
    }

    return (m_iCurrentInEnumOfReplicas != m_Replicas.end()) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Reset


STDMETHODIMP CReplicaEnum :: Reset()
{
/*++

Routine Description:

  Resets the current enumeration pointer to the start of the list

--*/

    m_iCurrentInEnumOfReplicas = m_Replicas.begin();
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Clone


STDMETHODIMP CReplicaEnum :: Clone
(
    IEnumVARIANT **o_ppEnum        //Return IEnumVARIANT pointer.
)
{
/*++

Routine Description:

  Creates a clone of the enumerator object

Arguments:

  o_ppEnum  -  address of the pointer to the IEnumVARIANT interface 
          of the newly created enumerator object

Notes:

  This has not been implemented.

--*/

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\repset.cpp ===
/*++
Module Name:
    RepSet.cpp
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "RepSet.h"
#include "netutils.h"
#include "ldaputils.h"
#include <dsgetdc.h>    // DsGetSiteName

//
// retrieve Site
//
HRESULT GetSiteName(IN BSTR i_bstrServer, OUT BSTR* o_pbstrSite)
{
    HRESULT hr = S_OK;
    LPTSTR  lpszSiteName = NULL;
    DWORD   dwErr = DsGetSiteName(i_bstrServer, &lpszSiteName);

    if (NO_ERROR == dwErr)
    {
        *o_pbstrSite = SysAllocString(lpszSiteName);
        NetApiBufferFree((LPBYTE)lpszSiteName);
        if (!*o_pbstrSite)
            hr = E_OUTOFMEMORY;
    } else if (ERROR_NO_SITENAME == dwErr)
    {
        *o_pbstrSite = SysAllocString(_T(""));
        if (!*o_pbstrSite)
            hr = E_OUTOFMEMORY;
    } else
    {
        CComBSTR  bstrText;
	FormatMessageString(&bstrText, 0, IDS_UNKNOWN_SITE, dwErr);
        *o_pbstrSite = bstrText.Copy();
        if (!*o_pbstrSite)
            hr = E_OUTOFMEMORY;

//        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// constructor

CReplicaSet::CReplicaSet() :
    m_pldap(NULL),
    m_bNewSchema(FALSE)
{
    dfsDebugOut((_T("CReplicaSet::CReplicaSet this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// destructor 


CReplicaSet::~CReplicaSet()
{
    _FreeMemberVariables();

    dfsDebugOut((_T("CReplicaSet::~CReplicaSet this=%p\n"), this));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// various properties

STDMETHODIMP CReplicaSet::get_Type(BSTR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrType)
    {
        m_bstrType = FRS_RSTYPE_OTHER;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrType);
    }

    *pVal = m_bstrType.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_Type(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrType && !lstrcmpi(newVal, m_bstrType))
        return S_OK; // no change

    CComBSTR bstrType = ((newVal && *newVal)? newVal : FRS_RSTYPE_DFS);
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrType);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_TYPE;
    pAttrVals[0].vpValue = (void *)(BSTR)bstrType;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);

    if (SUCCEEDED(hr))
        m_bstrType = bstrType;

    return hr;
}

STDMETHODIMP CReplicaSet::get_TopologyPref(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrTopologyPref)
    {
        m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_CUSTOM;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref);
    }

    *pVal = m_bstrTopologyPref.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    dfsDebugOut((_T("get_TopologyPref = %s\n"), m_bstrTopologyPref));

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_TopologyPref(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrTopologyPref && !lstrcmpi(newVal, m_bstrTopologyPref))
        return S_OK; // no change

    CComBSTR bstrTopologyPref = ((newVal && *newVal)? newVal : FRS_RSTOPOLOGYPREF_CUSTOM);
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrTopologyPref);

    HRESULT hr = S_OK;

    if (m_bNewSchema)
    {
        LDAP_ATTR_VALUE  pAttrVals[1];
        pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_TOPOLOGYPREF;
        pAttrVals[0].vpValue = (void *)(BSTR)bstrTopologyPref;
        pAttrVals[0].bBerValue = false;

        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);

        if (SUCCEEDED(hr))
            m_bstrTopologyPref = bstrTopologyPref;
    } else
    {
        m_bstrTopologyPref = bstrTopologyPref;
    }

    dfsDebugOut((_T("put_TopologyPref = %s\n"), m_bstrTopologyPref));

    return hr;
}

STDMETHODIMP CReplicaSet::get_HubMemberDN(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrHubMemberDN)
    {
        m_bstrHubMemberDN = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrHubMemberDN);
    }

    *pVal = m_bstrHubMemberDN.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    dfsDebugOut((_T("get_HubMemberDN = %s\n"), m_bstrHubMemberDN));

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_HubMemberDN(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrHubMemberDN && !lstrcmpi(newVal, m_bstrHubMemberDN))
        return S_OK; // no change

    CComBSTR bstrHubMemberDN = ((newVal && *newVal) ? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrHubMemberDN);

    HRESULT hr = S_OK;

    if (m_bNewSchema)
    {
        LDAP_ATTR_VALUE  pAttrVals[1];
        pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_HUBSERVER;
        pAttrVals[0].bBerValue = false;

        if (newVal && *newVal)
        {
            pAttrVals[0].vpValue = (void *)(BSTR)bstrHubMemberDN;
            hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
        } else
        {
            pAttrVals[0].vpValue = NULL;
            hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
        }
        if (SUCCEEDED(hr))
            m_bstrHubMemberDN = bstrHubMemberDN;
    } else
    {
        m_bstrHubMemberDN = bstrHubMemberDN;
    }

    dfsDebugOut((_T("put_HubMemberDN = %s\n"), m_bstrHubMemberDN));

    return hr;
}

STDMETHODIMP CReplicaSet::get_PrimaryMemberDN(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrPrimaryMemberDN)
    {
        m_bstrPrimaryMemberDN = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrPrimaryMemberDN);
    }

    *pVal = m_bstrPrimaryMemberDN.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_PrimaryMemberDN(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrPrimaryMemberDN && !lstrcmpi(newVal, m_bstrPrimaryMemberDN))
        return S_OK; // no change

    CComBSTR bstrPrimaryMemberDN = ((newVal && *newVal)? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrPrimaryMemberDN);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_PRIMARYMEMBER;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = S_OK;
    if (newVal && *newVal)
    {
        pAttrVals[0].vpValue = (void *)(BSTR)bstrPrimaryMemberDN;
        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    } else
    {
        pAttrVals[0].vpValue = NULL;
        hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    }
    if (SUCCEEDED(hr))
        m_bstrPrimaryMemberDN = bstrPrimaryMemberDN;

    return hr;
}

STDMETHODIMP CReplicaSet::get_FileFilter(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrFileFilter)
    {
        m_bstrFileFilter = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFileFilter);
    }

    *pVal = m_bstrFileFilter.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_FileFilter(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrFileFilter && !lstrcmpi(newVal, m_bstrFileFilter))
        return S_OK; // no change

    CComBSTR bstrFileFilter = ((newVal && *newVal) ? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFileFilter);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_FILEFILTER;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = S_OK;
    if (newVal && *newVal)
    {
        pAttrVals[0].vpValue = (void *)(BSTR)bstrFileFilter;
        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    } else
    {
        pAttrVals[0].vpValue = NULL;
        hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    }
    if (SUCCEEDED(hr))
        m_bstrFileFilter = bstrFileFilter;

    return hr;
}

STDMETHODIMP CReplicaSet::get_DirFilter(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrDirFilter)
    {
        m_bstrDirFilter = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDirFilter);
    }

    *pVal = m_bstrDirFilter.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_DirFilter(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrDirFilter && !lstrcmpi(newVal, m_bstrDirFilter))
        return S_OK; // no change

    CComBSTR bstrDirFilter = ((newVal && *newVal)? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDirFilter);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_DIRFILTER;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = S_OK;
    if (newVal && *newVal)
    {
        pAttrVals[0].vpValue = (void *)(BSTR)bstrDirFilter;
        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    } else
    {
        pAttrVals[0].vpValue = NULL;
        hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    }
    if (SUCCEEDED(hr))
        m_bstrDirFilter = bstrDirFilter;

    return hr;
}

STDMETHODIMP CReplicaSet::get_DfsEntryPath(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrDfsEntryPath)
    {
        m_bstrDfsEntryPath = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDfsEntryPath);
    }

    *pVal = m_bstrDfsEntryPath.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_Domain(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDomain);

    *pVal = m_bstrDomain.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_ReplicaSetDN(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrReplicaSetDN);

    *pVal = m_bstrReplicaSetDN.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_NumOfMembers(long* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    *pVal = m_frsMemberList.size();

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_NumOfConnections(long* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    *pVal = m_frsConnectionList.size();

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_TargetedDC(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDC);

    *pVal = m_bstrDC.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  various methods
STDMETHODIMP CReplicaSet::Create(
    BSTR i_bstrDomain,
    BSTR i_bstrReplicaSetDN,
    BSTR i_bstrType,
    BSTR i_bstrTopologyPref,
    BSTR i_bstrHubMemberDN,
    BSTR i_bstrPrimaryMemberDN,
    BSTR i_bstrFileFilter,
    BSTR i_bstrDirFilter
)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrType);

    _FreeMemberVariables();

    HRESULT hr = S_OK;

    do {
        m_bstrDomain = i_bstrDomain;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

        CComBSTR bstrDomainDN;
        hr = GetDomainInfo(
                        i_bstrDomain,
                        NULL,               // return DC's Dns name
                        NULL,               // return Domain's Dns name
                        &bstrDomainDN,      // return DC=nttest,DC=micr
                        NULL,               // return LDAP://<DC>/<Doma
                        &m_bstrDomainGuid   // return Domain's guid
                        );
        BREAK_IF_FAILED(hr);

        hr = ConnectToDS(m_bstrDomain, &m_pldap, &m_bstrDC);
        BREAK_IF_FAILED(hr);

        //
        // get schema version
        //
        hr = GetSchemaVersionEx(m_bstrDomain, FALSE);
        BREAK_IF_FAILED(hr);

        m_bNewSchema = (S_OK == hr);
        dfsDebugOut((_T("NewSchema=%d\n"), m_bNewSchema));

        m_bstrReplicaSetDN = i_bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        m_bstrReplicaSetDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        m_bstrReplicaSetDN += bstrDomainDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);

        m_bstrType = i_bstrType;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrType, &hr);

        //
        // create container objects if not exist
        //
        hr = CreateNtfrsSettingsObjects(m_pldap, m_bstrReplicaSetDN);
        BREAK_IF_FAILED(hr);

        //
        // create this nTFRSReplicaSet object
        //
        LDAP_ATTR_VALUE  pAttrVals[7];

        int i = 0;
        pAttrVals[i].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
        pAttrVals[i].vpValue = (void *)OBJCLASS_NTFRSREPLICASET;
        pAttrVals[i].bBerValue = false;

        i++;
        pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_TYPE;
        pAttrVals[i].vpValue = (void *)i_bstrType;
        pAttrVals[i].bBerValue = false;

        if (i_bstrTopologyPref && *i_bstrTopologyPref)
        {
            m_bstrTopologyPref = i_bstrTopologyPref;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);

            if (m_bNewSchema)
            {
                i++;
                pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_TOPOLOGYPREF;
                pAttrVals[i].vpValue = (void *)i_bstrTopologyPref;
                pAttrVals[i].bBerValue = false;
            }

            if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref))
            {
                if (i_bstrHubMemberDN && *i_bstrHubMemberDN)
                {
                    m_bstrHubMemberDN = i_bstrHubMemberDN;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrHubMemberDN, &hr);

                    if (m_bNewSchema)
                    {
                        i++;
                        pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_HUBSERVER;
                        pAttrVals[i].vpValue = (void *)i_bstrHubMemberDN;
                        pAttrVals[i].bBerValue = false;
                    }
                }
            }
        }

        if (i_bstrPrimaryMemberDN && *i_bstrPrimaryMemberDN)
        {
            m_bstrPrimaryMemberDN = i_bstrPrimaryMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrPrimaryMemberDN, &hr);

            i++;
            pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_PRIMARYMEMBER;
            pAttrVals[i].vpValue = (void *)i_bstrPrimaryMemberDN;
            pAttrVals[i].bBerValue = false;
        }

        if (i_bstrFileFilter && *i_bstrFileFilter)
        {
            m_bstrFileFilter = i_bstrFileFilter;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFileFilter, &hr);

            i++;
            pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_FILEFILTER;
            pAttrVals[i].vpValue = (void *)i_bstrFileFilter;
            pAttrVals[i].bBerValue = false;
        }

        if (i_bstrDirFilter && *i_bstrDirFilter)
        {
            m_bstrDirFilter = i_bstrDirFilter;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDirFilter, &hr);

            i++;
            pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_DIRFILTER;
            pAttrVals[i].vpValue = (void *)i_bstrDirFilter;
            pAttrVals[i].bBerValue = false;
        }

        hr = AddValues(
                m_pldap,
                m_bstrReplicaSetDN,
                ++i,
                pAttrVals
                );
        BREAK_IF_FAILED(hr);

    } while (0);

    if (FAILED(hr))
    {
        _FreeMemberVariables();

        //
        // try to clean empty container objects
        //
        (void)DeleteNtfrsReplicaSetObjectAndContainers(m_pldap, m_bstrReplicaSetDN);
    }

    return hr;
}

STDMETHODIMP CReplicaSet::Initialize(BSTR i_bstrDomain, BSTR i_bstrReplicaSetDN)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);

    _FreeMemberVariables();

    HRESULT hr = S_OK;

    do {
        m_bstrDomain = i_bstrDomain;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

        CComBSTR bstrDomainDN;
        hr = GetDomainInfo(
                        i_bstrDomain,
                        NULL,               // return DC's Dns name
                        NULL,               // return Domain's Dns name
                        &bstrDomainDN,      // return DC=nttest,DC=micr
                        NULL,               // return LDAP://<DC>/<Doma
                        &m_bstrDomainGuid   // return Domain's guid
                        );
        BREAK_IF_FAILED(hr);

        m_bstrReplicaSetDN = i_bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);

        hr = ConnectToDS(m_bstrDomain, &m_pldap, &m_bstrDC);
        BREAK_IF_FAILED(hr);

        //
        // get schema version
        //
        hr = GetSchemaVersionEx(m_bstrDomain, FALSE);
        BREAK_IF_FAILED(hr);

        m_bNewSchema = (S_OK == hr);
        dfsDebugOut((_T("NewSchema=%d\n"), m_bNewSchema));

        m_bstrReplicaSetDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        m_bstrReplicaSetDN += bstrDomainDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);

        PLDAP_ATTR_VALUE  pValues[7] = {0,0,0,0,0,0,0};
        LDAP_ATTR_VALUE  pAttributes[6];

        int i = 0;
        pAttributes[i].bstrAttribute = ATTR_FRS_REPSET_TYPE;
        if (m_bNewSchema)
        {
            pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_TOPOLOGYPREF;
            pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_HUBSERVER;
        }
        pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_PRIMARYMEMBER;
        pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_FILEFILTER;
        pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_DIRFILTER;

        hr = GetValues( m_pldap,
                        m_bstrReplicaSetDN,
                        OBJCLASS_SF_NTFRSREPLICASET,
                        LDAP_SCOPE_BASE,
                        ++i,
                        pAttributes,
                        pValues);
        BREAK_IF_FAILED(hr);

        do {
            i = 0;
            if (pValues[i])
            {
                m_bstrType = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrType, &hr);
            }

            if (!m_bNewSchema)
            {
                m_bstrHubMemberDN.Empty();
                m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_CUSTOM;
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);
            } else
            {
                i++;
                if (pValues[i])
                {
                    m_bstrTopologyPref = (PTSTR)(pValues[i]->vpValue);
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);
                }

                i++;
                if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref))
                {
                    if (pValues[i])
                    {
                        m_bstrHubMemberDN = (PTSTR)(pValues[i]->vpValue);
                        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrHubMemberDN, &hr);
                    } else
                    {
                        // something was wrong, reset Cutom topology
                        m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_CUSTOM;
                        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);
                    }
                }
            }

            i++;
            if (pValues[i])
            {
                m_bstrPrimaryMemberDN = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrPrimaryMemberDN, &hr);
            }

            i++;
            if (pValues[i])
            {
                m_bstrFileFilter = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFileFilter, &hr);
            }

            i++;
            if (pValues[i])
            {
                m_bstrDirFilter = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDirFilter, &hr);
            }
        } while (0);

        for (i = 0; i < 7; i++)
        {
            if (pValues[i])
                FreeAttrValList(pValues[i]);
        }

        hr = _PopulateMemberList();
        BREAK_IF_FAILED(hr);

        hr = _PopulateConnectionList();
        BREAK_IF_FAILED(hr);

        dfsDebugOut((_T("members=%d, connections=%d\n"), m_frsMemberList.size(), m_frsConnectionList.size()));
    } while (0);

    if (FAILED(hr))
        _FreeMemberVariables();

    return hr;
}

HRESULT CReplicaSet::_PopulateMemberList()
{
    PCTSTR ppszAttributes[] = {
                                ATTR_DISTINGUISHEDNAME,
                                ATTR_FRS_MEMBER_COMPUTERREF,
                                0
                                };

    LListElem* pElem = NULL;
    HRESULT hr = GetValuesEx(
                            m_pldap,
                            m_bstrReplicaSetDN,
                            LDAP_SCOPE_ONELEVEL,
                            OBJCLASS_SF_NTFRSMEMBER,
                            ppszAttributes,
                            &pElem);
    RETURN_IF_FAILED(hr);

    LListElem* pCurElem = pElem;
    while (pCurElem)
    {
        PTSTR** pppszValues = pCurElem->pppszAttrValues;

        if (!pppszValues ||
            !pppszValues[0] || !*(pppszValues[0]) ||
            !pppszValues[1] || !*(pppszValues[1]))
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted member object
        }

        CFrsMember *pMember = new CFrsMember;
        hr = pMember->InitEx(m_pldap, 
                            m_bstrDC,
                            *(pppszValues[0]),  // distinguishedName
                            *(pppszValues[1])   // computerRef
                            );
       if (FAILED(hr))
       {
           delete pMember;
           break;
       } else if (S_FALSE == hr)
           delete pMember;
        else
            m_frsMemberList.push_back(pMember);

        pCurElem = pCurElem->Next;
    }

    FreeLListElem(pElem);

    if (FAILED(hr))
        FreeFrsMembers(&m_frsMemberList);

    return hr;
}

STDMETHODIMP CReplicaSet::GetMemberList( 
        /* [retval][out] */ VARIANT __RPC_FAR *pvarMemberDNs)
{
    RETURN_INVALIDARG_IF_NULL(pvarMemberDNs);

    VariantInit(pvarMemberDNs);
    pvarMemberDNs->vt = VT_ARRAY | VT_VARIANT;
    pvarMemberDNs->parray = NULL;

    HRESULT hr = S_OK;
    int     cMembers = m_frsMemberList.size();
    if (!cMembers)
        return hr;  // parray is NULL when the member list is empty

    SAFEARRAYBOUND  bounds = {cMembers, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); (it != m_frsMemberList.end()) && (i < cMembers); it++, i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = ((*it)->m_bstrMemberDN).Copy();
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        pvarMemberDNs->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

STDMETHODIMP CReplicaSet::GetMemberListEx( 
        /* [retval][out] */ VARIANT __RPC_FAR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    VariantInit(pVal);
    pVal->vt = VT_ARRAY | VT_VARIANT;
    pVal->parray = NULL;

    HRESULT hr = S_OK;
    int     cMembers = m_frsMemberList.size();
    if (!cMembers)
        return hr;  // parray is NULL when the member list is empty

    SAFEARRAYBOUND  bounds = {cMembers, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); (it != m_frsMemberList.end()) && (i < cMembers); it++, i++)
    {
        VariantInit(&(varArray[i]));
        hr = _GetMemberInfo((*it), &(varArray[i]));
        BREAK_IF_FAILED(hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        pVal->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

HRESULT CReplicaSet::_GetMemberInfo( 
    IN  CFrsMember*     i_pFrsMember,
    OUT VARIANT*        o_pvarMember)
{
    RETURN_INVALIDARG_IF_NULL(i_pFrsMember);
    RETURN_INVALIDARG_IF_NULL(o_pvarMember);

    HRESULT         hr = S_OK;
    SAFEARRAYBOUND  bounds = {NUM_OF_FRSMEMBER_ATTRS, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    BSTR bstr[NUM_OF_FRSMEMBER_ATTRS] = {
                                    i_pFrsMember->m_bstrComputerDN,
                                    i_pFrsMember->m_bstrDomain,
                                    i_pFrsMember->m_bstrMemberDN,
                                    i_pFrsMember->m_bstrRootPath,
                                    i_pFrsMember->m_bstrServer,
                                    i_pFrsMember->m_bstrServerGuid,
                                    i_pFrsMember->m_bstrSite,
                                    i_pFrsMember->m_bstrStagingPath,
                                    i_pFrsMember->m_bstrSubscriberDN
                                        };

    for (int i = 0; i < NUM_OF_FRSMEMBER_ATTRS; i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = SysAllocString(bstr[i]);
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
    {
        o_pvarMember->vt = VT_ARRAY | VT_VARIANT;
        o_pvarMember->parray = psa;
    } else
        SafeArrayDestroy(psa);

    return hr;
}

STDMETHODIMP CReplicaSet::GetMemberInfo( 
        /* [in] */ BSTR i_bstrMemberDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);

    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!lstrcmpi(i_bstrMemberDN, (*it)->m_bstrMemberDN))
            break;
    }

    if (it == m_frsMemberList.end())
        return S_FALSE; // no such member

    return _GetMemberInfo((*it), o_pvarMember);
}

STDMETHODIMP CReplicaSet::GetBadMemberInfo( 
        /* [in] */ BSTR i_bstrServerName,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
    int n = lstrlen(i_bstrServerName);
    int nLen = 0;
    int nMinLen = 0;

    CFrsMember* pMember = NULL;
    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!mylstrncmpi(i_bstrServerName, (*it)->m_bstrServer, n))
        {
            nLen = lstrlen((*it)->m_bstrServer);
            if (!pMember || nLen < nMinLen)
            {
                nMinLen = nLen;
                pMember = *it;
            }
        }
    }

    if (!pMember)
        return S_FALSE; // no such member

    return _GetMemberInfo(pMember, o_pvarMember);
}

STDMETHODIMP CReplicaSet::IsFRSMember( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath
)
{
    if (!i_bstrDnsHostName || !*i_bstrDnsHostName ||
        !i_bstrRootPath || !*i_bstrRootPath)
        return S_FALSE;

    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!lstrcmpi(i_bstrDnsHostName, (*it)->m_bstrServer) &&
            !lstrcmpi(i_bstrRootPath, (*it)->m_bstrRootPath))
            break;
    }

    if (it == m_frsMemberList.end())
        return S_FALSE; // no such member

    return S_OK;
}

STDMETHODIMP CReplicaSet::IsHubMember( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath
)
{
    if (!i_bstrDnsHostName || !*i_bstrDnsHostName ||
        !i_bstrRootPath || !*i_bstrRootPath)
        return S_FALSE;

    if (0 != lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref))
        return S_FALSE; // not a hubspoke topology

    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!lstrcmpi(i_bstrDnsHostName, (*it)->m_bstrServer) &&
            !lstrcmpi(i_bstrRootPath, (*it)->m_bstrRootPath))
            break;
    }

    if (it == m_frsMemberList.end())
        return S_FALSE; // no such member

    if (!lstrcmpi(m_bstrHubMemberDN, (*it)->m_bstrMemberDN))
        return S_OK;

    return S_FALSE; 
}

STDMETHODIMP CReplicaSet::AddMember( 
        /* [in] */ BSTR i_bstrServer,
        /* [in] */ BSTR i_bstrRootPath,
        /* [in] */ BSTR i_bstrStagingPath,
        /* [in] */ BOOL i_bAddConnectionNow,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrMemberDN)
{
    CComBSTR    bstrComputerDomain;
    CComBSTR    bstrDnsHostName;
    CComBSTR    bstrComputerGuid;
    CComBSTR    bstrComputerDN;
    HRESULT     hr = GetServerInfo(i_bstrServer,
                        &bstrComputerDomain,
                        NULL, //o_pbstrNetbiosName
                        NULL, //o_pbValidDSObject
                        &bstrDnsHostName,
                        &bstrComputerGuid,
                        &bstrComputerDN
                        );
    if (S_OK != hr)
        return hr;   // don't add this member if it doesn't have an appropriate computer obj in a domain

    //
    // is i_bstrServer already a frs member
    //
    BOOL bIsFrsMember = FALSE;
    for (CFrsMemberList::iterator i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
    {
        if (!lstrcmpi(bstrComputerGuid, (*i)->m_bstrServerGuid))
        {
            bIsFrsMember = TRUE;
            break;
        }
    }

    if (bIsFrsMember)
    {
        if (0 != lstrcmpi(i_bstrRootPath, (*i)->m_bstrRootPath))
            return S_FALSE;    // cannot have two folders on the same computer join for the same replica set
 
        // member exists, return info of it
        if (o_pbstrMemberDN)
        {
            *o_pbstrMemberDN = (*i)->m_bstrMemberDN.Copy();
            RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrMemberDN);
        }
        return hr;
    }

    //
    // find out if the computer object sits in the same domain as the member object
    //
    CComBSTR bstrDCofComputerObj;
    BOOL bSameDomain = FALSE;
    PLDAP pldapComputer = NULL;
    if (!lstrcmpi(bstrComputerDomain, m_bstrDomain))
    {
        bSameDomain = TRUE;
        pldapComputer = m_pldap;
    } else
    {
        hr = ConnectToDS(bstrComputerDomain, &pldapComputer, &bstrDCofComputerObj);
        RETURN_IF_FAILED(hr);
    }

    CComBSTR bstrMemberDN;
    CComBSTR bstrSubscriberDN;
    do {
        //
        // create a nTFRSMember object in the DS
        //
        bstrMemberDN = _T("CN=");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += bstrComputerGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += m_bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);

        hr = CreateNtfrsMemberObject(m_pldap, bstrMemberDN, bstrComputerDN, bstrDCofComputerObj);
        BREAK_IF_FAILED(hr);

        //
        // create a nTFRSSubscriber object in the DS
        //
        hr = GetSubscriberDN(m_bstrReplicaSetDN, m_bstrDomainGuid, bstrComputerDN, &bstrSubscriberDN);
        BREAK_IF_FAILED(hr);

        hr = CreateNtfrsSubscriptionsObjects(pldapComputer, bstrSubscriberDN, bstrComputerDN);
        BREAK_IF_FAILED(hr);

        hr = CreateNtfrsSubscriberObject(
                    pldapComputer,
                    bstrSubscriberDN,
                    bstrMemberDN,
                    i_bstrRootPath,
                    i_bstrStagingPath,
                    m_bstrDC
                    );
    } while (0);

    if (!bSameDomain)
        CloseConnectionToDS(pldapComputer);

    RETURN_IF_FAILED(hr);

    //
    // add to m_frsMemberList
    //
    CFrsMember *pMember = new CFrsMember;
    hr = pMember->Init(
                    bstrDnsHostName,
                    bstrComputerDomain,
                    bstrComputerGuid,
                    i_bstrRootPath,
                    i_bstrStagingPath,
                    bstrMemberDN,
                    bstrComputerDN,
                    bstrSubscriberDN
                    );
   if (FAILED(hr))
   {
       delete pMember;
       return hr;
   }

    m_frsMemberList.push_back(pMember);

    //
    // if TopologyPref is not custom, add connections
    //
    if (i_bAddConnectionNow)
    {
        hr = _AdjustConnectionsAdd(bstrMemberDN);
        RETURN_IF_FAILED(hr);
    }

    //
    // if o_pbstrMemberDN specified, return o_pbstrMemberDN
    //
    if (o_pbstrMemberDN)
        *o_pbstrMemberDN = bstrMemberDN.Detach();

    return hr;
}

HRESULT CReplicaSet::_DeleteMember(CFrsMember* pFrsMember)
{
    HRESULT hr = S_OK;
    //
    // delete nTFRSSubscriber object
    //
    BOOL bSameDomain = FALSE;
    PLDAP pldapComputer = NULL;
    if (!lstrcmpi(pFrsMember->m_bstrDomain, m_bstrDomain))
    {
        bSameDomain = TRUE;
        pldapComputer = m_pldap;
    } else
    {
        hr = ConnectToDS(pFrsMember->m_bstrDomain, &pldapComputer, NULL);
        RETURN_IF_FAILED(hr);
    }

    hr = DeleteNtfrsSubscriberObjectAndContainers(
                                        pldapComputer, 
                                        pFrsMember->m_bstrSubscriberDN,
                                        pFrsMember->m_bstrComputerDN);

    if (!bSameDomain)
        CloseConnectionToDS(pldapComputer);

    RETURN_IF_FAILED(hr);

    //
    // adjust connections based on current topologyPref
    //
    if (m_frsMemberList.size() <= 2)
    {
        hr = _SetCustomTopologyPref();
    } else if (!lstrcmpi(FRS_RSTOPOLOGYPREF_RING, m_bstrTopologyPref))
    {
        BSTR bstrMemberDN[2];
        int i = 0;
        CFrsConnectionList::iterator it;
        for (it = m_frsConnectionList.begin(); (it != m_frsConnectionList.end()) && (i < 2); it++)
        {
            if (!lstrcmpi(pFrsMember->m_bstrMemberDN, (*it)->m_bstrFromMemberDN))
                bstrMemberDN[i++] = (*it)->m_bstrToMemberDN;
        }
        if (i != 2) 
            hr = _SetCustomTopologyPref(); // corrupted, reset to custom
        else
        {
            hr = AddConnection(bstrMemberDN[0], bstrMemberDN[1], TRUE, NULL);
            RETURN_IF_FAILED(hr);
            hr = AddConnection(bstrMemberDN[1], bstrMemberDN[0], TRUE, NULL);
        }
    }
    RETURN_IF_FAILED(hr);

    //
    // delete connections with other members
    //
    hr = _RemoveConnectionsFromAndTo(pFrsMember);
    RETURN_IF_FAILED(hr);

    //
    // delete nTFRSMember object
    //
    hr = DeleteDSObject(m_pldap, pFrsMember->m_bstrMemberDN, TRUE);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveMember( 
        /* [in] */ BSTR i_bstrMemberDN)
{
    HRESULT hr = S_OK;
    CFrsMemberList::iterator i;
    for (i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
    {
        if (!lstrcmpi(i_bstrMemberDN, (*i)->m_bstrMemberDN))
            break;
    }
    if (i == m_frsMemberList.end())
        return hr;  // no such member at all, return

    //
    // if it's the hub, change topologyPref to be custom
    //
    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref) &&
        !lstrcmpi(i_bstrMemberDN, m_bstrHubMemberDN))
    {
        hr = _SetCustomTopologyPref();
        RETURN_IF_FAILED(hr);
    }

    //
    // delete nTFRSSubscriber object
    // adjust connections
    // delete connections with other members
    // delete nTFRSMember object
    //
    hr = _DeleteMember((*i));

    //
    // remove it from m_frsMemberList
    //
    delete (*i);
    m_frsMemberList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveMemberEx( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath)
{
    HRESULT hr = S_OK;
    CFrsMemberList::iterator i;
    for (i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
    {
        if (!lstrcmpi(i_bstrDnsHostName, (*i)->m_bstrServer) &&
            !lstrcmpi(i_bstrRootPath, (*i)->m_bstrRootPath))
            break;
    }
    if (i == m_frsMemberList.end())
        return hr;  // no such member at all, return

    //
    // if it's the hub, change topologyPref to be custom
    //
    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref) &&
        !lstrcmpi((*i)->m_bstrMemberDN, m_bstrHubMemberDN))
    {
        hr = _SetCustomTopologyPref();
        RETURN_IF_FAILED(hr);
    }

    //
    // delete nTFRSSubscriber object
    // adjust connections
    // delete connections with other members
    // delete nTFRSMember object
    //
    hr = _DeleteMember((*i));

    //
    // remove it from m_frsMemberList
    //
    delete (*i);
    m_frsMemberList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveAllMembers()
{
    HRESULT hr = S_OK;
    CFrsMemberList::iterator i = m_frsMemberList.begin();
    while (i != m_frsMemberList.end())
    {
        //
        // delete nTFRSSubscriber object
        // adjust connections
        // delete connections with other members
        // delete nTFRSMember object
        //
        hr = _DeleteMember((*i));
        BREAK_IF_FAILED(hr);

        //
        // remove it from m_frsMemberList
        //
        delete (*i);
        m_frsMemberList.erase(i);

        i = m_frsMemberList.begin();
    }

    return hr;
}

HRESULT CReplicaSet::_PopulateConnectionList()
{
    PCTSTR ppszAttributes[] = {
                                ATTR_DISTINGUISHEDNAME,
                                ATTR_NTDS_CONNECTION_FROMSERVER,
                                ATTR_NTDS_CONNECTION_ENABLEDCONNECTION,
                                0
                                };

    LListElem* pElem = NULL;
    HRESULT hr = GetValuesEx(
                            m_pldap,
                            m_bstrReplicaSetDN,
                            LDAP_SCOPE_SUBTREE,
                            OBJCLASS_SF_NTDSCONNECTION,
                            ppszAttributes,
                            &pElem);
    RETURN_IF_FAILED(hr);

    LListElem* pCurElem = pElem;
    while (pCurElem)
    {
        PTSTR** pppszValues = pCurElem->pppszAttrValues;
        if (!pppszValues ||
            !pppszValues[0] || !*(pppszValues[0]) ||
            !pppszValues[1] || !*(pppszValues[1]) ||
            !pppszValues[2] || !*(pppszValues[2]))
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted connection object
        }

        PTSTR pszParentDN = _tcsstr(*(pppszValues[0]), _T(",CN="));
        if (!pszParentDN)
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted connection object
        }
        pszParentDN++; // point to the 2nd CN=XXX

        BOOL bFromServerFound = FALSE;
        BOOL bToServerFound = FALSE;
        CFrsMemberList::iterator i;
        for (i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
        {
            if (!bToServerFound && !lstrcmpi(pszParentDN, (*i)->m_bstrMemberDN))
            {
                bToServerFound = TRUE;
            }

            if (!bFromServerFound && !lstrcmpi(*(pppszValues[1]), (*i)->m_bstrMemberDN))
            {
                bFromServerFound = TRUE;
            }
        }
        if (!bFromServerFound || !bToServerFound)
        {
            pCurElem = pCurElem->Next;
            continue; // unknown fromServer or toServer, skip this connection
        }

        BOOL bEnable = !lstrcmpi(*(pppszValues[2]), CONNECTION_ENABLED_TRUE);
        CFrsConnection* pFrsConnection = new CFrsConnection;
        BREAK_OUTOFMEMORY_IF_NULL(pFrsConnection, &hr);
        hr = pFrsConnection->Init(
                                *(pppszValues[0]),  // FQDN
                                *(pppszValues[1]),  // fromServer
                                bEnable         // enableConnection
                                );
        if (FAILED(hr))
        {
            delete pFrsConnection;
            break;
        }

        m_frsConnectionList.push_back(pFrsConnection);

        pCurElem = pCurElem->Next;
    }

    FreeLListElem(pElem);

    if (FAILED(hr))
        FreeFrsConnections(&m_frsConnectionList);

    return hr;
}

STDMETHODIMP CReplicaSet::GetConnectionList( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnectionDNs)
{
    RETURN_INVALIDARG_IF_NULL(o_pvarConnectionDNs);

    VariantInit(o_pvarConnectionDNs);
    o_pvarConnectionDNs->vt = VT_ARRAY | VT_VARIANT;
    o_pvarConnectionDNs->parray = NULL;

    HRESULT hr = S_OK;
    int     cConnections = m_frsConnectionList.size();
    if (!cConnections)
        return hr;  // parray is NULL when the connection list is empty

    SAFEARRAYBOUND  bounds = {cConnections, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsConnectionList::iterator it;
    for (it = m_frsConnectionList.begin(); (it != m_frsConnectionList.end()) && (i < cConnections); it++, i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = ((*it)->m_bstrConnectionDN).Copy();
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        o_pvarConnectionDNs->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

STDMETHODIMP CReplicaSet::GetConnectionListEx( 
        /* [retval][out] */ VARIANT __RPC_FAR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    VariantInit(pVal);
    pVal->vt = VT_ARRAY | VT_VARIANT;
    pVal->parray = NULL;

    HRESULT hr = S_OK;
    int     cConnections = m_frsConnectionList.size();
    if (!cConnections)
        return hr;  // parray is NULL when the connection list is empty

    SAFEARRAYBOUND  bounds = {cConnections, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsConnectionList::iterator it;
    for (it = m_frsConnectionList.begin(); (it != m_frsConnectionList.end()) && (i < cConnections); it++, i++)
    {
        VariantInit(&(varArray[i]));
        hr = _GetConnectionInfo((*it), &(varArray[i]));
        BREAK_IF_FAILED(hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        pVal->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

HRESULT CReplicaSet::_GetConnectionInfo( 
    IN  CFrsConnection* i_pFrsConnection,
    OUT VARIANT*        o_pvarConnection)
{
    RETURN_INVALIDARG_IF_NULL(i_pFrsConnection);
    RETURN_INVALIDARG_IF_NULL(o_pvarConnection);

    HRESULT         hr = S_OK;
    SAFEARRAYBOUND  bounds = {NUM_OF_FRSCONNECTION_ATTRS, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    BSTR bstr[NUM_OF_FRSCONNECTION_ATTRS - 1] = {
                                    i_pFrsConnection->m_bstrConnectionDN,
                                    i_pFrsConnection->m_bstrFromMemberDN,
                                    i_pFrsConnection->m_bstrToMemberDN
                                        };

    for (int i = 0; i < NUM_OF_FRSCONNECTION_ATTRS - 1; i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = SysAllocString(bstr[i]);
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }
    if (SUCCEEDED(hr))
    {
        varArray[i].vt = VT_I4;
        varArray[i].lVal = (long)(i_pFrsConnection->m_bEnable);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
    {
        o_pvarConnection->vt = VT_ARRAY | VT_VARIANT;
        o_pvarConnection->parray = psa;
    } else
        SafeArrayDestroy(psa);

    return S_OK;
}

STDMETHODIMP CReplicaSet::GetConnectionInfo( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnection)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);

    CFrsConnectionList::iterator it;
    for (it = m_frsConnectionList.begin(); it != m_frsConnectionList.end(); it++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*it)->m_bstrConnectionDN))
            break;
    }

    if (it == m_frsConnectionList.end())
        return S_FALSE;

    return _GetConnectionInfo((*it), o_pvarConnection);
}

STDMETHODIMP CReplicaSet::AddConnection( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrConnectionDN)
{
    if (!lstrcmpi(i_bstrFromMemberDN, i_bstrToMemberDN))
        return S_OK;

    HRESULT hr = S_OK;

    //
    // is it an existing connection?
    //
    BOOL bIsFrsConnection = FALSE;
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
        {
            bIsFrsConnection = TRUE;
            break;
        }
    }
    if (bIsFrsConnection)
    {
        // connection exists, return info of it
        if (o_pbstrConnectionDN)
        {
            *o_pbstrConnectionDN = (*i)->m_bstrConnectionDN.Copy();
            RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrConnectionDN);
        }
        return hr;
    }

    //
    // locate the fromMember and the toMember in the m_frsMemberList
    //
    CFrsMemberList::iterator from;
    for (from = m_frsMemberList.begin(); from != m_frsMemberList.end(); from++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*from)->m_bstrMemberDN))
            break;
    }
    if (from == m_frsMemberList.end())
    {
        // fromServer is not a frsMember yet
        return E_INVALIDARG;
    }

    CFrsMemberList::iterator to;
    for (to = m_frsMemberList.begin(); to != m_frsMemberList.end(); to++)
    {
        if (!lstrcmpi(i_bstrToMemberDN, (*to)->m_bstrMemberDN))
            break;
    }
    if (to == m_frsMemberList.end())
    {
        // toServer is not a frsMember yet
        return E_INVALIDARG;
    }

    //
    // create the nTDSConnection object
    //
    CComBSTR bstrConnectionDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);
    bstrConnectionDN += (*from)->m_bstrServerGuid;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);
    bstrConnectionDN += _T(",");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);
    bstrConnectionDN += (*to)->m_bstrMemberDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);

    hr = CreateNtdsConnectionObject(
            m_pldap,
            bstrConnectionDN,
            i_bstrFromMemberDN,
            i_bEnable
            );
    RETURN_IF_FAILED(hr);

    //
    // add to m_frsConnectionList
    //
    CFrsConnection* pFrsConnection = new CFrsConnection;
    RETURN_OUTOFMEMORY_IF_NULL(pFrsConnection);
    hr = pFrsConnection->Init(
                            bstrConnectionDN,  // FQDN
                            i_bstrFromMemberDN,  // fromServer
                            i_bEnable         // enableConnection
                            );
    if (FAILED(hr))
    {
        delete pFrsConnection;
        return hr;
    }

    m_frsConnectionList.push_back(pFrsConnection);

    //
    // if o_pbstrConnectionDN specified, return o_pbstrConnectionDN
    //
    if (o_pbstrConnectionDN)
        *o_pbstrConnectionDN = bstrConnectionDN.Detach();

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveConnection( 
        /* [in] */ BSTR i_bstrConnectionDN)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return hr; // no such connection, return

    //
    // delete the nTDSConnection object
    //
    hr = DeleteDSObject(m_pldap, (*i)->m_bstrConnectionDN, TRUE);
    RETURN_IF_FAILED(hr);

    //
    // remove it from m_frsConnectionList
    //
    delete (*i);
    m_frsConnectionList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveConnectionEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return hr; // no such connection, return

    //
    // delete the nTDSConnection object
    //
    hr = DeleteDSObject(m_pldap, (*i)->m_bstrConnectionDN, TRUE);
    RETURN_IF_FAILED(hr);

    //
    // remove it from m_frsConnectionList
    //
    delete (*i);
    m_frsConnectionList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveAllConnections()
{
    HRESULT hr = S_OK;

    CFrsConnectionList::iterator i = m_frsConnectionList.begin();
    while (i != m_frsConnectionList.end())
    {
        //
        // delete the nTDSConnection object
        //
        hr = DeleteDSObject(m_pldap, (*i)->m_bstrConnectionDN, TRUE);
        BREAK_IF_FAILED(hr);

        //
        // remove it from m_frsConnectionList
        //
        delete (*i);
        m_frsConnectionList.erase(i);

        i = m_frsConnectionList.begin();
    }

    return hr;
}

HRESULT CReplicaSet::_RemoveConnectionsFromAndTo(CFrsMember* pFrsMember)
{
    RETURN_INVALIDARG_IF_NULL(pFrsMember);

    HRESULT hr = S_OK;

    CFrsConnectionList::iterator i = m_frsConnectionList.begin();
    while (i != m_frsConnectionList.end())
    {
        CFrsConnectionList::iterator itConn = i++;
        if (!lstrcmpi(pFrsMember->m_bstrMemberDN, (*itConn)->m_bstrFromMemberDN) ||
            !lstrcmpi(pFrsMember->m_bstrMemberDN, (*itConn)->m_bstrToMemberDN))
        {
            //
            // delete the nTDSConnection object
            //
            hr = DeleteDSObject(m_pldap, (*itConn)->m_bstrConnectionDN, TRUE);
            RETURN_IF_FAILED(hr);

            //
            // remove it from m_frsConnectionList
            //
            delete (*itConn);
            m_frsConnectionList.erase(itConn);
        }
    }

    return hr;
}

STDMETHODIMP CReplicaSet::EnableConnection( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ BOOL i_bEnable)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    //
    // update attribute enabledConnection of this nTDSConnection object
    //
    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_ENABLEDCONNECTION;
    pAttrVals[0].vpValue = (void *)(i_bEnable ? CONNECTION_ENABLED_TRUE : CONNECTION_ENABLED_FALSE);
    pAttrVals[0].bBerValue = false;

    hr = ::ModifyValues(m_pldap, (*i)->m_bstrConnectionDN, 1, pAttrVals);

    //
    // update i in the m_frsConnectionList
    //
    if (SUCCEEDED(hr))
        (*i)->m_bEnable = i_bEnable;

    return hr;
}

STDMETHODIMP CReplicaSet::EnableConnectionEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    //
    // update attribute enabledConnection of this nTDSConnection object
    //
    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_ENABLEDCONNECTION;
    pAttrVals[0].vpValue = (void *)(i_bEnable ? CONNECTION_ENABLED_TRUE : CONNECTION_ENABLED_FALSE);
    pAttrVals[0].bBerValue = false;

    hr = ::ModifyValues(m_pldap, (*i)->m_bstrConnectionDN, 1, pAttrVals);

    //
    // update i in the m_frsConnectionList
    //
    if (SUCCEEDED(hr))
        (*i)->m_bEnable = i_bEnable;

    return hr;
}

HRESULT CReplicaSet::_GetConnectionSchedule( 
        /* [in] */ BSTR                 i_bstrConnectionDN,
        /* [retval][out] */ VARIANT*    o_pVar)
{
    //
    // get attribute schedule of this nTDSConnection object
    //
    PLDAP_ATTR_VALUE    pValues[2] = {0,0};
    LDAP_ATTR_VALUE     pAttributes[1];
    pAttributes[0].bstrAttribute = ATTR_NTDS_CONNECTION_SCHEDULE;
    pAttributes[0].bBerValue = true;

    HRESULT hr = GetValues( m_pldap,
                    i_bstrConnectionDN,
                    OBJCLASS_SF_NTDSCONNECTION,
                    LDAP_SCOPE_BASE,
                    1,
                    pAttributes,
                    pValues);

    if (SUCCEEDED(hr) && pValues[0])
    {
        hr = ScheduleToVariant((SCHEDULE *)(pValues[0]->vpValue), o_pVar);

        FreeAttrValList(pValues[0]);
    
    } else if (!(pValues[0]) || HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED) == hr)
    {
        SCHEDULE *pSchedule = NULL;
        hr = GetDefaultSchedule(&pSchedule);
        if (SUCCEEDED(hr))
        {
            hr = ScheduleToVariant(pSchedule, o_pVar);
            free(pSchedule);
        }
    }

    return hr;
}

STDMETHODIMP CReplicaSet::GetConnectionSchedule( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT* o_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(o_pVar);

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    return _GetConnectionSchedule(i_bstrConnectionDN, o_pVar);
}

STDMETHODIMP CReplicaSet::GetConnectionScheduleEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [retval][out] */ VARIANT* o_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrToMemberDN);
    RETURN_INVALIDARG_IF_NULL(o_pVar);

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    return _GetConnectionSchedule((*i)->m_bstrConnectionDN, o_pVar);
}

STDMETHODIMP CReplicaSet::SetConnectionSchedule( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ VARIANT* i_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_pVar);

    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    SCHEDULE *pSchedule = NULL;
    hr = VariantToSchedule(i_pVar, &pSchedule);
    RETURN_IF_FAILED(hr);

    hr = ::SetConnectionSchedule(m_pldap, (*i)->m_bstrConnectionDN, pSchedule);

    free(pSchedule);

    return hr;
}

STDMETHODIMP CReplicaSet::SetConnectionScheduleEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ VARIANT* i_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrToMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_pVar);

    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    SCHEDULE *pSchedule = NULL;
    hr = VariantToSchedule(i_pVar, &pSchedule);
    RETURN_IF_FAILED(hr);

    hr = ::SetConnectionSchedule(m_pldap, (*i)->m_bstrConnectionDN, pSchedule);

    free(pSchedule);

    return hr;
}

STDMETHODIMP CReplicaSet::SetScheduleOnAllConnections( 
        /* [in] */ VARIANT* i_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_pVar);

    HRESULT hr = S_OK;

    SCHEDULE *pSchedule = NULL;
    hr = VariantToSchedule(i_pVar, &pSchedule);
    RETURN_IF_FAILED(hr);

    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        hr = ::SetConnectionSchedule(m_pldap, (*i)->m_bstrConnectionDN, pSchedule);
        BREAK_IF_FAILED(hr);
    }

    free(pSchedule);

    return hr;
}

STDMETHODIMP CReplicaSet::CreateConnections()
{
    HRESULT hr = S_OK;

    //
    // create connections from scratch
    //
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM))
        return hr;

    CFrsMemberList::iterator n1;
    CFrsMemberList::iterator n2;
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_RING))
    {
        CFrsMemberList::iterator head;

        head = n1 = m_frsMemberList.begin();
        while (n1 != m_frsMemberList.end())
        {
            n2 = n1++;
            if (n1 == m_frsMemberList.end())
            {
                if (m_frsMemberList.size() == 2)
                    break;

                n1 = head;
            }

            hr = AddConnection((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN, TRUE, NULL);
            BREAK_IF_FAILED(hr);
            hr = AddConnection((*n2)->m_bstrMemberDN, (*n1)->m_bstrMemberDN, TRUE, NULL);
            BREAK_IF_FAILED(hr);

            if (n1 == head)
                break;
        }
    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
        {
            if (!lstrcmpi((*n1)->m_bstrMemberDN, m_bstrHubMemberDN))
                continue;

            hr = AddConnection((*n1)->m_bstrMemberDN, m_bstrHubMemberDN, TRUE, NULL);
            BREAK_IF_FAILED(hr);
            hr = AddConnection(m_bstrHubMemberDN, (*n1)->m_bstrMemberDN, TRUE, NULL);
            BREAK_IF_FAILED(hr);
        }
    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_FULLMESH))
    {
        for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
        {
            for (n2 = m_frsMemberList.begin(); n2 != m_frsMemberList.end(); n2++)
            {
                if (!lstrcmpi((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN))
                    continue;

                hr = AddConnection((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN, TRUE, NULL);
                BREAK_IF_FAILED(hr);
            }
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}

STDMETHODIMP CReplicaSet::Delete()
{
    dfsDebugOut((_T("Delete ReplicaSet: %s\n"), m_bstrReplicaSetDN));

    HRESULT hr = S_OK;

    //
    // delete all connections
    //
    hr = RemoveAllConnections();
    RETURN_IF_FAILED(hr);

    //
    // delete all members
    //
    // Note: the nTFRSReplicaSet object will be deleted if empty
    //
    hr = RemoveAllMembers();
    RETURN_IF_FAILED(hr);

    //
    // delete nTFRSReplicaSettings container objects if empty
    //
    (void) DeleteNtfrsReplicaSetObjectAndContainers(m_pldap, m_bstrReplicaSetDN);

    //
    // Reset this instance
    //
    _FreeMemberVariables();

    return hr;
}

HRESULT CReplicaSet::_SetCustomTopologyPref()
{
    HRESULT hr = put_TopologyPref(FRS_RSTOPOLOGYPREF_CUSTOM);

    if (SUCCEEDED(hr))
        hr = put_HubMemberDN(_T(""));

    return hr;
}

HRESULT CReplicaSet::_AdjustConnectionsAdd(BSTR i_bstrNewMemberDN)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrNewMemberDN);

    HRESULT hr = S_OK;

    //
    // adjust connections after pFrsMember is added
    //
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM) || m_frsMemberList.empty())
        return hr;

    if (m_frsMemberList.size() == 2)
    {
        CFrsMemberList::iterator head = m_frsMemberList.begin();
        hr = AddConnection((*head)->m_bstrMemberDN, i_bstrNewMemberDN, TRUE, NULL);
        if (SUCCEEDED(hr))
            hr = AddConnection(i_bstrNewMemberDN, (*head)->m_bstrMemberDN, TRUE, NULL);
        return hr;
    }

    CFrsMemberList::iterator n1;
    CFrsMemberList::iterator n2;
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_RING))
    {
        n1 = m_frsMemberList.begin();
        n2 = n1++;

        hr = AddConnection((*n1)->m_bstrMemberDN, i_bstrNewMemberDN, TRUE, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(i_bstrNewMemberDN, (*n1)->m_bstrMemberDN, TRUE, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection((*n2)->m_bstrMemberDN, i_bstrNewMemberDN, TRUE, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(i_bstrNewMemberDN, (*n2)->m_bstrMemberDN, TRUE, NULL);
        RETURN_IF_FAILED(hr);

        if (m_frsMemberList.size() > 3)
        {
            hr = RemoveConnectionEx((*n2)->m_bstrMemberDN, (*n1)->m_bstrMemberDN);
            RETURN_IF_FAILED(hr);
            hr = RemoveConnectionEx((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN);
            RETURN_IF_FAILED(hr);
        }

    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        hr = AddConnection(i_bstrNewMemberDN, m_bstrHubMemberDN, TRUE, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(m_bstrHubMemberDN, i_bstrNewMemberDN, TRUE, NULL);
        RETURN_IF_FAILED(hr);

    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_FULLMESH))
    {
        for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
        {
            hr = AddConnection((*n1)->m_bstrMemberDN, i_bstrNewMemberDN, TRUE, NULL);
            BREAK_IF_FAILED(hr);
            hr = AddConnection(i_bstrNewMemberDN, (*n1)->m_bstrMemberDN, TRUE, NULL);
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  _FreeMemberVariables

void FreeDfsAlternates(CDfsAlternateList* pList)
{
    if (pList && !pList->empty())
    {
        for (CDfsAlternateList::iterator i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}

void FreeFrsMembers(CFrsMemberList* pList)
{
    if (pList && !pList->empty())
    {
        for (CFrsMemberList::iterator i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}

void FreeFrsConnections(CFrsConnectionList* pList)
{
    if (pList && !pList->empty())
    {
        for (CFrsConnectionList::iterator i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}

void CReplicaSet::_FreeMemberVariables()
{
    m_bstrType.Empty();
    m_bstrTopologyPref.Empty();

    m_bstrHubMemberDN.Empty();
    m_bstrPrimaryMemberDN.Empty();
    m_bstrFileFilter.Empty();
    m_bstrDirFilter.Empty();
    m_bstrDfsEntryPath.Empty();
    m_bstrReplicaSetDN.Empty();

    FreeDfsAlternates(&m_dfsAlternateList);
    FreeFrsMembers(&m_frsMemberList);
    FreeFrsConnections(&m_frsConnectionList);

    m_bstrDomain.Empty();
    m_bstrDomainGuid.Empty();
    m_bstrDC.Empty();
    m_bNewSchema = FALSE;

    if (m_pldap)
    {
        CloseConnectionToDS(m_pldap);
        m_pldap = NULL;
    }
}

///////////////////////////////////////////////////////////////////
//
// CFrsMember
//

HRESULT CFrsMember::InitEx(
    PLDAP   i_pldap,                // points to the i_bstrMemberDN's DS
    BSTR    i_bstrDC,               // domain controller pointed by i_pldap
    BSTR    i_bstrMemberDN,         // FQDN of nTFRSMember object
    BSTR    i_bstrComputerDN        // =NULL, FQDN of computer object
)
{
    _ReSet();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDC);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);

    HRESULT hr = S_OK;

    do {
        m_bstrMemberDN = i_bstrMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrMemberDN, &hr);

        if (i_bstrComputerDN && *i_bstrComputerDN)
        {
            m_bstrComputerDN = i_bstrComputerDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrComputerDN, &hr);
        }

        hr = _GetMemberInfo(i_pldap, i_bstrDC, m_bstrMemberDN, m_bstrComputerDN);
    } while (0);

    if (S_OK != hr)
        _ReSet();

    return hr; 
}

HRESULT CFrsMember::Init(
    IN BSTR i_bstrDnsHostName,
    IN BSTR i_bstrComputerDomain,
    IN BSTR i_bstrComputerGuid,
    IN BSTR i_bstrRootPath,
    IN BSTR i_bstrStagingPath,
    IN BSTR i_bstrMemberDN,
    IN BSTR i_bstrComputerDN,
    IN BSTR i_bstrSubscriberDN
    )
{
    _ReSet();

    RETURN_INVALIDARG_IF_NULL(i_bstrDnsHostName);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerGuid);
    RETURN_INVALIDARG_IF_NULL(i_bstrRootPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrStagingPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);

    HRESULT hr = S_OK;
    do {
        hr = GetSiteName(i_bstrDnsHostName, &m_bstrSite);
        BREAK_IF_FAILED(hr);

        m_bstrServer = i_bstrDnsHostName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServer, &hr);

        m_bstrDomain = i_bstrComputerDomain;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

        m_bstrServerGuid = i_bstrComputerGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServerGuid, &hr);

        m_bstrRootPath = i_bstrRootPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrRootPath, &hr);

        m_bstrStagingPath = i_bstrStagingPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStagingPath, &hr);

        m_bstrMemberDN = i_bstrMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrMemberDN, &hr);

        m_bstrComputerDN = i_bstrComputerDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrComputerDN, &hr);

        m_bstrSubscriberDN = i_bstrSubscriberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSubscriberDN, &hr);
    } while (0);

    if (FAILED(hr))
        _ReSet();

    return hr;
}

CFrsMember* CFrsMember::Copy()
{
    CFrsMember* pNew = new CFrsMember;
    
    if (pNew)
    {
        HRESULT hr = S_OK;

        do {
            pNew->m_bstrServer = m_bstrServer;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrServer, &hr);
            pNew->m_bstrSite = m_bstrSite;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrSite, &hr);
            pNew->m_bstrDomain = m_bstrDomain;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrDomain, &hr);
            pNew->m_bstrServerGuid = m_bstrServerGuid;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrServerGuid, &hr);

            pNew->m_bstrRootPath = m_bstrRootPath;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrRootPath, &hr);
            pNew->m_bstrStagingPath = m_bstrStagingPath;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrStagingPath, &hr);

            pNew->m_bstrMemberDN = m_bstrMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrMemberDN, &hr);
            pNew->m_bstrComputerDN = m_bstrComputerDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrComputerDN, &hr);
            pNew->m_bstrSubscriberDN = m_bstrSubscriberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrSubscriberDN, &hr);
        } while (0);

        if (FAILED(hr))
        {
            delete pNew;
            pNew = NULL;
        }
    }

    return pNew;
}

void CFrsMember::_ReSet()
{
    m_bstrServer.Empty();
    m_bstrSite.Empty();
    m_bstrDomain.Empty();
    m_bstrServerGuid.Empty();

    m_bstrRootPath.Empty();
    m_bstrStagingPath.Empty();

    m_bstrMemberDN.Empty();
    m_bstrComputerDN.Empty();
    m_bstrSubscriberDN.Empty();
}

//
// Given: MemberDN
// Read: ComputerDN, Domain, Site, ServerName 
//
// Return:
//      S_FALSE if no such object found
//
HRESULT CFrsMember::_GetMemberInfo
(
    PLDAP   i_pldap,            // points to the i_bstrMemberDN's DS
    BSTR    i_bstrDC,           // domain controller pointed by i_pldap
    BSTR    i_bstrMemberDN,     // FQDN of nTFRSMember object
    BSTR    i_bstrComputerDN    // = NULL FQDN of computer object
)
{
    m_bstrDomain.Empty();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDC);
    RETURN_INVALIDARG_IF_NULL(*i_bstrDC);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrMemberDN);

    HRESULT hr = S_OK;

    do {
        if (!i_bstrComputerDN || !*i_bstrComputerDN)
        {
            m_bstrComputerDN.Empty();

            //
            // Read:
            //      m_bstrComputerDN
            //
            PLDAP_ATTR_VALUE  pValues[2] = {0,0};
            LDAP_ATTR_VALUE  pAttributes[1];
            pAttributes[0].bstrAttribute = ATTR_FRS_MEMBER_COMPUTERREF;

            hr = GetValues( i_pldap,
                            m_bstrMemberDN,
                            OBJCLASS_SF_NTFRSMEMBER,
                            LDAP_SCOPE_BASE,
                            1,
                            pAttributes,
                            pValues);
            BREAK_IF_FAILED(hr);

            hr = E_FAIL;
            if (pValues[0])
            {
                m_bstrComputerDN = (PTSTR)(pValues[0]->vpValue);
                hr = (!m_bstrComputerDN) ? E_OUTOFMEMORY : S_OK;

                FreeAttrValList(pValues[0]);
            }

            BREAK_IF_FAILED(hr);
        }

        //
        // retrieve the domain for both ComputerDN and i_bstrMemberDN
        // If they are the same, reuse the handle to the LDAP port; 
        // otherwise, open a new handle.
        //
        // Read:
        //      m_bstrDomainDN
        //
        BOOL    bSameDomain = FALSE;
        HANDLE  hDS = NULL;
        DWORD   dwErr = DsBind(i_bstrDC, NULL, &hDS);
        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

        const PTSTR         pszFQDNs[2] = {(BSTR)m_bstrComputerDN, i_bstrMemberDN};
        DS_NAME_RESULT*     pDsNameResult = NULL;
        dwErr = DsCrackNames(
                            hDS,
                            DS_NAME_NO_FLAGS,
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            2,
                            pszFQDNs,
                            &pDsNameResult
                            );
        if (NO_ERROR == dwErr)
        {
            do {
                PDS_NAME_RESULT_ITEM pItem = pDsNameResult->rItems;

                if (DS_NAME_NO_ERROR != pItem->status)
                {
                    dwErr = pItem->status;
                } else
                {
                    // retrieve info of m_bstrComputerDN
                    m_bstrDomain = pItem->pDomain;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

                    // retrieve info of i_bstrMemberDN
                    pItem++;
                    if (DS_NAME_NO_ERROR != pItem->status)
                    {
                        dwErr = pItem->status;
                    } else
                    {
                        bSameDomain = !mylstrncmpi(m_bstrDomain, pItem->pDomain, lstrlen(m_bstrDomain));
                    }
                }
            } while (0);

            DsFreeNameResult(pDsNameResult);
        }

        DsUnBind(&hDS);

        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

        //
        // Create a new ldap handle if not in the same domain
        //
        PLDAP pldapComputer = NULL;
        if (bSameDomain)
            pldapComputer = i_pldap;
        else
        {
            hr = ConnectToDS(m_bstrDomain, &pldapComputer);
            BREAK_IF_FAILED(hr);
        }

        //
        // Read:
        //      m_bstrSubscriberDN, m_bstrRootPath, m_bstrStagingPath
        //
        hr = _GetSubscriberInfo(pldapComputer, m_bstrComputerDN, i_bstrMemberDN);

        //
        // Read:
        //      m_bstrServer, m_bstrServerGuid, m_bstrSite
        //
        if (S_OK == hr)
            hr = _GetComputerInfo(pldapComputer, m_bstrComputerDN);

        //
        // Close the newly created ldap handle
        //
        if (!bSameDomain)
            CloseConnectionToDS(pldapComputer);
    } while (0);

    if (S_OK != hr)
    {
        if (!i_bstrComputerDN || !*i_bstrComputerDN)
            m_bstrComputerDN.Empty();

        m_bstrDomain.Empty();
    }

    return hr;
}

//
// Given: ComputerDN, MemberDN
// Read:
//      m_bstrSubscriberDN, m_bstrRootPath, m_bstrStagingPath
//
// Return:
//      S_FALSE if no such object found
//
HRESULT CFrsMember::_GetSubscriberInfo
(
    PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
    BSTR    i_bstrComputerDN,   // FQDN of the computer object
    BSTR    i_bstrMemberDN      // FQDN of the corresponding nTFRSMember object
)
{
    m_bstrSubscriberDN.Empty();
    m_bstrRootPath.Empty();
    m_bstrStagingPath.Empty();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrMemberDN);

    //
    // locate the nTFRSSubscriber object whose attribute "frsMemberReference"
    // matches i_bstrMemberDN
    //
    CComBSTR bstrSearchFilter = _T("(&(objectCategory=nTFRSSubscriber)(frsMemberReference=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSearchFilter);
    bstrSearchFilter += i_bstrMemberDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSearchFilter);
    bstrSearchFilter += _T("))");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSearchFilter);

    PCTSTR ppszAttributes[] = {
                                ATTR_DISTINGUISHEDNAME,
                                ATTR_FRS_SUBSCRIBER_ROOTPATH,
                                ATTR_FRS_SUBSCRIBER_STAGINGPATH,
                                0
                                };

    LListElem* pElem = NULL;
    HRESULT hr = GetValuesEx(
                            i_pldap,
                            i_bstrComputerDN,
                            LDAP_SCOPE_SUBTREE,
                            bstrSearchFilter,
                            ppszAttributes,
                            &pElem);
    RETURN_IF_FAILED(hr);
    if (!pElem) // no matching nTFRSSubscriber object
        return S_FALSE;

    LListElem* pCurElem = pElem;
    while (pCurElem)
    {
        PTSTR** pppszValues = pCurElem->pppszAttrValues;
        if (!pppszValues ||
            !pppszValues[0] || !*(pppszValues[0]) ||
            !pppszValues[1] || !*(pppszValues[1]) ||
            !pppszValues[2] || !*(pppszValues[2]))
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted subscriber object
        }

        m_bstrSubscriberDN = *(pppszValues[0]);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSubscriberDN, &hr);
        m_bstrRootPath = *(pppszValues[1]);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrRootPath, &hr);
        m_bstrStagingPath = *(pppszValues[2]);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStagingPath, &hr);

        pCurElem = pCurElem->Next;
    }

    FreeLListElem(pElem);

    if (FAILED(hr))
    {
        m_bstrSubscriberDN.Empty();
        m_bstrRootPath.Empty();
        m_bstrStagingPath.Empty();
    }

    return hr;
}

//
// Given: ComputerDN
// Read:  m_bstrServer, m_bstrServerGuid, m_bstrSite
//
HRESULT CFrsMember::_GetComputerInfo
(
    PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
    BSTR    i_bstrComputerDN    // FQDN of the computer object
)
{
    m_bstrServer.Empty();
    m_bstrServerGuid.Empty();
    m_bstrSite.Empty();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrComputerDN);

    HRESULT hr = S_OK;

    do {
        //
        // read dNSHostName and objectGUID on the ComputerDN
        //
        PLDAP_ATTR_VALUE    pValues[3] = {0,0,0};
        LDAP_ATTR_VALUE     pAttributes[2];
        pAttributes[0].bstrAttribute = ATTR_DNSHOSTNAME;
        pAttributes[1].bstrAttribute = ATTR_OBJECTGUID;
        pAttributes[1].bBerValue = true;

        hr = GetValues( i_pldap,
                        i_bstrComputerDN,
                        OBJCLASS_SF_COMPUTER,
                        LDAP_SCOPE_BASE,
                        2,
                        pAttributes,
                        pValues);
        BREAK_IF_FAILED(hr);

        hr = E_FAIL;
        if (pValues[0])
        {
            m_bstrServer = (PTSTR)(pValues[0]->vpValue);
            hr = (!m_bstrServer) ? E_OUTOFMEMORY : S_OK;

            FreeAttrValList(pValues[0]);
        }

        if (pValues[1])
        {
            if (SUCCEEDED(hr))
            {
                if (pValues[1]->bBerValue)
                {
                    hr = UuidToStructuredString((UUID*)(pValues[1]->vpValue), &m_bstrServerGuid);
                } else
                {
                    m_bstrServerGuid = (PTSTR)(pValues[1]->vpValue);
                    hr = (!m_bstrServerGuid) ? E_OUTOFMEMORY : S_OK;
                }
            }

            FreeAttrValList(pValues[1]);
        }

        BREAK_IF_FAILED(hr);

        //
        // retrieve Site
        //
        hr = GetSiteName(m_bstrServer, &m_bstrSite);
        BREAK_IF_FAILED(hr);

    } while (0);

    if (FAILED(hr))
    {
        m_bstrServer.Empty();
        m_bstrServerGuid.Empty();
        m_bstrSite.Empty();
    }

    return hr;
}

//////////////////////////////////////////////////////////
//
// CFrsConnection
//

HRESULT CFrsConnection::Init(
    BSTR i_bstrConnectionDN,
    BSTR i_bstrFromMemberDN,
    BOOL i_bEnable)
{
    _ReSet();

    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);

    HRESULT hr = S_OK;
    do {
        m_bstrConnectionDN = i_bstrConnectionDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrConnectionDN, &hr);

        m_bstrFromMemberDN = i_bstrFromMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromMemberDN, &hr);

        TCHAR* p = _tcschr(m_bstrConnectionDN, _T(','));
        if (!p)
        {
            hr = E_INVALIDARG;
            break;
        }
        m_bstrToMemberDN = p + 1;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToMemberDN, &hr);

        m_bEnable = i_bEnable;
    } while (0);

    if (FAILED(hr))
        _ReSet();

    return hr;
}

CFrsConnection* CFrsConnection::Copy()
{
    CFrsConnection* pNew = new CFrsConnection;
    
    if (pNew)
    {
        HRESULT hr = S_OK;

        do {
            pNew->m_bstrConnectionDN = m_bstrConnectionDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrConnectionDN, &hr);
            pNew->m_bstrFromMemberDN = m_bstrFromMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrFromMemberDN, &hr);
            pNew->m_bstrToMemberDN = m_bstrToMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrToMemberDN, &hr);

            pNew->m_bEnable = m_bEnable;
        } while (0);

        if (FAILED(hr))
        {
            delete pNew;
            pNew = NULL;
        }
    }

    return pNew;
}

void CFrsConnection::_ReSet()
{
    m_bstrConnectionDN.Empty();
    m_bstrFromMemberDN.Empty();
    m_bstrToMemberDN.Empty();

    m_bEnable = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\repset.h ===
/*++
Module Name:
    RepSet.h

Abstract:

--*/


#ifndef __REPSET_H_
#define __REPSET_H_

#include "resource.h"       // main symbols
#include "dfsenums.h"
#include "netutils.h"
#include "ldaputils.h"

#include <list>
using namespace std;

class CFrsMember;

class CDfsAlternate
{
public:
    CComBSTR                    m_bstrServer;
    CComBSTR                    m_bstrShare;
    CFrsMember*                 m_pFrsMember;
};

class CFrsMember
{
public:
    CComBSTR                    m_bstrServer;
    CComBSTR                    m_bstrSite;
    CComBSTR                    m_bstrDomain;
    CComBSTR                    m_bstrServerGuid;

    CComBSTR                    m_bstrRootPath;
    CComBSTR                    m_bstrStagingPath;

    CComBSTR                    m_bstrMemberDN;
    CComBSTR                    m_bstrComputerDN;
    CComBSTR                    m_bstrSubscriberDN;

public:
    //
    // InitEx does query DS to retrieve related info
    //
    HRESULT InitEx(
        PLDAP   i_pldap,                // points to the i_bstrMemberDN's DS
        BSTR    i_bstrDC,               // domain controller pointed by i_pldap
        BSTR    i_bstrMemberDN,         // FQDN of nTFRSMember object
        BSTR    i_bstrComputerDN = NULL // FQDN of computer object
    );

    //
    // Init does NOT query DS
    //
    HRESULT Init(
        IN BSTR i_bstrDnsHostName,
        IN BSTR i_bstrComputerDomain,
        IN BSTR i_bstrComputerGuid,
        IN BSTR i_bstrRootPath,
        IN BSTR i_bstrStagingPath,
        IN BSTR i_bstrMemberDN,
        IN BSTR i_bstrComputerDN,
        IN BSTR i_bstrSubscriberDN
        );

    CFrsMember* Copy();

private:
    void _ReSet();

    HRESULT _GetMemberInfo(
        PLDAP   i_pldap,                // points to the i_bstrMemberDN's DS
        BSTR    i_bstrDC,               // domain controller pointed by i_pldap
        BSTR    i_bstrMemberDN,         // FQDN of nTFRSMember object
        BSTR    i_bstrComputerDN = NULL // FQDN of computer object
    );

    HRESULT _GetSubscriberInfo
    (
        PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
        BSTR    i_bstrComputerDN,   // FQDN of the computer object
        BSTR    i_bstrMemberDN      // FQDN of the corresponding nTFRSMember object
    );

    HRESULT _GetComputerInfo
    (
        PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
        BSTR    i_bstrComputerDN    // FQDN of the computer object
    );

};

class CFrsConnection
{
public:
    CComBSTR                    m_bstrConnectionDN;
    CComBSTR                    m_bstrFromMemberDN;
    CComBSTR                    m_bstrToMemberDN;
    BOOL                        m_bEnable;

    //
    // Init Does NOT query DS
    //
    HRESULT Init(
        BSTR i_bstrConnectionDN,
        BSTR i_bstrFromMemberDN,
        BOOL i_bEnable
        );

    CFrsConnection* Copy();

protected:
    void _ReSet();

};

typedef list<CDfsAlternate *>    CDfsAlternateList;
typedef list<CFrsMember *>       CFrsMemberList;
typedef list<CFrsConnection *>   CFrsConnectionList;

void FreeDfsAlternates(CDfsAlternateList* pList);
void FreeFrsMembers(CFrsMemberList* pList);
void FreeFrsConnections(CFrsConnectionList* pList);

class ATL_NO_VTABLE CReplicaSet : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CReplicaSet, &CLSID_ReplicaSet>,
    public IDispatchImpl<IReplicaSet, &IID_IReplicaSet, &LIBID_DFSCORELib>
{
public:
    CReplicaSet();

    ~CReplicaSet();
    
DECLARE_REGISTRY_RESOURCEID(IDR_REPLICASET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CReplicaSet)
    COM_INTERFACE_ENTRY(IReplicaSet)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IReplicaSet
    STDMETHOD(get_Type)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_Type)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_TopologyPref)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_TopologyPref)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_HubMemberDN)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_HubMemberDN)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_PrimaryMemberDN)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_PrimaryMemberDN)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_FileFilter)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_FileFilter)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_DirFilter)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_DirFilter)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_DfsEntryPath)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(get_Domain)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(get_ReplicaSetDN)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(get_NumOfMembers)( 
        /* [retval][out] */ long __RPC_FAR *pVal);

    STDMETHOD(get_NumOfConnections)( 
        /* [retval][out] */ long __RPC_FAR *pVal);

    STDMETHOD(get_TargetedDC)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(Create)(
		/* [in] */ BSTR i_bstrDomain,
        /* [in] */ BSTR i_bstrReplicaSetDN,
        /* [in] */ BSTR i_bstrType,
		/* [in] */ BSTR i_bstrTopologyPref,
        /* [in] */ BSTR i_bstrHubMemberDN,
		/* [in] */ BSTR i_bstrPrimaryMemberDN,
        /* [in] */ BSTR i_bstrFileFilter,
		/* [in] */ BSTR i_bstrDirFilter
    );

    STDMETHOD(Initialize)( 
        /* [in] */ BSTR i_bstrDomain,
        /* [in] */ BSTR i_bstrReplicaSetDN);

    STDMETHOD(GetMemberList)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMemberDNs);

    STDMETHOD(GetMemberListEx)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pVal);

    STDMETHOD(GetMemberInfo)( 
        /* [in] */ BSTR i_bstrMemberDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember);

    STDMETHOD(IsFRSMember)( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath);

    STDMETHOD(IsHubMember)( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath);

    STDMETHOD(AddMember)( 
        /* [in] */ BSTR i_bstrServer,
        /* [in] */ BSTR i_bstrRootPath,
        /* [in] */ BSTR i_bstrStagingPath,
        /* [in] */ BOOL i_bAddConnectionNow,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrMemberDN);

    STDMETHOD(RemoveMember)( 
        /* [in] */ BSTR i_bstrMemberDN);

    STDMETHOD(RemoveMemberEx)( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath);

    STDMETHOD(RemoveAllMembers)();

    STDMETHOD(GetConnectionList)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnectionDNs);

    STDMETHOD(GetConnectionListEx)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pVal);

    STDMETHOD(GetConnectionInfo)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnection);

    STDMETHOD(AddConnection)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrConnectionDN);

    STDMETHOD(RemoveConnection)( 
        /* [in] */ BSTR i_bstrConnectionDN);

    STDMETHOD(RemoveConnectionEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN);

    STDMETHOD(RemoveAllConnections)();

    STDMETHOD(EnableConnection)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ BOOL i_bEnable);

    STDMETHOD(EnableConnectionEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable);

    STDMETHOD(GetConnectionSchedule)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT* o_pVar);

    STDMETHOD(GetConnectionScheduleEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [retval][out] */ VARIANT* o_pVar);

    STDMETHOD(SetConnectionSchedule)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ VARIANT* i_pVar);

    STDMETHOD(SetConnectionScheduleEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ VARIANT* i_pVar);

    STDMETHOD(SetScheduleOnAllConnections)( 
        /* [in] */ VARIANT* i_pVar);

    STDMETHOD(CreateConnections)();

    STDMETHOD(Delete)();

    STDMETHOD(GetBadMemberInfo)( 
        /* [in] */ BSTR i_bstrServerName,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember);

protected:
    void _FreeMemberVariables();
    HRESULT _PopulateMemberList();
    HRESULT _PopulateConnectionList();
    HRESULT _DeleteMember(CFrsMember* pFrsMember);
    HRESULT _DeleteConnection(CFrsConnection* pFrsConnection);
    HRESULT _GetMemberInfo(CFrsMember* i_pFrsMember, VARIANT* o_pvarMember);
    HRESULT _GetConnectionInfo(CFrsConnection* i_pFrsConnection, VARIANT* o_pvarConnection);
    HRESULT _SetCustomTopologyPref();
    HRESULT _AdjustConnectionsAdd(BSTR i_bstrNewMemberDN);
    HRESULT _RemoveConnectionsFromAndTo(CFrsMember* pFrsMember);
    HRESULT _GetConnectionSchedule(BSTR i_bstrConnectionDN, VARIANT* o_pVar);

protected:
    CComBSTR            m_bstrType;
    CComBSTR            m_bstrTopologyPref;
    CComBSTR            m_bstrHubMemberDN;
    CComBSTR            m_bstrPrimaryMemberDN;
    CComBSTR            m_bstrFileFilter;
    CComBSTR            m_bstrDirFilter;
    CComBSTR            m_bstrDfsEntryPath;
    CComBSTR            m_bstrReplicaSetDN;

    CDfsAlternateList   m_dfsAlternateList;
    CFrsMemberList      m_frsMemberList;
    CFrsConnectionList  m_frsConnectionList;

    PLDAP               m_pldap;
    CComBSTR            m_bstrDomain;
    CComBSTR            m_bstrDomainGuid;
    CComBSTR            m_bstrDC;

    BOOL                m_bNewSchema;
};

#endif //__REPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_)
#define AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <lmcons.h>
#include <lmdfs.h>
#include <lmapibuf.h>    // For NetApiBufferFree.
#include <lmserver.h>
#include <lmerr.h>
#include <lmwksta.h>

#include "dfsDebug.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfscore\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DfsCore.rc
//
#define IDS_PROJNAME                    100
#define IDR_DFSROOT                     101
#define IDR_DFSJP                       102
#define IDR_DFSREP                      103
#define IDR_REPLICASET                  104
#define IDS_UNKNOWN_SITE                201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\addrep.h ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the declaration of the CAddRep.
  This class displays the Add Replica Dialog,which is used to add new Replica.

*/

#ifndef __ADDREP_H_
#define __ADDREP_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"

/////////////////////////////////////////////////////////////////////////////
// CAddRep
class CAddRep : 
  public CDialogImpl<CAddRep>
{
public:
  CAddRep();
  ~CAddRep();

  enum { IDD = IDD_ADDREP };
  typedef enum REPLICATION_TYPE 
  {
    REPLICATION_UNASSIGNED = 0,
    NO_REPLICATION,
    NORMAL_REPLICATION,
    STAGED_REPLICATION,
    IMMEDIATE_REPLICATION
  };

BEGIN_MSG_MAP(CAddRep)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
  COMMAND_ID_HANDLER(IDC_BUTTONNETBROWSE, OnNetBrowse)
END_MSG_MAP()

//  Command Handlers
  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnNetBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

//  Methods to access data in the dialog.
  HRESULT put_EntryPath(BSTR i_bstrParent);
  HRESULT get_NetPath(BSTR *o_bstrNetPath);
  HRESULT get_Server(BSTR *o_bstrServer);
  HRESULT get_Share(BSTR *o_bstrShare);
  REPLICATION_TYPE get_ReplicationType(VOID);

// Method to specify Dfs type.
  void  put_DfsType(DFS_TYPE  i_DfsType)
  {
    m_DfsType = i_DfsType;
  }

protected:
  CComBSTR  m_BrowseNetLabel;
  CComBSTR  m_bstrEntryPath;
  CComBSTR  m_bstrNetPath;
  CComBSTR  m_bstrServer;
  CComBSTR  m_bstrShare;

  REPLICATION_TYPE m_RepType;
  DFS_TYPE  m_DfsType;
};

#endif //__ADDREP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\addrep.cpp ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the Implementation of CAddRep.
  This class displays the Add Replica Dialog,which is used to add new Replica.

*/

#include "stdafx.h"
#include "AddRep.h"
#include "utils.h"
#include <shlobj.h>
#include <dsclient.h>
#include "dfshelp.h"

/////////////////////////////////////////////////////////////////////////////
// CAddRep

CAddRep::CAddRep() : m_RepType(REPLICATION_UNASSIGNED),
                    m_DfsType(DFS_TYPE_UNASSIGNED)
{
}

CAddRep::~CAddRep()
{
}


HRESULT CAddRep::put_EntryPath
(
  BSTR i_bstrEntryPath
)
{
/*++

Routine Description:

  Sets the path of the Junction point of this replica
  This is used to display in the edit text.

Arguments:

  i_bstrEntryPath  -  The junction point entry path.

*/

  RETURN_INVALIDARG_IF_NULL(i_bstrEntryPath);

  m_bstrEntryPath = i_bstrEntryPath;
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath);

  return S_OK;
}


HRESULT CAddRep::get_Server
(
  BSTR *o_pbstrServer
)
{
/*++

Routine Description:

  Returns the server component of the share path.

Arguments:

  o_pbstrServer  -  The server name is returned here.

*/
    GET_BSTR(m_bstrServer, o_pbstrServer);
}



HRESULT CAddRep::get_Share
(
  BSTR *o_pbstrShare
)
{
/*++

Routine Description:

  Returns the share component of the share path.

Arguments:

  o_pbstrShare  -  The share name is returned here.

*/
    GET_BSTR(m_bstrShare, o_pbstrShare);
}

HRESULT CAddRep::get_NetPath
(
  BSTR *o_pbstrNetPath
)
{
/*++

Routine Description:

  Returns the complete share path typed in by the user in the edit box.

Arguments:

  o_pbstrNetPath  -  The share path is returned here.

*/
    GET_BSTR(m_bstrNetPath, o_pbstrNetPath);
}

LRESULT CAddRep::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
  SetDlgItemText(IDC_EDIT_ADDREP_DFSLINK_PATH, m_bstrEntryPath);

  ::SendMessage(GetDlgItem(IDC_EDITNETPATH), EM_LIMITTEXT, MAX_PATH, 0);

          // Disable replication button for Std Dfs.
  if (DFS_TYPE_FTDFS != m_DfsType)
  {
    ::EnableWindow(GetDlgItem(IDC_ADDREP_REPLICATE), FALSE);
  } else
  {
          // Check "replication" as default
    CheckDlgButton(IDC_ADDREP_REPLICATE, BST_CHECKED);
  }

  return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CAddRep::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDREP);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CAddRep::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDREP);

  return TRUE;
}

LRESULT CAddRep::OnNetBrowse
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  CComBSTR  bstrPath;
  HRESULT   hr = BrowseNetworkPath(hWndCtl, &bstrPath);

  if (S_OK == hr)
  {
    SetDlgItemText(IDC_EDITNETPATH, bstrPath);
    ::SetFocus(GetDlgItem(IDC_ADDREP_REPLICATE));
  }

  if (S_FALSE == hr)
    ::SetFocus(GetDlgItem(IDC_EDITNETPATH));

  return (SUCCEEDED(hr));
}

LRESULT CAddRep::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  BOOL      bValidInput = FALSE;
  int       idString = 0;
  HRESULT   hr = S_OK;

  do {
    CWaitCursor wait;

    DWORD     dwTextLength = 0;

    m_bstrNetPath.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITNETPATH), &m_bstrNetPath, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_FIELD;
      break;
    }

    m_bstrServer.Empty();
    m_bstrShare.Empty();
    if (!ValidateNetPath(m_bstrNetPath, &m_bstrServer, &m_bstrShare))
      break;

    m_RepType = NO_REPLICATION;
    if (IsDlgButtonChecked(IDC_ADDREP_REPLICATE))
      m_RepType = NORMAL_REPLICATION;

    bValidInput = TRUE;

  } while (0);

  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDITNETPATH));
    return FALSE;
  } else if (bValidInput)
  {
    EndDialog(S_OK);
    return TRUE;
  }
  else
  {
    if (idString)
      DisplayMessageBoxWithOK(idString);
    ::SetFocus(GetDlgItem(IDC_EDITNETPATH));
    return FALSE;
  }
}

LRESULT CAddRep::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

CAddRep::REPLICATION_TYPE CAddRep::get_ReplicationType(
  VOID
  )
/*++

Routine Description:

  This method gets the type of replication requested.
  This value is based on the radio button selected when OK is pressed.

*/
{
  return m_RepType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\addtodfs.h ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the declaration of the CAddToDfs.
  This class displays the Add To Dfs Dialog,which is used to add new Junctions Points.

*/

#ifndef __ADDTODFS_H_
#define __ADDTODFS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAddToDfs
class CAddToDfs : 
  public CDialogImpl<CAddToDfs>
{
public:
  CAddToDfs();
  ~CAddToDfs();

  enum { IDD = IDD_ADDTODFS };

BEGIN_MSG_MAP(CAddToDfs)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
  COMMAND_ID_HANDLER(IDC_BUTTONNETBROWSE, OnNetBrowse)
  COMMAND_HANDLER(IDC_EDITCHLDNODE, EN_CHANGE, OnChangeDfsLink)
END_MSG_MAP()

//  Message Handlers.
  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnNetBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChangeDfsLink(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
public:
  // Clients Call this methods.
  // Sets the entry path of the parent. This should be called before calling DoModal.
  HRESULT put_ParentPath(BSTR i_bstrParent);

  // Methods to retrieve data from the dialog on EndDialog().
  HRESULT get_Comment(BSTR *o_bstrComment);
  HRESULT get_EntryPath(BSTR *o_bstrEntryPath);
  HRESULT get_JPName(BSTR *o_bstrJPName);
  HRESULT get_NetPath(BSTR *o_bstrNetPath);
  HRESULT get_Server(BSTR *o_bstrServer);
  HRESULT get_Share(BSTR *o_bstrShare);
  HRESULT get_Time(long *o_plTime);

protected:
  CComBSTR  m_BrowseDfsLabel;
  CComBSTR  m_BrowseNetLabel;
  CComBSTR  m_bstrParentPath;
  CComBSTR  m_bstrEntryPath;
  CComBSTR  m_bstrJPName;
  CComBSTR  m_bstrNetPath;
  CComBSTR  m_bstrServer;
  CComBSTR  m_bstrShare;
  CComBSTR  m_bstrComment;
  long      m_lTime;
};

#endif //__ADDTODFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\connect.cpp ===
/*++
Module Name:

    Connect.cpp

Abstract:

    This module contains the implementation for CConnectToDialog.
  This is used to display the Connect To Dfs Root dialog box

--*/



#include "stdafx.h"
#include <process.h>
#include "DfsGUI.h"
#include "Utils.h"      // For the LoadStringFromResource and SetStandardCursor method
#include "Connect.h"
#include "dfshelp.h"

static const int      iFOLDER_IMAGE = 0;
static const int      iFOLDER_SELECTED_IMAGE = 1;
static const int      iDOMAIN_IMAGE      = 2;
static const int      iDOMAIN_SELECTED_IMAGE  = 2;
static const int      iSTANDALONE_DFSROOT_IMAGE = 3;
static const int      iFT_DFSROOT_IMAGE = 3;
static const int      iOVERLAY_BUSY_IMAGE = 4;
static const int      iOVERLAY_ERROR_IMAGE = 5;
static const int      OV_BUSY = 1;
static const int      OV_ERROR = 2;

CConnectToDialog::CConnectToDialog()
{
  CWaitCursor    WaitCursor;    // Display the wait cursor

  m_pBufferManager = NULL;

  m_hImageList = NULL;

  (void)Get50Domains(&m_50DomainList);

  LoadStringFromResource(IDS_DOMAIN_DFSROOTS_LABEL, &m_bstrDomainDfsRootsLabel);
  LoadStringFromResource(IDS_ALL_DFSROOTS_LABEL, &m_bstrAllDfsRootsLabel);
}

CConnectToDialog::~CConnectToDialog()
{
  CWaitCursor    WaitCursor;  // An object to set\reset the cursor to wait cursor

  if(NULL != m_hImageList)
  {
     ImageList_Destroy(m_hImageList);
     m_hImageList = NULL;
  }

  // Free Domain List
  FreeNetNameList(&m_50DomainList);

  if (m_pBufferManager)
  {
    //
    // signal all related running threads to terminate
    //
    m_pBufferManager->SignalExit();

    //
    // decrement the reference count on the CBufferManager instance
    //
    m_pBufferManager->Release();
  }

}

LRESULT
CConnectToDialog::OnInitDialog(
  UINT            uMsg,
  WPARAM          wParam,
  LPARAM          lParam,
  BOOL&           bHandled
  )
{
  //
  // create instance of CBufferManager
  // m_pBufferManager will be set to NULL if CreateInstance() failed.
  //
  (void) CBufferManager::CreateInstance(m_hWnd, &m_pBufferManager);

  ::SendMessage(GetDlgItem(IDC_EditDfsRoot), EM_LIMITTEXT, DNSNAMELIMIT, 0);

  InitTVImageList();        // Get the image list for the TV

  FillupTheTreeView();      // Fill up the Tree View

  return TRUE;              // let the dialog box set the focus to any control it wants.
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CConnectToDialog::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_DLGCONNECTTO);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CConnectToDialog::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_DLGCONNECTTO);

  return TRUE;
}

LRESULT
CConnectToDialog::OnGetDataThreadDone(
  UINT            uMsg,
  WPARAM          wParam,
  LPARAM          lParam,
  BOOL&           bHandled
  )
{
  _ASSERT(m_pBufferManager);

  bHandled = TRUE;

  CEntryData* pEntry = reinterpret_cast<CEntryData*>(wParam);
  HRESULT hr = (HRESULT)lParam;

  _ASSERT(pEntry);

  CComBSTR      bstrNode = pEntry->GetNodeName();
  HTREEITEM     hItem = pEntry->GetTreeItem();

  switch (pEntry->GetEntryType())
  {
  case BUFFER_ENTRY_TYPE_VALID:
    (void)InsertData(pEntry, hItem);
    ChangeIcon(hItem, ICONTYPE_NORMAL);
    break;
  case BUFFER_ENTRY_TYPE_ERROR:
    ExpandNodeErrorReport(hItem, bstrNode, pEntry->GetEntryHRESULT());
    break;
  default:
    _ASSERT(FALSE);
    break;
  }

  bHandled = TRUE;

  return TRUE;
}

void CConnectToDialog::ChangeIcon(
    IN HTREEITEM  hItem,
    IN ICONTYPE   IconType
)
{
  TVITEM TVItem;

  ZeroMemory(&TVItem, sizeof(TVItem));
  TVItem.hItem = hItem;
  TVItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;

  switch (IconType)
  {
  case ICONTYPE_BUSY:
    TVItem.iImage = iOVERLAY_BUSY_IMAGE;
    TVItem.iSelectedImage = iOVERLAY_BUSY_IMAGE;
    break;
  case ICONTYPE_ERROR:
    TVItem.iImage = iOVERLAY_ERROR_IMAGE;
    TVItem.iSelectedImage = iOVERLAY_ERROR_IMAGE;
    break;
  default: // ICONTYPE_NORMAL
    {
      NODETYPE NodeType = UNASSIGNED;
      HRESULT hr = GetNodeInfo(hItem, NULL, &NodeType);

      if (FAILED(hr))
        return;

      switch (NodeType)
      {
      case TRUSTED_DOMAIN:
        TVItem.iImage = iDOMAIN_IMAGE;
        TVItem.iSelectedImage = iDOMAIN_SELECTED_IMAGE;
        break;
      case DOMAIN_DFSROOTS:
      case ALL_DFSROOTS:
        TVItem.iImage = iFOLDER_IMAGE;
        TVItem.iSelectedImage = iFOLDER_SELECTED_IMAGE;
        break;
      case FTDFS:
        TVItem.iImage = iFT_DFSROOT_IMAGE;
        TVItem.iSelectedImage = iFT_DFSROOT_IMAGE;
        break;
      case SADFS:
        TVItem.iImage = iSTANDALONE_DFSROOT_IMAGE;
        TVItem.iSelectedImage = iSTANDALONE_DFSROOT_IMAGE;
        break;
      default:
        return;
      }
    }
  }

  SendDlgItemMessage(IDC_TV, TVM_SETITEM, 0, (LPARAM)&TVItem);

  UpdateWindow();
}

/*
void CConnectToDialog::ChangeIcon(
    IN HTREEITEM  hItem,
    IN ICONTYPE   IconType
)
{
  TVITEM TVItem;

  ZeroMemory(&TVItem, sizeof(TVItem));
  TVItem.hItem = hItem;
  TVItem.mask = TVIF_STATE;
  TVItem.stateMask = TVIS_OVERLAYMASK;

  switch (IconType)
  {
  case ICONTYPE_BUSY:
    TVItem.state = INDEXTOOVERLAYMASK(OV_BUSY);
    break;
  case ICONTYPE_ERROR:
    TVItem.state = INDEXTOOVERLAYMASK(OV_ERROR);
    break;
  default:
    TVItem.state = 0;
    break;
  }

  SendDlgItemMessage(IDC_TV, TVM_SETITEM, 0, (LPARAM)&TVItem);

  UpdateWindow();
}
*/

void CConnectToDialog::ExpandNodeErrorReport(
    IN HTREEITEM  hItem,
    IN PCTSTR     pszNodeName,
    IN HRESULT    hr
)
{
  // change the icon to "X"
  dfsDebugOut((_T("Failed to expand: %s, hr=%x\n"), pszNodeName, hr));
  SetChildrenToZero(hItem);
  ChangeIcon(hItem, ICONTYPE_ERROR);
}

void CConnectToDialog::ExpandNode(
    IN PCTSTR       pszNodeName,
    IN NODETYPE     nNodeType,
    IN HTREEITEM    hParentItem
)
{
  HRESULT hr = S_OK;
  dfsDebugOut((_T("CConnectToDialog::ExpandNode for %s\n"), pszNodeName));

  if (m_pBufferManager)
  {
    //
    // change icon to wait
    //

    ChangeIcon(hParentItem, ICONTYPE_BUSY);

    UpdateWindow();

    //
    // start the thread to calculate a list of servers in the current selected domain
    //
    CEntryData *pEntry = NULL;
    hr = m_pBufferManager->LoadInfo(pszNodeName, nNodeType, hParentItem, &pEntry);

    if (SUCCEEDED(hr))
    {
      //
      // Either we get a valid ptr back (ie. data is ready), insert it;
      // or, a thread is alreay in progress, wait until a THREAD_DONE message.
      //
      if (pEntry)
      {
        _ASSERT(pEntry->GetEntryType() == BUFFER_ENTRY_TYPE_VALID);
        (void)InsertData(pEntry, hParentItem);
      }
    } else
    {
      ExpandNodeErrorReport(hParentItem, pszNodeName, hr);
    }
  }

  return;
}

HRESULT
CConnectToDialog::InsertData(
    IN CEntryData*    pEntry,
    IN HTREEITEM      hParentItem
)
{
  _ASSERT(pEntry);

  CComBSTR      bstrNode = pEntry->GetNodeName();
  NODETYPE      nNodeType = pEntry->GetNodeType();
  NETNAMELIST*  pList = pEntry->GetList();
  _ASSERT(pList);

  HRESULT       hr = S_OK;

  if (0 == pList->size())
  {
    SetChildrenToZero(hParentItem);
    return hr;
  }

  int nImageIndex;
  int nSelectedImageIndex;
  bool bChildren;

  nImageIndex = iSTANDALONE_DFSROOT_IMAGE;
  nSelectedImageIndex = iSTANDALONE_DFSROOT_IMAGE;
  bChildren = false;

  for (NETNAMELIST::iterator i = pList->begin(); i != pList->end(); i++)
  {
    hr = AddSingleItemtoTV(
            (*i)->bstrNetName,
            nImageIndex,
            nSelectedImageIndex,
            bChildren,
            nNodeType,
            hParentItem);

    RETURN_IF_FAILED(hr);
  }

  // make the child items visible
  HTREEITEM hChildItem = (HTREEITEM)SendDlgItemMessage(
    IDC_TV, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hParentItem);
  if (hChildItem)
    SendDlgItemMessage(IDC_TV, TVM_ENSUREVISIBLE, 0, (LPARAM)hChildItem);

  // sort all its child items
  SendDlgItemMessage(IDC_TV, TVM_SORTCHILDREN, 0, (LPARAM)hParentItem);

  return S_OK;
}

LRESULT
CConnectToDialog :: OnNotify(
  UINT    uMsg,
  WPARAM    wParam,
  LPARAM    lParam,
  BOOL&    bHandled
  )
/*++

Routine Description:

  Called on WM_NOTIFY.
  Used to set the Edit box depending on the current selection in the TV.


Arguments:
  uMsg  -  The windows message being sent. This is WM_NOTIFY.
  lParam  -  Info about the message like control for which the message is being sent,
        what sub type of message, etc


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  _ASSERTE(WM_NOTIFY == uMsg);
  _ASSERTE(lParam  != NULL);

  LRESULT      lr = FALSE;      // Set it to true if we handle this message.
  LPNM_TREEVIEW  pNMTreeView = (NM_TREEVIEW *) lParam;

  bHandled = FALSE;
                    // Check if the message  is for our tree control
  if (pNMTreeView && IDC_TV == pNMTreeView->hdr.idFrom)
  {
                    // Check if the message is for selection change.
    if (TVN_SELCHANGED == pNMTreeView->hdr.code)
    {
      lr = DoNotifySelectionChanged(pNMTreeView);
    }
    else if (TVN_ITEMEXPANDING == pNMTreeView->hdr.code)
    {
      lr = DoNotifyItemExpanding(pNMTreeView);
    }
    else if (NM_DBLCLK  == pNMTreeView->hdr.code)
    {
      lr = DoNotifyDoubleClick();
    } else
    {
      lr = FALSE;
    }
  }

  return (lr);
}




LRESULT
CConnectToDialog::DoNotifyDoubleClick(
  )
/*++

Routine Description:

  Handles the WM_NOTIFY for NM_DBLCLK.
  This acts like a click on OK, if the current item is a dfsroot.


Arguments:
  None


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  HRESULT          hr = E_FAIL;
  HTREEITEM        hCurrentItem = NULL;
  NODETYPE         NodeType = UNASSIGNED;

  hCurrentItem = TreeView_GetSelection(GetDlgItem(IDC_TV));
  if (NULL == hCurrentItem)      // Unable to get the current selection
  {
    return FALSE;
  }

  hr = GetNodeInfo(hCurrentItem, NULL, &NodeType);
  if(FAILED(hr))
    return FALSE;

                    // Take action only on a dfs root
  if (FTDFS == NodeType || SADFS == NodeType)
  {

    int    iHandled = TRUE;  // A variable used for communication with OnOK

    OnOK(NULL, 1, 0, iHandled);  // On a double click, we simulate a click on OK.
    _ASSERTE(TRUE == iHandled);

    return TRUE;
  }

  return FALSE;
}



LRESULT
CConnectToDialog::DoNotifyItemExpanding(
  IN LPNM_TREEVIEW    i_pNMTreeView
  )
/*++

Routine Description:

  Handles the WM_NOTIFY for TVN_ITEMEXPANDING.
  If the expand is for "Standalone label", we create another thread
  to fill it up.
  Else, we get the Fault Tolerant Dfs Roots for the domain name.

  Also we removes the '+' sign, if the tree node is empty.


Arguments:
  i_pNMTreeView  -  Information related to the tree and the node for which the message
            occurred


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  HTREEITEM    hCurrentItem = (i_pNMTreeView->itemNew).hItem;
  _ASSERT(hCurrentItem);

                      // If children actually exist, we have nothing to do. It is a normal expand
  HTREEITEM hItemChild = (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hCurrentItem);
  if (hItemChild)
    return FALSE;

  NODETYPE  NodeType = UNASSIGNED;
  HRESULT   hr = GetNodeInfo(hCurrentItem, NULL, &NodeType);
  if(FAILED(hr))
  {
    SetChildrenToZero(hCurrentItem);
    return TRUE;
  }

  switch (NodeType)
  {
  case TRUSTED_DOMAIN:
    {
      AddSingleItemtoTV(
            m_bstrDomainDfsRootsLabel,
            iFOLDER_IMAGE,
            iFOLDER_SELECTED_IMAGE,
            true,
            DOMAIN_DFSROOTS,
            hCurrentItem);
/*      AddSingleItemtoTV(
            m_bstrAllDfsRootsLabel,
            iFOLDER_IMAGE,
            iFOLDER_SELECTED_IMAGE,
            true,
            ALL_DFSROOTS,
            hCurrentItem); */
      return TRUE;
    }
  case DOMAIN_DFSROOTS:
//  case ALL_DFSROOTS:
    {
      CWaitCursor    WaitCursor;

      // get the domain name
      HTREEITEM hParentItem = (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hCurrentItem);
      _ASSERT(hParentItem);
      CComBSTR bstrDomainName;
      hr = GetNodeInfo(hParentItem, &bstrDomainName, NULL);
      if(FAILED(hr))
        SetChildrenToZero(hCurrentItem);

      ExpandNode(bstrDomainName, ((NodeType == DOMAIN_DFSROOTS) ? FTDFS : SADFS), hCurrentItem);

      return TRUE;
    } 
  default:
    break;
  }

  return FALSE;
}

LRESULT
CConnectToDialog::DoNotifySelectionChanged(
  IN LPNM_TREEVIEW    i_pNMTreeView
  )
/*++

Routine Description:

  Handles the WM_NOTIFY for TVN_SELCHANGED.
  The text in the edit box is set here to the dfs root path.


Arguments:
  i_pNMTreeView  -  Information related to the tree and the node for which the message
            occurred


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  HRESULT                 hr = S_OK;
  CComBSTR                bstrNameForEditBox;
  CComBSTR                bstrDisplayName;
  NODETYPE                NodeType;
  HTREEITEM               hItem = (i_pNMTreeView->itemNew).hItem;

  hr = GetNodeInfo(hItem, &bstrDisplayName, &NodeType);
  if(FAILED(hr))
    return FALSE;

  switch (NodeType)
  {
  case FTDFS:
    {
      // get its parent's display name
      HTREEITEM hParentItem =
        (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem);
      _ASSERT(hParentItem);
      HTREEITEM hGrandParentItem =
        (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hParentItem);
      _ASSERT(hGrandParentItem);

      CComBSTR  bstrDomainName;
      hr = GetNodeInfo(hGrandParentItem, &bstrDomainName, NULL);
      if(FAILED(hr))
        return FALSE;

      bstrNameForEditBox = _T("\\\\");
      bstrNameForEditBox += bstrDomainName;
      bstrNameForEditBox += _T("\\");
      bstrNameForEditBox += bstrDisplayName;

    }
    break;
/*  case SADFS:
    bstrNameForEditBox = bstrDisplayName;
    break; */
  default:
    bstrNameForEditBox = _T("");
    break;
  }

  return SetDlgItemText(IDC_DLG_EDIT, bstrNameForEditBox);
}

LRESULT
CConnectToDialog::OnOK(
  WORD  wNotifyCode,
  WORD  wID,
  HWND  hWndCtl,
  BOOL&  bHandled
  )
/*++

Routine Description:

  Called when the OK button is pressed.


Arguments:
  None  used.


Return value:

  0. As it is a command handler
  Calls EndDialog(S_OK). S_OK is passed back as return value of DoModal. This indicates
  that the dialog ended on OK being pressed

--*/
{
  DWORD     dwTextLength = 0;
  HRESULT   hr = S_OK;

  m_bstrDfsRoot.Empty();
  hr = GetInputText(GetDlgItem(IDC_DLG_EDIT), &m_bstrDfsRoot, &dwTextLength);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_DLG_EDIT));
    return FALSE;
  } else if (0 == dwTextLength)
  {
    DisplayMessageBoxWithOK(IDS_MSG_EMPTY_DFSROOT);
    ::SetFocus(GetDlgItem(IDC_DLG_EDIT));
    return FALSE;
  }

  EndDialog(S_OK);

  return 0;
}




LRESULT
CConnectToDialog::OnCancel(
  WORD  wNotifyCode,
  WORD  wID,
  HWND  hWndCtl,
  BOOL&  bHandled
  )
/*++

Routine Description:

  Called when the Cancel button is pressed.


Arguments:
  None used.


Return value:

  0. As it is a command handler
  Calls EndDialog(S_FALSE). S_FALSE is passed back as return value of DoModal.
  This indicates that the dialog ended on Cancel being pressed
--*/
{
  EndDialog(S_FALSE);

  return 0;
}



BOOL CConnectToDialog :: EndDialog(
  IN int    i_RetCode
  )
/*++

Routine Description:

  Overridden method that calls the parent method after some internal processing.
  This includes deleting the objects stored in the lparams of the TV items.


Arguments:
  None used.


Return value:

  The return value of the parent method.
--*/
{
  ::ShowCursor(FALSE);
  SetCursor(::LoadCursor(NULL, IDC_WAIT));
  ::ShowCursor(TRUE);

                    // Remove the Imagelist from the tree. We destroy it in the dtor
  SendDlgItemMessage(IDC_TV, TVM_SETIMAGELIST, TVSIL_NORMAL, (LPARAM)NULL);

  return CDialogImpl<CConnectToDialog>::EndDialog(i_RetCode);
}



STDMETHODIMP CConnectToDialog::get_DfsRoot(
  OUT BSTR*  pVal
  )
/*++

Routine Description:

  Return the selected DfsRoot name.
  Part of the interface IConnectToDialog.


Arguments:
  pVal - Return the BSTR in this.


Return value:

  S_OK, if successful
  E_FAIL, if the value is unavailable
  E_INVALIDARG, if the pointer is invalid(NULL)
  E_OUTOFMEMORY if we run out of memory
--*/
{
  RETURN_INVALIDARG_IF_NULL(pVal);

  if ((!m_bstrDfsRoot) || (0 == m_bstrDfsRoot.Length()))
  {
    return E_FAIL;
  }

  *pVal = SysAllocString(m_bstrDfsRoot);
  RETURN_OUTOFMEMORY_IF_NULL(*pVal);

  return S_OK;
}



void
CConnectToDialog::SetChildrenToZero(
  IN HTREEITEM      i_hItem
)
{
  TV_ITEM    TVItem;

  ZeroMemory(&TVItem, sizeof TVItem);
  TVItem.mask = TVIF_CHILDREN;
  TVItem.cChildren = 0;
  TVItem.hItem = i_hItem;

  SendDlgItemMessage( IDC_TV, TVM_SETITEM, 0, (LPARAM)&TVItem);
}

HRESULT CConnectToDialog::InitTVImageList()
{
  m_hImageList = ImageList_LoadBitmap(
                      _Module.GetModuleInstance(),
                      MAKEINTRESOURCE(IDB_CONNECT_16x16),
                      16,
                      8,
                      CLR_DEFAULT);
  if (NULL == m_hImageList)
    return E_FAIL;

  ImageList_SetOverlayImage(
              m_hImageList,
              iOVERLAY_BUSY_IMAGE,
              OV_BUSY);

  ImageList_SetOverlayImage(
              m_hImageList,
              iOVERLAY_ERROR_IMAGE,
              OV_ERROR);

  SendDlgItemMessage(
      IDC_TV,
      TVM_SETIMAGELIST,
      TVSIL_NORMAL,
      (LPARAM)m_hImageList);

  return S_OK;
}



HRESULT
CConnectToDialog::FillupTheTreeView(
  )
/*++

Routine Description:

  This routine does 2 things, adds the NT 5.0 domain names and the Standalone subtree label.
  Also makes the text over the TV invisible.

Arguments:

  None.

Return value:

    S_OK, On success
  HRESULT sent by methods called, if it is not S_OK.
  E_FAIL, on other errors.

--*/
{
  HRESULT        hr = S_OK;

  //
  // add trusted domains DNS names
  // FT dfs roots will be added under these nodes
  //
  if (m_50DomainList.empty())
    return hr;

  for(NETNAMELIST::iterator i = m_50DomainList.begin(); i != m_50DomainList.end(); i++)
  {
    _ASSERTE((*i)->bstrNetName);

    hr = AddSingleItemtoTV(
                (*i)->bstrNetName,
                iDOMAIN_IMAGE,
                iDOMAIN_SELECTED_IMAGE,
                true,    // Children = true
                TRUSTED_DOMAIN);
    if (FAILED(hr))
      break;
  }

  if (SUCCEEDED(hr))
  {
    // sort the trusted domains only
    SendDlgItemMessage(IDC_TV, TVM_SORTCHILDREN, 0, 0);
  }

  return hr;
}

HRESULT
CConnectToDialog::AddFaultTolerantDfsRoots(
  IN HTREEITEM  i_hCurrentItem,
  IN BSTR      i_bstrDomainName
  )
{
    RETURN_INVALIDARG_IF_NULL(i_hCurrentItem);
    RETURN_INVALIDARG_IF_NULL(i_bstrDomainName);

    NETNAMELIST   DfsRootList;
    HRESULT       hr = GetDomainDfsRoots(&DfsRootList, i_bstrDomainName);
    if (S_OK != hr)
        return hr;

    for (NETNAMELIST::iterator i = DfsRootList.begin(); i != DfsRootList.end(); i++)
    {
        hr = AddSingleItemtoTV(
                      (*i)->bstrNetName,
                      iFT_DFSROOT_IMAGE,
                      iFT_DFSROOT_IMAGE,
                      false,
                      FTDFS,      // Children = false
                      i_hCurrentItem);
        BREAK_IF_FAILED(hr);
    }

    FreeNetNameList(&DfsRootList);

    HTREEITEM hChildItem = (HTREEITEM)SendDlgItemMessage(
                                IDC_TV, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)i_hCurrentItem);
    if (hChildItem)
      SendDlgItemMessage(IDC_TV, TVM_ENSUREVISIBLE, 0, (LPARAM)hChildItem);

    SendDlgItemMessage(IDC_TV, TVM_SORTCHILDREN, 0, (LPARAM)i_hCurrentItem);

    return hr;
}

HRESULT
CConnectToDialog::AddSingleItemtoTV(
  IN const BSTR         i_bstrItemLabel,
  IN const int          i_iImageIndex,
  IN const int          i_iImageSelectedIndex,
  IN const bool         i_bChildren,
  IN const NODETYPE     i_NodeType,
  IN HTREEITEM          i_hItemParent  /* = NULL */
  )
{
  RETURN_INVALIDARG_IF_NULL(i_bstrItemLabel);

  HRESULT                 hr = S_OK;
  TV_INSERTSTRUCT         TVInsertData;
  TV_ITEM                 TVItem;
  HTREEITEM               hCurrentItem = NULL;

  ZeroMemory(&TVItem, sizeof(TVItem));
  ZeroMemory(&TVInsertData, sizeof(TVInsertData));

  TVItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;

  if (true == i_bChildren)    // To decide whether we add the '+' or not
  {
    TVItem.mask |= TVIF_CHILDREN;
    TVItem.cChildren = 1;
  }
  TVItem.pszText = i_bstrItemLabel;
  TVItem.cchTextMax = _tcslen(i_bstrItemLabel);
  TVItem.iImage = i_iImageIndex;
  TVItem.iSelectedImage = i_iImageSelectedIndex;
  TVItem.lParam = (LPARAM)i_NodeType;

  TVInsertData.hParent = i_hItemParent;
  TVInsertData.hInsertAfter = TVI_LAST; // No sorting to improve performance
  TVInsertData.item = TVItem;

  hCurrentItem = (HTREEITEM) SendDlgItemMessage(IDC_TV, TVM_INSERTITEM, 0, (LPARAM) (LPTV_INSERTSTRUCT) &TVInsertData);
  if (NULL == hCurrentItem)
    return E_FAIL;

  return S_OK;
}

HRESULT
CConnectToDialog::GetNodeInfo(
    IN  HTREEITEM               hItem,
    OUT BSTR*                   o_bstrName,
    OUT NODETYPE*               pNodeType
)
{
  _ASSERT(o_bstrName || pNodeType);

  HRESULT   hr = S_OK;
  TCHAR     szName[MAX_PATH];
  TVITEM    TVItem;
  ZeroMemory(&TVItem, sizeof(TVItem));

  TVItem.hItem = hItem;

  if (o_bstrName)
  {
    TVItem.mask |= TVIF_TEXT;
    TVItem.pszText = szName;
    TVItem.cchTextMax = MAX_PATH;
  }

  if (pNodeType)
    TVItem.mask |= TVIF_PARAM;

  if ( SendDlgItemMessage(IDC_TV, TVM_GETITEM, 0, (LPARAM)&TVItem) )
  {
    if (o_bstrName)
    {
      *o_bstrName = SysAllocString(szName);
      if (!*o_bstrName)
        hr = E_OUTOFMEMORY;
    }

    if (pNodeType)
    {
      *pNodeType = (NODETYPE)TVItem.lParam;
    }
  } else {
    hr = E_FAIL;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\connect.h ===
/*++
Module Name:

    Connect.h

Abstract:

    This module contains the declaration for CConnectToDialog. 
  This class is used to display the Connect To Dfs Root dialog box

--*/



#ifndef __CONNECT_H_
#define __CONNECT_H_


#include "resource.h"    // Main resource symbols
#include "NetUtils.h"
#include "DfsGUI.h"
#include "DfsCore.h"
#include "bufmgr.h"

typedef enum _ICONTYPE
{
        ICONTYPE_BUSY = 0,
        ICONTYPE_ERROR,
        ICONTYPE_NORMAL
} ICONTYPE;

/////////////////////////////////////////////////////////////////////////////
// CConnectToDialog
class CConnectToDialog : 
  public CDialogImpl<CConnectToDialog>
{
private:
  // This method is started the starting point of the second thread
  //friend DWORD WINAPI HelperThreadEntryPoint(IN LPVOID i_pvThisPointer);


private:
  // IDC_TREEDFSRoots is the resource id of the TV. Internally we useS IDC_TV only
  enum { IDC_TV = IDC_TREEDFSRoots };

  // The Edit box in the ConnectTo dialog
  enum {IDC_DLG_EDIT = IDC_EditDfsRoot};


public:
  CConnectToDialog();
  ~CConnectToDialog();

  // IDD_DLGCONNECTTO is the dialog id. This is used by CDialogImpl.
  enum { IDD = IDD_DLGCONNECTTO };


BEGIN_MSG_MAP(CDlgConnectTo)
  MESSAGE_HANDLER(WM_USER_GETDATA_THREAD_DONE, OnGetDataThreadDone)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()


  // Not implemented
private:
  CConnectToDialog(const CConnectToDialog& Obj);
  const CConnectToDialog& operator=(const CConnectToDialog& rhs);


public:

  // Message handlers
  LRESULT OnGetDataThreadDone(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  void ExpandNodeErrorReport(
      IN HTREEITEM  hItem,
      IN PCTSTR     pszNodeName, 
      IN HRESULT    hr
  );
  void ExpandNode(
    IN PCTSTR       pszNodeName,
    IN NODETYPE     nNodeType,
    IN HTREEITEM    hParentItem
  );

  HRESULT InsertData(
      IN CEntryData   *pEntry,
      IN HTREEITEM      hParentItem
  );


  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  // Used to get the notification about changing of TV's selection.
  LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam,  BOOL& bHandled);
  
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
  // Return the item selected by the user
  STDMETHOD(get_DfsRoot)(OUT BSTR *pVal);

  // Helper Methods
private:
  // Notify helpers


  // Handle the 
  LRESULT DoNotifyDoubleClick(
    );


  // Handle the TVN_ITEMEXPANDING notify for the Tree View
  LRESULT DoNotifyItemExpanding(
    IN LPNM_TREEVIEW        i_pNMTreeView
    );


  // Handle the TVN_SELCHANGED notify for the Tree View
  LRESULT DoNotifySelectionChanged(
    IN LPNM_TREEVIEW        i_pNMTreeView
    );



  // Initilization routines
  // Create the imagelist and initialize it.
  HRESULT InitTVImageList();


  // Add the items to the Tree View. This includes the domain names and the 
  // StandAlone subtree label
  HRESULT FillupTheTreeView(
    );

  // Set the cChilren label to zero for this tree item
  void SetChildrenToZero(
    IN HTREEITEM      i_hItem
    );

  // Add the fault tolerant dfs roots in the specified domain
  HRESULT AddFaultTolerantDfsRoots(
    IN HTREEITEM  i_hCurrentItem, 
    IN BSTR      i_bstrDomainName
    );

  HRESULT  AddSingleItemtoTV(  
    IN const BSTR         i_bstrItemLabel, 
    IN const int          i_iImageIndex, 
    IN const int          i_iImageSelectedIndex,
    IN const bool         i_bChildren,
    IN const NODETYPE     i_NodeType,
    IN HTREEITEM          i_hItemParent = NULL
    );
  void ChangeIcon(
      IN HTREEITEM hItem, 
      IN ICONTYPE  IconType
  );
  HRESULT GetNodeInfo(
      IN  HTREEITEM               hItem, 
      OUT BSTR*                   o_bstrName, 
      OUT NODETYPE*               pNodeType
  );


  // Overiding the method of CDialogImpl.
  BOOL  EndDialog(IN int i_RetCode);


  // Data members
private:
  CBufferManager      *m_pBufferManager;
  CComBSTR    m_bstrDfsRoot;          // Store the selected Dfs Root here
  
  HIMAGELIST    m_hImageList;          // The TV imagelist handle

  NETNAMELIST    m_50DomainList;        // Pointer to the first 50 domain information

  CComBSTR    m_bstrDomainDfsRootsLabel;
  CComBSTR    m_bstrAllDfsRootsLabel;
};

#endif //__CONNECTTODIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\custop.cpp ===
/*++
Module Name:

    CusTop.cpp

Abstract:

    This module contains the Implementation of CCustomTopology.
    This class displays the Customize Topology Dialog.

*/

#include "stdafx.h"
#include "CusTop.h"
#include "utils.h"
#include "dfshelp.h"
#include "ldaputils.h"

int g_FRS_CUSTOP_Last_SortColumn = 1;
#define NUM_OF_FRS_CUSTOP_COLUMNS   5

RSTOPOLOGYPREF_STRING g_TopologyPref[] = {
                    {FRS_RSTOPOLOGYPREF_RING, IDS_FRSPROP_RING}, 
                    {FRS_RSTOPOLOGYPREF_HUBSPOKE, IDS_FRSPROP_HUBSPOKE}, 
                    {FRS_RSTOPOLOGYPREF_FULLMESH, IDS_FRSPROP_FULLMESH}, 
                    {FRS_RSTOPOLOGYPREF_CUSTOM, IDS_FRSPROP_CUSTOM}
                    };

/////////////////////////////////////////////////////////////////////////////
//
// CCustomTopology
//

CCustomTopology::CCustomTopology()
{
}

CCustomTopology::~CCustomTopology()
{
}

HRESULT CCustomTopology::_GetMemberList()
{
    FreeCusTopMembers(&m_MemberList);

    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)m_piReplicaSet);

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = m_piReplicaSet->GetMemberListEx(&var);
    RETURN_IF_FAILED(hr);

    if (V_VT(&var) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa_1 = V_ARRAY(&var);
    if (!psa_1) // no member at all
        return hr;

    long    lLowerBound_1 = 0;
    long    lUpperBound_1 = 0;
    long    lCount_1 = 0;
    SafeArrayGetLBound(psa_1, 1, &lLowerBound_1);
    SafeArrayGetUBound(psa_1, 1, &lUpperBound_1);
    lCount_1 = lUpperBound_1 - lLowerBound_1 + 1;

    VARIANT HUGEP *pArray_1;
    SafeArrayAccessData(psa_1, (void HUGEP **) &pArray_1);

    for (long i = 0; i < lCount_1; i++)
    {
        if (V_VT(&(pArray_1[i])) != (VT_ARRAY | VT_VARIANT))
        {
            hr = E_INVALIDARG;
            break;
        }

        SAFEARRAY   *psa_0 = V_ARRAY(&(pArray_1[i]));
        if (!psa_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        long    lLowerBound_0 = 0;
        long    lUpperBound_0 = 0;
        long    lCount_0 = 0;
        SafeArrayGetLBound(psa_0, 1, &lLowerBound_0);
        SafeArrayGetUBound(psa_0, 1, &lUpperBound_0);
        lCount_0 = lUpperBound_0 - lLowerBound_0 + 1;
        if (NUM_OF_FRSMEMBER_ATTRS != lCount_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        VARIANT HUGEP *pArray_0;
        SafeArrayAccessData(psa_0, (void HUGEP **) &pArray_0);

        do {
            CCusTopMember* pNew = new CCusTopMember;
            BREAK_OUTOFMEMORY_IF_NULL(pNew, &hr);

            hr = pNew->Init(
                pArray_0[2].bstrVal, //bstrMemberDN,
                pArray_0[4].bstrVal, //bstrServer,
                pArray_0[6].bstrVal //bstrSite
                );

            if (SUCCEEDED(hr))
                m_MemberList.push_back(pNew);
            else
                delete pNew;

        } while (0);

        SafeArrayUnaccessData(psa_0);
    }

    SafeArrayUnaccessData(psa_1);

    if (SUCCEEDED(hr))
        hr = _SortMemberList();

    if (FAILED(hr))
        FreeCusTopMembers(&m_MemberList);

    SafeArrayDestroy(psa_1); // it should free psa_0 as well

    return hr;
}

HRESULT CCustomTopology::_GetConnectionList()
{
    FreeCusTopConnections(&m_ConnectionList);

    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)m_piReplicaSet);

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = m_piReplicaSet->GetConnectionListEx(&var);
    RETURN_IF_FAILED(hr);

    if (V_VT(&var) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa_1 = V_ARRAY(&var);
    if (!psa_1) // no connection at all
        return hr;

    long    lLowerBound_1 = 0;
    long    lUpperBound_1 = 0;
    long    lCount_1 = 0;
    SafeArrayGetLBound(psa_1, 1, &lLowerBound_1);
    SafeArrayGetUBound(psa_1, 1, &lUpperBound_1);
    lCount_1 = lUpperBound_1 - lLowerBound_1 + 1;

    VARIANT HUGEP *pArray_1;
    SafeArrayAccessData(psa_1, (void HUGEP **) &pArray_1);

    for (long i = 0; i < lCount_1; i++)
    {
        if (V_VT(&(pArray_1[i])) != (VT_ARRAY | VT_VARIANT))
        {
            hr = E_INVALIDARG;
            break;
        }

        SAFEARRAY   *psa_0 = V_ARRAY(&(pArray_1[i]));
        if (!psa_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        long    lLowerBound_0 = 0;
        long    lUpperBound_0 = 0;
        long    lCount_0 = 0;
        SafeArrayGetLBound(psa_0, 1, &lLowerBound_0);
        SafeArrayGetUBound(psa_0, 1, &lUpperBound_0);
        lCount_0 = lUpperBound_0 - lLowerBound_0 + 1;
        if (NUM_OF_FRSCONNECTION_ATTRS != lCount_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        VARIANT HUGEP *pArray_0;
        SafeArrayAccessData(psa_0, (void HUGEP **) &pArray_0);

        do {
            CComBSTR bstrFromServer;
            CComBSTR bstrFromSite;
            hr = _GetMemberDNInfo(pArray_0[1].bstrVal, &bstrFromServer, &bstrFromSite);
            BREAK_IF_FAILED(hr);

            CComBSTR bstrToServer;
            CComBSTR bstrToSite;
            hr = _GetMemberDNInfo(pArray_0[2].bstrVal, &bstrToServer, &bstrToSite);
            BREAK_IF_FAILED(hr);

            CCusTopConnection* pNew = new CCusTopConnection;
            BREAK_OUTOFMEMORY_IF_NULL(pNew, &hr);
            hr = pNew->Init(
                            pArray_0[1].bstrVal, //bstrFromDN,
                            bstrFromServer,
                            bstrFromSite,
                            pArray_0[2].bstrVal, //bstrToDN,
                            bstrToServer,
                            bstrToSite,
                            (BOOL)(pArray_0[3].lVal)  //bEnable
                            ); // CONNECTION_OPTYPE_OTHERS

            if (SUCCEEDED(hr))
                m_ConnectionList.push_back(pNew);
            else
                delete pNew;

        } while (0);

        SafeArrayUnaccessData(psa_0);
    }

    SafeArrayUnaccessData(psa_1);

    if (FAILED(hr))
        FreeCusTopConnections(&m_ConnectionList);

    SafeArrayDestroy(psa_1);

    return hr;
}

void CCustomTopology::_Reset()
{
    m_bstrTopologyPref.Empty();
    m_bstrHubMemberDN.Empty();

    FreeCusTopMembers(&m_MemberList);
    FreeCusTopConnections(&m_ConnectionList);

    m_piReplicaSet = NULL;
}

HRESULT CCustomTopology::put_ReplicaSet
(
  IReplicaSet* i_piReplicaSet
)
{
    RETURN_INVALIDARG_IF_NULL(i_piReplicaSet);

    _Reset();

    m_piReplicaSet = i_piReplicaSet;

    HRESULT hr = S_OK;

    do {
        hr = m_piReplicaSet->get_TopologyPref(&m_bstrTopologyPref);
        BREAK_IF_FAILED(hr);

        hr = m_piReplicaSet->get_HubMemberDN(&m_bstrHubMemberDN);
        BREAK_IF_FAILED(hr);

        hr = _GetMemberList();
        BREAK_IF_FAILED(hr);

        hr = _GetConnectionList();
        BREAK_IF_FAILED(hr);
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

int __cdecl CompareCusTopMembers(const void *arg1, const void *arg2 )
{
    return lstrcmpi(
                    (*(CCusTopMember**)arg1)->m_bstrServer,
                    (*(CCusTopMember**)arg2)->m_bstrServer
                    );
}

HRESULT CCustomTopology::_SortMemberList()
{
    HRESULT hr = S_OK;
    int     cMembers = m_MemberList.size();
    if (2 > cMembers)
        return hr;

    CCusTopMember** ppMember = (CCusTopMember **)calloc(cMembers, sizeof(CCusTopMember *));
    RETURN_OUTOFMEMORY_IF_NULL(ppMember);

    int i = 0;
    for (CCusTopMemberList::iterator it = m_MemberList.begin(); it != m_MemberList.end(); it++, i++)
    {
       ppMember[i] = (*it);
    }

    qsort((void *)ppMember, cMembers, sizeof(CCusTopMember *), CompareCusTopMembers);

    m_MemberList.clear();  // without deleting the object
    for (i = 0; i < cMembers; i++)
    {
        m_MemberList.push_back(ppMember[i]);
    }

    free((void *)ppMember);

    return hr;
}

HRESULT CCustomTopology::_GetMemberDNInfo(
    IN  BSTR    i_bstrMemberDN,
    OUT BSTR*   o_pbstrServer,
    OUT BSTR*   o_pbstrSite
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(o_pbstrServer);
    RETURN_INVALIDARG_IF_NULL(o_pbstrSite);

   for (CCusTopMemberList::iterator i = m_MemberList.begin(); i != m_MemberList.end(); i++)
   {
       if (!lstrcmpi(i_bstrMemberDN, (*i)->m_bstrMemberDN))
        break;
   }

   if (i == m_MemberList.end())
       return S_FALSE;

   *o_pbstrServer = (*i)->m_bstrServer.Copy();
   RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrServer);

   *o_pbstrSite = (*i)->m_bstrSite.Copy();
    if (!*o_pbstrSite)
    {
        SysFreeString(*o_pbstrServer);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CCustomTopology::_GetHubMember(
    OUT CCusTopMember** o_ppHubMember
    )
{
    RETURN_INVALIDARG_IF_NULL(o_ppHubMember);

    int     index = SendDlgItemMessage(IDC_FRS_CUSTOP_HUBSERVER, CB_GETCURSEL, 0, 0);
    int     len = SendDlgItemMessage(IDC_FRS_CUSTOP_HUBSERVER, CB_GETLBTEXTLEN, index, 0);
    PTSTR   pszServer = (PTSTR)calloc(len + 1, sizeof(TCHAR));
    RETURN_OUTOFMEMORY_IF_NULL(pszServer);

    SendDlgItemMessage(IDC_FRS_CUSTOP_HUBSERVER, CB_GETLBTEXT, index, (LPARAM)pszServer);

    CCusTopMemberList::iterator i;
    for (i = m_MemberList.begin(); i != m_MemberList.end(); i++)
    {
        if (!lstrcmpi(pszServer, (*i)->m_bstrServer))
         break;
    }

    free(pszServer);

    if (i == m_MemberList.end())
        return E_INVALIDARG;

    *o_ppHubMember = (*i);

    return S_OK;
}

LRESULT CCustomTopology::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    int i = 0;
    int nControlID = 0;

    //
    // set IDC_FRS_CUSTOP_TOPOLOGYPREF
    //
    nControlID = IDC_FRS_CUSTOP_TOPOLOGYPREF;
    for (i = 0; i < 4; i++)
    {
        CComBSTR bstrTopologyPref;
        LoadStringFromResource(g_TopologyPref[i].nStringID, &bstrTopologyPref);
        SendDlgItemMessage(nControlID, CB_INSERTSTRING, i, (LPARAM)(BSTR)bstrTopologyPref);
        if (!lstrcmpi(m_bstrTopologyPref, g_TopologyPref[i].pszTopologyPref))
        {
            SendDlgItemMessage(nControlID, CB_SETCURSEL, i, 0);
            ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_REBUILD), (0 != lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM)));
        }
    }

    //
    // set IDC_FRS_CUSTOP_HUBSERVER
    //
    nControlID = IDC_FRS_CUSTOP_HUBSERVER;
    int index = 0;
    CCusTopMemberList::iterator itMem;
    for (i = 0, itMem = m_MemberList.begin(); itMem != m_MemberList.end(); i++, itMem++)
    {
        SendDlgItemMessage(nControlID, CB_INSERTSTRING, i, (LPARAM)(BSTR)(*itMem)->m_bstrServer);
        if (!lstrcmpi(m_bstrHubMemberDN, (*itMem)->m_bstrMemberDN))
            index = i;
    }
    SendDlgItemMessage(nControlID, CB_SETCURSEL, index, 0);

    if (lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER), FALSE);
    }

    //
    // set IDC_FRS_CUSTOP_CONNECTIONS
    //
    nControlID = IDC_FRS_CUSTOP_CONNECTIONS;
    HWND hwndControl = GetDlgItem(nControlID);
    AddLVColumns(hwndControl, IDS_FRS_CUSTOP_COL_ENABLE, NUM_OF_FRS_CUSTOP_COLUMNS);
    ListView_SetExtendedListViewStyle(hwndControl, LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES);

    CCusTopConnectionList::iterator itConn;
    for (itConn = m_ConnectionList.begin(); itConn != m_ConnectionList.end(); itConn++)
        _InsertConnection(*itConn);

    ListView_SortItems( hwndControl,
                        ConnectionsListCompareProc,
                        (LPARAM)g_FRS_CUSTOP_Last_SortColumn);

    _EnableButtonsForConnectionList();

    return TRUE;  // Let the system set the focus
}

void CCustomTopology::_EnableButtonsForConnectionList()
{
    //
    // enable New/Delete/Schedule buttons accordingly
    //
    int nCount = ListView_GetSelectedCount(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS));
    ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_SCHEDULE), (nCount >= 1));

    int index = SendDlgItemMessage(IDC_FRS_CUSTOP_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
    if (3 == index) // bCustomTopology
    {
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_NEW), TRUE);
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_DELETE), (nCount >= 1));
    } else
    {
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_NEW), FALSE);
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_DELETE), FALSE);
    }
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CCustomTopology::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_CUSTOP);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CCustomTopology::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_CUSTOP);

    return TRUE;
}

BOOL CCustomTopology::_EnableRebuild()
{
    BOOL bSameTopologyPref = FALSE;
    int index = SendDlgItemMessage(IDC_FRS_CUSTOP_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
    if (lstrcmpi(FRS_RSTOPOLOGYPREF_CUSTOM, g_TopologyPref[index].pszTopologyPref) &&
        !lstrcmpi(m_bstrTopologyPref, g_TopologyPref[index].pszTopologyPref))
    {
        bSameTopologyPref = TRUE;
    }
    if (!bSameTopologyPref || 0 != lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
        return bSameTopologyPref;

    BOOL bSameHub = FALSE;
    CCusTopMember* pHubMember = NULL;
    HRESULT hr = _GetHubMember(&pHubMember);
    if (SUCCEEDED(hr))
        bSameHub = (!lstrcmpi(m_bstrHubMemberDN, pHubMember->m_bstrMemberDN));

    return bSameHub;
}

LRESULT CCustomTopology::OnTopologyPref
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT   hr = S_OK;

    if (CBN_SELCHANGE == wNotifyCode)
    {
        int index = SendDlgItemMessage(wID, CB_GETCURSEL, 0, 0);
        BOOL bCmdShow = (1 == index);
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER_LABEL), bCmdShow); 
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER), bCmdShow); 

        if (1 == index)
        {
            CCusTopMember* pHubMember = NULL;
            hr = _GetHubMember(&pHubMember);
            if (SUCCEEDED(hr))
                hr = _RebuildConnections(FRS_RSTOPOLOGYPREF_HUBSPOKE, pHubMember);
        } else
            hr = _RebuildConnections(g_TopologyPref[index].pszTopologyPref, NULL);

        _EnableButtonsForConnectionList();

        BOOL bSameTopology = _EnableRebuild();
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_REBUILD), bSameTopology);
    }

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnHubServer
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT hr = S_OK;

    if (CBN_SELCHANGE == wNotifyCode)
    {
        CCusTopMember* pHubMember = NULL;
        hr = _GetHubMember(&pHubMember);
        if (SUCCEEDED(hr))
            hr = _RebuildConnections(FRS_RSTOPOLOGYPREF_HUBSPOKE, pHubMember);

        BOOL bSameTopology = _EnableRebuild();
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_REBUILD), bSameTopology);
    }

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnRebuild
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT hr = S_OK;

    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        CCusTopMember* pHubMember = NULL;
        hr = _GetHubMember(&pHubMember);
        if (SUCCEEDED(hr))
            hr = _RebuildConnections(m_bstrTopologyPref, pHubMember);
    } else
        hr = _RebuildConnections(m_bstrTopologyPref, NULL);

    return (SUCCEEDED(hr));
}

HRESULT CCustomTopology::_RebuildConnections(
    IN  BSTR                i_bstrTopologyPref,
    IN  CCusTopMember*      i_pHubMember)
{
    HRESULT hr = S_OK;

    //
    // delete all existing connections from list and view
    //
    CCusTopConnectionList::iterator it = m_ConnectionList.begin();
    while (it != m_ConnectionList.end())
    {
        CCusTopConnectionList::iterator itConn = it++;

        if (CONNECTION_OPTYPE_ADD == (*itConn)->m_opType)
        {
            delete (*itConn);
            m_ConnectionList.erase(itConn);
        } else
        {
            (*itConn)->m_opType = CONNECTION_OPTYPE_DEL;
        }
    }

    ListView_DeleteAllItems(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS));

    //
    // re-create the connections as specified
    //
    if (m_MemberList.size() == 1)
        return hr;

    CCusTopMemberList::iterator n1;
    CCusTopMemberList::iterator n2;
    CCusTopConnection Conn;
    if (!lstrcmpi(i_bstrTopologyPref, FRS_RSTOPOLOGYPREF_RING))
    {
        CCusTopMemberList::iterator head;

        head = n1 = m_MemberList.begin();
        while (n1 != m_MemberList.end())
        {
            n2 = n1++;
            if (n1 == m_MemberList.end())
            {
                if (m_MemberList.size() == 2)
                    break;

                n1 = head;
            }

            hr = Conn.Init((*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        (*n2)->m_bstrMemberDN, (*n2)->m_bstrServer, (*n2)->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);

            hr = Conn.Init((*n2)->m_bstrMemberDN, (*n2)->m_bstrServer, (*n2)->m_bstrSite,
                        (*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);

            if (n1 == head)
                break;
        }
    } else if (!lstrcmpi(i_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        for (n1 = m_MemberList.begin(); n1 != m_MemberList.end(); n1++)
        {
            if (!lstrcmpi((*n1)->m_bstrMemberDN, i_pHubMember->m_bstrMemberDN))
                continue;

            hr = Conn.Init((*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        i_pHubMember->m_bstrMemberDN, i_pHubMember->m_bstrServer, i_pHubMember->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);

            hr = Conn.Init(i_pHubMember->m_bstrMemberDN, i_pHubMember->m_bstrServer, i_pHubMember->m_bstrSite,
                        (*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);
        }
    } else if (!lstrcmpi(i_bstrTopologyPref, FRS_RSTOPOLOGYPREF_FULLMESH))
    {
        for (n1 = m_MemberList.begin(); n1 != m_MemberList.end(); n1++)
        {
            for (n2 = m_MemberList.begin(); n2 != m_MemberList.end(); n2++)
            {
                if (!lstrcmpi((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN))
                    continue;

                hr = Conn.Init((*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                            (*n2)->m_bstrMemberDN, (*n2)->m_bstrServer, (*n2)->m_bstrSite,
                            TRUE, CONNECTION_OPTYPE_ADD);
                BREAK_IF_FAILED(hr);
                hr = _AddToConnectionListAndView(&Conn);
                BREAK_IF_FAILED(hr);
            }
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}

HRESULT CCustomTopology::_SetConnectionState(CCusTopConnection *pConn)
{
    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL);
    while (-1 != nIndex)
    {
        if (pConn == (CCusTopConnection *)GetListViewItemData(hwnd, nIndex))
            break;

        nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL);
    }

    if (-1 != nIndex)
    {
        ListView_SetCheckState(hwnd, nIndex, pConn->m_bStateNew);
        ListView_Update(hwnd, nIndex);
    }

    return S_OK;
}

HRESULT CCustomTopology::_InsertConnection(CCusTopConnection *pConn)
{
    RETURN_INVALIDARG_IF_NULL(pConn);

    HWND hwndControl = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    LVITEM  lvItem;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = (LPARAM)pConn;
    lvItem.pszText = _T("");
    lvItem.iSubItem = 0;
    int iItemIndex = ListView_InsertItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrFromServer;
    lvItem.iSubItem = 1;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrToServer;
    lvItem.iSubItem = 2;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrFromSite;
    lvItem.iSubItem = 3;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrToSite;
    lvItem.iSubItem = 4;
    ListView_SetItem(hwndControl, &lvItem);
    ListView_SetCheckState(hwndControl, iItemIndex, pConn->m_bStateNew);

    ListView_Update(hwndControl, iItemIndex);

    return S_OK;
}

LRESULT CCustomTopology::OnConnectionsNew
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  HRESULT   hr = S_OK;

  CNewConnections NewConnDlg;

  hr = NewConnDlg.Initialize(&m_MemberList);
  if (SUCCEEDED(hr))
  {
      hr = NewConnDlg.DoModal();
      if (S_OK == hr)
      {
          CCusTopConnectionList* pNewConnectionList = NULL;
          hr = NewConnDlg.get_NewConnections(&pNewConnectionList);
          if (SUCCEEDED(hr))
          {
              HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
              int nCount = ListView_GetItemCount(hwnd);

              CCusTopConnectionList::iterator it;
              for (it = pNewConnectionList->begin(); it != pNewConnectionList->end(); it++)
              {
                  hr = _AddToConnectionListAndView(*it);
                  BREAK_IF_FAILED(hr);
              }

              if (ListView_GetItemCount(hwnd) > nCount)
                ListView_SortItems(hwnd, ConnectionsListCompareProc, (LPARAM)g_FRS_CUSTOP_Last_SortColumn);
          }
      }
  }

  // if FAILED, display msg?

  return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnConnectionsDelete
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CCusTopConnection* pConn;
    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    while (-1 != nIndex &&
            (pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex)))
    {
        _RemoveFromConnectionList(pConn);        

        ListView_DeleteItem(hwnd, nIndex);
        
        nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    }

    return TRUE;
}

HRESULT CCustomTopology::_InitScheduleOnSelectedConnections()
{
    HRESULT             hr = S_OK;
    int                 nIndex = -1;
    CCusTopConnection*  pConn = NULL;
    HWND                hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    while ( -1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL | LVNI_SELECTED)) &&
            NULL != (pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex)))
    {
        if (!pConn->m_pScheduleNew)
        {
            if (pConn->m_pScheduleOld)
            {
                hr = CopySchedule(pConn->m_pScheduleOld, &pConn->m_pScheduleNew);
                RETURN_IF_FAILED(hr);
            } else
            {
                if (CONNECTION_OPTYPE_OTHERS == pConn->m_opType)
                {
                    //
                    // read schedule on an existing connection for the very first time
                    //
                    VARIANT var;
                    VariantInit(&var);
                    hr = m_piReplicaSet->GetConnectionScheduleEx(pConn->m_bstrFromMemberDN, pConn->m_bstrToMemberDN, &var);
                    RETURN_IF_FAILED(hr);

                    hr = VariantToSchedule(&var, &pConn->m_pScheduleOld);

                    VariantClear(&var);

                    if (SUCCEEDED(hr))
                        hr = CopySchedule(pConn->m_pScheduleOld, &pConn->m_pScheduleNew);

                    RETURN_IF_FAILED(hr);
                } else
                { // must be ADD operation
                    hr = GetDefaultSchedule(&pConn->m_pScheduleNew);
                    RETURN_IF_FAILED(hr);
                }
            }
        }
    }

    return hr;
}

HRESULT CCustomTopology::_UpdateScheduleOnSelectedConnections(IN SCHEDULE* i_pSchedule)
{
    HRESULT             hr = S_OK;
    int                 nIndex = -1;
    CCusTopConnection*  pConn = NULL;
    HWND                hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    while ( -1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL | LVNI_SELECTED)) &&
            NULL != (pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex)))
    {
        if (pConn->m_pScheduleNew)
        {
            free(pConn->m_pScheduleNew);
            pConn->m_pScheduleNew = NULL;
        }

        hr = CopySchedule(i_pSchedule, &pConn->m_pScheduleNew);
        BREAK_IF_FAILED(hr);
    }

    return hr;
}

LRESULT CCustomTopology::OnSchedule
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT hr = S_OK;

    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    int nCount = ListView_GetSelectedCount(hwnd);
    if (nCount < 1)
    {
        DisplayMessageBoxWithOK(IDS_FRS_CUSTOP_NOSELECTION);
        return FALSE;
    }

    do {
        //
        // get schedule info on each selected connections
        //
        hr = _InitScheduleOnSelectedConnections();
        BREAK_IF_FAILED(hr);

        //
        // get schedule of the first selected item
        //
        int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
        if (-1 == nIndex)
        {
            hr = E_INVALIDARG;
            break;
        }

        CCusTopConnection* pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex);
        if (!pConn)
        {
            hr = E_INVALIDARG;
            break;
        }

        SCHEDULE* pSchedule = NULL;
        hr = CopySchedule(pConn->m_pScheduleNew, &pSchedule);
        BREAK_IF_FAILED(hr);

        hr = InvokeScheduleDlg(m_hWnd, pSchedule);

        if (S_OK == hr)
            hr = _UpdateScheduleOnSelectedConnections(pSchedule);

        free(pSchedule);

    } while (0);

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CWaitCursor wait;
    BOOL      bValidInput = FALSE;
    int       idString = 0;
    HRESULT   hr = S_OK;

    do {
        //
        // if changed, update TopologyPref
        //
        int index = SendDlgItemMessage(IDC_FRS_CUSTOP_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
        if (0 != lstrcmpi(m_bstrTopologyPref, g_TopologyPref[index].pszTopologyPref))
        {
            hr = m_piReplicaSet->put_TopologyPref(g_TopologyPref[index].pszTopologyPref);
            BREAK_IF_FAILED(hr);
        }

        //
        // if changed, update HubServer
        //
        if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE) &&
            0 != lstrcmpi(g_TopologyPref[index].pszTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
        {
            hr = m_piReplicaSet->put_HubMemberDN(NULL);
            BREAK_IF_FAILED(hr);
        } else if (!lstrcmpi(g_TopologyPref[index].pszTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
        {
            CCusTopMember* pHubMember = NULL;
            hr = _GetHubMember(&pHubMember);
            BREAK_IF_FAILED(hr);

            if (0 != lstrcmpi(m_bstrHubMemberDN, pHubMember->m_bstrMemberDN))
                hr = m_piReplicaSet->put_HubMemberDN(pHubMember->m_bstrMemberDN);

            BREAK_IF_FAILED(hr);
        }

        //
        // if changed, update connections
        //
        CCusTopConnection* pConn = NULL;
        HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
        index = -1;
        while (-1 != (index = ListView_GetNextItem(hwnd, index, LVNI_ALL)))
        {
            pConn = (CCusTopConnection *)GetListViewItemData(hwnd, index);
            if (pConn)
                pConn->m_bStateNew = ListView_GetCheckState(hwnd, index);
        }

        hr = _MakeConnections();
        BREAK_IF_FAILED(hr);

        bValidInput = TRUE;

    } while (0);

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        return FALSE;
    } else if (bValidInput)
    {
        EndDialog(S_OK);
        return TRUE;
    }
    else
    {
        if (idString)
            DisplayMessageBoxWithOK(idString);
        return FALSE;
    }
}

LRESULT CCustomTopology::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

int CALLBACK ConnectionsListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn)
{
  CCusTopConnection* pItem1 = (CCusTopConnection *)lParam1;
  CCusTopConnection* pItem2 = (CCusTopConnection *)lParam2;
  int iResult = 0;

  if (pItem1 && pItem2)
  {
    g_FRS_CUSTOP_Last_SortColumn = lParamColumn;

    switch (lParamColumn)
    {
    case 0:     // Sort by bStateNew.
      iResult = pItem1->m_bStateNew - pItem2->m_bStateNew;
      break;
    case 1:     // Sort by From Server.
      iResult = lstrcmpi(pItem1->m_bstrFromServer, pItem2->m_bstrFromServer);
      break;
    case 2:     // Sort by To Server.
      iResult = lstrcmpi(pItem1->m_bstrToServer, pItem2->m_bstrToServer);
      break;
    case 3:     // Sort by From Site.
      iResult = lstrcmpi(pItem1->m_bstrFromSite, pItem2->m_bstrFromSite);
      break;
    case 4:     // Sort by To Site.
      iResult = lstrcmpi(pItem1->m_bstrToSite, pItem2->m_bstrToSite);
      break;
    default:
      iResult = 0;
      break;
    }
  }

  return(iResult);
}

LRESULT
CCustomTopology::OnNotify(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  IN LPARAM          i_lParam,
  IN OUT BOOL&       io_bHandled
  )
{
  NM_LISTVIEW*    pNMListView = (NM_LISTVIEW*)i_lParam;
  io_bHandled = FALSE; // So that the base class gets this notify too

  if (IDC_FRS_CUSTOP_CONNECTIONS == pNMListView->hdr.idFrom)
  {
    HWND hwndList = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    if (LVN_COLUMNCLICK == pNMListView->hdr.code)
    {
      // sort items
      ListView_SortItems( hwndList,
                          ConnectionsListCompareProc,
                          (LPARAM)(pNMListView->iSubItem));
      io_bHandled = TRUE;
    } else if (LVN_ITEMCHANGED == pNMListView->hdr.code)
    {
        _EnableButtonsForConnectionList();
    }
  }

  return io_bHandled;
}

//
// Update the connection objects in the DS
//
HRESULT CCustomTopology::_MakeConnections()
{
    HRESULT hr = S_OK;

    CCusTopConnectionList::iterator it;
    for (it = m_ConnectionList.begin(); it != m_ConnectionList.end(); it++)
    {
        switch ((*it)->m_opType)
        {
        case CONNECTION_OPTYPE_ADD:
            hr = m_piReplicaSet->AddConnection(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN,
                                    (*it)->m_bStateNew,
                                    NULL
                                    );
            BREAK_IF_FAILED(hr);

            if ((*it)->m_pScheduleNew)
            {
                VARIANT var;
                VariantInit(&var);
                hr = ScheduleToVariant((*it)->m_pScheduleNew, &var);
                BREAK_IF_FAILED(hr);

                hr = m_piReplicaSet->SetConnectionScheduleEx(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN,
                                    &var);
                VariantClear(&var);
            }
            break;

        case CONNECTION_OPTYPE_DEL:
            hr = m_piReplicaSet->RemoveConnectionEx(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN
                                    );
            break;

        default:
            if ((*it)->m_bStateNew != (*it)->m_bStateOld)
            {
                hr = m_piReplicaSet->EnableConnectionEx(
                                        (*it)->m_bstrFromMemberDN,
                                        (*it)->m_bstrToMemberDN,
                                        (*it)->m_bStateNew
                                        );
                BREAK_IF_FAILED(hr);
            }

            if (S_OK == CompareSchedules((*it)->m_pScheduleNew, (*it)->m_pScheduleOld))
                break;  // no change on shcedule

            if ((*it)->m_pScheduleNew)
            {
                VARIANT var;
                VariantInit(&var);
                hr = ScheduleToVariant((*it)->m_pScheduleNew, &var);
                BREAK_IF_FAILED(hr);

                hr = m_piReplicaSet->SetConnectionScheduleEx(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN,
                                    &var);
                VariantClear(&var);
            }

            break;
        }

        BREAK_IF_FAILED(hr);
    }

    return hr;
}

//////////////////////////////////////////////////////////
//
//

void FreeCusTopMembers(CCusTopMemberList* pList)
{
    if (pList && !pList->empty())
   {
       for (CCusTopMemberList::iterator i = pList->begin(); i != pList->end(); i++)
           delete (*i);

       pList->clear();
   }
}

void FreeCusTopConnections(CCusTopConnectionList* pList)
{
    if (pList && !pList->empty())
   {
       for (CCusTopConnectionList::iterator i = pList->begin(); i != pList->end(); i++)
           delete (*i);

       pList->clear();
   }
}

//////////////////////////////////////////////////////////
//
// CCusTopMember
//
CCusTopMember::~CCusTopMember()
{
    _Reset();
}

HRESULT CCusTopMember::Init(BSTR bstrMemberDN, BSTR bstrServer, BSTR bstrSite)
{
    RETURN_INVALIDARG_IF_NULL(bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(bstrServer);
    RETURN_INVALIDARG_IF_NULL(bstrSite);

    _Reset();

    HRESULT hr = S_OK;
    do {
        m_bstrMemberDN = bstrMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrMemberDN, &hr);
        m_bstrServer = bstrServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServer, &hr);
        m_bstrSite = bstrSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSite, &hr);
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

void CCusTopMember::_Reset()
{
    m_bstrMemberDN.Empty();
    m_bstrServer.Empty();
    m_bstrSite.Empty();
}

//////////////////////////////////////////////////////////
//
// CCusTopConnection
//
CCusTopConnection::CCusTopConnection()
{
    m_bStateOld = m_bStateNew = TRUE;
    m_pScheduleOld = m_pScheduleNew = NULL;
    m_opType = CONNECTION_OPTYPE_OTHERS;
}

CCusTopConnection::~CCusTopConnection()
{
    _Reset();
}

HRESULT CCusTopConnection::Init(
    BSTR bstrFromMemberDN, BSTR bstrFromServer, BSTR bstrFromSite,
    BSTR bstrToMemberDN, BSTR bstrToServer, BSTR bstrToSite,
    BOOL bState, // = TRUE
    CONNECTION_OPTYPE opType // = CONNECTION_OPTYPE_OTHERS
    )
{
    RETURN_INVALIDARG_IF_NULL(bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(bstrFromServer);
    RETURN_INVALIDARG_IF_NULL(bstrFromSite);

    RETURN_INVALIDARG_IF_NULL(bstrToMemberDN);
    RETURN_INVALIDARG_IF_NULL(bstrToServer);
    RETURN_INVALIDARG_IF_NULL(bstrToSite);

    _Reset();

    HRESULT hr = S_OK;
    do {
        m_bstrFromMemberDN = bstrFromMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromMemberDN, &hr);
        m_bstrFromServer = bstrFromServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromServer, &hr);
        m_bstrFromSite = bstrFromSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromSite, &hr);

        m_bstrToMemberDN = bstrToMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToMemberDN, &hr);
        m_bstrToServer = bstrToServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToServer, &hr);
        m_bstrToSite = bstrToSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToSite, &hr);

        m_bStateNew = m_bStateOld = bState;

        m_opType = opType;

        m_pScheduleOld = m_pScheduleNew = NULL;

    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

void CCusTopConnection::_Reset()
{
    m_bstrFromMemberDN.Empty();
    m_bstrFromServer.Empty();
    m_bstrFromSite.Empty();
    m_bstrToMemberDN.Empty();
    m_bstrToServer.Empty();
    m_bstrToSite.Empty();
    m_bStateOld = TRUE;
    m_bStateNew = TRUE;
    m_opType = CONNECTION_OPTYPE_OTHERS;

    if (m_pScheduleOld)
    {
        free(m_pScheduleOld);
        m_pScheduleOld = NULL;
    }

    if (m_pScheduleNew)
    {
        free(m_pScheduleNew);
        m_pScheduleNew = NULL;
    }
}

HRESULT CCusTopConnection::Copy(CCusTopConnection* pConn)
{
    if (!pConn || !(pConn->m_bstrFromMemberDN) || !*(pConn->m_bstrFromMemberDN))
        return E_INVALIDARG;

    _Reset();

    HRESULT hr = S_OK;
    do {
        m_bstrFromMemberDN = pConn->m_bstrFromMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromMemberDN, &hr);
        m_bstrFromServer = pConn->m_bstrFromServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromServer, &hr);
        m_bstrFromSite = pConn->m_bstrFromSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromSite, &hr);

        m_bstrToMemberDN = pConn->m_bstrToMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToMemberDN, &hr);
        m_bstrToServer = pConn->m_bstrToServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToServer, &hr);
        m_bstrToSite = pConn->m_bstrToSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToSite, &hr);

        m_bStateOld = pConn->m_bStateOld;
        m_bStateNew = pConn->m_bStateNew;

        m_opType = pConn->m_opType;

        if (pConn->m_pScheduleOld)
        {
            hr = CopySchedule(pConn->m_pScheduleOld, &m_pScheduleOld);
            BREAK_IF_FAILED(hr);
        }

        if (pConn->m_pScheduleNew)
        {
            hr = CopySchedule(pConn->m_pScheduleNew, &m_pScheduleNew);
            BREAK_IF_FAILED(hr);
        }
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

HRESULT CCustomTopology::_AddToConnectionListAndView(CCusTopConnection* pConn)
{
    RETURN_INVALIDARG_IF_NULL(pConn);

    BOOL bFound = FALSE;

    CCusTopConnectionList::iterator it;
    for (it = m_ConnectionList.begin(); it != m_ConnectionList.end(); it++)
    {
        if (!lstrcmpi((*it)->m_bstrFromMemberDN, pConn->m_bstrFromMemberDN) &&
            !lstrcmpi((*it)->m_bstrToMemberDN, pConn->m_bstrToMemberDN))
        {
            bFound = TRUE;
            break;
        }
    }

    HRESULT hr = S_OK;
    if (!bFound)
    {
        CCusTopConnection* pNew = new CCusTopConnection;
        RETURN_OUTOFMEMORY_IF_NULL(pNew);

        hr = pNew->Copy(pConn);
        if (FAILED(hr))
            delete pNew;
        else
        {
            m_ConnectionList.push_back(pNew);

            hr = _InsertConnection(pNew);
        }
    } else
    {
        (*it)->m_bStateNew = TRUE;
        if ((*it)->m_opType == CONNECTION_OPTYPE_DEL)
        {
            (*it)->m_opType = CONNECTION_OPTYPE_OTHERS;
            hr = _InsertConnection(*it);
        } else
        {
            (*it)->m_opType = CONNECTION_OPTYPE_OTHERS;
            hr = _SetConnectionState(*it);
        }
    }

    return hr;
}

HRESULT CCustomTopology::_RemoveFromConnectionList(CCusTopConnection* pConn)
{
    RETURN_INVALIDARG_IF_NULL(pConn);

    BOOL bFound = FALSE;

    CCusTopConnectionList::iterator it;
    for (it = m_ConnectionList.begin(); it != m_ConnectionList.end(); it++)
    {
        if (!lstrcmpi((*it)->m_bstrFromMemberDN, pConn->m_bstrFromMemberDN) &&
            !lstrcmpi((*it)->m_bstrToMemberDN, pConn->m_bstrToMemberDN))
        {
            bFound = TRUE;
            break;
        }
    }

    if (it != m_ConnectionList.end())
    {
        if (CONNECTION_OPTYPE_ADD == (*it)->m_opType)
        {
            delete (*it);
            m_ConnectionList.erase(it);
        } else
        {
            (*it)->m_opType = CONNECTION_OPTYPE_DEL;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CNewConnections
//

CNewConnections::CNewConnections() : m_pMemberList(NULL)
{
}

CNewConnections::~CNewConnections()
{
    FreeCusTopConnections(&m_NewConnectionList);
}


HRESULT CNewConnections::Initialize
(
  CCusTopMemberList* i_pMemberList
)
{
    RETURN_INVALIDARG_IF_NULL(i_pMemberList);
    m_pMemberList = i_pMemberList;
    return S_OK;
}

#define NUM_OF_FRS_NEWCONN_COLUMNS      2

LRESULT CNewConnections::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    int nControlID[] = {IDC_FRS_NEWCONN_FROM, IDC_FRS_NEWCONN_TO};
    int nColStringID[] = {IDS_FRS_NEWCONN_COL_FROMSERVER, IDS_FRS_NEWCONN_COL_TOSERVER};

    HWND hwndControl = NULL;
    CCusTopMemberList::iterator it;

    for (int i = 0; i < 2; i++)
    {
        hwndControl = GetDlgItem(nControlID[i]);
        AddLVColumns(hwndControl, nColStringID[i], NUM_OF_FRS_NEWCONN_COLUMNS);
        ListView_SetExtendedListViewStyle(hwndControl, LVS_EX_FULLROWSELECT);

        for (it = m_pMemberList->begin(); it != m_pMemberList->end(); it++)
        {
            LVITEM  lvItem;

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = (LPARAM)(*it);
            lvItem.pszText = (*it)->m_bstrServer;
            lvItem.iSubItem = 0;
            int iItemIndex = ListView_InsertItem(hwndControl, &lvItem);

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = iItemIndex;
            lvItem.pszText = (*it)->m_bstrSite;
            lvItem.iSubItem = 1;
            ListView_SetItem(hwndControl, &lvItem);
        }
    }

    return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CNewConnections::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_NEWCONN);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CNewConnections::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_NEWCONN);

  return TRUE;
}

HRESULT CNewConnections::get_NewConnections(CCusTopConnectionList** ppConnectionList)
{
    RETURN_INVALIDARG_IF_NULL(ppConnectionList);
    *ppConnectionList = &m_NewConnectionList;
    return S_OK;
}

LRESULT CNewConnections::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    BOOL      bValidInput = FALSE;
    int       idString = 0;
    HRESULT   hr = S_OK;

    do {
        idString = IDS_FRS_NEWCONN_NOSELECTION;

        //
        // get all selected From servers
        //
        CCusTopMember* pMember;
        CCusTopMemberList fromMemberList;
        HWND hwndFrom = GetDlgItem(IDC_FRS_NEWCONN_FROM);
        int nIndexFrom = ListView_GetNextItem(hwndFrom, -1, LVNI_ALL | LVNI_SELECTED);
        while (-1 != nIndexFrom &&
                (pMember = (CCusTopMember *)GetListViewItemData(hwndFrom, nIndexFrom)))
        {
            fromMemberList.push_back(pMember);
            nIndexFrom = ListView_GetNextItem(hwndFrom, nIndexFrom, LVNI_ALL | LVNI_SELECTED);
        }
        if (fromMemberList.empty())
            break;

        //
        // get all selected To servers
        //
        CCusTopMemberList toMemberList;
        HWND hwndTo = GetDlgItem(IDC_FRS_NEWCONN_TO);
        int nIndexTo = ListView_GetNextItem(hwndTo, -1, LVNI_ALL | LVNI_SELECTED);
        while (-1 != nIndexTo &&
                (pMember = (CCusTopMember *)GetListViewItemData(hwndTo, nIndexTo)))
        {
            toMemberList.push_back(pMember);
            nIndexTo = ListView_GetNextItem(hwndTo, nIndexTo, LVNI_ALL | LVNI_SELECTED);
        }
        if (toMemberList.empty())
            break;

        //
        // init the list
        //
        FreeCusTopConnections(&m_NewConnectionList);

        //
        // build the connection list
        //
        CCusTopMemberList::iterator from, to;
        for (from = fromMemberList.begin(); from != fromMemberList.end(); from++)
        {
            for (to = toMemberList.begin(); to != toMemberList.end(); to++)
            {
                if (!lstrcmpi((*from)->m_bstrServer, (*to)->m_bstrServer))
                    continue;

                CCusTopConnection* pNew = new CCusTopConnection;
                BREAK_OUTOFMEMORY_IF_NULL(pNew, &hr);

                hr = pNew->Init(
                            (*from)->m_bstrMemberDN, (*from)->m_bstrServer, (*from)->m_bstrSite,
                            (*to)->m_bstrMemberDN, (*to)->m_bstrServer, (*to)->m_bstrSite,
                            TRUE, CONNECTION_OPTYPE_ADD);
                BREAK_IF_FAILED(hr);

                m_NewConnectionList.push_back(pNew);
            }
            BREAK_IF_FAILED(hr);
        }

        if (SUCCEEDED(hr))
            bValidInput = TRUE;

    } while (0);

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        return FALSE;
    } else if (bValidInput)
    {
        EndDialog(S_OK);
        return TRUE;
    }
    else
    {
        if (idString)
            DisplayMessageBoxWithOK(idString);
        return FALSE;
    }
}

LRESULT CNewConnections::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

int CALLBACK MembersListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn)
{
  CCusTopMember* pItem1 = (CCusTopMember *)lParam1;
  CCusTopMember* pItem2 = (CCusTopMember *)lParam2;
  int iResult = 0;

  if (pItem1 && pItem2)
  {
    switch( lParamColumn)
    {
    case 0:     // Sort by Server.
      iResult = lstrcmpi(pItem1->m_bstrServer, pItem2->m_bstrServer);
      break;
    case 1:     // Sort by Site.
      iResult = lstrcmpi(pItem1->m_bstrSite, pItem2->m_bstrSite);
      break;
    default:
      iResult = 0;
      break;
    }
  }

  return(iResult);
}

LRESULT
CNewConnections::OnNotify(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  IN LPARAM          i_lParam,
  IN OUT BOOL&       io_bHandled
  )
{
  NM_LISTVIEW*    pNMListView = (NM_LISTVIEW*)i_lParam;
  io_bHandled = FALSE; // So that the base class gets this notify too

  if (IDC_FRS_NEWCONN_FROM == pNMListView->hdr.idFrom ||
      IDC_FRS_NEWCONN_TO == pNMListView->hdr.idFrom)
  {
    HWND hwndList = GetDlgItem(pNMListView->hdr.idFrom);
    if (LVN_COLUMNCLICK == pNMListView->hdr.code)
    {
      // sort items
      ListView_SortItems( hwndList,
                          MembersListCompareProc,
                          (LPARAM)(pNMListView->iSubItem));
      io_bHandled = TRUE;
    }
  }

  return io_bHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\bufmgr.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "bufmgr.h"
#include <process.h>

#define DOMAIN_DFSROOTS_SUFFIX  _T("D")
#define ALL_DFSROOTS_SUFFIX     _T("A")

unsigned __stdcall GetDataThreadFunc( void* lParam );

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::CBufferManager
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------
CBufferManager::CBufferManager(HWND hDlg) : 
  m_cRef(0), m_hDlg(hDlg)
{
  dfsDebugOut((_T("CBufferManager::CBufferManager, this=%p\n"), this));

  m_lContinue = 1;  
  InitializeCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::~CBufferManager
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------
CBufferManager::~CBufferManager()
{
  dfsDebugOut((_T("CBufferManager::~CBufferManager, this=%p\n"), this));

  _ASSERT(0 >= m_cRef);
  FreeBuffer();
  DeleteCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::CreateInstance
//
//  Synopsis:   Create an instance of CBufferManager.
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::CreateInstance(
    IN HWND               hDlg, 
    OUT CBufferManager **ppBufferManager
)
{
  dfsDebugOut((_T("CBufferManager::CreateInstance, hDlg=%x\n"), hDlg));

  _ASSERT(ppBufferManager);

  *ppBufferManager = new CBufferManager(hDlg);
  if ( !(*ppBufferManager) )
    return E_OUTOFMEMORY;

  (*ppBufferManager)->AddRef();

  return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::AddRef
//
//  Synopsis:   Increment reference count of this instance
//
//----------------------------------------------------------------------------
LONG
CBufferManager::AddRef()
{
  dfsDebugOut((_T("CBufferManager::AddRef, this=%p, preValue=%d\n"), this, m_cRef));

  return InterlockedIncrement(&m_cRef);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::Release
//
//  Synopsis:   Decrement reference count of this instance.
//              When the reference count reaches 0, delete this instance.
//
//----------------------------------------------------------------------------
LONG
CBufferManager::Release()
{
  dfsDebugOut((_T("CBufferManager::Release, this=%p, preValue=%d\n"), this, m_cRef));

  if (InterlockedDecrement(&m_cRef) <= 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::SignalExit
//
//  Synopsis:   Called by the owner dialog to signal the related threads to exit.
//
//----------------------------------------------------------------------------
void
CBufferManager::SignalExit()
{ 
  dfsDebugOut((_T("CBufferManager::SignalExit\n")));

  InterlockedExchange(&m_lContinue, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::ShouldExit
//
//  Synopsis:   Threads are calling this function periodically to see
//              if the owner dialog signals them to exit.
//
//----------------------------------------------------------------------------
BOOL
CBufferManager::ShouldExit()
{
  dfsDebugOut((_T("CBufferManager::ShouldExit %d\n"), !m_lContinue));

  return (!m_lContinue);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::LoadInfo
//
//  Synopsis:   The Owner dialog call it to get a pointer to the info of the specified domain.
//      The buffer consists of entries. 
//      Each entry is in the form of (LPTSTR szNodeName, CEntryData* pEntry).
//
//      LoadInfo() will first look up in the buffer.
//      If a valid entry is found, pass back pEntry to caller.
//      If an error entry is found, reset it (clear the error) and retry.
//      If an inprogress entry is found, do nothing. The caller will handle a THREAD_DONE later.
//      If no entry in the buffer, create a new entry, kick off a thread.
//
//      When the owner dialog get THREAD_DONE message, the related entry
//      in the buffer should either be a valid entry or an error entry.
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::LoadInfo(
    IN PCTSTR       pszNodeName,
    IN NODETYPE     nNodeType,
    IN HTREEITEM    hItem,
    OUT CEntryData **ppInfo
)
{
  _ASSERT(pszNodeName);
  _ASSERT(*pszNodeName);
  _ASSERT(hItem);
  _ASSERT(ppInfo);
  _ASSERT(*ppInfo == NULL);  // prevent memory leak

  dfsDebugOut((_T("CBufferManager::LoadInfo for %s\n"), pszNodeName));

  BOOL          bStartNewThread = FALSE;
  HRESULT       hr = S_OK;
  PVOID         ptr = NULL;
  CEntryData*  pEntry = NULL;
  Cache::iterator i;
  CComBSTR      bstrUniqueNodeName = pszNodeName;
  if (FTDFS == nNodeType)
    bstrUniqueNodeName += DOMAIN_DFSROOTS_SUFFIX;
  else
    bstrUniqueNodeName += ALL_DFSROOTS_SUFFIX;

  EnterCriticalSection(&m_CriticalSection);     // Lock buffer

  i = m_map.find(bstrUniqueNodeName);
  if (i != m_map.end()) {
    pEntry = (*i).second;
    //
    // Found an entry in the buffer.
    //
    if (pEntry)
    {
      switch (pEntry->GetEntryType())
      {
      case BUFFER_ENTRY_TYPE_VALID:
        // return the valid entry pointer
        *ppInfo = pEntry;
        break;
      case BUFFER_ENTRY_TYPE_ERROR:
        // kick off a thread to retry
        pEntry->ReSet();
        bStartNewThread = TRUE;
        break;
      case BUFFER_ENTRY_TYPE_INPROGRESS:
        // do nothing
        break;
      }
    }

  } else
  {
    //
    // not found in the buffer, need to start a new thread
    //
    bStartNewThread = TRUE;
    pEntry = new CEntryData(pszNodeName, nNodeType, hItem);
    PTSTR pszNode = _tcsdup(bstrUniqueNodeName);
    if (pEntry && pszNode) {
      m_map[pszNode] = pEntry;
    } else
    {
      hr = E_OUTOFMEMORY;
      if (pEntry)
        delete pEntry;
    }
  }

  if (SUCCEEDED(hr) && bStartNewThread)
  {
    hr = StartThread(pszNodeName, nNodeType);
    if (FAILED(hr))
    {
      delete pEntry;
      m_map.erase(bstrUniqueNodeName);
    }
  }

  LeaveCriticalSection(&m_CriticalSection);   // Unlock buffer

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::AddInfo
//
//  Synopsis:   Called by the thread function to add one result to the buffer.
//              It will pass back the pointer to the entry in the 5th parameters.
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::AddInfo(
    IN PCTSTR   pszNodeName, 
    IN PVOID    pList,
    IN HRESULT  hr,
    OUT PVOID*  ppv
)
{
  _ASSERT(pszNodeName);
  _ASSERT(*pszNodeName);

  dfsDebugOut((_T("CBufferManager::AddInfo for %s, hr=%x\n"), 
    pszNodeName, hr));

  PVOID   p = NULL;

  EnterCriticalSection(&m_CriticalSection);     // Lock buffer

  //
  // the entry must have been existed with a non-NULL pointer
  //
  Cache::iterator i = m_map.find(const_cast<PTSTR>(pszNodeName));
  _ASSERT(i != m_map.end());
  p = (*i).second;
  _ASSERT(p);

  ((CEntryData*)p)->SetEntry(pList, hr);

  LeaveCriticalSection(&m_CriticalSection);   // Unlock buffer

  *ppv = p;

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::FreeBuffer
//
//  Synopsis:   Clear m_map. 
//              This member holds all the results returned by various threads 
//              since the initialization of the owner dialog. Each one is 
//              in the form of (NodeName ==> CEntryData*)
//
//----------------------------------------------------------------------------
void
CBufferManager::FreeBuffer()
{
  EnterCriticalSection(&m_CriticalSection);     // Lock buffer

  if (!m_map.empty()) {
    for (Cache::iterator i = m_map.begin(); i != m_map.end(); i++)
    {
      if ((*i).first)
        free( (void *)((*i).first) );
      if ((*i).second)
        delete( (CEntryData*)((*i).second) );
    }
    m_map.clear();
  }

  LeaveCriticalSection(&m_CriticalSection);   // Unlock buffer
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::ThreadReport
//
//  Synopsis:   Report THREAD_DONE to the owner dialog. 
//
//----------------------------------------------------------------------------
void
CBufferManager::ThreadReport(
    IN PVOID    ptr,
    IN HRESULT  hr
)
{
  _ASSERT(ptr);

  PostMessage(m_hDlg, WM_USER_GETDATA_THREAD_DONE,
    reinterpret_cast<WPARAM>(ptr), hr);
}

/////////////////////////////////////////////////////////
// 
// thread info structure
typedef struct _GetDataThreadInfo
{
  PTSTR               pszNodeName;
  NODETYPE            nNodeType;
  CBufferManager      *pBufferManager;
} GETDATATHREADINFO;

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::StartThread
//
//  Synopsis:   Start a thread. 
//
//     Pass the following info to the thread function:
//
//     pszNodeName: 
//          domain we need to get a list of DCs for.
//     pBufferManager:
//          the CBufferManager instance for the ThreadFunc to 
//          add result to the buffer
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::StartThread(
    IN PCTSTR   pszNodeName,
    IN NODETYPE nNodeType
) 
{
  _ASSERT(pszNodeName);
  _ASSERT(*pszNodeName);

  dfsDebugOut((_T("CBufferManager::StartThread for %s\n"), pszNodeName));

  GETDATATHREADINFO *pThreadInfo = new GETDATATHREADINFO;
  if (!pThreadInfo)
    return E_OUTOFMEMORY;

  if ( !(pThreadInfo->pszNodeName = _tcsdup(pszNodeName)) )
  {
    delete pThreadInfo;
    return E_OUTOFMEMORY;
  }

  pThreadInfo->nNodeType = nNodeType;
  pThreadInfo->pBufferManager = this;

  AddRef();

  unsigned threadID;
  HANDLE pThread = (HANDLE)ULongToPtr(_beginthreadex( 
                      NULL,               //void *security, 
                      0,                  //unsigned stack_size, 
                      &GetDataThreadFunc,   //unsigned ( __stdcall *start_address )( void * ), 
                      (void *)pThreadInfo, //void *arglist, 
                      0,                  //unsigned initflag, 
                      &threadID           //unsigned *thrdaddr
                      ));


  if (!pThread)
  {
    free(pThreadInfo->pszNodeName);
    delete pThreadInfo;

    Release();

    return E_FAIL;
  }

  return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDataThreadFunc
//
//  Synopsis:   The GetData Thread Function. 
//              This function invokes GetDomainDfsRoots to get a list
//              of dfs root names in the specified domain, and add them to the buffer of 
//              CBufferManager instance.
//              This function regularly checks to see if the owner dialog signals
//              it to exit, if not, it will finish its normal operation and
//              post a THREAD_DONE message to the owner dialog.
//
//----------------------------------------------------------------------------
unsigned __stdcall GetDataThreadFunc( void* lParam )
{
  GETDATATHREADINFO *pThreadInfo = reinterpret_cast<GETDATATHREADINFO *>(lParam);
  _ASSERT(pThreadInfo);
  _ASSERT(pThreadInfo->pszNodeName);
  _ASSERT(*(pThreadInfo->pszNodeName));
  _ASSERT(pThreadInfo->pBufferManager);

  dfsDebugOut((_T("GetDataThreadFunc pszNodeName=%s, pBufferManager=%p\n"),
    pThreadInfo->pszNodeName, pThreadInfo->pBufferManager));

  //
  // retrieve information passed into this function
  //
  CComBSTR             bstrNode = pThreadInfo->pszNodeName;
  NODETYPE             nNodeType = pThreadInfo->nNodeType; 
  CBufferManager      *pBufferManager = pThreadInfo->pBufferManager;
  free(pThreadInfo->pszNodeName);
  delete pThreadInfo;

  NETNAMELIST*        pNameList = NULL;
  PVOID               pEntry = NULL;
  HRESULT             hr = S_OK;

  if (FAILED(hr) || pBufferManager->ShouldExit() || FTDFS != nNodeType)
    goto Thread_Exit;

  pNameList = new NETNAMELIST;
  if (!pNameList)
  {
    hr = E_OUTOFMEMORY;
    goto Thread_Exit;
  }

  if (FTDFS == nNodeType)
  {
    hr = GetDomainDfsRoots(pNameList, bstrNode);
    bstrNode += DOMAIN_DFSROOTS_SUFFIX;
  } /*else
  {
    hr = GetServers(pNameList, bstrNode);
    bstrNode += ALL_DFSROOTS_SUFFIX;
  } */

  if (pBufferManager->ShouldExit())
  {
    if (SUCCEEDED(hr))
      FreeNetNameList(pNameList);
    delete pNameList;
    goto Thread_Exit;
  }

  if (FAILED(hr)) {
    // Add an error entry in the buffer.
    delete pNameList;
    pBufferManager->AddInfo(bstrNode, NULL, hr, &pEntry);
    goto Thread_Exit;
  }

  //
  // Add result to the buffer in CBufferManager
  //
  hr = pBufferManager->AddInfo(bstrNode, pNameList, S_OK, &pEntry);
  if (FAILED(hr)) {
    FreeNetNameList(pNameList);
    delete pNameList;
  }

Thread_Exit:

  if (FALSE == pBufferManager->ShouldExit())
  {
    //
    // report THREAD_DONE with the pointer to the entry
    //
    if (pEntry)
      pBufferManager->ThreadReport(pEntry, hr);
  }

  //
  // Decrement the reference count on the CBufferManager instance
  //
  pBufferManager->Release();

  return 0;
}

///////////////////////////////////////////////
// class CEntryData

CEntryData::CEntryData(LPCTSTR pszNodeName, NODETYPE nNodeType, HTREEITEM hItem)
{
  m_bstrNodeName = pszNodeName;
  m_nNodeType = nNodeType;
  m_hItem = hItem;
  m_pList = NULL;
  m_hr = S_OK;
}

CEntryData::~CEntryData()
{
  dfsDebugOut((_T("CEntryData::~CEntryData\n")));
  FreeNetNameList(m_pList);
  if (m_pList)
    delete m_pList;
}

void
CEntryData::SetEntry(PVOID pList, HRESULT hr)
{
  FreeNetNameList(m_pList);
  if (m_pList)
    delete m_pList;
  m_pList = (NETNAMELIST *)pList;
  
  m_hr = hr;
}

enum BUFFER_ENTRY_TYPE
CEntryData::GetEntryType()
{
  if (FAILED(m_hr))
    return BUFFER_ENTRY_TYPE_ERROR;
  if (m_pList == NULL)
    return BUFFER_ENTRY_TYPE_INPROGRESS;
  return BUFFER_ENTRY_TYPE_VALID;
}

void
CEntryData::ReSet()
{
  _ASSERT(GetEntryType() == BUFFER_ENTRY_TYPE_ERROR);
  m_hr = S_OK;
  _ASSERT(GetEntryType() == BUFFER_ENTRY_TYPE_INPROGRESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\addtodfs.cpp ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the implementation for CAddToDfs.
  This class displays the Add To Dfs Dialog, which is used to add new Junctions Points.

*/

#include "stdafx.h"
#include "AddToDfs.h"
#include <shlobj.h>
#include <dsclient.h>
#include "utils.h"
#include "dfshelp.h"
#include "netutils.h"

/////////////////////////////////////////////////////////////////////////////
// CAddToDfs

CAddToDfs::CAddToDfs():m_lTime(1800)
{
}

CAddToDfs::~CAddToDfs()
{
}


HRESULT CAddToDfs::put_ParentPath
(
  BSTR i_bstrParentPath
)
{
/*++

Routine Description:

  Sets the path of the parent Junction point.
  This is used to display in the edit text and append to the entry path.

*/

  if (!i_bstrParentPath)
    return(E_INVALIDARG);

  m_bstrParentPath = i_bstrParentPath;

  if (!m_bstrParentPath)
    return(E_OUTOFMEMORY);

  return(S_OK);
}


HRESULT CAddToDfs::get_Comment
(
  BSTR *o_bstrComment
)
{
  if (!o_bstrComment)
    return(E_INVALIDARG);

  *o_bstrComment = SysAllocString(m_bstrComment);

  if (!*o_bstrComment)
    return(E_OUTOFMEMORY);

  return(S_OK);
}


HRESULT CAddToDfs::get_EntryPath
(
  BSTR *o_bstrEntryPath
)
{
/*++

Routine Description:

  Returns the complete entry path of the new Junction point to be created.

*/
  if (!o_bstrEntryPath)
    return(E_INVALIDARG);

  *o_bstrEntryPath = SysAllocString(m_bstrEntryPath);

  if (!*o_bstrEntryPath)
    return(E_OUTOFMEMORY);

  return(S_OK);
}

HRESULT CAddToDfs::get_JPName
(
  BSTR *o_bstrJPName
)
{
  if (!o_bstrJPName)
    return(E_INVALIDARG);

  *o_bstrJPName = SysAllocString(m_bstrJPName);

  if (!*o_bstrJPName)
    return(E_OUTOFMEMORY);

  return(S_OK);
}

HRESULT CAddToDfs::get_NetPath
(
  BSTR *o_bstrNetPath
)
{
/*++

Routine Description:

  Returns the complete share path typed in by the user in the edit box.

*/
  if (!o_bstrNetPath)
    return(E_INVALIDARG);

  *o_bstrNetPath = SysAllocString(m_bstrNetPath);

  if (!*o_bstrNetPath)
    return(E_OUTOFMEMORY);

  return(S_OK);
}


HRESULT CAddToDfs::get_Server
(
  BSTR *o_bstrServer
)
{
/*++

Routine Description:

  Returns the server component of the share path.

*/

  if (!o_bstrServer)
    return(E_INVALIDARG);

  *o_bstrServer = SysAllocString(m_bstrServer);

  if (!*o_bstrServer)
    return(E_OUTOFMEMORY);

  return(S_OK);
}



HRESULT CAddToDfs::get_Share
(
  BSTR *o_bstrShare
)
{
/*++

Routine Description:

  Returns the share component of the share path.

*/
  if (!o_bstrShare)
    return(E_INVALIDARG);

  *o_bstrShare = SysAllocString(m_bstrShare);

  if (!*o_bstrShare)
    return(E_OUTOFMEMORY);

  return(S_OK);
}





HRESULT CAddToDfs::get_Time
(
  long *o_plTime
)
{
  if (!o_plTime)
    return(E_INVALIDARG);

  *o_plTime = m_lTime;

  return(S_OK);
}

extern WNDPROC g_fnOldEditCtrlProc;

LRESULT CAddToDfs::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Performs the dialog initialization.

Arguments:

  As sent by Dialog Handler.

Return value:

*/

  m_bstrEntryPath.Empty();

  // Format the Parent enrty path and also display it in the static text.
  m_bstrParentPath += _T("\\");
  SetDlgItemText(IDC_EDIT_ADDLINK_DFSLINK_PATH, m_bstrParentPath);

  // Set the default time out value after getting it from the string resource.
  ::SendMessage(GetDlgItem(IDC_EDITTIME), EM_LIMITTEXT, 10, 0);
  TCHAR szTime[16];
  _stprintf(szTime, _T("%u"), m_lTime);
  SetDlgItemText(IDC_EDITTIME, szTime);
  g_fnOldEditCtrlProc = reinterpret_cast<WNDPROC>(
                 ::SetWindowLongPtr(
                                    GetDlgItem(IDC_EDITTIME),
                                    GWLP_WNDPROC, 
                                    reinterpret_cast<LONG_PTR>(NoPasteEditCtrlProc)));

  ::SendMessage(GetDlgItem(IDC_EDITNETPATH), EM_LIMITTEXT, MAX_PATH, 0);
  ::SendMessage(GetDlgItem(IDC_EDITCOMMENT), EM_LIMITTEXT, MAXCOMMENTSZ, 0);

  // Set the previous contents.
  SetDlgItemText(IDC_EDITNETPATH, m_bstrNetPath);
  SetDlgItemText(IDC_EDITCOMMENT, m_bstrComment);

  return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CAddToDfs::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDTODFS);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CAddToDfs::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDTODFS);

  return TRUE;
}

LRESULT CAddToDfs::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  BOOL    bValidInput = FALSE;
  int     idControl = 0;
  int     idString = 0;
  HRESULT hr = S_OK;

  do {
    CWaitCursor wait;

    DWORD dwTextLength = 0;

    // Validate IDC_EDITCOMMENT
    m_bstrComment.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITCOMMENT), &m_bstrComment, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
      m_bstrComment = _T("");

    // Validate IDC_EDITCHLDNODE
    idControl = IDC_EDITCHLDNODE;
    m_bstrJPName.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITCHLDNODE), &m_bstrJPName, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_FIELD;
      break;
    }
    m_bstrEntryPath = m_bstrParentPath;
    m_bstrEntryPath += m_bstrJPName;
    hr = CheckUNCPath(m_bstrEntryPath);
    if (S_OK != hr)
    {
      hr = S_FALSE;
      idString = IDS_INVALID_LINKNAME;
      break;
    }

    // Validate IDC_EDITNETPATH
    idControl = IDC_EDITNETPATH;
    m_bstrNetPath.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITNETPATH), &m_bstrNetPath, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_FIELD;
      break;
    }

    m_bstrServer.Empty();
    m_bstrShare.Empty();
    if (!ValidateNetPath(m_bstrNetPath, &m_bstrServer, &m_bstrShare))
      break;

    // Validate IDC_EDITTIME
    idControl = IDC_EDITTIME;
    CComBSTR bstrTemp;
    hr = GetInputText(GetDlgItem(IDC_EDITTIME), &bstrTemp, &dwTextLength);
    if (FAILED(hr))
      break;
    ULONG ulTimeout = 0;
    if (0 == dwTextLength || !ValidateTimeout(bstrTemp, &ulTimeout))
    {
      idString = IDS_MSG_TIMEOUT_INVALIDRANGE;
      break;
    }
    m_lTime = ulTimeout;

    bValidInput = TRUE;

  } while (0);

  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(idControl));
    return FALSE;
  } else if (bValidInput)
  {
    EndDialog(S_OK);
    return TRUE;
  } else
  {
    if (idString)
      DisplayMessageBoxWithOK(idString);
    ::SetFocus(GetDlgItem(idControl));
    return FALSE;
  }
}

LRESULT CAddToDfs::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  EndDialog(S_FALSE);
  return(true);
}

LRESULT CAddToDfs::OnNetBrowse
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  CComBSTR  bstrPath;
  HRESULT   hr = BrowseNetworkPath(hWndCtl, &bstrPath);

  if (S_OK == hr)
  {
    SetDlgItemText(IDC_EDITNETPATH, bstrPath);
    ::SetFocus(GetDlgItem(IDC_EDITCOMMENT));
  }

  if (S_FALSE == hr)
      ::SetFocus(GetDlgItem(IDC_EDITNETPATH));

  return (SUCCEEDED(hr));
}

LRESULT
CAddToDfs::OnChangeDfsLink(
    WORD wNotifyCode,
    WORD wID, 
    HWND hWndCtl,
    BOOL& bHandled)
{
  CComBSTR  bstrDfsLinkName;
  DWORD     dwTextLength = 0;
  (void)GetInputText(GetDlgItem(IDC_EDITCHLDNODE), &bstrDfsLinkName, &dwTextLength);

  if ((BSTR)bstrDfsLinkName)
  {
    CComBSTR bstrFullPath = m_bstrParentPath;
    bstrFullPath += bstrDfsLinkName;
    SetDlgItemText(IDC_EDIT_ADDLINK_DFSLINK_PATH, bstrFullPath);

    ::SendMessage(GetDlgItem(IDC_EDIT_ADDLINK_DFSLINK_PATH), EM_SETSEL, 0, (LPARAM)-1);
    ::SendMessage(GetDlgItem(IDC_EDIT_ADDLINK_DFSLINK_PATH), EM_SETSEL, (WPARAM)-1, 0);
    ::SendMessage(GetDlgItem(IDC_EDIT_ADDLINK_DFSLINK_PATH), EM_SCROLLCARET, 0, 0);
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\custop.h ===
/*++
Module Name:

    CusTop.cpp

Abstract:

    This module contains the declaration of the CCustomTopology.
    This class displays the Customize Topology Dialog.

*/

#ifndef __CUSTOP_H_
#define __CUSTOP_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"
#include "DfsCore.h"
#include <schedule.h>

#include <list>
using namespace std;

class CCusTopMember
{
public:
    ~CCusTopMember();

    CComBSTR    m_bstrMemberDN;
    CComBSTR    m_bstrServer;
    CComBSTR    m_bstrSite;
    HRESULT Init(BSTR bstrMemberDN, BSTR bstrServer, BSTR bstrSite);

    void _Reset();
};

typedef list<CCusTopMember *>    CCusTopMemberList;

void FreeCusTopMembers(CCusTopMemberList *pList);

class CCusTopConnection
{
public:
    CCusTopConnection();
    ~CCusTopConnection();

    CComBSTR    m_bstrFromMemberDN;
    CComBSTR    m_bstrFromServer;
    CComBSTR    m_bstrFromSite;
    CComBSTR    m_bstrToMemberDN;
    CComBSTR    m_bstrToServer;
    CComBSTR    m_bstrToSite;
    BOOL        m_bStateOld;
    BOOL        m_bStateNew;
    SCHEDULE*   m_pScheduleOld;
    SCHEDULE*   m_pScheduleNew;
    CONNECTION_OPTYPE m_opType;
    HRESULT Init(
        BSTR bstrFromMemberDN, BSTR bstrFromServer, BSTR bstrFromSite,
        BSTR bstrToMemberDN, BSTR bstrToServer, BSTR bstrToSite,
        BOOL bState = TRUE, CONNECTION_OPTYPE opType = CONNECTION_OPTYPE_OTHERS);
    HRESULT Copy(CCusTopConnection* pConn);

    void _Reset();
};

typedef list<CCusTopConnection *>    CCusTopConnectionList;

void FreeCusTopConnections(CCusTopConnectionList *pList);

typedef struct _RSTOPOLOGYPREF_STRING
{
    PTSTR   pszTopologyPref;
    int     nStringID;
} RSTOPOLOGYPREF_STRING;

extern RSTOPOLOGYPREF_STRING g_TopologyPref[];

/////////////////////////////////////////////////////////////////////////////
// CCustomTopology
class CCustomTopology : 
  public CDialogImpl<CCustomTopology>
{
public:
    CCustomTopology();
    ~CCustomTopology();

    enum { IDD = IDD_FRS_CUSTOM_TOPOLOGY };

BEGIN_MSG_MAP(CCustomTopology)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_TOPOLOGYPREF, OnTopologyPref)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_HUBSERVER, OnHubServer)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_REBUILD, OnRebuild)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_CONNECTIONS_NEW, OnConnectionsNew)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_CONNECTIONS_DELETE, OnConnectionsDelete)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_SCHEDULE, OnSchedule)
END_MSG_MAP()

    //  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTopologyPref(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHubServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRebuild(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnectionsNew(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnectionsDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSchedule(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNotify(
                    IN UINT            i_uMsg, 
                    IN WPARAM          i_wParam, 
                    IN LPARAM          i_lParam, 
                    IN OUT BOOL&        io_bHandled
                    );

    //  Methods to access data in the dialog.
    HRESULT put_ReplicaSet(IReplicaSet* i_piReplicaSet);

protected:
    void    _Reset();
    void    _EnableButtonsForConnectionList();
    BOOL    _EnableRebuild();
    HRESULT _AddToConnectionListAndView(CCusTopConnection *pConn);
    HRESULT _RemoveFromConnectionList(CCusTopConnection *pConn);
    HRESULT _SetConnectionState(CCusTopConnection *pConn);
    HRESULT _InsertConnection(CCusTopConnection *pConn);
    HRESULT _SortMemberList();
    HRESULT _GetMemberList();
    HRESULT _GetConnectionList();
    HRESULT _GetMemberDNInfo(
        IN  BSTR    i_bstrMemberDN,
        OUT BSTR*   o_pbstrServer,
        OUT BSTR*   o_pbstrSite
        );
    HRESULT _GetHubMember(
        OUT CCusTopMember** o_ppMember
        );

    HRESULT _RebuildConnections(
        IN  BSTR            i_bstrTopologyPref,
        IN  CCusTopMember*  i_pHubMember
        );

    HRESULT _MakeConnections();

    HRESULT _InitScheduleOnSelectedConnections();
    HRESULT _UpdateScheduleOnSelectedConnections(IN SCHEDULE* i_pSchedule);

    CComBSTR                m_bstrTopologyPref;  // FRS_RSTOPOLOGYPREF
    CComBSTR                m_bstrHubMemberDN;    // HubMemberDN
    CComPtr<IReplicaSet>    m_piReplicaSet;
    CCusTopMemberList       m_MemberList;
    CCusTopConnectionList   m_ConnectionList;
};

/////////////////////////////////////////////////////////////////////////////
// CNewConnections
class CNewConnections : 
  public CDialogImpl<CNewConnections>
{
public:
    CNewConnections();
    ~CNewConnections();

    enum { IDD = IDD_FRS_NEW_CONNECTIONS };

BEGIN_MSG_MAP(CNewConnections)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

    //  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNotify(
                    IN UINT            i_uMsg, 
                    IN WPARAM          i_wParam, 
                    IN LPARAM          i_lParam, 
                    IN OUT BOOL&        io_bHandled
                    );

    HRESULT Initialize(CCusTopMemberList* i_pMemberList);
    HRESULT get_NewConnections(CCusTopConnectionList** ppConnectionList);

protected:
    CCusTopMemberList*      m_pMemberList;       // do not release it 
    CCusTopConnectionList   m_NewConnectionList; // released in desctructor
};

int CALLBACK ConnectionsListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn);

int CALLBACK MembersListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn);

#endif //__CUSTOP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\bufmgr.h ===
#ifndef __BUFMGR_H__
#define __BUFMGR_H__

#include "netutils.h" //NETNAMELIST
#include <map>
using namespace std;

#define WM_USER_GETDATA_THREAD_DONE      WM_USER + 200

enum BUFFER_ENTRY_TYPE {
    BUFFER_ENTRY_TYPE_VALID = 0,
    BUFFER_ENTRY_TYPE_ERROR,
    BUFFER_ENTRY_TYPE_INPROGRESS
};

class CEntryData
{
public:
  CComBSTR                      m_bstrNodeName;
  NODETYPE                      m_nNodeType;
  HTREEITEM                     m_hItem;
  NETNAMELIST*                  m_pList;
  HRESULT                       m_hr;

  CEntryData(LPCTSTR pszNodeName, NODETYPE nNodeType, HTREEITEM hItem);
  ~CEntryData();

  inline LPCTSTR GetNodeName() { return m_bstrNodeName; }
  inline NODETYPE GetNodeType() { return m_nNodeType; }
  inline HTREEITEM GetTreeItem() { return m_hItem; }
  inline NETNAMELIST* GetList() { return m_pList; }
  inline HRESULT GetEntryHRESULT() { return m_hr; };

  void SetEntry(PVOID pList, HRESULT hr);
  enum BUFFER_ENTRY_TYPE GetEntryType();
  void ReSet();
};

struct mapcmpfn
{
    bool operator()(PTSTR p1, PTSTR p2) const
    {
        return lstrcmpi(p1, p2) < 0;
    }
};

typedef map<PTSTR, CEntryData *, mapcmpfn> Cache;

class CBufferManager
{
private:
  LONG  m_cRef; // instance reference count
  HWND  m_hDlg; // the owner dialog which owns this instance 
  LONG  m_lContinue; // synchronization flag between owner dialog and all the related running threads
  CRITICAL_SECTION  m_CriticalSection; // synchronize access to the buffer
  Cache   m_map; // NodeName ==> CEntryData*. The Buffer.

  void FreeBuffer();

  // constructor
  CBufferManager(HWND hDlg);
  // destructor
  ~CBufferManager();

public:
  static HRESULT CreateInstance(
    IN HWND hDlg, 
    OUT CBufferManager **ppBufferManager
  );

  LONG AddRef();
  LONG Release();
  void SignalExit();
  BOOL ShouldExit();

  HRESULT LoadInfo(
      IN PCTSTR       pszNodeName,
      IN NODETYPE     nNodeType,
      IN HTREEITEM    hItem,
      OUT CEntryData **ppInfo
  );
  HRESULT AddInfo(
      IN PCTSTR   pszNodeName, 
      IN PVOID    pList,
      IN HRESULT  hr,
      OUT PVOID*  ppv
  );
  void ThreadReport(
      IN PVOID    ptr,
      IN HRESULT  hr
  );
  HRESULT StartThread(
      IN PCTSTR pszNodeName,
      IN NODETYPE nNodeType
  );
};

#endif // __BUFMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsnodes.h ===
/*++
Module Name:

   DfsNodes.h

Abstract:

    Contains the declaration of DfsAdmin Snapin GUIDs for Nodes.

--*/

#ifndef _DFS_NODES_H
#define _DFS_NODES_H

extern GUID      s_guidDfsReplicaNodeType;

extern GUID      s_guidDfsJPNodeType;

extern GUID      s_guidDfsRootNodeType;

extern GUID      s_guidDfsAdminNodeType;

extern TCHAR*    s_tchDfsReplicaNodeType;

extern TCHAR*    s_tchDfsJPNodeType;

extern TCHAR*    s_tchDfsRootNodeType;

extern TCHAR*    s_tchDfsAdminNodeType;

#endif  //_DFS_NODES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsgui.cpp ===
// DfsGUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f DfsGUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DfsGUI.h"

#include "DfsGUI_i.c"

#include "DfsScope.h"
#include "DfsReslt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DfsSnapinResultManager, CDfsSnapinResultManager)
	OBJECT_ENTRY(CLSID_DfsSnapinScopeManager, CDfsSnapinScopeManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		SHFusionInitializeFromModuleID (hInstance, 2);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		SHFusionUninitialize();
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsnodes.cpp ===
/*++
Module Name:

    DfsNodes.h

Abstract:

    Contains the definition of DfsAdmin Snapin GUIDs for Nodes.

--*/

#include "stdafx.h"

GUID      s_guidDfsReplicaNodeType = {0x58268345,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};

GUID      s_guidDfsJPNodeType = {0x58268344,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};

GUID      s_guidDfsRootNodeType = {0x58268343,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};

GUID      s_guidDfsAdminNodeType = {0x58268342,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};


TCHAR*    s_tchDfsReplicaNodeType = _T("{58268345-28E8-11d1-A95B-008048918FB1}");

TCHAR*    s_tchDfsJPNodeType = _T("{58268344-28E8-11d1-A95B-008048918FB1}");

TCHAR*    s_tchDfsRootNodeType = _T("{58268343-28E8-11d1-A95B-008048918FB1}");

TCHAR*    s_tchDfsAdminNodeType = _T("{58268342-28E8-11d1-A95B-008048918FB1}");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsabout.cpp ===
/*++
Module Name:

    DfsAbout.cpp

Abstract:

    This module contains the implementation for the ISnapinAbout interface.
  Note: ISnapinAbout requires that we do a CoTaskMemAlloc for strings.

--*/


#include "stdafx.h"
#include "DfsGUI.h"
#include "Utils.h"      // For LoadResourceFromString
#include "DfsScope.h"




STDMETHODIMP 
CDfsSnapinScopeManager::GetSnapinDescription(
  OUT LPOLESTR*        o_ppaszOleString
  )
/*++

Routine Description:

  Returns a single string describing our snap-in.

Arguments:

  o_ppaszOleString  -  The pointer in which the description string is stored

Return value:

  S_OK, On success
  E_INVALIDARG, On null input parameter

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_ppaszOleString);

  CComBSTR        bstrTemp;
  HRESULT hr = LoadStringFromResource(IDS_SNAPIN_DESCRIPTION, &bstrTemp);
  RETURN_IF_FAILED(hr);  

  *o_ppaszOleString = reinterpret_cast<LPOLESTR>
          (CoTaskMemAlloc((lstrlen(bstrTemp) + 1) * sizeof(wchar_t)));
  if (*o_ppaszOleString == NULL)
      return E_OUTOFMEMORY;

  USES_CONVERSION;
  wcscpy(OUT *o_ppaszOleString, T2OLE(bstrTemp));

  return S_OK;
}



STDMETHODIMP 
CDfsSnapinScopeManager::GetProvider(
  OUT LPOLESTR*        o_lpszName
  )
/*++

Routine Description:

  Returns a single string describing this snap-in's provider, that is us.

Arguments:

  o_lpszName  -  The pointer in which the provider string is stored

Return value:

  S_OK, On success
  E_INVALIDARG, On null input parameter

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_lpszName);


                    // Read the required field from the version info struct
                    // 040904B0 - Lang-Code Page number
  HRESULT  hr = ReadFieldFromVersionInfo(
                  _T("CompanyName"),
                  o_lpszName
                  );
  RETURN_IF_FAILED(hr);  

  return S_OK;
}



STDMETHODIMP 
CDfsSnapinScopeManager::GetSnapinVersion(
  OUT LPOLESTR*        o_lpszVersion
  )
/*++

Routine Description:

  Returns a single string describing this snap-in's version number.

Arguments:

  o_lpszVersion  -  The pointer in which the version is stored

Return value:

  S_OK, On success
  E_INVALIDARG, On null input parameter

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_lpszVersion);



                    // Read the required field from the version info struct
                    // 040904B0 - Lang-Code Page number
  HRESULT  hr = ReadFieldFromVersionInfo(
                  _T("ProductVersion"),
                  o_lpszVersion
                  );
  RETURN_IF_FAILED(hr);  


  return S_OK;
}


//
// MMC makes copies of the returned icon. The snap-in can free the original
// when the ISnapinAbout interface is released.
// It is freed in ~CDfsSnapinScopeManager.
//
STDMETHODIMP 
CDfsSnapinScopeManager::GetSnapinImage(
  OUT  HICON*          o_hSnapinIcon
  )
{
  _ASSERT(o_hSnapinIcon);

  if (!m_hSnapinIcon)
  {
      m_hSnapinIcon = (HICON)LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_MAIN32x32),
                                      IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR|LR_DEFAULTSIZE); 
      if (!m_hSnapinIcon)
        return HRESULT_FROM_WIN32(GetLastError());
  }

  *o_hSnapinIcon = m_hSnapinIcon;

  return S_OK;
}


//
// MMC makes copies of the returned bitmaps. The snap-in can free the originals
// when the ISnapinAbout interface is released.
// They are freed in ~CDfsSnapinScopeManager.
//
STDMETHODIMP 
CDfsSnapinScopeManager::GetStaticFolderImage(
  OUT HBITMAP*        o_hSmallImage,   
  OUT HBITMAP*        o_hSmallImageOpen,
  OUT HBITMAP*        o_hLargeImage,   
  OUT COLORREF*       o_cMask
  )
{
    _ASSERT(o_hSmallImage);
    _ASSERT(o_hSmallImageOpen);
    _ASSERT(o_hLargeImage);
    _ASSERT(o_cMask);

    HRESULT hr = S_OK;

    do {
        if (!m_hLargeBitmap)
        {
            m_hLargeBitmap = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_MAIN32x32),
                                                IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR); 
            if (!m_hLargeBitmap)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        if (!m_hSmallBitmap)
        {
            m_hSmallBitmap = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_MAIN16x16),
                                                IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR); 
            if (!m_hSmallBitmap)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        if (!m_hSmallBitmapOpen)
        {
            m_hSmallBitmapOpen = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_MAIN16x16),
                                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR); 
            if (!m_hSmallBitmapOpen)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        *o_hLargeImage = m_hLargeBitmap;
        *o_hSmallImage = m_hSmallBitmap;
        *o_hSmallImageOpen = m_hSmallBitmapOpen;
        *o_cMask = RGB(255, 0, 255); // color of the 1st pixel: pink
    } while (0);

    return hr;
}


STDMETHODIMP 
CDfsSnapinScopeManager::ReadFieldFromVersionInfo(
  IN  LPTSTR            i_lpszField,
  OUT LPOLESTR*          o_lpszFieldValue
  )
/*++

Routine Description:

  Reads and returns a particular field from the binary's version information
  block.
  Allocates memory for the 'out' parameter using CoTaskMemAlloc.

Arguments:

  i_lpszField      -  The StringFileInfo field whose value is being queried. E.g
              ProductName, CompanyName etc.

  o_lpszFieldValue  -  The pointer in which the field value is returned
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpszField);
  RETURN_INVALIDARG_IF_NULL(o_lpszFieldValue);


  DWORD    dwVerInfoSize = 0;        // Size of version information block
  DWORD    dwIgnored = 0;          // An 'ignored' parameter, always '0'
  BOOL    bRetCode = 0;
  CComBSTR  bstrBinaryName;          // Name of our dll. %%% AC Could not find a way to get this??
  UINT    uVersionCharLen = 0;
  LPOLESTR  lpszReadFieldValue = NULL;    // Is temporary and is released as part of ver info block.
  LPVOID    lpVerInfo = NULL;        // The version information is read into this



                        // Load the dll name from resource
  HRESULT hr = LoadStringFromResource(IDS_APP_BINARY_NAME, &bstrBinaryName);
  RETURN_IF_FAILED(hr);  

                  // Get the size of the version struct
  dwVerInfoSize = ::GetFileVersionInfoSize(bstrBinaryName, &dwIgnored);
  if (dwVerInfoSize <= 0) 
  {
    return E_UNEXPECTED;
  }

  lpVerInfo = ::CoTaskMemAlloc(dwVerInfoSize);
  RETURN_OUTOFMEMORY_IF_NULL(lpVerInfo);
  

                // Read the version info resource
  bRetCode = ::GetFileVersionInfo(bstrBinaryName, dwIgnored, dwVerInfoSize, lpVerInfo);
  if (bRetCode <= 0)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_UNEXPECTED;
  }

              // First get the Language ID and page.
  DWORD    dwLangIDAndCodePage = 0;
  bRetCode = ::VerQueryValue(  (LPVOID)lpVerInfo, 
                _T("\\VarFileInfo\\Translation"),
                (LPVOID *)&lpszReadFieldValue, 
                &uVersionCharLen);

  if (bRetCode <= 0 || NULL == lpszReadFieldValue)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_UNEXPECTED;
  }

  
  dwLangIDAndCodePage = *((DWORD *)lpszReadFieldValue);
  
            // Using the LangId and the code page to form the query for Version Info.
  CComBSTR  bstrDesiredField;
  TCHAR    lpzStringOfLangIdCodePage[100];
  _stprintf(lpzStringOfLangIdCodePage, _T("%04x%04x"),LOWORD(dwLangIDAndCodePage), HIWORD(dwLangIDAndCodePage));

  bstrDesiredField = _T("\\StringFileInfo\\");
  bstrDesiredField += lpzStringOfLangIdCodePage;
  bstrDesiredField += _T("\\");
  bstrDesiredField += i_lpszField;

              // Read the Description from the versioninfo resource
  bRetCode = ::VerQueryValue(  (LPVOID)lpVerInfo, 
                bstrDesiredField,
                (LPVOID *)&lpszReadFieldValue, 
                &uVersionCharLen);
  if (bRetCode <= 0)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_UNEXPECTED;
  }

  UINT  uBufferLen = uVersionCharLen * sizeof (OLECHAR);
                // Allocate the memory and copy the structure
  *o_lpszFieldValue = (LPOLESTR)::CoTaskMemAlloc(uBufferLen);
  RETURN_OUTOFMEMORY_IF_NULL(*o_lpszFieldValue);
  
  memcpy(*o_lpszFieldValue, lpszReadFieldValue, uBufferLen);
  
  ::CoTaskMemFree(lpVerInfo);

  return S_OK;
}

STDMETHODIMP 
CDfsSnapinScopeManager::GetHelpTopic(
  OUT LPOLESTR*          o_lpszCompiledHelpFile
)
{
  if (o_lpszCompiledHelpFile == NULL)
    return E_POINTER;

  TCHAR   szSystemRoot[MAX_PATH + 1];      
  GetSystemWindowsDirectory(szSystemRoot, MAX_PATH);

  CComBSTR bstrRelHelpPath;
  HRESULT hr = LoadStringFromResource(IDS_MMC_HELP_FILE_PATH, &bstrRelHelpPath);
  if (FAILED(hr))
    return hr;

  *o_lpszCompiledHelpFile = reinterpret_cast<LPOLESTR>
          (CoTaskMemAlloc((_tcslen(szSystemRoot) + _tcslen(bstrRelHelpPath) + 1) * sizeof(wchar_t)));

  if (*o_lpszCompiledHelpFile == NULL)
    return E_OUTOFMEMORY;

  USES_CONVERSION;

  wcscpy(*o_lpszCompiledHelpFile, T2OLE(szSystemRoot));
  wcscat(*o_lpszCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)bstrRelHelpPath));

  return S_OK;
}

STDMETHODIMP 
CDfsSnapinScopeManager::GetLinkedTopics(
  OUT LPOLESTR*          o_lpszCompiledHelpFiles
)
{
  if (o_lpszCompiledHelpFiles == NULL)
    return E_POINTER;

  TCHAR   szSystemRoot[MAX_PATH + 1];      
  GetSystemWindowsDirectory(szSystemRoot, MAX_PATH);

  CComBSTR bstrRelHelpPath;
  HRESULT hr = LoadStringFromResource(IDS_LINKED_HELP_FILE_PATH, &bstrRelHelpPath);
  if (FAILED(hr))
    return hr;

  *o_lpszCompiledHelpFiles = reinterpret_cast<LPOLESTR>
          (CoTaskMemAlloc((_tcslen(szSystemRoot) + _tcslen(bstrRelHelpPath) + 1) * sizeof(wchar_t)));

  if (*o_lpszCompiledHelpFiles == NULL)
    return E_OUTOFMEMORY;

  USES_CONVERSION;

  wcscpy(*o_lpszCompiledHelpFiles, T2OLE(szSystemRoot));
  wcscat(*o_lpszCompiledHelpFiles, T2OLE((LPTSTR)(LPCTSTR)bstrRelHelpPath));

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsreslt.h ===
/*++
Module Name:

    DfsReslt.h

Abstract:

    This module contains the declaration for CDfsSnapinResultManager.

--*/


#ifndef __DFSRESLT_H_
#define __DFSRESLT_H_


#include "resource.h"       // main symbols
#include <mmc.h>
#include "mmcdispl.h"


class ATL_NO_VTABLE CDfsSnapinResultManager : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsSnapinResultManager, &CLSID_DfsSnapinResultManager>,
    public IComponent,
    public IExtendContextMenu,
    public IExtendControlbar
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DFSSNAPINRESULTMANAGER)

BEGIN_COM_MAP(CDfsSnapinResultManager)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
END_COM_MAP()



friend class CDfsSnapinScopeManager;
    


CDfsSnapinResultManager():m_pScopeManager(NULL),
                          m_pSelectScopeDisplayObject(NULL) 
    {
    }

    virtual ~CDfsSnapinResultManager()
    {
    }

// IComponent Methods
    STDMETHOD(Initialize)(
        IN LPCONSOLE                i_lpConsole
        );
    
    STDMETHOD(Notify)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN MMC_NOTIFY_TYPE            i_Event, 
        IN LPARAM                        i_lArg, 
        IN LPARAM                        i_lParam
        );
    
    STDMETHOD(Destroy)(
        IN MMC_COOKIE                        i_lCookie
        );
    
    STDMETHOD(GetResultViewType)(
        IN MMC_COOKIE                        i_lCookie,  
        OUT LPOLESTR*                o_ppViewType, 
        OUT LPLONG                    o_lpViewOptions
        );
    
    STDMETHOD(QueryDataObject)(
        IN MMC_COOKIE                        i_lCookie, 
        IN DATA_OBJECT_TYPES        i_DataObjectType, 
        OUT LPDATAOBJECT*            o_ppDataObject
        );
    
    STDMETHOD(GetDisplayInfo)(
        IN OUT RESULTDATAITEM*        io_pResultDataItem
        );
    
    STDMETHOD(CompareObjects)(
        IN LPDATAOBJECT                i_lpDataObjectA, 
        IN LPDATAOBJECT                i_lpDataObjectB
        );



// IExtendContextMenu methods.
    // For adding context menu items
    STDMETHOD (AddMenuItems)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
        IN LPLONG                    i_lpInsertionAllowed
        );



    // For taking action on a context menu selection.
    STDMETHOD (Command)(
        IN LONG                        i_lCommandID, 
        IN LPDATAOBJECT                i_lpDataObject
        );



// IExtendControlbar methods
    // Used to set the control bar
    STDMETHOD (SetControlbar)( 
        IN LPCONTROLBAR                i_pControlbar  
        );



  // A notify to the control bar
    STDMETHOD (ControlbarNotify)( 
        IN MMC_NOTIFY_TYPE            i_Event, 
        IN LPARAM                        i_lArg, 
        IN LPARAM                        i_lParam
        );



// helpers
private:
    void DetachAllToolbars();

   
    // Handling the Notify event for Select
    STDMETHOD(DoNotifySelect)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN BOOL                        i_bSelect,
        IN HSCOPEITEM                i_hParent                                       
        );


    // Handling the Notify event for Show
    STDMETHOD(DoNotifyShow)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN BOOL                        i_bShow,
        IN HSCOPEITEM                i_hParent                                       
        );


    // Handling the notify method for MMCN_DBLCLICK
    STDMETHOD(DoNotifyDblClick)(
        IN LPDATAOBJECT        i_lpDataObject
        );

    // Handling the notify method for MMCN_DELETE
    STDMETHOD(DoNotifyDelete)(
        IN LPDATAOBJECT        i_lpDataObject
        );

    // Handling the notify method for MMCN_CONTEXTHELP
    STDMETHOD(DfsHelp)();

    STDMETHOD(DoNotifyViewChange)(
        IN LPDATAOBJECT     i_lpDataObject,
        IN LONG_PTR         i_lArg,
        IN LONG_PTR         i_lParam
        );

    STDMETHOD(DoNotifyRefresh)(
        IN LPDATAOBJECT        i_lpDataObject
        );

// Data members
private:
    CDfsSnapinScopeManager*     m_pScopeManager;    // The corresponding Scope Manager object
    CComPtr<IHeaderCtrl2>       m_pHeader;            // The header control for the result view
    CComPtr<IResultData>        m_pResultData;
    CComPtr<IConsoleVerb>       m_pConsoleVerb;        // Sets the console verb
    CComPtr<IConsole2>          m_pConsole;
    CComPtr<IControlbar>        m_pControlbar;        // Callback used to handle toolbars, etc
    CMmcDisplay*                m_pSelectScopeDisplayObject;    // The CMmcDisplay pointer of the scope pane items
                                                                // That is currently selected in the view.
    CComPtr<IToolbar>           m_pMMCAdminToolBar;
    CComPtr<IToolbar>           m_pMMCRootToolBar;
    CComPtr<IToolbar>           m_pMMCJPToolBar;
    CComPtr<IToolbar>           m_pMMCReplicaToolBar;
};

#endif //__DFSRESLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsscope.cpp ===
/*++
Module Name:

    DfsScope.cpp

Abstract:

    This module contains the implementation for CDfsSnapinScopeManager. 
	Most of the method of the class CDfsSnapinScopeManager are in other files.
	Only the constructor  is here

--*/


#include "stdafx.h"
#include "DfsGUI.h"
#include "DfsScope.h"
#include "MmcAdmin.h"
#include "utils.h"

CDfsSnapinScopeManager::CDfsSnapinScopeManager(
	)
{
    m_hLargeBitmap = NULL;
    m_hSmallBitmap = NULL;
    m_hSmallBitmapOpen = NULL;
    m_hSnapinIcon = NULL;

	m_pMmcDfsAdmin = new CMmcDfsAdmin( this );
}


CDfsSnapinScopeManager::~CDfsSnapinScopeManager(
)
{
	m_pMmcDfsAdmin->Release();

    if (m_hLargeBitmap)
    {
        DeleteObject(m_hLargeBitmap);
        m_hLargeBitmap = NULL;
    }
    if (m_hSmallBitmap)
    {
        DeleteObject(m_hSmallBitmap);
        m_hSmallBitmap = NULL;
    }
    if (m_hSmallBitmapOpen)
    {
        DeleteObject(m_hSmallBitmapOpen);
        m_hSmallBitmapOpen = NULL;
    }
    if (m_hSnapinIcon)
    {
        DestroyIcon(m_hSnapinIcon);
        m_hSnapinIcon = NULL;
    }
}

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   sizeof(x)/sizeof(x[0])
#endif

typedef struct _RGSMAP {
  LPCTSTR szKey;
  UINT    idString;
} RGSMAP;

RGSMAP g_aRgsSnapinRegs[] = {
  OLESTR("DfsAppName"), IDS_APPLICATION_NAME,
  OLESTR("DfsAppProvider"), IDS_SNAPINABOUT_PROVIDER,
  OLESTR("DfsAppVersion"), IDS_SNAPINABOUT_VERSION
};

HRESULT
CDfsSnapinScopeManager::UpdateRegistry(BOOL bRegister)
{
  HRESULT hr = S_OK;
  struct _ATL_REGMAP_ENTRY *pMapEntries = NULL;
  int n = ARRAYSIZE(g_aRgsSnapinRegs);
  int i = 0;

  if (n > 0)
  {
    // allocate 1 extra entry that is set to {NULL, NULL}
    pMapEntries = (struct _ATL_REGMAP_ENTRY *)calloc(n+1, sizeof(struct _ATL_REGMAP_ENTRY));
    if (!pMapEntries)
      return E_OUTOFMEMORY;

    CComBSTR  bstrString;
    for (i=0; i<n; i++)
    {
      pMapEntries[i].szKey = g_aRgsSnapinRegs[i].szKey;

      hr = LoadStringFromResource(g_aRgsSnapinRegs[i].idString, &bstrString);
      if (FAILED(hr))
        break;

      pMapEntries[i].szData = T2OLE(bstrString.Detach());
    }
  }

  if (SUCCEEDED(hr))
    hr = _Module.UpdateRegistryFromResource(IDR_DFSSNAPINSCOPEMANAGER, bRegister, pMapEntries);

  // free resource strings
  if (n > 0)
  {
    for (i=0; i<n; i++)
    {
      if (pMapEntries[i].szData)
        SysFreeString( const_cast<LPTSTR>(OLE2CT(pMapEntries[i].szData)) );
    }

    free(pMapEntries);
  }

  return hr;
}

STDMETHODIMP CDfsSnapinScopeManager::CreatePropertyPages(
	IN LPPROPERTYSHEETCALLBACK				i_lpPropSheetCallback,
    IN LONG_PTR									i_lhandle,
	IN LPDATAOBJECT							i_lpIDataObject
	)
/*++

Routine Description:

	Called to create PropertyPages for the given node.
	The fact that this has been called implies the display object has a 
	page to display.


Arguments:

	i_lpPropSheetCallback	-	The callback used to add pages.
	i_lhandle				-	The handle used for notification
    i_lpDataObject			-	The IDataObject pointer which is used to get 
								the DisplayObject.


Return value:

    S_OK, if successful.
	E_INVALIDARG, if one of the arguments is null.
	Any HRESULT value other than S_OK return by the snap-in.

--*/
{
	if (NULL == i_lpIDataObject)
		return S_OK;

	RETURN_INVALIDARG_IF_NULL(i_lpPropSheetCallback);
    RETURN_INVALIDARG_IF_NULL(i_lhandle);

    HRESULT					hr = E_UNEXPECTED;
	CMmcDisplay*			pCMmcDisplayObj = NULL;

											// Get the display object from IDataObject
	hr = GetDisplayObject(i_lpIDataObject, &pCMmcDisplayObj);
	RETURN_IF_FAILED(hr);

							// Use the virtual method CreatePropertyPages in the display object
	hr = pCMmcDisplayObj->CreatePropertyPages(i_lpPropSheetCallback, i_lhandle);
	RETURN_IF_FAILED(hr);

	return S_OK;
}




STDMETHODIMP CDfsSnapinScopeManager::QueryPagesFor(
	IN LPDATAOBJECT							i_lpIDataObject
	)
/*++

Routine Description:

	Called by the console to decide whether there are PropertyPages 
	for the given node that should be displayed.
	We check, if the context is for scope or result(thereby skipping
	node manager) and if it is pass on the call to the Display object


Arguments:

    i_lpDataObject			-	The IDataObject pointer which is used to get 
								the DisplayObject.


Return value:

    S_OK,		if we want pages to be displayed. This is decided by the display
				object
	S_FALSE,	if we don't want pages to be display.

	E_INVALIDARG, if one of the arguments is null.
	Any HRESULT value other than S_OK return by the snap-in.

--*/
{
	if (NULL == i_lpIDataObject)
		return S_OK;

    HRESULT					hr = E_UNEXPECTED;
    CMmcDisplay*            pMmcDisplay = NULL;
    CMmcDisplay*            pCMmcDisplayObj = NULL;

                                            // Get the display object from IDataObject
    hr = GetDisplayObject(i_lpIDataObject, &pCMmcDisplayObj);
    RETURN_IF_FAILED(hr);

	return pCMmcDisplayObj->QueryPagesFor();
}




STDMETHODIMP 
CDfsSnapinScopeManager::DoNotifyPropertyChange(
	IN LPDATAOBJECT				i_lpDataObject, 
	IN LPARAM						i_lparam									   
	)
/*++

Routine Description:

	Take action on notify event MMCN_PROPERTY_CHANGE.

Arguments:

    i_lpDataObject	-	The IDataObject pointer. This is NULL here!!
	i_lparam		-	Whatever was sent to Notify. This is the display object
	
--*/
{
	RETURN_INVALIDARG_IF_NULL(i_lparam);


	HRESULT				hr = E_UNEXPECTED;
	CMmcDisplay*		pCMmcDisplayObj = (CMmcDisplay*)i_lparam;


										// Pass the notification to the display object.
	hr = pCMmcDisplayObj->PropertyChanged();
	RETURN_IF_FAILED(hr);


	return S_OK;
}


STDMETHODIMP 
CDfsSnapinScopeManager::GetWatermarks( 
	IN LPDATAOBJECT					pDataObject,
    IN HBITMAP*						lphWatermark,
    IN HBITMAP*						lphHeader,
    IN HPALETTE*					lphPalette,
    IN BOOL*						bStretch
	)
{
/*++

Routine Description:

	Gives the water mark bitmaps to mmc to display for new style pages.


Arguments:

	lphWatermark	-	Bitmap mark for body
	
	lphHeader		-	Bitmap for header

	lphPalette		-	Pallete

	bStretch		-	Strech / not?

Return value:

    S_OK, if successful.
	HRESULT sent by methods called, if it is not S_OK.
--*/

										// Load the bitmap for bofy water mark.
    *lphWatermark = (HBITMAP)LoadImage (
										_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDB_CREATE_DFSROOT_WATERMARK), 
										IMAGE_BITMAP, 
										0, 
										0, 
										LR_SHARED | LR_CREATEDIBSECTION
										);
	if(NULL == *lphWatermark)
	{
		return E_UNEXPECTED;
	}

											// Load the bitmap for header.
    *lphHeader = (HBITMAP)LoadImage (
										_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDB_CREATE_DFSROOT_HEADER), 
										IMAGE_BITMAP, 
										0, 
										0, 
										LR_SHARED | LR_CREATEDIBSECTION
										);
	if(NULL == *lphHeader)
	{
		return E_UNEXPECTED;
	}

											// Do not stretch.
	*bStretch = FALSE;
	*lphPalette = NULL;						// Defaukt color palette.

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsreslt.cpp ===
/*++
Module Name:

    MmcAdmin.cpp

Abstract:

    This module contains the part of the declaration for CDfsSnapinResultManager. 

--*/



#include "stdafx.h"
#include "DfsGUI.h"
#include "DfsReslt.h"
#include "DfsScope.h"      // The CDfsSnapinScopeManager class




STDMETHODIMP CDfsSnapinResultManager :: AddMenuItems
(
  IN LPDATAOBJECT        i_lpDataObject, 
  IN LPCONTEXTMENUCALLBACK  i_lpContextMenuCallback, 
  IN LPLONG          i_lpInsertionAllowed
)
/*++

Routine Description:

This routine adds the appropriate context menu using the ContextMenuCallback provided.

Arguments:

    i_lpDataObject - The dataobject used to identify the node.
    i_lpContextMenuCallback - A callback(function pointer) that is used to add the menu items
    i_lpInsertionAllowed - Specifies what menus can be added and where they can be added.

--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpDataObject);
  RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);
  RETURN_INVALIDARG_IF_NULL(i_lpInsertionAllowed);

  if (DOBJ_CUSTOMOCX == i_lpDataObject)
    return S_OK;

  return m_pScopeManager->AddMenuItems(i_lpDataObject, i_lpContextMenuCallback, i_lpInsertionAllowed);
}

STDMETHODIMP 
CDfsSnapinResultManager::Command(
  IN LONG           i_lCommandID, 
  IN LPDATAOBJECT   i_lpDataObject
)
/*++

Routine Description:

Action to be taken on a context menu selection or click is takes place.

Arguments:

  i_lpDataObject - The dataobject used to identify the node.
  i_lCommandID - The Command ID of the menu for which action has to be taken

--*/

{
  RETURN_INVALIDARG_IF_NULL(i_lpDataObject);

  return m_pScopeManager->Command(i_lCommandID, i_lpDataObject);
}


STDMETHODIMP 
CDfsSnapinResultManager::SetControlbar( 
  IN LPCONTROLBAR        i_pControlbar
  )
/*++

Routine Description:

  Called by MMC to allow us to set the IControlbar interface pointer

Arguments:

  i_pControlbar - The IControlbar interface pointer. Note, can be 0.

--*/
{
    if (!i_pControlbar)    // We are shutting down
        m_pControlbar.Release();
    else
        m_pControlbar = i_pControlbar;

    return S_OK;
}

void
CDfsSnapinResultManager::DetachAllToolbars()
{
    if (m_pMMCAdminToolBar)
        m_pControlbar->Detach(m_pMMCAdminToolBar);
    if (m_pMMCRootToolBar)
        m_pControlbar->Detach(m_pMMCRootToolBar);
    if (m_pMMCJPToolBar)
        m_pControlbar->Detach(m_pMMCJPToolBar);
    if (m_pMMCReplicaToolBar)
        m_pControlbar->Detach(m_pMMCReplicaToolBar);
}

STDMETHODIMP 
CDfsSnapinResultManager::ControlbarNotify( 
  IN MMC_NOTIFY_TYPE        i_Event, 
  IN LPARAM              i_lArg, 
  IN LPARAM              i_lParam
  )
/*++

Routine Description:

  Called by MMC to notify the toolbar about an event.
  This can be selection\disselection of node, click on a toolbar, etc.

Arguments:

  i_Event    -  The event that occurred.
  i_lArg    -  The argument for the event. Depends on the event
  i_lParam  -  The parameter for the event. Depends on the event

--*/
{
    HRESULT         hr = S_OK;
    LPDATAOBJECT    p_DataObject = NULL;
    CMmcDisplay*    pCMmcDisplayObj = NULL;

    switch (i_Event)        // Decide which method to call of the display object
    {
    case MMCN_BTN_CLICK:    // Click on a toolbar
    {
        p_DataObject = (LPDATAOBJECT)i_lArg;  

                      // Get the display object from IDataObject
        hr = m_pScopeManager->GetDisplayObject(p_DataObject, &pCMmcDisplayObj);
        RETURN_IF_FAILED(hr);
                      // Ask the display object to handle click on the toolbar
        hr = pCMmcDisplayObj->ToolbarClick(m_pControlbar, i_lParam);
        RETURN_IF_FAILED(hr);
        break;
    }
    case MMCN_SELECT:      // A node is being selected\deselected
    {
        BOOL    bSelect = (BOOL) HIWORD(i_lArg);
        p_DataObject = (LPDATAOBJECT)i_lParam;

        if (DOBJ_CUSTOMOCX == p_DataObject)
            break;
                      // Get the display object from IDataObject
        hr = m_pScopeManager->GetDisplayObject(p_DataObject, &pCMmcDisplayObj);
        RETURN_IF_FAILED(hr);

                  // Create the appropriate tool bar if it is
                  // Not created.
                  // Then ask the display object to handle selection
        //
        // Update the custom toolbars.
        // On select, it should detach unused toolbars and attach new ones as needed.
        // On deselect, to minimize flashing, it should not detach toolbars; it is 
        // best to disable them, but doing nothing on deselect is also acceptable. 
        //
        DISPLAY_OBJECT_TYPE    DisplayObType = pCMmcDisplayObj->GetDisplayObjectType();
        switch (DisplayObType)
        {
        case DISPLAY_OBJECT_TYPE_ADMIN:
            if (!m_pMMCAdminToolBar)
            {
                hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCAdminToolBar);
                RETURN_IF_FAILED(hr);
            }

            if (bSelect)
            {
                DetachAllToolbars();
                m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pMMCAdminToolBar);
            }

            hr = pCMmcDisplayObj->ToolbarSelect(i_lArg, m_pMMCAdminToolBar);
            break;
        case DISPLAY_OBJECT_TYPE_ROOT:
            if (!m_pMMCRootToolBar)
            {
                hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCRootToolBar);
                RETURN_IF_FAILED(hr);
            }

            if (bSelect)
            {
                DetachAllToolbars();
                m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pMMCRootToolBar);
            }

            hr = pCMmcDisplayObj->ToolbarSelect(i_lArg, m_pMMCRootToolBar);
            break;
        case DISPLAY_OBJECT_TYPE_JUNCTION:
            if (!m_pMMCJPToolBar)
            {
                hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCJPToolBar);
                RETURN_IF_FAILED(hr);
            }

            if (bSelect)
            {
                DetachAllToolbars();
                m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pMMCJPToolBar);
            }

            hr = pCMmcDisplayObj->ToolbarSelect(i_lArg, m_pMMCJPToolBar);
            break;
        case DISPLAY_OBJECT_TYPE_REPLICA:
            if (!m_pMMCReplicaToolBar)
            {
                hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCReplicaToolBar);
                RETURN_IF_FAILED(hr);
            }

            if (bSelect)
            {
                DetachAllToolbars();
                m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pMMCReplicaToolBar);
            }

            hr = pCMmcDisplayObj->ToolbarSelect(i_lArg, m_pMMCReplicaToolBar);
            break;
        }

        break;
    }

    default:
        break;
  }  // switch()

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfshelp.h ===
#ifndef __DFSHELP_H_
#define __DFSHELP_H_

#define DFS_CTX_HELP_FILE        _T("dfs.hlp")

#define IDH_ADDREP_DFSLINKPATH          70005000
#define IDH_ADDREP_EDITNETPATH          70005001
#define IDH_ADDREP_BUTTONNETBROWSE      70005002
#define IDH_ADDREP_REPLICATE            70005003
#define IDH_ADDTODFS_EDITCHLDNODE       70005025
#define IDH_ADDTODFS_DFSLINKPATH        70005026
#define IDH_ADDTODFS_EDITNETPATH        70005027
#define IDH_ADDTODFS_BUTTONNETBROWSE    70005028
#define IDH_ADDTODFS_EDITCOMMENT        70005029
#define IDH_ADDTODFS_EDITTIME           70005030
#define IDH_DLGCONNECTTO_EditDfsRoot    70005050
#define IDH_DLGCONNECTTO_TREEDFSRoots   70005051
#define IDH_FILTERDFSLINKS_MAXLIMIT     70005200
#define IDH_FILTERDFSLINKS_RADIO_NO     70005201
#define IDH_FILTERDFSLINKS_RADIO_YES    70005202
#define IDH_FILTERDFSLINKS_FILTER_TYPE  70005203
#define IDH_FILTERDFSLINKS_FILTER       70005204
#define IDH_PROP__REPLICA_SET_NAME      70005100
#define IDH_PROP_REFFERAL_TIME          70005102
#define IDH_PROP_REPLICA_SET_COMMENT    70005101
#define IDH_FRSPROP_FILEFILTER          70005206
#define IDH_FRSPROP_FILEFILTER_EDIT     70005207
#define IDH_FRSPROP_DIRFILTER           70005208
#define IDH_FRSPROP_DIRFILTER_EDIT      70005209
#define IDH_FRSPROP_PRIMARYMEMBER       70005210
#define IDH_FRSPROP_TOPOLOGYPREF        70005211
#define IDH_FRSPROP_HUBSERVER           70005212
#define IDH_FRSPROP_RESETSCHEDULE       70005213
#define IDH_FRSPROP_CUSTOMIZE           70005214
#define IDH_FRS_CUSTOP_TOPOLOGYPREF     70005215
#define IDH_FRS_CUSTOP_HUBSERVER_LABEL  70005216
#define IDH_FRS_CUSTOP_HUBSERVER        70005217
#define IDH_FRS_CUSTOP_CONNECTIONS      70005218
#define IDH_FRS_CUSTOP_CONNECTIONS_NEW  70005219
#define IDH_FRS_CUSTOP_CONNECTIONS_DELETE   70005220
#define IDH_FRS_CUSTOP_SCHEDULE         70005221
#define IDH_FRS_NEWCONN_FROM            70005222
#define IDH_FRS_NEWCONN_TO              70005223
#define IDH_PUBPROP_PUBLISH             70005224
#define IDH_PUBPROP_UNCPATH             70005225
#define IDH_PUBPROP_DESCRIPTION         70005226
#define IDH_PUBPROP_KEYWORDS            70005227
#define IDH_PUBPROP_KEYWORDS_EDIT       70005228
#define IDH_PUBPROP_MANAGEDBY           70005229
#define IDH_MVSTRINGEDIT_STRING         70005230
#define IDH_MVSTRINGEDIT_LIST           70005231
#define IDH_MVSTRINGEDIT_ADD            70005232
#define IDH_MVSTRINGEDIT_REMOVE         70005233
#define IDH_MROOTS_LIST                 -1

const DWORD g_aHelpIDs_IDD_ADDREP[]=
{
    IDC_EDIT_ADDREP_DFSLINK_PATH,IDH_ADDREP_DFSLINKPATH,
    IDC_EDITNETPATH,IDH_ADDREP_EDITNETPATH,
    IDC_BUTTONNETBROWSE,IDH_ADDREP_BUTTONNETBROWSE,
    IDC_ADDREP_REPLICATE,IDH_ADDREP_REPLICATE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADDTODFS[]=
{
    IDC_EDITCHLDNODE,IDH_ADDTODFS_EDITCHLDNODE,
    IDC_EDIT_ADDLINK_DFSLINK_PATH,IDH_ADDTODFS_DFSLINKPATH,
    IDC_EDITNETPATH,IDH_ADDTODFS_EDITNETPATH,
    IDC_BUTTONNETBROWSE,IDH_ADDTODFS_BUTTONNETBROWSE,
    IDC_EDITCOMMENT,IDH_ADDTODFS_EDITCOMMENT,
    IDC_EDITTIME,IDH_ADDTODFS_EDITTIME,
    0,0
};

const DWORD g_aHelpIDs_IDD_DLGCONNECTTO[]=
{
    IDC_TREEDFSRoots,IDH_DLGCONNECTTO_TREEDFSRoots,
    IDC_EditDfsRoot,IDH_DLGCONNECTTO_EditDfsRoot,
    0,0
};

const DWORD g_aHelpIDs_IDD_FILTERDFSLINKS[]=
{
    IDC_FILTERDFSLINKS_MAXLIMIT,IDH_FILTERDFSLINKS_MAXLIMIT,
    IDC_FILTERDFSLINKS_RADIO_NO,IDH_FILTERDFSLINKS_RADIO_NO,
    IDC_FILTERDFSLINKS_RADIO_YES,IDH_FILTERDFSLINKS_RADIO_YES,
    IDC_FILTERDFSLINKS_FILTER_TYPE,IDH_FILTERDFSLINKS_FILTER_TYPE,
    IDC_FILTERDFSLINKS_FILTER_LABEL,-1,
    IDC_FILTERDFSLINKS_FILTER,IDH_FILTERDFSLINKS_FILTER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_JP_PROP[]=
{
    IDC_REPLICA_SET_NAME,IDH_PROP__REPLICA_SET_NAME,
    IDC_REPLICA_SET_COMMENT,IDH_PROP_REPLICA_SET_COMMENT,
    IDC_REFFERAL_TIME,IDH_PROP_REFFERAL_TIME,
    0,0
};

const DWORD g_aHelpIDs_IDD_FRS_PROP[]=
{
    IDC_FRSPROP_FILEFILTER, IDH_FRSPROP_FILEFILTER,
    IDC_FRSPROP_FILEFILTER_EDIT, IDH_FRSPROP_FILEFILTER_EDIT,
    IDC_FRSPROP_DIRFILTER, IDH_FRSPROP_DIRFILTER,
    IDC_FRSPROP_DIRFILTER_EDIT, IDH_FRSPROP_DIRFILTER_EDIT,
    IDC_FRSPROP_PRIMARYMEMBER, IDH_FRSPROP_PRIMARYMEMBER,
    IDC_FRSPROP_TOPOLOGYPREF, IDH_FRSPROP_TOPOLOGYPREF,
    IDC_FRSPROP_HUBSERVER, IDH_FRSPROP_HUBSERVER,
    IDC_FRSPROP_RESETSCHEDULE, IDH_FRSPROP_RESETSCHEDULE,
    IDC_FRSPROP_CUSTOMIZE, IDH_FRSPROP_CUSTOMIZE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FRS_CUSTOP[]=
{
    IDC_FRS_CUSTOP_TOPOLOGYPREF, IDH_FRS_CUSTOP_TOPOLOGYPREF,
    IDC_FRS_CUSTOP_HUBSERVER_LABEL, IDH_FRS_CUSTOP_HUBSERVER_LABEL,
    IDC_FRS_CUSTOP_HUBSERVER, IDH_FRS_CUSTOP_HUBSERVER,
    IDC_FRS_CUSTOP_CONNECTIONS, IDH_FRS_CUSTOP_CONNECTIONS,
    IDC_FRS_CUSTOP_CONNECTIONS_NEW, IDH_FRS_CUSTOP_CONNECTIONS_NEW,
    IDC_FRS_CUSTOP_CONNECTIONS_DELETE, IDH_FRS_CUSTOP_CONNECTIONS_DELETE,
    IDC_FRS_CUSTOP_SCHEDULE, IDH_FRS_CUSTOP_SCHEDULE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FRS_NEWCONN[]=
{
    IDC_FRS_NEWCONN_FROM, IDH_FRS_NEWCONN_FROM,
    IDC_FRS_NEWCONN_TO, IDH_FRS_NEWCONN_TO,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PUBLISH_PROP[]=
{
    IDC_PUBPROP_PUBLISH, IDH_PUBPROP_PUBLISH,
    IDC_PUBPROP_UNCPATH, IDH_PUBPROP_UNCPATH,
    IDC_PUBPROP_UNCPATH_LABEL, -1,
    IDC_PUBPROP_DESCRIPTION, IDH_PUBPROP_DESCRIPTION,
    IDC_PUBPROP_DESCRIPTION_LABEL, -1,
    IDC_PUBPROP_KEYWORDS, IDH_PUBPROP_KEYWORDS,
    IDC_PUBPROP_KEYWORDS_LABEL, -1,
    IDC_PUBPROP_KEYWORDS_EDIT, IDH_PUBPROP_KEYWORDS_EDIT,
    IDC_PUBPROP_MANAGEDBY, IDH_PUBPROP_MANAGEDBY,
    IDC_PUBPROP_MANAGEDBY_LABEL, -1,
    IDC_PUBPROP_ERROR, -1,
    0, 0
};

const DWORD g_aHelpIDs_IDD_MVSTRINGEDIT[]=
{
    IDC_MVSTRINGEDIT_STRING, IDH_MVSTRINGEDIT_STRING,
    IDC_MVSTRINGEDIT_LIST, IDH_MVSTRINGEDIT_LIST,
    IDC_MVSTRINGEDIT_ADD, IDH_MVSTRINGEDIT_ADD,
    IDC_MVSTRINGEDIT_REMOVE, IDH_MVSTRINGEDIT_REMOVE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_MROOTS[]=
{
    IDC_MROOTS_LIST, IDH_MROOTS_LIST,
    0, 0
};

#endif // __DFSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfsscope.h ===
/*++
Module Name:

    DfsScope.h

Abstract:

    This module contains the declaration for CDfsSnapinScopeManager.
    This class implements IComponentData and other related interfaces

--*/


#ifndef __DFSSCOPE_H_
#define __DFSSCOPE_H_

#include "resource.h"       // main symbols
#include "MMCAdmin.h"        // For CMMCDfsAdmin


/////////////////////////////////////////////////////////////////////////////
// CDfsSnapinScopeManager
class ATL_NO_VTABLE CDfsSnapinScopeManager : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsSnapinScopeManager, &CLSID_DfsSnapinScopeManager>,
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStream,
    public ISnapinAbout,
    public ISnapinHelp2,
    public IExtendPropertySheet2
{
public:

//DECLARE_REGISTRY_RESOURCEID(IDR_DFSSNAPINSCOPEMANAGER)
  static HRESULT UpdateRegistry(BOOL bRegister);

BEGIN_COM_MAP(CDfsSnapinScopeManager)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinAbout)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
END_COM_MAP()

    CDfsSnapinScopeManager();

    virtual ~CDfsSnapinScopeManager();

//IComponentData Methods
    STDMETHOD(Initialize)(
            IN LPUNKNOWN                i_pUnknown
            );

    STDMETHOD(CreateComponent)(
            OUT LPCOMPONENT*            o_ppComponent
            );

    STDMETHOD(Notify)( 
            IN LPDATAOBJECT                i_lpDataObject, 
            IN MMC_NOTIFY_TYPE            i_Event, 
            IN LPARAM                        i_lArg, 
            IN LPARAM                        i_lParam
            );

    STDMETHOD(Destroy)();

    STDMETHOD(QueryDataObject)(
            IN MMC_COOKIE                        i_lCookie, 
            IN DATA_OBJECT_TYPES        i_DataObjectType, 
            OUT LPDATAOBJECT*            o_ppDataObject
            );

    STDMETHOD(GetDisplayInfo)(
            IN OUT SCOPEDATAITEM*        io_pScopeDataItem
            );       

    STDMETHOD(CompareObjects)(
            IN LPDATAOBJECT lpDataObjectA, 
            IN LPDATAOBJECT lpDataObjectB
            );



// IExtendContextMenu methods. Definition in ICtxMenu.cpp
    STDMETHOD (AddMenuItems)(
            IN LPDATAOBJECT                i_lpDataObject, 
            IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
            IN LPLONG                    i_lpInsertionAllowed
        );

    STDMETHOD (Command)(
            IN LONG                        i_lCommandID, 
            IN LPDATAOBJECT                i_lpDataObject
        );



// IPersistStream Implementation
    STDMETHOD (GetClassID)(
            OUT struct _GUID*            o_pClsid
        );
    
    // Use to check if the object has been changed since last save
    STDMETHOD (IsDirty)(
        );
    
    // Use to load the snap-in from a saved file
    STDMETHOD (Load)(
            IN LPSTREAM                    i_pStream
        );
    
    // Use to save the snap-in to a file
    STDMETHOD (Save)(
            OUT LPSTREAM                o_pStream,
            IN    BOOL                    i_bClearDirty
        );
    
    STDMETHOD (GetSizeMax)(
            OUT ULARGE_INTEGER*         o_pulSize
        );

// ISnapinAbout methods
    STDMETHOD (GetSnapinDescription)(
        OUT LPOLESTR*            o_lpszDescription
        );


    STDMETHOD (GetProvider)(
        OUT LPOLESTR*            o_lpszName
        );


    STDMETHOD (GetSnapinVersion)(
        OUT LPOLESTR*            o_lpszVersion
        );


    STDMETHOD (GetSnapinImage)(
        OUT    HICON*                o_hSnapIcon
        );


    STDMETHOD (GetStaticFolderImage)(
        OUT HBITMAP*                o_hSmallImage,   
        OUT HBITMAP*                o_hSmallImageOpen,
        OUT HBITMAP*                o_hLargeImage,   
        OUT COLORREF*                o_cMask
        );


  // ISnapinHelp2
    STDMETHOD (GetHelpTopic)(
      OUT LPOLESTR*          o_lpszCompiledHelpFile
    );

    STDMETHOD (GetLinkedTopics)(
      OUT LPOLESTR*          o_lpszCompiledHelpFiles
    );

// IExtendPropertySheet

    // Called to create the pages
    STDMETHOD (CreatePropertyPages)( 
        IN LPPROPERTYSHEETCALLBACK        i_lpPropSheetProvider,
        IN LONG_PTR                            i_lhandle,
        IN LPDATAOBJECT                    i_lpIDataObject
        );


    // Called to check, if the snapin was to display the pages
    STDMETHOD (QueryPagesFor)( 
        IN LPDATAOBJECT                    i_lpIDataObject
        );

    // Called to get water mar images for property pages.
    STDMETHOD (GetWatermarks)( 
        IN LPDATAOBJECT                    pDataObject,
        IN HBITMAP*                        lphWatermark,
        IN HBITMAP*                        lphHeader,
        IN HPALETTE*                    lphPalette,
        IN BOOL*                        bStretch
        );
    

    // Utility functions
public:
    // Get the Display Object from the IDataObject
    STDMETHOD(GetDisplayObject)(
        IN LPDATAOBJECT                    i_lpDataObject, 
        OUT CMmcDisplay**                o_ppMmcDisplay
        );


private:
    // Handle the notify event for MMCN_EXPAND
    STDMETHOD(DoNotifyExpand)(
        IN LPDATAOBJECT                    i_lpDataObject, 
        IN BOOL                            i_bExpanding,
        IN HSCOPEITEM                    i_hParent                                       
        );



    // Handled the notify event for MMCN_DELETE
    STDMETHOD(DoNotifyDelete)(
        IN LPDATAOBJECT                    i_lpDataObject
        );



    // Handle the notify for MMCN_PROPERTY_CHANGE
    STDMETHOD(DoNotifyPropertyChange)(
        IN LPDATAOBJECT                    i_lpDataObject, 
        IN LPARAM                            i_lparam                                       
        );



    // Handle the command line parameters
    STDMETHOD(HandleCommandLineParameters)(
        );



    // Read a particular field from the version information block.
    STDMETHOD(ReadFieldFromVersionInfo)(
        IN    LPTSTR                        i_lpszField,
        OUT LPOLESTR*                    o_lpszFieldValue
        );


protected:
    CMmcDfsAdmin*               m_pMmcDfsAdmin;        // The Class used for display and for dfsroot list.
    CComPtr<IConsoleNameSpace>  m_pScope;            // Pointer to the Scope Pane.
    CComPtr<IConsole2>          m_pConsole;            // Pointer to the Console.
    HBITMAP                     m_hLargeBitmap;
    HBITMAP                     m_hSmallBitmap;
    HBITMAP                     m_hSmallBitmapOpen;
    HICON                       m_hSnapinIcon;
};
#endif //__DFSSCOPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dfsadmin\dfsgui\dfswiz.cpp ===
/*++
Module Name:

    DfsWiz.cpp

Abstract:

    This module contains the implementation for CCreateDfsRootWizPage1, 2, 3, 4, 5, 6.
  These classes implement pages in the CreateDfs Root wizard.
--*/


#include "stdafx.h"
#include "resource.h"    // To be able to use the resource symbols
#include "DfsEnums.h"    // for common enums, typedefs, etc
#include "NetUtils.h"    
#include "ldaputils.h"    
#include "Utils.h"      // For the LoadStringFromResource method

#include "dfswiz.h"      // For Ds Query Dialog
#include <shlobj.h>
#include <dsclient.h>
#include <initguid.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <lmdfs.h>
#include <iads.h>
#include <icanon.h>
#include <dns.h>

HRESULT
ValidateFolderPath(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
);

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage1: Welcome page
// Has a watermark bitmap and no controls except the next and cancel buttons

CCreateDfsRootWizPage1::CCreateDfsRootWizPage1(
  IN LPCREATEDFSROOTWIZINFO      i_lpWizInfo
  ) 
  : CQWizardPageImpl<CCreateDfsRootWizPage1> (false), m_lpWizInfo(i_lpWizInfo)
/*++

Routine Description:

  The ctor for CCreateDfsRootWizPage1. Calls the parent ctor asking it to 
  display the  watermark bitmap

Arguments:

  i_lpWizInfo  - The wizard information structure. Contains details like 
  domain name, server name, etc

Return value:

  None

--*/
{
}



BOOL 
CCreateDfsRootWizPage1::OnSetActive()
/*++

Routine Description:

  Called when the page is being showed. Sets the buttons to be shown

Arguments:

  None

Return value:

  TRUE. Since we handle the message

--*/
{
  ::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);
  ::SetControlFont(m_lpWizInfo->hBigBoldFont, m_hWnd, IDC_WELCOME_BIG_TITLE);
  ::SetControlFont(m_lpWizInfo->hBoldFont, m_hWnd, IDC_WELCOME_SMALL_TITLE);

  return TRUE;
}


// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage2: Dfsroot type selection
// Used to decide the type of dfsroot to be created. Fault tolerant or standalone

CCreateDfsRootWizPage2::CCreateDfsRootWizPage2(
  IN LPCREATEDFSROOTWIZINFO        i_lpWizInfo
  )
  :m_lpWizInfo(i_lpWizInfo), CQWizardPageImpl<CCreateDfsRootWizPage2>(true)
/*++

Routine Description:

  The ctor for CCreateDfsRootWizPage2. Calls the parent ctor and stores 
  the Wizard info struct.

Arguments:

  i_lpWizInfo  - The wizard information structure. Contains details like 
  domain name, server name, etc

Return value:

  None

--*/
{
  CComBSTR  bstrTitle;
  CComBSTR  bstrSubTitle;


  HRESULT hr = LoadStringFromResource(IDS_WIZ_PAGE2_TITLE, &bstrTitle);
  _ASSERTE(S_OK == hr);
  _ASSERTE(NULL != bstrTitle.m_str);
  SetHeaderTitle(bstrTitle);

  hr = LoadStringFromResource(IDS_WIZ_PAGE2_SUBTITLE, &bstrSubTitle);
  _ASSERTE(S_OK == hr);
  _ASSERTE(NULL != bstrSubTitle.m_str);
  SetHeaderSubTitle(bstrSubTitle);
}



BOOL 
CCreateDfsRootWizPage2::OnSetActive()
/*++

Routine Description:

  Called when the page is being showed. Sets the buttons to be shown.
  Also, sets the Dfsroot type to be fault tolerant.

Arguments:

  None

Return value:

  TRUE. Since we handle the message

--*/
{
  ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

  SetDefaultValues();          // Update the controls to show default values

  return TRUE;
}



HRESULT 
CCreateDfsRootWizPage2::SetDefaultValues(
  )
/*++

Routine Description:

  Sets the default values for controls in the dialog box

Arguments:

  None
  

Return value:

  S_OK
--*/
{
                        // Fault Tolerant dfsroot is the default.
  if (DFS_TYPE_UNASSIGNED == m_lpWizInfo->DfsType)
  {                      // Set the variable and the radio button
    CheckRadioButton(IDC_RADIO_FTDFSROOT, IDC_RADIO_STANDALONE_DFSROOT, IDC_RADIO_FTDFSROOT);
    m_lpWizInfo->DfsType = DFS_TYPE_FTDFS;
  }

  return S_OK;
}
  
  
  
BOOL 
CCreateDfsRootWizPage2::OnWizardNext()
/*++

Routine Description:

  Called when the "Next" button is pressed. Gets the values from the page.

Arguments:

  None

Return value:

  TRUE. to let the user continue to the next page
  FALSE, to not let the user continue ahead.

--*/
{
  if (IsDlgButtonChecked(IDC_RADIO_FTDFSROOT))  // Use the radio buttons to set the variable
  {
    m_lpWizInfo->DfsType = DFS_TYPE_FTDFS;
  }
  else
  {
    m_lpWizInfo->DfsType = DFS_TYPE_STANDALONE;
  }

  return TRUE;
}



BOOL 
CCreateDfsRootWizPage2::OnWizardBack()
/*++

Routine Description:

  Called when the "Back" button on the pressed. Sets the buttons to be shown

Arguments:

  None

Return value:

  TRUE. Since we handle the message

--*/
{
  return OnReset();
}



BOOL 
CCreateDfsRootWizPage2::OnReset()
/*++

Routine Description:

  Called when the page is being released. Can be on "Back" or "Cancel"

Arguments:

  None

Return value:

  TRUE. Since we handle the message

--*/
{
  m_lpWizInfo->DfsType = DFS_TYPE_UNASSIGNED;    // Reset the dfsroot type

  return TRUE;
}

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage3: Domain selection
// Use to select a NT 5.0 domain

CCreateDfsRootWizPage3::CCreateDfsRootWizPage3(
  IN LPCREATEDFSROOTWIZINFO        i_lpWizInfo
  )
  : m_lpWizInfo(i_lpWizInfo), m_hImgListSmall(NULL),
    CQWizardPageImpl<CCreateDfsRootWizPage3>(true)
/*++

Routine Description:

  The ctor for CCreateDfsRootWizPage3. Calls the parent ctor and stores 
  the Wizard info struct.

Arguments:

  i_lpWizInfo  - The wizard information structure. Contains details like 
  domain name, server name, etc

Return value:

  None

--*/
{
  CComBSTR  bstrTitle;
  CComBSTR  bstrSubTitle;


  HRESULT hr = LoadStringFromResource(IDS_WIZ_PAGE3_TITLE, &bstrTitle);
  _ASSERTE(S_OK == hr);
  _ASSERTE(NULL != bstrTitle.m_str);
  SetHeaderTitle(bstrTitle);

  hr = LoadStringFromResource(IDS_WIZ_PAGE3_SUBTITLE, &bstrSubTitle);
  _ASSERTE(S_OK == hr);
  _ASSERTE(NULL != bstrSubTitle.m_str);
  SetHeaderSubTitle(bstrSubTitle);
}



CCreateDfsRootWizPage3::~CCreateDfsRootWizPage3(
  )
/*++

Routine Description:

  The dtor for CCreateDfsRootWizPage3.

Arguments:

  None

Return value:

  None

--*/
{
}



BOOL 
CCreateDfsRootWizPage3::OnSetActive()
/*++

Routine Description:

  Called when the page is being showed. Sets the buttons to be shown.
  Also, if the Dfsroot type is standalone, this page is skipped. Before 
  this the user domain name is specified

Arguments:

  None

Return value:

  TRUE. Since we handle the message
--*/
{
  CWaitCursor    WaitCursor;            // Set cursor to wait

//  if (NULL != m_lpWizInfo->bstrSelectedDomain)
//  {
//    OnReset();
//  }

              // Skip this page for standalone dfs roots
  if (DFS_TYPE_STANDALONE == m_lpWizInfo->DfsType)
  {
    return FALSE;    
  }


  SetDefaultValues();    // Update the controls to show default values

  ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);
  
  return TRUE;
}



HRESULT 
CCreateDfsRootWizPage3::SetDefaultValues(
  )
/*++

Routine Description:

  Sets the default values for controls in the dialog box
  Sets the edit box to the current domain. No check to see, if it has 
  been already done as Standalone skips this page

Arguments:

  None
  

Return value:

  S_OK
--*/
{
  if (NULL == m_lpWizInfo->bstrSelectedDomain)
  {
              // Page is displayed for the first time, Set domain to current domain
    CComBSTR    bstrDomain;
    HRESULT     hr = GetServerInfo(NULL, &bstrDomain);

    if (S_OK == hr && S_OK == Is50Domain(bstrDomain))
    {
      m_lpWizInfo->bstrSelectedDomain = bstrDomain.Detach();
    }
  }

  SetDlgItemText(IDC_EDIT_SELECTED_DOMAIN,
    m_lpWizInfo->bstrSelectedDomain ? m_lpWizInfo->bstrSelectedDomain : _T(""));

  // select the matching item in the listbox
  HWND hwndList = GetDlgItem(IDC_LIST_DOMAINS);
  if ( ListView_GetItemCount(hwndList) > 0)
  {
    int nIndex = -1;
    if (m_lpWizInfo->bstrSelectedDomain)
    {
        TCHAR   szText[DNS_MAX_NAME_BUFFER_LENGTH];
        while (-1 != (nIndex = ListView_GetNextItem(hwndList, nIndex, LVNI_ALL)))
        {
            ListView_GetItemText(hwndList, nIndex, 0, szText, DNS_MAX_NAME_BUFFER_LENGTH);
            if (!lstrcmpi(m_lpWizInfo->bstrSelectedDomain, szText))
            {
                ListView_SetItemState(hwndList, nIndex, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
                ListView_Update(hwndList, nIndex);
                break;
            }
        }
    }

    if (-1 == nIndex)
    {
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
        ListView_Update(hwndList, 0);
    }
  }

  return S_OK;
}
  
  
  
BOOL 
CCreateDfsRootWizPage3::OnWizardNext()
/*++

Routine Description:

  Called when the "Next" button is pressed. Gets the values from the page.
  Displays an error message, if an incorrect value has been specified

Arguments:

  None

Return value:

  TRUE. to let the user continue to the next page
  FALSE, to not let the user continue ahead.

--*/
{
  CWaitCursor    WaitCursor;      // Set cursor to wait

                        // Get the value entered by the user
  DWORD     dwTextLength = 0;
  CComBSTR  bstrCurrentText;
  HRESULT   hr = GetInputText(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN), &bstrCurrentText, &dwTextLength);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN));
    return FALSE;
  } else if (0 == dwTextLength)
  {
    DisplayMessageBoxWithOK(IDS_MSG_EMPTY_FIELD);
    ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN));
    return FALSE;
  }

  CComBSTR bstrDnsDomain;
  hr = CheckUserEnteredValues(bstrCurrentText, &bstrDnsDomain);
  if (S_OK != hr)  
  {                            // Error message on incorrect domain.
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_INCORRECT_DOMAIN, bstrCurrentText);
    return FALSE;
  }

  SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSelectedDomain);

  m_lpWizInfo->bstrSelectedDomain = bstrDnsDomain.Detach();

  return TRUE;
}

HRESULT 
CCreateDfsRootWizPage3::CheckUserEnteredValues(
  IN LPCTSTR          i_szDomainName,
  OUT BSTR*           o_pbstrDnsDomainName
  )
/*++
Routine Description:
  Checks the value that user has given for this page.
  This is done typically on "Next" key being pressed.
  Check, if the domain is NT 5.0 and contactable
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_szDomainName);

              // Check if it is NT 5.0 domain and is contactable
  return Is50Domain(const_cast<LPTSTR>(i_szDomainName), o_pbstrDnsDomainName);
}
  
  
  
BOOL 
CCreateDfsRootWizPage3::OnWizardBack()
/*++

Routine Description:

  Called when the "Back" button is pressed. Resets the values

Arguments:

  None

Return value:

  TRUE. to let the user continue to the previous page
  FALSE, to not let the user continue.

--*/
{
                          
  SetDlgItemText(IDC_EDIT_SELECTED_DOMAIN, _T(""));  // Set edit box to empty

  return OnReset();      // Simulate a reset.
}



BOOL 
CCreateDfsRootWizPage3::OnReset()
/*++

Routine Description:

  Called when the page is being released. Can be on "Back" or "Cancel"

Arguments:

  None

Return value:

  TRUE. Since we handle the message

--*/
{
  SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSelectedDomain);

  return TRUE;
}



LRESULT 
CCreateDfsRootWizPage3::OnNotify(
  IN UINT            i_uMsg, 
  IN WPARAM          i_wParam, 
  IN LPARAM          i_lParam, 
  IN OUT BOOL&        io_bHandled
  )
/*++

Routine Description:

  Notify message for user actions. We handle only the mouse click right now

Arguments:

  i_lParam  -  Details about the control sending the notify
  io_bHandled  -  Whether we handled this message or not.

Return value:

  TRUE
--*/
{
  io_bHandled = FALSE