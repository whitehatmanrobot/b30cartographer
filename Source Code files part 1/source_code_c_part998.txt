*********************

HRESULT CWmiDbSession::ShutDown ()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _WMILockit lkt(GetCS());

    try
    {
        if (m_pController)
        {
            ((CWmiDbController *)m_pController)->ReleaseSession(this);
            m_pController->Release();
            m_pController = NULL;
        }    
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::ShutDown\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::AddTransLock
//
//***************************************************************************

HRESULT CWmiDbSession::AddTransLock(SQL_ID dObjectId, DWORD dwHandleType)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SessionLock *pLock = new SessionLock;
    if (pLock)
    {
        DWORD dwVersion = 0;

        pLock->dObjectId = dObjectId;
        pLock->dwHandleType = dwHandleType;

        m_TransLocks.push_back(pLock);
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::CleanTransLocks
//
//***************************************************************************

HRESULT CWmiDbSession::CleanTransLocks()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for (int i = 0; i < m_TransLocks.size(); i++)
    {
        SessionLock *pLock = m_TransLocks.at(i);
        if (pLock)
        {
            hr = ((CWmiDbController *)m_pController)->LockCache.DeleteLock(
                pLock->dObjectId, false, pLock->dwHandleType);            
        }
    }

    m_TransLocks.clear();

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::LockExists
//
//***************************************************************************

BOOL CWmiDbSession::LockExists (SQL_ID dObjId)
{
    BOOL bRet = FALSE;

    for (int i = 0; i < m_TransLocks.size(); i++)
    {
        SessionLock *pLock = m_TransLocks.at(i);
        if (pLock)
        {
            if (pLock->dObjectId == dObjId)
            {
                bRet = TRUE;
                break;
            }
        }
    }

    return bRet;

}

//***************************************************************************
//
//  CWmiDbSession::UnlockDynasties
//
//***************************************************************************

HRESULT CWmiDbSession::UnlockDynasties(BOOL bDelete)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    _WMILockit lkt(GetCS());

    DWORD dwRefCount = Release_Lock();
    if (!dwRefCount)
    {
        DWORD dwThread = GetCurrentThreadId();

        SQLIDs *pIDs = &m_Dynasties[dwThread];

        // Reference count per object (IWmiDbHandle, IWmiDbIterator)
        // Backup fail-safe for handles and queries.

        if (pIDs)
        {
            for (int i = 0; i < pIDs->size(); i++)
            {
                SQL_ID dClass = pIDs->at(i);
                if (!bDelete)
                    GetSchemaCache()->UnlockDynasty(dClass);
                else
                    GetSchemaCache()->DeleteDynasty(dClass);
            }
            pIDs->clear();
        }
        SessionDynasties::iterator it = m_Dynasties.find(dwThread);
        if (it != m_Dynasties.end())
            m_Dynasties.erase(it);
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::DeleteRows
//
//***************************************************************************

HRESULT CWmiDbSession::DeleteRows(IWmiDbHandle *pScope, IWmiDbIterator *pIterator, REFIID iid)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CFlexArray arrHandles;

    IUnknown *pRet = NULL;

    DWORD dwNumRet = 0;

    // WARNING: This is NOT SCALABLE!!!!
    // We're doing it this way because ESS expects 
    // an event to be fired for each result row of a 
    // delete query.  This should be optimized by
    // deleting all the results in one go, and notifying
    // ESS that the class had some of its members deleted

    HRESULT hRes = pIterator->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_COOKIE,
        iid, &dwNumRet, (void **)&pRet);
    while (SUCCEEDED(hRes) && dwNumRet)
    {
        arrHandles.Add(pRet);

        hRes = pIterator->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_COOKIE,
            iid, &dwNumRet, (void **)&pRet);
    }                                               

    // When the iterator returns the last row,
    // it will release the db connection

    if (arrHandles.Size())
    {
        // Transact this operation so we don't fire events until
        // all objects have been deleted.

        int iPos = 0;
        GUID transguid;
        CoCreateGuid(&transguid);

        hr = Begin(0, 0, &transguid);
        if (SUCCEEDED(hr))
        {
            for (iPos = 0; iPos < arrHandles.Size(); iPos++)
            {
                IUnknown *pHandle = (IUnknown *)arrHandles.GetAt(iPos);
                if (FAILED(hr = DeleteObject(pScope, 0, iid, (void *)pHandle)))
                {
                    pHandle->Release();
                    break;
                }
                pHandle->Release();
            }
        }
        if (SUCCEEDED(hr))
            hr = Commit(0);
        else
        {
            hr = Rollback(0);
            // Clean up the handles that were left over.
            for (int i = iPos+1; i < arrHandles.Size(); i++)
            {
                IUnknown *pHandle =  (IUnknown *)arrHandles.GetAt(i);
                pHandle->Release();
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::AddRef_Lock
//
//***************************************************************************

DWORD CWmiDbSession::AddRef_Lock()
{
    DWORD dwThreadId = GetCurrentThreadId();

    DWORD dwRefCount = m_ThreadRefCount[dwThreadId];
    InterlockedIncrement((LONG *) &dwRefCount);
    m_ThreadRefCount[dwThreadId] = dwRefCount;

    return dwRefCount;

}

//***************************************************************************
//
//  CWmiDbSession::Release_Lock
//
//***************************************************************************

DWORD CWmiDbSession::Release_Lock()
{
    DWORD dwThreadId = GetCurrentThreadId();

    DWORD dwRefCount = m_ThreadRefCount[dwThreadId];
    if (dwRefCount > 0)
        InterlockedDecrement((LONG *) &dwRefCount);

    m_ThreadRefCount[dwThreadId] = dwRefCount;

    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\reputils.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   reputils.cpp
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#define _REPUTILS_CPP_

#include "precomp.h"
#include <wbemcli.h>
#include <wbemutil.h>
#include <comutil.h>
#include <stdio.h>

#include <reputils.h>
#include <flexarry.h>
#include <wstring.h>
#include <wqllex.h>
#include <genutils.h>

//***************************************************************************

void SetBoolQualifier(IWbemQualifierSet *pQS, LPCWSTR lpQName, long lFlavor)
{
    VARIANT var;
    VariantInit(&var);
    var.vt = VT_BOOL;
    var.boolVal = 1;
    pQS->Put(lpQName, &var, lFlavor);
    VariantClear(&var);
}

//***************************************************************************

LPWSTR StripEscapes (LPWSTR lpIn)
{
    WCHAR szTmp[450];
    wchar_t *pRet = NULL;
    int i, iPos = 0;
    bool bInit = false;

    int iLen = wcslen(lpIn);
    if (iLen)
    {
        for (i = 0; i < iLen; i++)
        {
            WCHAR t = lpIn[i];
            if (!bInit && t == '\\')
            {
                bInit = true;
                continue;
            }
            bInit = false;
            szTmp[iPos] = t;
            iPos++;
        }
    }
    szTmp[iPos] = '\0';

    pRet = new wchar_t [wcslen(szTmp)+1];
    if (pRet)
        wcscpy(pRet, szTmp);

    return pRet;

}

//***************************************************************************

LPWSTR GetStr (DWORD dwValue)
{
    wchar_t *pTemp = new wchar_t [30];
    if (pTemp)
        swprintf(pTemp, L"%ld", dwValue);

    return pTemp;
}

//***************************************************************************

LPWSTR GetStr(double dValue)
{
    wchar_t *pTemp = new wchar_t [30];
    if (pTemp)
        swprintf(pTemp, L"%lG", dValue);

    return pTemp;
}

//***************************************************************************

LPWSTR GetStr (SQL_ID dValue)
{
    wchar_t *pTemp = new wchar_t [30];
    if (pTemp)
        swprintf(pTemp, L"%I64d", dValue);

    return pTemp;
}

//***************************************************************************

LPWSTR GetStr (float dValue)
{
    wchar_t *pTemp = new wchar_t [30];
    if (pTemp)
        swprintf(pTemp, L"%g", dValue);

    return pTemp;
}

//***************************************************************************

LPWSTR GetStr (VARIANT &vValue)
{
    IWbemClassObject *pTemp;
    VARIANT vTemp;
    CIMTYPE cimtype;
    long lTemp;
    wchar_t *pRet = NULL;

    switch( vValue.vt)
    {
    case VT_I1:
        pRet = GetStr((DWORD)vValue.cVal);
        break;
    case VT_UI1:
        pRet = GetStr((DWORD)vValue.bVal);
        break;
    case VT_I2:
        pRet = GetStr((DWORD)vValue.iVal);
        break;
    case VT_I4:
        pRet = GetStr((DWORD)vValue.lVal);
        break;
    case VT_BOOL:
        pRet = GetStr((DWORD)vValue.boolVal);
        break;
    case VT_R4:
        pRet = GetStr((float)vValue.fltVal);
        break;
    case VT_R8:
        pRet = GetStr((double)vValue.dblVal);
        break;
    case VT_NULL:
    case VT_EMPTY:
        pRet = NULL;
        break;
    case VT_BSTR:
        pRet = StripQuotes(vValue.bstrVal);
        break;
    case VT_UNKNOWN:
        VariantInit(&vTemp);
        pTemp = (IWbemClassObject *)V_UNKNOWN(&vValue);
        if (pTemp)
        {
            pTemp->Get(L"__RelPath", 0, &vTemp, &cimtype, &lTemp);
            if (vTemp.vt == VT_BSTR)
                pRet = StripQuotes(vTemp.bstrVal);
        }
        VariantClear(&vTemp);
        break;
    case VT_UI1|VT_ARRAY:
        pRet = new wchar_t [1];
        if (pRet)
            pRet[0] = L'\0';
        break;
    default:   
        pRet = new wchar_t [1];
        if (pRet)
            pRet[0] = L'\0';
    }

    return pRet;
}

//***************************************************************************

LPWSTR GetPropertyVal (LPWSTR lpProp, IWbemClassObject *pObj)
{
    LPWSTR lpRet = NULL;
    VARIANT vVal;
    VariantInit(&vVal);

    if (SUCCEEDED(pObj->Get(lpProp, 0, &vVal, NULL, NULL)))
    {
        lpRet = GetStr(vVal);
        VariantClear(&vVal);
    }
    return lpRet;
}

//***************************************************************************

DWORD GetQualifierFlag (LPWSTR lpQfrName, IWbemQualifierSet *pQS)
{
    DWORD dwRet = 0;
    VARIANT vVal;
    VariantInit(&vVal);
    if (SUCCEEDED(pQS->Get(lpQfrName, 0, &vVal, NULL)))
        dwRet = vVal.lVal;
    VariantClear(&vVal);
    return dwRet;
}

//***************************************************************************

DWORD GetStorageType (CIMTYPE cimtype, bool bArray)
{
    DWORD dwRet = 0;

    if (cimtype == CIM_STRING || cimtype == CIM_DATETIME)
        dwRet = WMIDB_STORAGE_STRING;
    else if (cimtype == CIM_REAL32 || cimtype == CIM_REAL64)
        dwRet = WMIDB_STORAGE_REAL;
    else if (cimtype == CIM_REFERENCE || cimtype == CIM_OBJECT)
        dwRet = WMIDB_STORAGE_REFERENCE;
    else if ((cimtype == CIM_UINT8) && bArray)
        dwRet = WMIDB_STORAGE_IMAGE;
    else dwRet = WMIDB_STORAGE_NUMERIC; 

    return dwRet;
}

//***************************************************************************

HRESULT GetVariantFromArray (SAFEARRAY *psaArray, long iPos, long vt, VARIANT &vTemp)
{
    HRESULT hr = 0;
    BOOL bTemp;
    long lTemp;
    double dTemp;
    BSTR sTemp;
    IUnknown *pUnk = NULL;

    switch(vt)
    {
    case VT_BOOL:
        SafeArrayGetElement(psaArray, &iPos, &bTemp);
        vTemp.vt = (unsigned short)vt;
        vTemp.boolVal = (BOOL)bTemp;
        break;
    case VT_UI1:
    case VT_I1:
        SafeArrayGetElement(psaArray, &iPos, &lTemp);
        vTemp.vt = VT_UI1;
        vTemp.bVal = (BYTE)lTemp;
        break;
    case VT_UI2:
    case VT_I2:
        SafeArrayGetElement(psaArray, &iPos, &lTemp);
        vTemp.vt = VT_I2;
        vTemp.iVal = (int)lTemp;
    case VT_UI4:
    case VT_I4:
        SafeArrayGetElement(psaArray, &iPos, &lTemp);
        vTemp.vt = VT_I4;
        vTemp.lVal = lTemp;
        break;
    case VT_R4:
        SafeArrayGetElement(psaArray, &iPos, &dTemp);
        vTemp.vt = (unsigned short)vt;
        vTemp.fltVal = (float)dTemp;
        break;
    case VT_UI8:
    case VT_I8:
    case VT_R8:
        SafeArrayGetElement(psaArray, &iPos, &dTemp);
        vTemp.vt = VT_R8;
        vTemp.dblVal = dTemp;
        break;
    case VT_BSTR:
        SafeArrayGetElement(psaArray, &iPos, &sTemp);
        vTemp.vt = (unsigned short)vt;
        vTemp.bstrVal = sTemp;
        break;
    case VT_UNKNOWN:
        SafeArrayGetElement(psaArray, &iPos, &pUnk);
        vTemp.vt = (unsigned short)vt;
        V_UNKNOWN(&vTemp) = pUnk;
        break;
    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

//***************************************************************************

void GetByteBuffer (VARIANT *pValue, BYTE **ppInBuff, DWORD &dwLen)
{
    long lUBound;
    dwLen = 0;

    SAFEARRAY *psaArray = V_ARRAY(pValue);
    if (psaArray)
    {
        HRESULT hr = SafeArrayGetUBound(psaArray, 1, &lUBound);
        lUBound += 1;
        *ppInBuff = new BYTE[lUBound];
        BYTE *pCurr = *ppInBuff;
        if (pCurr)
        {
            for (long i = 0; i < lUBound; i++)
            {
                BYTE byte;
                hr = SafeArrayGetElement(psaArray, &i, &byte);            
                if (FAILED(hr))
                    break;

                //if (!byte)
                //    break;

                *pCurr = byte;
                pCurr++;
                dwLen++;
            }
        }
    }
}

//***************************************************************************

DWORD GetMaxByte (DWORD One, DWORD Two)
{
    DWORD dwRet = 0;

    if (One > Two)
        dwRet = One;
    else
        dwRet = Two;

    return dwRet;
}

//***************************************************************************

DWORD GetMaxBytes(DWORD One, DWORD Two)
{
    DWORD dwRet = 0;

    dwRet |= GetMaxByte(One&0xF, Two&0xF);
    dwRet |= GetMaxByte(One&0xF0, Two&0xF0);
    dwRet |= GetMaxByte(One&0xF00, Two&0xF00);
    dwRet |= GetMaxByte(One&0xF000, Two&0xF000);
    dwRet |= GetMaxByte(One&0xF0000, Two&0xF0000);
    dwRet |= GetMaxByte(One&0xF00000, Two&0xF00000);
    dwRet |= GetMaxByte(One&0xF000000, Two&0xF000000);
    dwRet |= GetMaxByte(One&0xF0000000, Two&0xF0000000);

    return dwRet;
}


//***************************************************************************

LPWSTR TruncateLongText(const wchar_t *pszData, long lMaxLen, bool &bChg, int iTruncLen, BOOL bAppend)
{
    LPWSTR lpRet = NULL;
    bChg = false;
    if (!pszData)
        return Macro_CloneLPWSTR(L"");

    long lLen = wcslen(pszData);
    if (lLen <= lMaxLen)
        return Macro_CloneLPWSTR(pszData);

    wchar_t *wTemp = new wchar_t [iTruncLen+1];
    if (wTemp)
    {
        if (bAppend)
        {
            wcsncpy(wTemp, pszData, iTruncLen-3);
	        wTemp[iTruncLen-3] = L'\0';
	        wcscat(wTemp, L"...\0");
        }
        else
        {
            wcsncpy(wTemp, pszData, iTruncLen);
            wTemp[iTruncLen] = L'\0';
        }
    
        bChg = true;
        lpRet = wTemp;
    }

    return lpRet;
}

BOOL IsTruncated(LPCWSTR lpData, int iCompLen)
{
    BOOL bRet = FALSE;

    int iLen = wcslen(lpData);
    if (iLen == iCompLen)
    {
        if (lpData[iCompLen-1] == L'.' &&
            lpData[iCompLen-2] == L'.' &&
            lpData[iCompLen-3] == L'.')
            bRet = TRUE;
    }

    return bRet;
}

//***************************************************************************

HRESULT PutVariantInArray (SAFEARRAY **ppsaArray, long iPos, VARIANT *vTemp)
{
    HRESULT hr = 0;
    long lTemp;
    double dTemp;
    BOOL bTemp;
    BSTR sTemp;
    SAFEARRAY *psaArray = *ppsaArray;
    IUnknown *pTemp = NULL;

    long why[1];
    why[0] = iPos;

    switch(vTemp->vt & 0xFF)
    {
    case VT_BOOL:
        bTemp = vTemp->boolVal;
        hr = SafeArrayPutElement(psaArray, why, &bTemp);
        break;
    case VT_I1:
    case VT_UI1:
        lTemp = vTemp->bVal;
        hr = SafeArrayPutElement(psaArray, why, &lTemp);
        break;
    case VT_I2:
    case VT_UI2:
        lTemp = vTemp->iVal;
        hr = SafeArrayPutElement(psaArray, why, &lTemp);
        break;
    case VT_I4:
    case VT_UI4:
        lTemp = vTemp->lVal;
        hr = SafeArrayPutElement(psaArray, why, &lTemp);
        break;
    case VT_R4:
        dTemp = vTemp->fltVal;
        hr = SafeArrayPutElement(psaArray, why, &dTemp);
        break;
    case VT_I8:
    case VT_UI8:
    case VT_R8:
        dTemp = vTemp->dblVal;
        hr = SafeArrayPutElement(psaArray, why, &dTemp);
        break;
    case VT_BSTR:
        sTemp = vTemp->bstrVal;
        hr = SafeArrayPutElement(psaArray, why, sTemp);        
        break;
    case VT_UNKNOWN:
        pTemp = V_UNKNOWN(vTemp);
        hr = SafeArrayPutElement(psaArray, why, pTemp);        
        break;
    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

LPWSTR GetOperator (DWORD dwOp)
{
    LPWSTR lpRet = new wchar_t [15];
    if (lpRet)
    {
        switch (dwOp)
        {                   
        case WQL_TOK_LE:
          wcscpy(lpRet, L" <= ");
          break;
        case WQL_TOK_LT:
          wcscpy(lpRet, L" < ");
          break;
        case WQL_TOK_GE:
          wcscpy(lpRet, L" >= ");
          break;
        case WQL_TOK_GT:
          wcscpy(lpRet, L" > ");
          break;
        case WQL_TOK_EQ:
          wcscpy(lpRet, L" = ");
          break;
        case WQL_TOK_NE:
          wcscpy(lpRet, L" <> ");
          break;
        case WQL_TOK_LIKE:
          wcscpy(lpRet, L" like ");
          break;
        case WQL_TOK_NOT_LIKE:
          wcscpy(lpRet, L" not like ");
          break;
        case WQL_TOK_IS:
          wcscpy(lpRet, L" = ");
          break;
        case WQL_TOK_BEFORE:
          wcscpy(lpRet, L" < ");
          break;
        case WQL_TOK_AFTER:
          wcscpy(lpRet, L" > ");
          break;
        case WQL_TOK_NOT_BEFORE:
          wcscpy(lpRet, L" >= ");
            break;
        case WQL_TOK_NOT_AFTER:
           wcscpy(lpRet, L" <= ");
            break;
        default:
           wcscpy(lpRet, L"");
        }
    }

    return lpRet;
}

LPWSTR StripQuotes(LPWSTR lpText, WCHAR tIn)
{
    wchar_t *pszTemp = new wchar_t [wcslen(lpText)*2+1];
    if (pszTemp)
    {
        int iPos = 0;
        int iLen = wcslen(lpText);
        if (iLen)
        {
            for (int i = 0; i < iLen; i++)
            {
                WCHAR t = lpText[i];
                if (t == tIn)
                {
                    pszTemp[iPos] = t;
                    iPos++;
                }
                pszTemp[iPos] = t;
                iPos++;
            }
        }
        pszTemp[iPos] = '\0';
    }

    return pszTemp;
}


//***************************************************************************
//
//  GENUTILS so we don't have to build the entire file
//
//***************************************************************************

POLARITY BOOL IsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

POLARITY BOOL IsWinMgmt(void)
{
    //
    // Retrieve EXE path
    //
	static BOOL bRet = FALSE;
	static BOOL bInit = FALSE;

	if (!bInit)
	{

		WCHAR wszExePath[MAX_PATH+1];
		if(GetModuleFileNameW(NULL, wszExePath, MAX_PATH+1) == 0)
			return FALSE;
		//
		// Extract the file-name portion
		//

		WCHAR* pwcFileName = wcsrchr(wszExePath, L'\\');
		if(pwcFileName == NULL)
			pwcFileName = wszExePath;
		else
			pwcFileName++;

		if(_wcsnicmp(pwcFileName, FILENAME_PREFIX_EXE_W, wcslen(FILENAME_PREFIX_EXE_W)))
			bRet = FALSE;
		else
			bRet = TRUE;
		bInit = TRUE;
	}

    return bRet;
}

POLARITY BOOL VariantCompare(VARIANT *vComp1, VARIANT *vComp2)
{
    IWbemClassObject *pTemp = NULL;
    VARIANT vTemp1, vTemp2;

    BOOL bRet = FALSE;
    if (vComp1->vt != vComp2->vt)
        bRet = FALSE;
    else
    {
        switch(vComp1->vt)
        {
        case VT_I1:
            bRet = (vComp1->cVal == vComp2->cVal) ? TRUE : FALSE;
            break;
        case VT_UI1:
            bRet = (vComp1->bVal == vComp2->bVal) ? TRUE : FALSE;            
            break;
        case VT_I2:
            bRet = (vComp1->iVal == vComp2->iVal) ? TRUE : FALSE;            
            break;
        case VT_I4:
            bRet = (vComp1->lVal == vComp2->lVal) ? TRUE : FALSE;            
            break;
        case VT_BOOL:
            bRet = (vComp1->boolVal == vComp2->boolVal) ? TRUE : FALSE;            
            break;
        case VT_R4:
            bRet = (vComp1->fltVal == vComp2->fltVal) ? TRUE : FALSE;            
            break;
        case VT_R8:
            bRet = (vComp1->dblVal == vComp2->dblVal) ? TRUE : FALSE;            
            break;
        case VT_NULL:
        case VT_EMPTY:
            bRet = TRUE;
            break;
        case VT_BSTR:
            bRet = (!_wcsicmp(vComp1->bstrVal, vComp2->bstrVal)) ? TRUE : FALSE;
            break;
        case VT_UNKNOWN:
            VariantInit(&vTemp1), VariantInit(&vTemp2);
            bRet = FALSE;
            pTemp = (IWbemClassObject *)V_UNKNOWN(vComp1);
            if (pTemp)
            {
                pTemp->Get(L"__RelPath", 0, &vTemp1, NULL, NULL);

                pTemp = (IWbemClassObject *)V_UNKNOWN(vComp2);
                if (pTemp)
                {
                    pTemp->Get(L"__RelPath", 0, &vTemp2, NULL, NULL);
                    bRet = (!_wcsicmp(vTemp1.bstrVal, vTemp2.bstrVal)) ? TRUE : FALSE;
                }
            }
            VariantClear(&vTemp1), VariantClear(&vTemp2);
            break;
        case VT_UI1|VT_ARRAY:
            bRet = FALSE;   // not supported
            break;
        }
    }

    bRet = (bRet == TRUE ? FALSE: TRUE);

    return bRet;
}

char * GetAnsiString (wchar_t *pStr)
{
    char * pRet = new char [(wcslen(pStr)*2)+2];
    if (pRet)
    {
        sprintf(pRet, "%S", pStr);
    }
    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by repdrvr.rc
//
#define IDS_WMI_SERVER                  1
#define IDS_WMI_DATABASE                2
#define IDS_WMI_USER_NAME               3
#define IDS_WMI_PASSWORD                4
#define IDS_WMI_LOCALE                  5
#define IDS_WMI_READMODE                6

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\seqstream.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   seqstream.h
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#ifndef __SEQSTREAM_H_
#define __SEQSTREAM_H_

class CSeqStream : public ISequentialStream
{
public:
    //Constructors
    CSeqStream();
    virtual ~CSeqStream();
    virtual BOOL Seek(ULONG iPos);
    virtual BOOL Clear();
    virtual BOOL CompareData(void* pBuffer);
    virtual ULONG Length()  { return m_cBufSize; };
    virtual operator void* const() { return m_pBuffer; };
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);  
    STDMETHODIMP Read( 
            /* [out] */ void __RPC_FAR *pv,
            /* [in]  */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
    STDMETHODIMP Write( 
            /* [in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out]*/ ULONG __RPC_FAR *pcbWritten);
protected:
   //Data
private:
    ULONG       m_cRef;         // reference count
    void*       m_pBuffer;      // buffer
    ULONG       m_cBufSize;     // buffer size
    ULONG       m_iPos;         // current index position in the buffer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\seqstream.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  CSeqStream - bogus class for manipulating blobs.
//
//***************************************************************************
#include "precomp.h"

#include <windows.h>
#include <comutil.h>

#include <arena.h>
#include <seqstream.h>

CSeqStream::CSeqStream()
{
    m_iPos         = 0;
    m_cRef         = 0;
    m_pBuffer      = NULL;
    m_cBufSize     = 0;
    //The constructor AddRef's
    AddRef();
}

  
CSeqStream::~CSeqStream()
{
    //Shouldn't have any references left
    CWin32DefaultArena::WbemMemFree(m_pBuffer);
    
}
  
ULONG    CSeqStream::AddRef(void)
{
    return ++m_cRef;
}

ULONG    CSeqStream::Release(void)
{
    if(--m_cRef)
        return m_cRef;   

    delete this;
    return 0;

}

HRESULT CSeqStream::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown)
        *ppv = this;
    if (riid == IID_ISequentialStream)
        *ppv = this;  

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

BOOL CSeqStream::Seek(ULONG iPos)
{
    //Reset the current buffer position
    m_iPos = iPos;
    return TRUE;
} 

BOOL CSeqStream::Clear()
{
    m_iPos         = 0;
    m_cBufSize     = 0;
    CWin32DefaultArena::WbemMemFree(m_pBuffer);
    
    m_pBuffer = NULL;

    return TRUE;
}

BOOL CSeqStream::CompareData(void* pBuffer)
{
    return memcmp(pBuffer, m_pBuffer, m_cBufSize)==0;
}

HRESULT CSeqStream::Read(void *pv, ULONG cb, ULONG* pcbRead)
{
    //Parameter checking

    if(pcbRead)
        *pcbRead = 0;
  
    if(!pv)
        return STG_E_INVALIDPOINTER;
  
    if(cb == 0)
        return S_OK;

    //Actual code
    ULONG cBytesLeft = m_cBufSize - m_iPos;
    ULONG cBytesRead = cb > cBytesLeft ? cBytesLeft : cb; 

    //if no more bytes to retrieve return 
    if(cBytesLeft == 0)
        return S_FALSE; 

    //Copy to users buffer the number of bytes requested or remaining
    memcpy(pv, (void*)((BYTE*)m_pBuffer + m_iPos), cBytesRead);
    m_iPos += cBytesRead;

    if(pcbRead)
        *pcbRead = cBytesRead;

    if(cb != cBytesRead)
        return S_FALSE; 

    return S_OK;
}

HRESULT CSeqStream::Write(const void *pv, ULONG cb, ULONG* pcbWritten)
{
    if(!pv)
        return STG_E_INVALIDPOINTER;

    if(pcbWritten)
        *pcbWritten = 0;

    if(cb == 0)
        return S_OK;

    //Enlarge the current buffer
    m_cBufSize += cb;

    //Need to append to the end of the stream
    // m_pBuffer = CWin32DefaultArena::WbemMemReAlloc(m_pBuffer, m_cBufSize);
    if (m_pBuffer)
        m_pBuffer = CWin32DefaultArena::WbemMemReAlloc(m_pBuffer, m_cBufSize);
    else
        m_pBuffer = CWin32DefaultArena::WbemMemAlloc(m_cBufSize);

    memcpy((void*)((BYTE*)m_pBuffer + m_iPos), pv, cb); 

    if(pcbWritten)
        *pcbWritten = cb;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\repsecurity.cpp ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   repsecurity.cpp
//
//   a-davcoo     25-Jan-00       Created to house repository security 
//                                functionality.
//
//***************************************************************************

#define _REPSECURITY_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class


#define DBINITCONSTANTS // Initialize OLE constants...
#define INITGUID        // ...once in each app.
#define _WIN32_DCOM
#include "precomp.h"

#include <std.h>
#include <sqlexec.h>
#include <repdrvr.h>
#include <wbemint.h>
#include <math.h>
#include <resource.h>
#include <reputils.h>
#include <crc64.h>
#include <smrtptr.h>
#include <winntsec.h>

//***************************************************************************
//
// CWmiDbSession::GetObjectSecurity
//
//***************************************************************************

HRESULT CWmiDbSession::GetObjectSecurity (CSQLConnection *pConn, SQL_ID dObjectId, PNTSECURITY_DESCRIPTOR *ppSD, DWORD dwSDLength,
                                          DWORD dwFlags, BOOL &bHasDacl)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Retrieve this object and populate the SD.

    bHasDacl = FALSE;

    // See if this ID even has an SD.

    if (!((CWmiDbController *)m_pController)->HasSecurityDescriptor(dObjectId))
        return WBEM_S_NO_ERROR;
    if(IsInAdminGroup())
        return WBEM_S_NO_ERROR;


    BOOL bNeedToRel = FALSE;
    if (!pConn)
    {
        hr = GetSQLCache()->GetConnection(&pConn, FALSE, FALSE);
        bNeedToRel = TRUE;
    }

    if (SUCCEEDED(hr))
    {
        PNTSECURITY_DESCRIPTOR pSD = NULL;

        // For now, we will never cache the __SECURITY_DESCRIPTOR property.  Always
        // retrieve it from a proc call.

        hr = CSQLExecProcedure::GetSecurityDescriptor(pConn, dObjectId, &pSD, dwSDLength, dwFlags);
        if (hr == WBEM_E_NOT_FOUND)
        {
            bHasDacl = FALSE;
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
			PACL pDACL=NULL;
			BOOL bDefaulted, bTemp;
			BOOL bSuccess=GetSecurityDescriptorDacl (pSD, &bTemp, &pDACL, &bDefaulted);
			if (!bSuccess)
			{
				hr = WBEM_E_FAILED;
			}
			else
			{
				bHasDacl = (bTemp && pDACL!=NULL);
			}
        }

        if (bHasDacl)
            *ppSD = pSD;
        else
        {
            *ppSD = NULL;
            delete pSD;
        }

        if (bNeedToRel)
            GetSQLCache()->ReleaseConnection(pConn, hr, FALSE);
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::VerifyObjectSecurity()
//
//  This method verifies that the caller has the requested access to the
//  target object.  If the reqested access can be granted, a successfull
//  result is returned.  If not, WBEM_E_ACCESS_DENIED is returned.  This
//  method will check the entire security inheritance tree, as required.
//
//***************************************************************************
HRESULT CWmiDbSession::VerifyObjectSecurity(CSQLConnection *pConn, IWmiDbHandle __RPC_FAR *pTarget,
	                                        DWORD AccessType)
{
	CWmiDbHandle *pObject=(CWmiDbHandle *)pTarget;
	HRESULT hr=VerifyObjectSecurity (pConn, pObject->m_dObjectId, pObject->m_dClassId, 
		pObject->m_dScopeId, 0, AccessType);

	return hr;
}


//***************************************************************************
//
//  CWmiDbSession::VerifyObjectSecurity()
//
//  This method verifies that the caller has the requested access to the
//  target object.  If the reqested access can be granted, a successfull
//  result is returned.  If not, WBEM_E_ACCESS_DENIED is returned.  This
//  method will check the entire security inheritance tree, as required.
//  The ScopeId and ScopeClassId are allowed to be 0 when calling this 
//  method.
//
//***************************************************************************
HRESULT CWmiDbSession::VerifyObjectSecurity(CSQLConnection *pConn, 
	SQL_ID ObjectId,
	SQL_ID ClassId,
	SQL_ID ScopeId,
	SQL_ID ScopeClassId,
	DWORD AccessType)
{
	// Validate the state of the session and initialize the schema cache if required.
	if (!m_pController || ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
	{
		return WBEM_E_SHUTTING_DOWN;
	}

	if (!((CWmiDbController *)m_pController)->m_bCacheInit)
	{
		HRESULT hr=LoadSchemaCache();
		if (SUCCEEDED(hr))
			((CWmiDbController *)m_pController)->m_bCacheInit=TRUE;
		else
			return hr;
	}

	// Obtain the object's effective security descriptor and see if access to the object 
	// is granted.  Access to administrators is always granted.
	HRESULT hr=WBEM_S_NO_ERROR;
	if (!((CWmiDbController *)m_pController)->m_bIsAdmin)
	{
		PNTSECURITY_DESCRIPTOR pSD=NULL;
		DWORD dwSDLength;

		hr=GetEffectiveObjectSecurity (pConn, ObjectId, ClassId, ScopeId, ScopeClassId, &pSD, dwSDLength);
		if (SUCCEEDED(hr) && pSD)
		{
			BOOL bHasDACL;
			hr=AccessCheck (pSD, AccessType, bHasDACL);

            delete pSD;
		}
	}

	return hr;
}


//***************************************************************************
//
//  CWmiDbSession::VerifyObjectSecurity()
//
//  Used internally to the repository driver, currently only by PutObject().
//
//***************************************************************************
HRESULT CWmiDbSession::VerifyObjectSecurity(CSQLConnection *pConn, 
	SQL_ID dScopeID, 
	SQL_ID dScopeClassId,
	LPWSTR lpObjectPath, 
	CWbemClassObjectProps *pProps,
    DWORD dwHandleType, 
	DWORD dwReqAccess, 
	SQL_ID &dObjectId, 
	SQL_ID &dClassId)
{
	// Validate the state of the session and initialize the schema cache if required.
	if (!m_pController || ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
	{
		return WBEM_E_SHUTTING_DOWN;
	}

	if (!((CWmiDbController *)m_pController)->m_bCacheInit)
	{
		HRESULT hr=LoadSchemaCache();
		if (SUCCEEDED(hr))
			((CWmiDbController *)m_pController)->m_bCacheInit=TRUE;
		else
			return hr;
	}

	// If we have an objectid, then the security has already been validated.  We can just
	// return the classid.  
	HRESULT hr=WBEM_S_NO_ERROR;
	if (dObjectId && !dClassId)
	{
		hr=GetSchemaCache()->GetClassID(pProps->lpClassName, dScopeID, dClassId);
	}
	else
	{
		// Otherwise, we don't have an objectid and we'll need to get it from the database
		// or from the schema cache.
		hr=GetSchemaCache()->GetClassID(pProps->lpClassName, dScopeID, dClassId);
		if (pProps->dwGenus==WBEM_GENUS_CLASS)
		{
			dObjectId=dClassId;
		}

		// Make sure the parent class isn't locked.
		if (!dClassId)
		{
			hr=GetSchemaCache()->GetClassID(pProps->lpSuperClass, dScopeID, dClassId);
		}

		// If not found, make sure we can access the class.
		BOOL bNewObj=(!dObjectId);
		if (bNewObj)
		{
			hr=VerifyClassSecurity(pConn, dClassId, dwReqAccess);
		}
		else
		{
			hr=VerifyObjectSecurity(pConn, dObjectId, dClassId, dScopeID, dScopeClassId, dwReqAccess);
			if (SUCCEEDED(hr))
			{
				// Make sure we aren't blocked by any other handle type.
				bool bImmediate=!((dwHandleType & 0xF0000000)==WMIDB_HANDLE_TYPE_SUBSCOPED);
				hr=((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjectId, WMIDB_HANDLE_TYPE_EXCLUSIVE, NULL, 
					dScopeID, dClassId, &((CWmiDbController *)m_pController)->SchemaCache, false, 0, 0);                    

				if (SUCCEEDED(hr))
				{
					hr=((CWmiDbController *)m_pController)->LockCache.DeleteLock(dObjectId, false, WMIDB_HANDLE_TYPE_EXCLUSIVE);
				}
			}
		}
	}

	// Done.
	return hr;
}


//***************************************************************************
//
//  CWmiDbSession::VerifyClassSecurity()
//
//  This method verifies that the caller has the requested access to the
//  target class.  If the reqested access can be granted, a successfull
//  result is returned.  If not, WBEM_E_ACCESS_DENIED is returned.  This
//  method will check the entire security inheritance tree, as required.
//
//***************************************************************************
HRESULT CWmiDbSession::VerifyClassSecurity(CSQLConnection *pConn, 
	SQL_ID ClassId,
	DWORD AccessType)
{
	return VerifyObjectSecurity (pConn, ClassId, 1, 0, 0, AccessType);
}


//***************************************************************************
//
//  CWmiDbSession::GetEffectiveObjectSecurity()
//
//  This method searches for the SD which should be applied to verification
//  of access against the specified object.  This SD could be the one directly
//  associated with the object, or if the object does not have a SD with a
//  DACL, it will be the inherited SD.  Note, ScopeId and ScopeClassId can
//  be 0 when calling this function.
//
//***************************************************************************
HRESULT CWmiDbSession::GetEffectiveObjectSecurity(CSQLConnection *pConn, 
	SQL_ID ObjectId,
	SQL_ID ClassId,
	SQL_ID ScopeId,
	SQL_ID ScopeClassId,
	PNTSECURITY_DESCRIPTOR *ppSD,
	DWORD &dwSDLength
)
{
	// Attempt to get the security descriptor directly associated with the object.
	HRESULT hr = 0;
    BOOL bHasDACL;
    
    if (ClassId == 1)
        hr = GetObjectSecurity (pConn, ObjectId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_CLASS, bHasDACL);
    else
        hr = GetObjectSecurity (pConn, ObjectId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_INSTANCE, bHasDACL);

	// If the object did not have a security descriptor, get it's inherited security descriptor.
	if (SUCCEEDED(hr) && !bHasDACL)
	{
		hr=GetInheritedObjectSecurity (pConn, ObjectId, ClassId, ScopeId, ScopeClassId, ppSD, dwSDLength);
	}

	// Done.
	return hr;
}

	
//***************************************************************************
//
//  CWmiDbSession::GetInheritedObjectSecurity()
//
//  This method determines what security descriptor (if any) would be 
//  inherited by a target object, if the target object had no security 
//  descriptor.  Note that ScopeId and ScopeClassId are allowed to be 0
//  when calling this method.
//
//***************************************************************************
HRESULT CWmiDbSession::GetInheritedObjectSecurity(CSQLConnection *pConn, 
	SQL_ID ObjectId,
	SQL_ID ClassId,
	SQL_ID ScopeId,
	SQL_ID ScopeClassId,
	PNTSECURITY_DESCRIPTOR *ppSD,
	DWORD &dwSDLength)
{
	// Determine whether the target object is a class or an instance.  Handling
	// of instances includes handling of __Instances containers.  Note, a target 
	// with a ClassId of 1 is a class object and the object ID is the class's
	// class ID.
	HRESULT hr=WBEM_S_NO_ERROR;
	if (ClassId==1)
	{
		hr=GetInheritedClassSecurity (pConn, ObjectId, ScopeId, ScopeClassId, ppSD, dwSDLength);
	}
	else
	{
		hr=GetInheritedInstanceSecurity (pConn, ObjectId, ClassId, ScopeId, ScopeClassId, ppSD, dwSDLength);
	}

	// Done.
	return hr;
}


//***************************************************************************
//
//  CWmiDbSession::GetInheritedClassSecurity()
//
//  This method determines what security descriptor (if any) would be inherited
//  by a target class, if the target class had no security descriptor.  This 
//  function will work properly for classes scoped to an object, although this 
//  isn't currently being supported in the rest of WMI.  The ScopeId and the
//  ScopeClassId are allowed to be 0 when using this method.
//
//***************************************************************************
HRESULT CWmiDbSession::GetInheritedClassSecurity(CSQLConnection *pConn, 
	SQL_ID ClassId,
	SQL_ID ScopeId,
	SQL_ID ScopeClassId,
	PNTSECURITY_DESCRIPTOR *ppSD,
	DWORD &dwSDLength)
{
	// Create some convience variables.
	CSchemaCache *pSchema=&((CWmiDbController *)m_pController)->SchemaCache;
	
	// Iterate through the chain of superclasses, until a security descriptor
	// is found, or the top-level base class is reached.
	HRESULT hr=WBEM_S_NO_ERROR;
	bool bTopReached=false;
    BOOL bHasDACL = FALSE;
	SQL_ID dParentId=ClassId;
	do
	{
		// Attempt to locate the superclass.
		hr=pSchema->GetParentId (dParentId, dParentId);
		if (SUCCEEDED(hr) && dParentId != 1)
		{
			hr = GetObjectSecurity(pConn, dParentId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_CLASS, bHasDACL);
		}
		else if (hr==WBEM_E_NOT_FOUND || dParentId == 1)
		{
			// Top of the class hierarchy has been reached.
			hr=WBEM_S_NO_ERROR;
			bTopReached=true;
		}
	}
	while (SUCCEEDED(hr) && !bTopReached && !bHasDACL);

    // If we are at the top of the hierarchy, check security on __Classes for this 
    // namespace.

    if (bTopReached && !bHasDACL)
    {
        IWmiDbHandle *pClassesObj = NULL;

        _bstr_t sName;
        if (ScopeId && SUCCEEDED(pSchema->GetNamespaceName(ScopeId, &sName)))
        {
            sName += L":__Classes=@";
            SQL_ID dClassSec = CRC64::GenerateHashValue(sName);
            hr = GetObjectSecurity(pConn, dClassSec, ppSD, dwSDLength, 0, bHasDACL);
        } 
    }

	// Done.
	return hr;
}
	

//***************************************************************************
//
//  CWmiDbSession::GetInheritedInstanceSecurity()
//
//  This method determines what security descriptor (if any) would be inher-
//  ited by a target instance, if the target instance had no SD.  This method 
//  works for both real instances and instances of __Instances containers.  
//  The ScopeId and the ScopeClassId are allowed to be 0 when using this 
//  method.
//
//***************************************************************************
HRESULT CWmiDbSession::GetInheritedInstanceSecurity(CSQLConnection *pConn, 
	SQL_ID ObjectId,
	SQL_ID ClassId,
	SQL_ID ScopeId,
	SQL_ID ScopeClassId,
	PNTSECURITY_DESCRIPTOR *ppSD,
	DWORD &dwSDLength)
{
	// Setup some convience variables.
	CSchemaCache *pSchema=&((CWmiDbController *)m_pController)->SchemaCache;

	// See if the target is an __Instances container.  If so, it's security is
	// inherited from the __Instances containers of parent classes, and finaly
	// from it's scoping object (owning namespace).
	HRESULT hr=WBEM_S_NO_ERROR;
	if (ClassId==INSTANCESCLASSID)
	{
		hr=GetInheritedContainerSecurity (pConn, ObjectId, ScopeId, ScopeClassId, ppSD, dwSDLength);
	}
	else
	{
		// See if the target object is a namespace.  If it is, then do not attempt
		// to inherit security from parent namespaces.  The security inheritance tree
		// effictively stops at the first namespace.
		/// A-DAVCOO:  Of course we should inherit security from the parent namespaces.  
		/// A-DAVCOO:  But, those namespaces might not even be in the same repository.  
		/// A-DAVCOO:  Hence, that case needs to be handled outside of this driver.
		if (ClassId!=NAMESPACECLASSID && !pSchema->IsDerivedClass (NAMESPACECLASSID, ClassId))
		{
			// Determine the parent scope/namespace as well as it's class, if they
			// were not supplied by the caller.
			if (!ScopeId)
			{
				// We do not have the scope, so get the scope and it's class.
				hr=pSchema->GetParentNamespace (ObjectId, ScopeId, &ScopeClassId);
			}
			else if (!ScopeClassId)
			{
				// We have the scope, but not the scope's class.
				hr=pSchema->GetNamespaceClass (ScopeId, ScopeClassId);
			}

			// If the instance is scoped directly to a namespace, then we first walk
			// the instance's __Instances container chain.  Note, that an __Instances
			// container's object ID is the class ID it represents.
			if (SUCCEEDED(hr))
			{
				if (ScopeClassId==NAMESPACECLASSID || pSchema->IsDerivedClass (NAMESPACECLASSID, ScopeClassId))
				{
					// Check the class's immediate __Instances container.
					BOOL bHasDACL;
					hr = GetObjectSecurity (pConn, ClassId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_INSTANCE, bHasDACL);
					if (SUCCEEDED(hr))
					{
						// The class's __Instances container did not supply a DACL, so get
						// the __Instances container's inherited security.
						hr=GetInheritedContainerSecurity (pConn, ClassId, 0, 0, ppSD, dwSDLength);
					}
				}
				else
				{
					// The instance is not scoped immediately to a namespace derived class,
					// so, check the security of it's scoping object.
                    BOOL bHasDACL;
					hr = GetObjectSecurity (pConn, ScopeId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_INSTANCE, bHasDACL);
					if (SUCCEEDED(hr))
					{
						// Scoping object had no DACL, so use it's inherited security.
						hr=GetInheritedInstanceSecurity (pConn, ScopeId, ScopeClassId, 0, 0, ppSD, dwSDLength);
					}
				}
			}
		}
        else
        {
            BOOL bHasDACL = FALSE;

            // Check security on this namespace object.

            hr = GetObjectSecurity (pConn, ScopeId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_INSTANCE, bHasDACL);
        }
	}

	// Done.
	return hr;
}


//***************************************************************************
//
//  CWmiDbSession::GetInheritedContainerSecurity()
//
//  This method determines what security descriptor (if any) would be inherited
//  by a target __Instances container, if the target container had no security
//  descriptor.  Note, that as a side effect of the alogrithm used, this method
//  will work for __Instances containers scoped to an object as well as to a
//  namespace, if such beasts ever exist for the purposes of scoping a class to
//  an instance.  The ScopeId and the ScopeClassId are allowed to be 0 when 
//  using this method.
//
//***************************************************************************
HRESULT CWmiDbSession::GetInheritedContainerSecurity(CSQLConnection *pConn, 
	SQL_ID ClassId,
	SQL_ID ScopeId,
	SQL_ID ScopeClassId,
	PNTSECURITY_DESCRIPTOR *ppSD,
	DWORD &dwSDLength)
{
	// Setup some convience variables.
	CSchemaCache *pSchema=&((CWmiDbController *)m_pController)->SchemaCache;

	// Iterate through the chain of superclasses, checking each __Instances
	// container for an appropriate security descriptor and DACL.
	HRESULT hr=WBEM_S_NO_ERROR;
	BOOL bHasDACL=false;
	bool bTopReached=false;
	SQL_ID dParentId=ClassId;
	do
	{
		// Attempt to locate the superclass.
		hr=pSchema->GetParentId (dParentId, dParentId);
		if (SUCCEEDED(hr))
		{
			// A class's class ID is used for it's __Instances conatiner's object ID.
			hr = GetObjectSecurity(pConn, dParentId, ppSD, dwSDLength, WMIDB_SECURITY_FLAG_INSTANCE, bHasDACL);
		}
		else if (hr==WBEM_E_NOT_FOUND)
		{
			// Top of the class hierarchy has been reached.
			hr = WBEM_S_NO_ERROR;
			bTopReached = true;
		}
	}
	while (SUCCEEDED(hr) && !bHasDACL && !bTopReached);

	return hr;
}


//***************************************************************************
//
//  CSecurityCache::AccessCheck()
//
//	This function returns a successful result if the requested access to the
//	object is granted, an error result if an error occurs while validating
//  access, or WMI_E_ACCESS_DENIED if access was sucessfully verified but 
//  denied.
//
//	NOTE:  If an object does not have and SD or it has a NULL DACL, access 
//  is granted, but, bHasDACL is set to FALSE.
//
//***************************************************************************
HRESULT CWmiDbSession::AccessCheck( PNTSECURITY_DESCRIPTOR pSD, DWORD dwAccessType, BOOL &bHasDACL )
{
	bHasDACL=TRUE;

    // An object without an SD grants all access.  The caller should check bHasDACL and 
	// inherit security as appropriate.
	HRESULT hr=WBEM_S_NO_ERROR;
	if (pSD==NULL)
	{
		bHasDACL=FALSE;
	}
	else
	{
		// If the object has an SD, but no DACL, then all access is granted.  The caller
		// should check bHasDACL and propagate the check upwards as necessary.
		PACL pDACL=NULL;
		BOOL bDefaulted;
		BOOL bSuccess=GetSecurityDescriptorDacl (pSD, &bHasDACL, &pDACL, &bDefaulted);
		if (!bSuccess)
		{
			hr=WBEM_E_FAILED;
		}
		else if (!bHasDACL || pDACL==NULL)
		{
			bHasDACL=FALSE;
		}
		else
		{
			bHasDACL=TRUE;

			HRESULT hr2 = CoImpersonateClient();
			if (SUCCEEDED(hr))
			{
				// Because we have called CoImpersonateClient(), the thread will have an access
				// token (inferred from Okuntseff, p151).  Threads don't have one by default.
				HANDLE hClientToken=NULL;
                HANDLE hThread = GetCurrentThread();
				bSuccess=OpenThreadToken (hThread, TOKEN_READ | TOKEN_QUERY , TRUE, &hClientToken);                
				if (!bSuccess)
				{            
                    DWORD dwRet = GetLastError();
                    if (dwRet == ERROR_NO_TOKEN)
                    {
                        // No thread token.  Look at process tokens.

                        HANDLE hProc = GetCurrentProcess();
						HANDLE hProcToken;
                        bSuccess = OpenProcessToken(hProc, TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE , &hProcToken);
						if (bSuccess)
						{
							bSuccess = DuplicateToken (

								hProcToken,
								SecurityDelegation ,
								& hClientToken
							) ;

							CloseHandle ( hProcToken ) ;
						}

                        CloseHandle(hProc);
                    }
                    
                    if (!bSuccess)
                    {
                        DEBUGTRACE((LOG_WBEMCORE, "OpenThreadToken failed with %ld", dwRet));
					    hr=WBEM_E_FAILED;
                    }
				}
				
                if (bSuccess)
				{
					GENERIC_MAPPING accessmap;
                    DWORD dw1 = 0, dw2 = 1;

					accessmap.GenericWrite=0;
					accessmap.GenericRead=0;
					accessmap.GenericExecute=0;
					accessmap.GenericAll=0;

                    MapGenericMask(&dwAccessType, &accessmap);
                    PRIVILEGE_SET ps[10];
                    dw1 = 10 * sizeof(PRIVILEGE_SET);

					DWORD PsSize, GrantedAccess;
					BOOL AccessStatus;

                    bSuccess = ::AccessCheck(
                          pSD,                   // security descriptor
                          hClientToken,             // handle to client access token
                          dwAccessType,               // requested access rights 
                          &accessmap,                     // map generic to specific rights
                          ps,                       // receives privileges used
                          &dw1,                     // size of privilege-set buffer
                          &dw2,                     // retrieves mask of granted rights
                          &AccessStatus                     // retrieves results of access check
                          );

					if (!bSuccess)
					{
                        DWORD dwRet = GetLastError();
                        DEBUGTRACE((LOG_WBEMCORE, "AccessCheck failed with %ld", dwRet));
						hr=WBEM_E_FAILED;
					}
					else if (!AccessStatus)
					{
						hr=WBEM_E_ACCESS_DENIED;
					}

					CloseHandle (hClientToken);
				}
                CloseHandle(hThread);

				CoRevertToSelf();
			}
		}
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\reputils.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   reputils.h
//
//   cvadai     6-May-1999      created.
//   sanjes     20-Apr-2000     Bumped Current DB Version to 2.
//
//***************************************************************************

#ifndef _REPUTILS_H_
#define _REPUTILS_H_

typedef __int64 SQL_ID;

#define CURRENT_DB_VERSION             5

#define WMIDB_STORAGE_STRING           1
#define WMIDB_STORAGE_NUMERIC          2
#define WMIDB_STORAGE_REAL             3
#define WMIDB_STORAGE_REFERENCE        4
#define WMIDB_STORAGE_IMAGE            5
#define WMIDB_STORAGE_COMPACT          6

#define REPDRVR_FLAG_ARRAY      0x1
#define REPDRVR_FLAG_QUALIFIER  0x2
#define REPDRVR_FLAG_KEY        0x4
#define REPDRVR_FLAG_INDEXED    0x8
#define REPDRVR_FLAG_NOT_NULL   0x10
#define REPDRVR_FLAG_METHOD     0x20
#define REPDRVR_FLAG_IN_PARAM   0x40
#define REPDRVR_FLAG_OUT_PARAM  0x80
#define REPDRVR_FLAG_KEYHOLE    0x100
#define REPDRVR_FLAG_ABSTRACT   0x200
#define REPDRVR_FLAG_UNKEYED    0x400
#define REPDRVR_FLAG_SINGLETON  0x800
#define REPDRVR_FLAG_HIDDEN     0x1000
#define REPDRVR_FLAG_SYSTEM     0x2000
#define REPDRVR_FLAG_IMAGE      0x4000
#define REPDRVR_FLAG_CLASSREFS  0x8000

#define REPDRVR_MAX_LONG_STRING_SIZE 255

void SetBoolQualifier(IWbemQualifierSet *pQS, LPCWSTR lpQName, long lFlavor=0x3);
LPWSTR StripEscapes (LPWSTR lpIn);
LPWSTR GetStr (DWORD dwValue);
LPWSTR GetStr(double dValue);
LPWSTR GetStr (SQL_ID dValue);
LPWSTR GetStr (float dValue);
LPWSTR GetStr (VARIANT &vValue);
LPWSTR GetPropertyVal (LPWSTR lpProp, IWbemClassObject *pObj);
DWORD GetQualifierFlag (LPWSTR lpQfrName, IWbemQualifierSet *pQS);
DWORD GetStorageType (CIMTYPE cimtype, bool bArray = false);
HRESULT GetVariantFromArray (SAFEARRAY *psaArray, long iPos, long vt, VARIANT &vTemp);
void GetByteBuffer (VARIANT *pValue, BYTE **ppInBuff, DWORD &dwLen);
LPWSTR StripQuotes(LPWSTR lpText, WCHAR t = '\'');
DWORD GetMaxBytes(DWORD One, DWORD Two);
DWORD GetMaxByte(DWORD One, DWORD Two);
LPWSTR GetOperator (DWORD dwOp);
LPWSTR TruncateLongText(const wchar_t *pszData, long lMaxLen, bool &bChg, 
                      int iTruncLen = REPDRVR_MAX_LONG_STRING_SIZE, BOOL bAppend = TRUE);
BOOL IsTruncated(LPCWSTR lpData, int iCompLen = REPDRVR_MAX_LONG_STRING_SIZE);
HRESULT PutVariantInArray (SAFEARRAY **ppsaArray, long iPos, VARIANT *vTemp);
char * GetAnsiString (wchar_t *pStr);

#endif // _REPUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\smrtptr.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#include "precomp.h"
#include <comutil.h>
#include <smrtptr.h>


CReleaseMe::CReleaseMe (  IUnknown *pIn)
{
    m_pIn = pIn;
}

CReleaseMe::~CReleaseMe ()
{
    if (m_pIn)
        m_pIn->Release();
}


CFreeMe::CFreeMe ( BSTR pIn)
{
    m_pIn = pIn;
}

CFreeMe::~CFreeMe ()
{
    if (m_pIn)
        SysFreeString(m_pIn);
}

CClearMe::CClearMe ( VARIANT *pIn)
{
    m_pIn = pIn;
    VariantInit(m_pIn);
}

CClearMe::~CClearMe ()
{
    if (m_pIn)
        VariantClear(m_pIn);
}

CRepdrvrCritSec::CRepdrvrCritSec (CRITICAL_SECTION *pCS)
{
    p_cs = pCS;
    EnterCriticalSection(pCS);
}

CRepdrvrCritSec::~CRepdrvrCritSec()
{
    LeaveCriticalSection(p_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\smrtptr.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef _SMRTPTR_H_
#define _SMRTPTR_H_

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p = NULL) : m_p(p){}
    ~CDeleteMe() {delete m_p;}

    //  overwrites the previous pointer, does NOT delete it
    void operator= (T* p) {m_p = p;}
};

class CReleaseMe 
{
public:
    CReleaseMe ( IUnknown *pIn);
    ~CReleaseMe ();
private:
    IUnknown *m_pIn;
};

class CFreeMe
{
public:
    CFreeMe ( BSTR pIn);
    ~CFreeMe ();
private:
    BSTR m_pIn;
};

class CClearMe
{
public:
    CClearMe ( VARIANT *pIn);
    ~CClearMe ();
private:
    VARIANT *m_pIn;
};

class CRepdrvrCritSec
{
public:
    CRepdrvrCritSec (CRITICAL_SECTION *pCS);
    ~CRepdrvrCritSec ();
private:
    CRITICAL_SECTION *p_cs;
};



#endif // _SMRTPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
TARGETTYPE=DYNLINK

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
LINKLIBS=\
	$(CORELIB_LIB)
TARGETLIBS=\
	$(WMIIDL_LIB) \
	$(WBEMINT_LIB) \
	$(WBEMCOMN_DLL_LIB) \
	$(WMIREPOSITIDL_LIB) \
	$(SDK_LIB_PATH)\oledb.lib \
	$(SDK_LIB_PATH)\msvcprt.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\vccomsup.lib \
	$(SDK_LIB_PATH)\winmm.lib \
	$(SDK_LIB_PATH)\psapi.lib \
        $(UTILLIB_LIB)

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WMIIDL_INC); \
	$(WBEMINT_INC); \
	$(WBEMCOMN_INC); \
	$(WMIREPOSITIDL_INC);\
	$(CORELIB_INC); \
        $(WBEMCORE_INC); \
        $(UTILLIB_INC); \
        $(COMMON)\wmiutils

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.
SOURCES= \
	..\clsfctry.cpp \
	..\REPDRVR.cpp \
	..\WQLTOSQL.cpp \
	..\SQLUTILS.cpp \
	..\SEQSTREAM.cpp \
	..\SQLCACHE.cpp \
	..\SQLEXEC.cpp \
	..\repcache.cpp \
	..\repsecurity.cpp \
	..\reputils.cpp \
	..\smrtptr.cpp \
	..\sqlit.cpp \
    ..\sqlbackup.cpp \

C_DEFINES=$(C_DEFINES) /DBUILD_CORE
WIN32_WINNT_VERSION=0x0400
USER_C_FLAGS=/EHa
MSC_OPTIMIZATION=/Ob2
USE_NATIVE_EH=1
USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlcache.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlcache.cpp
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#define _SQLCACHE_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class
#include "precomp.h"

#include <std.h>
#include <sqlcache.h>
#include <arena.h>
#include <reputils.h>
#include <smrtptr.h>

#if defined _WIN64
#define ULONG unsigned __int64
#define LONG __int64
#endif

typedef std::vector <CSQLConnection *> ConnVector;

CDBObjectManager::CDBObjectManager()
{
    
}

CDBObjectManager::~CDBObjectManager()
{
}

void CDBObjectManager::Empty()
{
    DWORD dwVals1[] = 
    {
        SQL_POS_HACCESSOR,         
        SQL_POS_ICOMMANDTEXT,
        SQL_POS_ICOMMANDWITHPARAMS,
        SQL_POS_IACCESSOR,         
        SQL_POS_IOPENROWSET,       
        SQL_POS_IROWSETCHANGE,     
        SQL_POS_IROWSETINDEX,     
        SQL_POS_IROWSET
    };

    DWORD dwVals2[] = 
    {
        SQL_POS_INSERT_CLASS,     
        SQL_POS_INSERT_CLASSDATA ,
        SQL_POS_INSERT_BATCH  ,   
        SQL_POS_INSERT_PROPBATCH,
        SQL_POS_INSERT_BLOBDATA ,
        SQL_POS_HAS_INSTANCES ,  
        SQL_POS_OBJECTEXISTS   , 
        SQL_POS_GETCLASSOBJECT  
    };

    DWORD dwNumVals1 = sizeof(dwVals1) / sizeof(DWORD);
    DWORD dwNumVals2 = sizeof(dwVals2) / sizeof(DWORD);

    for (int i = 0; i < dwNumVals1; i++)
    {
        for (int j = 0; j < dwNumVals2; j++)
        {
            DeleteObject(dwVals1[i]|dwVals2[j]);
        }
    }
}

void * CDBObjectManager::GetObject(DWORD type)
{
    WmiDBObject *pObj = NULL;
    void *pRet = NULL;

    m_Objs.Get(type, &pObj);
    if (pObj)
    {
        if (type & SQL_POS_HACCESSOR)
            pRet = (void *)pObj->hAcc;
        else
            pRet = pObj->pUnk;
    }
    return pRet;
}

void CDBObjectManager::SetObject(DWORD type, void *pNew)
{   
    WmiDBObject *pObj = new WmiDBObject;
    if (pObj)
    {
        if (!(type & SQL_POS_HACCESSOR))
        {
            void *pTemp = GetObject(type);
            if (pTemp)
                ((IUnknown *)pTemp)->Release();
            pObj->pUnk = (IUnknown *)pNew;
            pObj->hAcc = NULL;
        }
        else
        {
            void *pTemp = GetObject(SQL_POS_IACCESSOR | (type & 0xFFF));
            void *pTemp2 = GetObject(type);
        
            if (pTemp2 && pTemp)
                ((IAccessor *)pTemp)->ReleaseAccessor((HACCESSOR)pTemp, NULL);
            pObj->hAcc = (HACCESSOR)pNew;
            pObj->pUnk = NULL;
        }
        if (pNew)
            m_Objs.Insert((SQL_ID)type, pObj);
    }
}

void CDBObjectManager::DeleteObject(DWORD type)
{
    WmiDBObject *pObj = NULL;
    m_Objs.Get(type, &pObj);
    if (pObj)
    {
        void *pTemp = GetObject(type);
        if (pTemp)
        {
            if (!(type & SQL_POS_HACCESSOR))
            {                            
                ((IUnknown *)pTemp)->Release();
            }
            else
            {
                void *pTemp2 = GetObject(SQL_POS_IACCESSOR | (type & 0xFFF));                       
                if (pTemp2 && pTemp)
                    ((IAccessor *)pTemp2)->ReleaseAccessor((HACCESSOR)pTemp, NULL);
            }            
        }
    }
}

//***************************************************************************
//
//  CSQLConnCache::CSQLConnCache
//
//***************************************************************************

CSQLConnCache::CSQLConnCache(DBPROPSET *pPropSet, DWORD MaxConns, DWORD Timeout)
{
	InitializeCriticalSection(&m_cs);

    m_pPropSet = pPropSet;
    m_dwMaxNumConns = MaxConns;
    m_dwTimeOutSecs = Timeout;
    m_sDatabaseName = L"master";
    m_bInit = FALSE;
    m_dwStatus = 0;
}

//***************************************************************************
//
//  CSQLConnCache::~CSQLConnCache
//
//***************************************************************************
CSQLConnCache::~CSQLConnCache()
{
    for (int i = 0; i < m_Conns.size(); i++)
    {
        CSQLConnection *pConn = m_Conns.at(i);        
        delete pConn;
    }
    m_Conns.clear();

	DeleteCriticalSection(&m_cs);

}

//***************************************************************************
//
//  CSQLConnCache::SetCredentials
//
//***************************************************************************
HRESULT CSQLConnCache::SetCredentials(DBPROPSET *pPropSet)
{
    CRepdrvrCritSec r(&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pPropSet)
        hr = WBEM_E_INVALID_PARAMETER;
    else
    {
        if (m_pPropSet)
            delete m_pPropSet;

        m_pPropSet = pPropSet;
    }

    return hr;

}
//***************************************************************************
//
//  CSQLConnCache::SetMaxConnections
//
//***************************************************************************
HRESULT CSQLConnCache::SetMaxConnections (DWORD dwMax)
{
    CRepdrvrCritSec r (&m_cs);

    HRESULT hr = WBEM_S_NO_ERROR;

    if (!dwMax)
        hr = WBEM_E_INVALID_PARAMETER;
    else
        m_dwMaxNumConns = dwMax;

    return hr;
}
//***************************************************************************
//
//  CSQLConnCache::SetTimeoutMinutes
//
//***************************************************************************
HRESULT CSQLConnCache::SetTimeoutSecs(DWORD dwSecs)
{
    CRepdrvrCritSec r (&m_cs);

    m_dwTimeOutSecs = dwSecs;

    return WBEM_S_NO_ERROR;
}
//***************************************************************************
//
//  CSQLConnCache::SetDatabase
//
//***************************************************************************

HRESULT CSQLConnCache::SetDatabase(LPCWSTR lpDBName)
{
    CRepdrvrCritSec r (&m_cs);

    m_sDatabaseName = lpDBName;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CSQLConnCache::GetCredentials
//
//***************************************************************************
HRESULT CSQLConnCache::GetCredentials(DBPROPSET **ppPropSet)
{
    CRepdrvrCritSec r (&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!ppPropSet)
        hr = WBEM_E_INVALID_PARAMETER;
    else
        *ppPropSet = m_pPropSet;

    return hr;
    
}
//***************************************************************************
//
//  CSQLConnCache::GetMaxConnections
//
//***************************************************************************
HRESULT CSQLConnCache::GetMaxConnections (DWORD &dwMax)
{
    CRepdrvrCritSec r (&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    dwMax = m_dwMaxNumConns;

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::GetTimeoutSecs
//
//***************************************************************************
HRESULT CSQLConnCache::GetTimeoutSecs (DWORD &dwSecs)
{
    CRepdrvrCritSec r (&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    dwSecs = m_dwTimeOutSecs;

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::GetDatabase
//
//***************************************************************************
HRESULT CSQLConnCache::GetDatabase (_bstr_t &sName)
{
    CRepdrvrCritSec r (&m_cs);
    HRESULT hr = WBEM_S_NO_ERROR;

    sName = m_sDatabaseName;

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::ClearConnections
//
//***************************************************************************

HRESULT CSQLConnCache::ClearConnections()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Shutdown();

    for (int i = m_Conns.size()-1; i >= 0; i--)
    {
        CSQLConnection *pConn = m_Conns.at(i);
        delete pConn;
    }
    m_Conns.clear();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlexec.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlexec.h
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#ifndef _SQLEXEC_H_
#define _SQLEXEC_H_

// This file defines a class that maintains a cache of 
// SQL connections. Each instance of this class only 
// contains one set of logon credentials.
// Each controller by default is only entitled to
// a maximum of 20 connections.
// ===================================================

#define SQL_STRING_LIMIT           3970
#define REPDRVR_NAME_LIMIT         REPDRVR_MAX_LONG_STRING_SIZE
#define REPDRVR_PATH_LIMIT         450

#include <std.h>
#include <comutil.h>
#include <oledb.h>
#include <oledberr.h>
#include <seqstream.h>
#include <objcache.h>
#include <sqlcache.h>
#include <wbemint.h>
#include <repcache.h>
#include <coresvc.h>

//*******************************************************
//
// CSQLExecute
//
//*******************************************************

// This needs to deal with blob data,
// and support batching.

 class _declspec( dllexport ) CSQLExecute
{
public:

    static HRESULT ExecuteQuery(IDBCreateCommand *pCmd, LPCWSTR lpSQL, IRowset **ppIRowset = NULL, DWORD *dwNumRows = NULL, ...);
    static HRESULT ExecuteQuery(IDBInitialize *pDBInit, LPCWSTR lpSQL, IRowset **ppIRowset = NULL, DWORD *dwNumRows = NULL);

    static HRESULT ExecuteQueryAsync(IDBInitialize *pDBInit, LPCWSTR lpSQL, IDBAsynchStatus **ppIAsync, DWORD *dwNumRows = NULL);

    static HRESULT IsDataReady(IDBAsynchStatus *pIAsync);
    static HRESULT CancelQuery(IDBAsynchStatus *pIAsync);

    static HRESULT GetNumColumns(IRowset *pIRowset, IMalloc *pMalloc, int &iNumCols);
    static HRESULT GetDataType(IRowset *pIRowset, int iPos, IMalloc *pMalloc, DWORD &dwType,
                                 DWORD &dwSize, DWORD &dwPrec, DWORD &dwScale, LPWSTR *lpColumnName = NULL);
    static HRESULT GetColumnValue(IRowset *pIRowset, int iPos, IMalloc *pMalloc, HROW **pRow, VARIANT &vValue, LPWSTR * lpColumnName=NULL);

    static HRESULT ReadImageValue (IRowset *pRowset, int iPos, HROW **pRow, BYTE **pBuffer, DWORD &dwLen);
    static HRESULT WriteImageValue(IDBCreateCommand *pCmd, LPCWSTR lpSQL, int iPos, BYTE *pValue, DWORD dwLen);
    
    static HRESULT GetWMIError(IUnknown *pErrorObj);
    static HRESULT GetWMIError(long ErrorID);
    static void SetDBNumeric (DB_NUMERIC &Id, SQL_ID ObjId);
    static void ClearBindingInfo(DBBINDING *binding);
    static void SetBindingInfo(DBBINDING *binding, ULONG iOrdinal, ULONG uSize, DBPARAMIO io, ULONG maxlen, DBTYPE type, BYTE bPrecision);
    static void SetParamBindInfo (DBPARAMBINDINFO &BindInfo, LPWSTR pszType, LPWSTR lpName, ULONG uSize, DWORD dwFlags, BYTE bPrecision);

    static void GetInt64 (DB_NUMERIC *pId, wchar_t **ppBuffer);
    static __int64 GetInt64 (DB_NUMERIC *pId);

    static void SetVariant(DWORD dwType, VARIANT *pValue, BYTE *pData, DWORD dwTargetType);

protected:

    CSQLExecute(){};
    ~CSQLExecute(){};
};

 
//***************************************************************************
//
//  CSQLExecProcedure - class for executing procedures as efficiently as 
 //                     possible.
//
//***************************************************************************

class _declspec (dllexport) CSQLExecProcedure
{
    typedef std::vector <SQL_ID> SQLIDs;

public:
    static HRESULT GetObjectIdByPath (CSQLConnection *pConn, LPCWSTR lpPath, SQL_ID &dObjectId, SQL_ID &dClassId, 
        SQL_ID *dScopeId, BOOL *bDeleted=NULL); // sp_GetInstanceID

    static HRESULT GetHierarchy(CSQLConnection *pConn, SQL_ID dClassId); // sp_GetChildClassList, sp_GetParentList
    static HRESULT GetNextUnkeyedPath(CSQLConnection *pConn, SQL_ID dClassId, _bstr_t &sNewPath); // sp_GetNextUnkeyedPath
    static HRESULT GetNextKeyhole(CSQLConnection *pConn, DWORD iPropertyId, SQL_ID &dNewId); // sp_GetNextKeyhole

    static HRESULT DeleteProperty(CSQLConnection *pConn, DWORD iPropertyId); // sp_DeleteClassData
    static HRESULT DeleteInstanceData (CSQLConnection *pConn, SQL_ID dObjectId, DWORD iPropertyId, DWORD iPos = -1);
    static HRESULT CheckKeyMigration(CSQLConnection *pConn, LPWSTR lpObjectKey, LPWSTR lpClassName, SQL_ID dClassId, SQL_ID dScopeID,
                            SQL_ID *pIDs, DWORD iNumIDs);
    static HRESULT NeedsToCheckKeyMigration(BOOL &bCheck);
    static HRESULT Execute (CSQLConnection *pConn, LPCWSTR lpProcName, CWStringArray &arrValues,
                                IRowset **ppIRowset);
    static HRESULT EnumerateSubScopes (CSQLConnection *pConn, SQL_ID dScopeId);
    static HRESULT InsertScopeMap (CSQLConnection *pConn, SQL_ID dScopeId, LPCWSTR lpScopePath, SQL_ID );

    static HRESULT GetClassInfo (CSQLConnection *pConn, SQL_ID dClassId, SQL_ID &dSuperClassId, BYTE **pBuffer, DWORD &dwBuffLen);
    static HRESULT HasInstances(CSQLConnection *pConn, SQL_ID dClassId, SQL_ID *pDerivedIds, DWORD iNumDerived, BOOL &bInstancesExist);
    static HRESULT InsertClass (CSQLConnection *pConn, LPCWSTR lpClassName, LPCWSTR lpObjectKey, LPCWSTR lpObjectPath, SQL_ID dScopeID,
                 SQL_ID dParentClassId, SQL_ID dDynasty, DWORD iState, BYTE *pClassBuff, DWORD dwClassBuffLen, DWORD iClassFlags, DWORD iInsertFlags, SQL_ID &dNewId);
    static HRESULT UpdateClassBlob (CSQLConnection *pConn, SQL_ID dClassId, _IWmiObject *pObj);
    static HRESULT InsertClassData (CSQLConnection *pConn, IWbemClassObject *pObj, CSchemaCache *pCache,SQL_ID dScopeId, SQL_ID dClassId, LPCWSTR lpPropName, 
            DWORD CIMType, DWORD StorageType,LPCWSTR lpValue, SQL_ID dRefClassId, DWORD iPropID, DWORD iFlags, 
                DWORD iFlavor, BOOL iSkipValid, DWORD &iNewPropId, SQL_ID dOrigClassId=0, BOOL *bIsKey = NULL);
    static HRESULT InsertBlobData (CSQLConnection *pConn, SQL_ID dClassId, SQL_ID dObjectId, DWORD iPropertyId, BYTE *pImage, DWORD iPos, DWORD dwNumBytes);
    static HRESULT InsertPropertyBatch (CSQLConnection *pConn, LPCWSTR lpObjectKey, LPCWSTR lpPath, LPCWSTR lpClassName,
        SQL_ID dClassId, SQL_ID dScopeId, DWORD iFlags, InsertPropValues *pVals, DWORD iNumVals, SQL_ID &dNewObjectId);
    static HRESULT InsertBatch (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dScopeId, SQL_ID dClassId,
                            InsertQfrValues *pVals, DWORD iNumVals=10);
    static HRESULT ObjectExists (CSQLConnection *pConn,SQL_ID dId, BOOL &bExists, SQL_ID *dClassId, SQL_ID *dScopeId, BOOL bDeletedOK = FALSE);
    static HRESULT RenameSubscopes (CSQLConnection *pConn, LPWSTR lpOldPath, LPWSTR lpOldKey, LPWSTR lpNewPath, LPWSTR lpNewKey);

    static HRESULT GetSecurityDescriptor(CSQLConnection *pConn, SQL_ID dObjectId, 
                                                 PNTSECURITY_DESCRIPTOR * ppSD, DWORD &dwBuffLen,
                                                 DWORD dwFlags);
    static HRESULT EnumerateSecuredChildren(CSQLConnection *pConn, CSchemaCache *pCache, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId,
                            SQLIDs &ObjIds, SQLIDs &ClassIds, SQLIDs &ScopeIds);
    // Special functions for handling ESS

    static HRESULT InsertUncommittedEvent (CSQLConnection *pConn,LPCWSTR lpGUID, LPWSTR lpNamespace, LPWSTR lpClassName, IWbemClassObject *pOldObj, 
                IWbemClassObject *pNewObj, CSchemaCache *pCache);
    static HRESULT DeleteUncommittedEvents (CSQLConnection *pConn,LPCWSTR lpGUID, CSchemaCache *pCache, CObjectCache *pObjCache);
    static HRESULT CommitEvents(CSQLConnection *pConn, _IWmiCoreServices *pESS, LPCWSTR lpNamespace,
                    LPCWSTR lpGUID, CSchemaCache *pCache, CObjectCache *pObjCache);

private:
    CSQLExecProcedure() {};
    ~CSQLExecProcedure() {};
};



#endif  // _SQLEXEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlexec.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlexec.cpp
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#define _SQLEXEC_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class
#include "precomp.h"

#include <std.h>
#include <sqlutils.h>
#include <sqlexec.h>
#include <arena.h>
#include <reputils.h>
#include <smrtptr.h>

#if defined _WIN64
#define ULONG unsigned __int64
#define LONG __int64
#endif

typedef struct tagDBObject
{
    HACCESSOR hAcc;
    IUnknown *pUnk;

} DBObject;

struct BLOBDATA
{
    DBSTATUS            dwStatus;   
    DWORD               dwLength; 
    ISequentialStream*  pISeqStream;
}; 

__int64 CSQLExecute::GetInt64 (DB_NUMERIC *pId)
{
    BYTE buff;
    __int64 dTemp = 0;
    __int64 *pTemp = &dTemp;

    int i = 0, iPos = 15;

    while (iPos >= 0)
    {
        buff = pId->val[iPos];

        dTemp |= buff;
        iPos--;

        if (iPos >= 0)
            dTemp <<= 8;
    }

    if (!pId->sign)
        dTemp *= -1;

    return dTemp;
}

void CSQLExecute::GetInt64 (DB_NUMERIC *pId, wchar_t **ppBuffer)
{
    __int64 dTemp;

    dTemp = GetInt64 (pId);
    wchar_t *pBuff = new wchar_t[21];
    if (pBuff)
        swprintf(pBuff, L"%I64d", dTemp);

    *ppBuffer = pBuff;
}

struct OLEDBDATA
{
    DBSTATUS dwStatus;
    DWORD dwLen;
    BYTE data[8192];
};

//***************************************************************************

void CSQLExecute::SetDBNumeric (DB_NUMERIC &Id, SQL_ID ObjId)
{
    Id.precision = 20;
    Id.scale = 0;
    Id.sign = 1;

    __int64 dTemp = ObjId;
    short i = 0, iPos = 0;
    
    if (dTemp < 0)
    {
        Id.sign = 0;
        dTemp *= -1;
    }

    while (iPos < 16)
    {
        if (!dTemp)
        {
            Id.val[iPos] = 0;            
        }
        else
        {
            i = dTemp & 0xFF;
            Id.val[iPos] = i;

            dTemp >>= 8;
        }
        iPos++;
    }
}

void CSQLExecute::ClearBindingInfo(DBBINDING *binding)
{
    binding->obLength = 0;
    binding->obStatus = 0;
    binding->pTypeInfo = NULL;
    binding->pObject = NULL;
    binding->pBindExt = NULL;
    binding->dwPart = DBPART_VALUE;
    binding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    binding->dwFlags = 0;
    binding->bScale = 0;
}

void CSQLExecute::SetBindingInfo(DBBINDING *binding, unsigned long iOrdinal, unsigned long uSize, DBPARAMIO io, 
                                 unsigned long maxlen, DBTYPE type, BYTE bPrecision)
{
    binding->iOrdinal = iOrdinal;
    binding->obValue = uSize;
    binding->eParamIO = io;
    binding->cbMaxLen = maxlen;
    binding->wType = type;
    binding->bPrecision = bPrecision;
}

void CSQLExecute::SetParamBindInfo (DBPARAMBINDINFO &BindInfo, LPWSTR pszType, LPWSTR lpName, unsigned long uSize, DWORD dwFlags, BYTE bPrecision)
{
    BindInfo.pwszDataSourceType = pszType;
    BindInfo.pwszName = lpName;
    BindInfo.ulParamSize = uSize;
    BindInfo.dwFlags = dwFlags;
    BindInfo.bPrecision = bPrecision;
    BindInfo.bScale = 0;
}
//***************************************************************************
//
//  CSQLExecute::ExecuteQuery
//
//***************************************************************************
HRESULT CSQLExecute::ExecuteQuery(IDBCreateCommand *pCmd, LPCWSTR lpSQL, IRowset **ppIRowset, DWORD *dwNumRows, ...)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ICommandText *pICommandText = NULL;
    IRowset *pIRowset = NULL;
    LONG lRows;

    va_list argptr;

    int iSize = wcslen(lpSQL)+4096;
   
    wchar_t *pSQL = new wchar_t[iSize];
    CDeleteMe <wchar_t> r (pSQL);
    if (pSQL)
    {
        va_start(argptr, dwNumRows);
        vswprintf(pSQL, lpSQL, argptr);
        va_end(argptr);

        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);  
        CReleaseMe r (pICommandText);

        if (SUCCEEDED(hr))
        {
            pICommandText->SetCommandText(DBGUID_DBSQL, pSQL);

            ICommand *pICommand = NULL;
            pICommandText->QueryInterface(IID_ICommand,
                (void **) & pICommand);
            CReleaseMe r1 (pICommand);

            hr = pICommand->Execute(NULL, IID_IRowset, NULL,
                 &lRows, (IUnknown**) &pIRowset);    

            if (FAILED(hr))
            {
                int i = 0;
                hr = GetWMIError(pICommand);
            }
            else
            {
                if (ppIRowset)
                    *ppIRowset = pIRowset;
                else if (pIRowset)
                    pIRowset->Release();
            }
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;
    
    if (dwNumRows)
        *dwNumRows = lRows;

    return hr;

}

//***************************************************************************
//
//  CSQLExecute::ExecuteQuery
//
//***************************************************************************
HRESULT CSQLExecute::ExecuteQuery(IDBInitialize *pDBInit, LPCWSTR lpSQL, IRowset **ppIRowset, DWORD *dwNumRows)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IDBCreateSession *pIDBCreate = NULL;
    IDBCreateCommand *pIDBCreateCommand = NULL;

    hr = pDBInit->QueryInterface(IID_IDBCreateSession,
            (void**) &pIDBCreate);
    CReleaseMe r (pIDBCreate);

    if (SUCCEEDED(hr))
    {
        hr = pIDBCreate->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pIDBCreateCommand);    
        CReleaseMe r2 (pIDBCreateCommand);

        if (SUCCEEDED(hr))
        {
            hr = ExecuteQuery(pIDBCreateCommand, lpSQL, ppIRowset, dwNumRows);
        }
    }            

    return hr;
 }

//***************************************************************************
//
//  CSQLExecute::ExecuteQueryAsync
//
//***************************************************************************

HRESULT CSQLExecute::ExecuteQueryAsync(IDBInitialize *pDBInit, LPCWSTR lpSQL, IDBAsynchStatus **ppIAsync, DWORD *dwNumRows)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IDBCreateSession *pIDBCreate = NULL;
    IDBCreateCommand *pIDBCreateCommand = NULL;
    ICommandText *pICommandText = NULL;
    LONG lRows = 0;

    hr = pDBInit->QueryInterface(IID_IDBCreateSession,
            (void**) &pIDBCreate);
    CReleaseMe r (pIDBCreate);

    if (SUCCEEDED(hr))
    {
        hr = pIDBCreate->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pIDBCreateCommand);    
        CReleaseMe r1 (pIDBCreateCommand);

        if (SUCCEEDED(hr))
        {
            hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
                (IUnknown**) &pICommandText);    
            CReleaseMe r2 (pICommandText);

            if (SUCCEEDED(hr))
            {
                // Admittedly, this won't work unless we have
                // set the IDBProperties DBPROP_ROWSET_ASYNCH
                // property to DBPROPVAL_ASYNCH_INITIALIZE

                pICommandText->SetCommandText(DBGUID_DBSQL, lpSQL);

                ICommand *pICommand = NULL;
                pICommandText->QueryInterface(IID_ICommand,
                    (void **) & pICommand);
                CReleaseMe r3 (pICommand);

                hr = pICommand->Execute(NULL, IID_IDBAsynchStatus, NULL,
                     &lRows, (IUnknown**) ppIAsync);    

            }
        }
    }    

    if (dwNumRows)
        *dwNumRows = lRows;

    return hr;
}

//***************************************************************************
//
//  CSQLExecute::IsDataReady
//
//***************************************************************************
HRESULT CSQLExecute::IsDataReady(IDBAsynchStatus *pIAsync)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    unsigned long uAsyncPhase = 0;
    ULONG uProgress, uProgressMax;

    if (pIAsync)
        hr = pIAsync->GetStatus(DB_NULL_HCHAPTER, DBASYNCHOP_OPEN,
                &uProgress, &uProgressMax, &uAsyncPhase, NULL);

    if (SUCCEEDED(hr))
        hr = WBEM_S_NO_ERROR;
    else if (hr == DB_E_CANCELED)
        hr = WBEM_S_OPERATION_CANCELLED;
    else
    {
        hr = WBEM_E_FAILED;
        // SetWMIOLEDBError(pIAsync);
    }

    if (uAsyncPhase == DBASYNCHPHASE_COMPLETE)
        hr = WBEM_S_NO_ERROR;
    else if (uAsyncPhase == DBASYNCHPHASE_INITIALIZATION ||
            uAsyncPhase == DBASYNCHPHASE_POPULATION)
        hr = WBEM_S_PENDING;

    return hr;
}

//***************************************************************************
//
//  CSQLExecute::CancelQuery
//
//***************************************************************************
HRESULT CSQLExecute::CancelQuery(IDBAsynchStatus *pIAsync)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (pIAsync)
    {
        hr = pIAsync->Abort(DB_NULL_HCHAPTER, DBASYNCHOP_OPEN);
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecute::GetNumColumns
//
//***************************************************************************

HRESULT CSQLExecute::GetNumColumns(IRowset *pIRowset, IMalloc *pMalloc, int &iNumCols)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DBCOLUMNINFO*   pColumnsInfo = NULL;
    IColumnsInfo*   pIColumnsInfo = NULL;    
    OLECHAR*        pColumnStrings = NULL;  
    ULONG           uNum;

    pIRowset->QueryInterface(IID_IColumnsInfo, (void**) &pIColumnsInfo);
    CReleaseMe r (pIColumnsInfo);
    hr = pIColumnsInfo->GetColumnInfo(&uNum, &pColumnsInfo, &pColumnStrings);    

    pMalloc->Free( pColumnsInfo );    
    pMalloc->Free( pColumnStrings );

    if (SUCCEEDED(hr))
        iNumCols = (int)uNum;

    return hr;
}

//***************************************************************************
//
//  CSQLExecute::GetDataType
//
//***************************************************************************

HRESULT CSQLExecute::GetDataType(IRowset *pIRowset, int iPos, IMalloc *pMalloc, DWORD &dwType,
                                 DWORD &dwSize, DWORD &dwPrec, DWORD &dwScale, LPWSTR *lpColName)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    DBCOLUMNINFO*   pColumnsInfo = NULL;
    IColumnsInfo*   pIColumnsInfo = NULL;    
    OLECHAR*        pColumnStrings = NULL;  
    ULONG           uNum;
    BYTE*           pRowValues = NULL;

    pIRowset->QueryInterface(IID_IColumnsInfo, (void**) &pIColumnsInfo);
    CReleaseMe r (pIColumnsInfo);
    hr = pIColumnsInfo->GetColumnInfo(&uNum, &pColumnsInfo, &pColumnStrings);    
    if (SUCCEEDED(hr) && uNum >= iPos)
    {
        dwSize = pColumnsInfo[iPos-1].ulColumnSize;
        dwPrec = pColumnsInfo[iPos-1].bPrecision;
        dwScale = pColumnsInfo[iPos-1].bScale;
        dwType = pColumnsInfo[iPos-1].wType;
        if (lpColName)
            *lpColName = Macro_CloneLPWSTR(pColumnsInfo[iPos-1].pwszName);
    }
    else
    {
        dwType = 0;
        dwSize = 0;
        dwPrec = 0;
        dwScale = 0;
    }

    pMalloc->Free( pColumnsInfo );    
    pMalloc->Free( pColumnStrings );

    return hr;

}

//***************************************************************************
//
//  CSQLExecute::GetColumnValue
//
//***************************************************************************
HRESULT CSQLExecute::GetColumnValue(IRowset *pIRowset, int iPos, IMalloc *pMalloc, HROW **ppRow, 
                                    VARIANT &vValue, LPWSTR * lpColName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwType;
    DWORD           dwOrigType ;
    IAccessor*      pIAccessor=NULL;        // Pointer to the
                                            // accessor
    HACCESSOR       hAccessor;              // Accessor handle
    HROW            *pRows = NULL;
    ULONG           cRowsObtained;          // Count of rows
                                            // obtained
    DBBINDSTATUS*   pDBBindStatus = NULL;    
    DBBINDING*      pDBBindings = NULL;
    OLEDBDATA       data;

    VariantClear(&vValue);

    if (!ppRow)
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        if (*ppRow)
        {
            pRows = *ppRow;
        }
        else
        {
            HROW *hRow = new HROW[1];
            if (!hRow)
                return WBEM_E_OUT_OF_MEMORY;

            pRows = &hRow[0];
            hr = pIRowset->GetNextRows(            0,                  // Reserved
                0,                  // cRowsToSkip
                1,                  // cRowsDesired
                &cRowsObtained,     // cRowsObtained
                &pRows );           // Filled in w/ row handles.

            if (hr != DB_S_ENDOFROWSET && SUCCEEDED(hr))
            {
                *ppRow = pRows;
            }
        }
      
        if (hr != DB_S_ENDOFROWSET && SUCCEEDED(hr))
        {
            DWORD dwSize = 0, dwPrec = 0, dwScale = 0;

            hr = GetDataType(pIRowset, iPos, pMalloc, dwType, dwSize, dwPrec, dwScale, lpColName);
            if (SUCCEEDED(hr))
            {
                dwOrigType = dwType;

                if (dwType == DBTYPE_DATE || dwType == DBTYPE_DBDATE)
                {
                    dwType = DBTYPE_DBTIMESTAMP;
                    dwSize = sizeof(DBTIMESTAMP)+1;
                }
                else if (dwType == DBTYPE_CY ||
                    (dwType == DBTYPE_NUMERIC && dwScale > 0) ||
                    dwType == DBTYPE_GUID)
                {
                    dwType = DBTYPE_WSTR;
                    dwSize = 100;
                }

                pDBBindings = new DBBINDING[1];
                CDeleteMe <DBBINDING> r5 (pDBBindings);
                if (!pDBBindings)
                    return WBEM_E_OUT_OF_MEMORY;

                pDBBindings[0].iOrdinal = iPos;
                pDBBindings[0].obValue = offsetof(OLEDBDATA, data);
                pDBBindings[0].obLength = offsetof(OLEDBDATA, dwLen);        
                pDBBindings[0].obStatus = offsetof(OLEDBDATA, dwStatus);
                pDBBindings[0].pTypeInfo = NULL;
                pDBBindings[0].pObject = NULL;
                pDBBindings[0].pBindExt = NULL;
                pDBBindings[0].dwPart =  DBPART_VALUE | DBPART_STATUS | DBPART_LENGTH;
                pDBBindings[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
                pDBBindings[0].eParamIO = DBPARAMIO_NOTPARAM;
                pDBBindings[0].wType = dwType;

                if (dwSize > 65535)
                    dwSize = 65535;

                if (dwType == DBTYPE_WSTR ||
                    dwType == DBTYPE_STR || 
                    dwType == DBTYPE_BSTR)
                    pDBBindings[0].cbMaxLen = dwSize+1;
                else
                    pDBBindings[0].cbMaxLen = dwSize;

                pDBBindings[0].dwFlags = 0;        
                pDBBindings[0].bPrecision = dwPrec;
                pDBBindings[0].bScale = dwScale;

                pDBBindStatus = new DBBINDSTATUS[1];
                CDeleteMe <DBBINDSTATUS> r6 (pDBBindStatus);
                if (!pDBBindStatus)
                    return WBEM_E_OUT_OF_MEMORY;

                pIRowset->QueryInterface(IID_IAccessor, (void**) &pIAccessor);
                CReleaseMe r7 (pIAccessor);
                hr = pIAccessor->CreateAccessor(
                    DBACCESSOR_ROWDATA,// Accessor will be used to retrieve row
                                        // data
                    1,             // Number of columns being bound
                    pDBBindings,       // Structure containing bind info
                    0,                 
                    &hAccessor,        // Returned accessor handle
                    pDBBindStatus      // Information about binding validity        
                 );

                if (SUCCEEDED(hr))
                {
                     hr = pIRowset->GetData(*pRows, hAccessor, &data);
                     VariantClear(&vValue);
                     if (data.dwStatus != DBSTATUS_S_ISNULL)
                         SetVariant(dwType, &vValue, data.data, dwOrigType);
                     else
                         vValue.vt = VT_NULL;

                     hr = WBEM_S_NO_ERROR;
                }
                
            }            

            pIAccessor->ReleaseAccessor(hAccessor, NULL);    
        }
    }

    if (hr == DB_S_ENDOFROWSET)
        hr = WBEM_S_NO_MORE_DATA;

    return hr;
}

//***************************************************************************
//
//  CSQLExecute::ReadImageValue
//
//***************************************************************************

HRESULT CSQLExecute::ReadImageValue (IRowset *pIRowset, int iPos, HROW **ppRow, BYTE **ppBuffer, DWORD &dwLen)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IAccessor*      pIAccessor;             // Pointer to the
            
    DBOBJECT        ObjectStruct;
    HACCESSOR       hAccessor;              // Accessor handle
    ULONG           cRowsObtained;          // Count of rows
                                            // obtained
    DBBINDSTATUS*   pDBBindStatus = NULL;    
    DBBINDING       *pDBBindings = NULL;

    ObjectStruct.dwFlags = STGM_READ; 
    ObjectStruct.iid = IID_ISequentialStream;

    HROW*           pRows = NULL;
    unsigned long   cbRead;            // Count of bytes read
    BLOBDATA        BLOBGetData;

    if (!ppRow)
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        if (*ppRow)
        {
            pRows = *ppRow;
        }
        else
        {
            HROW *hRow = new HROW[1];
            if (!hRow)
                return WBEM_E_OUT_OF_MEMORY;

            pRows = &hRow[0];
            hr = pIRowset->GetNextRows(            0,                  // Reserved
                0,                  // cRowsToSkip
                1,                  // cRowsDesired
                &cRowsObtained,     // cRowsObtained
                &pRows );           // Filled in w/ row handles.

            if (hr != DB_S_ENDOFROWSET && SUCCEEDED(hr))
            {
                *ppRow = pRows;
            }
        }
    }

    dwLen = 0;    

    if (hr != DB_S_ENDOFROWSET && SUCCEEDED(hr))
    {
        pDBBindings = new DBBINDING[1];
        if (!pDBBindings)
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe <DBBINDING> d (pDBBindings);
        pDBBindings[0].iOrdinal = iPos;
        pDBBindings[0].obValue = offsetof(BLOBDATA, pISeqStream);
        pDBBindings[0].obLength = offsetof(BLOBDATA, dwLength);        
        pDBBindings[0].obStatus = offsetof(BLOBDATA, dwStatus);
        pDBBindings[0].pTypeInfo = NULL;
        pDBBindings[0].pObject = &ObjectStruct;
        pDBBindings[0].pBindExt = NULL;
        pDBBindings[0].dwPart = DBPART_VALUE | DBPART_STATUS | DBPART_LENGTH;
        pDBBindings[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        pDBBindings[0].eParamIO = DBPARAMIO_NOTPARAM;
        pDBBindings[0].wType = DBTYPE_IUNKNOWN;
        pDBBindings[0].cbMaxLen = 0;
        pDBBindings[0].dwFlags = 0;        
        pDBBindings[0].bPrecision = 0;
        pDBBindings[0].bScale = 0;

        pDBBindStatus = new DBBINDSTATUS[1];        
        if (!pDBBindStatus)
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe <DBBINDSTATUS> d1 (pDBBindStatus);
    
        pIRowset->QueryInterface(IID_IAccessor, (void**) &pIAccessor);
        CReleaseMe r1 (pIAccessor);

        hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1,
            pDBBindings, 0, &hAccessor, pDBBindStatus);

        if (FAILED(hr))
            hr = WBEM_E_OUT_OF_MEMORY;
        else
        {
            DWORD dwTotal = 0;

            // Get the row data, the pointer to an ISequentialStream*.

             hr = pIRowset->GetData(*pRows, hAccessor, &BLOBGetData);
            if (SUCCEEDED(hr) && BLOBGetData.dwStatus == DBSTATUS_S_OK)
            {
                ISequentialStream *pStream = BLOBGetData.pISeqStream;
                CReleaseMe r (pStream);

                DWORD dwSize = BLOBGetData.dwLength; 

                BYTE *pbTemp = NULL;
                pbTemp =  (BYTE *)CWin32DefaultArena::WbemMemAlloc(dwSize);
                if (!pbTemp)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {   
                    ZeroMemory(pbTemp, dwSize);
                    *ppBuffer = pbTemp;                    

                    hr = pStream->Read(pbTemp, dwSize, &cbRead);                   
                    if (hr == S_OK)
                        dwLen = cbRead;                    
                    else
                        hr = WBEM_E_FAILED;
                }   
            }

            pIAccessor->ReleaseAccessor(hAccessor, NULL);
        }

    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecute::WriteImageValue
//
//***************************************************************************

HRESULT CSQLExecute::WriteImageValue(IDBCreateCommand *pIDBCreateCommand, LPCWSTR lpSQL, int iPos, BYTE *pValue, DWORD dwLen)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IAccessor*      pIAccessor;             // Pointer to the
            
    DBOBJECT        ObjectStruct;
    HACCESSOR       hAccessor;              // Accessor handle
    ULONG           cRowsObtained;          // Count of rows
                                            // obtained
    DBBINDSTATUS*   pDBBindStatus = NULL;    
    DBBINDING       *pDBBindings = NULL;

    HROW*           pRows = NULL;
    LONG            lRows;
    ICommandText*       pICommandText       = NULL;
    ICommandProperties* pICommandProperties = NULL;
    IRowset         *pIRowset = NULL;
    IRowsetChange   *pRowsetChg = NULL;

    ObjectStruct.dwFlags = STGM_READ; 
    ObjectStruct.iid = IID_ISequentialStream;

    BLOBDATA BLOBSetData;
    DBPROPSET   rgPropSets[1];
    DBPROP      rgProperties[1];
    const ULONG cProperties = 1;
    rgPropSets[0].guidPropertySet = DBPROPSET_ROWSET;
    rgPropSets[0].cProperties = cProperties;
    rgPropSets[0].rgProperties = rgProperties;

    //Now set properties in the property group (DBPROPSET_ROWSET)
    rgPropSets[0].rgProperties[0].dwPropertyID = DBPROP_UPDATABILITY;
    rgPropSets[0].rgProperties[0].dwOptions = DBPROPOPTIONS_REQUIRED;
    rgPropSets[0].rgProperties[0].dwStatus = DBPROPSTATUS_OK;
    rgPropSets[0].rgProperties[0].colid = DB_NULLID;
    rgPropSets[0].rgProperties[0].vValue.vt = VT_I4;
    V_I4(&rgPropSets[0].rgProperties[0].vValue) = DBPROPVAL_UP_CHANGE;

    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);    
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {
        //Set the rowset properties
        hr = pICommandText->QueryInterface(IID_ICommandProperties,
                                (void **)&pICommandProperties);
        CReleaseMe r (pICommandProperties);
        if (SUCCEEDED(hr))
        {

            hr = pICommandProperties->SetProperties(1, rgPropSets);                       

            pICommandText->SetCommandText(DBGUID_DBSQL, lpSQL);

            ICommand *pICommand = NULL;
            pICommandText->QueryInterface(IID_ICommand,
                (void **) & pICommand);
            CReleaseMe r2 (pICommand);

            hr = pICommand->Execute(NULL, IID_IRowsetChange, NULL,
                 &lRows, (IUnknown**) &pRowsetChg);    
            CReleaseMe r3 (pRowsetChg);

            if (FAILED(hr))
            {
                int i = 0;
                hr = GetWMIError(pICommand);
            }
            else
            {
                hr = pRowsetChg->QueryInterface(IID_IRowset, 
                                                    (void **)&pIRowset);
                CReleaseMe r4 (pIRowset);
                if (SUCCEEDED(hr))
                {

                    HROW *hRow = new HROW[1];
                    if (!hRow)
                        return WBEM_E_OUT_OF_MEMORY;
                    pRows = &hRow[0];
                    hr = pIRowset->GetNextRows(            0,                  // Reserved
                        0,                  // cRowsToSkip
                        1,                  // cRowsDesired
                        &cRowsObtained,     // cRowsObtained
                        &pRows );           // Filled in w/ row handles.
                    CDeleteMe <HROW> d0 (hRow);
                    if (SUCCEEDED(hr))
                    {   
                        pDBBindings = new DBBINDING[1];
                        if (!pDBBindings)
                            return WBEM_E_OUT_OF_MEMORY;
                        CDeleteMe <DBBINDING> d1 (pDBBindings);

                        pDBBindings[0].iOrdinal = iPos;
                        pDBBindings[0].obValue = offsetof(BLOBDATA, pISeqStream);
                        pDBBindings[0].obLength = offsetof(BLOBDATA, dwLength);        
                        pDBBindings[0].obStatus = offsetof(BLOBDATA, dwStatus);
                        pDBBindings[0].pTypeInfo = NULL;
                        pDBBindings[0].pObject = &ObjectStruct;
                        pDBBindings[0].pBindExt = NULL;
                        pDBBindings[0].dwPart = DBPART_VALUE | DBPART_STATUS | DBPART_LENGTH;
                        pDBBindings[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
                        pDBBindings[0].eParamIO = DBPARAMIO_NOTPARAM;
                        pDBBindings[0].wType = DBTYPE_IUNKNOWN;
                        pDBBindings[0].cbMaxLen = 0;
                        pDBBindings[0].dwFlags = 0;        
                        pDBBindings[0].bPrecision = 0;
                        pDBBindings[0].bScale = 0;

                        pDBBindStatus = new DBBINDSTATUS[1];      
                        if (!pDBBindStatus)
                            return WBEM_E_OUT_OF_MEMORY;
                        CDeleteMe <DBBINDSTATUS> d2 (pDBBindStatus);

                        hr = pIRowset->QueryInterface(IID_IAccessor, (void**) &pIAccessor);
                        CReleaseMe r5 (pIAccessor);
                        if (SUCCEEDED(hr))
                        {
                            hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1,
                                pDBBindings, 0, &hAccessor, pDBBindStatus);

                            CSeqStream *pSeqStream = new CSeqStream;
                            if (!pSeqStream)
                                return WBEM_E_OUT_OF_MEMORY;

                            pSeqStream->Write(pValue, dwLen, NULL);
                            BLOBSetData.pISeqStream = pSeqStream;
                            BLOBSetData.dwStatus = DBSTATUS_S_OK;
                            BLOBSetData.dwLength = pSeqStream->Length();

                            hr = pRowsetChg->SetData(pRows[0], hAccessor, &BLOBSetData);
                            if (FAILED(hr))
                                hr = GetWMIError(pICommand);

                            pIAccessor->ReleaseAccessor(hAccessor, NULL);
                        }
                        pIRowset->ReleaseRows(1, pRows, NULL, NULL, NULL);
                    }
                }
            }
        }       
    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecute::SetVariant
//
//***************************************************************************
void CSQLExecute::SetVariant(DWORD dwType, VARIANT *vValue, BYTE *pData, DWORD dwTargetType)
{

    vValue->vt = VT_NULL;
    BYTE *pBuffer = NULL;
    wchar_t *wTemp = NULL;

    switch(dwType)
    {
    case DBTYPE_DBTIMESTAMP:
        if (*pData)
        {
            DBTIMESTAMP *pTime = ((DBTIMESTAMP *)pData);
            wchar_t szTmp[100];
            swprintf(szTmp, L"%04d%02d%02d%02d%02d%02d.%06d+000",
                pTime->year, pTime->month, pTime->day, pTime->hour, 
                pTime->minute, pTime->second, pTime->fraction);

            V_BSTR(vValue) = SysAllocString((LPWSTR)szTmp);
            vValue->vt = VT_BSTR;
        }
        break;

    case DBTYPE_STR:
        wTemp = new wchar_t[(strlen((const char *)pData)*2)];
        if (wTemp)
        {
            swprintf(wTemp, L"%S", (const char *)pData);
            V_BSTR(vValue) = SysAllocString(wTemp);
            vValue->vt = VT_BSTR;
            delete wTemp;
        }

        break;
    case DBTYPE_WSTR:
    case DBTYPE_BSTR:
        V_BSTR(vValue) = SysAllocString((LPWSTR)pData);
        vValue->vt = VT_BSTR;
        break;

    case DBTYPE_I4:
    case DBTYPE_UI4:
        if (*((long *)pData) != NULL)
            V_I4(vValue) = *((long *)pData);            
        else
            V_I4(vValue) = 0;            
        vValue->vt = VT_I4;

        break;
    case DBTYPE_I2:
    case DBTYPE_UI2:
        if (*((short *)pData) != NULL)
            V_I4(vValue) = *((short *)pData);
        else
            V_I4(vValue) = 0;
        vValue->vt = VT_I4; // We are expecting the short ints to come out as long...
        break;

    case DBTYPE_I1:
    case DBTYPE_UI1:
        V_UI1(vValue) = *((BYTE *)pData);
        vValue->vt = VT_UI1;      
        break;

    case DBTYPE_BOOL:
        V_BOOL(vValue) = (*((BOOL *)pData) ? TRUE: FALSE);
        vValue->vt = VT_BOOL;
        break;

    case DBTYPE_R4:
        if (*((float *)pData) != NULL)
        {
            vValue->fltVal = (*((float *)pData));            
        }
        else
            vValue->fltVal = 0;            
        vValue->vt = VT_R4;
        break;
    case DBTYPE_R8:
        if (*((double *)pData) != NULL)
        {
            vValue->dblVal = (*((double *)pData));            
        }
        else
            vValue->dblVal = 0;            
        vValue->vt = VT_R8;
        break;

    case DBTYPE_I8:
    case DBTYPE_UI8:
    case DBTYPE_NUMERIC:
        if (*pData != NULL)
        {
            wchar_t *pwTemp = NULL;
            long lRet;
            short sRet;
            BYTE bRet;

            DB_NUMERIC *pTemp = ((DB_NUMERIC *)pData);
            switch(dwTargetType)
            {
            case DBTYPE_I8:
            case DBTYPE_UI8:
            case DBTYPE_NUMERIC:
                GetInt64(pTemp, &pwTemp);                
                vValue->bstrVal = SysAllocString(pwTemp);
                vValue->vt = VT_BSTR;
                delete pwTemp;
                break;
            case DBTYPE_I4:
            case DBTYPE_UI2:
            case DBTYPE_UI4:
                lRet = (*((long *)pTemp->val));
                vValue->lVal = lRet;
                if (!pTemp->sign) vValue->lVal *= -1;
                vValue->vt = VT_I4;
                break;
            case DBTYPE_I2:
                sRet = *((short *)pTemp->val);
                V_I2(vValue) = sRet;
                vValue->vt = VT_I2;
                if (!pTemp->sign) V_I2(vValue) *= -1;
                break;
            case CIM_BOOLEAN:
                V_BOOL(vValue) = *((BOOL *)pTemp->val)?true:false;
                vValue->vt = VT_BOOL;
                break;
            case DBTYPE_UI1:
            case DBTYPE_I1:
            case CIM_CHAR16:
                bRet = *((BYTE *)pTemp->val);
                V_UI1(vValue) = bRet;
                vValue->vt = VT_UI1;
                break;
            }
        }
        break;                
    case DBTYPE_BYTES:
        // UINT8|ARRAY
        // We have to set this as an array of bytes.
        

        // vValue->pbVal = (BYTE *)pData;

        // vValue->vt = VT_UI1|VT_ARRAY;    // ?? Is this right? TBD         
        break;                
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlit.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlit.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _SQLIT_H_
#define _SQLIT_H_

#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#include <sqlexec.h>

//***************************************************************************
//  CWmiDbIterator
//***************************************************************************

class CWmiDbIterator : public IWmiDbIterator
{
    friend class CWmiDbSession;
public:
    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );

    virtual HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ DWORD dwFlags) ;
    
    virtual HRESULT STDMETHODCALLTYPE NextBatch( 
        /* [in] */ DWORD dwNumRequested,
        /* [in] */ DWORD dwTimeOutSeconds,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [in] */ REFIID riid,
        /* [out] */ DWORD __RPC_FAR *pdwNumReturned,
        /* [iid_is][length_is][size_is][out] */ LPVOID __RPC_FAR *ppObjects);

    CWmiDbIterator();
    ~CWmiDbIterator();

protected:

    IDBAsynchStatus *m_pStatus;
    IRowset *m_pRowset;
    CSQLConnection *m_pConn;
    ULONG m_uRefCount;
    CWmiDbSession *m_pSession;
    IMalloc *m_pIMalloc;
};

//*******************************************************
//
// CSQLExec
//
//*******************************************************

// This needs to deal with blob data,
// and support batching.

 class _declspec( dllexport ) CSQLExecuteRepdrvr : CSQLExecute
{
     typedef std::map <DWORD, DWORD> Properties;
public:
    static HRESULT GetNextResultRows(int iNumRows, IRowset *pIRowset, IMalloc *pMalloc, IWbemClassObject *pNewObj,
        CSchemaCache *pSchema, CWmiDbSession *pSession, Properties &PropIds, bool *bImageFound=NULL, bool bOnImage = false);    

private:

    CSQLExecuteRepdrvr(){};
    ~CSQLExecuteRepdrvr(){};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlcache.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlutils.h
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#ifndef _SQLCACHE_H_
#define _SQLCACHE_H_

// This file defines a class that maintains a cache of 
// SQL connections. Each instance of this class only 
// contains one set of logon credentials.
// Each controller by default is only entitled to
// a maximum of 20 connections.
// ===================================================

#define ROOTNAMESPACEID -1411745643584611171
#define NAMESPACECLASSID 2372429868687864876
#define MAPPEDNSCLASSID  -7061265575274197401
#define INSTANCESCLASSID 3373910491091605771
#define CONTAINERASSOCID -7316356768687527881
#define CLASSSECURITYID  -6648033040106090009
#define CLASSESID        864779262989765648
#define CLASSINSTSECID   3879906028937869252
#define THISNAMESPACEID  8909346217325131296

#include <std.h>
#include <seqstream.h>
#include <comutil.h>
#include <objcache.h>


typedef struct InsertQualifierValues
{
    int iPropID;       // internal property ID 
    wchar_t *pValue;   // Value
    wchar_t *pRefKey;  // The key string, if a reference property.
    int iPos;          // Array position
    int iQfrID;        // ID of qualifier or method dependency
    int iFlavor;       // Qualifier flavor, if applicable.
    bool bLong;        // TRUE if this is too long for this op sys
    int iStorageType;  // our internal storage type
    bool bIndexed;     // TRUE if indexed
    SQL_ID dClassId;   // The actual Class ID of this property
    InsertQualifierValues()
    {
        pValue = NULL, pRefKey = NULL, iPos = 0, iQfrID = 0, iFlavor = 0,
            bLong = FALSE, iStorageType = 0, bIndexed = FALSE, dClassId = 0;
    }
} InsertQfrValues;

typedef InsertQfrValues InsertPropValues;

// Structs to facilitate passing OLE DB parameters

typedef struct tagBATCHPARAMS
{
    DB_NUMERIC dObjectId;       // @ObjectId
    DB_NUMERIC dScopeId;        // @ScopeID
    DB_NUMERIC dClassId;        // @ClassID
    int        iQfrId[5];       // @QfrId[0-4]
    BSTR       sPropValue[5];   // @QfrValue[0-4]
    int        iPos[5];         // @QfrPos[0-4]
    int        iPropId[5];      // @PropID[0-4]
    int        iFlavor[5];      // @Flavor[0-4]
} BATCHPARAMS;


// SQL procedures
#define SQL_POS_INSERT_CLASS       0x0
#define SQL_POS_INSERT_CLASSDATA   0x1
#define SQL_POS_INSERT_BATCH       0x2
#define SQL_POS_INSERT_PROPBATCH   0x4
#define SQL_POS_INSERT_BLOBDATA    0x8
#define SQL_POS_HAS_INSTANCES      0x10
#define SQL_POS_OBJECTEXISTS       0x20
#define SQL_POS_GETCLASSOBJECT     0x40

// Jet tables
#define SQL_POS_OBJECTMAP          0x0
#define SQL_POS_CLASSMAP           0x1
#define SQL_POS_PROPERTYMAP        0x2
#define SQL_POS_CLASSDATA          0x4
#define SQL_POS_CLASSIMAGES        0x8
#define SQL_POS_INDEXSTRING        0x10
#define SQL_POS_INDEXNUMERIC       0x20
#define SQL_POS_INDEXREAL          0x40
#define SQL_POS_INDEXREF           0x80

#define SQL_POS_ICOMMANDTEXT       0x00010000
#define SQL_POS_ICOMMANDWITHPARAMS 0x00020000
#define SQL_POS_IACCESSOR          0x00040000
#define SQL_POS_HACCESSOR          0x00080000
#define SQL_POS_IOPENROWSET        0x00100000
#define SQL_POS_IROWSETCHANGE      0x00200000
#define SQL_POS_IROWSETINDEX       0x00400000
#define SQL_POS_IROWSET            0x00800000

#define SQL_POS_PKINDEX            0x0
#define SQL_POS_INDEX2             0x100
#define SQL_POS_INDEX3             0x200

typedef struct 
{
    HACCESSOR hAcc;
    IUnknown *pUnk;

} WmiDBObject;

class CDBObjectManager
{
public:
    CDBObjectManager();
    ~CDBObjectManager();

    void Empty();
    void * GetObject(DWORD type);
    void SetObject(DWORD type, void * pNew);
    void DeleteObject(DWORD type);

private:
    CHashCache<WmiDBObject*> m_Objs;
};


class _declspec( dllexport ) CSQLConnection
{
public:
    CSQLConnection() {m_dwThreadId = GetCurrentThreadId(), m_bIsDistributed = FALSE;};
    virtual ~CSQLConnection () {};

    DWORD        m_dwThreadId;
    BOOL         m_bIsDistributed;

};

//***************************************************************************
//
//  CSQLConnCache
//
//***************************************************************************

 class CSQLConnCache
{
    typedef std::vector <CSQLConnection *> ConnVector;
    typedef std::vector <HANDLE> HandleVector;
public:
    CSQLConnCache(DBPROPSET *pPropSet = NULL, DWORD dwMaxConns = 15, 
        DWORD dwTimeout = 600);
    ~CSQLConnCache();

    HRESULT SetCredentials(DBPROPSET *pPropSet);
    HRESULT SetMaxConnections (DWORD dwMax);
    HRESULT SetTimeoutSecs(DWORD dwSecs);
    HRESULT SetDatabase(LPCWSTR lpDBName);

    HRESULT GetConnection(CSQLConnection **ppConn, BOOL bTransacted = FALSE, 
        BOOL bDistributed = FALSE,DWORD dwTimeOutSecs = 600);
    HRESULT ReleaseConnection(CSQLConnection *pConn, 
            HRESULT retcode = WBEM_S_NO_ERROR, BOOL bDistributed = FALSE);
    HRESULT DeleteUnusedConnections(BOOL bDeadOnly=FALSE);
    // Distrubuted only
    HRESULT FinalRollback(CSQLConnection *pConn);
    HRESULT FinalCommit(CSQLConnection *pConn);

    HRESULT GetCredentials(DBPROPSET **ppPropSet);
    HRESULT GetMaxConnections (DWORD &dwMax);
    HRESULT GetTimeoutSecs (DWORD &dwSecs);
    HRESULT GetDatabase(_bstr_t &sName);

    HRESULT ClearConnections();
    HRESULT Shutdown();

private:
    HRESULT ExecInitialQueries(IDBInitialize *pDBInit, CSQLConnection *pConn);

    CRITICAL_SECTION m_cs;
    ConnVector   m_Conns;
    DBPROPSET   *m_pPropSet;
    DWORD        m_dwMaxNumConns;
    DWORD        m_dwTimeOutSecs;
    _bstr_t      m_sDatabaseName;
    HandleVector m_WaitQueue;
    BOOL         m_bInit;
    DWORD        m_dwStatus;
};


#endif  // _SQLCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\std.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 

#include "precomp.h"
#include <comutil.h>
#include <map>
#include <vector>
#include <oledb.h>
#include <oledberr.h> 
#include <sqloledb.h>
#include <flexarry.h>
#include <wstring.h>
#include <wqlnode.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <time.h>
#include <reposit.h>
#include <wqltosql.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlit.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlit.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _SQLIT_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#define DBINITCONSTANTS // Initialize OLE constants...
#define INITGUID        // ...once in each app.
#define _WIN32_DCOM
#include "precomp.h"

#include <std.h>
#include <sqlutils.h>
#include <repdrvr.h>
#include <sqlit.h>
#include <wbemint.h>

//***************************************************************************
//
//  CWmiDbIterator::CWmiDbIterator
//
//***************************************************************************

CWmiDbIterator::CWmiDbIterator()
{
    m_pStatus = NULL;
    m_pRowset = NULL;
    m_pSession = NULL;
    m_pIMalloc = NULL;
    m_pConn = NULL;
    m_uRefCount = 0;
}

//***************************************************************************
//
//  CWmiDbIterator::~CWmiDbIterator
//
//***************************************************************************
CWmiDbIterator::~CWmiDbIterator()
{
    Cancel(0);
    if (m_pSession)
        m_pSession->Release();
    if (m_pIMalloc)
        m_pIMalloc->Release();
}

//***************************************************************************
//
//  CWmiDbIterator::QueryInterface
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbIterator::QueryInterface
        (REFIID riid,
        void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_IWmiDbIterator==riid )
    {
        *ppvObject = (IWmiDbIterator *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//  CWmiDbIterator::AddRef
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiDbIterator::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//  CWmiDbIterator::Release
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiDbIterator::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return WBEM_S_NO_ERROR;
}
//***************************************************************************
//
//  CWmiDbIterator::Cancel
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbIterator::Cancel( 
    /* [in] */ DWORD dwFlags) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = CSQLExecute::CancelQuery(m_pStatus);

    if (m_pStatus)
        m_pStatus->Release();
    m_pStatus = NULL;

    if (m_pConn)
    {
        ((CWmiDbController *)m_pSession->m_pController)->ConnCache.ReleaseConnection(m_pConn, hr);
        m_pConn = NULL;
    }

    if (m_pRowset)
        m_pRowset->Release();
    m_pRowset = NULL;

    return hr;
}

//***************************************************************************
//
//  CWmiDbIterator::NextBatch
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbIterator::NextBatch( 
    /* [in] */ DWORD dwNumRequested,
    /* [in] */ DWORD dwTimeOutSeconds,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwNumReturned,
    /* [iid_is][length_is][size_is][out] */ LPVOID __RPC_FAR *ppObjects)
{

    HRESULT hr = WBEM_S_NO_ERROR, hrRet = WBEM_S_NO_ERROR;
    bool bImmediate = !(dwRequestedHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED);

    if (!m_pSession || !(m_pSession->m_pController) || 
        ((CWmiDbController *)m_pSession->m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (!dwNumRequested || !ppObjects)
        return WBEM_E_INVALID_PARAMETER;

    if (dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID &&
        riid == IID_IWmiDbHandle)
        return WBEM_E_INVALID_PARAMETER;

    // FIXME: We need to create a readahead cache.
    
    if (dwFlags & WMIDB_FLAG_LOOKAHEAD || 
        (riid != IID_IWmiDbHandle &&
         riid != IID_IWbemClassObject &&
         riid != IID__IWmiObject))
        /// UuidCompare(pIIDRequestedInterface, &IID_IWmiDbHandle, NULL) ||
        // UuidCompare(pIIDRequestedInterface, &IID_IWbemClassObject, NULL))
        return WBEM_E_NOT_SUPPORTED;

    if (pdwNumReturned)
        *pdwNumReturned = 0;

    if (!m_pStatus && !m_pRowset)
        return WBEM_S_NO_MORE_DATA;

    // For each ObjectId, do we instantiate a new handle,
    // and increment a background ref count on the object itself?
    // How do we keep track of the handles that are in use??

    try
    {

        HROW *pRow = NULL;
        VARIANT vTemp;
        VariantInit(&vTemp);
        int iNumRetrieved = 0;
        IRowset *pIRowset = NULL;

        if (m_pStatus)
        {
            hr = CSQLExecute::IsDataReady(m_pStatus);
    
            // TO DO: Wait if we are pending.  Fail for now.

            if (SUCCEEDED(hr))
            {            
                hr = m_pStatus->QueryInterface(IID_IRowset, (void **)&pIRowset);
            }
        }
        else
            pIRowset = m_pRowset;

        if (SUCCEEDED(hr) && pIRowset)
        {
            // TO DO: Take the timeout value into consideration!!!
    
            hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
            while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA && iNumRetrieved < dwNumRequested)
            {

                if (!m_pSession || !(m_pSession->m_pController) || 
                    ((CWmiDbController *)m_pSession->m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
                {
                    hrRet = WBEM_E_SHUTTING_DOWN;
                    break;
                }

                // At this point, we need to check the cache
                // to make sure we don't already have one of these,
                // and that its not locked.
    
                SQL_ID dID = 0;
            
                if (vTemp.vt == VT_BSTR)
                    dID = _wtoi64(vTemp.bstrVal);
                else if (vTemp.vt == VT_I4)
                    dID = vTemp.lVal;

                SQL_ID dClassID = 0, dScopeID = 0;
                DWORD dwLockType = 0;

                VariantClear(&vTemp);
                hr = CSQLExecute::GetColumnValue(pIRowset, 2, m_pIMalloc, &pRow, vTemp);
                if (vTemp.vt == VT_BSTR)
                    dClassID = _wtoi64(vTemp.bstrVal);
                else if (vTemp.vt == VT_I4)
                    dClassID = vTemp.lVal;

                VariantClear(&vTemp);
                hr = CSQLExecute::GetColumnValue(pIRowset, 3, m_pIMalloc, &pRow, vTemp);

                if (vTemp.vt == VT_BSTR)
                    dScopeID = _wtoi64(vTemp.bstrVal);
                else if (vTemp.vt == VT_I4)
                    dScopeID = vTemp.lVal;

                VariantClear(&vTemp);

                //hr = ((CWmiDbSession *)m_pSession)->VerifyObjectSecurity(NULL, dID, dClassID, dScopeID, 0, WBEM_ENABLE);
                if (SUCCEEDED(hr))
                {
                    CWmiDbHandle *pTemp = new CWmiDbHandle;
                    if (pTemp)
                    {
                        DWORD dwVersion = 0;
                        // Obtain a lock for this object
                        // =============================  
                        pTemp->m_pSession = m_pSession;

                        hr = ((CWmiDbController *)m_pSession->m_pController)->LockCache.AddLock(bImmediate, dID, dwRequestedHandleType, pTemp, 
                            dScopeID, dClassID, &((CWmiDbController *)m_pSession->m_pController)->SchemaCache, false,
                            0, 0, &dwVersion);

                        if (FAILED(hr))
                        {
                            delete pTemp;
                            // If they failed to get a handle, what do we do?
                            // Ignore it and continue, I guess.
                            hrRet = WBEM_S_PARTIAL_RESULTS;
                            ppObjects[iNumRetrieved] = NULL;
                    
                        }
                        else
                        {               
                            ((CWmiDbController *)m_pSession->m_pController)->AddHandle();
                            pTemp->AddRef();
                            pTemp->m_dwVersion = dwVersion;
                            pTemp->m_dwHandleType = dwRequestedHandleType;
                            pTemp->m_dClassId = dClassID;
                            pTemp->m_dObjectId = dID;
                            if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                                pTemp->m_bSecDesc = TRUE;

                            if (pTemp->m_dClassId == MAPPEDNSCLASSID)
                                pTemp->m_bDefault = FALSE;

                            pTemp->m_dScopeId = dScopeID;

                            if (riid == IID_IWmiDbHandle)
                            {
                                ppObjects[iNumRetrieved] = pTemp;
                                iNumRetrieved++;
                            }
                            else if (riid == IID_IWbemClassObject ||
                                riid == IID__IWmiObject)
                            {
                                IWbemClassObject *pTemp2 = NULL;
                                hr = pTemp->QueryInterface(IID_IWbemClassObject, (void **)&pTemp2);
                                ppObjects[iNumRetrieved] = pTemp2;
                                if (FAILED(hr))
                                    hrRet = WBEM_S_PARTIAL_RESULTS;
                                else
                                    iNumRetrieved++;
                                pTemp->Release();
                            }
                        }
                    }
                    else
                    {
                        // *pQueryResult = NULL;  // What do we do here?  Cancel, I assume.
                        hrRet = WBEM_E_OUT_OF_MEMORY;
                        break;
                    }         
                
                }
                else
                    hrRet = WBEM_S_PARTIAL_RESULTS;

                if (m_pSession && ((CWmiDbSession *)m_pSession)->m_pController)
                    ((CWmiDbController *)m_pSession->m_pController)->IncrementHitCount(false);

                VariantClear(&vTemp);

                hr = pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                delete pRow;
                pRow = NULL;
                if (iNumRetrieved == dwNumRequested)
                    break;
                hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
            }
        }

        if (pdwNumReturned)
            *pdwNumReturned = iNumRetrieved;

        // Null out m_pStatus if there are no more results!!!
        if (hr == WBEM_S_NO_MORE_DATA)
        {
            hrRet = WBEM_S_NO_MORE_DATA;
            Cancel(0);
        }
    }
    catch (...)
    {
        hrRet = WBEM_E_CRITICAL_ERROR;
    }

    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlutils.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlcache.h
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#ifndef _SQLUTILS_H_
#define _SQLUTILS_H_

#include <seqstream.h>
#include <sqlcache.h>

class CWmiDbSession;

typedef struct STRUCTHASINSTANCES
{
    DB_NUMERIC dClassId;
    DWORD      dwHasInst;
} STRUCTHASINSTANCES;


typedef struct STRUCTINSERTCLASS
{
    BSTR       sClassName;
    BSTR       sObjectKey;
    BSTR       sObjectPath;
    DB_NUMERIC dScopeID;
    DB_NUMERIC dParentClassId;
    int        iClassState;
    BYTE       *pClassBuff;
    int        iClassFlags;
    int        iInsertFlags;        
    DB_NUMERIC dRetVal;

} STRUCTINSERTCLASS;


typedef struct STRUCTINSERTCLASSDATA
{
    DB_NUMERIC  dClassId;
    BSTR        sPropName;
    int         iCimType;
    int         iStorageType;
    BSTR        sValue;
    DB_NUMERIC  dRefClassId;
    int         iPropID;
    int         iFlags;
    int         iFlavor;
    int         iRetVal;   
    int         iKnownID;
    BOOL        bIsKey;
} STRUCTINSERTCLASSDATA;

typedef struct STRUCTOBJECTEXISTS
{
    DB_NUMERIC dObjectId;
    DB_NUMERIC dClassId;
    DB_NUMERIC dScopeId;
    BOOL       bExists;
} STRUCTOBJECTEXISTS;

typedef struct STRUCTINSERTBLOB
{
    DB_NUMERIC dClassId;
    DB_NUMERIC dObjectId;
    int        iPropertyId;
    BYTE       *pImage;
    int        iPos;
} STRUCTINSERTBLOB;

typedef struct STRUCTINSERTPROPBATCH
{
    DB_NUMERIC dObjectId;
    BSTR       sObjectKey;
    BSTR       sObjectPath;
    BSTR       sCompKey;
    DB_NUMERIC dClassId;
    DB_NUMERIC dScopeId;
    int        iInsertFlags;
    int        iPropId[5];
    BSTR       sPropValue[5];
    int        iPos[5];
    BOOL       bInit;
} STRUCTINSERTPROPBATCH;

typedef struct STRUCTINSERTBATCH
{
    DB_NUMERIC dObjectId; // @ObjectId
    DB_NUMERIC dScopeId;  // @ScopeID
    DB_NUMERIC dClassId;  // @ClassID
    int        iQfrId[5]; // @QfrId?
    BSTR       sPropValue[5]; // @QfrValue?
    int        iPos[5]; // @QfrPos?
    int        iPropId[5]; // @PropID?
    int        iFlavor[5]; // @Flavor?
} STRUCTINSERTBATCH;


class _declspec( dllexport ) COLEDBConnection : public CSQLConnection
{
    friend class CSQLConnCache;
public:
    COLEDBConnection (IDBInitialize *pDBInit);
    ~COLEDBConnection ();

    IDBInitialize * GetDBInitialize () {return m_pDBInit;};
    IDBCreateSession * GetSessionObj() {return m_pSession;};
    IDBCreateCommand * GetCommand() {return m_pCmd;};

    ICommandText * GetCommandText(DWORD type) {return (ICommandText * )m_ObjMgr.GetObject(SQL_POS_ICOMMANDTEXT|type);};
    ICommandWithParameters * GetCommandWithParams(DWORD type) {return (ICommandWithParameters * )m_ObjMgr.GetObject(SQL_POS_ICOMMANDWITHPARAMS|type);};
    IAccessor * GetIAccessor(DWORD type) {return (IAccessor * )m_ObjMgr.GetObject(SQL_POS_IACCESSOR|type);};
    HACCESSOR GetAccessor(DWORD type) {return (HACCESSOR )m_ObjMgr.GetObject(SQL_POS_HACCESSOR|type);};
    IRowset * GetRowset(DWORD type) {return (IRowset * )m_ObjMgr.GetObject(SQL_POS_IROWSET|type);};
    IOpenRowset * GetOpenRowset(DWORD type) {return (IOpenRowset * )m_ObjMgr.GetObject(SQL_POS_IOPENROWSET|type);};
    IRowsetChange * GetRowsetChange(DWORD type) {return (IRowsetChange * )m_ObjMgr.GetObject(SQL_POS_IROWSETCHANGE|type);};
    IRowsetIndex * GetRowsetIndex(DWORD type) {return (IRowsetIndex * )m_ObjMgr.GetObject(SQL_POS_IROWSETINDEX|type);};

    void SetCommandText (DWORD type, ICommandText *pNew) {m_ObjMgr.SetObject(SQL_POS_ICOMMANDTEXT|type, pNew);};
    void SetCommandWithParams (DWORD type, ICommandWithParameters *pNew) {m_ObjMgr.SetObject(SQL_POS_ICOMMANDWITHPARAMS|type, pNew);};
    void SetIAccessor (DWORD type, IAccessor *pNew) {m_ObjMgr.SetObject(SQL_POS_IACCESSOR|type, pNew);};
    void SetAccessor (DWORD type, HACCESSOR hNew) {m_ObjMgr.SetObject(SQL_POS_HACCESSOR|type, (void *)hNew);};
    void SetRowset(DWORD type, IRowset *pNew) {m_ObjMgr.SetObject(SQL_POS_IROWSET|type, pNew);};
    void SetOpenRowset(DWORD type, IOpenRowset *pNew) {m_ObjMgr.SetObject(SQL_POS_IOPENROWSET|type, pNew);};
    void SetRowsetChange (DWORD type, IRowsetChange *pNew) {m_ObjMgr.SetObject(SQL_POS_IROWSETCHANGE|type, pNew);};
    void SetRowsetIndex (DWORD type, IRowsetIndex *pNew) {m_ObjMgr.SetObject(SQL_POS_IROWSETINDEX|type, pNew);};

    void SetSessionObj (IDBCreateSession *pNew) {m_pSession = pNew;};
    void SetCommand (IDBCreateCommand *pNew) 
    {
        if (m_pCmd) 
            m_pCmd->Release();
        m_pCmd = pNew;
        pNew->AddRef();
    };

private:
    time_t         m_tCreateTime;
    IDBInitialize *m_pDBInit;
    bool           m_bInUse;

    IDBCreateSession   *m_pSession;
    IDBCreateCommand   *m_pCmd;
    ITransaction       *m_pTrans;
    CDBObjectManager m_ObjMgr;

};


#endif  // _SQLUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sqlutils.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlcache.cpp
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#define _SQLCACHE_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class
#include "precomp.h"

#include <std.h>
#include <smrtptr.h>
#include <reputils.h>
#include <sqlutils.h>
#include <sqlcache.h>
#include <sqlit.h>
#include <repdrvr.h>
#include <wbemint.h>

#if defined _WIN64
#define ULONG unsigned __int64
#define LONG __int64
#endif

//***************************************************************************
//
//  COLEDBConnection::COLEDBConnection
//
//***************************************************************************

COLEDBConnection::COLEDBConnection (IDBInitialize *pDBInit)
{
    m_pDBInit = pDBInit;
    m_tCreateTime = time(0);
    m_bInUse = false;
    m_pSession = NULL;
    m_pCmd = NULL;
    m_pTrans = NULL;
}

//***************************************************************************
//
//  COLEDBConnection::~COLEDBConnection
//
//***************************************************************************
COLEDBConnection::~COLEDBConnection ()
{
    if (m_pDBInit)  
    {
        m_ObjMgr.Empty();
        if (m_pTrans)
            m_pTrans->Release();
        if (m_pCmd) m_pCmd->Release();
        if (m_pSession) 
            m_pSession->Release();
        m_pDBInit->Uninitialize();
        while (m_pDBInit->Release());
    }
}


//***************************************************************************
//
//  CSQLExecuteRepdrvr::GetNextResultRows
//
//***************************************************************************

HRESULT CSQLExecuteRepdrvr::GetNextResultRows(int iNumRows, IRowset *pIRowset, IMalloc *pMalloc, IWbemClassObject *pNewObj, CSchemaCache *pSchema
                                       , CWmiDbSession *pSession, Properties &PropIds, bool *bImage, bool bOnImage)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG           nCols;    
    DBCOLUMNINFO*   pColumnsInfo = NULL;
    OLECHAR*        pColumnStrings = NULL;    
    ULONG           nCol;
    ULONG           cRowsObtained;          // Count of rows
                                            // obtained
    HROW            *rghRows = new HROW[iNumRows];      // Row handles
    HROW*           pRows = &rghRows[0];    // Pointer to the row
                                            // handles
    CDeleteMe <HROW> r2 (rghRows);
    IAccessor*      pIAccessor;             // Pointer to the
                                            // accessor
    HACCESSOR       hAccessor;              // Accessor handle
    DBBINDSTATUS*   pDBBindStatus = NULL;    
    DBBINDING*      pDBBindings = NULL;
    BYTE*           pRowValues = NULL;
    LPWSTR          lpColumnName;

    // Get Column Info
    
    IColumnsInfo*   pIColumnsInfo;    

    pIRowset->QueryInterface(IID_IColumnsInfo, (void**) &pIColumnsInfo);
    hr = pIColumnsInfo->GetColumnInfo(&nCols, &pColumnsInfo, &pColumnStrings);    
    CReleaseMe r1 (pIColumnsInfo);

    if (nCols > 11 || nCols < 10)
        return WBEM_E_INVALID_QUERY;


    // Create the binding structures
    ULONG       cbRow = 0;   
    
    pDBBindings = new DBBINDING[nCols];
    CDeleteMe <DBBINDING> d1(pDBBindings);

    if (!pDBBindings || !rghRows)
        return WBEM_E_OUT_OF_MEMORY;

    for (nCol = 0; nCol < nCols; nCol++)        
    {
        pDBBindings[nCol].iOrdinal = nCol+1;
        pDBBindings[nCol].obValue = cbRow;
        pDBBindings[nCol].obLength = 0;        
        pDBBindings[nCol].obStatus = 0;
        pDBBindings[nCol].pTypeInfo = NULL;
        pDBBindings[nCol].pObject = NULL;
        pDBBindings[nCol].pBindExt = NULL;
        pDBBindings[nCol].dwPart = DBPART_VALUE;
        pDBBindings[nCol].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        pDBBindings[nCol].eParamIO = DBPARAMIO_NOTPARAM;
        pDBBindings[nCol].wType = pColumnsInfo[nCol].wType;

        if (nCol == 10)
        {
            pDBBindings[nCol].wType = DBTYPE_WSTR;  // 64-bit ints must end up as strings.
            pDBBindings[nCol].cbMaxLen = 50;
        }
        else
        {
            if (pDBBindings[nCol].wType == DBTYPE_WSTR ||
                pDBBindings[nCol].wType == DBTYPE_STR || 
                pDBBindings[nCol].wType == DBTYPE_BSTR)
                pDBBindings[nCol].cbMaxLen = pColumnsInfo[nCol].ulColumnSize+1;
            else
                if (pColumnsInfo[nCol].ulColumnSize > 65535)
                    pDBBindings[nCol].cbMaxLen = 65535;
                else
                    pDBBindings[nCol].cbMaxLen = pColumnsInfo[nCol].ulColumnSize;
        }

        pDBBindings[nCol].dwFlags = 0;        
        pDBBindings[nCol].bPrecision = pColumnsInfo[nCol].bPrecision;
        pDBBindings[nCol].bScale = pColumnsInfo[nCol].bScale;
        
        lpColumnName = pColumnsInfo[nCol].pwszName;

        cbRow += pDBBindings[nCol].cbMaxLen;        
    }

    pRowValues = new BYTE[cbRow];    
    pDBBindStatus = new DBBINDSTATUS[nCols];
    CDeleteMe <BYTE> r3 (pRowValues);
    CDeleteMe <DBBINDSTATUS> r4 (pDBBindStatus);

    if (!pRowValues || !pDBBindStatus)
        return WBEM_E_OUT_OF_MEMORY;

    pIRowset->QueryInterface(IID_IAccessor, (void**) &pIAccessor);
    CReleaseMe r7 (pIAccessor);
    pIAccessor->CreateAccessor(
        DBACCESSOR_ROWDATA,// Accessor will be used to retrieve row
                           // data
        nCols,             // Number of columns being bound
        pDBBindings,       // Structure containing bind info
        0,                 
        &hAccessor,        // Returned accessor handle
        pDBBindStatus      // Information about binding validity        
     );

    // Get the next row.

    hr = pIRowset->GetNextRows(            0,                  // Reserved
        0,                  // cRowsToSkip
        iNumRows,           // cRowsDesired
        &cRowsObtained,     // cRowsObtained
        &pRows );           // Filled in w/ row handles.
    if (FAILED(hr))
    {
        // SetWMIOLEDBError(pIRowset);
    }
    else
    {
        if (cRowsObtained > 0)
        {
            for (int i = 0; i < cRowsObtained; i++)
            {                
                pIRowset->GetData(rghRows[i], hAccessor, pRowValues);
                
                DWORD dwPropertyId, dwStorage, dwPosition, dwCIMType, dwFlags, dwPropFlags;
                _bstr_t sPropName;
                SQL_ID dRefID = 0;
                VARIANT vValue;
                CClearMe c (&vValue);
                wchar_t wTemp[455];
               
                // We should have exactly 13 columns:
                // (ObjectId, ClassId, PropertyId, ArrayPos, PropertyStringValue,
                //  PropertyNumericValue, PropertyRealValue, Flags, ClassId, ObjectPath, 
                //  RefId, RefClassId, string binding of PropertyNumericValue
                // ===================================================================

                SQL_ID dOrigClassId = 0;
                
                if (&pRowValues[pDBBindings[0].obValue] != NULL)
                {
                    if (pDBBindings[1].wType == DBTYPE_NUMERIC)
                    {
                        DB_NUMERIC *pTemp = (DB_NUMERIC *)&pRowValues[pDBBindings[1].obValue];
                        dOrigClassId = CSQLExecute::GetInt64(pTemp);
                    }
                    else
                        dOrigClassId = *((long *)&pRowValues[pDBBindings[1].obValue]);;
                }

                dwPropertyId = *((long *)&pRowValues[pDBBindings[2].obValue]);
                dwPosition = *((short *)&pRowValues[pDBBindings[3].obValue]);
                dwFlags = *((short *)&pRowValues[pDBBindings[7].obValue]) == NULL ? 0 : *((short *)&pRowValues[pDBBindings[7].obValue]);
                
                hr = pSchema->GetPropertyInfo (dwPropertyId, &sPropName, NULL, &dwStorage,
                                &dwCIMType, &dwPropFlags);
                if (FAILED(hr))
                    break;

                BYTE *pBuffer = NULL;
                DWORD dwLen = 0;

                switch (dwStorage)
                {
                case WMIDB_STORAGE_STRING:
                    if (bOnImage)
                    {
                        hr = ReadImageValue(pIRowset, 5, &pRows, &pBuffer, dwLen);
                        SetVariant(CIM_STRING, &vValue, pBuffer, dwCIMType);
                    }
                    else
                    {
                        SetVariant(CIM_STRING, &vValue, &pRowValues[pDBBindings[4].obValue], dwCIMType);
						int iLen = wcslen(vValue.bstrVal);
                        if (bImage)
                            *bImage = (IsTruncated(vValue.bstrVal) ? true : false);
                    }

                    break;
                case WMIDB_STORAGE_NUMERIC:
                    if (dwCIMType == CIM_UINT64 || dwCIMType == CIM_SINT64)
                        SetVariant(CIM_STRING, &vValue, &pRowValues[pDBBindings[10].obValue], dwCIMType);
                    else
                    {
                        if (pDBBindings[5].wType == DBTYPE_NUMERIC)
                            SetVariant(DBTYPE_NUMERIC, &vValue, &pRowValues[pDBBindings[5].obValue], dwCIMType);
                        else
                            SetVariant(VT_I4, &vValue, &pRowValues[pDBBindings[5].obValue], dwCIMType);
                    }
                    break;
                case WMIDB_STORAGE_REAL:
                    SetVariant(VT_R8, &vValue, &pRowValues[pDBBindings[6].obValue], dwCIMType);
                    break;
                case WMIDB_STORAGE_REFERENCE: // Reference or object
                    if (bOnImage)
                    {
                        hr = ReadImageValue(pIRowset, 5, &pRows, &pBuffer, dwLen);
                        if (dwCIMType == CIM_REFERENCE)
                            SetVariant(CIM_STRING, &vValue, pBuffer, dwCIMType);
                    }
                    else
                        SetVariant(CIM_STRING, &vValue, &pRowValues[pDBBindings[4].obValue], dwCIMType);
                    break;
                case WMIDB_STORAGE_IMAGE:   // Used different procedure.
                    hr = ReadImageValue(pIRowset, 5, &pRows, &pBuffer, dwLen);
                    // Read the buffer, and attempt to set it as a safearray.

                    if (dwCIMType != CIM_OBJECT)
                    {
                        if (SUCCEEDED(hr) && dwLen > 0)
                        {
                            long why[1];                        
                            unsigned char t;
                            SAFEARRAYBOUND aBounds[1];
                            aBounds[0].cElements = dwLen; // This *should* be the max value!!!!
                            aBounds[0].lLbound = 0;
                            SAFEARRAY* pArray = SafeArrayCreate(VT_UI1, 1, aBounds);                            
                            vValue.vt = VT_I1;
                            for (int i2 = 0; i2 < dwLen; i2++)
                            {            
                                why[0] = i2;
                                t = pBuffer[i2];
                                hr = SafeArrayPutElement(pArray, why, &t);                            
                            }
                            vValue.vt = VT_ARRAY|VT_UI1;
                            V_ARRAY(&vValue) = pArray;
                            CWin32DefaultArena::WbemMemFree(pBuffer);
                            dwCIMType |= CIM_FLAG_ARRAY;
                        }
                        else
                            vValue.vt = VT_NULL;
                    }
                        
                    break;                   
                default:
                    
                    hr = WBEM_E_NOT_AVAILABLE;
                    break;
                }

                // Qualifier's property ID, if applicable.
                if (dwPropFlags & REPDRVR_FLAG_QUALIFIER ||
                    dwPropFlags & REPDRVR_FLAG_IN_PARAM ||
                    dwPropFlags & REPDRVR_FLAG_OUT_PARAM)
                {
                    if (pDBBindings[8].wType == DBTYPE_NUMERIC)
                    {
                        DB_NUMERIC *pTemp = (DB_NUMERIC *)&pRowValues[pDBBindings[8].obValue];
                        dRefID = CSQLExecute::GetInt64(pTemp);
                    }
                    else
                        dRefID = *((long *)&pRowValues[pDBBindings[8].obValue]);
                }              

                // If this is an object (not a reference), 
                // then we need to Get the object and set it in 
                // the variant.  Otherwise, the variant is simply
                // the string path to the object.
                // ===============================================

                if (dwCIMType == CIM_OBJECT)
                {
                    if (!bOnImage)
                    {
                        IWmiDbHandle *pHand = NULL;

                        hr = pSession->GetObject_Internal((LPWSTR)vValue.bstrVal, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHand);
                        CReleaseMe r4 (pHand);
                        if (SUCCEEDED(hr))
                        {
                            IWbemClassObject *pEmbed = NULL;
                            hr = pHand->QueryInterface(IID_IWbemClassObject, (void **)&pEmbed);
                            if (SUCCEEDED(hr))
                            {        
                                VariantClear(&vValue);
                                V_UNKNOWN(&vValue) = (IUnknown *)pEmbed;
                                vValue.vt = VT_UNKNOWN;
                                // VariantClear will release this, right?
                            }
                        }
                    }
                    else
                    {
                        IWbemClassObject *pEmbedClass = NULL, *pEmbed = NULL;
                        _IWmiObject *pInt = NULL;
                        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IWbemClassObject, (void **)&pEmbedClass);                        
                        if (SUCCEEDED(hr))
                        {
                            VARIANT v;
                            VariantInit(&v);
                            CClearMe c (&v);
                            v.bstrVal = SysAllocString(L"Z");
                            v.vt = VT_BSTR;
                            pEmbedClass->Put(L"__Class", 0, &v, CIM_STRING);
                            hr = pEmbedClass->SpawnInstance(0, &pEmbed);
                            CReleaseMe r1 (pEmbedClass);

                            if (SUCCEEDED(hr))
                            {
                                hr = pEmbed->QueryInterface(IID__IWmiObject, (void **)&pInt);
                                CReleaseMe r (pInt);
                                if (SUCCEEDED(hr))
                                {
                                    LPVOID  pTaskMem = NULL;

                                    if (SUCCEEDED(hr))
                                    {
                                        pTaskMem = CoTaskMemAlloc( dwLen );

                                        if ( NULL != pTaskMem )
                                        {
                                            // Copy the memory
                                            CopyMemory( pTaskMem, pBuffer, dwLen );
                                            hr = pInt->SetObjectMemory(pTaskMem, dwLen);
                                            if (SUCCEEDED(hr))
                                            {
                                                VariantClear(&vValue);
                                                V_UNKNOWN(&vValue) = (IUnknown *)pEmbed;
                                                vValue.vt = VT_UNKNOWN;
                                                dwStorage = WMIDB_STORAGE_REFERENCE;
                                            }
                                        }
                                        else
                                        {
                                            hr = WBEM_E_OUT_OF_MEMORY;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // For array properties, what we actually need to do is
                // see if the property exists already.  If not, we
                // initialize the safe array and add the first element.
                // If so, we simply set the value in the existing array.
                // ======================================================

                if (FAILED(hr))
                    break;

                if (dwPropFlags & REPDRVR_FLAG_ARRAY && (dwStorage != WMIDB_STORAGE_IMAGE) )
                {
                    dwCIMType |= CIM_FLAG_ARRAY;

                    VARIANT vTemp;
                    CClearMe c (&vTemp);
                    VariantCopy(&vTemp, &vValue);
                    long lTemp;
                    CIMTYPE cimtype;
                    VariantClear(&vValue);
                    if (SUCCEEDED(pNewObj->Get(sPropName, 0, &vValue, &cimtype, &lTemp)))
                    {
                        if (PropIds[dwPropertyId])
                        {
                            SAFEARRAY *pArray = V_ARRAY(&vValue);                            
                            hr = PutVariantInArray(&pArray, dwPosition, &vTemp);                            
                        }
                        else
                        {
                            if (vValue.vt != VT_NULL)
                                VariantClear(&vValue);

                            // This is a new object.
                            SAFEARRAYBOUND aBounds[1];
                            aBounds[0].cElements = dwPosition+1; // This *should* be the max value!!!!
                            aBounds[0].lLbound = 0;
                            SAFEARRAY* pArray = SafeArrayCreate(vTemp.vt, 1, aBounds);                            
                            hr = PutVariantInArray(&pArray, dwPosition, &vTemp);
                            vValue.vt = VT_ARRAY|vTemp.vt;
                            V_ARRAY(&vValue) = pArray;
                            PropIds[dwPropertyId] = true;
                        }                        
                    }
                }              

                if (!(dwPropFlags & REPDRVR_FLAG_QUALIFIER) &&
                    !(dwPropFlags & REPDRVR_FLAG_IN_PARAM) && 
                    !(dwPropFlags & REPDRVR_FLAG_OUT_PARAM))
                {
                    hr = pNewObj->Put(sPropName, 0, &vValue, dwCIMType);
                }

                // If this is a qualifier on a class, get the qualifier set and set the value.
                else if (dwPropFlags & REPDRVR_FLAG_QUALIFIER )
                {                    
                    if (dRefID != 0)
                    {
                        _bstr_t sProp2;
                        DWORD dwFlags2, dwRefID;

                        hr = pSchema->GetPropertyInfo (dRefID, &sProp2, NULL, NULL,
                                NULL, &dwFlags2, NULL, NULL, &dwRefID);
                        if (SUCCEEDED(hr))
                        {
                            IWbemQualifierSet *pQS = NULL;
                            hr = pNewObj->GetPropertyQualifierSet(sProp2, &pQS);
                            CReleaseMe r4 (pQS);
                            if (SUCCEEDED(hr))
                                pQS->Put(sPropName, &vValue, dwFlags);
                        }                        
                    }
                    else    // Its just a class/instance qualifier.  Set it.
                    {
                        IWbemQualifierSet *pQS = NULL;
                        hr = pNewObj->GetQualifierSet(&pQS);
                        CReleaseMe r5 (pQS);
                        if (SUCCEEDED(hr))
                            hr = pQS->Put(sPropName, &vValue, dwFlags);
                    }
                }

           }
        }
        else
            hr = WBEM_S_NO_MORE_DATA;
    }    

    pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL);        

    pIAccessor->ReleaseAccessor(hAccessor, NULL);    

    pMalloc->Free( pColumnsInfo );    
    pMalloc->Free( pColumnStrings );

    if (hr == DB_S_ENDOFROWSET)
        hr = WBEM_S_NO_MORE_DATA;

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\QUASAR\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\autotest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



// *****************************************************
//
//  autotest.cpp
// 
//  Automated test suite for Quasar
//
//  This should exercise all the major functionality
//  of any implementation of the repository driver,
//  and report the successes/failures/perf figures.
//
// *****************************************************

#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <comutil.h>
#include <time.h>
#include <reposit.h>
#include <wbemcli.h>
#include <testmods.h>

#include <oledb.h>
#include <msjetoledb.h>

HRESULT RunSuite(int iSuiteNum, IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope);
BOOL SetParam(const wchar_t *pszParam);
void SetObjProp(IWbemClassObject *pObj, const wchar_t *pszPropName, wchar_t *pszValue, CIMTYPE ct = CIM_STRING);
void ShowHelp();

CLSID ridDriver = CLSID_WmiRepository_SQL;

struct LocalParams
{
    wchar_t szServerName[250]; // SQL Server name
    wchar_t szDatabase[100];   // SQL database
    wchar_t szUser[100];       // SQL User name
    wchar_t szPassword[100];   // SQL Password
    wchar_t szLogonUser[200];  // Logon user account (for security testing)
    DWORD   dwTestSuite;          // Test suite # to run (0 if all)
    wchar_t szFileName[250];      // File name for results
    wchar_t szNamespace[100];     // Namespace to create
    BOOL    bDropNamespace;       // TRUE to drop namespace afterwards
    DWORD   dwMaxNumThreads;      // Maximum number of threads
    DWORD   dwMaxHierarchyDepth;  // Maximum hierarchy depth
    DWORD   dwMaxNumObjects;      // Maximum number of any object type
    BOOL    bGatherStats;         // TRUE to print statistics
    DWORD   dwCacheSize;          // Maximum cache size    
};

LocalParams config = {L".",L"WMI1",L"sa",L"",L"AKIAPOLAAU\\Guest", 0, L"", L"test", FALSE, 2, 5, 1000, TRUE, 65535};



// *****************************************************
//
//  wmain
//
// *****************************************************

int __cdecl main (int argc, char ** argv)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWmiDbController *pController = NULL;
    WMIDB_LOGON_TEMPLATE *pTemplate = NULL;
    IWmiDbSession *pSession= NULL;

    ridDriver = CLSID_WmiRepository_SQL;

    printf (" *** WMI QUASAR REPOSITORY DRIVER COMPLIANCE TEST ***\n\n");

    for (int i = 1; i < argc; i++)
    {
        // Set the value in the appropriate
        // slot...

		wchar_t wTemp[50];
		swprintf(wTemp, L"%S", argv[i]);
        if (!SetParam((const wchar_t *)wTemp))
        {
            wchar_t szTmp[100];
            ShowHelp();
            wprintf(L"Press <Enter> to continue.\n");
            _getws(szTmp);
            return 0;
        }
    }

    hr = CoInitialize(NULL);

    // Connect to driver.  Set login information
    //  and attempt to get a connection.

    hr = CoCreateInstance(ridDriver, NULL, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (void **)&pController);
    if (SUCCEEDED(hr))
    {   
        wchar_t szPath[500];
        IWbemPath *pNamespacePath = NULL;
        IWbemClassObject *pNewNamespace = NULL;
        IWmiDbHandle *pRoot = NULL;
		IWmiDbHandle *pScopePath = NULL;
        wchar_t szTmp[250];
        hr = pController->GetLogonTemplate(0x409, 0, &pTemplate);
        if (SUCCEEDED(hr))
        {         
            // Print out the current configuration, for the record.
            // ====================================================
            
            wprintf(L"\n*** Configuration ***\n"
                    L"=======================\n"
                    L"SQL Server Name.... %s\n", (const wchar_t *)config.szServerName);
            wprintf(L"Database Name.. %s\n", (const wchar_t *)config.szDatabase);
            wprintf(L"User ID........ %s\n", (const wchar_t *)config.szUser);
            if (wcslen(config.szLogonUser))
                wprintf(L"NT User............ %s\n", (const wchar_t *)config.szLogonUser);
            else
                wprintf(L"(No NT User)\n");
            if (wcslen(config.szFileName))
                wprintf(L"Output File ............ %s\n", (const wchar_t *)config.szFileName);
            else 
                wprintf(L"(No Database Script)\n");
            wprintf(L"Namespace Name..... %s\n", (const wchar_t *)config.szNamespace);
            if (config.dwTestSuite)
                wprintf(L"Test Suite #....... %ld\n", config.dwTestSuite);
            else
                wprintf(L"(Running all test suites...)\n");
            wprintf(L"Max Num Threads.... %ld\n", config.dwMaxNumThreads);
            wprintf(L"Max Hierarchy Depth %ld\n", config.dwMaxHierarchyDepth);
            wprintf(L"Max Num Objects.... %ld\n", config.dwMaxNumObjects);
            wprintf(L"Max Cache Size..... %ld\n", config.dwCacheSize);
            wprintf(L"Drop Namespace?.... %s\n", (config.bDropNamespace ) ? L"TRUE" : L"FALSE");
            wprintf(L"Gather statistics?. %s\n", (config.bGatherStats) ? L"TRUE" : L"FALSE");
            if (ridDriver == CLSID_WmiRepository_SQL)
                wprintf(L"Using SQL driver\n");
            else
                wprintf(L"Using JET driver\n");
            wprintf(L"=======================\n\n");

            // Fill in the parameters:            

            for (i = 0; i < (int)pTemplate->dwArraySize - 1; i++)
            {
                if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Server"))
                {
                    pTemplate->pParm[i].Value.bstrVal = SysAllocString(config.szServerName);
                    pTemplate->pParm[i].Value.vt = VT_BSTR;
                }
                else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Database"))
                {
                    pTemplate->pParm[i].Value.bstrVal = SysAllocString(config.szDatabase);
                    pTemplate->pParm[i].Value.vt = VT_BSTR;
                }
                else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"UserID"))
                {
                    pTemplate->pParm[i].Value.bstrVal = SysAllocString(config.szUser);
                    pTemplate->pParm[i].Value.vt = VT_BSTR;
                }
                else if (!_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Password"))
                {
                    pTemplate->pParm[i].Value.bstrVal = SysAllocString(config.szPassword);                   
                    pTemplate->pParm[i].Value.vt = VT_BSTR;
                }
                
            }

            hr = pController->SetCacheValue(config.dwCacheSize);
			if (FAILED(hr))
				printf("IWmiDbController::SetCacheValue failed (%X)\n", hr);

            hr = pController->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pSession, &pRoot);
            if (SUCCEEDED(hr))
            {
                wcscpy(szPath, L"__Namespace");

                pController->FreeLogonTemplate(&pTemplate);
                printf("Successfully obtained connection to repository...\n");

                // Create a namespace (config.szNamespace)

                IWbemClassObject *pNamespace = NULL;
                IWmiDbHandle *pNSHandle = NULL;

                hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                        IID_IWbemPath, (LPVOID *) &pNamespacePath);
                if (SUCCEEDED(hr))
                {
                    ULONG uLen = 500;
                    pNamespacePath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, szPath);

                    hr = pSession->GetObject(pRoot, pNamespacePath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pNSHandle);
                    if (SUCCEEDED(hr))
                    {
                        hr = pNSHandle->QueryInterface(IID_IWbemClassObject, (void **)&pNamespace);                      
                        if (SUCCEEDED(hr))
                        {
                            pNamespace->SpawnInstance(0, &pNewNamespace);
                       
                            SetObjProp(pNewNamespace, L"Name", config.szNamespace);
                            hr = pSession->PutObject(pRoot, IID_IWbemClassObject, pNewNamespace, WBEM_FLAG_CREATE_ONLY, WMIDB_HANDLE_TYPE_VERSIONED, &pScopePath);                            
                            if (FAILED(hr))
                            {
                                pNamespacePath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, config.szNamespace);
                                hr = pSession->DeleteObject(pRoot, 0, IID_IWbemPath, pNamespacePath);
                                if (SUCCEEDED(hr))
                                    hr = pSession->PutObject(pRoot, IID_IWbemClassObject, pNewNamespace, WBEM_FLAG_CREATE_ONLY, 
                                        WMIDB_HANDLE_TYPE_VERSIONED, &pScopePath);
                            }
                            if (SUCCEEDED(hr))
						    {
                                hr = RunSuite(config.dwTestSuite, pSession, pController, pScopePath);
							    if (FAILED(hr))
								    printf("RunSuite failed with %X\n", hr);
						    }
						    else
							    wprintf(L"IWmiDbSession::PutObject failed to put %s (%X)\n", (const wchar_t *)config.szNamespace, hr);
                            pNSHandle->Release();
                            pNamespace->Release();
                            pNewNamespace->Release();
                        }
                        else
                            printf("IWmiDbHandle::QueryInterface failed (IID_IWbemClassObject) (%X)\n", hr);
                    }                    
					else
						wprintf(L"IWmiDbSession::GetObject failed to get %s (%X) \n", (const wchar_t *)szPath, hr);
                }
				else
					printf("CoCreateInstance failed to create a IWbemPath (%X)\n", hr);

            }        
			else
				printf("IWmiDbController::Logon failed (%X)\n", hr);
        }
		else
			printf("IWmiDbController::GetLogonTemplate failed. (%X)\n", hr);

        // Drop the namespace, if requested
        // ================================

        if (SUCCEEDED(hr) && config.bDropNamespace)
        {
            hr = pSession->DeleteObject(pRoot, 0, IID_IWmiDbHandle, pScopePath);
            if (FAILED(hr))
                printf("IWmiDbSession::DeleteObject failed (%X)\n", hr);
            else
                printf("IWmiDbSession::DeleteObject succeeded.  PLEASE VERIFY REMOVAL OF NAMESPACE IN UNDERLYING REPOSITORY!!\n\n");
        }
        
        hr = pController->FlushCache(0);

        hr = pController->Shutdown(0);
        if (SUCCEEDED(hr))
        {
            try {

                DWORD dwType = 0;
                if (pSession)
                {
                    hr = pSession->PutObject(pRoot, IID_IWbemClassObject, pScopePath, 0, 0, NULL);
                    if (SUCCEEDED(hr))
                        wprintf(L"WARNING: IWmiDbSession::PutObject succeeded after shutdown!!\n");
                    hr = pSession->SetDecoration(L".", L"root");
                    if (SUCCEEDED(hr))
                        wprintf(L"WARNING: IWmiDbSession::SetDecoration succeeded after shutdown!!\n");
                }
                if (SUCCEEDED(pController->SetCacheValue(0)))
                    wprintf(L"WARNING: IWmiDbController::SetCacheValue succeeded after shutdown!!\n\n");
            }
            catch (...)
            {
                wprintf(L"ERROR: An exception occurred while testing post-shutdown calls.\n");
            }
        }
        else
            wprintf(L"IWmiDbController::Shutdown failed (%X)\n", hr);

        if (pRoot)
            pRoot->Release();
        if (pNamespacePath)
            pNamespacePath->Release();
		if (pScopePath)
			pScopePath->Release();
        if (pSession)
            pSession->Release();                    
        if (pController)
            pController->Release();

        if (SUCCEEDED(hr))
            printf("Shutdown successful.\n");

        printf("Press <Enter> to end.\n");
        _getws(szTmp);

        CoUninitialize();       
    }
	else
		printf("CoCreateInstance failed to create an IWmiDbController (%X).\n", hr);

    return 0;

}

// *****************************************************
//
//  RunSuite
//
// *****************************************************

HRESULT RunSuite(int iSuiteNum, IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (iSuiteNum)
        printf("*** Running Test Suite %ld...\n", iSuiteNum);
    else
        printf("*** Running ALL Test Suites.  Beginning...\n");

    // Run the suite(s)...

    SuiteManager mgr (config.szFileName, config.szLogonUser, config.dwMaxNumThreads, config.dwMaxHierarchyDepth, config.dwMaxNumObjects);
    hr = mgr.RunSuite(iSuiteNum, pSession, pController, pScope);

    // Report the statistics!!
    
    mgr.DumpResults(config.bGatherStats);

    printf("*** Done\n");

    return hr;
}


// *****************************************************
//
//  SetObjProp
//
// *****************************************************

void SetObjProp(IWbemClassObject *pObj, const wchar_t *pszPropName, wchar_t *pszValue, CIMTYPE ct)
{
    VARIANT vTemp;
    VariantInit(&vTemp);

    vTemp.vt = VT_BSTR;
    vTemp.bstrVal = SysAllocString(pszValue);

    HRESULT hr = pObj->Put(pszPropName, 0, &vTemp, ct);
    VariantClear(&vTemp);
}

// *****************************************************
//
//  ShowHelp
//
// *****************************************************

void ShowHelp()
{
    wprintf(L" Parameters:\n");
    wprintf(L" ==========\n");
    wprintf(L" S=Server name \n");
    wprintf(L" D=Database\n");
    wprintf(L" U=User\n");
    wprintf(L" P=Password\n");
    wprintf(L" UA=Logon user account\n");
    wprintf(L" TS=Test Suite # (1=Functionality, 2=Error Verification, 3=Stress)\n");
    wprintf(L" FN=File name\n");
    wprintf(L" NS=Name of the test namespace.\n");
    wprintf(L" MT=Max number of threads to run concurrently\n");
    wprintf(L" MH=Maximum hierarchy depth\n");
    wprintf(L" NO=Maximum number of any one object to create\n");
    wprintf(L" CS=Cache size in bytes\n");
    wprintf(L" ST=Gather speed/space statistics (Y/N)\n");
    wprintf(L" DN=Drop namespace when done (Y/N)\n");
    wprintf(L" SQL=Use SQL driver (Y/N)\n");
    wprintf(L" /?  Display help\n");
    wprintf(L"\n");
    wprintf(L" Example: autotest S=. D=WMI1 U=sa CS=65535\n\n");
}

// *****************************************************
//
//  SetParam
//
// *****************************************************

BOOL SetParam(const wchar_t *pszParam)
{
    BOOL bRet = 0;
    wchar_t szTmp[5];

    wchar_t *pTmp = wcsstr(pszParam, L"=");
    if (pTmp)
    {
        bRet = TRUE;
        wcsncpy(szTmp, pszParam, pTmp-pszParam);
        szTmp[pTmp-pszParam] = '\0';
        pTmp++;

        if (!_wcsicmp(szTmp, L"S"))
            wcscpy(config.szServerName, pTmp);
        else if (!_wcsicmp(szTmp, L"D"))
            wcscpy(config.szDatabase, pTmp);           
        else if (!_wcsicmp(szTmp, L"U"))
            wcscpy(config.szUser, pTmp);
        else if (!_wcsicmp(szTmp, L"P"))
            wcscpy(config.szPassword, pTmp);
        else if (!_wcsicmp(szTmp, L"UA"))
            wcscpy(config.szLogonUser, pTmp);
        else if (!_wcsicmp(szTmp, L"TS"))
            config.dwTestSuite = _wtoi(pTmp);
        else if (!_wcsicmp(szTmp, L"FN"))
            wcscpy(config.szFileName, pTmp);
        else if (!_wcsicmp(szTmp, L"NS"))
            wcscpy(config.szNamespace, pTmp);
        else if (!_wcsicmp(szTmp, L"DN"))
        {
            if (!_wcsicmp(pTmp, L"Y"))
                config.bDropNamespace = TRUE;
            else
                config.bDropNamespace = false;
        }
        else if (!_wcsicmp(szTmp, L"MT"))
            config.dwMaxNumThreads = _wtoi(pTmp);
        else if (!_wcsicmp(szTmp, L"MH"))
            config.dwMaxHierarchyDepth = _wtoi(pTmp);
        else if (!_wcsicmp(szTmp, L"NO"))
            config.dwMaxNumObjects = _wtoi(pTmp);
        else if (!_wcsicmp(szTmp, L"ST"))
        {
            if (!_wcsicmp(pTmp, L"Y"))
                config.bGatherStats = TRUE;
            else
                config.bGatherStats = false;
        }
        else if (!_wcsicmp(szTmp, L"SQL"))
        {
            if (!_wcsicmp(pTmp, L"Y"))
                ridDriver = CLSID_WmiRepository_SQL;
            else
                ridDriver = CLSID_WmiRepository_Jet;
        }
        else if (!_wcsicmp(szTmp, L"CS"))
            config.dwCacheSize = _wtoi(pTmp);
        else
            bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\wqltosql.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   wqltosql.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _WQLTOSQL_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#include "precomp.h"

#include <windows.h>
#include <comutil.h>
#include <flexarry.h>
#include <wstring.h>
#include <wqlnode.h>
#include <reposit.h>
#include <time.h>
#include <map>
#include <vector>
#include <wbemcli.h>
#include <wbemint.h>
#include <wqltosql.h>
#include <repcache.h>
#include <reputils.h>
#include <smrtptr.h>
#include <sqlcache.h>
#include <wqllex.h>

#define WMIDB_PROPERTY_THIS   0x1000

//***************************************************************************
//
//  TempQL Lex Table
//
//***************************************************************************

/*----------------------------------------------------

References of {objpath} where
    ResultClass=XXX
    Role=YYY
    RequiredQualifier=QualifierName
    ClassDefsOnly

Associators of {objpath} where
    ResultClass=XXX
    AssocClass=YYY
    Role=PPP
    RequiredQualifier=QualifierName
    RequiredAssocQualifier=QualifierName
    ClassDefsOnly

------------------------------------------------------*/

#define QUERY_TYPE_CLASSDEFS_ONLY 0x1
#define QUERY_TYPE_GETREFS        0x2
#define QUERY_TYPE_GETASSOCS      0x4
#define QUERY_TYPE_SCHEMA_ONLY    0x8

#define QASSOC_TOK_STRING       101
#define QASSOC_TOK_IDENT        102
#define QASSOC_TOK_DOT          103
#define QASSOC_TOK_EQU          104
#define QASSOC_TOK_COLON        105

#define QASSOC_TOK_ERROR        1
#define QASSOC_TOK_EOF          0

#define ST_IDENT                13
#define ST_STRING               19
#define ST_QSTRING              26
#define ST_QSTRING_ESC          30

//***************************************************************************
//
//  CSQLBuilder::FormatSQL
//
//***************************************************************************
HRESULT CSQLBuilder::FormatSQL (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                IWbemQuery *pQuery, _bstr_t &sSQL, DWORD dwFlags,
                                DWORD dwHandleType, SQL_ID *dClassId, 
                                BOOL *bHierarchyQuery, BOOL bTmpTblOK, BOOL *bDeleteQuery,
                                BOOL *bDefault)
{

    // This needs to convert an entire query
    // into SQL.  We assume that any attempt to get
    // a specific object will be done through GetObject.
    // This is strictly to return the ObjectIds of heterogenous
    // query results.

    HRESULT hr = WBEM_S_NO_ERROR;

    if (!m_pSchema)
        return WBEM_E_NOT_FOUND;

    char szTmpNum[25];
    BOOL bPartialFailure = FALSE;
    m_dwTableCount = 1;
    m_bClassSpecified = false;

    m_dNamespace = dScopeId;

    if (bHierarchyQuery)
        *bHierarchyQuery = FALSE;
 
    _bstr_t sColList, sFrom, sWhere;

    sColList = L"select a.ObjectId, a.ClassId, a.ObjectScopeId ";
    sFrom = L" from ObjectMap as a ";
    sWhere = L" where a.ObjectState <> 2";
    
    // Query types:
    // ===========
    // WMIDB_FLAG_QUERY_SHALLOW + WMIDB_HANDLE_TYPE_SCOPE : ObjectScopeId = %I64d
    // WMIDB_FLAG_QUERY_SHALLOW + WMIDB_HANDLE_TYPE_CONTAINER: inner join ContainerObjs as b on b.ContaineeId = a.ObjectId
    //                                                          and b.ContainerId = %I64d
    // WMIDB_FLAG_QUERY_DEEP + <any> : inner join #SubScopeIds on (ID = a.ObjectScopeId OR (ID = a.ObjectId AND a.ObjectId != %I64d))

    if (m_dNamespace)
    {
        sprintf(szTmpNum, "%I64d", m_dNamespace);

        // Scope is an __Instances container
        // This is shallow by definition.
        if (dScopeClassId == INSTANCESCLASSID)
        {
            sWhere += L" and a.ObjectKey != 'root' and a.ClassId = ";
            sWhere += szTmpNum;
            char szTmp[25];
            sprintf(szTmp, "%I64d", dSuperScope);
            sWhere += L" and a.ObjectScopeId in (0, ";
            sWhere += szTmp;
            sWhere += L")";
        }
        else
        {
            // Shallow enumeration
            if (!(dwFlags & WMIDB_FLAG_QUERY_DEEP))
            {   
                if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
                {
                    sFrom += L" inner join ContainerObjs as z on z.ContaineeId = a.ObjectId "
                             L" and z.ContainerId = ";
                    sFrom += szTmpNum;
                }
                else   
                {
                    sWhere += L" and a.ObjectKey != 'root' and a.ObjectScopeId in (0,";
                    sWhere += szTmpNum;
                    sWhere += L")";
                }
            }
            // Deep enumeration, we enumerate all contained and subscope objects.
            else
            {   
                if (bTmpTblOK)
                {
                    sFrom += L" inner join #SubScopeIds on (ID = a.ObjectScopeId OR (ID = a.ObjectId AND a.ObjectId != ";                
                    sFrom += szTmpNum;
                    sFrom += L"))";
                }
                else
                    hr = E_NOTIMPL;
            }
        }
    }

    if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
        m_dNamespace = dSuperScope; // Containers are not valid scopes.

    sSQL = "";

    if (pQuery)
    {
        SWQLNode *pTop = NULL, *pRoot = NULL;
        pQuery->GetAnalysis(WMIQ_ANALYSIS_RESERVED, 0, (void **)&pTop);
        if (pTop && pTop->m_pLeft)
        {
            pRoot = pTop->m_pLeft;

            if (bDeleteQuery)
            {
                if (pRoot->m_dwNodeType == TYPE_SWQLNode_Delete)
                    *bDeleteQuery = TRUE;
                else
                    *bDeleteQuery = FALSE;
            }

            // *** WARNING ***
            // This is phase I of this formatting code.
            // In the future, we will need to also support
            // joins, counts, order by, group by, having,
            // qualifier queries, and lots of other stuff
            // that has yet to be defined. 
            // For now, this will just return a single 
            // ObjectId for any query that is passed in.

            // Reject any query with Where options (order by, group by)

            if (pRoot->m_pRight != NULL)
            {
                if (pRoot->m_pRight->m_pRight != NULL)
                {
                    bPartialFailure = TRUE;
                }
            }

            // No counts, or multi-table queries.

            if (pRoot->m_pLeft != NULL)
            {
                hr = GetClassFromNode(pRoot->m_pLeft, bDefault);
                if (SUCCEEDED(hr))
                {
                    if (m_dClassID == 1)
                    {
                        sWhere += L" and a.ClassId = 1";
                        if (bDefault)
                            *bDefault = TRUE;
                    }
                    else if (m_dClassID == INSTANCESCLASSID)
                    {
                        wchar_t wTemp[128];
                        swprintf(wTemp, L" select a.ObjectId, %I64d, a.ObjectScopeId ", INSTANCESCLASSID);
                        sColList = wTemp;

                        sWhere += L" and a.ClassId = 1";     // Classes only
                        if (bDefault)
                            *bDefault = TRUE;
                    }
                }
            }           

            if (SUCCEEDED(hr))
            {
                // Now we parse the where clause.
                if (pRoot->m_pRight && pRoot->m_pRight->m_pLeft)
                {
                    _bstr_t sNewSQL;
                    bool bSys = false;
                    hr = FormatWhereClause((SWQLNode_RelExpr *)pRoot->m_pRight->m_pLeft, sNewSQL, L"a", bSys);
                    if (SUCCEEDED(hr))
                    {
                        if (bSys)
                        {
                            sFrom += L" inner join vSystemProperties as av on av.ObjectId = a.ObjectId ";
                        }
                        sWhere += L" AND ";
                        sWhere += sNewSQL;

                        // Make sure the results are limited to instances of the requested class
                        // (Safeguard)

                        if (!m_bClassSpecified)
                        {
                            wchar_t wTemp[256];
                            if (bSys)
                            {
                                swprintf(wTemp, L" and exists (select * from ClassData as j where av.ObjectId = j.ObjectId"
                                    L" and j.ClassId= %I64d) ", m_dClassID);                                
                            }
                            else
                            {
                                // __Instances is automatically a shallow hierarchy query

                                if (m_dClassID != INSTANCESCLASSID)
                                {
                                    // Until we figure out how to do this in Jet,
                                    // we will only select instances of the requested class.
                                    if (bTmpTblOK)
                                        wcscpy(wTemp, L" AND EXISTS (select b.ClassId from #Children as b "
                                                    L"    where b.ClassId = a.ClassId )");
                                    else
                                        swprintf(wTemp, L" AND a.ClassId = %I64d", m_dClassID);

                                    if (bHierarchyQuery)
                                        *bHierarchyQuery = TRUE;
                                }
                            }

                            sWhere += wTemp;
                        }
                    }

                }
                else
                {
                    // __Instances is automatically a shallow hierarchy query

                    if (m_dClassID != INSTANCESCLASSID)
                    {
                        wchar_t wTemp[256];
                    
                        // If no criteria, make sure we only get the class we asked for.

                        if (bTmpTblOK)
                            wcscpy(wTemp, L" AND EXISTS (select b.ClassId from #Children as b "
                                        L"    where b.ClassId = a.ClassId)");
                        else
                            swprintf(wTemp, L" AND a.ClassId = %I64d", m_dClassID);

                        if (bHierarchyQuery)
                            *bHierarchyQuery = TRUE;
                        sWhere += wTemp;
                    }
                }

                sSQL = sColList + sFrom + sWhere;

                if (dClassId)
                    *dClassId = m_dClassID;
            }
        }
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;

    if ((SUCCEEDED(hr) && bPartialFailure))
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;

    return hr;
}


//***************************************************************************
//
//  CSQLBuilder::FormatSQL
//
//***************************************************************************

HRESULT CSQLBuilder::FormatSQL (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                SQL_ID dTargetObjID, LPWSTR pResultClass,
                                LPWSTR pAssocClass, LPWSTR pRole, LPWSTR pResultRole, LPWSTR pRequiredQualifier,
                                LPWSTR pRequiredAssocQualifier, DWORD dwQueryType, _bstr_t &sSQL, DWORD dwFlags,
                                DWORD dwHandleType, SQL_ID *_dAssocClass, SQL_ID *_dResultClass, BOOL bIsClass)
{
    // Query types:
    // ===========
    // WMIDB_FLAG_QUERY_SHALLOW + WMIDB_HANDLE_TYPE_SCOPE : ObjectScopeId = %I64d

    // WMIDB_FLAG_QUERY_SHALLOW + WMIDB_HANDLE_TYPE_CONTAINER: inner join ContainerObjs as b on b.ContaineeId = a.ObjectId
    //                                                          and b.ContainerId = %I64d
    // WMIDB_FLAG_QUERY_DEEP + <any> : inner join #SubScopeIds on (ID = a.ObjectScopeId OR (ID = a.ObjectId AND a.ObjectId != %I64d))
    // Scope = __Instances=<Class>: and ClassId = %I64d

    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwRoleID = 0, dwResultRole = 0, dwAssocQfr = 0;
    SQL_ID dAssocClass = 0, dTargetObj = 0, dThisClassId = 0;
    bool bWhereReq = true;
    _bstr_t sRole = "", sAssocQfr = "", sAssocClass = "", sResultRole = "";
    _bstr_t sName;
    SQL_ID dwSuperClassID;
    SQL_ID dwScopeID;
    DWORD dwTemp;
    _bstr_t sJoin = L"RefId";

    hr = m_pSchema->GetClassInfo(dTargetObjID, sName, dwSuperClassID, dwScopeID, dwTemp);
    if (SUCCEEDED(hr))
    {
        dThisClassId = dTargetObjID;
        sJoin = L"RefClassId";
    }
    hr = WBEM_S_NO_ERROR;

    m_dNamespace = dScopeId;

    if (dwQueryType & QUERY_TYPE_CLASSDEFS_ONLY)
        sSQL = L"select distinct a.ClassId, 1, 0 ";
    else
        sSQL = L"select a.ObjectId, a.ClassId, a.ObjectScopeId ";

    sSQL += L" from ObjectMap as a ";
    if (m_dNamespace)
    {
        char szTmp[25];
        sprintf(szTmp, "%I64d", m_dNamespace);

        if (dScopeClassId == INSTANCESCLASSID)
        {
            sSQL += L" WHERE a.ClassId = ";
            sSQL += szTmp;
            sprintf(szTmp, "%I64d", dSuperScope);
            sSQL += L" and a.ObjectScopeId = ";
            sSQL += szTmp;
        }
        else
        {
            if (!(dwFlags & WMIDB_FLAG_QUERY_DEEP))
            {
                if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
                {
                    sSQL += L" inner join ContainerObjs as z on z.ContaineeId = a.ObjectId "
                            L" WHERE z.ContainerId = ";
                    sSQL += szTmp;
                }
                else
                {
                    sSQL += " WHERE a.ObjectScopeId = ";
                    sSQL += szTmp;
                }
            }
            else
            {
                sSQL += L" inner join #SubScopeIds on (ID = a.ObjectScopeId OR (ID = a.ObjectId AND a.ObjectId != ";
                sSQL += szTmp;
                sSQL += L" )) ";
            }
        }

        sSQL += L" AND ";

    }
    else 
        sSQL += " WHERE ";
    
    sSQL += " a.ObjectState <> 2 AND ";

    // Containers are not valid scopes.

    if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
        m_dNamespace = dSuperScope;


    // RESULTCLASS
    if (pResultClass != NULL)
    {
        wchar_t wTemp[100];

        // Get the class ID of this class
        hr = m_pSchema->GetClassID(pResultClass, m_dNamespace, dThisClassId);
        if (FAILED(hr))
            goto Exit;

        swprintf(wTemp, L" a.ClassId = %I64d", dThisClassId);
        bWhereReq = false;
        sSQL += wTemp;
        if (_dResultClass)
            *_dResultClass = dThisClassId;
    }
    // REQUIREDQUALIFIER
    if (pRequiredQualifier != NULL)
    {
        /*
        wchar_t wTemp[255];
        DWORD dwPropId = 0;
        hr = m_pSchema->GetPropertyID(pRequiredQualifier, dThisClassId, REPDRVR_FLAG_QUALIFIER, 
                        REPDRVR_IGNORE_CIMTYPE, dwPropId, NULL, NULL, NULL, TRUE);
        if (FAILED(hr))
            goto Exit;

        if (!bWhereReq)
            sSQL += L" AND ";

        // FIXME: This will only work on class-level qualifiers.
        // It will not work on instance qualifiers.  

        swprintf(wTemp, L"EXISTS (select ClassId from ClassData as c where a.ClassId = c.ObjectId and c.PropertyId = %ld)",
            dwPropId);
        bWhereReq = false;
        sSQL += wTemp;
        */
    }

    if (!bWhereReq)
        sSQL += " AND ";

    // ROLE
    if (pRole)
    {
        wchar_t wTemp[512];
        swprintf(wTemp, L" and b.PropertyId in (select PropertyId from PropertyMap where PropertyName = '%s')", pRole);
        sRole = wTemp;
    }

    // RESULTROLE
    if (pResultRole)
    {
        wchar_t wTemp[512];
        swprintf(wTemp, L" and b.PropertyId in (select PropertyId from PropertyMap where PropertyName = '%s')", pResultRole);
        sResultRole = wTemp;
    }

    // REQUIREDASSOCQUALIFIER
    if (pRequiredAssocQualifier)
    {
        /*
        wchar_t wTemp[256];
        hr = m_pSchema->GetPropertyID(pRequiredAssocQualifier, dThisClassId, REPDRVR_FLAG_QUALIFIER, 
                REPDRVR_IGNORE_CIMTYPE, dwAssocQfr, NULL, NULL, NULL, TRUE);
        if (FAILED(hr))
            goto Exit;
        swprintf(wTemp, L" AND EXISTS (select ObjectId from ClassData as d where b.ClassId = d.ObjectId and d.PropertyId = %ld)",
            dwAssocQfr);
        sAssocQfr = wTemp;
        */
    }

    // ASSOCCLASS
    if (pAssocClass)
    {
        wchar_t wTemp[256];
        hr = m_pSchema->GetClassID(pAssocClass, m_dNamespace, dAssocClass);
        if (FAILED(hr))
            goto Exit;
        swprintf(wTemp, L" AND b.ClassId = %I64d", dAssocClass);
        sAssocClass = wTemp;
        if (_dAssocClass)
            *_dAssocClass = dAssocClass;
    }

    if (dwQueryType & QUERY_TYPE_GETREFS)
    {
        wchar_t wTemp[1024];

        if (!bIsClass)
        {
            swprintf(wTemp, L" EXISTS (select ObjectId from ClassData as b where a.ObjectId = b.ObjectId "
                            L" %s and b.%s = %I64d)", (const wchar_t *)sRole, (const wchar_t *)sJoin, dTargetObjID);
        }
        else
        {
            swprintf(wTemp, L" a.ClassId = 1 AND EXISTS (select r.ClassId from ReferenceProperties as r  "
                            L" where r.ClassId = a.ObjectId and r.RefClassId = %I64d)", dTargetObjID);
        }

        sSQL += wTemp;
    }
    else
    {
        wchar_t wTemp[2048];
        if (!bIsClass)
        {
            swprintf(wTemp, L" EXISTS (select b.RefId from ClassData as b inner join ClassData as c on c.ObjectId = b.ObjectId "
                            L" where c.RefId = a.ObjectId and b.%s = %I64d and c.RefId <> b.RefId %s%s%s%s)", (const wchar_t *)sJoin,
                            dTargetObjID, (const wchar_t *)sRole, (const wchar_t *)sResultRole, (const wchar_t *)sAssocClass, 
                            (const wchar_t *)sAssocQfr);
        }
        else
        {
            swprintf(wTemp, L" a.ClassId = 1 AND EXISTS (select r.ClassId from ReferenceProperties as r  "
                            L" INNER JOIN ReferenceProperties as r2 on r.ClassId = r2.ClassId and r.PropertyId <> r2.PropertyId"
                            L" where r.ClassId = a.ObjectId and r2.RefClassId = %I64d)", dTargetObjID);


        }
        sSQL += wTemp;
    }


Exit:

    return hr;

}
//***************************************************************************
//
//  CSQLBuilder::FormatWhereClause
//
//***************************************************************************

HRESULT CSQLBuilder::FormatWhereClause (SWQLNode_RelExpr *pNode, _bstr_t &sSQL, LPCWSTR lpJoinAlias, bool &bSysPropsUsed)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bDone = FALSE;
    SQL_ID dClassId = 0;

    // For each node, we need to 
    //  1. Look at the node type (and, or, not or typed)
    //  2. If not typed, group and continue
    //  3. If typed, construct the clause based on the property ID of the 
    //     property, the value and the operator.

    if (pNode)
    {
        DWORD dwType = pNode->m_dwExprType;
        _bstr_t sTemp;

        switch(dwType)
        {
        case WQL_TOK_OR:
        case WQL_TOK_AND:
            if (pNode->m_pLeft)
            {
                sTemp = "(";
                hr |= FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pLeft, sTemp, lpJoinAlias, bSysPropsUsed);
            }
            if (dwType == WQL_TOK_OR)
                sTemp += " OR ";
            else 
                sTemp += " AND ";

            if (pNode->m_pRight)
            {                
                hr |= FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pRight, sTemp, lpJoinAlias, bSysPropsUsed);
                sTemp += ")";
            }

            sSQL += sTemp;

            break;
        case WQL_TOK_NOT:
            sSQL += " NOT ";

            // Supposedly, only a left clause follows not...

            if (pNode->m_pLeft)
            {
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pLeft, sTemp, lpJoinAlias, bSysPropsUsed);
                sSQL += sTemp;
            }
            m_bClassSpecified = false;  // whatever we've done probably negated the class qualifier.
            break;

        default:    // Typed expression

            m_dwTableCount++;
            
            SWQLTypedExpr *pExpr = ((SWQLNode_RelExpr *)pNode)->m_pTypedExpr;
            if (pExpr != NULL)
            {
                DWORD dwProp1 = 0, dwProp2 = 0, dwOp = 0;
                DWORD dwStorage1 = 0, dwStorage2 = 0;
                DWORD dwKey1, dwKey2;
                _bstr_t sPropName, sValue, sSrc;
                wchar_t sAlias[256];
                swprintf(sAlias, L"%s%ld", lpJoinAlias, m_dwTableCount);

                _bstr_t sColName;
                if (pExpr->m_pColRef)
                    sColName = pExpr->m_pColRef;
                else if (pExpr->m_pIntrinsicFuncOnColRef && 
                    !_wcsicmp(pExpr->m_pIntrinsicFuncOnColRef, L"datepart") && 
                    pExpr->m_pLeftFunction)
                {
                    sColName = ((SWQLNode_Datepart *)pExpr->m_pLeftFunction)->m_pColRef->m_pColName;
                }
                hr = GetPropertyID(m_dClassID, pExpr->m_pQNLeft, sColName, dwProp1, dwStorage1, dwKey1);

                if (SUCCEEDED(hr))
                {
                    if (dwStorage1 == WMIDB_PROPERTY_THIS)
                    {
                        // Special-case: the __this property.

                       hr = m_pSchema->GetClassID(pExpr->m_pConstValue->m_Value.m_pString, m_dNamespace, dClassId);
                       if (SUCCEEDED(hr) && dClassId != 1)
                       {
                           sSQL += L" a.ObjectId in (";

                           SQL_ID *pIDs = NULL;
                           int iNumChildren = 0;
                           hr = m_pSchema->GetDerivedClassList(dClassId, &pIDs, iNumChildren);
                           if (SUCCEEDED(hr))
                           {
                               char szTmp[25];
                               sprintf(szTmp, "%I64d", dClassId);
                               sSQL += szTmp;

                               for (int i = 0; i < iNumChildren; i++)
                               {
                                   sSQL += L",";
                                   sprintf(szTmp, "%I64d", pIDs[i]);
                                   sSQL += szTmp;                                            
                               }
                               delete pIDs;
                               sSQL += L")";
                            }
                       }

                    }
                    else
                    {
                        GetStorageTable(dwStorage1, dwKey1, sSrc);

                        if (dwStorage1 == WMIDB_STORAGE_COMPACT)
                            swprintf(sAlias, L"%sv", lpJoinAlias);

                        // Can't query anything stored as image

                        if (dwStorage1 == WMIDB_STORAGE_IMAGE || dwStorage2 == WMIDB_STORAGE_IMAGE)
                            return WBEM_E_QUERY_NOT_IMPLEMENTED;

                        dwOp = pExpr->m_dwRelOperator;

                        hr = FunctionalizeProperty (sAlias, dwStorage1, pExpr->m_pIntrinsicFuncOnColRef, pExpr->m_pLeftFunction, pExpr->m_pColRef, sPropName);

                        if (SUCCEEDED(hr))
                        {
                            if (pExpr->m_pConstValue != NULL)
                            {
                                CIMTYPE ct=0;
                                m_pSchema->GetPropertyInfo(dwProp1, NULL, NULL, NULL, (DWORD *)&ct);
                                if (ct != CIM_DATETIME)
                                    hr = FunctionalizeValue (pExpr->m_pConstValue, dwStorage1, pExpr->m_pIntrinsicFuncOnConstValue, sValue);
                                else
                                {
                                    // Skip this token... 
                                    // The core will post-filter.
                                    bDone = TRUE;
                                    sSQL += L" 1=1 ";
                                }
                            }
                            else if (pExpr->m_pJoinColRef != NULL)
                            {
                                // SPECIAL CASE.  To compare two properties, we deliberately cause a join to happen.

                                m_dwTableCount++;
                                wchar_t sAlias2[256];
                            
                                _bstr_t sSrc2;
                                _bstr_t sPropName2, sExtra = L"";

                                if (pExpr->m_pJoinColRef)
                                    sColName = pExpr->m_pJoinColRef;
                                else if (pExpr->m_pIntrinsicFuncOnJoinColRef && 
                                    !_wcsicmp(pExpr->m_pIntrinsicFuncOnJoinColRef, L"datepart") && 
                                    pExpr->m_pRightFunction)
                                {
                                    sColName = ((SWQLNode_Datepart *)pExpr->m_pRightFunction)->m_pColRef->m_pColName;
                                }

                                hr = GetPropertyID(m_dClassID, pExpr->m_pQNRight, sColName, dwProp2, dwStorage2, dwKey2);
                                GetStorageTable(dwStorage2, dwKey2, sSrc2);
                                if (dwStorage2 == WMIDB_STORAGE_COMPACT)
                                    swprintf(sAlias2, L"%sv", lpJoinAlias);
                                else
                                    swprintf(sAlias2, L"%s%ld", lpJoinAlias, m_dwTableCount);

                                hr = FunctionalizeProperty (sAlias2, dwStorage2, pExpr->m_pIntrinsicFuncOnJoinColRef, pExpr->m_pRightFunction, pExpr->m_pJoinColRef, sPropName2);

                                if (pExpr->m_pQNRight)
                                {        
                                    SWQLQualifiedNameField *pNF = (SWQLQualifiedNameField *)pExpr->m_pQNRight->m_aFields[0];
                                    hr = FormatPositionQuery(pNF, pExpr->m_dwRightArrayIndex, sAlias2, sTemp);
                                    if (SUCCEEDED(hr))
                                        sExtra = sTemp;
                                }
                                if (pExpr->m_pQNLeft)
                                {        
                                    SWQLQualifiedNameField *pNF = (SWQLQualifiedNameField *)pExpr->m_pQNLeft->m_aFields[0];
                                    hr = FormatPositionQuery(pNF, pExpr->m_dwLeftArrayIndex, sAlias, sTemp);
                                    if (SUCCEEDED(hr))
                                        sExtra += sTemp;
                                }

                                if (SUCCEEDED(hr))
                                {
                                    wchar_t wTempSQL[2048];

                                    // If the right side is a system property, we just treat this
                                    // like a regular comparison.

                                    if (dwStorage2 == WMIDB_STORAGE_COMPACT)
                                    {                                                                        
                                        bSysPropsUsed = true;
                                        bDone = false;
                                        sValue = sPropName2;
                                    }
                                    // If the left side is a system property, we need to reverse the
                                    // values and let it through...

                                    else if (dwStorage1 == WMIDB_STORAGE_COMPACT)
                                    {
                                        sValue = sPropName;
                                        sPropName = sPropName2;
                                        wcscpy(sAlias,sAlias2);
                                        dwProp1 = dwProp2;
                                        bSysPropsUsed = true;
                                        dwStorage1 = dwStorage2;       
                                        sSrc = sSrc2;
                                    }
                                    // Otherwise, we create a new join and wrap up.
                                    else
                                    {
                                        LPWSTR lpOp = GetOperator(dwOp);
                                        CDeleteMe <wchar_t> r (lpOp);

                                        swprintf(wTempSQL, L" EXISTS "
                                              L" (select %s.ObjectId from %s as %s inner join %s as %s on %s%s%s and %s.ObjectId = %s.ObjectId "
                                              L" where %s.ObjectId=%s.ObjectId and %s.PropertyId = %ld and %s.PropertyId = %ld%s)",
                                              sAlias, (const wchar_t *)sSrc, sAlias,
                                              (const wchar_t *)sSrc2, sAlias2, (const wchar_t *)sPropName, 
                                              lpOp,(const wchar_t *)sPropName2, sAlias,
                                              sAlias2, lpJoinAlias, sAlias, sAlias,
                                              dwProp1, sAlias2, dwProp2, (const wchar_t *)sExtra);                                        
                                        bDone = TRUE;
                                        sSQL += wTempSQL;
                                    }

                                }
                            }

                            if (SUCCEEDED(hr) && !bDone)
                            {
                                _bstr_t sPrefix = "";
                                LPWSTR lpOp = GetOperator(dwOp);

                                if (!lpOp || !wcslen(lpOp))
                                {
                                    switch (dwOp)
                                    {
                                    case WQL_TOK_NULL:
                                    case WQL_TOK_ISNULL:
                                      sPrefix = " NOT ";
                                      sValue = "";                      
                                      break;
                                    case WQL_TOK_NOT_NULL:
                                      sValue = "";                      
                                      break;
                                    case WQL_TOK_ISA:
                                       sPropName = sAlias;
                                       sPropName += L".RefClassId";
                                       delete lpOp;
                                       lpOp = new wchar_t [10];
                                       if (lpOp)
                                       {
                                           hr = m_pSchema->GetClassID(pExpr->m_pConstValue->m_Value.m_pString, m_dNamespace, dClassId);
                                           if (SUCCEEDED(hr) && dClassId != 1)
                                           {
                                               wcscpy(lpOp, L" in ");
                                               sValue = L"(";
                                               SQL_ID *pIDs = NULL;
                                               int iNumChildren = 0;
                                               hr = m_pSchema->GetDerivedClassList(dClassId, &pIDs, iNumChildren);
                                               if (SUCCEEDED(hr))
                                               {
                                                   char szTmp[25];
                                                   sprintf(szTmp, "%I64d", dClassId);
                                                   sValue += szTmp;

                                                   for (int i = 0; i < iNumChildren; i++)
                                                   {
                                                       sValue += L",";
                                                       sprintf(szTmp, "%I64d", pIDs[i]);
                                                       sValue += szTmp;                                            
                                                   }
                                                   delete pIDs;
                                                   sValue += L")";
                                                }
                                               if (dwStorage1 == WMIDB_STORAGE_COMPACT)
                                                   dwStorage1 = WMIDB_STORAGE_REFERENCE;
                                           }
                                           else
                                           {
                                               wcscpy(lpOp, L" <> ");
                                               sValue = L"0";
                                           }
                                       }
                                       else
                                           hr = WBEM_E_OUT_OF_MEMORY;
                                   
                                       break;
                                    case WQL_TOK_BETWEEN:
                                       delete lpOp;
                                       lpOp = new wchar_t [10];
                                       if (lpOp)
                                       {
                                           wcscpy(lpOp, L" between ");
                                           sValue += " and ";
                                           hr = FunctionalizeValue (pExpr->m_pConstValue2, dwStorage2, pExpr->m_pIntrinsicFuncOnConstValue, sTemp);
                                           sValue += sTemp;
                                       }
                                       else
                                           hr = WBEM_E_OUT_OF_MEMORY;
                                      break;  
                                    case WQL_TOK_NOT_IN:
                                    case WQL_TOK_IN:
                                    case WQL_TOK_IN_SUBSELECT:
                                    case WQL_TOK_NOT_IN_SUBSELECT:
                                    case WQL_TOK_IN_CONST_LIST:
                                    case WQL_TOK_NOT_IN_CONST_LIST:
                                      delete lpOp;
                                      lpOp = new wchar_t [10];  
                                      if (lpOp)
                                      {
                                          wcscpy(lpOp, L"");
                                          if (pExpr->m_dwRelOperator == WQL_TOK_NOT_IN ||
                                              pExpr->m_dwRelOperator == WQL_TOK_NOT_IN_SUBSELECT ||
                                              pExpr->m_dwRelOperator == WQL_TOK_NOT_IN_CONST_LIST)
                                          {
                                              wcscpy(lpOp, L" not ");
                                          }
                                          wcscat(lpOp, L" in ");
                                          sValue = "(";

                                          if (pExpr->m_dwRelOperator == WQL_TOK_IN_SUBSELECT ||
                                              pExpr->m_dwRelOperator == WQL_TOK_NOT_IN_SUBSELECT) 
                                          {
                                              // If a subselect, we need to construct an entirely new tree, passing
                                              // in the current alias.  

                                                _bstr_t sTemp;
                                                m_dwTableCount++;
                                                wchar_t wAlias3[256];
                                                swprintf(wAlias3, L"%s%ld", lpJoinAlias, m_dwTableCount);

                                                wchar_t *pColName = sPropName;
                                                pColName += wcslen(sAlias)+1;

                                                hr = FormatSimpleSelect (wAlias3, pColName, pExpr->m_pSubSelect, sTemp);
                                                if (SUCCEEDED(hr))
                                                    sValue += sTemp;                        
                                          }
                                          else 
                                          {
                                              // If a const list, behaves as normal
                                              if (pExpr->m_pConstList)
                                              {
                                                  for (int iPos = 0; iPos < pExpr->m_pConstList->m_aValues.Size(); iPos++) 
                                                  {
                                                      if (iPos > 0) 
                                                          sValue += ",";

                                                      hr = FunctionalizeValue(((SWQLTypedConst *)pExpr->m_pConstList->m_aValues.GetAt(iPos)), dwStorage1, pExpr->m_pIntrinsicFuncOnConstValue, sTemp);
                                                      sValue += sTemp;
                                                  }
                                              }
                                          }

                                          sValue += ")";
                                      }
                                      else
                                          hr = WBEM_E_OUT_OF_MEMORY;
                                      break;
                                    default:    
                                        break;
                                    }
                                }

                                if (SUCCEEDED(hr))
                                {
                                    long lLen = wcslen(sValue) + 512;

                                    wchar_t *pTempSQL = new wchar_t[lLen];
                                    CDeleteMe <wchar_t> r (pTempSQL);
                                    if (pTempSQL)
                                    {
                                        if (sValue.length() != 0)
                                        {
                                            if (dwStorage1 != WMIDB_STORAGE_COMPACT)
                                                sTemp = L" and ";

                                            sTemp += sPropName + lpOp + sValue;
                                            sValue = sTemp;
                                        }
                        
                                        // Set array position (for left value only)
                                        if (pExpr->m_dwLeftFlags & WQL_FLAG_COMPLEX_NAME)
                                        {
                                            if (pExpr->m_pQNLeft)
                                            {
                                
                                                SWQLQualifiedNameField *pNF = (SWQLQualifiedNameField *)pExpr->m_pQNLeft->m_aFields[0];
                                                hr = FormatPositionQuery(pNF, pExpr->m_dwLeftArrayIndex, sAlias, sTemp);
                                                if (SUCCEEDED(hr))
                                                    sValue + sTemp;

                                            }
                                        }

                                        if (dwStorage1 != WMIDB_STORAGE_COMPACT)
                                        {
                                            swprintf(pTempSQL, L"%s EXISTS (select %s.ObjectId from %s as %s where %s.ObjectId=%s.ObjectId and %s.PropertyId = %ld %s)",
                                                            (const wchar_t *)sPrefix, sAlias, (const wchar_t *)sSrc, sAlias,
                                                            sAlias, lpJoinAlias, sAlias,
                                                            dwProp1, (const wchar_t *)sValue);
                                        }
                                        else
                                        {
                                            bSysPropsUsed = true;
                                            // This is a straight comparison on a system property...
                                            swprintf(pTempSQL, L" %s",
                                                (const wchar_t *)sValue);
                                        }
                                        sSQL += pTempSQL;
                                    }
                                    else
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                    delete lpOp;
                                }
                            }
                        }                        
                    }
                }

            }
            break;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLBuilder::GetStorageTable
//
//***************************************************************************

HRESULT CSQLBuilder::GetStorageTable(DWORD dwStorage, DWORD dwKey, _bstr_t &sTable)
{
    if (dwStorage == WMIDB_STORAGE_COMPACT)
        sTable = L"vSystemProperties";
    else
    {
        sTable = L"ClassData";

        if (dwKey & 4 || dwKey & 8)
        {
            switch(dwStorage)
            {
            case WMIDB_STORAGE_STRING:
                sTable = L"IndexStringData";
                break;
            case WMIDB_STORAGE_NUMERIC:
                sTable = L"IndexNumericData";
                break;
            case WMIDB_STORAGE_REAL:
                sTable = L"IndexRealData";
                break;
            case WMIDB_STORAGE_REFERENCE:
                sTable = L"IndexRefData";
                break;
            }
        
        }
    }
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CSQLBuilder::GetPropertyID
//
//***************************************************************************

HRESULT CSQLBuilder::GetPropertyID (SQL_ID dClassID, SWQLQualifiedName *pQN, LPCWSTR pColRef, DWORD &PropID, DWORD &Storage, DWORD &Flags)
{

    // If this is an embedded object property,
    // we need the actual class ID.  The only way
    // to do that is the walk through all the properties,
    // and reconcile each layer.

    BOOL bThis = FALSE;

    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dRefClassId = dClassID;

    if (pQN != NULL)
    {        
        /*
        for (int i = pQN->GetNumNames() - 1; i >= 0; i--)
        {
            SWQLQualifiedNameField *pNF = (SWQLQualifiedNameField *)pQN->m_aFields[i];
            if (pNF)
            {
                hr = m_pSchema->GetPropertyID(pNF->m_pName, dRefClassId, 0, 
                        REPDRVR_IGNORE_CIMTYPE, PropID, &dClassID, NULL, NULL, TRUE);
                if (SUCCEEDED(hr))
                {
                    // Look up the property ID for this class.
                    hr = m_pSchema->GetPropertyInfo(PropID, NULL, NULL, &Storage,
                        NULL, &Flags);
                }                    
            }
        }
        */
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
    }
    else if (pColRef != NULL)
    {
        wchar_t wName[1024];
        if (!_wcsicmp(pColRef, L"__this"))
        {
            Storage = WMIDB_PROPERTY_THIS;
            bThis = TRUE;
            m_bClassSpecified = true;    // they are specifying which classes they want...
        }
        else
        {
            wcscpy(wName, pColRef);

            // Look up the property ID for this class.
            hr = m_pSchema->GetPropertyID(wName, m_dClassID, 0, REPDRVR_IGNORE_CIMTYPE,
                    PropID, &dClassID, NULL, NULL, TRUE);
            if (SUCCEEDED(hr))
                hr = m_pSchema->GetPropertyInfo(PropID, NULL, NULL, &Storage,
                    NULL, &Flags);
        }
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;

    if (!bThis)
    {
        if (m_dClassID == dClassID)
            m_bClassSpecified = true;

        if (Flags & REPDRVR_FLAG_SYSTEM)    
            Storage = WMIDB_STORAGE_COMPACT;
    }

    return hr;

}

//***************************************************************************
//
//  CSQLBuilder::FunctionalizeProperty
//
//***************************************************************************

HRESULT CSQLBuilder::FunctionalizeProperty (LPCWSTR lpAlias, DWORD dwType, LPWSTR lpFuncName, SWQLNode *pFunction, LPWSTR lpColName, _bstr_t &sProp)
{
    // Apply any functions to the appropriate column of ClassData

    HRESULT hr = WBEM_S_NO_ERROR;
    bool bRef = false;

    _bstr_t sTemp;

    if (lpFuncName != NULL)
    {
        if (!_wcsicmp(lpFuncName, L"datepart"))
            sTemp = L"substring";
        else
            sTemp = lpFuncName;

        sTemp += "(";       
    }

    sTemp += lpAlias;
    sTemp += L".";

    switch(dwType)
    {
      case WMIDB_STORAGE_STRING:
         // Unicode
         sTemp += L"PropertyStringValue";
         break;
      case WMIDB_STORAGE_NUMERIC:
          // SQL_ID
         sTemp += L"PropertyNumericValue";
         break;
      case WMIDB_STORAGE_REAL:
          // real
         sTemp += L"PropertyRealValue";
         break;
      case WMIDB_STORAGE_REFERENCE:
         // REF: Since this is stored as a number, we have to 
          // subselect to get the real path, and apply all
          // functions to it.
         bRef = true;
         sTemp = L"(select ObjectPath from ObjectMap where ObjectId = ";
         sTemp += lpAlias;
         sTemp += ".RefId)";
         break;
      case WMIDB_STORAGE_COMPACT:   
          // System property, using vSystemProperties
          sTemp += lpColName;
          break;
      default:
        hr = WBEM_E_INVALID_QUERY;
        break;
    }

    if (pFunction)
    {
        if (pFunction->m_dwNodeType == TYPE_SWQLNode_Datepart)
        {
            sTemp += ",";

            switch(((SWQLNode_Datepart *)pFunction)->m_nDatepart)
            {
            case WQL_TOK_YEAR:
                sTemp += L"1,4";
                break;
            case WQL_TOK_MONTH:
                sTemp += L"5,2";
                break;
            case WQL_TOK_DAY:
                sTemp += L"7,2";
                break;
            case WQL_TOK_HOUR:
                sTemp += L"9,2";
                break;
            case WQL_TOK_MINUTE:
                sTemp += L"11,2";
                break;
            case WQL_TOK_SECOND:
                sTemp += L"13,2";
                break;
            case WQL_TOK_MILLISECOND:
                sTemp += L"16,6";
                break;
            default:
                hr = WBEM_E_INVALID_QUERY;
                break;
            }        
        }
    }

    if (lpFuncName != NULL)
    {
        sTemp += ")";
    }

    if (SUCCEEDED(hr))
        sProp = sTemp;

    return hr;
}

//***************************************************************************
//
//  CSQLBuilder::FunctionalizeValue
//
//***************************************************************************

HRESULT CSQLBuilder::FunctionalizeValue(SWQLTypedConst *pValue, DWORD dwType, LPWSTR lpFuncName, _bstr_t &sValue)
{
    // Apply any functions to the data, and add quotes as appropriate.

    HRESULT hr = WBEM_S_NO_ERROR;
    _bstr_t sTemp;

    if (lpFuncName)
    {
        sTemp = lpFuncName;
        sTemp += L"(";
    }

    if (pValue->m_dwType == VT_LPWSTR) {
        sTemp += L"'";
        LPWSTR lpTemp = StripQuotes(pValue->m_Value.m_pString);
        CDeleteMe <wchar_t> r (lpTemp);
        LPWSTR lpTemp2 = StripQuotes(lpTemp, '%');
        CDeleteMe <wchar_t> r2 (lpTemp2);

        if (dwType == WMIDB_STORAGE_COMPACT && !wcslen(lpTemp2))
            sTemp += L"meta_class";
        else
            sTemp += lpTemp2;
        sTemp += L"'";
    }
	else if(pValue->m_dwType == VT_NULL)
	{
		hr = WBEM_E_INVALID_QUERY;
	}
    else if (pValue->m_dwType == VT_I4)
    {
        char szTmp[25];
        sprintf(szTmp, "%ld", pValue->m_Value.m_lValue);
        sTemp += szTmp;
    }
    else if (pValue->m_dwType == VT_BOOL)
    {
        if (pValue->m_Value.m_bValue)
            sTemp += L"1";
        else
            sTemp += L"0";
    }
    else if (pValue->m_dwType == VT_R8)
    {
        char szTmp[25];
        sprintf(szTmp, "%lG", pValue->m_Value.m_dblValue);
        sTemp += szTmp;
    }

    if (lpFuncName)
    {
        sTemp += L")";
    }

    if (SUCCEEDED(hr))
        sValue = sTemp;

    return hr;
}

//***************************************************************************
//
//  CSQLBuilder::FormatSimpleSelect
//
//***************************************************************************

HRESULT CSQLBuilder::FormatSimpleSelect (LPCWSTR lpUseAlias,LPCWSTR lpColName, SWQLNode *pTop, _bstr_t &sSQL)
{
    // Internal use only: This is to format subselects, so it should
    // consist of a single column select from a known class.

    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dClassID;
    DWORD dwPropID = 0, dwStorage = 0, dwFlags = 0;
    _bstr_t sSrc = L"";
    _bstr_t sExtra=L"";
    _bstr_t sSubCol = lpColName;

    if (pTop)
    {
        if (pTop->m_pLeft)
        {
            if (pTop->m_pLeft->m_pRight)
            {
                SWQLNode_TableRef *pRef = (SWQLNode_TableRef *)pTop->m_pLeft->m_pRight->m_pLeft;
                hr = m_pSchema->GetClassID(pRef->m_pTableName, m_dNamespace, dClassID);
                if (FAILED(hr))
                    hr = WBEM_E_INVALID_QUERY;
            }
            else
                hr = WBEM_E_INVALID_QUERY;
            if (pTop->m_pLeft->m_pLeft)
            {
                SWQLNode_ColumnList *pList = (SWQLNode_ColumnList *)pTop->m_pLeft->m_pLeft;
                SWQLColRef *pCol = (SWQLColRef *)pList->m_aColumnRefs[0];
                if (pCol)
                {
                    _bstr_t sName = pCol->m_pColName;
                    if (pCol->m_dwFlags & WQL_FLAG_COMPLEX_NAME)
                    {
                        SWQLQualifiedName *pQN = pCol->m_pQName;
                        if (pQN)
                        {
                            hr = FormatPositionQuery((SWQLQualifiedNameField *)pQN->m_aFields[0], pCol->m_dwArrayIndex, lpUseAlias, sExtra);
                        }
                    }
                    
                    hr = GetPropertyID(dClassID, pCol->m_pQName, pCol->m_pColName, dwPropID, dwStorage, dwFlags);
                    if (SUCCEEDED(hr))
                    {
                        GetStorageTable(dwStorage, dwFlags, sSrc);
                        
                        // If we are comparing different types,
                        // or using a system property, get the new col name

                        FunctionalizeProperty (lpUseAlias, dwStorage, NULL, NULL, pCol->m_pColName, sSubCol);                    
                    }

                }
            }
        }
        else
            hr = WBEM_E_INVALID_QUERY;
    }
    else
        hr = WBEM_E_INVALID_QUERY;

    if (SUCCEEDED(hr))
    {
        wchar_t wTemp[256];
        wchar_t wWhere[512];
        _bstr_t sTemp, sTempSQL;

        // Construct the *simple* where clause....
        // If there is any where element at all, we need to ditch the
        // simple approach and revert to the subselect set...
        // ==========================================================

        swprintf(wTemp, L"select %s from %s as %s",
                (const wchar_t *)sSubCol,
                (const wchar_t *)sSrc, lpUseAlias);

        sTemp = wTemp;

        if (dwStorage == WMIDB_STORAGE_COMPACT)
             swprintf(wWhere, L" where %s.ClassId = %I64d", lpUseAlias, dClassID);
        else
             swprintf(wWhere, L" where PropertyId = %ld%s", dwPropID, (const wchar_t *)sExtra);

        if (pTop->m_pRight)
        {            
            bool bSysPropsUsed = false;
            
            hr = FormatWhereClause((SWQLNode_RelExpr *)pTop->m_pRight->m_pLeft, sTempSQL, lpUseAlias, bSysPropsUsed);
            if (SUCCEEDED(hr) && sTempSQL.length() > 0)
            {
                if (bSysPropsUsed && !(dwStorage == WMIDB_STORAGE_COMPACT))
                {
                    wchar_t NewSQL[1024];
                    swprintf(NewSQL, L" inner join vSystemProperties as %sv on %sv.ObjectId = %s.ObjectId and %sv.ClassId = %I64d",
                        lpUseAlias, lpUseAlias, lpUseAlias, lpUseAlias, dClassID);
                    sTemp += NewSQL;
                }
                sTemp += wWhere;
                sTemp += L" AND ";
                sTemp += sTempSQL;
            }
            else
                sTemp += wWhere;
        }

        sSQL = sTemp;
    }
    

    return hr;
}

//***************************************************************************
//
//  CSQLBuilder::FormatPositionQuery
//
//***************************************************************************

HRESULT CSQLBuilder::FormatPositionQuery (SWQLQualifiedNameField *pQNF, int iPos, LPCWSTR lpAlias, _bstr_t &sQuery)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    wchar_t wTemp[128];
    int iTemp;

    if (pQNF)
    {
        if (pQNF->m_bArrayRef)
        {
            iTemp = (int)pQNF->m_dwArrayIndex;
        }
    }
    else
        iTemp = iPos;

    swprintf(wTemp, L"and %s.ArrayPos = %ld", lpAlias, iTemp);

    sQuery = wTemp;

    return hr;

}


//***************************************************************************
//
//  CSQLBuilder::GetClassFromNode
//
//***************************************************************************

HRESULT CSQLBuilder::GetClassFromNode (SWQLNode *pNode, BOOL *bDefaultStorage)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR lpTableName = NULL;

    switch(pNode->m_dwNodeType)
    {
    case TYPE_SWQLNode_TableRefs:

        if (((SWQLNode_TableRefs *)pNode)->m_nSelectType == WQL_FLAG_COUNT)
            return WBEM_E_PROVIDER_NOT_CAPABLE;
        
        if (pNode->m_pRight != NULL)
        {
            if (pNode->m_pRight->m_pLeft->m_dwNodeType != TYPE_SWQLNode_TableRef)
                hr = WBEM_E_PROVIDER_NOT_CAPABLE;
            else
            {
                SWQLNode_TableRef *pRef = (SWQLNode_TableRef *)pNode->m_pRight->m_pLeft;
                lpTableName = pRef->m_pTableName;
            }
        }
        else
            return WBEM_E_INVALID_SYNTAX;

        break;
    case TYPE_SWQLNode_TableRef:
        
        if (pNode->m_dwNodeType != TYPE_SWQLNode_TableRef)
            hr = WBEM_E_INVALID_SYNTAX;
        else
            lpTableName = ((SWQLNode_TableRef *)pNode)->m_pTableName;
        
        break;
    default:
        return WBEM_E_NOT_SUPPORTED;
        break;
    }
        
    // Query = "select * from __Instances" : fudge it so they get all classes in this namespace.

    hr = m_pSchema->GetClassID(lpTableName, m_dNamespace, m_dClassID);
    if (FAILED(hr))
        hr = WBEM_E_INVALID_QUERY;

    // System classes are always default.
    if (bDefaultStorage)
    {
        if (lpTableName[0] == L'_')
            *bDefaultStorage = TRUE;
        else
            *bDefaultStorage = FALSE;
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\wqltosql.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   wqltosql.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _WQLTOSQL_H_
#define _WQLTOSQL_H_

typedef __int64 SQL_ID;

struct C_wchar_LessCase
{
	bool operator()(const wchar_t * _X, const wchar_t * _Y) const
    {
        return (_wcsicmp( _X,_Y ) < 0); 
    }
};

class CWmiDbHandle;
class CSchemaCache;

// WQL - SQL converter

class CSQLBuilder
{
public:
    // Generic SQL
    HRESULT FormatSQL        (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                IWbemQuery *pQuery, _bstr_t &sSQL, DWORD dwFlags,
                                DWORD dwHandleType, SQL_ID *dClassId=0,
                                BOOL *bHierarchyQuery=0, BOOL bTmpTblOK=TRUE, BOOL *bDelete=NULL,
                                BOOL *bDefault=NULL);
    HRESULT FormatSQL        (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                SQL_ID dTargetObjID, LPWSTR pResultClass,
                                LPWSTR pAssocClass, LPWSTR pRole, LPWSTR pResultRole, LPWSTR pRequiredQualifier,
                                LPWSTR pRequiredAssocQualifier, DWORD dwQueryType, _bstr_t &sSQL, DWORD dwFlags,
                                DWORD dwHandleType, SQL_ID *dAssocClass=0, SQL_ID *dResultClass=0, BOOL bIsClass=FALSE);

    

    CSQLBuilder(CSchemaCache *pSchema) {m_pSchema = pSchema;};
    ~CSQLBuilder(){};
private:
    HRESULT FormatWhereClause (SWQLNode_RelExpr *pNode, _bstr_t &sSQL, LPCWSTR lpJoinAlias, bool &bSysPropsUsed);
    HRESULT GetStorageTable(DWORD dwStorage, DWORD dwKey, _bstr_t &sTable);
    HRESULT GetPropertyID (SQL_ID dClassID, SWQLQualifiedName *pQN, LPCWSTR pColRef, DWORD &PropID, DWORD &Storage, DWORD &Flags);
    HRESULT FunctionalizeProperty (LPCWSTR lpAlias, DWORD dwType, LPWSTR lpFuncName, SWQLNode *pFunction, LPWSTR lpColName, _bstr_t &sProp);
    HRESULT FunctionalizeValue(SWQLTypedConst *pValue, DWORD dwType, LPWSTR lpFuncName, _bstr_t &sValue);
    HRESULT FormatSimpleSelect (LPCWSTR lpUseAlias, LPCWSTR lpColName,SWQLNode *pTop, _bstr_t &sSQL);
    HRESULT FormatPositionQuery (SWQLQualifiedNameField *pQNF, int iPos, LPCWSTR lpAlias, _bstr_t &sQuery);
    HRESULT GetClassFromNode (SWQLNode *pNode, BOOL *bDefaultStorage=NULL);

    SQL_ID m_dClassID;
    DWORD  m_dwTableCount;
    bool   m_bClassSpecified;
    SQL_ID m_dNamespace;
    CSchemaCache *m_pSchema;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\testcust.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



// *****************************************************
//
//  testcust.cpp
//
// *****************************************************
#include "precomp.h"
#include <comutil.h>
#include <reposit.h>
#include <time.h>
#include <stdio.h>
#include <wbemcli.h>
#include <testmods.h>

// Functionality to test on each class:
// ==> create mapping
// ==> create class
// * queries
// * insert, update, delete
// * update, delete classes
// =====================================

HRESULT SetBoolQfr(IWbemClassObject *pObj, LPWSTR lpQfrName)
{
    HRESULT hr = 0;
    IWbemQualifierSet *pQS = NULL;
    pObj->GetQualifierSet(&pQS);
    if (pQS)
    {
        VARIANT vTemp;
        VariantInit(&vTemp);
        vTemp.vt = VT_BOOL;
        vTemp.boolVal = true;
        hr = pQS->Put(lpQfrName, &vTemp, 3);
        VariantClear(&vTemp);
        pQS->Release();
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

HRESULT PutArrayProp (IWbemClassObject *pObj, LPWSTR lpPropName, LPWSTR lpValue1, LPWSTR lpValue2 = NULL, LPWSTR lpValue3 = NULL)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vTemp;
    VariantInit(&vTemp);

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    BSTR sValue = NULL;

    SAFEARRAYBOUND aBounds[1];

    aBounds[0].lLbound = 0;
    aBounds[0].cElements = 1;
    if (lpValue2)
        aBounds[0].cElements++;
    if (lpValue3)
        aBounds[0].cElements++;

    pArray = SafeArrayCreate(VT_BSTR, 1, aBounds);

    why[0] = 0;
    sValue = SysAllocString(lpValue1);
    SafeArrayPutElement(pArray, why, sValue);

    if (lpValue2)
    {
        why[0] = 1;
        sValue = SysAllocString(lpValue2);
        SafeArrayPutElement(pArray, why, sValue);

        if (lpValue3)
        {
            why[0] = 2;
            sValue = SysAllocString(lpValue3);
            SafeArrayPutElement(pArray, why, sValue);
        }
    }

    V_ARRAY(&vTemp) = pArray;
    vTemp.vt = VT_ARRAY|VT_BSTR;

    hr = pObj->Put(lpPropName, 0, &vTemp, CIM_STRING+CIM_FLAG_ARRAY);

    VariantClear(&vTemp);

    return hr;
}

HRESULT MapProducts(IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

    /*** keyhole
    create table Products
    (
        ProductId int NOT NULL IDENTITY(1,1),
        ProductName nvarchar(50) NULL,
        Category smallint NULL,
        MSRP smallmoney NULL,
        SerialNum nvarchar(50),
        constraint Products_PK primary key clustered (ProductId),
        constraint Products_AK unique (SerialNum)
    )

    class Products
    {
        [key, keyhole] uint32 ProductId;
        string ProductName;
        uint16 Category;
        string MSRP;
        string SerialNum;
    };
    */

    SetStringProp(pMap, L"sClassName", L"Products", TRUE);
    SetStringProp(pMap, L"sTableName", L"Products");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"ProductId");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 5;
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"ProductId");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN);
    SetIntProp   (pProp, L"bReadOnly", TRUE, FALSE, CIM_BOOLEAN);
    PutArrayProp (pProp, L"arrColumnNames", L"ProductId");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"ProductName");
    PutArrayProp (pProp, L"arrColumnNames", L"ProductName");
    why[0] = 1;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Category");
    PutArrayProp (pProp, L"arrColumnNames", L"Category");
    why[0] = 2;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"MSRP");
    SetIntProp   (pProp, L"bStoreAsNumber", TRUE, FALSE, CIM_BOOLEAN);
    PutArrayProp (pProp, L"arrColumnNames", L"MSRP");
    why[0] = 3;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"SerialNum");
    PutArrayProp (pProp, L"arrColumnNames", L"SerialNum");
    why[0] = 4;
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"Products");
    SetIntProp   (pClass, L"ProductId", 0, TRUE, CIM_UINT32);
    IWbemQualifierSet *pQS = NULL;
    pClass->GetPropertyQualifierSet(L"ProductId", &pQS);
    if (pQS)
    {
        VARIANT vTemp;
        VariantInit(&vTemp);
        vTemp.boolVal = true;
        vTemp.vt = VT_BOOL;
        hr = pQS->Put(L"keyhole", &vTemp, 3);
        VariantClear(&vTemp);
        pQS->Release();
    }

    SetStringProp(pClass, L"ProductName", L"");
    SetIntProp   (pClass, L"Category", 0, FALSE, CIM_UINT16);
    SetStringProp(pClass, L"MSRP", L"");
    SetStringProp(pClass, L"SerialNum", L"");

    return hr;
}


HRESULT MapCustomers(IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

    /*** basic information plus a blob array
    create table Customer
    (
        CustomerId int NOT NULL,
        CustomerName nvarchar(75) NULL,
        Address1 nvarchar(100) NULL,
        Address2 nvarchar(100) NULL,
        City nvarchar(50) NULL,
        State nvarchar(2) NULL,
        Zip nvarchar(10) NULL,
        Country nvarchar(50) NULL,
        Phone varchar(25) NULL,
        Fax varchar(25) NULL,
        Email varchar(25) NULL,
        ContactName nvarchar(75) NULL,
        PreferredCustomer bit NOT NULL DEFAULT 0,
        constraint Customer_PK primary key clustered (CustomerId)
    )
    create table Customer_Logo
    (
        CustomerId int NOT NULL,
        Logo image NULL,
        constraint Customer_Logos_PK primary key clustered (CustomerId),
    )

    class Customer
    {
        [key] uint32 CustomerId int;
        [indexed] string CustomerName;
        string Address1;
        string Address2;
        string City;
        string State;
        string Zip;
        string Country;
        string Phone;
        string Fax;
        string Email;
        string ContactName;
        boolean PreferredCustomer;
        uint8 Logo[];
    };
    */

    SetStringProp(pMap, L"sClassName", L"Customer", TRUE);
    SetStringProp(pMap, L"sTableName", L"Customer");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 14;
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"CustomerId");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN);
    PutArrayProp (pProp, L"arrColumnNames", L"CustomerId");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"CustomerName");
    PutArrayProp (pProp, L"arrColumnNames", L"CustomerName");
    why[0] = 1;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Address1");
    PutArrayProp (pProp, L"arrColumnNames", L"Address1");
    why[0] = 2;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Address2");
    PutArrayProp (pProp, L"arrColumnNames", L"Address2");
    why[0] = 3;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"City");
    PutArrayProp (pProp, L"arrColumnNames", L"City");
    why[0] = 4;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"State");
    PutArrayProp (pProp, L"arrColumnNames", L"State");
    why[0] = 5;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Zip");
    PutArrayProp (pProp, L"arrColumnNames", L"Zip");
    why[0] = 6;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Country");
    PutArrayProp (pProp, L"arrColumnNames", L"Country");
    why[0] = 7;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Phone");
    PutArrayProp (pProp, L"arrColumnNames", L"Phone");
    why[0] = 8;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Fax");
    PutArrayProp (pProp, L"arrColumnNames", L"Fax");
    why[0] = 9;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Email");
    PutArrayProp (pProp, L"arrColumnNames", L"Email");
    why[0] = 10;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"ContactName");
    PutArrayProp (pProp, L"arrColumnNames", L"ContactName");
    why[0] = 11;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"PreferredCustomer");
    PutArrayProp (pProp, L"arrColumnNames", L"PreferredCustomer");
    why[0] = 12;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Logo");
    PutArrayProp (pProp, L"arrColumnNames", L"Logo");
    PutArrayProp (pProp, L"arrForeignKeys", L"CustomerId");
    SetStringProp (pProp, L"sTableName",   L"Customer_Logo");
    SetIntProp   (pProp, L"bStoreAsBlob", TRUE, FALSE, CIM_BOOLEAN);
    why[0] = 13;
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"Customer");
    SetIntProp   (pClass, L"CustomerId", 0, TRUE, CIM_UINT32);
    SetStringProp(pClass, L"CustomerName", L"");
    SetStringProp(pClass, L"Address1", 0);
    SetStringProp(pClass, L"Address2", L"");
    SetStringProp(pClass, L"City", L"");
    SetStringProp(pClass, L"State", L"");
    SetStringProp(pClass, L"Zip", L"");
    SetStringProp(pClass, L"Country", L"");
    SetStringProp(pClass, L"Phone", L"");
    SetStringProp(pClass, L"Fax", L"");
    SetStringProp(pClass, L"Email", L"");
    SetStringProp(pClass, L"ContactName", L"");
    SetIntProp   (pClass, L"PreferredCustomer", 0, FALSE, CIM_BOOLEAN);

    hr = pClass->Put(L"Logo", 0, NULL, CIM_UINT8+CIM_FLAG_ARRAY);

    return hr;

}



HRESULT MapOrders(IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

    /*** Association
    create table Orders
    (
        OrderId int NOT NULL,
        ProductId int NOT NULL,
        CustomerId int NOT NULL,
        OrderDate smalldatetime NULL,
        SalesPrice money NULL,
        Quantity int NULL,
        Commission numeric(15,3) NULL,
        OrderStatus tinyint NULL DEFAULT 0,
        ShipDate datetime NULL,
        SalesId int NULL,
        OrderFax varbinary(4096) NULL,
        constraint Order_PK primary key nonclustered (ProductId, CustomerId, OrderId)
    )
    [association]
    class Orders
    {
        [key] Products ref Product;
        [key] Customer ref Customer;
        [key] uint32 OrderId;
        datetime OrderDate;
        string SalesPrice;
        uint32 Quantity;
        string Commission;
        uint8 OrderStatus;
        datetime ShipDate;
        uint32 SalesId;
        uint8 OrderFax[];
    };

    */

    SetStringProp(pMap, L"sClassName", L"Orders", TRUE);
    SetStringProp(pMap, L"sTableName", L"Orders");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 11; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    // This is an association
    // Two of the keys are references, a fact ignored in the mapping.

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Product");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"ProductId");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Customer");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"CustomerId");
    why[0] = 1;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"OrderId");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"OrderId");
    why[0] = 2;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"SalesPrice");
    SetIntProp   (pProp, L"bStoreAsNumber", TRUE, FALSE, CIM_BOOLEAN);
    PutArrayProp (pProp, L"arrColumnNames", L"SalesPrice");
    why[0] = 3;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Quantity");
    PutArrayProp (pProp, L"arrColumnNames", L"Quantity");
    why[0] = 4;
    SafeArrayPutElement(pArray, why, pProp);
    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Commission");
    SetIntProp   (pProp, L"bStoreAsNumber", TRUE, FALSE, CIM_BOOLEAN);
    PutArrayProp (pProp, L"arrColumnNames", L"Commission");
    why[0] = 5;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"OrderStatus");
    PutArrayProp (pProp, L"arrColumnNames", L"OrderStatus");
    why[0] = 6;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"ShipDate");
    PutArrayProp (pProp, L"arrColumnNames", L"ShipDate");
    why[0] = 7;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"SalesId");
    PutArrayProp (pProp, L"arrColumnNames", L"SalesId");
    why[0] = 8;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"OrderDate");
    PutArrayProp (pProp, L"arrColumnNames", L"OrderDate");
    why[0] = 9;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"OrderFax");
    PutArrayProp (pProp, L"arrColumnNames", L"OrderFax");
    why[0] = 10;
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"Orders"); 
    SetStringProp(pClass, L"Product", L"", TRUE, CIM_REFERENCE);
    SetStringProp(pClass, L"Customer", L"", TRUE, CIM_REFERENCE);
    SetIntProp   (pClass, L"OrderId", 0, TRUE);
    SetStringProp(pClass, L"OrderDate", L"", FALSE, CIM_DATETIME);
    SetStringProp(pClass, L"SalesPrice", L"");
    SetIntProp   (pClass, L"Quantity", 0);
    SetStringProp(pClass, L"Commission", L"");
    SetIntProp   (pClass, L"OrderStatus", 0, FALSE, CIM_UINT8);
    SetStringProp(pClass, L"ShipDate", L"", FALSE, CIM_DATETIME);
    SetIntProp   (pClass, L"SalesId", 0);
    SetIntProp   (pClass, L"OrderFax", NULL, FALSE, CIM_UINT8+CIM_FLAG_ARRAY);
    SetBoolQfr(pClass, L"association");

    IWbemQualifierSet *pQS = NULL;
    vValue.vt = VT_BSTR;
    vValue.bstrVal = SysAllocString(L"ref:Product");
    pClass->GetPropertyQualifierSet(L"Product", &pQS);
    pQS->Put(L"cimtype", &vValue, 3);
    pQS->Release();
    VariantClear(&vValue);

    vValue.vt = VT_BSTR;
    vValue.bstrVal = SysAllocString(L"ref:Customer");
    pClass->GetPropertyQualifierSet(L"Customer", &pQS);
    pQS->Put(L"cimtype", &vValue, 3);
    pQS->Release();
    VariantClear(&vValue);


    return hr;

}


HRESULT MapConfiguration(IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

    /*** singleton, with array
    [singleton]
    create table Configuration
    (
        LastUpdate datetime NULL,
        ServerName nvarchar(1024),
        Contexts1 nvarchar(50),
        Contexts2 nvarchar(50),
        Contexts3 nvarchar(50)
    )

    [singleton]
    class Configuration
    {
        datetime LastUpdate;
        string ServerName;
        string Contexts[];
    };

    */

    SetStringProp(pMap, L"sClassName", L"Configuration", TRUE);
    SetStringProp(pMap, L"sTableName", L"Configuration");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 5; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"LastUpdate");
    PutArrayProp (pProp, L"arrColumnNames", L"LastUpdate");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"ServerName");
    PutArrayProp (pProp, L"arrColumnNames", L"ServerName");
    why[0] = 1;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Contexts[0]");
    PutArrayProp (pProp, L"arrColumnNames", L"Contexts1");
    why[0] = 2;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Contexts[1]");
    PutArrayProp (pProp, L"arrColumnNames", L"Contexts2");
    why[0] = 3;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Contexts[2]");
    PutArrayProp (pProp, L"arrColumnNames", L"Contexts3");
    why[0] = 4;
    SafeArrayPutElement(pArray, why, pProp);


    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"Configuration"); 
    SetBoolQfr(pClass, L"singleton");
    SetStringProp(pClass, L"LastUpdate", L"", FALSE, CIM_DATETIME);
    SetStringProp(pClass, L"ServerName", L"");
    hr = pClass->Put(L"Contexts", NULL, NULL,  CIM_STRING+CIM_FLAG_ARRAY);
   
    return hr;

}


HRESULT MapEmbeddedEvents(IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;


    /*** blob object array
    create table EmbeddedEvents
    (
        EventID int NOT NULL,
        CaptureDate datetime NULL,
        EventData image NULL
    )

    class EmbeddedEvents
    {
        [key] sint32 EventID;
        datetime CaptureDate;
        object EventData[];
    };
    */

    SetStringProp(pMap, L"sClassName", L"EmbeddedEvents", TRUE);
    SetStringProp(pMap, L"sTableName", L"EmbeddedEvents");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 3; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"EventID");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"EventID");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"CaptureDate");
    PutArrayProp (pProp, L"arrColumnNames", L"CaptureDate");
    why[0] = 1;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"EventData");
    PutArrayProp (pProp, L"arrColumnNames", L"EventData");
    SetIntProp   (pProp, L"bStoreAsBlob", TRUE, FALSE, CIM_BOOLEAN);
    why[0] = 2;
    SafeArrayPutElement(pArray, why, pProp);


    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"EmbeddedEvents");
    SetIntProp   (pClass, L"EventID", 0, TRUE);
    SetStringProp(pClass, L"CaptureDate", L"", FALSE, CIM_DATETIME);
    
    hr = pClass->Put(L"EventData", 0, NULL, CIM_OBJECT);

    return hr;

}

HRESULT MapGenericEvent (IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;

    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

     /*** string keyhole (uniqueidentifier)
     create table GenericEvent
     (
         EventID uniqueidentifier NOT NULL,
         EventDescription nvarchar(1024) NULL,
         GenericEventID int NULL,
         constraint GenericEvent_PK primary key clustered (EventID)
     )

      class GenericEvent
       (
          [keyhole, key]
          string sID;
          string sDescription;
          EmbeddedEvents oEvent;
       };
    ***/

    SetStringProp(pMap, L"sClassName", L"GenericEvent", TRUE);
    SetStringProp(pMap, L"sTableName", L"GenericEvent");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"EventID");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 3; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"sID");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"EventID");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"sDescription");
    PutArrayProp (pProp, L"arrColumnNames", L"EventDescription");
    why[0] = 1;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"oEvent.EventID");
    PutArrayProp (pProp, L"arrColumnNames", L"GenericEventID");
    why[0] = 2;
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"GenericEvent"); 
    SetStringProp(pClass, L"sDescription", L"");
    SetStringProp(pClass, L"sID", L"", TRUE);
    hr = pClass->Put(L"oEvent", NULL, NULL,  CIM_OBJECT);

    IWbemQualifierSet *pQS = NULL;
    pClass->GetPropertyQualifierSet(L"oEvent", &pQS);
    if (pQS)
    {
        vValue.vt = VT_BSTR;
        vValue.bstrVal = SysAllocString(L"object:EmbeddedEvents");
        hr = pQS->Put(L"cimtype", &vValue, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
        pQS->Release();
        VariantClear(&vValue);
    }

    pClass->GetPropertyQualifierSet(L"sID", &pQS);
    if (pQS)
    {
        vValue.boolVal = true;
        vValue.vt = VT_BOOL;
        hr = pQS->Put(L"keyhole", &vValue, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
        pQS->Release();
        VariantClear(&vValue);
    }    

    return hr;

}

HRESULT MapComputerSystem(IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

    /*** keyhole, invisible key
    create table ComputerSystem
    (
        SystemId int NOT NULL IDENTITY(1,1),
        SystemName nvarchar(450) NULL,
        constraint ComputerSystem_PK primary key clustered (SystemId)
    )

    class ComputerSystem
    {
        [key] string SystemName;
    };

    */
    SetStringProp(pMap, L"sClassName", L"ComputerSystem", TRUE);
    SetStringProp(pMap, L"sTableName", L"ComputerSystem");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"SystemId");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 1; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"SystemName");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"SystemName");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"ComputerSystem"); 
    SetStringProp(pClass, L"SystemName", L"", TRUE);

    return hr;

}


HRESULT MapCIMLogicalDevice (IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;

    /*** abstract parent 
    create table CIMLogicalDevice
    (
        DeviceID varchar(5)    
    )

    [abstract]
    class CIMLogicalDevice
    {
        [key] string DeviceID;
    };

    */

    SetStringProp(pMap, L"sClassName", L"CIMLogicalDevice", TRUE);
    SetStringProp(pMap, L"sTableName", L"CIMLogicalDevice");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"");
    SetStringProp(pMap, L"sScopeClass", L"");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 1; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"DeviceID");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN); 
    PutArrayProp (pProp, L"arrColumnNames", L"DeviceID");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"CIMLogicalDevice"); 
    SetBoolQfr   (pClass, L"abstract");
    SetStringProp(pClass, L"DeviceID", L"", TRUE);

    return hr;

}


HRESULT MapLogicalDisk (IWbemClassObject *pMappingProp, IWbemClassObject **ppMap, IWbemClassObject **ppClass)
{
    HRESULT hr = 0;
    
    IWbemClassObject *pMap = *ppMap;
    IWbemClassObject *pClass = *ppClass;


    /*** derived, scoped class
    create table LogicalDisk
    (
        DeviceID varchar(5) NOT NULL,
        FileSystem varchar(20) NULL,
        Size int NULL,
        VolumeSerialNumber varchar(128) NULL,
        FreeSpace int NULL,
        constraint LogicalDisk_PK primary key clustered (DeviceID)
    )

    class LogicalDisk : CIMLogicalDevice
    {
        [key] string DeviceID;
        string FileSystem;
        uint32 Size;
        string VolumeSerialNumber;
        uint32 FreeSpace;
    };

    */
    SetStringProp(pMap, L"sClassName", L"LogicalDisk", TRUE);
    SetStringProp(pMap, L"sTableName", L"LogicalDisk");
    SetStringProp(pMap, L"sDatabaseName", L"WMICust");
    SetStringProp(pMap, L"sPrimaryKeyCol", L"");
    SetStringProp(pMap, L"sScopeClass", L"ComputerSystem");

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    IWbemClassObject *pProp = NULL;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].cElements = 5; 
    aBounds[0].lLbound = 0;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"DeviceID");
    SetIntProp   (pProp, L"bIsKey", TRUE, FALSE, CIM_BOOLEAN);
    PutArrayProp (pProp, L"arrColumnNames", L"DeviceID");
    why[0] = 0;                
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"FileSystem");
    PutArrayProp (pProp, L"arrColumnNames", L"FileSystem");
    why[0] = 1;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"Size");
    PutArrayProp (pProp, L"arrColumnNames", L"Size");
    why[0] = 2;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"VolumeSerialNumber");
    PutArrayProp (pProp, L"arrColumnNames", L"VolumeSerialNumber");
    why[0] = 3;
    SafeArrayPutElement(pArray, why, pProp);

    pMappingProp->SpawnInstance(0, &pProp);
    SetStringProp(pProp, L"sPropertyName", L"FreeSpace");
    PutArrayProp (pProp, L"arrColumnNames", L"FreeSpace");
    why[0] = 4;
    SafeArrayPutElement(pArray, why, pProp);

    VARIANT vValue;
    VariantInit(&vValue);
    V_ARRAY(&vValue) = pArray;
    vValue.vt = VT_ARRAY|VT_UNKNOWN;
    hr = pMap->Put(L"arrProperties", NULL, &vValue, CIM_FLAG_ARRAY+CIM_OBJECT);
    VariantClear(&vValue);

    SetStringProp(pClass, L"__Class", L"LogicalDisk");
    SetStringProp(pClass, L"DeviceID", L"", TRUE);
    SetStringProp(pClass, L"FileSystem", L"");
    SetIntProp   (pClass, L"Size", 0);
    SetStringProp(pClass, L"VolumeSerialNumber", L"");
    SetIntProp   (pClass, L"FreeSpace", 0);

    return hr;

}

BOOL TestSuiteCustRepDrvr::StopOnFailure()
{
    return FALSE;
}

TestSuiteCustRepDrvr::TestSuiteCustRepDrvr(const wchar_t *pszFileName)
: TestSuite(pszFileName)
{

}

TestSuiteCustRepDrvr::~TestSuiteCustRepDrvr()
{

}

HRESULT TestSuiteCustRepDrvr::RunSuite(IWmiDbSession *pSess, IWmiDbController *pController, IWmiDbHandle *pRoot)
{

    RecordResult (0, L" *** Custom Repository Driver Suite running... *** \n", 0);

    wprintf(L" *** Custom Repository Driver Suite running... *** \n");

    HRESULT hr = WBEM_S_NO_ERROR;

    IWmiDbHandle *pMapping = NULL;
    IWmiDbHandle *pMappingPropHandle = NULL;
    IWmiDbHandle *pTempNs = NULL;
    IWbemClassObject *pClass = NULL;

    IWbemPath *pPth = NULL;
    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
        IID_IWbemPath, (void **)&pPth); 

    // First, create an instance of __SqlMappedNamespace
    // and set it as the root handle.

    pPth->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"__SqlMappedNamespace");
    hr = pSess->GetObject(pRoot, pPth, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pMapping);    
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        hr = pMapping->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
        IWbemClassObject *pInst = NULL;
        if (SUCCEEDED(hr))
        {
            pObj->SpawnInstance(0, &pInst);

            SetStringProp(pInst, L"Name", L"Test1");
            hr = pSess->PutObject(pRoot, IID_IWbemClassObject, pInst, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pTempNs);
            pInst->Release();
            pObj->Release();
        }
        pMapping->Release();
    }
   
    // Next, create mappings for each table in the database WMICust.

    if (SUCCEEDED(hr))
    {
        pPth->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"__CustRepDrvrMapping");
        hr = pSess->GetObject(pRoot, pPth, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pMapping);    
        if (SUCCEEDED(hr))
        {
            pPth->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"__CustRepDrvrMappingProperty");
            hr = pSess->GetObject(pRoot, pPth, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pMappingPropHandle);    
        }
        if (SUCCEEDED(hr))
        {
            IWbemClassObject *p1 = NULL;
            IWbemClassObject *pInst = NULL;
            IWmiDbHandle *pHandle = NULL;
            VARIANT vTemp;
            wchar_t wTemp[100];
            VariantInit(&vTemp);

            hr = pMapping->QueryInterface(IID_IWbemClassObject, (void **)&p1);
            if (SUCCEEDED(hr))
            {
                pMappedObj = p1;

                IWbemClassObject *p2= NULL;

                hr = pMappingPropHandle->QueryInterface(IID_IWbemClassObject, (void **)&p2);

                pSession = pSess;
                m_pController = pController;
                pMappedNs = pTempNs;
                pMappingProp = p2;
                pPath = pPth;

                RecordResult(hr = TestProducts(), L"Testing Products", 0);
                RecordResult(hr = TestCustomers(), L"Testing Customers", 0);
                RecordResult (hr = TestOrders(), L"Testing Orders", 0);
                RecordResult (hr = TestEmbeddedEvents(), L"Testing embedded events", 0);
                RecordResult (hr = TestConfiguration(), L"Testing Configuration", 0);
                RecordResult (hr = TestGenericEvents(), L"Testing generic events", 0);
                RecordResult (hr = TestComputerSystem(), L"Testing computer system", 0);
                RecordResult (hr = TestCIMLogicalDevice(), L"Testing CIM logical device", 0);
                RecordResult (hr = TestLogicalDisk(), L"Testing Logical disk", 0);
                
                pMappingProp->Release();
                pMappedObj->Release();
            }
            pMapping->Release();
            pMappingPropHandle->Release();
        }
        pTempNs->Release();

    }

    pPth->Release();

    return hr;
}


HRESULT TestSuiteCustRepDrvr::TestProducts()
{
    HRESULT hr = 0;
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;
    VARIANT vTemp;
    VariantInit(&vTemp);
    wchar_t wTemp[512];

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);
    if (SUCCEEDED(hr))
    {
        hr = MapProducts(pMappingProp, &pMap, &pClass);
        if (SUCCEEDED(hr))
        {
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
            if (SUCCEEDED(hr))
                hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);

        }
        pMap->Release();

        RecordResult(hr, L"Mapping Products class",0);

        // Exercise instances..

        hr = pClass->SpawnInstance(0, &pInst);
        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pHandle = NULL;
            SetIntProp   (pInst, L"ProductId", 2, TRUE, CIM_UINT32);
            SetStringProp(pInst, L"ProductName", L"Widgit");
            SetIntProp   (pInst, L"Category", 1, FALSE, CIM_UINT16);
            SetStringProp(pInst, L"MSRP", L"1.77");
            SetStringProp(pInst, L"SerialNum", L"WWW-999");

            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
            RecordResult(hr, L"Inserting instance of Products",0);
            pInst->Release();

            if (SUCCEEDED(hr))
            {
                hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
    
                pHandle->Release();
                pInst->Get(L"ProductId", 0, &vTemp, NULL, NULL);
                swprintf(wTemp, L"Products=%ld", vTemp.lVal);
                pInst->Release();

                pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wTemp);

                hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
                RecordResult(hr, L"Retrieving instance of Products",0);

                // Verify that all the data is correct.
                // If not, don't delete the object.

                if (pHandle)
                {
                    hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
                    if (SUCCEEDED(hr))
                    {
                        HRESULT hTemp = 0;

                        if (FAILED(ValidateProperty(pInst, L"ProductName", CIM_STRING, L"Widgit"))) 
                        {
                            RecordResult(E_FAIL, L"Verifying Products.ProductName='Widgit'", 0);
                            hTemp = E_FAIL;
                        }
                        if (FAILED(ValidateProperty(pInst, L"Category", CIM_UINT16, 1))) 
                        {
                            RecordResult(E_FAIL, L"Verifying Products.Category = 1 ", 0);
                            hTemp = E_FAIL;
                        }
                        if (FAILED(ValidateProperty(pInst, L"MSRP", CIM_STRING, L"1.77")))
                        {
                            RecordResult(E_FAIL, L"Verifying Products.MSRP = '1.77'.", 0);
                            hTemp = E_FAIL;
                        }
                        if (FAILED(ValidateProperty(pInst, L"SerialNum", CIM_STRING, L"WWW-999"))) 
                        {
                            RecordResult(E_FAIL, L"Verifying Products.SerialNum = 'WWW-999'", 0);
                            hTemp = E_FAIL;
                        }

                        if (SUCCEEDED(hTemp))
                        {
                            // Try out queries.

                            IWbemQuery *pQuery = NULL;
                            hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
                            if (SUCCEEDED(hr))
                            {
                                DWORD dwNumObjs = 0;
                                IWmiDbIterator *pIt = NULL;
                                pQuery->Parse(L"SQL", L"select ProductId, MSRP from Products", 0);
                                RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                                    WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select ProductId, MSRP from Products'", 0);
                                if (SUCCEEDED(hr))
                                {
                                    IWbemClassObject *pTemp = NULL;
                                    RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                                        &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Products)", 0);
                                    if (pTemp)
                                    {
                                        pTemp->Release();
                                        pTemp = NULL;
                                    }
                                    pIt->Release();
                                }
                                pQuery->Parse(L"SQL", L"select count(*) from Products", 0);
                                RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                                    WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select count(*) from Products'", 0);
                                if (SUCCEEDED(hr))
                                {
                                    IWbemClassObject *pTemp = NULL;
                                    RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                                        &dwNumObjs, (void **)&pTemp), L"NextBatch (select count(*) from Products)", 0);
                                    if (pTemp)
                                    {
                                        pTemp->Release();
                                        pTemp = NULL;
                                    }
                                    pIt->Release();
                                }
                                pQuery->Parse(L"SQL", L"select * from Products where Category = 1 and MSRP <> 100", 0);
                                RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                                    WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select * from Products where Category = 1"
                                    L" and MSRP <> 100", 0);
                                if (SUCCEEDED(hr))
                                {
                                    IWbemClassObject *pTemp = NULL;
                                    RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                                        &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Products where Category = 1 and MSRP <> \"100\")", 0);
                                    if (pTemp)
                                    {
                                        pTemp->Release();
                                        pTemp = NULL;
                                    }
                                    pIt->Release();
                                }
                                pQuery->Parse(L"SQL", L"select * from Products where upper(ProductName) = 'WIDGIT'", 0);
                                RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                                    WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"select * from Products where upper(ProductName) = 'WIDGIT'", 0);
                                if (SUCCEEDED(hr))
                                {
                                    IWbemClassObject *pTemp = NULL;
                                    RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                                        &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Products where upper(ProductName) = 'WIDGIT')", 0);
                                    if (pTemp)
                                    {
                                        pTemp->Release();
                                        pTemp = NULL;
                                    }
                                    pIt->Release();
                                }
                                pQuery->Release();
                            }
                            
                            hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
                            RecordResult(hr, L"Deleting instance of Products",0);
                        }
                        else
                            RecordResult(0, L"Product instance NOT DELETED", 0);
                        pInst->Release();                        
                    }                    
                    pHandle->Release();
                }
            }
        }
        if (pClass)
            pClass->Release();
    }
    VariantClear(&vTemp);
    return hr;

}

HRESULT TestSuiteCustRepDrvr::TestCustomers()
{
    HRESULT hr = 0;
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;
    VARIANT vTemp;
    VariantInit(&vTemp);
    wchar_t wTemp[512];

    // Customers 
    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapCustomers(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping Customers class",0);

    pMap->Release();

    // Exercise instances..

    pClass->SpawnInstance(0, &pInst);
    SetIntProp   (pInst, L"CustomerId", 2001, TRUE, CIM_UINT32);
    SetStringProp(pInst, L"CustomerName", L"Purina");
    SetStringProp(pInst, L"Address1", L"1 Catfood Way");
    SetStringProp(pInst, L"Address2", L"Suite 6");
    SetStringProp(pInst, L"City", L"Fido");
    SetStringProp(pInst, L"State", L"AL");
    SetStringProp(pInst, L"Zip", L"65882");
    SetStringProp(pInst, L"Country", L"USA");
    SetStringProp(pInst, L"Phone", L"(999) 999-9999");
    SetStringProp(pInst, L"Fax", L"(999) 999-9999");
    SetStringProp(pInst, L"Email", L"meow@woof.com");
    SetStringProp(pInst, L"ContactName", L"Morris");
    SetIntProp   (pInst, L"PreferredCustomer", 1, FALSE, CIM_BOOLEAN);

    // Set the array property with some garbage.

    SAFEARRAY *pArray = NULL;
    long why[1];                        
    unsigned char t1;
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].lLbound = 0;
    aBounds[0].cElements = 3;
    pArray = SafeArrayCreate(VT_UI1, 1, aBounds);
    why[0] = 0;
    t1 = 100;
    SafeArrayPutElement(pArray, why, &t1);
    why[0] = 1;
    t1 = 200;
    SafeArrayPutElement(pArray, why, &t1);
    why[0] = 2;
    t1 = 0;
    SafeArrayPutElement(pArray, why, &t1);
    V_ARRAY(&vTemp) = pArray;
    vTemp.vt = VT_ARRAY|VT_UI1;
    hr = pInst->Put(L"Logo", NULL, &vTemp, CIM_FLAG_ARRAY+CIM_UINT8);
    VariantClear(&vTemp);

    hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, 0, NULL);
    RecordResult(hr, L"Inserting instance of Customers ",0);
   
    pInst->Release();

    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Customer=2001");
    IWmiDbHandle *pHandle = NULL;

    hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Retrieving instance of Customers ",0);

    // Verify that all data is correct.
    // If not, don't delete

    if (SUCCEEDED(hr))
    {
        hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
        if (SUCCEEDED(hr))
        {
            HRESULT hTemp = 0;
            
            // Only verify non-string types (ones that may fail)

            if (FAILED(ValidateProperty(pInst, L"CustomerId", CIM_UINT32, 2001))) 
            {
                RecordResult(E_FAIL, L"Verifying Customer.CustomerId = 2001", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"CustomerName", CIM_STRING, L"Purina"))) 
            {
                RecordResult(E_FAIL, L"Verifying Customer.CustomerName='Purina'", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"PreferredCustomer", CIM_BOOLEAN, 1)))
            {
                RecordResult(E_FAIL, L"Verifying Customer.PreferredCustomer=TRUE", 0);
                hTemp = E_FAIL;
            }
            hr = pInst->Get(L"Logo", NULL, &vTemp, NULL, NULL);
            if (SUCCEEDED(hr) && (vTemp.vt == (VT_ARRAY|VT_UI1)))
            {
                BYTE temp1=0, temp2=0, temp3=0;
                pArray = V_ARRAY(&vTemp);
                if (pArray)
                {
                    long lTemp=0;
                    SafeArrayGetElement(pArray, &lTemp, &temp1);
                    lTemp = 1;
                    SafeArrayGetElement(pArray, &lTemp, &temp2);
                    lTemp = 2;
                    SafeArrayGetElement(pArray, &lTemp, &temp3);
                }
                if (temp1 != 100 || temp2 != 200 || temp3 != 0)
                {
                    RecordResult(E_FAIL, L"Verifying Customer.Logo",0);
                    hTemp = E_FAIL;
                }
            }

            if (SUCCEEDED(hTemp))
            {
                
                // Try out queries.
                IWbemQuery *pQuery = NULL;
                hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
                if (SUCCEEDED(hr))
                {
                    IWmiDbIterator *pIt = NULL;
                    DWORD dwNumObjs = 0;
                    pQuery->Parse(L"SQL", L"select * from Customer order by CustomerName", 0);
                    RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                        WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select * from Customer order by CustomerName'", 0);
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTemp = NULL;
                        RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                            &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Customer order by CustomerName)", 0);
                        if (pTemp)
                        {
                            pTemp->Release();
                            pTemp = NULL;
                        }
                        pIt->Release();
                    }
                    pQuery->Parse(L"SQL", L"select * from Customer where CustomerName > \"A\" ", 0);
                    RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                        WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select * from Customer where CustomerName is not null'", 0);
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTemp = NULL;
                        RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                                &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Customer where CustomerName is not null)", 0);
                        if (pTemp)
                        {
                            pTemp->Release();
                            pTemp = NULL;
                        }
                        pIt->Release();
                    }
                    pQuery->Release();
                }                

                hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
                RecordResult(hr, L"Deleting instance of Customers ",0);
            }
            else
                RecordResult(E_FAIL, L"Customer instance NOT DELETED", 0);
            pInst->Release();
        }
        pHandle->Release();
    }

    pClass->Release();
    VariantClear(&vTemp);

    return hr;
}
HRESULT TestSuiteCustRepDrvr::TestOrders()
{
    HRESULT hr = 0;
    // Orders
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL, *pInst = NULL;;

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapOrders(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping Orders class ",0);

    pMap->Release();

    // Exercise instances.

    pClass->SpawnInstance(0, &pInst);
    SetStringProp(pInst, L"Product", L"Product=1", TRUE, CIM_REFERENCE);
    SetStringProp(pInst, L"Customer", L"Customer=1004", TRUE, CIM_REFERENCE);
    SetIntProp   (pInst, L"OrderId", 1, TRUE);
    SetStringProp(pInst, L"OrderDate", L"19991201120000.000000+***", FALSE, CIM_DATETIME);
    SetStringProp(pInst, L"SalesPrice", L"48.99");
    SetIntProp   (pInst, L"Quantity", 100);
    SetStringProp(pInst, L"Commission", L".05");
    SetIntProp   (pInst, L"OrderStatus", 8, FALSE, CIM_UINT8);
    SetStringProp(pInst, L"ShipDate", L"20000101120000.000000+***", FALSE, CIM_DATETIME);
    SetIntProp   (pInst, L"SalesId", 69);
    SetIntProp   (pInst, L"OrderFax", NULL, FALSE, CIM_UINT8+CIM_FLAG_ARRAY);

    hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, 0, NULL);
    RecordResult(hr, L"Inserting instance of Orders ",0);

    pInst->Release();
    IWmiDbHandle *pHandle = NULL;

    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Orders.Product=\"Product=1\",Customer=\"Customer=1004\",OrderId=1");
    hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Retrieving instance of Orders ",0);

    // Verify that all data is correct.
    // If not, don't delete

    if (SUCCEEDED(hr))
    {
        hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
        if (SUCCEEDED(hr))
        {
            HRESULT hTemp = 0;
            
            // Only verify non-string types (ones that may fail)

            if (FAILED(ValidateProperty(pInst, L"Product", CIM_REFERENCE, L"Product=1"))) 
            {
                RecordResult(E_FAIL, L"Verifying Orders.Product= 'Product=1'", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"Customer", CIM_REFERENCE, L"Customer=1004"))) 
            {
                RecordResult(E_FAIL, L"Verifying Orders.Customer= 'Customer=1004'", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"OrderId", CIM_UINT32, 1)))
            {
                RecordResult(E_FAIL, L"Verifying Orders.OrderId = 1", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"OrderDate", CIM_DATETIME, L"19991201120000.000000+000")))
            {
                RecordResult(E_FAIL, L"Verifying Orders.OrderDate= '19991201120000.000000+***'", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"SalesPrice", CIM_STRING, L"48.99")))
            {
                RecordResult(E_FAIL, L"Verifying Orders.SalesPrice= 48.99", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"Commission", CIM_STRING, L".050")))
            {
                RecordResult(E_FAIL, L"Verifying Orders.Commission = 0.05", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"OrderStatus", CIM_UINT8, 8)))
            {
                RecordResult(E_FAIL, L"Verifying Orders.OrderStatus = 8", 0);
                hTemp = E_FAIL;
            }
            if (FAILED(ValidateProperty(pInst, L"ShipDate", CIM_DATETIME, L"20000101120000.000000+000")))
            {
                RecordResult(E_FAIL, L"Verifying Orders.ShipDate = '20000101120000.000000+***'", 0);
                hTemp = E_FAIL;
            }

            if (SUCCEEDED(hTemp))
            {                
                // Try out queries.
                IWbemQuery *pQuery = NULL;
                hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
                if (SUCCEEDED(hr))
                {
                    IWmiDbIterator *pIt = NULL;
                    DWORD dwNumObjs = 0;
                    pQuery->Parse(L"SQL", L"select * from Orders where datepart(yy, OrderDate) = 1999", 0);
                    RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                        WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select * from Orders where datepart(yy, OrderDate) = 1999'", 0);
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTemp = NULL;
                        RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                            &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Orders where datepart(yy, OrderDate) = 1999)", 0);
                        if (pTemp)
                        {
                            pTemp->Release();
                            pTemp = NULL;
                        }
                        pIt->Release();
                    }
                    pQuery->Parse(L"SQL", L"select * from Orders where ShipDate > OrderDate", 0);
                    RecordResult(hr = pSession->ExecQuery(pMappedNs, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                        WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt), L"Executing query 'select * from Orders where ShipDate > OrderDate'", 0);
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pTemp = NULL;
                        RecordResult(hr = pIt->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_VERSIONED, IID_IWbemClassObject, 
                                &dwNumObjs, (void **)&pTemp), L"NextBatch (select * from Orders where ShipDate > OrderDate)", 0);
                        if (pTemp)
                        {
                            pTemp->Release();
                            pTemp = NULL;
                        }
                        pIt->Release();
                    }
                    pQuery->Release();
                }
                
                hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
                RecordResult(hr, L"Deleting instance of Orders ",0);
            }
            else
                RecordResult(E_FAIL, L"Orders instance NOT DELETED", 0);
            pInst->Release();
        }
        pHandle->Release();
    }
    pClass->Release();

    return hr;
}
HRESULT TestSuiteCustRepDrvr::TestConfiguration()
{
    HRESULT hr = 0;
    // Configuration

    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;
    VARIANT vTemp;
    VariantInit(&vTemp);
    wchar_t wTemp[512];

    hr = pMappedObj->SpawnInstance(0, &pMap);                       
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemClassObject, (void **)&pClass);

        hr = MapConfiguration(pMappingProp, &pMap, &pClass);
        if (SUCCEEDED(hr))
        {
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
            if (SUCCEEDED(hr))
                hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
        }
        RecordResult(hr, L"Mapping Configuration class ",0);

        pMap->Release();   

        // Exercise instances.

        pClass->SpawnInstance(0, &pInst);

        SetStringProp(pInst, L"LastUpdate", L"20001231010000.000000+***", FALSE, CIM_DATETIME);
        SetStringProp(pInst, L"ServerName", L"AKIAPOLAAU");
        hr = PutArrayProp(pInst, L"Contexts", L"Context1", L"Context2", L"Context3");

        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, 0, NULL);
        RecordResult(hr, L"Inserting instance of Configuration ",0);

        pInst->Release();

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Configuration=@");
        IWmiDbHandle *pHandle = NULL;

        hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
        RecordResult(hr, L"Retrieving instance of Configuration ",0);

        // Verify that all data is correct.
        // If not, don't delete

        if (SUCCEEDED(hr))
        {
            hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
            if (SUCCEEDED(hr))
            {
                HRESULT hTemp = 0;
            
                // Only verify non-string types (ones that may fail)

                if (FAILED(ValidateProperty(pInst, L"LastUpdate", CIM_DATETIME, L"20001231010000.000000+000"))) 
                {
                    RecordResult(E_FAIL, L"Verifying Configuration.LastUpdate ", 0);
                    hTemp = E_FAIL;
                }
                if (FAILED(ValidateProperty(pInst, L"ServerName", CIM_STRING, L"AKIAPOLAAU"))) 
                {
                    RecordResult(E_FAIL, L"Verifying Configuration.ServerName ", 0);
                    hTemp = E_FAIL;
                }

                hr = pInst->Get(L"Contexts", NULL, &vTemp, NULL, NULL);
                if (SUCCEEDED(hr) && (vTemp.vt == (VT_ARRAY|VT_BSTR)))
                {
                    SAFEARRAY *pArray = NULL;
                    BYTE temp1=0, temp2=0, temp3=0;
                    pArray = V_ARRAY(&vTemp);
                    BSTR sTemp1, sTemp2, sTemp3;
                    if (pArray)
                    {
                        long lTemp=0;
                        SafeArrayGetElement(pArray, &lTemp, &sTemp1);
                        lTemp = 1;
                        SafeArrayGetElement(pArray, &lTemp, &sTemp2);
                        lTemp = 2;
                        SafeArrayGetElement(pArray, &lTemp, &sTemp3);
                    }
                    if (wcscmp(sTemp1, L"Context1") || wcscmp(sTemp2, L"Context2")
                        || wcscmp(sTemp3, L"Context3"))
                    {
                        RecordResult(E_FAIL, L"Verifying Configuration.Contexts ", 0);
                        hTemp = E_FAIL;
                    }
                }

                if (SUCCEEDED(hTemp))
                {
                    hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
                    RecordResult(hr, L"Deleting instance of Configuration ",0);
                }
                else
                    RecordResult(E_FAIL, L"Configuration instance NOT DELETED", 0);
                pInst->Release();
            }
            pHandle->Release();
        }
        pClass->Release();
    }
    VariantClear(&vTemp);

    return hr;

}
HRESULT TestSuiteCustRepDrvr::TestEmbeddedEvents()
{
    HRESULT hr = 0;
    // EmbeddedEvents
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;
    VARIANT vTemp;
    VariantInit(&vTemp);
    wchar_t wTemp[512];

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapEmbeddedEvents(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping EmbeddedEvents class ",0);

    pMap->Release();

    // Exercise instances.

    pClass->SpawnInstance(0, &pInst);

    SetIntProp   (pInst, L"EventID", 1);
    SetStringProp(pInst, L"CaptureDate", L"20000227020000.000000+***", FALSE, CIM_DATETIME);

    IWbemClassObject *pTemp2 = NULL;
    pClass->SpawnInstance(0, &pTemp2);
    SetIntProp(pTemp2, L"EventID", 1000);
    
    V_UNKNOWN(&vTemp) = pTemp2;
    vTemp.vt = VT_UNKNOWN;

    hr = pInst->Put(L"EventData", 0, &vTemp, CIM_OBJECT);
    VariantClear(&vTemp);

    hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, 0, NULL);
    RecordResult(hr, L"Inserting instance of EmbeddedEvents ",0);

    pInst->Release();

    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"EmbeddedEvents=1");
    IWmiDbHandle *pHandle = NULL;

    hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Retrieving instance of EmbeddedEvents ",0);

    // Verify that all data is correct.
    // If not, don't delete

    if (SUCCEEDED(hr))
    {
        hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
        if (SUCCEEDED(hr))
        {
            HRESULT hTemp = 0;
            
            // Only verify non-string types (ones that may fail)

            if (FAILED(ValidateProperty(pInst, L"CaptureDate", CIM_DATETIME, L"20000227020000.000000+000"))) 
            {
                RecordResult(E_FAIL, L"Verifying EmbeddedEvents.CaptureDate", 0);
                hTemp = E_FAIL;
            }

            hr = pInst->Get(L"EventData", NULL, &vTemp, NULL, NULL);
            if (SUCCEEDED(hr) && (vTemp.vt == (VT_ARRAY|VT_UNKNOWN)))
            {
                SAFEARRAY *pArray = V_ARRAY(&vTemp);
                if (pArray)
                {
                    long lTemp=0;
                    SafeArrayGetElement(pArray, &lTemp, &pTemp2);
                    if (pTemp2 == NULL || FAILED(ValidateProperty(pTemp2, L"EventID", CIM_UINT32, 1000)))
                    {
                        RecordResult(E_FAIL, L"Verifying EmbeddedEvents.EventData", 0);
                        hTemp = E_FAIL;
                    }
                }
            }


            if (SUCCEEDED(hr))
            {
                hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
                RecordResult(hr, L"Deleting instance of EmbeddedEvents ",0);
            }
            else
                RecordResult(E_FAIL, L"EmbeddedEvents instance NOT DELETED\n", 0);
            pInst->Release();
        }
        pHandle->Release();
    }

    pClass->Release();
    VariantClear(&vTemp);

    return hr;

}
HRESULT TestSuiteCustRepDrvr::TestGenericEvents()
{
    HRESULT hr = 0;
              
    // GenericEvent
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;
    VARIANT vTemp;
    VariantInit(&vTemp);
    wchar_t wTemp[512];

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapGenericEvent(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping GenericEvent class ",0);

    pMap->Release();

    // Exercise instances

    pClass->SpawnInstance(0, &pInst);
    SetStringProp(pInst, L"sDescription", L"This is an event.");

    IWmiDbHandle *pHandle = NULL;

    hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Inserting instance of GenericEvent ",0);
    if (SUCCEEDED(hr))
    {
        hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pInst);
    
        pInst->Get(L"sID", 0, &vTemp, NULL, NULL);
        swprintf(wTemp, L"GenericEvent=\"%s\"", vTemp.bstrVal);
        pInst->Release();

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wTemp);

        hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
        RecordResult(hr, L"Retrieving instance of GenericEvent ",0);

        if (SUCCEEDED(hr))
        {

            hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
            RecordResult(hr, L"Deleting instance of GenericEvent ",0);
        }
        else
            RecordResult(E_FAIL, L"GenericEvent instance NOT DELETED", 0);

        pInst->Release();
        pHandle->Release();
    }
    VariantClear(&vTemp);

    return hr;

}
HRESULT TestSuiteCustRepDrvr::TestComputerSystem()
{
    HRESULT hr = 0;
    // ComputerSystem
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapComputerSystem(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping ComputerSystem class ",0);

    pMap->Release();


    // Exercise instances.
    IWmiDbHandle *pHandle = NULL;

    pClass->SpawnInstance(0, &pInst);
    SetStringProp(pInst, L"SystemName", L"AKIAPOLAAU");
    hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Inserting instance of ComputerSystem ",0);

    pInst->Release();
    if (pHandle)
        pHandle->Release();

    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"ComputerSystem=\"AKIAPOLAAU\"");
    hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Retrieving instance of ComputerSystem ",0);

    hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
    RecordResult(hr, L"Deleting instance of ComputerSystem ",0);

    if (pClass)
        pClass->Release();
    if (pHandle)
        pHandle->Release();

    return hr;

}
HRESULT TestSuiteCustRepDrvr::TestCIMLogicalDevice()
{
    HRESULT hr = 0;
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;

    // CIMLogicalDevice

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapCIMLogicalDevice(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping CIMLogicalDevice class ",0);

    pMap->Release();
    

    return hr;

}
HRESULT TestSuiteCustRepDrvr::TestLogicalDisk()
{
    HRESULT hr = 0;

    // LogicalDisk
    IWbemClassObject *pMap = NULL;
    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pInst = NULL;

    pMappedObj->SpawnInstance(0, &pMap);                       
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pClass);

    hr = MapLogicalDisk(pMappingProp, &pMap, &pClass);
    if (SUCCEEDED(hr))
    {
        hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pMap, 0, 0, NULL);
        if (SUCCEEDED(hr))
            hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pClass, 0, 0, NULL);
    }
    RecordResult(hr, L"Mapping LogicalDisk class ",0);

    pMap->Release();               

    // Exercise instances.

    pClass->SpawnInstance(0, &pInst);
    SetStringProp(pInst, L"DeviceID", L"C:");
    SetStringProp(pInst, L"FileSystem", L"NTFS");
    SetIntProp   (pInst, L"Size", 2000);
    SetStringProp(pInst, L"VolumeSerialNumber", L"ABCDEF");
    SetIntProp   (pInst, L"FreeSpace", 50);

    hr = pSession->PutObject(pMappedNs, IID_IWbemClassObject, pInst, 0, 0, NULL);
    RecordResult(hr, L"Inserting instance of LogicalDisk ",0);

    pInst->Release();
    IWmiDbHandle *pHandle = NULL;

    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"LogicalDisk=\"C:\"");
    hr = pSession->GetObject(pMappedNs, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
    RecordResult(hr, L"Retrieving instance of LogicalDisk ",0);

    hr = pSession->DeleteObject(pMappedNs, 0, IID_IWmiDbHandle, pHandle);
    RecordResult(hr, L"Deleting instance of LogicalDisk ",0);

    if (pClass)
        pClass->Release();
    if (pHandle)
        pHandle->Release();
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\mmfarena2.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MMFARENA.CPP

Abstract:

    CMMFArena2 implementation (arenas based on memory-mapped files).

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemutil.h"
#include "mmfarena2.h"

CMMFArena2 *  g_pDbArena;

#define MAX_PAGE_SIZE_WIN9X		0x200000	/*2MB*/
#define MAX_PAGE_SIZE_NT		0x3200000	/*50MB*/

struct MMFOffsetItem
{
	DWORD_PTR m_dwBaseOffset;
	LPBYTE    m_pBasePointer;
	HANDLE    m_hMappingHandle;
	DWORD     m_dwBlockSize;
};

#if (defined DEBUG || defined _DEBUG)
void MMFDebugBreak()
{
	DebugBreak();
}
#else
inline void MMFDebugBreak() {}
#endif

//***************************************************************************
//
//	CMMFArena2::CMMFArena2
//
//	Constructor.  Initialises a few things.
//
//***************************************************************************
CMMFArena2::CMMFArena2(bool bReadOnly) 
: m_bReadOnlyAccess(bReadOnly), m_dwStatus(0), m_hFile(INVALID_HANDLE_VALUE)
{
	g_pDbArena = this;

	//Get processor granularity
	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	m_dwMappingGranularity = sysInfo.dwAllocationGranularity;

	//Create the maximum page size... based on the OS
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
	{
		//Failed... assume the worst!
		m_dwMaxPageSize = MAX_PAGE_SIZE_WIN9X;
	}
	else
	{
		if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			m_dwMaxPageSize = MAX_PAGE_SIZE_NT;
		}
		else
		{
			m_dwMaxPageSize = MAX_PAGE_SIZE_WIN9X;
		}
	}
}

//***************************************************************************
//
//	CMMFArena2::CreateNewMMF
//
//	Creates a new MMF.  This creates a single page with the header initialised
//	for with the MMF header information.
//
//	pszFile			: Filename of the MMF to open
//	dwGranularity	: Minimum block allocation size
//	dwInitSize		: Initial size of the repository.
//
//	Return value	: false if we failed, true if we succeed.
//
//***************************************************************************
bool CMMFArena2::CreateNewMMF(const char *pszFile,		//File of MMF to open
							  DWORD dwGranularity,		// Granularity per allocation (min block size)
							  DWORD dwInitSize)			// Initial heap size
{
	//Size should be of a specific granularity...
	if (dwInitSize % m_dwMappingGranularity)
		dwInitSize += (m_dwMappingGranularity - (dwInitSize % m_dwMappingGranularity));

	// Create a new file
	// =================
	m_hFile = CreateFile(
		 pszFile,
		 GENERIC_READ | (m_bReadOnlyAccess ? 0 : GENERIC_WRITE),
		 FILE_SHARE_READ | (m_bReadOnlyAccess ? FILE_SHARE_WRITE : 0),
		 0,
		 CREATE_NEW,
		 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
		 0
		 );

	if (m_hFile == INVALID_HANDLE_VALUE) 
	{
		_ASSERT(0, "WinMgmt: Failed to create a new repository file");
		m_dwStatus = 7;
		return false;
	}

	//Create the end page marker here in case we have no memory...
	MMFOffsetItem *pOffsetEnd = 0;
	pOffsetEnd = new MMFOffsetItem;
	if (pOffsetEnd == 0)
	{
		_ASSERT(0, "WinMgmt: Out of memory");
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		throw CX_MemoryException();
	}

	//Create the base page...
	MMFOffsetItem *pOffsetItem = CreateBasePage(dwInitSize, dwGranularity);
	if (pOffsetItem == 0)
	{
		_ASSERT(0, "WinMgmt: Failed to create base MMF page");
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		return false;
	}
	int nStatus = -1;
	//Add this page information to the offset manager...
	nStatus = m_OffsetManager.Add(pOffsetItem);
	if (nStatus != 0)
	{
		_ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
		//We are out of memory... lets tidy up...
		ClosePage(pOffsetItem);
		delete pOffsetItem;

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		throw CX_MemoryException();
	}

	//Fill in the end page marker information and add it to the offset manager...
	pOffsetEnd->m_dwBaseOffset = m_pHeapDescriptor->m_dwCurrentSize;
	pOffsetEnd->m_pBasePointer = 0;
	pOffsetEnd->m_hMappingHandle = 0;
	pOffsetEnd->m_dwBlockSize = 0;
	
	nStatus = -1;
	nStatus = m_OffsetManager.Add(pOffsetEnd);
	if (nStatus != 0)
	{
		_ASSERT(0, "WinMgmt: Failed to add end block marker into offset table");
		//We are out of memory... lets tidy up...
		ClosePage(pOffsetItem);
		m_OffsetManager.Empty();
		delete pOffsetItem;
		delete pOffsetEnd;

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		throw CX_MemoryException();
	}

	return true;
}

//***************************************************************************
//
//	CMMFArena2::LoadMMF
//
//	Loads an existing MMF.  Loads in the base page and all pages following
//	that
//
//	pszFile			: Filename of the MMF to open
//
//	Return value	: false if we failed, true if we succeed.
//
//***************************************************************************
bool CMMFArena2::LoadMMF(const char *pszFile)
{
	//Open the file...
	m_hFile = CreateFile(
		 pszFile,
		 GENERIC_READ | (m_bReadOnlyAccess ? 0 : GENERIC_WRITE),
		 FILE_SHARE_READ | (m_bReadOnlyAccess ? FILE_SHARE_WRITE : 0),
		 0,
		 OPEN_EXISTING,
		 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
		 0
		 );

	if (m_hFile == INVALID_HANDLE_VALUE) 
	{
		_ASSERT(0, "WinMgmt: Failed to open existing repository file");
		m_dwStatus = 7;
		return false;
	}
	DWORD dwSizeOfRepository = 0;
	MMFOffsetItem *pOffsetItem = 0;

	//Open the base page...
	pOffsetItem = OpenBasePage(dwSizeOfRepository);
	if (pOffsetItem == 0)
	{
		_ASSERT(0, "WinMgmt: Failed to open base page in MMF");
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		return false;
	}

	//Add the details to the offset manager...
	int nStatus = -1;
	nStatus = m_OffsetManager.Add(pOffsetItem);
	if (nStatus)
	{
		_ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
		ClosePage(pOffsetItem);
		delete pOffsetItem;

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		throw CX_MemoryException();
	}

	DWORD_PTR dwPageBase = 0;

	if (m_pHeapDescriptor->m_dwVersion == 9)
	{
		//Now loop through all the following pages and load them...
		DWORD dwSizeLastPage = 0;
		nStatus = -1;
		for (dwPageBase = pOffsetItem->m_dwBlockSize; dwPageBase < dwSizeOfRepository; dwPageBase += dwSizeLastPage)
		{
			//Open the next...
			pOffsetItem = OpenExistingPage(dwPageBase);
			if (pOffsetItem == 0)
			{
				_ASSERT(0, "WinMgmt: Failed to open an existing page in the MMF");
				//Failed to do that!
				CloseAllPages();
				CloseHandle(m_hFile);
				m_hFile = INVALID_HANDLE_VALUE;
				m_dwStatus = 7;
				return false;
			}
			//Add the information to the offset manager...
			nStatus = -1;
			nStatus = m_OffsetManager.Add(pOffsetItem);
			if (nStatus)
			{
				_ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
				//Failed to do that!
				ClosePage(pOffsetItem);
				delete pOffsetItem;
				CloseAllPages();
				CloseHandle(m_hFile);
				m_hFile = INVALID_HANDLE_VALUE;
				m_dwStatus = 7;
				throw CX_MemoryException();
			}
			dwSizeLastPage = pOffsetItem->m_dwBlockSize;
		}
	}
	else if ((m_pHeapDescriptor->m_dwVersion == 10) || (m_pHeapDescriptor->m_dwVersion < 9))
	{
		dwPageBase = pOffsetItem->m_dwBlockSize;
	}
	else
	{
		_ASSERT(0, "WinMgmt: Database error... Code has not been added to support the opening of this database!!!!!");
		ERRORTRACE((LOG_WBEMCORE, "Database error... Code has not been added to support the opening of this database!!!!!\n"));
	}

	//Create a mapping entry to mark the end of the MMF
	pOffsetItem = new MMFOffsetItem;
	if (pOffsetItem == 0)
	{
		_ASSERT(0, "WinMgmt: Out of memory");
		//Failed to do that!
		CloseAllPages();
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		throw CX_MemoryException();
	}
	pOffsetItem->m_dwBaseOffset = dwPageBase;
	pOffsetItem->m_dwBlockSize = 0;
	pOffsetItem->m_hMappingHandle = 0;
	pOffsetItem->m_pBasePointer = 0;
	nStatus = -1;
	nStatus = m_OffsetManager.Add(pOffsetItem);
	if (nStatus)
	{
		_ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
		//Failed to do that!
		ClosePage(pOffsetItem);
		delete pOffsetItem;
		CloseAllPages();
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwStatus = 7;
		throw CX_MemoryException();
	}

	return true;
};

//***************************************************************************
//
//	CMMFArena2::OpenBasePage
//
//	Opens the MMF first page which has all the information about the rest
//	of the MMF as well as the first page of data.
//
//	dwSizeOfRepository	: Returns the current size of the repository
//
//	Return value	: Pointer to an offset item filled in with the base
//					  page information.  NULL if we fail to open the
//					  base page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::OpenBasePage(DWORD &dwSizeOfRepository)
{
	MMFOffsetItem *pOffsetItem = 0;
	pOffsetItem = new MMFOffsetItem;
	if (pOffsetItem == 0)
		throw CX_MemoryException();

	//Seek to the start of this page...
	if (SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		_ASSERT(0, "WinMgmt: Failed to set file pointer on MMF");
		delete pOffsetItem;
		return 0;
	}

	//Read in the hear information so we can find the size of this block...
	DWORD dwActualRead;
	MMF_ARENA_HEADER mmfHeader;
	if ((ReadFile(m_hFile, &mmfHeader, sizeof(MMF_ARENA_HEADER), &dwActualRead, 0) == 0) || (dwActualRead != sizeof(MMF_ARENA_HEADER)))
	{
		_ASSERT(0, "WinMgmt: Failed to read MMF header information");
		delete pOffsetItem;
		return 0;
	}

	//Record the current size information...
	dwSizeOfRepository = mmfHeader.m_dwCurrentSize;

	DWORD dwSizeToMap = 0;

	if ((mmfHeader.m_dwVersion < 9) || (mmfHeader.m_dwVersion == 10))
	{
		//old style database, we map in everything...
		dwSizeToMap = mmfHeader.m_dwCurrentSize;
	}
	else if (mmfHeader.m_dwVersion == 9)
	{
		//We get the first page...
		dwSizeToMap = mmfHeader.m_dwSizeOfFirstPage;
	}
	else
	{
		_ASSERT(0, "WinMgmt: Database error... Code has not been added to support the opening of this database!!!!!");
		ERRORTRACE((LOG_WBEMCORE, "Database error... Code has not been added to support the opening of this database!!!!!\n"));
	}

	//Create the file mapping for this page...
	HANDLE hMapping = CreateFileMapping(
		m_hFile,							// Disk file
		0,									// No security
		(m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,		// Extend the file to match the heap size
		0,									// High-order max size
		dwSizeToMap,		// Low-order max size
		0									// No name for the mapping object
		);

	if (hMapping == NULL) 
	{
		_ASSERT(0, "WinMgmt: Failed to create file mapping");
		delete pOffsetItem;
		return 0;
	}

	// Map this into memory...
	LPBYTE pBindingAddress = (LPBYTE)MapViewOfFile(hMapping,
												(m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
												 0,
												 0,
												 dwSizeToMap
												 );

	if (pBindingAddress == NULL) 
	{
		_ASSERT(0, "WinMgmt: Failed to map MMF into memory");
		delete pOffsetItem;
		CloseHandle(hMapping);
		return 0;
	}

	//Record the base address of this because we need easy access to the header...
	m_pHeapDescriptor = (MMF_ARENA_HEADER*) pBindingAddress;

	//Create a mapping entry for this...
	pOffsetItem->m_dwBaseOffset = 0;
	pOffsetItem->m_dwBlockSize = dwSizeToMap;
	pOffsetItem->m_hMappingHandle = hMapping;
	pOffsetItem->m_pBasePointer = pBindingAddress;

	return pOffsetItem;
}

//***************************************************************************
//
//	CMMFArena2::OpenExistingPage
//
//	Opens the specified page from the repostory.
//
//	dwBaseOffset	: Offset within the MMF to map in.
//
//	Return value	: Pointer to an offset item filled in with the 
//					  page information.  NULL if we fail to open the
//					  page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::OpenExistingPage(DWORD_PTR dwBaseOffset)
{
	MMFOffsetItem *pOffsetItem = 0;
	pOffsetItem = new MMFOffsetItem;
	if (pOffsetItem == 0)
		throw CX_MemoryException();

	//Set the file pointer to the start of this page...
	if (SetFilePointer(m_hFile, dwBaseOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		//We are messed up!
		_ASSERT(0, "WinMgmt: Failed to determine the size of the next block to load");
		return 0;
	}

	//Read in the page information so we can find out how big the page is...
	DWORD dwActualRead = 0;
	MMF_PAGE_HEADER pageHeader;
	if ((ReadFile(m_hFile, &pageHeader, sizeof(MMF_PAGE_HEADER), &dwActualRead, 0) == 0) || (dwActualRead != sizeof(MMF_PAGE_HEADER)))
	{
		_ASSERT(0, "WinMgmt: Failed to read the next page block size");
		return 0;
	}

	//Create the file mapping...
	HANDLE hMapping;
	hMapping = CreateFileMapping(m_hFile, 
								 0, 
								 (m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,
								 0, 
								 dwBaseOffset + pageHeader.m_dwSize, 
								 0);
	
	if (hMapping == 0)
	{
		_ASSERT(0, "WinMgmt: Failed to map in part of the memory mapped file!");
		return 0;
	}

	//Map this into memory...
	LPBYTE pBindingAddress;
	pBindingAddress= (LPBYTE)MapViewOfFile(hMapping,
											(m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
											0,
											dwBaseOffset,
											pageHeader.m_dwSize);
	if (pBindingAddress == 0)
	{
		_ASSERT(0, "WinMgmt: Failed to bind part of the memory mapped file into memory!");
		return 0;
	}

	//Record the information...
	pOffsetItem->m_dwBaseOffset = dwBaseOffset;
	pOffsetItem->m_dwBlockSize = pageHeader.m_dwSize;
	pOffsetItem->m_hMappingHandle = hMapping;
	pOffsetItem->m_pBasePointer = pBindingAddress;

	return pOffsetItem;
}

//***************************************************************************
//
//	CMMFArena2::CreateBasePage
//
//	Creates a new base page and initialises it.
//
//	dwInitSize		: Initial size of the repotitory, which is also the size
//					  of the first page.
//	dwGranularity	: Size of mimimmum block allocation size...
//
//	Return value	: Pointer to an offset item filled in with the 
//					  page information.  NULL if we fail to open the
//					  page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::CreateBasePage(DWORD dwInitSize, DWORD dwGranularity)
{
	MMFOffsetItem *pOffsetItem = 0;
	pOffsetItem = new MMFOffsetItem;
	if (pOffsetItem == 0)
		throw CX_MemoryException();

	// Create a file mapping for this base page...
	// ===========================================
	HANDLE hMapping = CreateFileMapping(
		m_hFile,							// Disk file
		0,									// No security
		(m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,		// Extend the file to match the heap size
		0,									// High-order max size
		dwInitSize,							// Low-order max size
		0									// No name for the mapping object
		);

	if (hMapping == NULL) 
	{
		_ASSERT(0, "WinMgmt: Failed to create a new file mapping");
		return 0;
	}

	// Map this page into memory...
	// ============================
	LPBYTE pBindingAddress = (LPBYTE)MapViewOfFile(hMapping,
												(m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
												 0,
												 0,
												 dwInitSize
												 );

	if (pBindingAddress == NULL) 
	{
		_ASSERT(0, "WinMgmt: Failed to map in new page into memory");
		CloseHandle(hMapping);
		return 0;
	}

	//Record the base pointer which is used throughout to hold important items
	//and information about the MMF.
	m_pHeapDescriptor = (MMF_ARENA_HEADER*) pBindingAddress;

	// Record the final heap address and set up the other related pointers.
	m_pHeapDescriptor->m_dwVersion = 0;
	m_pHeapDescriptor->m_dwGranularity = dwGranularity;
	m_pHeapDescriptor->m_dwCurrentSize = dwInitSize;
	m_pHeapDescriptor->m_dwMaxSize = 0;
	m_pHeapDescriptor->m_dwGrowBy = 0;
	m_pHeapDescriptor->m_dwHeapExtent = sizeof(MMF_ARENA_HEADER);
	m_pHeapDescriptor->m_dwEndOfHeap = dwInitSize;
	m_pHeapDescriptor->m_dwFreeList = 0;
	m_pHeapDescriptor->m_dwRootBlock = 0;
	m_pHeapDescriptor->m_dwSizeOfFirstPage = dwInitSize;

	//Now we have to add this information to the offset manager...
	pOffsetItem->m_dwBaseOffset = 0;
	pOffsetItem->m_pBasePointer = pBindingAddress;
	pOffsetItem->m_hMappingHandle = hMapping;
	pOffsetItem->m_dwBlockSize = dwInitSize;

	return pOffsetItem;
}

//***************************************************************************
//
//	CMMFArena2::CreateNewPage
//
//	Creates a new page and initialises the header, returning a structure
//	detailing the page.
//
//	dwBaseOffset	: Base offset of this new page
//	dwSize			: Size of this page
//
//	Return value	: Pointer to an offset item filled in with the 
//					  page information.  NULL if we fail to open the
//					  page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::CreateNewPage(DWORD_PTR dwBaseOffset, DWORD dwSize)
{
	MMFOffsetItem *pOffsetItem = 0;
	pOffsetItem = new MMFOffsetItem;
	if (pOffsetItem == 0)
		throw CX_MemoryException();

	//Create the file mapping, this may grow the file...
	HANDLE hNewMapping;
	LPBYTE pNewBindingAddress = NULL;
	hNewMapping = CreateFileMapping(
		m_hFile,										// Disk file
		0,												// No security
		(m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,					// Extend the file to match the heap size
		0,												// High-order max size
		dwBaseOffset + dwSize,							// Low-order max size
		0												// No name for the mapping object
		);

	DWORD dwErr = GetLastError();

	if (hNewMapping != 0 && dwErr == 0) 
	{

		//Map this into memory...
		pNewBindingAddress = (LPBYTE)MapViewOfFile(
			hNewMapping,
			(m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
			0,
			dwBaseOffset,							// Old size used here!!!
			dwSize									// Size of new part of mapping
			);

		if (pNewBindingAddress)
		{
			//Record the information...
			pOffsetItem->m_dwBaseOffset = dwBaseOffset;
			pOffsetItem->m_pBasePointer = pNewBindingAddress;
			pOffsetItem->m_hMappingHandle = hNewMapping;
			pOffsetItem->m_dwBlockSize = dwSize;

			//Fill in the page header...
			MMF_PAGE_HEADER *pPageHeader = (MMF_PAGE_HEADER *)pNewBindingAddress;
			pPageHeader->m_dwSize = dwSize;
		}			 
		else
		{
			_ASSERT(0, "WinMgmt: Failed to map in page of MMF into memory");
			ERRORTRACE((LOG_WBEMCORE, "Failed to map the new file mapping into memory for block size of %lu.  Last Error = %lu\n", dwSize, GetLastError()));
			CloseHandle(hNewMapping);
			delete pOffsetItem;
			pOffsetItem = 0;
		}
	}
	else
	{
		_ASSERT(0, "WinMgmt: Failed to create a file mapping for the MMF");
		if (hNewMapping != 0)
			CloseHandle(hNewMapping);
		ERRORTRACE((LOG_WBEMCORE, "Failed to create a new file mapping for %lu bytes block.  Last Error = %lu\n", dwSize, dwErr));
		delete pOffsetItem;
		pOffsetItem = 0;
	}

	return pOffsetItem;
}

//***************************************************************************
//
//	CMMFArena2::ClosePage
//
//	Closes the page specified
//
//	pOffsetItem	: Information about the page to close.
//
//	Return value	: None
//
//***************************************************************************
void CMMFArena2::ClosePage(MMFOffsetItem *pOffsetItem)
{
	if (pOffsetItem->m_hMappingHandle)
	{
		UnmapViewOfFile(pOffsetItem->m_pBasePointer);
		CloseHandle(pOffsetItem->m_hMappingHandle);
	}
}

//***************************************************************************
//
//	CMMFArena2::CloseAllPages
//
//	Closes all pages in the offset manager, deleting the pointers of the
//	objects in there.
//
//	Return value	: None
//
//***************************************************************************
void CMMFArena2::CloseAllPages()
{
	//Close each of the file mappings...
	for (int i = 0; i != m_OffsetManager.Size(); i++)
	{
		MMFOffsetItem *pItem = (MMFOffsetItem*)m_OffsetManager[i];
		ClosePage(pItem);
		delete pItem;
	}
	m_OffsetManager.Empty();
}

//***************************************************************************
//
//	CMMFArena2::~CMMFArena2
//
//	Destructor flushes the heap, unmaps the view and closes handles.
//
//***************************************************************************

CMMFArena2::~CMMFArena2()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		//Make sure what is in the MMF is flushed...
		Flush();

		//Remember the size of the file....
		DWORD dwFileSize = m_pHeapDescriptor->m_dwCurrentSize;

		//Close each of the file mappings...
		CloseAllPages();

		//Set the size in case we messed it up if we failed to do a grow...
		SetFilePointer(m_hFile, dwFileSize, NULL, FILE_BEGIN);
		SetEndOfFile(m_hFile);

		//Close the file handle
		CloseHandle(m_hFile);
	}
}

//***************************************************************************
//
//	CMMFArena2::Alloc
//
//	Allocates a new memory block.	Uses the free list if a suitable block
//	can be found; grows the heap if required.
//
//	Parameters:
//	<dwBytes>		Number of bytes to allocate.
//
//	Return value:
//	Offsete of memory, or 0 on failure.
//
//***************************************************************************
DWORD_PTR CMMFArena2::Alloc(DWORD dwBytes)
{
	//Allocation of 0 bytes returns 0!
	if (dwBytes == 0)
		return 0;

	if (m_dwStatus != 0)
		throw DATABASE_FULL_EXCEPTION();

	//Make sure we are large enough block for any information we store in the 
	//block when it is deleted
	if (dwBytes < sizeof(MMF_BLOCK_DELETED))
		dwBytes = sizeof(MMF_BLOCK_DELETED);

	//Check the granularity of the size...
	DWORD dwGran = m_pHeapDescriptor->m_dwGranularity;
	dwBytes = (dwBytes - 1 + dwGran) / dwGran * dwGran;

	//Now adjust the size to include the header and trailer blocks...
	dwBytes += sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER);

	//Get the first item in the free-list pointer
	DWORD_PTR dwFreeBlock = m_pHeapDescriptor->m_dwFreeList;
	MMF_BLOCK_HEADER *pFreeBlock = (MMF_BLOCK_HEADER*)OffsetToPtr(dwFreeBlock);

	//While free-list pointer is not NULL, and the size of the free-list pointer 
	//block is too small
	while (dwFreeBlock && (GetSize(pFreeBlock) < dwBytes))
	{
		ValidateBlock(dwFreeBlock);

		//Get the next block in the free-list pointer
		MMF_BLOCK_DELETED *pUserBlock = GetUserBlock(pFreeBlock);
		dwFreeBlock = pUserBlock->m_dwFLnext;
		pFreeBlock = (MMF_BLOCK_HEADER*)OffsetToPtr(dwFreeBlock);
	}

	//If the free-list pointer is NULL, we need to allocate more space in the arena
	if (dwFreeBlock == NULL)
	{
		//If there is not enough space at the end of the heap unused, we need to 
		//grow the heap
		if (dwBytes > (m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent)) 
		{
			//Mark the chunk of memory at the end of the arena as deleted as it is too 
			//small to use...
			if (m_pHeapDescriptor->m_dwEndOfHeap != m_pHeapDescriptor->m_dwHeapExtent)
			{
				DecorateUsedBlock(m_pHeapDescriptor->m_dwHeapExtent, m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent);
				Free(DWORD_PTR((LPBYTE)m_pHeapDescriptor->m_dwHeapExtent + sizeof(MMF_BLOCK_HEADER)));
				m_pHeapDescriptor->m_dwHeapExtent = m_pHeapDescriptor->m_dwEndOfHeap;
			}

			//If (Grow the arena by at least dwBytes) fails
			if (GrowArena(dwBytes) == 0)
			{
				//Fail the operation
				throw DATABASE_FULL_EXCEPTION();
				m_dwStatus = 1;
				return 0;
			}
		}
		
		//We have a chunk of memory at the end of the arena which is not in the 
		//free-list.  We need to extend the size of the working arena and 
		//use this.
		if ((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent - dwBytes) <= (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER) + max(sizeof(MMF_BLOCK_DELETED), m_pHeapDescriptor->m_dwGranularity)))
		{
			dwBytes += m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent - dwBytes;
		}
		DWORD_PTR dwFreeBlock = m_pHeapDescriptor->m_dwHeapExtent;
		m_pHeapDescriptor->m_dwHeapExtent += dwBytes;
		DecorateUsedBlock(dwFreeBlock, dwBytes);

//		_ASSERT((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) > (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER) + sizeof(MMF_BLOCK_DELETED)), "Space left at end of arena is too small");
		ZeroOutBlock(dwFreeBlock, 0xCD);
		return dwFreeBlock + sizeof(MMF_BLOCK_HEADER);
	}

	ValidateBlock(dwFreeBlock);

	//If this block is large enough to split
	if ((GetSize(pFreeBlock) - dwBytes) >= 
			(sizeof(MMF_BLOCK_HEADER) + 
			 sizeof(MMF_BLOCK_TRAILER) + 
			 max(sizeof(MMF_BLOCK_DELETED), m_pHeapDescriptor->m_dwGranularity)))
	{
		//We need to split this large block into two and put the free-list
		//information from the start of this block into the newly
		//slit off bit
		MMF_BLOCK_DELETED *pFreeBlockUser = GetUserBlock(pFreeBlock);
		MMF_BLOCK_TRAILER *pFreeBlockTrailer = GetTrailerBlock(pFreeBlock);
		DecorateAsDeleted(dwFreeBlock + dwBytes, 
						  GetSize(pFreeBlock) - dwBytes, 
						  pFreeBlockUser->m_dwFLnext,
						  pFreeBlockTrailer->m_dwFLback);

		//Now need to point the previous blocks and next blocks free-list pointers to point
		//to this new starting point.
		MMF_BLOCK_HEADER *pNewFreeBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwFreeBlock + dwBytes);
		MMF_BLOCK_DELETED *pNewFreeBlockUser = GetUserBlock(pNewFreeBlockHeader);
		MMF_BLOCK_TRAILER *pNewBlockTrailer = GetTrailerBlock(pNewFreeBlockHeader);

		//Deal with previous block...
		if (pNewBlockTrailer->m_dwFLback)
		{
			MMF_BLOCK_HEADER *pPrevFreeBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(pNewBlockTrailer->m_dwFLback);
			MMF_BLOCK_DELETED *pPrevFreeBlockUser = GetUserBlock(pPrevFreeBlockHeader);
			pPrevFreeBlockUser->m_dwFLnext = dwFreeBlock + dwBytes;
		}
		else
		{
			m_pHeapDescriptor->m_dwFreeList = dwFreeBlock + dwBytes;
		}
		
		//Deal with next block...if there is one
		if (pNewFreeBlockUser->m_dwFLnext)
		{
			MMF_BLOCK_HEADER *pNextFreeBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(pNewFreeBlockUser->m_dwFLnext);
			MMF_BLOCK_TRAILER *pNextFreeBlockTrailer = GetTrailerBlock(pNextFreeBlockHeader);
			pNextFreeBlockTrailer->m_dwFLback = dwFreeBlock + dwBytes;
		}

		//Set up the header and footer of this newly slit block
		DecorateUsedBlock(dwFreeBlock, dwBytes);
	}
	else
	{
		//Otherwise we need to remove this block from the free-list.
		RemoveBlockFromFreeList(pFreeBlock);

		//Populate this block with header and trailer information
		DecorateUsedBlock(dwFreeBlock, GetSize(pFreeBlock));
	}
	ZeroOutBlock(dwFreeBlock, 0xCD);

	_ASSERT(!(((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) != 0) &&
			((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) < (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER) + sizeof(MMF_BLOCK_DELETED)))), 
			"Space left at end of arena is too small");

	//Return the offset to the caller.
	return dwFreeBlock + sizeof(MMF_BLOCK_HEADER);
}

//***************************************************************************
//
//	CMMFArena2::Realloc
//
//	Allocates a new block of the requested size, copies the current
//	contents to it and frees up the original.  If the original is
//	large enough it returns that.
//
//	Parameters:
//	<dwAddress> 	The address to reallocate
//	<dwNewSize> 	New requested size
//	
//	Return value:
//	TRUE on success, FALSE if not enough memory of corruption detected
//
//***************************************************************************
DWORD_PTR CMMFArena2::Realloc(DWORD_PTR dwOriginal, DWORD dwNewSize)
{
	if (m_dwStatus != 0)
		throw DATABASE_FULL_EXCEPTION();

	//Validate original block...
	ValidateBlock(dwOriginal - sizeof(MMF_BLOCK_HEADER));

	MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwOriginal - sizeof(MMF_BLOCK_HEADER));

	//If the original block is large enough, return the original
	if ((GetSize(pHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER))  >= dwNewSize)
		return dwOriginal;

	//Allocate a new block
	DWORD_PTR dwNewBlock = Alloc(dwNewSize);

	//If the allocation failed return NULL
	if (dwNewBlock == 0)
		return 0;

	//Copy orignial contents into it
	memcpy(OffsetToPtr(dwNewBlock), OffsetToPtr(dwOriginal), GetSize(pHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER));

	//Free original block
	Free(dwOriginal);

	//Return newly allocated block
	return dwNewBlock;
}

//***************************************************************************
//
//	CMMFArena2::Free
//
//	Frees a block of memory and places it on the free list.
//
//	Parameters:
//	<dwAddress> 	The address to 'free'.
//	
//	Return value:
//	TRUE on success, FALSE on erroneous address.
//
//***************************************************************************

BOOL CMMFArena2::Free(DWORD_PTR dwAddress)
{
	//Freeing of NULL is OK!
	if (dwAddress == 0)
		return TRUE;

	if (m_dwStatus != 0)
		throw DATABASE_FULL_EXCEPTION();

	//Set the address to point to the actual start of the block
	dwAddress -= sizeof(MMF_BLOCK_HEADER);

	//Check the block is valid...
	ValidateBlock(dwAddress);

	MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwAddress);

	DWORD     dwMappedBlockSize = 0;
	DWORD_PTR dwMappedBlockBaseAddress = GetBlockBaseAddress(dwAddress, dwMappedBlockSize);

	//If there is a block following this and it is deleted we should remove it from the free-list
	//chain and merge it with this block... That is if this is not the last block
	//in the heap!
	DWORD_PTR dwNextBlockAddress = dwAddress + GetSize(pBlockHeader);
	if ((dwNextBlockAddress < (dwMappedBlockBaseAddress + dwMappedBlockSize)) && (dwNextBlockAddress < m_pHeapDescriptor->m_dwHeapExtent))
	{
		MMF_BLOCK_HEADER *pNextBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwNextBlockAddress);
		if (IsDeleted(pNextBlockHeader))
		{
			//OK, we can now remove this block from the free-list
			RemoveBlockFromFreeList(pNextBlockHeader);

			DecorateUsedBlock(dwAddress, GetSize(pBlockHeader) + GetSize(pNextBlockHeader));
		}
	}

	//If there is a deleted block before we have to merge this block into the previous one
	//The previous block is deleted if there is something in the FL back-pointer of the 
	//previous blocks trailer.  Make sure this is not the first block in the heap though!!!
	MMF_BLOCK_HEADER *pPrevBlockHeader = 0;
	if ((dwAddress != (dwMappedBlockBaseAddress + sizeof(MMF_PAGE_HEADER))) && (pPrevBlockHeader = GetPreviousDeletedBlock(pBlockHeader)))
	{
		//There is a deleted block prior to this one!  We need to merge them
		MMF_BLOCK_DELETED *pPrevBlockUser = GetUserBlock(pPrevBlockHeader);
		MMF_BLOCK_TRAILER *pPrevBlockTrailer = GetTrailerBlock(pPrevBlockHeader);
		DecorateAsDeleted(PtrToOffset(LPBYTE(pPrevBlockHeader)), 
						  GetSize(pPrevBlockHeader) + GetSize(pBlockHeader),
						  pPrevBlockUser->m_dwFLnext, 
						  pPrevBlockTrailer->m_dwFLback);

		//This block is now fully set up in the free-list!!!
		dwAddress = PtrToOffset(LPBYTE(pPrevBlockHeader));
		
		ValidateBlock(dwAddress);
	}
	else
	{
		//We just add this block as it stands to the free-list chain.
		DecorateAsDeleted(dwAddress, GetSize(pBlockHeader), m_pHeapDescriptor->m_dwFreeList, NULL);

		//Point the free-list header pointer at us
		m_pHeapDescriptor->m_dwFreeList = dwAddress;

		//If there is a next block, set the next blocks previous FL pointer to us
		MMF_BLOCK_DELETED *pBlockUser = GetUserBlock(pBlockHeader);
		if (pBlockUser->m_dwFLnext)
		{
			MMF_BLOCK_HEADER *pNextBlockHeader = (MMF_BLOCK_HEADER*)(OffsetToPtr(pBlockUser->m_dwFLnext));
			MMF_BLOCK_TRAILER *pNextBlockTrailer = GetTrailerBlock(pNextBlockHeader);
			pNextBlockTrailer->m_dwFLback = dwAddress;
		}

		ValidateBlock(dwAddress);
	}

	ZeroOutBlock(dwAddress, 0xDD);
	return TRUE;
}

//***************************************************************************
//
//	CMMFArena2::GrowArena
//
//	Grows the head of the MMF by atleast the amount specified.	It does not
//	add the space to the free-list.
//
//	Parameters:
//	<dwGrowBySize>		Number of bytes to allocate.
//
//	Return value:
//	FALSE if cannot grow the heap (either because it is locked, or due to
//	a failure).  TRUE otherwise.
//
//***************************************************************************
DWORD_PTR CMMFArena2::GrowArena(DWORD dwGrowBySize)
{
	//Check that the arena is valid before continuing...
	if (m_dwStatus != 0)
		return 0;

	//Validation of heap and no grow passes 0 in!
	if (dwGrowBySize == 0)
		return 0;

	// We check the current size and see if applying
	// the m_dwGrowBy factor would increase the size beyond
	// the maximum heap size.
	// ======================================================
	DWORD dwIncrement = 0;

	while (dwIncrement < dwGrowBySize) 
	{
		if (((m_pHeapDescriptor->m_dwCurrentSize + dwIncrement) / 10) < m_dwMappingGranularity )
			dwIncrement += m_dwMappingGranularity;
		else
			dwIncrement += (m_pHeapDescriptor->m_dwCurrentSize + dwIncrement) / 10;
	}

	//Cap the size of the page...
	//If we are a larger block that the max size allowed... cap it...
	if (dwIncrement > m_dwMaxPageSize)
	{
		dwIncrement = m_dwMaxPageSize;
	}

	// If here, we can try to increase the heap size by remapping.
	// ===========================================================
	MMFOffsetItem *pOffsetItem = 0;
	bool bLastTry = false;
	while (pOffsetItem == 0)
	{
		//Try and use a smaller increment until we fail to allocate the smallest block size possible...
		//---------------------------------------------------------------------------------------------

		//Make sure this block is big enough for the request plus the page header...
		if (dwIncrement < (dwGrowBySize + sizeof(MMF_PAGE_HEADER)))
		{
			dwIncrement = dwGrowBySize + sizeof(MMF_PAGE_HEADER);
			bLastTry = true;
		}

		if (dwIncrement <= m_dwMappingGranularity)
		{
			bLastTry = true;
		}
		//Size should be of a specific granularity...
		if (dwIncrement % m_dwMappingGranularity)
			dwIncrement += (m_dwMappingGranularity - (dwIncrement % m_dwMappingGranularity));

		pOffsetItem = CreateNewPage(m_pHeapDescriptor->m_dwCurrentSize, dwIncrement);

		if (pOffsetItem == 0)
		{
			//We failed!  Can we try again...
			if (bLastTry)
			{
				//No!  This was the smallest we could make the block
				return 0;
			}
					
			dwIncrement /= 2;
		}

	}
	if (pOffsetItem == 0)
	{
		return 0;
	}

	int nStatus = -1;
	nStatus = m_OffsetManager.InsertAt(m_OffsetManager.Size()-1, pOffsetItem);
	if (nStatus)
	{
		ClosePage(pOffsetItem);
		delete pOffsetItem;
		throw CX_MemoryException();
	}

	DWORD dwNewSize = m_pHeapDescriptor->m_dwCurrentSize + dwIncrement;

	// If here, we succeeded completely
	// ================================
	m_pHeapDescriptor->m_dwHeapExtent = m_pHeapDescriptor->m_dwCurrentSize + sizeof(MMF_PAGE_HEADER);
	m_pHeapDescriptor->m_dwCurrentSize = dwNewSize;
	m_pHeapDescriptor->m_dwEndOfHeap = dwNewSize;

	//get end of file item... and update it with new end offset
	MMFOffsetItem *pEndOffsetItem = (MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size() - 1];
	pEndOffsetItem->m_dwBaseOffset = dwNewSize;

	return pOffsetItem->m_dwBaseOffset;  
}

//***************************************************************************
//
//	CMMFArena2::Flush
//
//	Flushes all uncommited changed to disk.
//
//	Parameters:
//
//	Return value:
//	TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::Flush()
{
	//Need to loop through all mappings and flush them all...
	//Close each of the file mappings...
	for (int i = 0; i != m_OffsetManager.Size(); i++)
	{
		MMFOffsetItem *pItem = (MMFOffsetItem*)m_OffsetManager[i];
		if (pItem->m_hMappingHandle)
		{
			FlushViewOfFile(pItem->m_pBasePointer, 0);
		}
	}
	return TRUE;
}
//***************************************************************************
//
//	CMMFArena2::Flush
//
//	Flushes the page associated with the specified address
//
//	Parameters:
//		<dwAddress>	offset within the MMF to flush
//
//	Return value:
//	TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::Flush(DWORD_PTR dwAddress)
{
    MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwAddress - sizeof(MMF_BLOCK_HEADER));

    if (!FlushViewOfFile(pHeader, GetSize(pHeader)))
        return FALSE;
    return TRUE;
}

//***************************************************************************
//
//	CMMFArena2::DecorateUsedBlock
//
//	Populates the header and trailer blocks in the specified block.
//
//	Parameters:
//		<dwBlock>	Offset of block to decorate
//		<dwBytes>	Size of block
//
//	Return value:
//	TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::DecorateUsedBlock(DWORD_PTR dwBlock, DWORD dwBytes)
{
	MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
	pHeader->m_dwSize = (dwBytes & MMF_REMOVE_DELETED_MASK);
	MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
	pTrailer->m_dwFLback = NULL;

	if (sizeof(pTrailer->m_dwCheckBlock))
	{
		for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
		{
			pTrailer->m_dwCheckBlock[dwIndex] = MMF_DEBUG_INUSE_TAG;
		}
	}

	return TRUE;
}

//***************************************************************************
//
//	CMMFArena2::DecorateAsDeleted
//
//	Populates the header and trailer blocks in the specified block with 
//	everything needed to make it look like a deleted block. Updates
//	the items associated with the free list within the block
//
//	Parameters:
//		<dwBlock>				Offset of block to decorate
//		<dwBytes>				Size of block
//		<dwNextFreeListOffset>	next item in the free-list
//		dwPrevFreeListOffset<>	previous item in the free list.
//
//	Return value:
//	TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::DecorateAsDeleted(DWORD_PTR dwBlock, 
								   DWORD dwBytes, 
								   DWORD_PTR dwNextFreeListOffset,
								   DWORD_PTR dwPrevFreeListOffset)
{
	MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
	pHeader->m_dwSize = (dwBytes | MMF_DELETED_MASK);
	MMF_BLOCK_DELETED *pUserBlock = GetUserBlock(pHeader);
	MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
	pTrailer->m_dwFLback = dwPrevFreeListOffset;
	pUserBlock->m_dwFLnext = dwNextFreeListOffset;

	if (sizeof(pTrailer->m_dwCheckBlock))
	{
		for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
		{
			pTrailer->m_dwCheckBlock[dwIndex] = MMF_DEBUG_DELETED_TAG;
		}
	}

	return TRUE;
}

//***************************************************************************
//
//	CMMFArena2::ValidateBlock
//
//	Validates the memory block as much as possible and calls a debug break
//	point if an error is detected.  Does this by analysing the size and
//	the trailer DWORDs
//
//	Parameters:
//		<dwBlock>				Offset of block to check
//
//	Return value:
//	TRUE if success.
//
//***************************************************************************
#if (defined DEBUG || defined _DEBUG)
BOOL CMMFArena2::ValidateBlock(DWORD_PTR dwBlock)
{
	try
	{
		MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
		MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
		if (sizeof(pTrailer->m_dwCheckBlock))
		{
			DWORD dwCheckBit;

			//Is it deleted?
			if (pHeader->m_dwSize & MMF_DELETED_MASK)
			{
				//Yes it is, so the we check for 0xFFFF
				dwCheckBit = MMF_DEBUG_DELETED_TAG;
			}
			else
			{
				dwCheckBit = MMF_DEBUG_INUSE_TAG;
			}

			for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
			{
				if (pTrailer->m_dwCheckBlock[dwIndex] != dwCheckBit)
				{
					char string[200];
					sprintf(string, "WinMgmt: MMF Arena heap corruption,offset = 0x%p\n", dwBlock);
					OutputDebugString(string);
					MMFDebugBreak();
					_ASSERT(0, string);
					return FALSE;
				}
			}
		}
		if (!(pHeader->m_dwSize & MMF_DELETED_MASK))
		{
			//We are not deleted, so we should have a trailer back pointer of NULL
			if (pTrailer->m_dwFLback != 0)
			{
				char string[200];
				sprintf(string, "WinMgmt: MMF Arena heap corruption, offset = 0x%p\n", dwBlock);
				OutputDebugString(string);
				MMFDebugBreak();
				_ASSERT(0, string);
				return FALSE;
			}

		}
	}
	catch (...)
	{
		char string[200];
		sprintf(string, "WinMgmt: MMF Arena heap corruption, offset = 0x%p\n", dwBlock);
		OutputDebugString(string);
		MMFDebugBreak();
		_ASSERT(0, string);
		return FALSE;
	}

	return TRUE;
}
#endif
//***************************************************************************
//
//	CMMFArena2::RemoveBlockFromFreeList
//
//	Removes the specified block from the free-list.
//
//	Parameters:
//		<pBlockHeader>				pointer of block to remove
//
//	Return value:
//	TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::RemoveBlockFromFreeList(MMF_BLOCK_HEADER *pBlockHeader)
{
	//Bit of validation...
	if (!IsDeleted(pBlockHeader))
	{
		char string[200];
		sprintf(string, "WinMgmt: MMF Arena heap corruption: deleting deleted block, offset = 0x%p\n", Fixdown(pBlockHeader));
		OutputDebugString(string);
		MMFDebugBreak();
		_ASSERT(0, string);
		return FALSE;
	}

	MMF_BLOCK_DELETED *pUserBlock = GetUserBlock(pBlockHeader);
	MMF_BLOCK_TRAILER *pTrailerBlock = GetTrailerBlock(pBlockHeader);

	//Deal with next block if it exists
	if (pUserBlock->m_dwFLnext != 0)
	{
		//This has a next block.  Its back pointer needs to point to our back pointer
		MMF_BLOCK_HEADER *pNextFreeBlock = (MMF_BLOCK_HEADER *)OffsetToPtr(pUserBlock->m_dwFLnext);
		MMF_BLOCK_TRAILER *pNextTrailerBlock = GetTrailerBlock(pNextFreeBlock);
		pNextTrailerBlock->m_dwFLback = pTrailerBlock->m_dwFLback;
	}

	//Deal with previous block if it exists
	if (pTrailerBlock->m_dwFLback == 0)
	{
		//This is the first item in the free-list so the heap descriptor points to it.
		//Now needs to point to the next item.
		m_pHeapDescriptor->m_dwFreeList = pUserBlock->m_dwFLnext;
	}
	else
	{
		//This has a previous block in the list
		MMF_BLOCK_HEADER *pPrevFreeBlock = (MMF_BLOCK_HEADER *)OffsetToPtr(pTrailerBlock->m_dwFLback);
		MMF_BLOCK_DELETED *pPrevUserBlock = GetUserBlock(pPrevFreeBlock);
		pPrevUserBlock->m_dwFLnext = pUserBlock->m_dwFLnext;
	}

	return TRUE;
}

//***************************************************************************
//
//	CMMFArena2::GetPreviousDeletedBlock
//
//	If the previous block in the MMF is deleted it returns the pointer to 
//	it.  If there the previous block is not deleted or there is no 
//	previous block it returns NULL
//
//	Parameters:
//		<pBlockHeader>				pointer to the current block
//
//	Return value:
//	NULL if no previous deleted block, otherwise pointer to one.
//
//***************************************************************************
MMF_BLOCK_HEADER *CMMFArena2::GetPreviousDeletedBlock(MMF_BLOCK_HEADER *pBlockHeader)
{
	//If this is the first block there is no previous block...
	if (PtrToOffset(LPBYTE(pBlockHeader)) == sizeof(MMF_ARENA_HEADER))
		return NULL;

	//Only do anything if there are deleted blocks (we have to do this check for the
	//special case, so might as well use it around everything!)
	if (m_pHeapDescriptor->m_dwFreeList)
	{
		//Special case of when the previous block is the head block, in which case the trailer of the
		//previous block is is NULL!
		MMF_BLOCK_HEADER *pHeadFreeBlock = (MMF_BLOCK_HEADER*)OffsetToPtr(m_pHeapDescriptor->m_dwFreeList);
		if ((LPBYTE(pHeadFreeBlock) + GetSize(pHeadFreeBlock)) == LPBYTE(pBlockHeader))
		{
			//The head block is the previous deleted block!
			return pHeadFreeBlock;
		}

		//Get the trailer pointer to the previous block...
		MMF_BLOCK_TRAILER *pPrevBlockTrailer = (MMF_BLOCK_TRAILER *)(LPBYTE(pBlockHeader) - sizeof(MMF_BLOCK_TRAILER));
		if (pPrevBlockTrailer->m_dwFLback == NULL)
		{
			//The previous block is not deleted. (if this was the head free-list item we would
			//have returned it in the special case!)
			return NULL;
		}

		//Now we need to get the previous deleted block to this previous block!
		MMF_BLOCK_HEADER *pPrevPrevBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(pPrevBlockTrailer->m_dwFLback);

		//Now need this blocks user section so we can get the start of the next free-list item (the one we
		//want!)
		MMF_BLOCK_DELETED *pPrevPrevBlockUser = (MMF_BLOCK_DELETED *)(LPBYTE(pPrevPrevBlockHeader) + sizeof(MMF_BLOCK_HEADER));
		return (MMF_BLOCK_HEADER *)OffsetToPtr(pPrevPrevBlockUser->m_dwFLnext);
	}

	//There are no deleted blocks!
	return NULL;
}

#if (defined DEBUG || defined _DEBUG)
BOOL CMMFArena2::ZeroOutBlock(DWORD_PTR dwBlock, int cFill)
{
	MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
	if (IsDeleted(pBlockHeader))
	{
		memset(LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_DELETED), cFill, GetSize(pBlockHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER) - sizeof(MMF_BLOCK_DELETED));
	}
	else
	{
		memset(LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER), cFill, GetSize(pBlockHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER));
	}
	return TRUE;
}
#endif

//Some debugging functions...
void CMMFArena2::Reset()
{
    // Move cursor to first block.
    // ===========================

    m_dwCursor = sizeof(MMF_ARENA_HEADER);
}

BOOL CMMFArena2::Next(LPBYTE *ppBlock, DWORD *pdwSize, BOOL *pbActive)
{
    if (m_dwCursor >= m_pHeapDescriptor->m_dwHeapExtent)
        return FALSE;

    // Return the block address and block size values to the caller.
    // We strip out the MS bit of the block size, since it is not
    // part of the size, but indicates whether or not the block is
    // part of the free list or part of the active chain.
    // =============================================================

	MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(m_dwCursor);

    *ppBlock = LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER);  // Move past the head block.
    *pdwSize = GetSize(pBlockHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER);

    *pbActive = !IsDeleted(pBlockHeader);

    // Advance our cursor.
    // ===================

    m_dwCursor += GetSize(pBlockHeader);

    return TRUE;
}

//***************************************************************************
//
//  CMMFArena::TextDump
//
//  Dumps a summary of the heap to a text file.
//
//  Parameters:
//  <pszFile>       The text file to which to perform the dump. This
//                  file is appended to.
//
//***************************************************************************

void CMMFArena2::TextDump(const char *pszFile)
{
    FILE *f = fopen(pszFile, "at");
    if (!f)
        return;
        
    LPBYTE pAddress = 0;
    DWORD dwSize = 0;
    BOOL bActive = 0;

    // Primary heap.
    // =============

    fprintf(f, "---Primary Heap Contents---\n");

    Reset();
    while (Next(&pAddress, &dwSize, &bActive))
    {
        fprintf(f, "BLOCK 0x%X  Size=%06d ", PtrToOffset(pAddress), dwSize);
        if (bActive)
            fprintf(f, "(active)  :");
        else
            fprintf(f, "(deleted) :");

        for (int i = 0; i < (int) dwSize && i < 32; i++)
            if (pAddress[i] < 32)
                fprintf(f, ".");
            else
                fprintf(f, "%c", pAddress[i]);
        fprintf(f, "\n");
    }
    
    fclose(f);
}

//***************************************************************************
//
//  CMMFArena::GetHeapInfo
//
//  Gets detailed summary info about the heap.  Completely walks the
//  heap to do this.
//
//  Parameters:
//      <pdwTotalSize>          Receives the heap size.
//      <pdwActiveBlocks>       Receives the number of allocated blocks.
//      <pdwActiveBytes>        Receives the total allocated bytes.
//      <pdwFreeBlocks>         Receives the number of 'free' blocks.
//      <pdwFreeByte>           Receives the number of 'free' bytes.
//
//***************************************************************************

void CMMFArena2::GetHeapInfo(
    DWORD *pdwTotalSize,
    DWORD *pdwActiveBlocks,
    DWORD *pdwActiveBytes,
    DWORD *pdwFreeBlocks,
    DWORD *pdwFreeBytes
    )
{
    LPBYTE pAddress = 0;
    DWORD dwSize = 0;
    BOOL bActive = 0;

    if (pdwTotalSize)   
        *pdwTotalSize = m_pHeapDescriptor->m_dwCurrentSize;
 
    if (pdwActiveBlocks)
        *pdwActiveBlocks = 0;
    if (pdwActiveBytes)
        *pdwActiveBytes = 0;
    if (pdwFreeBlocks)
        *pdwFreeBlocks = 0;
    if (pdwFreeBytes)
        *pdwFreeBytes = 0;
        
 
    Reset();
    while (Next(&pAddress, &dwSize, &bActive))
    {
        if (bActive)
        {
            if (pdwActiveBytes)
                (*pdwActiveBytes) += dwSize;
            if (pdwActiveBlocks)
                (*pdwActiveBlocks)++;
        }            
        else
        {
            if (pdwFreeBytes)
                (*pdwFreeBytes) += dwSize;
            if (pdwFreeBlocks)
                (*pdwFreeBlocks)++;
        }
    }        
}

BOOL CMMFArena2::FileValid(const char *pszFilename)
{
	BOOL bValid = FALSE;
	HANDLE hFile = CreateFile(
		 pszFilename,
		 GENERIC_READ | GENERIC_WRITE,
		 FILE_SHARE_READ,									// Share mode = exclusive
		 0, 												// Security
		 OPEN_EXISTING,										// Creation distribution
		 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,	// Attribute
		 0													// Template file
		 );

	if (hFile == INVALID_HANDLE_VALUE)
	{
		//This means the file does not exist or something screwy has happened.
		return FALSE;
	}

	MMF_ARENA_HEADER header;
	DWORD dwBytesRead;
	if (ReadFile(hFile, &header, sizeof(MMF_ARENA_HEADER), &dwBytesRead, NULL))
	{
		if (sizeof(MMF_ARENA_HEADER) == dwBytesRead)
		{
			if (header.m_dwVersion <= 3)
			{
				//The header exists, now we need to check to make sure the file length is
				//correct...
				//Magic numbers :-)  This is how the Version 3 or less size was calculated.
				//actually it was sizeof the header, which was 568 in those days.
				if (GetFileSize(hFile, NULL) == (header.m_dwCurrentSize + 568))
				{
					bValid = TRUE;
				}
				else
				{
					//The sizes are not the same...
				}
			}
			else
			{
				//The header exists, now we need to check to make sure the file length is
				//correct...
				if (GetFileSize(hFile, NULL) == header.m_dwCurrentSize)
				{
					bValid = TRUE;
				}
				else
				{
					//The sizes are not the same...
				}
			}

		}
		else
		{
			//Implies the file length may have been zeroed out or something
		}
	}
	else
	{
		//Implies the file length may have been zeroed out or something
	}

	CloseHandle(hFile);

	_ASSERT(bValid == TRUE, "Repository size is not the same as the size we think it should be.");

	return bValid;
}

DWORD_PTR CMMFArena2::GetRootBlock()
{ 
	if (m_pHeapDescriptor->m_dwVersion <= 3)
	{
		DWORD_PTR *pMem = (DWORD_PTR*) m_pHeapDescriptor;
		return pMem[9];
	}
	else
	{
		return (m_pHeapDescriptor ? m_pHeapDescriptor->m_dwRootBlock : 0); 
	}
}

DWORD CMMFArena2::Size(DWORD_PTR dwBlock)
{
	if (m_dwStatus != 0)
		throw DATABASE_FULL_EXCEPTION();

	//Set the address to point to the actual start of the block
	dwBlock -= sizeof(MMF_BLOCK_HEADER);

	//Check the block is valid...
	ValidateBlock(dwBlock);

	MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwBlock);

	return GetSize(pBlockHeader);
}

//Given an offset, returns a fixed up pointer
LPBYTE CMMFArena2::OffsetToPtr(DWORD_PTR dwOffset)
{
	if (dwOffset == 0)
		return 0;

	if (m_dwStatus != 0)
		throw DATABASE_FULL_EXCEPTION();

	try
	{
		LPBYTE pBlock = 0;
		int l = 0, u = m_OffsetManager.Size() - 1;

		while (l <= u)
		{
			int m = (l + u) / 2;
			if (dwOffset < ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset)
			{
				u = m - 1;
			}
			else if (dwOffset >= ((MMFOffsetItem *)m_OffsetManager[m+1])->m_dwBaseOffset)
			{
				l = m + 1;
			}
			else
			{
				return ((MMFOffsetItem *)m_OffsetManager[m])->m_pBasePointer + (dwOffset - ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset);
			}
		}
	}
	catch (...)
	{
	}
	char string[220];
	sprintf(string, "WinMgmt: Could not find the block requested in the repository, offset requested = 0x%p, end of repository = 0x%p\n", dwOffset, ((MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size()-1])->m_dwBaseOffset);
	OutputDebugString(string);
	_ASSERT(0, string);
	MMFDebugBreak();
	return 0;
}

//Given a pointer, returns an offset from the start of the MMF
DWORD_PTR  CMMFArena2::PtrToOffset(LPBYTE pBlock)
{
	if (m_dwStatus != 0)
		throw DATABASE_FULL_EXCEPTION();

	for (int i = 0; i < m_OffsetManager.Size(); i++)
	{
		register MMFOffsetItem *pItem = (MMFOffsetItem *)m_OffsetManager[i];
		if ((pBlock >= pItem->m_pBasePointer) &&
			(pBlock < (pItem->m_pBasePointer + pItem->m_dwBlockSize)))
		{
			return pItem->m_dwBaseOffset + (pBlock - pItem->m_pBasePointer);
		}
	}
	char string[220];
	sprintf(string, "WinMgmt: Could not find the offset requested in the repository, pointer requested = 0x%p\n", pBlock);
	OutputDebugString(string);
	_ASSERT(0, string);
	MMFDebugBreak();
	return 0;
}

DWORD_PTR CMMFArena2::GetBlockBaseAddress(DWORD_PTR dwOffset, DWORD &dwSize)
{
	LPBYTE pBlock = 0;
	int l = 0, u = m_OffsetManager.Size() - 1;

	while (l <= u)
	{
		int m = (l + u) / 2;
		if (dwOffset < ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset)
		{
			u = m - 1;
		}
		else if (dwOffset >= ((MMFOffsetItem *)m_OffsetManager[m+1])->m_dwBaseOffset)
		{
			l = m + 1;
		}
		else
		{
			register MMFOffsetItem *pItem = (MMFOffsetItem *)m_OffsetManager[m];
			dwSize = pItem->m_dwBlockSize;
			return pItem->m_dwBaseOffset;
		}
	}
	char string[220];
	sprintf(string, "WinMgmt: Could not find the block requested in the repository, offset requested = 0x%p, end of repository = 0x%p\n", dwOffset, ((MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size()-1])->m_dwBaseOffset);
	OutputDebugString(string);
	_ASSERT(0, string);
	MMFDebugBreak();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\mmfarena2.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MMFARENA.H

Abstract:

    CArena derivative based on memory mapped files.

History:

	a-raymcc	23-Apr-96		Created
	paulall 	23-Mar-98		Re-worked

--*/

#if (defined __WIN9x_BUILD__)
#include "mmfarena2_w9x.h"
#elif (defined __WINNT_BUILD__)

#ifndef _MMFARENA_H_
#define _MMFARENA_H_

#include "corepol.h"
#include "FlexArry.h"

#if defined _WIN32
#define MMF_DELETED_MASK		0x80000000
#define MMF_REMOVE_DELETED_MASK	0x7FFFFFFF
#define MMF_DEBUG_DELETED_TAG	0xFFFFFFFF
#define MMF_DEBUG_INUSE_TAG		0xFEFEFEFE
#elif defined _WIN64
#define MMF_DELETED_MASK		0x8000000000000000
#define MMF_REMOVE_DELETED_MASK	0x7FFFFFFFFFFFFFFF
#define MMF_DEBUG_DELETED_TAG	0xFFFFFFFFFFFFFFFF
#define MMF_DEBUG_INUSE_TAG		0xFEFEFEFEFEFEFEFE
#endif

struct MMFOffsetItem;

#include "corex.h"
class DATABASE_FULL_EXCEPTION : public CX_Exception
{
};

//***************************************************************************
//
//	struct MMF_ARENA_HEADER
//
//	Root structure for MMF Arena.  This is recorded on the disk
//	image at the very beginning of the file.
//
//***************************************************************************

#pragma pack(4) 				// Require fixed aligment.

typedef struct
{
	// Version used to create file
	// vvvvvv MUST BE FIRST VALUE vvvvvvv
	DWORD  m_dwVersion; 		// <<<<<< MUST BE FIRST VALUE!
	// ^^^^^^ MUST BE FIRST VALUE ^^^^^^^
	DWORD  m_dwGranularity; 	// Granularity of allocation	  
	DWORD  m_dwCurrentSize; 	// Current size of heap
	DWORD  m_dwMaxSize; 		// Max heap size, -1= no limit
	DWORD  m_dwGrowBy;			// Bytes to grow by during out-of-heap
	
	DWORD_PTR  m_dwHeapExtent;		// First unused address
	DWORD_PTR  m_dwEndOfHeap;		// Last valid address + 1
	DWORD_PTR  m_dwFreeList;		// NULL if empty
	DWORD_PTR  m_dwRootBlock;		// Root block
	DWORD m_dwSizeOfFirstPage;	//Size of the first block
	
}	MMF_ARENA_HEADER;

typedef struct
{
	DWORD m_dwSize; 		//Size of block.  Highest bit set when deleted.

}	MMF_BLOCK_HEADER;

typedef struct
{
	DWORD_PTR m_dwFLback;	//previous free block in the chain, NULL if not deleted
	DWORD m_dwCheckBlock[2];

}	MMF_BLOCK_TRAILER;

typedef struct
{
	DWORD_PTR m_dwFLnext;		//Next free block in the chain

}	MMF_BLOCK_DELETED;

typedef struct
{
	DWORD m_dwSize;				//Size of page

}	MMF_PAGE_HEADER;			//Page header... not there for first page.
#pragma pack()					// Restore previous aligment.


//***************************************************************************
//
//	class CMMFArena2 
//
//	Implements an offset-based heap over a memory-mapped file.
//
//***************************************************************************

class POLARITY CMMFArena2 
{
	DWORD  m_dwStatus;
	HANDLE m_hFile;
	MMF_ARENA_HEADER *m_pHeapDescriptor;
	DWORD m_dwCursor;
	DWORD m_dwMappingGranularity;
	bool m_bReadOnlyAccess;
	DWORD m_dwMaxPageSize;
	CFlexArray m_OffsetManager;

	//Adds the header and trailer items to the specified block.
	BOOL DecorateUsedBlock(DWORD_PTR dwBlock, DWORD dwBytes);
	
	//Adds header and trailer items to the specified block and marks it as deleted
	BOOL DecorateAsDeleted(DWORD_PTR dwBlock, 
						   DWORD dwBytes, 
						   DWORD_PTR dwNextFreeListOffset,
						   DWORD_PTR dwPrevFreeListOffset);

	//Retrieves the size of the block from the header and removes the deleted bit
	DWORD GetSize(MMF_BLOCK_HEADER *pBlock) { return pBlock->m_dwSize & MMF_REMOVE_DELETED_MASK; }

	MMF_BLOCK_DELETED *GetUserBlock(MMF_BLOCK_HEADER *pBlockHeader) { return (MMF_BLOCK_DELETED*)(LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER)); }
	MMF_BLOCK_TRAILER *GetTrailerBlock(MMF_BLOCK_HEADER *pBlockHeader) { return (MMF_BLOCK_TRAILER*)(LPBYTE(pBlockHeader) + GetSize(pBlockHeader) - sizeof(MMF_BLOCK_TRAILER)); }


	//Removes a deleted block from the free-list
	BOOL RemoveBlockFromFreeList(MMF_BLOCK_HEADER *pBlock);

	//Gets the previous block pointer if the block is deleted, otherwise return NULL
	MMF_BLOCK_HEADER *GetPreviousDeletedBlock(MMF_BLOCK_HEADER *pBlockHeader);

	//Zero's out a block (not including the header and trailer!)
	BOOL ZeroOutBlock(DWORD_PTR dwBlock, int cFill)
#if (defined DEBUG || defined _DEBUG)
		;
#else
	{ return TRUE;}
#endif

	//Some debugging functions...
    void    Reset();
    BOOL    Next(LPBYTE *ppAddress, DWORD *pdwSize, BOOL *pbActive);

	//Checks the deleted bit of the size block
	BOOL IsDeleted(MMF_BLOCK_HEADER *pBlock) { return (pBlock->m_dwSize & MMF_DELETED_MASK) ? TRUE : FALSE; }
	//Validates a pointer
	BOOL ValidateBlock(DWORD_PTR dwBlock)
#if (defined DEBUG || defined _DEBUG)
		;
#pragma message("MMF heap validation enabled.")
#else
	{ return TRUE;}
#endif

	// Grows the size of the arena by a minumum of the specified amount
	DWORD_PTR GrowArena(DWORD dwGrowBySize);

	//For a given offset, return the mapped base offset and size
	DWORD_PTR GetBlockBaseAddress(DWORD_PTR dwOffset, DWORD &dwSize);

	MMFOffsetItem *CreateNewPage(DWORD_PTR dwBaseOffset, DWORD dwSize);
	MMFOffsetItem *CreateBasePage(DWORD dwInitSize, DWORD dwGanularity);
	MMFOffsetItem *OpenBasePage(DWORD &dwSizeOfRepository);
	MMFOffsetItem *OpenExistingPage(DWORD_PTR dwBaseOffset);
	void ClosePage(MMFOffsetItem *pOffsetItem);
	void CloseAllPages();

public:
	enum { create_new, use_existing };
		
	// Constructor.
	CMMFArena2(bool bReadOnly = false);
   
	// Destructor.
	~CMMFArena2();

	//Methods to open an MMF
	bool LoadMMF(const char *pszFile);
	bool CreateNewMMF(const char *pszFile,
					  DWORD dwGranularity,
					  DWORD dwInitSize);

	// Allocates a block of memory.   
	DWORD_PTR Alloc(IN DWORD dwBytes);

	// Reallocates a block of memory.
	DWORD_PTR Realloc(DWORD_PTR dwOriginal, DWORD dwNewSize);

	// Frees a block of memory.
	BOOL Free(DWORD_PTR dwBlock);

	DWORD Size(DWORD_PTR dwBlock);

	//Writes any changes not already commited in the MMF to disk.
	BOOL Flush();
	BOOL Flush(DWORD_PTR dwOffsetToFlush);

	void SetVersion(DWORD dwVersion) { if (m_pHeapDescriptor) m_pHeapDescriptor->m_dwVersion = dwVersion; }
	DWORD GetVersion() { return (m_pHeapDescriptor? m_pHeapDescriptor->m_dwVersion : 0); }

	DWORD_PTR GetRootBlock();
	void SetRootBlock(DWORD_PTR dwRootBlock) { if (m_pHeapDescriptor) m_pHeapDescriptor->m_dwRootBlock = dwRootBlock; }

	DWORD GetStatus() { return m_dwStatus; }

    // Tells the amount of memory remaining without a remap or new extent.
    // ===================================================================
    DWORD_PTR   ExtentMemAvail() 
        { return (m_pHeapDescriptor ? (m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) : 0);
        }         

	//Given an offset, returns a fixed up pointer
	LPBYTE OffsetToPtr(DWORD_PTR dwOffset);

	//Given a pointer, returns an offset from the start of the MMF
	DWORD_PTR  PtrToOffset(LPBYTE pBlock);

    // Gets summary heap information.
    // ==============================
    void GetHeapInfo(
         DWORD *pdwTotalSize,
         DWORD *pdwActiveBlocks,
         DWORD *pdwActiveBytes,
         DWORD *pdwFreeBlocks,
         DWORD *pdwFreeBytes
		 );

	MMF_ARENA_HEADER *GetMMFHeader() { return m_pHeapDescriptor; }

	//Dumps the heap to a file
	void TextDump(const char *pszFile);

	//Checks the deleted bit of the size block
	BOOL IsDeleted(DWORD_PTR dwBlock) { return IsDeleted((MMF_BLOCK_HEADER*)(OffsetToPtr(dwBlock - sizeof(MMF_BLOCK_HEADER)))); }

	BOOL IsValidBlock(DWORD_PTR dwBlock) { return ValidateBlock(dwBlock - sizeof(MMF_BLOCK_HEADER)); }

	//Does a check of the MMF file to make sure it is valid.  At time of writing this only
	//checks the file size.
	static BOOL FileValid(const char *pszFilename);

	bool MappingGood() { return true; }

};

//***************************************************************************
//
//	Fixup helpers.
//
//	These are all strongly type variations of the same thing: they fix
//	up the based ptr to a dereferenceable pointer or take the ptr and
//	fix it back down to an offset.
//
//***************************************************************************
extern CMMFArena2* g_pDbArena;
template <class T> T Fixup(T ptr) 
{ return T(g_pDbArena->OffsetToPtr(DWORD_PTR(ptr))); }
template <class T> T Fixdown(T ptr) 
{ return T(g_pDbArena->PtrToOffset(LPBYTE(ptr))); }

template <class T> class Offset_Ptr
{
private:
	T *m_pTarget;
	T *m_poTarget;

protected:
	void SetValue(T *val) { m_pTarget = Fixup(val); m_poTarget = val;}
	void SetValue(Offset_Ptr &val) { m_pTarget = val.m_pTarget; m_poTarget = val.m_poTarget; }

public:
	Offset_Ptr() : m_pTarget(0), m_poTarget(0) {}

	T* operator ->() { return m_pTarget; }
	DWORD_PTR GetDWORD_PTR() { return DWORD_PTR(m_poTarget); }
	T* GetOffset() { return m_poTarget; }
	T* GetPtr() { return m_pTarget; }
};
#endif

#else
#define __STR2__(x) #x
#define __STR1__(x) __STR2__(x)
#define __LOC__ __FILE__ "("__STR1__(__LINE__)") : Error xxxx: "
#pragma message("Unknown platform destination specified in makefile.  Don't know what database version to use.")
#pragma message(__LOC__"Unsupported platform destination for MMFArena2.")
#undef __STR2__
#undef __STR1__
#undef __LOC__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\winntsec.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.H

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#ifndef _WINNTSEC_H_
#define _WINNTSEC_H_

class CNtSecurity;

// All ACE types are currently have the same binary layout. Rather
// than doing a lot of useless casts, we produce a general-purpose
// typedef to hold all ACEs.
// ================================================================

typedef ACCESS_ALLOWED_ACE GENERIC_ACE;
typedef GENERIC_ACE *PGENERIC_ACE;

#define FULL_CONTROL     \
        (DELETE |       \
         READ_CONTROL | \
        WRITE_DAC |         \
        WRITE_OWNER |   \
        SYNCHRONIZE | GENERIC_ALL)


//***************************************************************************
//
//  CNtSid
//
//  Models SIDs (users/groups).
//
//***************************************************************************

class CNtSid
{
    PSID    m_pSid;
    LPWSTR  m_pMachine;
    LPWSTR  m_pDomain;
    DWORD   m_dwStatus;
    SID_NAME_USE m_snu;

public:
    enum { NoError, Failed, NullSid, InvalidSid, InternalError, AccessDenied = 0x5 };

    enum SidType {CURRENT_USER, CURRENT_THREAD};

    CNtSid(SidType st);
    CNtSid() { m_pSid = 0; m_pMachine = 0; m_dwStatus = NullSid; }
    bool IsUser(){return m_snu == SidTypeUser;};

    CNtSid(PSID pSrc);
        // Construct based on another SID.

    CNtSid(LPWSTR pUser, LPWSTR pMachine = 0);
        // Construct based on a user (machine name is optional).

   ~CNtSid();

    CNtSid(CNtSid &Src);
    CNtSid &operator =(CNtSid &Src);
    int operator ==(CNtSid &Comparand);

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    PSID GetPtr() { return m_pSid; }
        // Returns the internal SID ptr to interface with NT APIs
    DWORD GetSize();

    BOOL CopyTo(PSID pDestination);

    BOOL IsValid() { return (m_pSid && IsValidSid(m_pSid)); }
        // Checks the validity of the internal SID.

    void Dump();
        // Dumps SID info to console for debugging.

    int GetInfo(
        LPWSTR *pRetAccount,        // Account, use operator delete
        LPWSTR *pRetDomain,         // Domain, use operator delete
        DWORD  *pdwUse              // See SID_NAME_USE for values
        );

    BOOL GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen);

};

//***************************************************************************
//
//  CBaseAce
//
//  Base class for aces.
//
//***************************************************************************

class CBaseAce
{

public:

    CBaseAce(){};
    virtual ~CBaseAce(){};

    virtual int GetType() = 0;
    virtual int GetFlags() = 0;         // inheritance etc.
    virtual ACCESS_MASK GetAccessMask() = 0;
    virtual HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize) = 0;
    virtual HRESULT GetFullUserName2(WCHAR ** pBuff) = 0; // call must free
    virtual DWORD GetStatus() = 0;
    virtual void SetFlags(long lFlags) =0;
    virtual DWORD GetSerializedSize() = 0;
    virtual bool  Serialize(BYTE * pData) = 0;
    virtual bool  Deserialize(BYTE * pData) = 0;
};


//***************************************************************************
//
//  CNtAce
//
//  Models NT ACEs.
//
//***************************************************************************

class CNtAce : public CBaseAce
{
    PGENERIC_ACE    m_pAce;
    DWORD           m_dwStatus;

public:
    enum { NoError, InvalidAce, NullAce, InternalError };

    CNtAce() { m_pAce = 0; m_dwStatus = NullAce; }

    CNtAce(PGENERIC_ACE pAceSrc);
    CNtAce(CNtAce &Src);
    CNtAce & operator =(CNtAce &Src);

   ~CNtAce();

   CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser,
        LPWSTR pMachine = 0         // Defaults to local machine
        );

    CNtAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        CNtSid & Sid
        );

    int GetType();
    int GetFlags();         // inheritance etc.
    void SetFlags(long lFlags){m_pAce->Header.AceFlags = (unsigned char)lFlags;};

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    int GetSubject(
        LPWSTR *pSubject
        );

    ACCESS_MASK GetAccessMask();

    CNtSid *GetSid();
    BOOL GetSid(CNtSid &Dest);

    PGENERIC_ACE GetPtr() { return m_pAce; }
    DWORD GetSize() { return m_pAce ? m_pAce->Header.AceSize : 0; }
    HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize);
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData);
    bool Deserialize(BYTE * pData);

    void Dump(int iAceNum = -1);
    void DumpAccessMask();
};

//***************************************************************************
//
//  C9XAce
//
//  Simulates NT ACEs for 9X boxs.
//
//***************************************************************************

class C9XAce : public CBaseAce
{
    LPWSTR m_wszFullName;
    DWORD m_dwAccess;
    int m_iFlags;
    int m_iType;
public:

   C9XAce(){m_wszFullName = 0;};
   C9XAce(DWORD Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser);
   ~C9XAce();

    int GetType(){return m_iType;};
    int GetFlags(){return m_iFlags;};         // inheritance etc.

    ACCESS_MASK GetAccessMask(){return m_dwAccess;};
    HRESULT GetFullUserName(WCHAR * pBuff, DWORD dwSize);
    HRESULT GetFullUserName2(WCHAR ** pBuff); // call must free
    DWORD GetStatus(){ return CNtAce::NoError; };
    void SetFlags(long lFlags){m_iFlags = (unsigned char)lFlags;};
    DWORD GetSerializedSize();
    bool Serialize(BYTE * pData);
    bool Deserialize(BYTE * pData);

};


//***************************************************************************
//
//  CNtAcl
//
//  Models an NT ACL.
//
//***************************************************************************

class CNtAcl
{
    PACL    m_pAcl;
    DWORD   m_dwStatus;

public:
    enum { NoError, InternalError, NullAcl, InvalidAcl };
    enum { MinimumSize = 1 };

    CNtAcl(DWORD dwInitialSize = 128);

    CNtAcl(CNtAcl &Src);
    CNtAcl & operator = (CNtAcl &Src);

    CNtAcl(PACL pAcl);  // Makes a copy
   ~CNtAcl();

    int  GetNumAces();

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    CNtAce *GetAce(int nIndex);
    BOOL GetAce(int nIndex, CNtAce &Dest);

    BOOL DeleteAce(int nIndex);
    BOOL AddAce(CNtAce *pAce);

    BOOL IsValid() { return(m_pAcl && IsValidAcl(m_pAcl)); }
        // Checks the validity of the embedded ACL.

    BOOL Resize(DWORD dwNewSize);
        // Or use CNtAcl::MinimumSize to trim the ACL to min size.
        // Fails if an illegal size is specified.

    DWORD GetSize();

    PACL GetPtr() { return m_pAcl; }
        // Returns the internal pointer for interface with NT APIs.

    BOOL GetAclSizeInfo(
        PDWORD pdwBytesInUse,
        PDWORD pdwBytesFree
        );

    void Dump();
};

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  Helper for converting between absolute and relative SDs.
//
//***************************************************************************

struct SNtAbsoluteSD
{
    PSECURITY_DESCRIPTOR m_pSD;

    PACL m_pDacl;
    PACL m_pSacl;
    PSID m_pOwner;
    PSID m_pPrimaryGroup;

    SNtAbsoluteSD();
   ~SNtAbsoluteSD();
};

//***************************************************************************
//
//  CNtSecurityDescriptor
//
//  Models an NT Security Descriptor.  Note that in order to use this for an
//  AccessCheck, the DACL, owner sid, and group sid must be set!
//
//***************************************************************************

class CNtSecurityDescriptor
{
    PSECURITY_DESCRIPTOR m_pSD;
    int m_dwStatus;


public:
    enum { NoError, NullSD, Failed, InvalidSD, SDOwned, SDNotOwned };

    CNtSecurityDescriptor();

    CNtSecurityDescriptor(
        PSECURITY_DESCRIPTOR pSD,
        BOOL bAcquire = FALSE
        );

    CNtSecurityDescriptor(CNtSecurityDescriptor &Src);
    CNtSecurityDescriptor & operator=(CNtSecurityDescriptor &Src);

    ~CNtSecurityDescriptor();

    SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy();
    BOOL SetFromAbsoluteCopy(SNtAbsoluteSD *pSrc);

    int HasOwner();

    BOOL IsValid() { return(m_pSD && IsValidSecurityDescriptor(m_pSD)); }
        // Checks the validity of the embedded security descriptor&

    DWORD GetStatus() { return m_dwStatus; }
        // Returns one of the enumerated types.

    CNtAcl *GetDacl();
        // Deallocate with operator delete

    BOOL GetDacl(CNtAcl &DestAcl);
        // Retrieve into an existing object

    BOOL SetDacl(CNtAcl *pSrc);

    CNtAcl *GetSacl();
        // Deallocate with operator delete

    BOOL SetSacl(CNtAcl *pSrc);

    CNtSid *GetOwner();
    BOOL SetOwner(CNtSid *pSid);

    CNtSid *GetGroup();
    BOOL SetGroup(CNtSid *pSid);

    PSECURITY_DESCRIPTOR GetPtr() { return m_pSD; }
        // Returns the internal pointer for interface with NT APIs

    DWORD GetSize();

    void Dump();
};

//***************************************************************************
//
//  CNtSecurity
//
//  General-purpose NT security helpers.
//
//***************************************************************************

class CNtSecurity
{
public:
    enum { NoError, InternalFailure, NotFound, InvalidName, AccessDenied = 5, NoSecurity,
           Failed };

    static BOOL DumpPrivileges();

    static BOOL SetPrivilege(
        IN TCHAR *pszPrivilegeName,     // An SE_ value.
        IN BOOL  bEnable               // TRUE=enable, FALSE=disable
        );

    static BOOL GetFileSD(
        IN TCHAR *pszFile,
        IN SECURITY_INFORMATION SecInfo,
        OUT CNtSecurityDescriptor **pSD
        );

    static BOOL SetFileSD(
        IN TCHAR *pszFile,
        IN SECURITY_INFORMATION SecInfo,
        IN CNtSecurityDescriptor *pSD
        );

    static int GetRegSD(
        IN HKEY hRoot,
        IN TCHAR *pszSubKey,
        IN SECURITY_INFORMATION SecInfo,
        OUT CNtSecurityDescriptor **pSD
        );

    static int SetRegSD(
        IN HKEY hRoot,
        IN TCHAR *pszSubKey,
        IN SECURITY_INFORMATION SecInfo,
        IN CNtSecurityDescriptor *pSD
        );


/*    static int GetDCName(
        IN  LPWSTR   pszDomain,
        OUT LPWSTR *pszDC,
        IN  LPWSTR   pszServer
        );*/

    static BOOL IsUserInGroup(
        HANDLE hClientToken,
        CNtSid & Sid
        );

    static DWORD AccessCheck(
        HANDLE hAccessToken,
        ACCESS_MASK RequiredAccess,
        CNtSecurityDescriptor *pSD
        );  // TBD

    static CNtSid *GetCurrentThreadSid(); // TBD

    static bool DoesLocalGroupExist(LPWSTR pwszGroup, LPWSTR pwszMachine);
    static bool AddLocalGroup(LPWSTR pwszGroupName, LPWSTR pwszGroupDescription);
};

BOOL FIsRunningAsService(VOID);
BOOL SetObjectAccess2(HANDLE hObj);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\testmods.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



// *****************************************************
//
//  Testmods.cpp
//
// *****************************************************

#include "precomp.h"
#include <comutil.h>
#include <reposit.h>
#include <time.h>
#include <stdio.h>
#include <wbemcli.h>
#include <testmods.h>
#include <wbemint.h>
#include <flexarry.h>
#include <wstring.h>
#include <winntsec.h>

#define TESTMOD_NOTIF L"TESTMOD_NOTIF" 

int TestSuiteStressTest::iRunning = 0;

int __cdecl IsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

int __cdecl IsWinMgmt(void)
{
    return FALSE;
}

int GetDiff(SYSTEMTIME tEnd, SYSTEMTIME tStart)
{
    int iRet = 0;

    __int64 iTemp = (tEnd.wDay * 1000000000) +
                    (tEnd.wHour * 10000000) +
                    (tEnd.wMinute * 100000) +
                    (tEnd.wSecond * 1000) +
                    tEnd.wMilliseconds;
    iTemp -= ((tStart.wDay * 1000000000) +
                    (tStart.wHour * 10000000) +
                    (tStart.wMinute * 100000) +
                    (tStart.wSecond * 1000) +
                    tStart.wMilliseconds);

    iRet = (int) iTemp;

    return iRet;
}

// *****************************************************

HRESULT SetBoolQfr(IWbemClassObject *pObj, LPWSTR lpPropName, LPWSTR lpQfrName)
{
    HRESULT hr;
    VARIANT vTemp;
    VariantInit(&vTemp);

    IWbemQualifierSet *pQS = NULL;
    hr = pObj->GetPropertyQualifierSet(lpPropName, &pQS);
    if (SUCCEEDED(hr))
    {
        vTemp.boolVal = true;
        vTemp.vt = VT_BOOL;
        hr = pQS->Put(lpQfrName, &vTemp, 3);
        VariantClear(&vTemp);
        pQS->Release();
    }
    return hr;
}

// *****************************************************

HRESULT SetAsKey(IWbemClassObject *pObj, LPWSTR lpPropName)
{
    HRESULT hr;
    hr = SetBoolQfr(pObj, lpPropName, L"key");
    return hr;
}

// *****************************************************

HRESULT SetStringProp(IWbemClassObject *pObj, LPWSTR lpPropName, LPWSTR lpValue, BOOL bKey, CIMTYPE ct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vTemp;
    VariantInit(&vTemp);
    vTemp.bstrVal = SysAllocString(lpValue);
    vTemp.vt = VT_BSTR;
    hr = pObj->Put(lpPropName, 0, &vTemp, ct);
    VariantClear(&vTemp);

    if (SUCCEEDED(hr) && bKey)
        hr = SetAsKey(pObj, lpPropName);

    return hr;
}
// *****************************************************

HRESULT SetIntProp(IWbemClassObject *pObj, LPWSTR lpPropName, DWORD dwValue, BOOL bKey, CIMTYPE ct)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vTemp;
    VariantInit(&vTemp);

    switch(ct)
    {
    case CIM_BOOLEAN:
        V_BOOL(&vTemp) = (BOOL)dwValue;
        vTemp.vt = VT_BOOL;
        break;
    case CIM_SINT8:
    case CIM_UINT8:
    case CIM_CHAR16:
        V_UI1(&vTemp) = (unsigned char)dwValue;
        vTemp.vt = VT_UI1;
        break;
    case CIM_SINT16:
        V_I2(&vTemp) = (short)dwValue;
        vTemp.vt = VT_I2;
        break;
    case CIM_UINT16:
    case CIM_SINT32:
    case CIM_UINT32:
        V_I4(&vTemp) = dwValue;
        vTemp.vt = VT_I4;
        break;
    default:
        vTemp.vt = VT_NULL;
        break;
    }
    hr = pObj->Put(lpPropName, 0, &vTemp, ct);
    VariantClear(&vTemp);

    if (SUCCEEDED(hr) && bKey)
        hr = SetAsKey(pObj, lpPropName);

    return hr;
}
// *****************************************************

DWORD GetNumericValue (IWbemClassObject *pObj, LPWSTR lpPropName)
{
    DWORD dwRet = 0;
    VARIANT vTemp;
    VariantInit(&vTemp);

    HRESULT hr = pObj->Get(lpPropName, 0, &vTemp, NULL, NULL);
    if (SUCCEEDED(hr))
        dwRet = vTemp.lVal;
    VariantClear(&vTemp);
    return dwRet;
}
// *****************************************************

_bstr_t GetStringValue (IWbemClassObject *pObj, LPWSTR lpPropName)
{
    _bstr_t sRet;
    VARIANT vTemp;
    VariantInit(&vTemp);

    HRESULT hr = pObj->Get(lpPropName, 0, &vTemp, NULL, NULL);
    if (SUCCEEDED(hr) && vTemp.vt == VT_BSTR)
        sRet = vTemp.bstrVal;
    else
        sRet = L"";
    VariantClear(&vTemp);
    return sRet;
}
// *****************************************************

HRESULT ValidateProperty(IWbemClassObject *pObj, LPWSTR lpPropName, CIMTYPE cimtype, VARIANT *vDefault)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vTemp;
    CIMTYPE ct;
    VariantInit(&vTemp);

    hr = pObj->Get(lpPropName, 0, &vTemp, &ct, NULL);
    if (SUCCEEDED(hr))
    {
        if (vDefault == NULL)
        {
            if (vTemp.vt != VT_NULL)
                hr = WBEM_E_FAILED;
        }
        else if (cimtype != ct)
            hr = WBEM_E_TYPE_MISMATCH;
        else 
        {
            // FIXME: Deal with arrays!!!

            if (vDefault->vt == VT_I4)
            {
                switch(vTemp.vt)
                {
                case VT_I4:
                    if (V_I4(&vTemp) != V_I4(vDefault))
                        hr = WBEM_E_FAILED;
                    break;
                case VT_I2:
                    if (V_I2(&vTemp) != V_I4(vDefault))
                        hr = WBEM_E_FAILED;
                    break;
                case VT_UI1:
                    if (V_UI1(&vTemp) != V_I4(vDefault))
                        hr = WBEM_E_FAILED;
                    break;
                case VT_BOOL:
                    if ((!V_BOOL(&vTemp)) != (!V_I4(vDefault)))
                        hr = WBEM_E_FAILED;
                    break;
                case VT_R4:
                    if (V_R4(&vTemp) != V_I4(vDefault))
                        hr = WBEM_E_FAILED;
                    break;
                case VT_R8:
                    if (V_R8(&vTemp) != V_I4(vDefault))
                        hr = WBEM_E_FAILED;
                    break;
                default:
                    hr = WBEM_E_FAILED;
                    break;
                }
            }
            else if (vDefault->vt == VT_BSTR)
            {
                if (_wcsicmp(vDefault->bstrVal,vTemp.bstrVal))
                    hr = WBEM_E_FAILED;
            }
        }
    }

    VariantClear(&vTemp);

    return hr;
}
// *****************************************************

HRESULT ValidateProperty(IWbemClassObject *pObj, LPWSTR lpPropName, CIMTYPE cimtype, DWORD dwVal)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT vTemp;
    VariantInit(&vTemp);

    V_I4(&vTemp) = dwVal;
    vTemp.vt = VT_I4;

    hr = ValidateProperty(pObj, lpPropName, cimtype, &vTemp);

    VariantClear(&vTemp);
    return hr;
}
// *****************************************************

HRESULT ValidateProperty(IWbemClassObject *pObj, LPWSTR lpPropName, CIMTYPE cimtype, LPWSTR lpVal)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT vTemp;
    VariantInit(&vTemp);

    V_BSTR(&vTemp) = SysAllocString(lpVal);
    vTemp.vt = VT_BSTR;

    hr = ValidateProperty(pObj, lpPropName, cimtype, &vTemp);

    VariantClear(&vTemp);
    return hr;
}

// *****************************************************
//
//  SuiteManager
//
// *****************************************************

HRESULT SuiteManager::RunSuite(int iSuiteNum, IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i =0;

    switch(iSuiteNum)
    {
    case SUITE_FUNC:
        dwTotalSuites++;
        hr = ppSuites[0]->RunSuite(pSession, pController, pScope);
        dwNumSuccess = ppSuites[0]->GetNumSuccess();
        dwNumFailed = ppSuites[0]->GetNumFailed();
        dwNumRun = ppSuites[0]->GetNumRun();
        break;
    case SUITE_ERR:
        dwTotalSuites++;
        hr = ppSuites[2]->RunSuite(pSession, pController, pScope);
        dwNumSuccess = ppSuites[1]->GetNumSuccess();
        dwNumFailed = ppSuites[1]->GetNumFailed();
        dwNumRun = ppSuites[1]->GetNumRun();
        break;
    case SUITE_STRESS:
        dwTotalSuites++;
        hr = ppSuites[1]->RunSuite(pSession, pController, pScope);
        dwNumSuccess = ppSuites[2]->GetNumSuccess();
        dwNumFailed = ppSuites[2]->GetNumFailed();
        dwNumRun = ppSuites[2]->GetNumRun();
        break;
    case SUITE_CUST:
        dwTotalSuites++;
        hr = ppSuites[3]->RunSuite(pSession, pController, pScope);
        dwNumSuccess = ppSuites[2]->GetNumSuccess();
        dwNumFailed = ppSuites[2]->GetNumFailed();
        dwNumRun = ppSuites[2]->GetNumRun();      
        break;
    case SUITE_ALL:
        for (i = 0; i < NUM_INITIAL_SUITES; i++)
        {
            pController->FlushCache(0);
            dwTotalSuites++;
            hr = ppSuites[i]->RunSuite(pSession, pController, pScope);
            dwNumSuccess += ppSuites[i]->GetNumSuccess();
            dwNumFailed += ppSuites[i]->GetNumFailed();
            dwNumRun += ppSuites[i]->GetNumRun();
            if (FAILED(hr))
            {
                if (ppSuites[i]->StopOnFailure())
                   break;
            }
        }
        break;
    default:
        hr = WBEM_E_INVALID_PARAMETER;
        break;
    }

    return hr;
}
// *****************************************************

void SuiteManager::DumpResults(BOOL bDetail)
{    
    dwNumRun = 0;
    dwNumSuccess = 0;
    dwNumFailed = 0;

    printf("*********************************\n");
    printf("*        R E S U L T S          *\n");
    printf("*********************************\n");

    for (int i = 0; i < NUM_INITIAL_SUITES; i++)
    {
        dwNumRun += ppSuites[i]->GetNumRun();
        dwNumSuccess += ppSuites[i]->GetNumSuccess();
        dwNumFailed += ppSuites[i]->GetNumFailed();
    }
    printf("*********************************\n\n");
    printf("* Suites Run            %ld      \n", dwTotalSuites);
    printf("* Scenarios Run         %ld      \n", dwNumRun);
    printf("* Succeeded             %ld      \n", dwNumSuccess);
    printf("* Failed                %ld      \n", dwNumFailed);
    if (dwNumRun)
        printf("* Pass Rate             %lG      \n", ((float)dwNumSuccess/(float)dwNumRun)*100);
        
    printf("*********************************\n\n");
}

SuiteManager::SuiteManager(const wchar_t *pszFileName, const wchar_t *pszLogon, int nMaxThreads, int nMaxDepth, int nMaxNumObjs)
{
    iMaxThreads = nMaxThreads;
    iMaxDepth = nMaxDepth;
    iMaxNumObjs = nMaxNumObjs;
    dwTotalSuites = 0;
    dwNumRun = 0;
    dwNumSuccess = 0;
    dwNumFailed = 0;
    tStartTime = 0;
    tEndTime = 0;
    ppSuites = (TestSuite **) new TestSuite *[NUM_INITIAL_SUITES];
    ppSuites[0] = new TestSuiteFunctionality(pszFileName, pszLogon);
    ppSuites[1] = new TestSuiteStressTest(pszFileName, nMaxDepth, nMaxNumObjs, nMaxThreads);
    ppSuites[2] = new TestSuiteErrorTest(pszFileName, nMaxThreads);
    ppSuites[3] = new TestSuiteCustRepDrvr(pszFileName);

}

SuiteManager::~SuiteManager()
{
    //for (int i = 0; i < NUM_INITIAL_SUITES; i++)
        //delete ppSuites[i];
    delete ppSuites;
}

// *****************************************************
//
//  StatData
//
// *****************************************************

StatData::StatData()
{
    pNext = NULL;
    hrErrorCode = 0;
}

StatData::~StatData()
{
}
// *****************************************************

void StatData::PrintData()
{

    wprintf(L"* %d:%d:%d.%d - %s\n",
        EndTime.wHour,
        EndTime.wMinute,
        EndTime.wSecond,
        EndTime.wMilliseconds,
        (const wchar_t *)szDescription);

    wprintf(L"  %s with error code %X [Duration = %ld ms]\n",
        (SUCCEEDED(hrErrorCode) ? L"succeeded" : L"FAILED"),
        hrErrorCode, dwDuration);

    if (pNext)
        pNext->PrintData();
}

// *****************************************************
//
//  TestSuite
//
// *****************************************************

void TestSuite::DumpResults()
{
    printf("*********************************\n");
    if (pStats)
        pStats->PrintData();
}
// *****************************************************

TestSuite::TestSuite(const wchar_t *pszFileName)
{
    hMajorResult = WBEM_S_NO_ERROR;
    sResult = L"";
    pStats = NULL;
    pEndStat = NULL;
    dwNumSuccess = 0;
    dwNumFailed = 0;
    dwNumRun = 0;

    sprintf(szFileName, "%S", pszFileName);
}
// *****************************************************

TestSuite::~TestSuite()
{
    delete pStats;
}
// *****************************************************

BOOL TestSuite::RecordResult(HRESULT hrInput, const wchar_t *pszDetails, long lMilliseconds, ...)
{
    BOOL bRet = TRUE;
    wchar_t wMsg[1024];
    va_list argptr;

    va_start(argptr, lMilliseconds);
    vswprintf(wMsg, pszDetails, argptr);
    va_end(argptr);

    if (FAILED(hrInput))
    {
        wprintf(L"ERROR: * %s FAILED (%X)\n", wMsg, hrInput);
    }

    if (strlen(szFileName))
    {
        FILE *fp = fopen(szFileName, "ab");
        if (fp)
        {
            SYSTEMTIME EndTime;
            GetLocalTime(&EndTime);
            fprintf(fp, "* %d:%d:%d.%d - %S\r\n",
                EndTime.wHour,
                EndTime.wMinute,
                EndTime.wSecond,
                EndTime.wMilliseconds,
                (const wchar_t *)wMsg);

            fprintf(fp, "  %s with error code %X [Duration = %ld ms]\r\n",
                (SUCCEEDED(hrInput) ? "succeeded" : "FAILED"),
                hrInput, lMilliseconds);
            fclose(fp);
        }
    }

    if (SUCCEEDED(hrInput))
        dwNumSuccess++;
    else
        dwNumFailed++;
    dwNumRun++;

    return bRet;
}
// *****************************************************

HRESULT TestSuite::GetObject(IWmiDbHandle *pScope, LPWSTR lpObjName, DWORD dwHandleType, DWORD dwNumObjects, 
                  IWmiDbHandle **pHandle, IWbemClassObject **pObj, LPWSTR lpParent)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemPath *pPath = NULL;

    *pObj =NULL;
    *pHandle = NULL;

    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
        IID_IWbemPath, (void **)&pPath); 

    if (SUCCEEDED(hr))
    {
        hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpObjName);

        hr = pSession->GetObject(pScope, pPath, 0, dwHandleType, pHandle);

        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pTemp = *pHandle;
            hr = pTemp->QueryInterface(IID_IWbemClassObject, (void **)pObj);           
            if (SUCCEEDED(hr))
            {
                // Verify the object.  Make sure it contains the
                // properties that were created - no more, no less.

                if (dwNumObjects != (DWORD)-1)
                {
                    DWORD dwRet = GetNumericValue(*pObj, L"__Property_Count");
                    if (dwRet != dwNumObjects)
                        hr = WBEM_E_INVALID_OBJECT;
                }

                _bstr_t sRet = GetStringValue(*pObj, L"__Namespace");
                if (!sRet.length())
                    hr = WBEM_E_INVALID_NAMESPACE;   

                if (lpParent != NULL)
                {
                    sRet = GetStringValue(*pObj, L"__SuperClass");
                    if (_wcsicmp(lpParent, sRet))
                        hr = WBEM_E_INVALID_SUPERCLASS;
                }
            }
        }
        pPath->Release();
    }
    else
        wprintf(L"WARNING: call failed to CoCreateInstance (IID_IWbemPath).\n");

    if (FAILED(hr))
    {
        if (*pHandle) (*pHandle)->Release();
        if (*pObj) (*pObj)->Release();
    }
    return hr;
}


// *****************************************************
//
//  TestSuiteFunctionality
//
// *****************************************************

BOOL TestSuiteFunctionality::StopOnFailure()
{
    return TRUE;
}

// *****************************************************

HRESULT TestSuiteFunctionality::RunSuite(IWmiDbSession *_pSession, IWmiDbController *_pController, IWmiDbHandle *_pScope)
{
    wprintf(L" *** Functionality Suite running... *** \n");
    RecordResult(0, L" *** Functionality Suite running... *** \n", 0);

    HRESULT hr = 0;
    pSession = _pSession;
    pController = _pController;
    pScope = _pScope;

    try {
        ValidateAPIs();
    }
    catch (...) {
        RecordResult(WBEM_E_FAILED, L"Caught an exception while validating APIs", 0);

    }

    try {
        hr = CreateObjects();   // If we can't create objects, fail.
    }
    
    catch (...)
    {
        RecordResult(WBEM_E_FAILED, L"Caught an exception while creating objects.", 0);
        goto Exit;
    }
    
    if (SUCCEEDED(hr))
    {
        try {
            hr = GetObjects();  // If we can't retrieve objects, fail.
        }
        
        catch (...)
        {
            RecordResult(WBEM_E_FAILED, L"Caught an exception while retrieving objects.", 0);
            hr = WBEM_E_FAILED;
            goto Exit;
        }
        
        if (SUCCEEDED(hr))
        {
            try {
                HandleTypes();
            }
            catch (...)
            {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing handle types.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                VerifyCIMClasses();
            }
            catch (...){
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing CIM class types.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                VerifyCIMTypes();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing CIM property types.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                VerifyMethods();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while verifying methods.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                UpdateObjects();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while updating objects.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                ChangeHierarchy();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing hierarchy changes.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                VerifyContainers();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing containers.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                Security();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing security.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            try {
                VerifyTransactions();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing transactions.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            if (Interfaces[IWmiDbBatchSession_pos])
            {
                try {
                    Batch();
                }
                catch (...) {
                    RecordResult(WBEM_E_FAILED, L"Caught an exception while testing batch operations.", 0);
                    hr = WBEM_E_FAILED;
                    goto Exit;
                }
            }
            
            try {
                DeleteObjects();
            }
            catch (...) {
                RecordResult(WBEM_E_FAILED, L"Caught an exception while testing deletes.", 0);
                hr = WBEM_E_FAILED;
                goto Exit;
            }

            if (Interfaces[IWbemQuery_pos])
            {
                try {
                    Query();
                }
                catch (...) {
                    RecordResult(WBEM_E_FAILED, L"Caught an exception while testing queries.", 0);
                    hr = WBEM_E_FAILED;
                    goto Exit;
                }
            }
        }
    }

Exit:

    return hr;
}


// *****************************************************
TestSuiteFunctionality::TestSuiteFunctionality(const wchar_t *pszFile, const wchar_t *pszLogon)
: TestSuite(pszFile)
{
    sLogon = pszLogon;
}

// *****************************************************
TestSuiteFunctionality::~TestSuiteFunctionality()
{
}

// *****************************************************
HRESULT TestSuiteFunctionality::ValidateAPIs()
{
    HRESULT hr;
    SYSTEMTIME tStartTime, tEndTime;
    DWORD dwResult = 0;

    // Make sure all the required interfaces are supported.
    // These are: IWmiDbController, IWmiDbSession, IWmiDbHandle, IWmiBinaryObjectPath,
    //    IWmiDbBatchSession, IWmiDbIterator
    // Since the first four have already been proven if we have gotten to this point,
    //    so just try the others.

    IWmiDbBatchSession *pBatch= NULL;
    hr = pSession->QueryInterface(IID_IWmiDbBatchSession, (void **)&pBatch);
    RecordResult(hr, L"Supports IWmiDbBatchSession", 0);
    if (SUCCEEDED(hr))
    {
        Interfaces[IWmiDbBatchSession_pos] = TRUE;
        pBatch->Release();
    }
    else
        Interfaces[IWmiDbBatchSession_pos] = FALSE;

    IWbemQuery *pQuery = NULL;
    hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
    RecordResult(hr, L"Supports IWbemQuery", 0);

    if (SUCCEEDED(hr))
    {
        Interfaces[IWbemQuery_pos] = TRUE;
        IWmiDbIterator *pIterator = NULL;
        wchar_t szTmp[100];
        wcscpy(szTmp, L"select * from __Namespace"); // This has got to be supported...
        pQuery->Parse(L"SQL", szTmp, 0);

        GetLocalTime(&tStartTime);
        hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIterator);
        GetLocalTime(&tEndTime);
        if (SUCCEEDED(hr))
        {
            if (pIterator != NULL)
            {
                RecordResult(WBEM_S_NO_ERROR, L"Supports IWmiDbIterator", 0);
                Interfaces[IWmiDbIterator_pos] = TRUE;
                pIterator->Release();
            }
            else
            {
                Interfaces[IWmiDbIterator_pos] = FALSE;
                RecordResult(WBEM_E_NOT_FOUND, L"Supports IWmiDbIterator", 0);
            }
        }
        pQuery->Release();
        RecordResult(hr, L"Execute query: 'select * from __Namespace'", GetDiff(tEndTime,tStartTime));
    }
    else
    {
        Interfaces[IWbemQuery_pos] = FALSE;
        Interfaces[IWmiDbIterator_pos] = FALSE;
    }
 
    // Check the optional APIs

    RecordResult(pController->SetCallTimeout(30000), L"IWmiDbController::SetCallTimeout 30 secs. ", 0);
    RecordResult(pController->GetStatistics(WMIDB_FLAG_TOTAL_HANDLES, &dwResult), L"IWmiDbController::GetStatistics (Total Handles)", 0);
    RecordResult(pController->GetStatistics(WMIDB_FLAG_CACHE_SATURATION, &dwResult), L"IWmiDbController::GetStatistics (Cache Saturation)", 0);
    RecordResult(pController->GetStatistics(WMIDB_FLAG_CACHE_HIT_RATE, &dwResult), L"IWmiDbController::GetStatistics (Cache Hit Rate)", 0);

    // Set decoration.
    RecordResult(pSession->SetDecoration(L"MACHINE1", L"root\\default"), L"IWmiDbSession::SetDecoration (Machine1, root\\default)", 0);
      
    return WBEM_S_NO_ERROR;  // We are only testing non-essential interfaces here.
}

// *****************************************************
HRESULT TestSuiteFunctionality::CreateObjects()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    VARIANT vClass;
    VariantInit(&vClass);

    // Everything needs to be scoped to pScope!
    // We should only fail this call if a *major* piece of functionality does not work.
    // If the flag doesn't work, oh well.

    IWbemClassObject *pParentClass = NULL;
    IWmiDbHandle *pParentHandle = NULL;

    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pParentClass);

    if (SUCCEEDED(hr))
    {
        // class Parent1 { [key] uint32 Key1; };

        pParentClass->Put(L"Key1", 0, NULL, CIM_UINT32);
        SetAsKey(pParentClass, L"Key1");
        SetStringProp(pParentClass, L"__Class", L"Parent1");
        GetLocalTime(&tStartTime);
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pParentClass, 
            WBEM_FLAG_CREATE_OR_UPDATE, WMIDB_HANDLE_TYPE_COOKIE, &pParentHandle);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::PutObject (Parent1, Key1=uint32, cookie)", GetDiff(tEndTime,tStartTime));
        
        if (SUCCEEDED(hr))
        {
            if (!pParentHandle)
                RecordResult(WBEM_E_UNEXPECTED, L"IWmiDbSession::PutObject populating handle", 0);
            else
            {
                pParentClass->Release();
                GetLocalTime(&tStartTime);
                hr = pParentHandle->QueryInterface(IID_IWbemClassObject, (void **)&pParentClass);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"IWmiDbHandle::QueryInterface (IWbemClassObject)", GetDiff(tEndTime,tStartTime));

                // class Child1:Parent1 { [key] uint32 Key1; string Prop1;};
                
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject *pChildClass = NULL;
                    IWmiDbHandle *pChildHandle = NULL;
                    hr = pParentClass->SpawnDerivedClass(0, &pChildClass);
                    if (FAILED(hr))
                    {
                        RecordResult(hr, L"IWbemClassObject::SpawnDerivedClass", 0);
                        return hr;
                    }

                    SetStringProp(pChildClass, L"__Class", L"Child1");

                    pChildClass->Put(L"Prop1", 0, NULL, CIM_STRING);
                    GetLocalTime(&tStartTime);
                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pChildClass, 
                        WBEM_FLAG_CREATE_OR_UPDATE, WMIDB_HANDLE_TYPE_COOKIE, &pChildHandle);
                    GetLocalTime(&tEndTime);

                    RecordResult(hr, L"IWmiDbSession::PutObject (Child1:Parent1, Prop1=string, cookie)", GetDiff(tEndTime,tStartTime));
            
                    // instance of Child1 { Key1 = 1; Prop1 = "ABCDEF";};

                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pChildInstance = NULL;
                        IWmiDbHandle *pInst = NULL;

                        pChildClass->Release();
                        GetLocalTime(&tStartTime);
                        hr = pChildHandle->QueryInterface(IID_IWbemClassObject, (void **)&pChildClass);
                        GetLocalTime(&tEndTime);                        
                        RecordResult(hr, L"IWmiDbHandle::QueryInterface (IWbemClassObject)", GetDiff(tEndTime,tStartTime));

                        if (SUCCEEDED(hr))
                        {                            
                            pChildClass->SpawnInstance(0, &pChildInstance);

                            SetStringProp(pChildInstance, L"Prop1", L"ABCDEF");

                            vClass.lVal = 1;
                            vClass.vt = VT_I4;
                            hr = pChildInstance->Put(L"Key1", 0, &vClass, CIM_UINT32);
                            VariantClear(&vClass);
                            
                            GetLocalTime(&tStartTime);
                            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pChildInstance,
                                WBEM_FLAG_CREATE_ONLY, WMIDB_HANDLE_TYPE_COOKIE, &pInst);
                            GetLocalTime(&tEndTime);

                            RecordResult(hr, L"IWmiDbSession::PutObject - create_only (Child1.Key1=1)", GetDiff(tEndTime,tStartTime));
                            if (pInst)
                                pInst->Release();
                            else if (SUCCEEDED(hr))
                                RecordResult(WBEM_E_UNEXPECTED, L"IWmiDbSession::PutObject populating handle", 0);
                            pChildInstance->Release();
                        }
                    }

                    // instance of Parent1 {Key1 =2;};

                    IWbemClassObject *pParentInst = NULL;
                    IWmiDbHandle *pInst = NULL;
                    pParentClass->SpawnInstance(0, &pParentInst);
                    vClass.lVal = 2;
                    vClass.vt = VT_I4;
                    hr = pParentInst->Put(L"Key1", 0, &vClass, CIM_UINT32);
                    VariantClear(&vClass);
                    if (SUCCEEDED(hr))
                    {
                        GetLocalTime(&tStartTime);
                        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pParentInst, 
                            WBEM_FLAG_CREATE_OR_UPDATE, WMIDB_HANDLE_TYPE_COOKIE, &pInst);
                        RecordResult(hr, L"IWmiDbSession::PutObject (Parent1.Key1=2)", GetDiff(tEndTime,tStartTime));
                        if (SUCCEEDED(hr) && pInst)
                        {
                            // This seems pointless, but this makes sure we can scope
                            // to objects that are not of class __Namespace:
                            // Create a class "SubScope1", scoped to the Parent1=2

                            Sleep(1000);
                            IWbemClassObject *pScopeObj = NULL;
                            IWmiDbHandle *pScopeHandle = NULL;

                            // #pragma namespace <Child1.Key1=1>
                            // class SubScope1 { [key] uint32 Key1;};

                            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IWbemClassObject, (void **)&pScopeObj);
                            if (SUCCEEDED(hr))
                            {                            
                                pScopeObj->Put(L"Key1", 0, NULL, CIM_UINT32);

                                SetStringProp(pScopeObj, L"__Class", L"SubScope1");
                                SetAsKey(pScopeObj, L"Key1");

                                GetLocalTime(&tStartTime);
                                hr = pSession->PutObject(pInst, IID_IWbemClassObject, pScopeObj, 
                                    WBEM_FLAG_CREATE_OR_UPDATE, WMIDB_HANDLE_TYPE_COOKIE, &pScopeHandle);
                                GetLocalTime(&tEndTime);
                                RecordResult(hr, L"IWmiDbSession::PutObject (Parent1=2:SubScope1, Key1=uint32, cookie)", GetDiff(tEndTime,tStartTime));

                                // instance of SubScope1 {Key1 = 1;};

                                if (pScopeHandle)
                                {
                                    pScopeObj->Release();
                                    pScopeHandle->QueryInterface(IID_IWbemClassObject, (void **)&pScopeObj);
                                    if (pScopeObj)
                                    {
                                        IWbemClassObject *pScopeInst = NULL;
                                        IWmiDbHandle *pScopeInstHandle = NULL;

                                        pScopeObj->SpawnInstance(0, &pScopeInst);
                                        if (pScopeInst)
                                        {
                                            vClass.lVal = 1;
                                            vClass.vt = VT_I4;
                                            pScopeInst->Put(L"Key1", 0, &vClass, CIM_UINT32);
                                            VariantClear(&vClass);

                                            GetLocalTime(&tStartTime);
                                            hr = pSession->PutObject(pInst, IID_IWbemClassObject, pScopeInst,
                                                WBEM_FLAG_CREATE_OR_UPDATE, WMIDB_HANDLE_TYPE_COOKIE, &pScopeInstHandle);
                                            GetLocalTime(&tEndTime);

                                            RecordResult(hr, L"IWmiDbSession::PutObject (Parent1=2:SubScope1.Key1=1)", GetDiff(tEndTime,tStartTime));
                                            if (pScopeInstHandle)
                                                pScopeInstHandle->Release();
                                            pScopeInst->Release();
                                        }

                                        // class SubScope2: SubScope1 {[key] uint32 Key1; string Prop1;};

                                        IWbemClassObject *pScopeObj2 = NULL;
                                        IWmiDbHandle *pScope2Handle = NULL;

                                        pScopeObj->SpawnDerivedClass(0, &pScopeObj2);
                                        if (pScopeObj2)
                                        {
                                            pScopeObj2->Put(L"Prop1", 0, NULL, CIM_STRING);
                                            SetStringProp(pScopeObj2, L"__Class", L"SubScope2");
                                            GetLocalTime(&tStartTime);
                                            hr = pSession->PutObject(pInst, IID_IWbemClassObject, pScopeObj2,
                                                WBEM_FLAG_CREATE_OR_UPDATE, WMIDB_HANDLE_TYPE_COOKIE, &pScope2Handle);
                                            GetLocalTime(&tEndTime);
                                            RecordResult(hr, L"IWmiDbSession::PutObject (SubScope2:SubScope1)", GetDiff(tEndTime,tStartTime));

                                            if (pScope2Handle)
                                                pScope2Handle->Release();
                                            pScopeObj2->Release();
                                        }
                                    }

                                    pScopeHandle->Release();
                                }
                                pScopeObj->Release();
                            }
                         
                            pInst->Release();
                        }                    
                    }
                    
                    pParentInst->Release();
                    if (pChildClass)
                        pChildClass->Release();
                    if (pChildHandle)
                        pChildHandle->Release();

                }
            }

            hr = WBEM_S_NO_ERROR; // nothing else is fatal
        }

        pParentClass->Release();
        if(pParentHandle)
            pParentHandle->Release();

    }
    
    return hr;

}

// *****************************************************
HRESULT TestSuiteFunctionality::GetObjects()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    BOOL bFatal = FALSE;

    // Retrieve and verify the objects we already created.
    // Failing Parent1, Child1 or the instances is fatal.
    
    // class Parent1 { [key] uint32 Key1; };

    IWbemClassObject *pObj = NULL;
    IWmiDbHandle *pHandle = NULL;

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (Parent1) - cookie", GetDiff(tEndTime,tStartTime));

    if (pObj)
        RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, (VARIANT *)NULL), L"Validating Parent1.Key1", 0);
    else
        bFatal = TRUE;

    // Make sure they have the same IUnknown pointers
    // We perform this test only once.
    //if (pHandle != NULL && pObj != NULL)
    //    RecordResult(((IUnknown *)pObj == (IUnknown *)pHandle)?0:WBEM_E_TYPE_MISMATCH, L"IWbemClassObject and IWmiDbHandle have same IUnknown pointers", 0);            

    if (pObj) pObj->Release();
    if (pHandle) pHandle->Release();

    // class Child1:Parent1 { [key] uint32 Key1; string Prop1;};

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"Child1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pHandle, &pObj, L"Parent1");
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (Child1) - cookie", GetDiff(tEndTime,tStartTime));

    if (SUCCEEDED(hr))
    {
        RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, (VARIANT *)NULL), L"Validating Child1.Key1", 0);
        RecordResult(ValidateProperty(pObj, L"Prop1", CIM_STRING, (VARIANT *)NULL), L"Validating Child.Prop1", 0);

        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();
    }
    else
        bFatal = TRUE;
   
    // instance of Parent1 {Key1 =2;};
    
    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"Parent1=2", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (Parent1=2) - cookie", GetDiff(tEndTime,tStartTime));

    IWmiDbHandle *pInstHandle = NULL;
    if (SUCCEEDED(hr))
    {
        RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, 2), L"Validating Parent1=2.Key1", 0);
        if (pObj) pObj->Release();
        pInstHandle = pHandle;// save it, this is our scope!
    }
    else
        bFatal = TRUE;
  
    // instance of Child1 { Key1 = 1; Prop1 = "ABCDEF";};
    
    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"Child1=1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pHandle, &pObj, L"Parent1");
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (Child1=1) - cookie", GetDiff(tEndTime,tStartTime));

    if (SUCCEEDED(hr))
    {
        RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, 1), L"Validating Child1.Key1=1", 0);
        RecordResult(ValidateProperty(pObj, L"Prop1", CIM_STRING, L"ABCDEF"), L"Validating Child1=1.Prop1", 0);
        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();
    }

    // instance of Child1 { Key1 = 1};

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"Parent1=1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pHandle, &pObj, L"Parent1");
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (Parent1=1) - specifying parent class", GetDiff(tEndTime,tStartTime));

    if (SUCCEEDED(hr))
    {
        RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, 1), L"Validating Child1.Key1=1", 0);
        RecordResult(ValidateProperty(pObj, L"Prop1", CIM_STRING, L"ABCDEF"), L"Validating Child1=1.Prop1", 0);
        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();
    }    

    // Full path (including all scopes)

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"\\\\.\\root\\default\\test:Parent1=2:SubScope1=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (test:Parent1=2:SubScope1=1) - cookie", GetDiff(tEndTime,tStartTime));

    if (SUCCEEDED(hr))
    {
        if (pHandle) pHandle->Release();
        if (pObj) pObj->Release();
    }
  
    // Full path (including all scopes)

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"\\\\.\\root\\default\\test", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"GetObject (\\\\.\\root\\default\\test) - cookie", GetDiff(tEndTime,tStartTime));

    if (SUCCEEDED(hr))
    {
        if (pHandle) pHandle->Release();
        if (pObj) pObj->Release();
    }

    if (pInstHandle)
    {
        // class SubScope1 { [key] uint32 Key1;};

        GetLocalTime(&tStartTime);
        hr = GetObject(pInstHandle, L"SubScope1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"GetObject (SubScope1) - cookie", GetDiff(tEndTime,tStartTime));

        if (pObj)
            RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, (VARIANT *)NULL), L"Validating SubScope1.Key1", 0);

        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();

        // class SubScope2: SubScope1 {[key] uint32 Key1; string Prop1;};

        GetLocalTime(&tStartTime);
        hr = GetObject(pInstHandle, L"SubScope2", WMIDB_HANDLE_TYPE_COOKIE, 2, &pHandle, &pObj, L"SubScope1");
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"GetObject (SubScope2) - cookie", GetDiff(tEndTime,tStartTime));

        if (pObj)
        {
            RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, (VARIANT *)NULL), L"Validating SubScope2.Key1", 0);
            RecordResult(ValidateProperty(pObj, L"Prop1", CIM_STRING, (VARIANT *)NULL), L"Validating SubScope2.Prop1", 0);
        }

        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();

        // instance of SubScope1 {Key1 = 1;};

        GetLocalTime(&tStartTime);
        hr = GetObject(pInstHandle, L"SubScope1=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"GetObject (SubScope1=1) - cookie", GetDiff(tEndTime,tStartTime));

        if (pObj)
            RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, 1), L"Validating SubScope1.Key1=1", 0);

        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();

        GetLocalTime(&tStartTime);
        hr = GetObject(pInstHandle, L"..", WMIDB_HANDLE_TYPE_COOKIE, -1, &pHandle, &pObj);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"GetObject (..) - cookie", GetDiff(tEndTime, tStartTime));

        if (pObj) pObj->Release();
        if (pHandle) pHandle->Release();

        pInstHandle->Release();
    }

    // Changing the decoration from \\MACHINE1\root\default to \\MACHINE2\root\test should cause no error...

    RecordResult(pSession->SetDecoration(L"MACHINE2", L"root\\test"), L"IWmiDbSession::SetDecoration (Machine2, root\\test)", 0);
    
    hr = pScope->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
    if (SUCCEEDED(hr))
    {
        _IWmiObject *pInt = NULL;
        hr = pObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
        pObj->Release();
        if (SUCCEEDED(hr))
        {
            hr = pInt->SetDecoration(L"MACHINE2", L"root\\test");
            RecordResult(hr, L"_IWmiObject::SetDecoration (root object)", 0);
            pInt->Release();

            RecordResult(GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj), 
                L"IWmiDbSession::GetObject (changed decoration)", 0);
        }        
    }

    if (pHandle) pHandle->Release();
    if (pObj)
    {
        // Ensure that the decoration is what we asked for.
        RecordResult(!_wcsicmp(GetStringValue(pObj, L"__Namespace"), L"root\\test\\test")?WBEM_S_NO_ERROR:WBEM_E_FAILED,
            L"IWmiDbSession::SetDecoration properly decorates namespace.", 0);
        RecordResult(!_wcsicmp(GetStringValue(pObj, L"__Server"), L"MACHINE2")?WBEM_S_NO_ERROR:WBEM_E_FAILED,
            L"IWmiDbSession::SetDecoration properly decorates server name.", 0);

        pObj->Release();
    }

    if (bFatal)
        hr = WBEM_E_FAILED;
    else
        hr = WBEM_S_NO_ERROR;

    return hr;

}

// *****************************************************
HRESULT TestSuiteFunctionality::HandleTypes()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    // Try all the different handle types.
    // Cookie, versioned, exclusive, protected.| subscoped
    // no_caching, strong caching, weak caching

    // Caching we can't verify, but at least we can find out
    // if we get an error when we try to use it...

    IWmiDbHandle *pHandle = NULL;
    IWbemClassObject *pObj = NULL;
    IWbemPath *pPath = NULL;
    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
        IID_IWbemPath, (void **)&pPath); 
    if (SUCCEEDED(hr))
    {
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=2");
        GetLocalTime(&tStartTime);
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_NO_CACHE, &pHandle);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) no cache", GetDiff(tEndTime,tStartTime));
        if (SUCCEEDED(hr))
            pHandle->Release();

        GetLocalTime(&tStartTime);
        hr = pSession->GetObjectDirect(pScope, pPath, 0, IID_IWbemClassObject, (void **)&pObj);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::GetObjectDirect (Parent1=2) ", GetDiff(tEndTime,tStartTime));
        if (SUCCEEDED(hr))
            pObj->Release();
        
        GetLocalTime(&tStartTime);
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_STRONG_CACHE, &pHandle);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) strong cache", GetDiff(tEndTime,tStartTime));
        if (SUCCEEDED(hr))
            pHandle->Release();

        GetLocalTime(&tStartTime);
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_WEAK_CACHE, &pHandle);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) weak cache", GetDiff(tEndTime,tStartTime));
        if (SUCCEEDED(hr))
            pHandle->Release();

        // Try out the handle types:
        // COOKIE blocks nothing and is never validated.
        // VERSIONED blocks nothing, but is rendered obsolete on Put
        // PROTECTED handles are blocked by exclusive handles
        // EXCLUSIVE handles are blocked if there are protected handles,
        //  they block other exclusive handles, and they block the 
        //  rendering of a cookie or versioned handle into an object.
        // SUBSCOPES apply to all dependent objects.

        // Now, we take out 4 handles: one of each type,

        IWmiDbHandle *pVersioned = NULL, *pCookie = NULL, *pProtected = NULL, *pExclusive = NULL;

        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pCookie);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) cookie", 0);
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pVersioned);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) versioned", 0);
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_PROTECTED, &pProtected);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) protected", 0);

        DWORD dwHandleType = 0;
        if (pCookie)
        {
            pCookie->GetHandleType(&dwHandleType);
            if (dwHandleType == WMIDB_HANDLE_TYPE_INVALID)
                RecordResult(WBEM_E_INVALID_OBJECT, L"Cookie handle unaffected by protected lock", 0);
        }
        if (pVersioned)
        {
            pVersioned->GetHandleType(&dwHandleType);
            if (dwHandleType == WMIDB_HANDLE_TYPE_INVALID)
                RecordResult(WBEM_E_INVALID_OBJECT, L"Versioned handle unaffected by protected lock", 0);
        }
        
        // The exclusive lock should fail...
        if (pProtected)
        {
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pExclusive);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0), L"IWmiDbSession::GetObject (Parent1=2) exclusive (protected outstanding)", 0);
            if (SUCCEEDED(hr)) pExclusive->Release();

            // We should *not* fail to get a cookie or a versioned handle.
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pHandle);
            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) cookie (protected outstanding)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();

            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) versioned (protected outstanding)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();

            // A second protected should be OK.
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_PROTECTED, &pHandle);
            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) protected (protected outstanding)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();
           
            pProtected->GetHandleType(&dwHandleType);
            RecordResult(dwHandleType == WMIDB_HANDLE_TYPE_PROTECTED?0:WBEM_E_FAILED,L"First protected handle remains after second released", 0);

            pProtected->Release();
        }

        // With no protected lock, exclusive should succeed.
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pExclusive);
        RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) exclusive", 0);
        
        // Now we should fail to get a protected handle...
        if (pExclusive)
        {
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_PROTECTED, &pProtected);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0), L"IWmiDbSession::GetObject (Parent1=2) protected (exclusive outstanding)", 0);
            if (SUCCEEDED(hr)) pProtected->Release();

            // We should *not* fail to get a cookie or a versioned handle.
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pHandle);
            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) cookie (exclusive outstanding)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();

            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2) versioned (exclusive outstanding)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();

            // It should fail to get another exclusive handle.
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0), L"IWmiDbSession::GetObject (Parent1=2) exclusive (exclusive outstanding)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();

            // We should fail to render a cookie as an object.
            IWbemClassObject *pObj =NULL;
            hr = pCookie->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0), L"IWmiDbHandle::QueryInterface (cookie - exclusive outstanding)", 0);
            if (SUCCEEDED(hr)) pObj->Release();

            // An exclusive lock on Parent should work, if its not subscoped...
            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1");
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1 - exclusive)", 0);
            if (SUCCEEDED(hr)) pHandle->Release();

            // We should be able to view the exclusive object.
            hr = pExclusive->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            RecordResult(hr, L"IWmiDbHandle::QueryInterface (exclusive)", 0);
            if (pObj)
            {
                // We should be able to update it.
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pExclusive, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
                RecordResult(hr, L"IWmiDbSession::PutObject (Parent1=2 - exclusive)", 0);
                pObj->Release();
                if (SUCCEEDED(hr))
                {                    
                    // Now our versioned handle should be out-of-date...
                    pExclusive->Release();
                    pHandle->Release();
                    hr = pVersioned->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
                    RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0),L"IWmiDbHandle::QueryInterface (versioned - out-of-date)", 0);
                    if (SUCCEEDED(hr)) pObj->Release();
                }                
            }
        }
        if (pCookie) pCookie->Release();
        if (pVersioned) pVersioned->Release();

        pCookie = NULL, pVersioned = NULL, pProtected = NULL, pExclusive = NULL;

        // Now, verify if all this worked for subscopes.
        // An exclusive handle on Parent1=2 should block subscoped protected handles on Parent1
        // An exclusive handle on Child1 should block subscoped protected handles on Parent1
        // A subscoped protected handle on Parent1 should block an exclusive lock on Parent1=2
        // A subscoped protected handle on Parent1 should block an exclusive lock on Child1

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=2");
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
        if (SUCCEEDED(hr))
        {
            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1");
            hr = pSession->GetObject(pScope, pPath,0, WMIDB_HANDLE_TYPE_SUBSCOPED|WMIDB_HANDLE_TYPE_EXCLUSIVE,
                &pExclusive);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0),L"IWmiDbSession::GetObject (subscoped exclusive class, exclusive instance outstanding)", 0);
            if (SUCCEEDED(hr)) pExclusive->Release();
            pHandle->Release();
        }

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Child1");
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
        if (SUCCEEDED(hr))
        {
            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1");
            hr = pSession->GetObject(pScope, pPath,0, WMIDB_HANDLE_TYPE_SUBSCOPED|WMIDB_HANDLE_TYPE_EXCLUSIVE,
                &pExclusive);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0),L"IWmiDbSession::GetObject (subscoped exclusive class, exclusive child outstanding)", 0);
            if (SUCCEEDED(hr)) pExclusive->Release();
            pHandle->Release();
        }

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1");
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_EXCLUSIVE|WMIDB_HANDLE_TYPE_SUBSCOPED, &pHandle);
        if (SUCCEEDED(hr))
        {
            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=2");
            hr = pSession->GetObject(pScope, pPath,0, WMIDB_HANDLE_TYPE_EXCLUSIVE,
                &pExclusive);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0),L"IWmiDbSession::GetObject (exclusive instance, exclusive subscoped parent lock outstanding)", 0);
            if (SUCCEEDED(hr)) pExclusive->Release();
            
            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Child1");
            hr = pSession->GetObject(pScope, pPath,0, WMIDB_HANDLE_TYPE_EXCLUSIVE,
                &pExclusive);
            RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:0),L"IWmiDbSession::GetObject (exclusive class, exclusive subscoped parent lock outstanding)", 0);
            if (SUCCEEDED(hr)) pExclusive->Release();

            pHandle->Release();
        }
        
        pPath->Release();
    }

    return hr;
}

// *****************************************************
HRESULT SetBoolQualifier(IWbemClassObject *pObj, LPWSTR lpQfrName, LPWSTR lpPropName = NULL)
{
    HRESULT hr;
    IWbemQualifierSet *pQS = NULL;
    if (lpPropName == NULL)
        pObj->GetQualifierSet(&pQS);
    else
        pObj->GetPropertyQualifierSet(lpPropName, &pQS);
    if (pQS)
    {
        VARIANT vTemp;
        VariantInit(&vTemp);
        vTemp.boolVal = true;
        vTemp.vt = VT_BOOL;
        hr = pQS->Put(lpQfrName, &vTemp, 3);
        VariantClear(&vTemp);
        pQS->Release();
    }

    return hr;
}
    
// *****************************************************
HRESULT CreateClass (IWmiDbHandle **ppRet, IWmiDbSession *pSession, IWmiDbHandle *pScope, 
                     LPWSTR lpClassName, LPWSTR lpQfrName, CIMTYPE ctKey1, 
                     LPWSTR lpParent = NULL, LPWSTR lpPropQfr = NULL, CIMTYPE ctKey2=0,
                     DWORD dwOptionalHandle = 0)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject *pObj = NULL;

    if (lpParent)
    {
        IWbemPath *pPath = NULL;
        hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemPath, (void **)&pPath); 
        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pParent = NULL;
            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpParent);
            hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pParent);
            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pParentObj = NULL;
                hr = pParent->QueryInterface(IID_IWbemClassObject, (void **)&pParentObj);
                if (SUCCEEDED(hr))
                {
                    hr = pParentObj->SpawnDerivedClass(0, &pObj);
                    pParentObj->Release();
                }
                pParent->Release();
            }
            pPath->Release();
        }
    }
    else
    {
        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pObj);
    }

    if (SUCCEEDED(hr))
    {
        SetStringProp(pObj, L"__Class", lpClassName);
        if (ctKey1)
        {
            pObj->Put(L"Key1", 0, NULL, ctKey1);
            SetAsKey(pObj, L"Key1");
            if (ctKey1 == CIM_REFERENCE && 
                !_wcsicmp(lpClassName, L"Association1"))
            {
                IWbemQualifierSet *pQS = NULL;
                pObj->GetPropertyQualifierSet(L"Key1", &pQS);
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.bstrVal = SysAllocString(L"ref:Parent1");
                vTemp.vt = VT_BSTR;
                pQS->Put(L"CIMTYPE", &vTemp, 3);
                pQS->Release();
                VariantClear(&vTemp);
            }
        }
        if (ctKey2)
        {
            pObj->Put(L"Key2", 0, NULL, ctKey2);
            SetAsKey(pObj, L"Key2");

            if (ctKey2 == CIM_REFERENCE && 
                !_wcsicmp(lpClassName, L"Association1"))
            {
                IWbemQualifierSet *pQS = NULL;
                pObj->GetPropertyQualifierSet(L"Key2", &pQS);
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.bstrVal = SysAllocString(L"ref:Child1");
                vTemp.vt = VT_BSTR;
                pQS->Put(L"CIMTYPE", &vTemp, 3);
                pQS->Release();
                VariantClear(&vTemp);
            }

        }

        if (lpQfrName)
            SetBoolQualifier(pObj, lpQfrName);

        if (lpPropQfr)
            SetBoolQualifier(pObj, lpPropQfr, L"Key1");

        // Put the object in the database.

        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, WMIDB_HANDLE_TYPE_COOKIE|dwOptionalHandle, ppRet);
        pObj->Release();
    }

    return hr;
}
// *****************************************************

HRESULT CreateInstance(IWmiDbHandle **ppRet, IWmiDbSession *pSession, IWmiDbHandle *pScope, 
                       LPWSTR lpClassName, LPWSTR lpKeyValue, CIMTYPE ctKey1, 
                       LPWSTR lpKey2 = NULL, CIMTYPE ctKey2=0, DWORD dwOptionalHandle = 0,
                       DWORD dwFlags = 0)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemPath*pPath = NULL;
    
    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER,
        IID_IWbemPath, (void **)&pPath);
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pParent = NULL;
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpClassName);
        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pParent);
        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pParentObj = NULL;
            hr = pParent->QueryInterface(IID_IWbemClassObject, (void **)&pParentObj);
            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pObj = NULL;
                pParentObj->SpawnInstance(0, &pObj);
                if (pObj)
                {
                    if (ctKey1 == CIM_STRING || ctKey1 == CIM_REFERENCE || ctKey1 == CIM_DATETIME)
                        SetStringProp(pObj, L"Key1", lpKeyValue, FALSE, ctKey1);
                    else if (ctKey1 != 0)
                        SetIntProp(pObj, L"Key1", _wtoi(lpKeyValue), FALSE, ctKey1);
                    if (ctKey2 == CIM_STRING || ctKey2 == CIM_REFERENCE || ctKey2 == CIM_DATETIME)
                        SetStringProp(pObj, L"Key2", lpKey2, FALSE, ctKey1);
                    else if (ctKey2 != 0)
                        SetIntProp(pObj, L"Key2", _wtoi(lpKey2), FALSE, ctKey1);

                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, dwFlags, WMIDB_HANDLE_TYPE_COOKIE|dwOptionalHandle, ppRet);
                    pObj->Release();
                }
                pParentObj->Release();
            }
            pParent->Release();
        }
        pPath->Release();
    }

    return hr;
}

// *****************************************************

HRESULT TestSuiteFunctionality::VerifyCIMClasses()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    IWmiDbHandle *pRet = NULL;

    // Verifies most of the standard practices of CIM.
    // All we want to do here is confirm that the documented concepts 
    // are stored correctly.  We don't want to check anything that WMI 
    // should handle internally, since that may change.

    GetLocalTime(&tStartTime);
    hr = CreateClass(&pRet, pSession, pScope, L"Abstract1", L"abstract", CIM_UINT32);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"Creating abstract class (Abstract1)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        pRet->Release();
        hr = CreateInstance(&pRet, pSession, pScope, L"Abstract1", L"1", CIM_UINT32);
        RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:0, L"Failing to create instance of abstract class (Abstract1=1)", 0);
        if (SUCCEEDED(hr)) pRet->Release();
    }       

    // Singleton class.  This can have only one instance, total, including
    // parent or derived classes.  

    GetLocalTime(&tStartTime);
    hr = CreateClass(NULL, pSession, pScope, L"Singleton1", L"singleton", 0);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"Creating singleton class (Singleton1)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        GetLocalTime(&tStartTime);
        hr = CreateClass(NULL, pSession, pScope, L"Singleton2", L"singleton", 0, L"Singleton1");
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating derived singleton class (Singleton2:Singleton1)", GetDiff(tEndTime,tStartTime));
        if (SUCCEEDED(hr))
        {
            bool bSuccess = false;
            GetLocalTime(&tStartTime);
            hr = CreateInstance(NULL, pSession, pScope, L"Singleton2", NULL, 0);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"Creating derived singleton instance (Singleton2=@)", GetDiff(tEndTime,tStartTime));
            if (SUCCEEDED(hr))
            {
                GetLocalTime(&tStartTime);
                hr = CreateInstance(NULL, pSession, pScope, L"Singleton1", NULL, 0);
                GetLocalTime(&tEndTime);
                RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:0, L"Failing to create second singleton instance (Singleton1=@)", GetDiff(tEndTime,tStartTime));
            }
        }
    }
    
    // Associations - classes and instances

    GetLocalTime(&tStartTime);
    hr = CreateClass(NULL, pSession, pScope, L"Association1", L"association", CIM_REFERENCE, NULL, NULL, CIM_REFERENCE);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"Creating association class (Association1)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        GetLocalTime(&tStartTime);
        hr = CreateInstance(&pRet, pSession, pScope, L"Association1", L"test:Parent1=2", CIM_REFERENCE, L"test:Child1=1", CIM_REFERENCE);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating association instance (Association1.Key1=\"Parent1=2\",Key2=\"Child1=1\")", GetDiff(tEndTime,tStartTime));

        // When we retrieve this object, the two end-points should be translatable into two valid objects.

        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pObj = NULL;
            hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);

                hr = pObj->Get(L"Key1", 0, &vTemp, NULL, NULL);
                if (SUCCEEDED(hr) && vTemp.vt == VT_BSTR)
                {
                    IWbemPath*pPath = NULL;
    
                    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER,
                        IID_IWbemPath, (void **)&pPath);
                    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, vTemp.bstrVal);

                    IWmiDbHandle *pTemp = NULL;
                    hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTemp);
                    RecordResult(hr, L"Verifying reference value (Association1.Key1 = Parent1=2)", 0);

                    if (SUCCEEDED(hr)) pTemp->Release();
                    pPath->Release();
                }
                VariantClear(&vTemp);

                pObj->Release();
            }
            pRet->Release();
        }
    }
    
    // Unkeyed class.  This class has no defined key.  The object path is dynamically generated.
    //   Instances can only be retrieved by query, not by GetObject.
    
    GetLocalTime(&tStartTime);
    hr = CreateClass(NULL, pSession, pScope, L"Unkeyed1", L"unkeyed", 0);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"Creating unkeyed class (Unkeyed1)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        GetLocalTime(&tStartTime);
        hr = CreateInstance(&pRet, pSession, pScope, L"Unkeyed1", NULL, 0);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating unkeyed instance (Unkeyed1=?)", GetDiff(tEndTime,tStartTime));
        if (pRet)
        {
            IWbemClassObject *pObj = NULL;
            GetLocalTime(&tStartTime);
            hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbHandle::QueryInterface (Unkeyed1)", GetDiff(tEndTime,tStartTime));
            pRet->Release();
            if (SUCCEEDED(hr)) pObj->Release();
        }
    }
   

    // Keyholes.  A keyhole property should be populated if left blank.  Verify on string and int.

    hr = CreateClass(NULL, pSession, pScope, L"Keyhole1", NULL, CIM_UINT32, NULL, L"keyhole");
    RecordResult(hr, L"Creating class Keyhole1", 0);
    if (SUCCEEDED(hr))
    {
        GetLocalTime(&tStartTime);
        hr = CreateInstance(&pRet, pSession, pScope, L"Keyhole1", NULL, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating keyhole instance (Keyhole1=?)", GetDiff(tEndTime,tStartTime));

        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pObj =NULL;
            hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                long lTemp = 0;
                hr = pObj->Get(L"Key1", 0, &vTemp, NULL, NULL);
                RecordResult(SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal > 0 ? WBEM_S_NO_ERROR: WBEM_E_FAILED, 
                    L"Verifying populated keyhole value (Keyhole1=?).", 0);
                lTemp = vTemp.lVal;
                VariantClear(&vTemp);

                // Now updating this object should leave the value alone...

                IWmiDbHandle *pTemp = NULL;
                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTemp);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"Updating existing keyhole (Keyhole1=1)", GetDiff(tEndTime,tStartTime));
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject *pTempObj = NULL;
                    hr = pTemp->QueryInterface(IID_IWbemClassObject, (void **)&pTempObj);
                    if (SUCCEEDED(hr))
                    {
                        hr = pTempObj->Get(L"Key1", 0, &vTemp, NULL, NULL);
                        RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == lTemp)?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                            L"Verifying update of keyhole instance (Keyhole1=1)", 0);
                        VariantClear(&vTemp);
                        pTempObj->Release();

                    }
                    pTemp->Release();
                }
                pObj->Release();
            }
            pRet->Release();
        }
    }

     // Compound keys.  Create an instance in one order, should be able to retrieve it in the other.

    hr = CreateClass(NULL, pSession, pScope, L"CompoundKeys1", NULL, CIM_UINT32, NULL, NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class CompoundKeys1", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateInstance(NULL, pSession, pScope, L"CompoundKeys1", L"1", CIM_UINT32, L"2", CIM_UINT32);
        RecordResult(hr, L"Creating instance CompoundKeys1=1,2", 0);
        if (SUCCEEDED(hr))
        {
            pRet = NULL;
            IWbemClassObject *pObj =NULL;
            GetLocalTime(&tStartTime);
            hr = GetObject(pScope, L"CompoundKeys1.Key2=2,Key1=1", WMIDB_HANDLE_TYPE_COOKIE, 2,
                &pRet, &pObj, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::GetObject (CompoundKeys1.Key2=2,Key1=1)", GetDiff(tEndTime,tStartTime));
            if (pObj) pObj->Release();
            if (pRet) pRet->Release();
        }
        hr = CreateInstance(NULL, pSession, pScope, L"CompoundKeys1", L"1", CIM_UINT32, L"1", CIM_UINT32, 0, WBEM_FLAG_CREATE_ONLY);
        RecordResult(hr, L"Creating instance CompoundKeys1=1,1", 0);
        if (SUCCEEDED(hr))
        {
            pRet = NULL;
            IWbemClassObject *pObj =NULL;
            GetLocalTime(&tStartTime);
            hr = GetObject(pScope, L"CompoundKeys1.Key2=1,Key1=1", WMIDB_HANDLE_TYPE_COOKIE, 2,
                &pRet, &pObj, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::GetObject (CompoundKeys1.Key2=1,Key1=1)", GetDiff(tEndTime,tStartTime));
            if (pObj) pObj->Release();
            if (pRet) pRet->Release();
        }
    }

    // Make sure it supports string keyholes.

    hr = CreateClass(NULL, pSession, pScope, L"Keyhole2", NULL, CIM_STRING, NULL, L"keyhole");
    RecordResult(hr, L"Creating class Keyhole2", 0);
    if (SUCCEEDED(hr))
    {
        GetLocalTime(&tStartTime);
        hr = CreateInstance(&pRet, pSession, pScope, L"Keyhole2", NULL, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating keyhole instance (Keyhole2=?)", GetDiff(tEndTime,tStartTime));

        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pObj =NULL;
            hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                hr = pObj->Get(L"Key1", 0, &vTemp, NULL, NULL);
                RecordResult(SUCCEEDED(hr) && vTemp.vt == VT_BSTR && wcslen(vTemp.bstrVal) ? WBEM_S_NO_ERROR: WBEM_E_FAILED, 
                    L"Verifying populated keyhole value (Keyhole2).", 0);
                VariantClear(&vTemp);
                pObj->Release();
            }
            pRet->Release();
        }
    }
    return hr;

}

// *****************************************************

HRESULT TestSuiteFunctionality::VerifyMethods()
{
    HRESULT hr;
    IWmiDbHandle *pRet = NULL;
    SYSTEMTIME tStartTime, tEndTime;

    // Methods.  This should support methods and method parameters for storage and retrieval.

    hr = CreateClass(&pRet, pSession, pScope, L"Method1", NULL, CIM_STRING, NULL, NULL, NULL, WMIDB_HANDLE_TYPE_NO_CACHE);
    RecordResult(hr, L"Creating class Method1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        if (SUCCEEDED(hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass)))
        {
            IWbemQualifierSet *pQS = NULL;
            VARIANT vTemp;
            VariantInit(&vTemp);

            // One method with no parameters.

            pClass->PutMethod(L"Method1", 0, NULL, NULL);
            pClass->GetMethodQualifierSet(L"Method1", &pQS);
            
            vTemp.vt = VT_BSTR;
            vTemp.bstrVal = SysAllocString(L"This method has no parameters.");
            pQS->Put(L"Description", &vTemp, 0);
            pQS->Release();
            VariantClear(&vTemp);

            // One method with in and out parameters

            IWbemClassObject *pIn = NULL;
            IWbemClassObject *pOut = NULL;
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemClassObject, (void **)&pIn);
            SetStringProp(pIn, L"__Class", L"__Parameters");
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemClassObject, (void **)&pOut);
            SetStringProp(pOut, L"__Class", L"__Parameters");

            // Each parameter needs to have zero-based "id" fields.
            SetStringProp(pIn, L"InParam1", L"in");
            SetIntProp(pIn, L"InParam2", 1);
            SetStringProp(pOut, L"OutParam1", L"out");

            hr = pIn->GetPropertyQualifierSet(L"InParam1", &pQS);
            if (SUCCEEDED(hr))
            {
                vTemp.vt = VT_I4;
                vTemp.lVal = 0;
                hr = pQS->Put(L"id", &vTemp, 0);
                VariantClear(&vTemp);
                pQS->Release();
            }

            hr = pIn->GetPropertyQualifierSet(L"InParam2", &pQS);
            if (SUCCEEDED(hr))
            {
                vTemp.vt = VT_I4;
                vTemp.lVal = 1;
                hr = pQS->Put(L"id", &vTemp, 0);
                pQS->Release();
                VariantClear(&vTemp);
            }

            hr = pOut->GetPropertyQualifierSet(L"OutParam1", &pQS);
            if (SUCCEEDED(hr))
            {
                vTemp.vt = VT_I4;
                vTemp.lVal = 2;
                hr = pQS->Put(L"id", &vTemp, 0);
                vTemp.vt = VT_BSTR;
                vTemp.bstrVal = SysAllocString(L"This is an out parameter.");
                pQS->Put(L"Description", &vTemp, 0);
                pQS->Release();
                VariantClear(&vTemp);
            }

            hr = pClass->PutMethod(L"Method2", 0, pIn, pOut);
            pIn->Release();
            pOut->Release();

            hr = pClass->GetMethodQualifierSet(L"Method2", &pQS);
            if (SUCCEEDED(hr))
            {
                vTemp.vt = VT_BSTR;
                vTemp.bstrVal = SysAllocString(L"This method has in and out parameters.");
                pQS->Put(L"Description", &vTemp, 0);
                pQS->Release();
                VariantClear(&vTemp);
            }
            
            GetLocalTime(&tStartTime);

            IWmiDbHandle *pNew = NULL;
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_NO_CACHE, &pNew);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"Creating a class with methods (Method1)", GetDiff(tEndTime,tStartTime));

            // Retrieve it and make sure it contains all the components we just created.
            
            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pNewObj =NULL;
                hr = pNew->QueryInterface(IID_IWbemClassObject, (void **)&pNewObj);
                if (SUCCEEDED(hr))
                {
                    RecordResult(pNewObj->GetMethod(L"Method1", 0, &pIn, &pOut), L"Verifying existence of Method1.Method1", 0);
                    if (pIn) pIn->Release();
                    if (pOut) pOut->Release();

                    RecordResult(pNewObj->GetMethod(L"Method2", 0, &pIn, &pOut), L"Verifying existence of Method1.Method2", 0);
                    RecordResult((pIn == NULL)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Verifying existence of in parameters on Method1.Method2", 0);
                    RecordResult((pOut == NULL)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Verifying existence of out parameters on Method1.Method2", 0);

                    if (pIn)
                    {                        
                        hr = ValidateProperty(pIn, L"InParam1", CIM_STRING, L"in");
                        RecordResult(hr, L"Verifying Method1.Method2.InParam1", 0);

                        hr = ValidateProperty(pIn, L"InParam2", CIM_UINT32, 1);
                        RecordResult(hr,L"Verifying Method1.Method2.InParam2", 0);

                        pIn->Release();
                    }

                    if (pOut)
                    {
                        hr = pOut->Get(L"OutParam1", 0, &vTemp, NULL, NULL);
                        RecordResult(SUCCEEDED(hr) && vTemp.vt == VT_BSTR && !_wcsicmp(vTemp.bstrVal, L"out")?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                            L"Verifying Method1.Method2.OutParam1", 0);
                        VariantClear(&vTemp);

                        hr = pOut->GetPropertyQualifierSet(L"OutParam1", &pQS);
                        if (SUCCEEDED(hr))
                        {
                            hr = pQS->Get(L"Description", NULL, &vTemp, NULL);
                            RecordResult(SUCCEEDED(hr) && vTemp.vt == VT_BSTR && !_wcsicmp(vTemp.bstrVal, L"This is an out parameter.")
                                ?WBEM_S_NO_ERROR:WBEM_E_FAILED,L"Verifying qualifier Method1.Method2.OutParam1.Description", 0);
                            VariantClear(&vTemp);
                            hr = pQS->Get(L"id", NULL, &vTemp, NULL);
                            RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == 2) ? WBEM_S_NO_ERROR: WBEM_E_FAILED,
                                L"Driver preserves method parameter ID.", 0);
                            VariantClear(&vTemp);
                            pQS->Release();
                        }
                        pOut->Release();
                    }

                    pNewObj->GetMethodQualifierSet(L"Method2", &pQS);
                    if (pQS)
                    {
                        hr = pQS->Get(L"Description", NULL, &vTemp, NULL);
                        RecordResult(SUCCEEDED(hr) && vTemp.vt == VT_BSTR && !_wcsicmp(vTemp.bstrVal, L"This method has in and out parameters.")
                            ?WBEM_S_NO_ERROR:WBEM_E_FAILED,L"Verifying qualifier Method1.Method2.Description", 0);
                        pQS->Release();
                        VariantClear(&vTemp);
                    }

                    pNewObj->Release();
                }
                pNew->Release();
            }
            pClass->Release();
        }
        pRet->Release();
    }

    return hr;
}

// *****************************************************

HRESULT TestSuiteFunctionality::VerifyCIMTypes()
{
    HRESULT hr;
    SYSTEMTIME tStartTime, tEndTime;
    IWmiDbHandle *pRet = NULL;
    IWbemClassObject *pTemp = NULL;

     // Case-insensitive searches should always work!!!

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"parent1.key1=2", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pTemp);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"Case-insensitive retrieval (parent1.key1=2)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        pRet->Release();
        pTemp->Release();
    }
    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"child1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pRet, &pTemp);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"Case-insensitive retrieval (child1)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        pRet->Release();
        pTemp->Release();
    }

    // Null.  If a property is saved as null, it should be returned as null (and not blank).

    hr = CreateClass(&pRet, pSession, pScope, L"Nulls1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Nulls1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        if (SUCCEEDED(hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass)))
        {
            pRet->Release();
            hr = pClass->Put(L"Prop1", 0, NULL, CIM_STRING);
            hr = pClass->Put(L"Prop2", 0, NULL, CIM_UINT32);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, WMIDB_HANDLE_TYPE_COOKIE, &pRet);
            if (SUCCEEDED(hr))
            {
                pClass->Release();
                pRet->Release();
                hr = CreateInstance(&pRet, pSession, pScope, L"Nulls1", L"1", CIM_UINT32);
                RecordResult(hr, L"Creating instance Nulls1=1", 0);
                if (SUCCEEDED(hr))
                {
                    hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass);
                    if (SUCCEEDED(hr))
                    {
                        hr = ValidateProperty(pClass, L"Prop1", CIM_STRING, (VARIANT *)NULL);
                        RecordResult(hr, L"Persisting null string data (Nulls1=1.Prop1)", 0);
                        hr = ValidateProperty(pClass, L"Prop2", CIM_UINT32, (VARIANT *)NULL);
                        RecordResult(hr, L"Persisting null uint32 data (Nulls1=1.Prop2)", 0);
                        pClass->Release();
                    }
                    pRet->Release();
                }
            }
        }
    }

    // Not_Null.  Should disallow null on instances.  Should disallow null keys

    hr = CreateClass(&pRet, pSession, pScope, L"Not_Null1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Not_Null1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        if (SUCCEEDED(hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass)))
        {
            pClass->Put(L"Prop1", 0, NULL, CIM_STRING);
            SetBoolQualifier(pClass, L"not_null", L"Prop1");
            pRet->Release();
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, WMIDB_HANDLE_TYPE_COOKIE, &pRet);
            if (SUCCEEDED(hr))
            {
                hr = CreateInstance(NULL, pSession, pScope, L"Not_Null1", L"1", CIM_UINT32);
                RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:0, L"Disallowing nulls in a not_null property (Not_Null1.Prop1)", 0);               
                if (pRet) pRet->Release();
            }            
            pClass->Release();
        }
        else
            pRet->Release();
    }    
    
    // Qualifiers + flavors on instances+classes+properties
    // Storage and retrieval (no cache!)  ToInstance and ToSubclass flavors should be preserved.

    IWbemClassObject *pObj = NULL;
    hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pObj);
    RecordResult(hr, L"Retrieving Parent1", 0);
    if (SUCCEEDED(hr))
    {
        pRet->Release();
        IWbemQualifierSet *pQS = NULL;
        VARIANT vTemp;
        VariantInit(&vTemp);
        pObj->GetQualifierSet(&pQS);
        if (pQS)
        {
            vTemp.lVal = 1;
            vTemp.vt = VT_I4;
            pQS->Put(L"Number", &vTemp, WBEM_FLAVOR_NOT_OVERRIDABLE|WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

            SetBoolQualifier(pObj, L"Boolean");

            pQS->Release();
            VariantClear(&vTemp);
        }
        pObj->GetPropertyQualifierSet(L"Key1", &pQS);
        if (pQS)
        {
            vTemp.bstrVal = SysAllocString(L"Test");
            vTemp.vt = VT_BSTR;
            pQS->Put(L"Text", &vTemp, WBEM_FLAVOR_NOT_OVERRIDABLE|WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
            pQS->Release();
            VariantClear(&vTemp);
        }
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, WMIDB_HANDLE_TYPE_COOKIE, &pRet);
        RecordResult(SUCCEEDED(hr) ? WBEM_E_FAILED : WBEM_S_NO_ERROR, L"Storing propagated qualifier on class with instances", 0);

/*** NOVA COMPATIBILITY: We can't add a propagated qualifier to a class with instances.
        if (SUCCEEDED(hr))
        {
            pObj->Release();

            hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                pObj->GetQualifierSet(&pQS);
                if (pQS)
                {
                    hr = pQS->Get(L"Number", NULL, &vTemp, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == 1)?0:WBEM_E_FAILED,
                        L"Storing and retrieving class int32 (Parent1.Number) qualifiers", 0);
                    VariantClear(&vTemp);
                    hr = pQS->Get(L"Boolean", NULL, &vTemp, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BOOL && vTemp.boolVal == -1)?0:WBEM_E_FAILED,
                        L"Storing and retrieving class boolean (Parent1.Boolean) qualifiers", 0);
                    VariantClear(&vTemp);

                    pQS->Release();
                }
                pObj->GetPropertyQualifierSet(L"Key1", &pQS);
                if (pQS)
                {
                    hr = pQS->Get(L"Text", NULL, &vTemp, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR && !_wcsicmp(L"Test", vTemp.bstrVal))?0:WBEM_E_FAILED,
                        L"Storing and retrieving class text (Parent1.Key1.Text) qualifiers", 0);
                    VariantClear(&vTemp);
                    pQS->Release();
                }
                pObj->Release();
            }
            pRet->Release();
        }
        else
            pObj->Release();

        // If that worked, we should be able to retrieve the 
        // subclass and instance and see the same qualifiers on them.

        hr = GetObject(pScope, L"Parent1=2", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pObj);
        RecordResult(hr, L"Retrieving Parent1=2", 0);
        if (SUCCEEDED(hr))
        {
            pRet->Release();
            pObj->GetQualifierSet(&pQS);
            if (pQS)
            {
                hr = pQS->Get(L"Number", NULL, &vTemp, NULL);
                RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == 1)?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Verifying new propogated qualifier on class in existing instance (Parent1=2.Number)", 0);

                VariantClear(&vTemp);

                vTemp.lVal = 10;
                vTemp.vt = VT_I4;
                pQS->Put(L"InstanceNumber", &vTemp, 0);
                VariantClear(&vTemp);
                pQS->Release();
            }
            pObj->GetPropertyQualifierSet(L"Key1", &pQS);
            if (pQS)
            {
                hr = pQS->Get(L"Text", NULL, &vTemp, 0);
                RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR )?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Verifying new propogated qualifier on property in existing instance (Parent1=2.Text)", 0);
                VariantClear(&vTemp);

                vTemp.lVal = 20;
                vTemp.vt = VT_I4;
                pQS->Put(L"InstanceNumber", &vTemp, 0);
                VariantClear(&vTemp);
                pQS->Release();
            }
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, WMIDB_HANDLE_TYPE_COOKIE, &pRet);
            if (SUCCEEDED(hr))
            {
                pObj->Release();

                hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
                if (SUCCEEDED(hr))
                {
                    // We should have two instance qualifiers
                    pObj->GetQualifierSet(&pQS);
                    if (pQS)
                    {
                        hr = pQS->Get(L"Number", NULL, &vTemp, NULL);
                        RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == 1)?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                            L"Verifying propogated qualifier on instance (Parent1=2.Number)", 0);
                        VariantClear(&vTemp);

                        hr = pQS->Get(L"InstanceNumber", NULL, &vTemp, NULL);
                        RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == 10)?0:WBEM_E_FAILED,
                            L"Storing and retrieving instance int32 (Parent1=2.InstanceNumber) qualifiers", 0);
                        VariantClear(&vTemp);
                        pQS->Release();
                    }
                    pObj->GetPropertyQualifierSet(L"Key1", &pQS);
                    if (pQS)
                    {
                        hr = pQS->Get(L"InstanceNumber", NULL, &vTemp, NULL);
                        RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_I4 && vTemp.lVal == 20)?0:WBEM_E_FAILED,
                            L"Storing and retrieving instance int32 (Parent1=2.Key1.InstanceNumber) qualifiers", 0);
                        VariantClear(&vTemp);
                        pQS->Release();
                    }
                    pObj->Release();
                }

                pRet->Release();
            }
            else
                pObj->Release();
           
        }
        */
    }

    // Indexed property.  The repository should create an index for it.  We have no way of verifying that it did, though.

    hr = CreateClass(&pRet, pSession, pScope, L"Index1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Index1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        if (SUCCEEDED(hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass)))
        {
            pClass->Put(L"IndexProp1", 0, NULL, CIM_UINT32);
            SetBoolQualifier(pClass, L"indexed", L"IndexProp1");
            pClass->Put(L"Prop2", 0, NULL, CIM_STRING);
            pRet->Release();
            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, WMIDB_HANDLE_TYPE_COOKIE, &pRet);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"Creating class with indexes (Index1)", GetDiff(tEndTime,tStartTime));
            if (SUCCEEDED(hr))
            {
                // Create an instance

                IWbemClassObject *pIndex = NULL;
                IWmiDbHandle *pInst = NULL;

                pClass->SpawnInstance(0, &pIndex);
                SetIntProp(pIndex, L"Key1", 1);
                SetIntProp(pIndex, L"IndexProp1", 100);
                SetStringProp(pIndex, L"Prop2", L"Some value.");
                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pIndex, 0, WMIDB_HANDLE_TYPE_COOKIE, &pInst);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"Creating instance with indexed data (Index1=1)", GetDiff(tEndTime,tStartTime));
                if (pInst) pInst->Release();
                pIndex->Release();

                // Now index Prop2.  
/* NOVA COMPATIBLITY: Not supported (yet)
                SetBoolQualifier(pClass, L"indexed", L"Prop2");
                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, 0, NULL);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"Adding index to a property with existing data (Index1.Prop2)", GetDiff(tEndTime,tStartTime));
*/
                pRet->Release();
            }
            pClass->Release();
        }
        else
            pRet->Release();
    }    

    // Defaults.  All default data should propogate between classes and new instances.  New defaults
    //   must be copied if class modified.

    hr = CreateClass(&pRet, pSession, pScope, L"Default1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Default1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        if (SUCCEEDED(hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass)))
        {            
            SetStringProp(pClass, L"StringDefault", L"This is the string default");
            SetIntProp(pClass, L"IntDefault", 0);
            pClass->Put(L"IntNoDefault", 0, NULL, CIM_UINT32);

            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, 0, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"Creating class with default data  (Default1)", GetDiff(tEndTime,tStartTime));

            IWbemClassObject *pInst = NULL;
            pClass->SpawnInstance(0, &pInst);
            SetIntProp(pInst, L"Key1", 1);
            SetIntProp(pInst, L"IntDefault", NULL, FALSE, NULL);
            
            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pInst, 0, 0, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"Creating instance using default data (Default1=1)", GetDiff(tEndTime,tStartTime));

            pInst->Release();
/* NOVA COMPATIBLITY: Not supported (yet)
            // Add a new default, and change a different default in the class.
            pClass->Put(L"IntDefault", 0, NULL, CIM_UINT32); // Make sure a non-null default is overridable.
            SetIntProp(pClass, L"IntNoDefault", 99);
            SetStringProp(pClass, L"StringDefault2", L"This is a new string default.");
            SetStringProp(pClass, L"RefDefault", L"Testing", FALSE, CIM_REFERENCE);
            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, 0, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"Updating class with new default data and existing instances (Default1)", GetDiff(tEndTime,tStartTime));
*/
            pClass->Release();
/*

            IWmiDbHandle *pHand = NULL;
            hr = GetObject(pScope, L"Default1=1", WMIDB_HANDLE_TYPE_COOKIE, 6, &pHand, &pClass);
            RecordResult(hr, L"Retrieving Default1=1", 0);
            if (SUCCEEDED(hr))
            {
                RecordResult( ValidateProperty(pClass, L"StringDefault", CIM_STRING, L"This is the string default"),
                    L"Validating propogated default Default1=1.StringDefault", 0);
                RecordResult( ValidateProperty(pClass, L"IntDefault", CIM_UINT32, (VARIANT *)NULL),
                    L"Validating overriding null Default1=1.IntDefault", 0);

                pClass->Release();
                pHand->Release();
            }
*/
        }
        pRet->Release();
    }
   
    // Supported property datatypes and boundaries.  
    //  * uint8       * uint16    * [uint32]  * uint64
    //  * sint8       * sint16    * sint32    * sint64
    //  * real32      * real64    * char16    * datetime
    //  * [reference] * object    * boolean   * [string]
    // Skip references since they only apply to associations, tested elsewhere.

    hr = CreateClass(&pRet, pSession, pScope, L"AllDatatypes1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class AllDatatypes1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass);
        if (SUCCEEDED(hr))
        {
            pClass->Put(L"string", NULL, NULL, CIM_STRING);            
            pClass->Put(L"dt", NULL, NULL, CIM_DATETIME);            
            pClass->Put(L"boolean", NULL, NULL, CIM_BOOLEAN);            
            pClass->Put(L"sint8", NULL, NULL, CIM_SINT8);            
            pClass->Put(L"sint16", NULL, NULL, CIM_SINT16);            
            pClass->Put(L"sint32", NULL, NULL, CIM_SINT32);            
            pClass->Put(L"sint64", NULL, NULL, CIM_SINT64);            
            pClass->Put(L"uint8", NULL, NULL, CIM_UINT8);            
            pClass->Put(L"uint16", NULL, NULL, CIM_UINT16);            
            pClass->Put(L"uint32", NULL, NULL, CIM_UINT32);            
            pClass->Put(L"uint64", NULL, NULL, CIM_UINT64);            
            pClass->Put(L"real32", NULL, NULL, CIM_REAL32);            
            pClass->Put(L"real64", NULL, NULL, CIM_REAL64);            
            pClass->Put(L"char16", NULL, NULL, CIM_CHAR16);
            pClass->Put(L"object", NULL, NULL, CIM_OBJECT);

            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, 0, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::PutObject (AllDatatypes1)", GetDiff(tEndTime,tStartTime));

            // Now create several instances:
            // One with upper bounds exercised:

            IWbemClassObject *pInst1 = NULL;
            pClass->SpawnInstance(0, &pInst1);
            if (pInst1)
            {
                SetIntProp(pInst1, L"Key1", 1);
                SetIntProp(pInst1, L"boolean", true, FALSE, CIM_BOOLEAN);
                SetIntProp(pInst1, L"sint8", 127, FALSE, CIM_SINT8);
                SetIntProp(pInst1, L"sint16", 32767, FALSE, CIM_SINT16);
                SetIntProp(pInst1, L"sint32", 2147483647, FALSE, CIM_SINT32);
                SetIntProp(pInst1, L"uint8", 255, FALSE, CIM_UINT8);
                SetIntProp(pInst1, L"uint16", 65533, FALSE, CIM_UINT16);
                SetIntProp(pInst1, L"uint32", 4294967294, FALSE, CIM_UINT32);
                SetStringProp(pInst1, L"string", L"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
                SetStringProp(pInst1, L"dt", L"29991231235959.999999+000", 0, CIM_DATETIME);
                SetIntProp(pInst1, L"char16", 0xFF, FALSE, CIM_CHAR16);

                VARIANT vTemp;
                VariantInit(&vTemp);
                V_R4(&vTemp) = (float)3.402823E38;
                vTemp.vt = VT_R4;
                pInst1->Put(L"real32", NULL, &vTemp, CIM_REAL32);
                VariantClear(&vTemp);

                V_R8(&vTemp) = (double)1.7969313486231E308;
                vTemp.vt = VT_R8;
                pInst1->Put(L"real64", NULL, &vTemp, CIM_REAL64);
                VariantClear(&vTemp);

                V_BSTR(&vTemp) = SysAllocString(L"922337203685477580");
                vTemp.vt = VT_BSTR;
                pInst1->Put(L"uint64", NULL, &vTemp, CIM_UINT64);
                VariantClear(&vTemp);

                V_BSTR(&vTemp) = SysAllocString(L"922337203685477580");
                vTemp.vt = VT_BSTR;
                pInst1->Put(L"sint64", NULL, &vTemp, CIM_SINT64);
                VariantClear(&vTemp);

                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pInst1, 0, 0, NULL);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"IWmiDbSession::PutObject - upper bounds, all datatypes (AllDatatypes1=1)", GetDiff(tEndTime,tStartTime));
                pInst1->Release();

                IWmiDbHandle *pTempHandle = NULL;
                IWbemClassObject *pTempObj = NULL;
                hr = GetObject(pScope, L"AllDatatypes1=1", WMIDB_HANDLE_TYPE_COOKIE, 16, &pTempHandle, &pTempObj);
                RecordResult(hr, L"Retrieving AllDatatypes1=1", 0);
                if (SUCCEEDED(hr))
                {
                    RecordResult(ValidateProperty(pTempObj, L"boolean", CIM_BOOLEAN, true), L"Validating AllDatatypes1=1.boolean", 0);
                    RecordResult(ValidateProperty(pTempObj, L"sint8", CIM_SINT8, 127), L"Validating AllDatatypes1=1.sint8", 0);
                    RecordResult(ValidateProperty(pTempObj, L"sint16", CIM_SINT16, 32767), L"Validating AllDatatypes1=1.sint16", 0);
                    RecordResult(ValidateProperty(pTempObj, L"sint32", CIM_SINT32, 2147483647), L"Validating AllDatatypes1=1.sint32", 0);
                    RecordResult(ValidateProperty(pTempObj, L"uint8", CIM_UINT8, 255), L"Validating AllDatatypes1=1.uint8", 0);
                    RecordResult(ValidateProperty(pTempObj, L"uint16", CIM_UINT16, 65533), L"Validating AllDatatypes1=1.uint16", 0);
                    RecordResult(ValidateProperty(pTempObj, L"uint32", CIM_UINT32, 4294967294), L"Validating AllDatatypes1=1.uint32", 0);
                    RecordResult(ValidateProperty(pTempObj, L"string", CIM_STRING, 
                        L"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 
                        L"Validating AllDatatypes1=1.string", 0);
                    RecordResult(ValidateProperty(pTempObj, L"dt", CIM_DATETIME, L"29991231235959.999999+000"), L"Validating AllDatatypes1=1.datetime", 0);
                    RecordResult(ValidateProperty(pTempObj, L"char16", CIM_CHAR16, 0xFF), L"Validating AllDatatypes1=1.char16", 0);

                    hr = pTempObj->Get(L"real32", 0, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_R4)?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=1.real32", 0);
                    VariantClear(&vTemp);
                        
                    hr = pTempObj->Get(L"real64", 0, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_R8)?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=1.real64", 0);
                    VariantClear(&vTemp);

                    hr = pTempObj->Get(L"uint64", NULL, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR)?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=1.uint64", 0);
                    VariantClear(&vTemp);

                    hr = pTempObj->Get(L"sint64", NULL, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR)?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=1.sint64", 0);
                    VariantClear(&vTemp);

                    pTempObj->Release();
                    pTempHandle->Release();
                }                   
            }

            // Test the lower non-null bounds.

            hr = pClass->SpawnInstance(0, &pInst1);
            if (SUCCEEDED(hr))
            {
                SetIntProp(pInst1, L"Key1", 2);
                SetIntProp(pInst1, L"boolean", 0, FALSE, CIM_BOOLEAN);
                SetIntProp(pInst1, L"sint8", 127, FALSE, CIM_SINT8);
                SetIntProp(pInst1, L"sint16", 32767, FALSE, CIM_SINT16);
                SetIntProp(pInst1, L"sint32", 2147483647, FALSE, CIM_SINT32);
                SetIntProp(pInst1, L"uint8", 0, FALSE, CIM_UINT8);
                SetIntProp(pInst1, L"uint16", 0, FALSE, CIM_UINT16);
                SetIntProp(pInst1, L"uint32", 0, FALSE, CIM_UINT32);
                SetStringProp(pInst1, L"string", L".");
                SetStringProp(pInst1, L"dt", L"00000000000001.000000+000", 0, CIM_DATETIME);
                SetIntProp(pInst1, L"char16", 1, FALSE, CIM_CHAR16);

                VARIANT vTemp;
                VariantInit(&vTemp);
                V_R4(&vTemp) = (float)-3.402823E38;
                vTemp.vt = VT_R4;
                pInst1->Put(L"real32", NULL, &vTemp, CIM_REAL32);
                VariantClear(&vTemp);

                V_R8(&vTemp) = (double)-1.79769313486231E308 ;
                vTemp.vt = VT_R8;
                pInst1->Put(L"real64", NULL, &vTemp, CIM_REAL64);
                VariantClear(&vTemp);

                V_BSTR(&vTemp) = SysAllocString(L"0");
                vTemp.vt = VT_BSTR;
                pInst1->Put(L"uint64", NULL, &vTemp, CIM_UINT64);
                VariantClear(&vTemp);

                V_BSTR(&vTemp) = SysAllocString(L"-922337203685477580");
                vTemp.vt = VT_BSTR;
                pInst1->Put(L"sint64", NULL, &vTemp, CIM_SINT64);
                VariantClear(&vTemp);

                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pInst1, 0, 0, NULL);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"IWmiDbSession::PutObject - lower bounds, all datatypes (AllDatatypes1=1)", GetDiff(tEndTime,tStartTime));
                pInst1->Release();

                IWmiDbHandle *pTempHandle = NULL;
                IWbemClassObject *pTempObj = NULL;
                hr = GetObject(pScope, L"AllDatatypes1=2", WMIDB_HANDLE_TYPE_COOKIE, 16, &pTempHandle, &pTempObj);
                RecordResult(hr, L"Retrieving AllDatatypes1=2", 0);
                if (SUCCEEDED(hr))
                {
                    RecordResult(ValidateProperty(pTempObj, L"boolean", CIM_BOOLEAN, (DWORD)0), L"Validating AllDatatypes1=2.boolean", 0);
                    RecordResult(ValidateProperty(pTempObj, L"sint8", CIM_SINT8, 127), L"Validating AllDatatypes1=2.sint8", 0);
                    RecordResult(ValidateProperty(pTempObj, L"sint16", CIM_SINT16, 32767), L"Validating AllDatatypes1=2.sint16", 0);
                    RecordResult(ValidateProperty(pTempObj, L"sint32", CIM_SINT32, 2147483647), L"Validating AllDatatypes1=2.sint32", 0);
                    RecordResult(ValidateProperty(pTempObj, L"uint8", CIM_UINT8, (DWORD)0), L"Validating AllDatatypes1=2.uint8", 0);
                    RecordResult(ValidateProperty(pTempObj, L"uint16", CIM_UINT16, (DWORD)0), L"Validating AllDatatypes1=2.uint16", 0);
                    RecordResult(ValidateProperty(pTempObj, L"uint32", CIM_UINT32, (DWORD)0), L"Validating AllDatatypes1=2.uint32", 0);
                    RecordResult(ValidateProperty(pTempObj, L"string",CIM_STRING, L"."), L"Validating AllDatatypes1=2.string", 0);
                    RecordResult(ValidateProperty(pTempObj, L"dt", CIM_DATETIME, L"00000000000001.000000+000"), L"Validating AllDatatypes1=2.datetime", 0);
                    RecordResult(ValidateProperty(pTempObj, L"char16", CIM_CHAR16, 1), L"Validating AllDatatypes1=1.char16", 0);

                    hr = pTempObj->Get(L"real32", NULL, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_R4 )?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=2.real32", 0);
                    VariantClear(&vTemp);
                        
                    hr = pTempObj->Get(L"real64", NULL, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_R8 )?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=2.real64", 0);
                    VariantClear(&vTemp);

                    hr = pTempObj->Get(L"uint64", NULL, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR )?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=2.uint64", 0);
                    VariantClear(&vTemp);

                    hr = pTempObj->Get(L"sint64", NULL, &vTemp, NULL, NULL);
                    RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR )?WBEM_S_NO_ERROR: WBEM_E_FAILED,
                        L"Validating AllDatatypes1=2.sint64", 0);
                    VariantClear(&vTemp);

                    pTempObj->Release();
                    pTempHandle->Release();
                }                                   
            }

            // Finally, an instance with only the embedded object populated.

            hr = pClass->SpawnInstance(0, &pInst1);
            if (SUCCEEDED(hr))
            {
                IWmiDbHandle *pParent = NULL;
                IWbemClassObject *pObj = NULL;
                hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pParent, &pObj);
                RecordResult(hr, L"Retrieving Parent1", 0);
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject *pNewEmbed = NULL;
                    VARIANT vTemp;
                    VariantInit(&vTemp);

                    pObj->SpawnInstance(0, &pNewEmbed);
                    SetIntProp(pNewEmbed, L"Key1", 1);  // This overlap should succeed since its an embedded object!
                    vTemp.vt = VT_UNKNOWN;
                    V_UNKNOWN(&vTemp) = (IUnknown *)pNewEmbed;

                    SetIntProp(pInst1, L"Key1", 3);
                    hr = pInst1->Put(L"object", NULL, &vTemp, CIM_OBJECT);

                    GetLocalTime(&tStartTime);
                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pInst1, 0, 0, NULL);
                    GetLocalTime(&tEndTime);
                    RecordResult(hr, L"IWmiDbSession::PutObject - embedded object (AllDatatypes1=3.object)", GetDiff(tEndTime,tStartTime));

                    pParent->Release();
                    pObj->Release();

                    VariantClear(&vTemp);

                    hr = GetObject(pScope, L"AllDatatypes1=3", WMIDB_HANDLE_TYPE_COOKIE, 16, &pParent, &pObj);
                    RecordResult(hr, L"Retrieving AllDatatypes1=3", 0);
                    if (SUCCEEDED(hr))
                    {
                        hr = pObj->Get(L"object", NULL, &vTemp, NULL, NULL);
                        if (SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTemp = NULL;
                            if (vTemp.vt == VT_UNKNOWN)
                            {
                                pTemp = (IWbemClassObject *)V_UNKNOWN(&vTemp);
                                RecordResult(ValidateProperty(pTemp, L"Key1", CIM_UINT32, 1), L"Validating property AllDatatypes1=3.object.Key1", 0);
                                RecordResult(ValidateProperty(pTemp, L"__Class", CIM_STRING, L"Parent1"), 
                                    L"Validating property AllDatatypes1=3.object.__Class", 0);
                                VariantClear(&vTemp);
                            }
                            else
                                RecordResult(WBEM_E_FAILED, L"Embedded object property is IUnknown * (AllDatatypes1=3.object)", 0);
                        }
                        else
                            RecordResult(hr, L"IWbemClassObject::Get (AllDatatypes1=3.object)", 0);

                        pParent->Release();
                        pObj->Release();
                    }
                }
                pInst1->Release();
            }

            // Also, an instance with an embedded object of an unknown class 

            hr = pClass->SpawnInstance(0, &pInst1);
            if (SUCCEEDED(hr))
            {
                IWmiDbHandle *pParent = NULL;
                IWbemClassObject *pObj = NULL;
                
                hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                        IID_IWbemClassObject, (void **)&pObj);

                if (SUCCEEDED(hr))
                {
                    SetStringProp(pObj, L"Key1", NULL, TRUE);
                    SetStringProp(pObj, L"__Class", L"BrandNew");

                    IWbemClassObject *pNewEmbed = NULL;
                    VARIANT vTemp;
                    VariantInit(&vTemp);

                    pObj->SpawnInstance(0, &pNewEmbed);
                    SetStringProp(pNewEmbed, L"Key1", L"XXX");  // This overlap should succeed since its an embedded object!
                    vTemp.vt = VT_UNKNOWN;
                    V_UNKNOWN(&vTemp) = (IUnknown *)pNewEmbed;

                    SetIntProp(pInst1, L"Key1", 4);
                    hr = pInst1->Put(L"object", NULL, &vTemp, CIM_OBJECT);

                    GetLocalTime(&tStartTime);
                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pInst1, 0, 0, NULL);
                    GetLocalTime(&tEndTime);
                    RecordResult(hr, L"IWmiDbSession::PutObject - embedded object of undefined class (AllDatatypes1=4) ", GetDiff(tEndTime,tStartTime));

                    pObj->Release();

                    VariantClear(&vTemp);

                    hr = GetObject(pScope, L"AllDatatypes1=4", WMIDB_HANDLE_TYPE_COOKIE, 16, &pParent, &pObj);
                    RecordResult(hr, L"Retrieving AllDatatypes1=4", 0);
                    if (SUCCEEDED(hr))
                    {
                        hr = pObj->Get(L"object", NULL, &vTemp, NULL, NULL);
                        if (SUCCEEDED(hr))
                        {
                            IWbemClassObject *pTemp = NULL;
                            if (vTemp.vt == VT_UNKNOWN)
                            {
                                pTemp = (IWbemClassObject *)V_UNKNOWN(&vTemp);
                                RecordResult(ValidateProperty(pTemp, L"Key1", CIM_STRING, L"XXX"), L"Validating property AllDatatypes1=4.object.Key1", 0);
                                RecordResult(ValidateProperty(pTemp, L"__Class", CIM_STRING, L"BrandNew"), 
                                    L"Validating property AllDatatypes1=3.object.__Class", 0);
                                VariantClear(&vTemp);
                            }
                            else
                                RecordResult(WBEM_E_FAILED, L"Embedded object property is IUnknown * (AllDatatypes1=4.object)", 0);
                        }
                        else
                            RecordResult(hr, L"IWbemClassObject::Get (AllDatatypes1=4.object)", 0);

                        pParent->Release();
                        pObj->Release();
                    }
                }
                pInst1->Release();
            }

            pClass->Release();
        }
        pRet->Release();
    }

    // Class with arrays and blobs.  Test updates and default data.

    hr = CreateClass(&pRet, pSession, pScope, L"Arrays1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Arrays1", 0);
    if (SUCCEEDED(hr))
    {
        BSTR sTemp;
        IWbemClassObject *pClass = NULL;
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass);
        if (SUCCEEDED(hr))
        {
            // A blob with no default value.

            pClass->Put(L"Blob1", NULL, NULL, CIM_UINT8|CIM_FLAG_ARRAY);

            VARIANT vValue;
            VariantInit(&vValue);

            // A 32-bit int array with default 101,2,5000

            long why[1];                        
            DWORD t;
            SAFEARRAYBOUND aBounds[1];
            aBounds[0].cElements = 3; // 3 elements to start.
            aBounds[0].lLbound = 0;
            SAFEARRAY* pArray = SafeArrayCreate(VT_I4, 1, aBounds);                            
            why[0] = 0;
            t = 101;
            SafeArrayPutElement(pArray, why, &t);                            
            why[0] = 1;
            t = 2;
            SafeArrayPutElement(pArray, why, &t);                            
            why[0] = 2;
            t = 5000;
            SafeArrayPutElement(pArray, why, &t);                            
            vValue.vt = VT_ARRAY|VT_I4;
            V_ARRAY(&vValue) = pArray;

            pClass->Put(L"Uint32Array1", NULL, &vValue, CIM_UINT32|CIM_FLAG_ARRAY);
            VariantClear(&vValue);

            // A string array with default A,B,C
            
            pArray = SafeArrayCreate(VT_BSTR, 1, aBounds);
            why[0] = 0;
            sTemp = SysAllocString(L"A");
            hr = SafeArrayPutElement(pArray, why, sTemp);
            why[0] = 1;
            sTemp = SysAllocString(L"B");
            SafeArrayPutElement(pArray, why, sTemp);
            why[0] = 2;
            sTemp = SysAllocString(L"C");
            SafeArrayPutElement(pArray, why, sTemp);
            vValue.vt = VT_ARRAY|VT_BSTR;
            V_ARRAY(&vValue) = pArray;
            hr = pClass->Put(L"StringArray1", NULL, &vValue, CIM_STRING|CIM_FLAG_ARRAY);
            VariantClear(&vValue);

            // An object array with no default.

            pClass->Put(L"ObjectArray1", NULL, NULL, CIM_OBJECT | CIM_FLAG_ARRAY);

            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, 0, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::PutObject - uint8, uint32, string arrays (Arrays1)", GetDiff(tEndTime,tStartTime));
            VariantClear(&vValue);

            // Create an instance that populates the blob data.  Verify that the defaults are OK.

            IWbemClassObject *pInst = NULL;
            pClass->SpawnInstance(0, &pInst);
            if (pInst)
            {
                SetIntProp(pInst, L"Key1", 1);

                // Create some blob data  (100,200,0)

                unsigned char t1;
                pArray = SafeArrayCreate(VT_UI1, 1, aBounds);
                why[0] = 0;
                t1 = 100;
                SafeArrayPutElement(pArray, why, &t1);
                why[0] = 1;
                t1 = 200;
                SafeArrayPutElement(pArray, why, &t1);
                why[0] = 2;
                t1 = 0;
                SafeArrayPutElement(pArray, why, &t1);
                V_ARRAY(&vValue) = pArray;
                vValue.vt = VT_ARRAY|VT_UI1;
                hr = pInst->Put(L"Blob1", NULL, &vValue, CIM_FLAG_ARRAY|CIM_UINT8);
                VariantClear(&vValue);

                // Create an embedded object 

                aBounds[0].cElements = 1;
                pArray = SafeArrayCreate(VT_UNKNOWN, 1, aBounds);
                why[0] = 0;

                IWmiDbHandle *pParent = NULL;
                IWbemClassObject *pObj1 = NULL;
                hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pParent, &pObj1);
                RecordResult(hr, L"Retrieving Parent1", 0);
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject *pNewEmbed = NULL;
                    VARIANT vTemp;
                    VariantInit(&vTemp);

                    pObj1->SpawnInstance(0, &pNewEmbed);
                    SetIntProp(pNewEmbed, L"Key1", 1);  // This overlap should succeed since its an embedded object!
                   
                    SafeArrayPutElement(pArray, why, pNewEmbed);
                    V_ARRAY(&vValue) = pArray;
                    vValue.vt = VT_ARRAY|VT_UNKNOWN;
                    hr = pInst->Put(L"ObjectArray1", NULL, &vValue, CIM_FLAG_ARRAY|CIM_OBJECT);
                    VariantClear(&vValue);
                    pParent->Release();
                    pObj1->Release();
                }
                
                // Override the default on the string array (C,B)

                aBounds[0].cElements = 2; // Removing one...
                pArray = SafeArrayCreate(VT_BSTR, 1, aBounds);
                why[0] = 0;
                sTemp = SysAllocString(L"C");
                SafeArrayPutElement(pArray, why, sTemp);
                why[0] = 1;
                sTemp = SysAllocString(L"B");
                SafeArrayPutElement(pArray, why, sTemp);
                vValue.vt = VT_ARRAY|VT_BSTR;
                V_ARRAY(&vValue) = pArray;
                hr = pInst->Put(L"StringArray1", NULL, &vValue, CIM_STRING|CIM_FLAG_ARRAY);
                VariantClear(&vValue);
                
                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pInst, 0, 0, NULL);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"IWmiDbSession::PutObject - blob data (Arrays1=1)", GetDiff(tEndTime,tStartTime));
                VariantClear(&vValue);
                pInst->Release();

                if (SUCCEEDED(hr))
                {
                    // Now verify all the individual elements:

                    IWbemClassObject *pObj = NULL;
                    IWmiDbHandle *pHandle = NULL;
                    GetLocalTime(&tStartTime);
                    hr = GetObject(pScope, L"Arrays1=1", WMIDB_HANDLE_TYPE_COOKIE, 5, &pHandle, &pObj);
                    GetLocalTime(&tEndTime);
                    RecordResult(hr, L"IWmiDbSession::GetObject - array instance (Arrays1=1)", GetDiff(tEndTime,tStartTime));
                    if (SUCCEEDED(hr))
                    {
                        // Blob1 should be 100,200,0 - in that order.

                        hr = pObj->Get(L"Blob1", NULL, &vValue, NULL, NULL);
                        if (SUCCEEDED(hr) && (vValue.vt == (VT_ARRAY|VT_UI1)))
                        {
                            BYTE temp1=0, temp2=0, temp3=0;
                            pArray = V_ARRAY(&vValue);
                            if (pArray)
                            {
                                long lTemp=0;
                                SafeArrayGetElement(pArray, &lTemp, &temp1);
                                lTemp = 1;
                                SafeArrayGetElement(pArray, &lTemp, &temp2);
                                lTemp = 2;
                                SafeArrayGetElement(pArray, &lTemp, &temp3);

                            }
                            RecordResult((temp1==100 && temp2==200 && temp3==0)?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                                L"Validating Arrays1=1.object value (100,200,0)", 0);
                        }
                        else
                            RecordResult(WBEM_E_FAILED, L"IWbemClassObject::Get  (Arrays1=1.blob1)", 0);
                        VariantClear(&vValue);

                        // Uint32Array1 should be 101,2,5000

                        hr = pObj->Get(L"Uint32Array1", NULL, &vValue, NULL, NULL);
                        if (SUCCEEDED(hr) && vValue.vt == (VT_ARRAY|VT_I4))
                        {
                            DWORD temp1=0, temp2=0, temp3=0;
                            pArray = V_ARRAY(&vValue);
                            if (pArray)
                            {
                                long lUBound = 0;
                                SafeArrayGetUBound(pArray, 1, &lUBound);
                                if (lUBound != 2)
                                    RecordResult(WBEM_E_FAILED, L"Validating correct number of array elements (Arrays1=1.Uint32Array1)",0);
                                else
                                {
                                    long lTemp=0;
                                    SafeArrayGetElement(pArray, &lTemp, &temp1);
                                    lTemp = 1;
                                    SafeArrayGetElement(pArray, &lTemp, &temp2);
                                    lTemp = 2;
                                    SafeArrayGetElement(pArray, &lTemp, &temp3);
                                }
                            }
                            RecordResult((temp1==101 && temp2==2 && temp3==5000)?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                                L"Validating Arrays1=1.Uint32Array1 default value (101,2,5000)", 0);
                        }
                        else
                            RecordResult(WBEM_E_FAILED, L"IWbemClassObject::Get  (Arrays1=1.Uint32Array1)", 0);
                        VariantClear(&vValue);

                        // Object Array 1 should contain Parent1=1

                        hr = pObj->Get(L"ObjectArray1", NULL, &vValue, NULL, NULL);
                        if (SUCCEEDED(hr) && vValue.vt == (VT_ARRAY|VT_UNKNOWN))
                        {
                            pArray = V_ARRAY(&vValue);
                            if (pArray)
                            {
                                long lTemp = 0;
                                long lUBound = 0;
                                IUnknown *pUnk = NULL;

                                SafeArrayGetUBound(pArray, 1, &lUBound);
                                if (lUBound != 0)
                                    RecordResult(WBEM_E_FAILED, L"Validating correct number of array elements (Arrays1=1.ObjectArray1)", 0);

                                SafeArrayGetElement(pArray, &lTemp, &pUnk);

                                if (pUnk)
                                {
                                    IWbemClassObject *pObj = NULL;
                                    pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
                                    if (pObj)
                                    {
                                        RecordResult(ValidateProperty(pObj, L"__Class", CIM_STRING, L"Parent1"), L"Validating Arrays1=1.ObjectArray1.__Class", 0);
                                        RecordResult(ValidateProperty(pObj, L"Key1", CIM_UINT32, 1), L"Validating Arrays1=1.ObjectArray1.__Class", 0);

                                        pObj->Release();
                                    }
                                }
                                else
                                    RecordResult(WBEM_E_FAILED, L"Validating object array element (Arrays1=1.ObjectArray1)", 0);
                            }
                            VariantClear(&vValue);
                        }
                        else
                            RecordResult(WBEM_E_FAILED, L"IWbemClassObject::Get  (Arrays1=1.ObjectArray1)", 0);

                        // The string array should be C,B

                        hr = pObj->Get(L"StringArray1", NULL, &vValue, NULL, NULL);
                        if (SUCCEEDED(hr) && vValue.vt == (VT_ARRAY|VT_BSTR))
                        {
                            BSTR sTemp1 = NULL, sTemp2 = NULL;

                            pArray = V_ARRAY(&vValue);
                            if (pArray)
                            {
                                long lTemp = 0;
                                long lUBound = 0;
                                SafeArrayGetUBound(pArray, 1, &lUBound);
                                if (lUBound != 1)
                                    RecordResult(WBEM_E_FAILED, L"Validating size of overridden instance array Arrays1=1.StringArray1 ", 0);

                                SafeArrayGetElement(pArray, &lTemp, &sTemp1);
                                lTemp = 1;
                                SafeArrayGetElement(pArray, &lTemp, &sTemp2);
                            }
                            if (sTemp1 && sTemp2)
                            {
                                RecordResult((!_wcsicmp(L"C",sTemp1) && !_wcsicmp(L"B",sTemp2))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                                    L"Validating Arrays1=1.StringArray1 value ('C','B')",0);
                            }

                            if (sTemp1) SysFreeString(sTemp1);
                            if (sTemp2) SysFreeString(sTemp2);
                        }
                        else
                            RecordResult(WBEM_E_FAILED, L"IWbemClassObject::Get (Arrays1=1.StringArray1", 0);
                        VariantClear(&vValue);
                        pObj->Release();
                        pHandle->Release();
                    }
                }
            }
        }

        pRet->Release();
    }
          
    // Supported qualifier properties:
    // * [sint32]     * real64    * [boolean] * [string]
    
    hr = CreateClass(&pRet, pSession, pScope, L"Qualifiers1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Qualifiers1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pClass = NULL;
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pClass);
        if (SUCCEEDED(hr))
        {
            IWbemQualifierSet *pQfr = NULL;
            pClass->GetQualifierSet(&pQfr);
            if (pQfr)
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.vt = VT_R8;
                V_R8(&vTemp) = 123456.789;
                hr = pQfr->Put(L"RealQfr", &vTemp, 3);
                VariantClear(&vTemp);
                if (SUCCEEDED(hr))
                {
                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pClass, 0, 0, NULL);
                    RecordResult(hr, L"IWmiDbSession::PutObject - class with real64 qualifier (Qualifiers1)", 0);
                    if (SUCCEEDED(hr))
                    {
                        IWmiDbHandle *pNewHand = NULL;
                        IWbemClassObject *pNewObj = NULL;
                        hr = GetObject(pScope, L"Qualifiers1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pNewHand, &pNewObj);
                        RecordResult(hr, L"Retrieving Qualifiers1", 0);
                        if (SUCCEEDED(hr))
                        {
                            pNewObj->GetQualifierSet(&pQfr);
                            if (pQfr)
                            {
                               hr = pQfr->Get(L"RealQfr", NULL, &vTemp, NULL);
                               RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_R8 && vTemp.dblVal != 0)?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                                   L"Validating Real64 qualifier (Qualifiers1.RealQfr)", 0);
                               VariantClear(&vTemp);
                            }
                            pNewHand->Release();
                            pNewObj->Release();

                        }
                        else
                            RecordResult(WBEM_E_FAILED, L"Retrieving class Qualifiers1", 0);
                    }
                }
                VariantClear(&vTemp);
                pQfr->Release();
            }
            pClass->Release();
        }
        pRet->Release();
    }

    return hr;

}
// *****************************************************

HRESULT TestSuiteFunctionality::UpdateObjects()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    IWmiDbHandle *pRet = NULL;
    IWbemClassObject *pObj = NULL;

    // Verify that the update only flag works.

    hr = GetObject(pScope, L"Child1=1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pRet, &pObj);
    RecordResult(hr, L"Retrieving Child1=1", 0);
    if (SUCCEEDED(hr))
    {
        SetStringProp(pObj, L"Prop1", L"ZXYWVU");

        GetLocalTime(&tStartTime);
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, WBEM_FLAG_UPDATE_ONLY, 0, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::PutObject - update only (Child1=1)", GetDiff(tEndTime,tStartTime));

        // Updating keys should create another instance.  Both should be retrievable.

        SetIntProp(pObj, L"Key1", 3);
        GetLocalTime(&tStartTime);
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::PutObject - changing keys (Child1=3)", GetDiff(tEndTime,tStartTime));

        pRet->Release();
        pObj->Release();

        GetLocalTime(&tStartTime);
        hr = GetObject(pScope, L"Child1=1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pRet, &pObj);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::GetObject (Child1=1)", GetDiff(tEndTime,tStartTime));

        GetLocalTime(&tStartTime);
        hr = GetObject(pScope, L"Child1=3", WMIDB_HANDLE_TYPE_COOKIE, 2, &pRet, &pObj);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::GetObject (Child1=3)", GetDiff(tEndTime,tStartTime));
    }

    // Updating a class should work if we didn't change anything.
    
    hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pObj);
    if (SUCCEEDED(hr))
    {
        GetLocalTime(&tStartTime);
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, WBEM_FLAG_UPDATE_ONLY, 0, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::PutObject - update populated class with no changes, retrieved (Parent1)", GetDiff(tEndTime,tStartTime));
        pRet->Release();
        pObj->Release();
    }

    hr = CreateClass(NULL, pSession,pScope, L"Parent1", NULL, CIM_UINT32);
    RecordResult(hr, L"IWmiDbSession::PutObject - update populated class with no changes, cocreated (Parent1)", GetDiff(tEndTime,tStartTime));

    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, L"Child1=1", WMIDB_HANDLE_TYPE_COOKIE, 2, &pRet, &pObj);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"IWmiDbSession::GetObject (Child1=1) following parent update.", GetDiff(tEndTime,tStartTime));

    // Create a new class with instances and default data, and try the acceptable conversions  (numeric, no loss of precision)

    hr = CreateClass(&pRet, pSession, pScope, L"Convert1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Convert1", 0);
    if (SUCCEEDED(hr))
    {
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
        if (SUCCEEDED(hr))
        {
            SetIntProp(pObj, L"Uint8ToSint8", 10, FALSE, CIM_UINT8);
            SetIntProp(pObj, L"Sint8ToSint16", 20, FALSE, CIM_SINT8);
            SetIntProp(pObj, L"Sint16ToUint32", 30, FALSE, CIM_SINT16);
            SetIntProp(pObj, L"Uint32ToReal32", 40, FALSE, CIM_UINT32);

            VARIANT vTemp;
            VariantInit(&vTemp);
            V_R4(&vTemp) = (float)1.2;
            vTemp.vt = VT_R4;
            pObj->Put(L"Real32ToReal64", NULL, &vTemp, NULL);
            VariantClear(&vTemp);

            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
            if (SUCCEEDED(hr))
            {
                SetIntProp(pObj, L"Uint8ToSint8", 11, FALSE, CIM_SINT8);
                SetIntProp(pObj, L"Sint8ToSint16", 21, FALSE, CIM_SINT16);
                SetIntProp(pObj, L"Sint16ToUint32", 31, FALSE, CIM_UINT32);
                hr = pObj->Delete(L"Uint32ToReal32");
                V_R4(&vTemp) = 41;
                vTemp.vt = VT_R4;
                pObj->Put(L"Uint32ToReal32", NULL, &vTemp, CIM_REAL32);
                VariantClear(&vTemp);
                V_R8(&vTemp) = 11.2;
                vTemp.vt = VT_R8;
                pObj->Put(L"Real32ToReal64", NULL, &vTemp, CIM_REAL64);
                VariantClear(&vTemp);

                GetLocalTime(&tStartTime);
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
                GetLocalTime(&tEndTime);
                RecordResult(hr, L"IWmiDbSession::PutObject - converting numeric types (Convert1=1)", GetDiff(tEndTime,tStartTime));

                // Create an instance with only default data.
                hr = CreateInstance(NULL, pSession, pScope, L"Convert1", L"1", CIM_UINT32);
                RecordResult(hr, L"Creating instance Convert1=1", 0);

                if (SUCCEEDED(hr))
                {
                    // Verify that the conversion worked...

                    IWmiDbHandle *pTemp = NULL;
                    IWbemClassObject *pTempObj = NULL;
                    hr = GetObject(pScope, L"Convert1=1", WMIDB_HANDLE_TYPE_COOKIE, 6, &pTemp, &pTempObj);
                    RecordResult(hr, L"Retrieving Convert1=1", 0);
                    if (SUCCEEDED(hr))
                    {
                        RecordResult(ValidateProperty(pTempObj, L"Uint8ToSint8", CIM_SINT8, 11), L"Validating Convert1.Uint8ToSint8", 0);
                        RecordResult(ValidateProperty(pTempObj, L"Sint8ToSint16", CIM_SINT16, 21), L"Validating Convert1.Sint8ToSint16", 0);
                        RecordResult(ValidateProperty(pTempObj, L"Sint16ToUint32", CIM_UINT32, 31), L"Validating Convert1.Sint16ToUint32", 0);
                        RecordResult(ValidateProperty(pTempObj, L"Uint32ToReal32", CIM_REAL32, 41), L"Validating Convert1.Uint32ToReal32", 0);

                        pTempObj->Get(L"Real32ToReal64", 0, &vTemp, NULL, NULL);
                        RecordResult((vTemp.vt == VT_R8 && vTemp.dblVal == 11.2), L"Validating Convert1=1.Real32ToReal64", 0);

                        pTemp->Release();
                        pTempObj->Release();
                        VariantClear(&vTemp);
                    }
                }
            }

            pObj->Release();
        }
        pRet->Release();
    }

    // Now retrieve a child object from the cache, and make sure
    // that an update to the parent object wipes out the cached child object.

    hr = CreateClass(&pRet, pSession, pScope, L"NestedCache", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class NestedCache", 0);
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pChildClass = NULL, *pChildInst = NULL;
        hr = CreateClass(&pChildClass, pSession, pScope, L"NestedCacheChild", NULL, CIM_UINT32, L"NestedCache", 
            NULL, NULL, WMIDB_HANDLE_TYPE_STRONG_CACHE);
        RecordResult(hr, L"Creating class NestedCacheChild", 0);
        if (SUCCEEDED(hr))
        {
            hr = CreateInstance(&pChildInst, pSession, pScope, L"NestedCacheChild", L"1", CIM_UINT32, 
                NULL, NULL, WMIDB_HANDLE_TYPE_STRONG_CACHE);
            RecordResult(hr, L"Creating instance NestedCacheChild1=1", 0);
            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pChildClassObj = NULL, *pChildInstObj = NULL, *pParentObj = NULL;

                // Instantiate both the instance and the child class, and release.

                hr = pChildClass->QueryInterface(IID_IWbemClassObject, (void **)&pChildClassObj);
                hr = pChildInst->QueryInterface(IID_IWbemClassObject, (void **)&pChildInstObj);

                if (pChildClassObj) pChildClassObj->Release();
                if (pChildInstObj) pChildInstObj->Release();

                // If we add a property to the parent class, it should 
                // show up in both the child and instance, if we instantiate them.

                hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pParentObj);
                if (SUCCEEDED(hr))
                {
                    SetIntProp(pParentObj, L"ParentProperty", 1);
                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pParentObj, 0, 0, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = pChildClass->QueryInterface(IID_IWbemClassObject, (void **)&pChildClassObj);
                        if (SUCCEEDED(hr))
                        {
                            RecordResult(pChildClassObj->Get(L"ParentProperty", 0, NULL, NULL, NULL), L"Updating parent object refreshes/updates cached child class", 0);
                            pChildClassObj->Release();
                        }
                        hr = pChildInst->QueryInterface(IID_IWbemClassObject, (void **)&pChildInstObj);
                        if (SUCCEEDED(hr))
                        {
                            RecordResult(pChildInstObj->Get(L"ParentProperty", 0, NULL, NULL, NULL), L"Updating parent object refreshes/updates cached child class instance", 0);
                            pChildInstObj->Release();
                        }
                    }
                    pParentObj->Release();
                }

                pChildInst->Release();
            }
            pChildClass->Release();
        }
        pRet->Release();
    }

    // Verify Rename functions.

    hr = CreateClass(NULL, pSession, pScope, L"Rename1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Rename1", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateInstance(NULL, pSession, pScope, L"Rename1", L"1", CIM_UINT32);
        RecordResult(hr, L"Creating instance Rename1=1", 0);
        if (SUCCEEDED(hr))
        {
            IWbemPath*pPath1, *pPath2;
            hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemPath, (void **)&pPath1); 
            hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemPath, (void **)&pPath2); 
            
            // Rename key values.

            pPath1->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"test:Rename1=1");
            pPath2->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"test:Rename1=2");
            hr = pSession->RenameObject(pPath1, pPath2, 0, 0, NULL);
            RecordResult(hr, L"RenameObject (test:Rename1=1 -> Rename1=2)", 0);

            if (SUCCEEDED(hr))
            {
                // Rename scope.

                pPath1->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"test:Rename1=2");
                pPath2->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"test:Child1=1:Rename1=2");
                hr = pSession->RenameObject(pPath1, pPath2, 0, 0, NULL);
                RecordResult(hr, L"RenameObject (test:Rename1=2 -> test:Child1=1:Rename1=2)", 0, 0, NULL);
            }
            pPath1->Release();
            pPath2->Release();
        }
    }

    return hr;

}
// *****************************************************

HRESULT TestSuiteFunctionality::ChangeHierarchy()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;


    // Adding an existing class to a parent should work, as long
    //   as it doesn't change the key.

    hr = CreateClass(NULL, pSession, pScope, L"Child2", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class Child2", 0);
    if (SUCCEEDED(hr))
    {
        bool bSuccess = false;

        GetLocalTime(&tStartTime);
        hr = CreateClass(NULL, pSession, pScope, L"Child2", NULL, CIM_UINT32, L"Parent1");
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::PutObject - add new parent (Child2:Parent1)", GetDiff(tEndTime,tStartTime));
        if (SUCCEEDED(hr))
            bSuccess = true;

        // Changing the parent of a class should work if the key is the same.

        GetLocalTime(&tStartTime);
        hr = CreateClass(NULL, pSession, pScope, L"Child2", NULL, CIM_UINT32, L"Child1");
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbSession::PutObject - change parent (Child2:Child1)", GetDiff(tEndTime,tStartTime));

        // Removing the parent of a class should work if the key is the same.
        if (bSuccess)
        {
            GetLocalTime(&tStartTime);
            hr = CreateClass(NULL, pSession, pScope, L"Child2", NULL, CIM_UINT32);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::PutObject - remove parent (Child2)", GetDiff(tEndTime,tStartTime));
        }
    }

    GetLocalTime(&tEndTime);
    

    return hr;

}

// *****************************************************

HRESULT TestSuiteFunctionality::VerifyContainers()
{
    HRESULT hr = 0;
    wchar_t wTmp[128];
    SYSTEMTIME tStartTime, tEndTime;

    for (int i = 101; i <= 200; i++)
    {
        swprintf(wTmp, L"%ld", i);
        hr = CreateInstance(NULL, pSession, pScope, L"Parent1", wTmp, CIM_UINT32);
    }

    IWbemPath*pPath = NULL;
    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
        IID_IWbemPath, (void **)&pPath); 

    hr = CreateClass(NULL, pSession, pScope, L"Container1", NULL, CIM_STRING);
    RecordResult(hr, L"Creating class Container1", 0);
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pContainer = NULL;
        hr = CreateInstance (&pContainer, pSession, pScope, L"Container1", L"Stuff", CIM_STRING,
            NULL, NULL, WMIDB_HANDLE_TYPE_CONTAINER);
        RecordResult(hr, L"Creating instance Container1='Stuff'", 0);
        if (SUCCEEDED(hr))
        {
            for (i = 101; i <= 200; i++)
            {
                swprintf(wTmp, L"test:Parent1=%ld", i);
                pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wTmp);
                hr = pSession->AddObject(pContainer, pPath, 0, 0, NULL);
                RecordResult(hr, L"Adding %s to Container1='Stuff'", 0, wTmp);
                if (FAILED(hr))
                    break;
            }

            for (i = 180; i <= 200; i++)
            {
                swprintf(wTmp, L"test:Parent1=%ld", i);
                pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wTmp);
                hr = pSession->RemoveObject(pContainer, pPath, 0);
                RecordResult(hr, L"Removing %s from Container1='Stuff'", 0, wTmp);
                if (FAILED(hr))
                    break;
            }

            IWmiDbIterator *pIt = NULL;
            hr = pSession->Enumerate(pContainer, 0, WMIDB_HANDLE_TYPE_COOKIE, &pIt);
            RecordResult(hr, L"Enumerating Container1='Stuff'", 0);
            if (SUCCEEDED(hr))
            {
                // Iterator
                int iNum = 100;
                DWORD dwNumRet = 0;
                IUnknown **ppHandle = new IUnknown *[iNum];

                GetLocalTime(&tStartTime);
                hr = pIt->NextBatch(iNum, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);
                GetLocalTime(&tEndTime);

                RecordResult(hr, L"IWmiDbIterator::NextBatch (%ld results) ", GetDiff(tEndTime,tStartTime), dwNumRet);
                for (int j = 0; j < (int)dwNumRet; j++)
                    ppHandle[j]->Release();
                
                delete ppHandle;
                if (pIt)
                    pIt->Release();
            }

            IWbemQuery *pQuery = NULL;

            hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
            if (SUCCEEDED(hr))
            {
                pQuery->Parse(L"SQL", L"select * from Parent1 where Key1 < 100", 0);
                hr = pSession->ExecQuery(pContainer, pQuery, WMIDB_FLAG_QUERY_SHALLOW, 
                    WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt);
                RecordResult(hr, L"Executing SHALLOW query select * from Parent1 where Key1 < 100 scoped to Container1='Stuff'", 0);
                if (SUCCEEDED(hr))
                {
                    // Iterator
                    int iNum = 10;
                    DWORD dwNumRet = 0;
                    IUnknown **ppHandle = new IUnknown *[iNum];

                    GetLocalTime(&tStartTime);
                    hr = pIt->NextBatch(iNum, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);
                    GetLocalTime(&tEndTime);

                    if (dwNumRet != 0)
                        RecordResult(WBEM_E_FAILED, L"Shallow query scoped to Container1='Stuff' returns results.", 0);

                    for (int j = 0; j < (int)dwNumRet; j++)
                        ppHandle[j]->Release();
                
                    delete ppHandle;
                    if (pIt)
                        pIt->Release();
                }

                pQuery->Parse(L"SQL", L"select * from Parent1 where Key1 <= 200", 0);
                hr = pSession->ExecQuery(pContainer, pQuery, WMIDB_FLAG_QUERY_DEEP, 
                    WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt);
                RecordResult(hr, L"Executing DEEP query select * from Parent1 where Key1 <= 200 scoped to Container1='Stuff'", 0);
                if (SUCCEEDED(hr))
                {
                    // Iterator
                    int iNum = 10;
                    DWORD dwNumRet = 0;
                    IUnknown **ppHandle = new IUnknown *[iNum];

                    GetLocalTime(&tStartTime);
                    hr = pIt->NextBatch(iNum, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);
                    GetLocalTime(&tEndTime);

                    if (dwNumRet == 0)
                        RecordResult(WBEM_E_FAILED, L"Deep query scoped to Container1='Stuff' returns no results.", 0);

                    for (int j = 0; j < (int)dwNumRet; j++)
                        ppHandle[j]->Release();
                
                    delete ppHandle;
                    if (pIt)
                        pIt->Release();
                }

                pQuery->Parse(L"SQL", L"references of {test:Parent1=101}", 0);
                hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_VERSIONED, NULL, &pIt);
                RecordResult(hr, L"Executing query references of {Parent1=101} ", 0);
                if (SUCCEEDED(hr))
                {
                    // Iterator
                    int iNum = 10;
                    DWORD dwNumRet = 0;
                    IUnknown **ppHandle = new IUnknown *[iNum];

                    GetLocalTime(&tStartTime);
                    hr = pIt->NextBatch(iNum, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);
                    GetLocalTime(&tEndTime);

                    if (dwNumRet == 0)
                        RecordResult(WBEM_E_FAILED, L"References of query scoped to container returns no results.", 0);

                    for (int j = 0; j < (int)dwNumRet; j++)
                        ppHandle[j]->Release();
                
                    delete ppHandle;
                    if (pIt)
                        pIt->Release();
                }

            }
            else
                RecordResult(WBEM_E_FAILED, L"CoCreateInstance (IWbemQuery) failed.  Tests skipped", 0);

            pContainer->Release();
        }

        // Special case; The __Instances container

        IWmiDbHandle *pRet = NULL;
        IWbemClassObject *pObj = NULL;

        hr = GetObject(pScope, L"__Instances=\"Parent1\"", WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_CONTAINER, -1, &pRet, &pObj);
        RecordResult(hr, L"Retrieving __Instances of Parent1", 0);
        if (SUCCEEDED(hr))
        {
            // Add and remove should fail regardless.
            // Enumeration should retrieve all instances of this class

            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=101");
            hr = pSession->AddObject(pRet, pPath, 0, 0, NULL);
            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR,
                L"Verifying AddObject fails for __Instances container", 0);

            hr = pSession->RemoveObject(pRet, pPath, 0);
            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR,
                L"Verifying RemoveObject fails for __Instances container", 0);

            IWmiDbIterator *pIt;
            hr = pSession->Enumerate(pRet, 0, WMIDB_HANDLE_TYPE_COOKIE, &pIt);
            if (SUCCEEDED(hr))
            {
                // Iterator
                int iNum = 100;
                DWORD dwNumRet = 0;
                IUnknown **ppHandle = new IUnknown *[iNum];

                GetLocalTime(&tStartTime);
                hr = pIt->NextBatch(iNum, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);
                GetLocalTime(&tEndTime);

                if (!dwNumRet)
                    RecordResult(WBEM_E_FAILED, L"IWmiDbIterator::NextBatch (%ld results) ", GetDiff(tEndTime,tStartTime), dwNumRet);
                else
                    RecordResult(hr, L"IWmiDbIterator::NextBatch (%ld results) ", GetDiff(tEndTime,tStartTime), dwNumRet);

                for (int j = 0; j < (int)dwNumRet; j++)
                    ppHandle[j]->Release();
                
                delete ppHandle;
                if (pIt)
                    pIt->Release();
            }

            pRet->Release();
            pObj->Release();
        }

        pPath->Release();
    }

    return hr;
}

// *****************************************************

HRESULT TestSuiteFunctionality::VerifyTransactions()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    wchar_t wTmp[128];
    SYSTEMTIME tStartTime, tEndTime;
    IWmiDbHandle *pHandle = NULL;
    IWbemClassObject *pObj = NULL;
    GUID transguid;

    // Transaction 1: Begin, Insert, Insert, Commit => 2 objects
   
    IWbemTransaction *pTrans = NULL;
    hr = pSession->QueryInterface(IID_IWbemTransaction, (void **)&pTrans);
    if (FAILED(hr))
    {
        RecordResult(hr, L"Repository supports IWbemTransaction", 0);
        return hr;
    }

    // Precreate the __Transaction and __UncommittedEvent classes.

    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pObj);
    if (SUCCEEDED(hr))
    {
        SetStringProp(pObj, L"__Class", L"__Transaction");
        SetStringProp(pObj, L"GUID", L"", TRUE);
        SetStringProp(pObj, L"ClientComment", L"");
        SetStringProp(pObj, L"ClientID", L"");
        SetIntProp(pObj, L"State", 0, FALSE, CIM_UINT32);
        SetStringProp(pObj, L"Start", L"", FALSE, CIM_DATETIME);
        SetStringProp(pObj, L"LastUpdate", L"", FALSE, CIM_DATETIME);

        GetLocalTime(&tStartTime);
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating __Transaction class", GetDiff(tEndTime, tStartTime));
        pObj->Release();
    }

    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pObj);
    if (SUCCEEDED(hr))
    {
        IWbemQualifierSet *pQS = NULL;

        SetStringProp(pObj, L"__Class", L"__UncommittedEvent");
        SetIntProp(pObj, L"EventID", 0, CIM_UINT32, TRUE); 
        SetBoolQfr(pObj, L"EventID", L"keyhole");

        SetStringProp(pObj, L"TransactionGUID", L""); 
        SetBoolQfr(pObj, L"TransactionGUID", L"indexed");

        SetStringProp(pObj, L"NamespaceName", L"");
        SetStringProp(pObj, L"ClassName", L"");
        hr = pObj->Put(L"OldObject", 0, NULL, CIM_OBJECT);
        hr = pObj->Put(L"NewObject", 0, NULL, CIM_OBJECT);
        SetIntProp(pObj, L"Transacted", 1, FALSE, CIM_BOOLEAN);

        GetLocalTime(&tStartTime);
        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"Creating __UncommittedEvent class", GetDiff(tEndTime, tStartTime));
        pObj->Release();
    }

    hr = CoCreateGuid(&transguid);
    hr = pTrans->Begin(0, 0, &transguid);
    RecordResult(hr, L"IWmiDbSession::Begin", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"Trans1", NULL, CIM_UINT32);
        if (SUCCEEDED(hr))
        {
            hr = CreateInstance(NULL, pSession, pScope, L"Trans1", L"1", CIM_UINT32);
            if (SUCCEEDED(hr))
            {
                ULONG uState = 0;
                hr = pTrans->QueryState(0, &uState);
                RecordResult(uState == WBEM_TRANSACTION_STATE_PENDING? WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"QueryState returns PENDING", 0);

                hr = pTrans->Commit(0);
                RecordResult(hr, L"IWmiDbSession::Commit", 0);

                // Make sure both objects are still in the db.

                hr = GetObject(pScope, L"Trans1=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
                RecordResult(hr, L"Verifying Commit worked (creating Trans1)", 0);
                if (pHandle)
                    pHandle->Release();
                if (pObj)
                    pObj->Release();
            }
            else
                pTrans->Rollback(0);
        }
        else
            pTrans->Rollback(0);
    }

    pHandle = NULL;
    pObj = NULL;

    // Transaction 2: Begin, Insert, Delete, Commit => No object

    hr = CoCreateGuid(&transguid);
    hr = pTrans->Begin(0, 0, &transguid);
    RecordResult(hr, L"IWmiDbSession::Begin", 0);
    if (SUCCEEDED(hr))
    {        
        hr = CreateClass(&pHandle, pSession, pScope, L"Trans1", NULL, CIM_UINT32);
        if (SUCCEEDED(hr))
        {
            hr = pSession->DeleteObject(pScope, 0, IID_IWmiDbHandle, pHandle);
            if (SUCCEEDED(hr))
            {
                hr = pTrans->Commit(0);
                RecordResult(hr, L"IWmiDbSession::Commit", 0);

                // Make sure both objects are still in the db.

                hr = GetObject(pScope, L"Trans1=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
                RecordResult(FAILED(hr)?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"Verifying Commit worked (deleting Trans1)", 0);
                if (pHandle)
                    pHandle->Release();
            }
            else
                pTrans->Rollback(0);
        }
        else
            pTrans->Rollback(0);
    }

    pHandle = NULL;
/*
    // Transaction 3: Begin, Insert, Rollback => No object

    hr = CoCreateGuid(&transguid);
    hr = pTrans->Begin(0, 0, &transguid);
    RecordResult(hr, L"IWmiDbSession::Begin", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"Trans2", NULL, CIM_UINT32);
        if (SUCCEEDED(hr))
        {
            hr = pTrans->Rollback(0);
            RecordResult(hr, L"IWmiDbSession::Rollback", 0);

            // Make sure both objects are still in the db.

            hr = GetObject(pScope, L"Trans2", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHandle, &pObj);
            RecordResult(FAILED(hr)?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"Verifying Rollback worked (rollback Trans2)", 0);
            if (pHandle)
                pHandle->Release();
        }
        else
            pTrans->Rollback(0);
    }
    pTrans->Release();
    */
    return hr;
}

// *****************************************************

HRESULT TestSuiteFunctionality::Query()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    DWORD dwCompLevel = 0;
    DWORD dwNumElements = 0;

    struct TestQueries
    {
        wchar_t *pszQuery;
        DWORD   dwCompLevel;
        BOOL    bStopOnFail;
        BOOL    bResults;
    };

    // Just a few general tests...
    // 0 = select + where clause

    TestQueries tests[] = 
    {L"select * from Parent1", 0, TRUE, TRUE,
     L"select Key1, Prop1 from Child1", 0, FALSE, TRUE,
     L"select * from Parent1 where Key1 = 1", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 != 1", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 <> 1", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 > 0", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 < 0", 0,FALSE, FALSE,
     L"select * from Parent1 where Key1 >= 0", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 <= 0", 0,FALSE, FALSE,
     L"select * from Parent1 where Key1 is null", 0,FALSE, FALSE,
     L"select * from Parent1 where Key1 is not null", 0,FALSE,  TRUE,
     L"select * from Parent1 where Key1 = 0 or Key1 = 1", 0,FALSE,  TRUE,
     L"select * from Parent1 where Key1 = 1 and Key1 <> 0", 0,FALSE, TRUE,
     L"select * from Parent1 where ((Key1 = 1 or Key1 = 2) and Key1 <> 0)", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 in (1,2,3)", 0,FALSE, TRUE,
     L"select * from Parent1 where Key1 not in (0,1,2)", 0,FALSE, TRUE,
     L"select * from Child1 where Prop1 = \"ZZZ\"", 0, FALSE, FALSE,
     L"select * from Child1 where NOT Prop1 = \"ZZZ\"", 0, FALSE, TRUE,
     L"select * from Child1 where Prop1 <> \"ZZZ\"", 0, FALSE, TRUE,
     L"select * from Child1 where Prop1 not like \"ZZZ%\"", 0, FALSE, TRUE,
     L"select * from Child1 where upper(Prop1) <> \"ZZZ\"", 0, FALSE, TRUE,
     L"select * from AllDatatypes1 where datepart(mm, dt) = 12", 0, FALSE, TRUE,
     L"select * from AllDatatypes1 where datepart(yy, dt) = 2999", 0, FALSE, TRUE,

     // Property to property comparison

     L"select * from CompoundKeys1 where Key1 = Key2 ", 0, FALSE, TRUE,
     L"select * from CompoundKeys1 where Key2 > Key1 ", 0, FALSE, TRUE,
     L"select * from CompoundKeys1 where Key1 <> Key2", 0, FALSE, TRUE,
     L"select * from CompoundKeys1 where Key2 < Key1 ", 0, FALSE, FALSE,
     
     // Schema queries

     L"select * from __Instances", 0, FALSE, TRUE,
     L"select * from Parent1 where __Class = 'Child1'", 0, FALSE, TRUE,
     L"select * from Parent1 where __Genus = 2", 0, FALSE, TRUE,
     L"select * from Parent1 where __Dynasty = 'Parent1'", 0, FALSE, FALSE,
     //L"select * from Parent1 where __Derivation[0] = 'Parent1'", 0, FALSE, TRUE,
     L"select * from meta_class", 0, FALSE, TRUE,
     L"select * from meta_class where __this isa 'Parent1'", 0, FALSE, TRUE,
     L"select * from meta_class where __SuperClass = 'Parent1'", 0, FALSE, TRUE,

    // 1 = TempQL
     L"references of {Parent1=2}", 1, TRUE, TRUE,
     L"references of {Parent1}", 1, FALSE, TRUE,
     L"references of {Parent1=2} where ResultClass=Association1", 1, FALSE, TRUE,
     L"references of {Parent1=2} where RequiredQualifier=Association", 1, FALSE, TRUE,
     L"references of {Parent1=2} where Role=Key1", 1, FALSE, TRUE,
     L"references of {Parent1=2} where ClassDefsOnly", 1, FALSE, TRUE,
     L"references of {Parent1=2} where Role=Key1 RequiredQualifier=Association", 1, FALSE, TRUE,

     L"associators of {Parent1=2}", 1, TRUE, TRUE,
     L"associators of {Parent1}", 1, FALSE, TRUE,
     L"associators of {Parent1=2} where ResultClass=Child1", 1, FALSE, TRUE,
     L"associators of {Parent1=2} where AssocClass=Association1", 1, FALSE, TRUE,
     L"associators of {Parent1=2} where Role=Key1", 1, FALSE, TRUE,
     L"associators of {Parent1=2} where RequiredQualifier=Description", 1, FALSE, FALSE,
     L"associators of {Parent1=2} where RequiredAssocQualifier=Association", 1, FALSE, TRUE,
     L"associators of {Parent1=2} where ClassDefsOnly", 1, FALSE, TRUE,
     L"associators of {Parent1=2} where ResultClass=Child1 AssocClass=Association1 Role=Key1", 1, FALSE, TRUE,

    // 2 = simple joins, order by, insert/update/delete
     L"select * from Parent1 order by Key1", 2, FALSE, TRUE,
     //L"update Child1 set Prop1 = \"ABC\" where Key1= 1", 2, FALSE, FALSE,
     //L"insert into Child1 (Key1, Prop1) values (99, L\"Test\")", 2, FALSE,FALSE,
     L"delete from Child1 where Key1 = 1", 2, FALSE, FALSE,
     //L"select * from Parent1, Child1 where Parent1.Key1= Child1.Key1", 2, TRUE, TRUE,

    // 3 = SQL-92, subselects, transactions, union 
     //L"select * from Parent1 as p inner join Child1 as c on p.Key1=c.Key1", 3, TRUE, TRUE,
     //L"select * from Parent1 where Key1 between 1 and 10", 3, FALSE, TRUE,
     //L"select Key1 from Child1 where Prop1 like \"A%\"", 3,FALSE, TRUE,
     //L"select Key1 from Child1 where Prop1 not like \"A%\"", 3,FALSE,TRUE,
     //L"select * from Parent1 where Key1 in (select Key1 from Child1)", 3,FALSE, TRUE,
     //L"select * from Parent1 where Key1 not in (select Key1 from Child1)", 3,FALSE, TRUE,
     //L"select Key1 from Parent1 UNION select Key1 from Child1", 3, FALSE, TRUE,
     //L"begin transaction", 3, FALSE,FALSE,
     //L"rollback transaction", 3, FALSE, FALSE
    };

    dwNumElements = sizeof(tests) / sizeof(TestQueries);
    
    IWmiDbIterator *pIterator = NULL;
    IWbemQuery *pQuery = NULL;

    hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < (int)dwNumElements; i++)
        {
            hr = pQuery->Parse(L"SQL", tests[i].pszQuery, 0);
            if (FAILED(hr))
            {
                RecordResult(hr, L"IWbemQuery parsing %s", 0, tests[i].pszQuery);
                continue;
            }

            DWORD dwResults = 0;
            GetLocalTime(&tStartTime);
            hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, &dwResults, &pIterator);
            GetLocalTime(&tEndTime);

            RecordResult(hr, tests[i].pszQuery, GetDiff(tEndTime,tStartTime));

            if (dwResults == WBEM_REQUIREMENTS_START_POSTFILTER)
                RecordResult(hr, L"WARNING: Query must be post-filtered with this driver.", 0);
            
            if (FAILED(hr) && tests[i].bStopOnFail)
            {
                dwCompLevel = (tests[i].dwCompLevel)-1;
                break;
            }
            else if (SUCCEEDED(hr))
            {
                if (tests[i].bResults)
                {
                    // Iterator
                    int iNum = 5;
                    DWORD dwNumRet = 0;
                    IUnknown **ppHandle = new IUnknown *[iNum];

                    GetLocalTime(&tStartTime);
                    hr = pIterator->NextBatch(iNum, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);
                    GetLocalTime(&tEndTime);

                    if (FAILED(hr))
                        RecordResult(hr, L"IWmiDbIterator::NextBatch ", GetDiff(tEndTime,tStartTime));
                    else
                    {
                        if (dwNumRet == 0)
                        {
                            wprintf(L" [QUERY: %s]\n", tests[i].pszQuery);
                            RecordResult(WBEM_E_FAILED, L"IWmiDbIterator::NextBatch - results expected", GetDiff(tEndTime,tStartTime));
                        }
                    }

                    for (int j = 0; j < (int)dwNumRet; j++)
                        ppHandle[j]->Release();
                    
                    delete ppHandle;
                }
                if (pIterator)
                    pIterator->Release();
            }
        }
    }

    wchar_t wTemp[100];
    swprintf(wTemp, L"QUERY COMPLIANCE LEVEL = %ld", dwCompLevel);

    RecordResult(0, wTemp, 0);

    return hr;

}
// *****************************************************

HRESULT TestSuiteFunctionality::Batch()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    // WMIDB_FLAG_ATOMIC or WMIDB_FLAG_BEST_EFFORT

    // Put objects:

    IWmiDbHandle *pRet = NULL;
    IWbemClassObject *pClass = NULL;

    hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pClass);
    RecordResult(hr, L"Retrieving Parent1", 0);
    if (SUCCEEDED(hr))
    {
        IWmiDbBatchSession *pBatch = NULL;
        hr = pSession->QueryInterface(IID_IWmiDbBatchSession, (void **)&pBatch);        
        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pObj = NULL;
            WMIOBJECT_BATCH batch;

            batch.dwArraySize = 3;
            batch.pElements = new WMI_BATCH_OBJECT_ACCESS[3];
            for (int i = 0; i < 3; i++)
            {            
                IWbemClassObject *Obj = NULL;
                batch.pElements[i].pPath = NULL;

                pClass->SpawnInstance(0, &pObj);
                SetIntProp(pObj, L"Key1", i+4);
        
                batch.pElements[i].pHandle = pObj;            
                batch.pElements[i].dwFlags = 0;
            }

            GetLocalTime(&tStartTime);
            hr = pBatch->PutObjects(pScope, WMIDB_FLAG_ATOMIC, WMIDB_HANDLE_TYPE_COOKIE, &batch);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbBatchSession::PutObjects - atomic (Parent1=4,Parent1=5,Parent1=6)", GetDiff(tEndTime,tStartTime));

            pObj = (IWbemClassObject *)batch.pElements[0].pHandle;
            pObj->Put(L"Key1", NULL, NULL, CIM_UINT32); // nullifying a key should cause a failure, but "best effort" should succeed overall.
            pObj = (IWbemClassObject *)batch.pElements[1].pHandle;
            SetIntProp(pObj, L"Key1", 5);
            pObj = (IWbemClassObject *)batch.pElements[2].pHandle;
            SetIntProp(pObj, L"Key1", 6);

            GetLocalTime(&tStartTime);
            hr = pBatch->PutObjects(pScope, WMIDB_FLAG_BEST_EFFORT, WMIDB_HANDLE_TYPE_COOKIE, &batch);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbBatchSession::PutObjects - best effort (Parent1=null key, Parent1=5,Parent1=6)", GetDiff(tEndTime,tStartTime));
            RecordResult(FAILED(batch.pElements[0].hRes) ? WBEM_S_NO_ERROR: WBEM_E_FAILED, L"IWmiDbBatchSession::PutObjects - recorded failure "
                L" on null key (Parent1)", 0);

            if (SUCCEEDED(hr))
            {
                for (i = 0; i < 3; i++)
                {
                    if (SUCCEEDED(batch.pElements[i].hRes) && batch.pElements[i].pReturnHandle)
                        batch.pElements[i].pReturnHandle->Release();
                    batch.pElements[i].pHandle->Release();
                    batch.pElements[i].pReturnHandle = NULL;
                }
            }
            pBatch->Release();        
            delete batch.pElements;
        }

        pRet->Release();
        pClass->Release();
    }

    // Get

    IWmiDbBatchSession *pBatch = NULL;
    hr = pSession->QueryInterface(IID_IWmiDbBatchSession, (void **)&pBatch);        
    if (SUCCEEDED(hr))
    {
        IWbemPath*pPath = NULL;
        WMIOBJECT_BATCH batch;
        batch.dwArraySize = 3;
        batch.pElements = new WMI_BATCH_OBJECT_ACCESS[3];
        for (int i = 0; i < 3; i++)
        {
            batch.pElements[i].pReturnHandle = NULL;
            batch.pElements[i].dwFlags = 0;
            batch.pElements[i].pHandle = NULL;
            batch.pElements[i].hRes = 0;

            hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemPath, (void **)&pPath); 
            batch.pElements[i].pPath = pPath;
        }

        batch.pElements[0].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1");
        batch.pElements[1].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=2");
        batch.pElements[2].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Child1=1");

        GetLocalTime(&tStartTime);
        hr = pBatch->GetObjects(pScope, WMIDB_FLAG_ATOMIC, WMIDB_HANDLE_TYPE_COOKIE, &batch);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbBatchSession::GetObjects - atomic: (Parent1,Parent1=2,Child1=1)", GetDiff(tEndTime,tStartTime));

        for (i = 0; i < 3; i++)
        {
            if (SUCCEEDED(batch.pElements[i].hRes) && batch.pElements[i].pReturnHandle)
                batch.pElements[i].pReturnHandle->Release();     
            batch.pElements[i].pReturnHandle = NULL;
        }    

        batch.pElements[0].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=0");

        GetLocalTime(&tStartTime);
        hr = pBatch->GetObjects(pScope, WMIDB_FLAG_BEST_EFFORT, WMIDB_HANDLE_TYPE_COOKIE, &batch);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbBatchSession::GetObjects - best effort: (Parent1=0 (invalid),Parent1=2,Child1=1)", GetDiff(tEndTime,tStartTime));

        for (i = 0; i < 3; i++)
        {
            if (SUCCEEDED(batch.pElements[i].hRes) && batch.pElements[i].pReturnHandle)
                batch.pElements[i].pReturnHandle->Release();
        }    

        // Delete.
        
        batch.pElements[0].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"BogusClass");
        batch.pElements[1].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"AnotherBogusClass");
        batch.pElements[2].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Child1=4");

        GetLocalTime(&tStartTime);
        hr = pBatch->DeleteObjects(pScope, WMIDB_FLAG_BEST_EFFORT, &batch);
        GetLocalTime(&tEndTime);
        RecordResult(hr, L"IWmiDbBatchSession::DeleteObjects - best effort: (BogusClass, AnotherBogusClass, Child1=4)", GetDiff(tEndTime,tStartTime));

        for (i = 0; i < 3; i++)
        {
            if (i < 2)
                RecordResult(FAILED(batch.pElements[i].hRes)?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbBatchSession::DeleteObjects - expected failure code.", 0);
            batch.pElements[i].pPath->Release();
        }            
    }


    GetLocalTime(&tEndTime);
    

    return hr;

}
// *****************************************************

HRESULT TestSuiteFunctionality::Security()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    PNTSECURITY_DESCRIPTOR pDescr = NULL;   
    HANDLE hToken;
    HANDLE hThread = GetCurrentThread();

    {
        TOKEN_PRIVILEGES tp;
        LUID luid;
        HANDLE hProcHandle;
        BOOL bRet = false;

        if(OpenProcessToken(GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES,
                            &hProcHandle ))
        {
            if(!LookupPrivilegeValue(NULL, SE_TCB_NAME , &luid))

            {
                wprintf(L"Unable to lookup privilege (%ld)", GetLastError() );
                CloseHandle(hProcHandle);
            }
            else
            {

                tp.PrivilegeCount           = 1;
                tp.Privileges[0].Luid       = luid;
                tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                bRet = AdjustTokenPrivileges(hProcHandle, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
                                            NULL, NULL );

                if (!bRet)
                {
                    wprintf(L"Unable to adjust token privileges (%ld)\n", GetLastError());
                    CloseHandle(hProcHandle);
                }
                else
                {
                    wchar_t temp[400];
                    wcscpy(temp, (const wchar_t *)sLogon);
					wchar_t *pDomain = NULL;
                    wchar_t *pUser = wcschr(temp, L'\\');
					if (!pUser)
					{
						pUser = temp;
						pDomain = 0;
					}
					else
					{
						pUser++;
						pDomain = temp;
					}

                    temp[pUser-pDomain-1] = '\0';

                    if (LogonUser(pUser,pDomain, L"", LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &hToken))
                    {
                        BOOL bRet = SetThreadToken(&hThread, hToken);
                        bRet = ImpersonateLoggedOnUser(hToken);
                        bRet = true;
                    }
                    else
                    {
                        wprintf(L"Unable to logon user %s (%ld)\n", (const wchar_t *)sLogon, GetLastError());
                        CloseHandle(hProcHandle);
						bRet = FALSE;
                    }
                }
            }        
        }

        if (bRet)
        {
       
            IWmiDbHandle *pParentClass = NULL;
            IWbemClassObject *pTemp = NULL;
            hr = GetObject(pScope, L"Parent1=2", WMIDB_HANDLE_TYPE_VERSIONED|WMIDB_HANDLE_TYPE_SUBSCOPED, 1, &pParentClass, &pTemp);
            RecordResult(hr, L"Retrieving Parent1=2", 0);
            if (SUCCEEDED(hr))
            {               
                pParentClass->Release();
                CNtAcl *pAcl = NULL;
                CNtSid *sid = new CNtSid(sLogon);
                pDescr = (PNTSECURITY_DESCRIPTOR)new BYTE[4096];
                InitializeSecurityDescriptor(pDescr, SECURITY_DESCRIPTOR_REVISION);
                if (SetSecurityDescriptorOwner(pDescr, sid->GetPtr(), false))
                {
                    BOOL bRet = SetSecurityDescriptorGroup(pDescr, sid->GetPtr(), false);

                    CNtAce *ace = new CNtAce(WBEM_FULL_WRITE_REP|DELETE, ACCESS_DENIED_ACE_TYPE, CONTAINER_INHERIT_ACE, sLogon);        
                    pAcl = new CNtAcl;
                    pAcl->AddAce(ace);
                    CNtAce *ace2 = new CNtAce(WBEM_ENABLE, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, sLogon);        
                    pAcl->AddAce(ace2);
                
                    if (SetSecurityDescriptorDacl(pDescr, true, pAcl->GetPtr(), false))
                    {
                        SECURITY_DESCRIPTOR_CONTROL ctrl;
                        DWORD dwRev = 0;
                        BOOL bRes = GetSecurityDescriptorControl(pDescr, &ctrl,&dwRev);
                        if (bRes)
                        {
                            if (!(ctrl & SE_SELF_RELATIVE))  // Source is not absolute!!
                            {
                                PNTSECURITY_DESCRIPTOR pNew = NULL;                    
                                DWORD dwSize = 0;
                                dwSize = GetSecurityDescriptorLength(pDescr);
                                pNew = (PNTSECURITY_DESCRIPTOR)CWin32DefaultArena::WbemMemAlloc(dwSize);
                                ZeroMemory(pNew, dwSize);

                                hr = MakeSelfRelativeSD(pDescr, pNew, &dwSize);                        
                                delete pDescr;
                                pDescr = pNew;

                                if (!IsValidSecurityDescriptor(pDescr))
                                    hr = WBEM_E_FAILED;
                            }
                        }

                        // First, revoke write and delete from the object itself.

                        DWORD dwLen = GetSecurityDescriptorLength(pDescr);
                        GetLocalTime(&tStartTime);
                        hr = ((_IWmiObject *)pTemp)->WriteProp(L"__SECURITY_DESCRIPTOR", 0, dwLen, dwLen, CIM_UINT8|CIM_FLAG_ARRAY, pDescr);
                        if (SUCCEEDED(hr))
                            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pTemp, WBEM_FLAG_USE_SECURITY_DESCRIPTOR,
                                    0, NULL);
                        GetLocalTime(&tEndTime);
                        RecordResult(hr, L"IWmiDbSession::PutObject - revoke write & delete from Parent1=2 ", GetDiff(tEndTime,tStartTime));
                        if (SUCCEEDED(hr))
                        {
                            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pTemp, 0, 0, NULL);
                            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Verifying Parent1=2 permissions", 0);

                            IWmiDbHandle *pParentClass = NULL;
                            IWbemClassObject *pTemp3 = NULL;
                            GetLocalTime(&tStartTime);
                            IWbemPath *pPath = NULL;
                            hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IWbemPath, (void **)&pPath); 
                            if (SUCCEEDED(hr))
                            {
                                hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"Parent1=2");

                                hr = pSession->GetObject(pScope, pPath, WBEM_FLAG_USE_SECURITY_DESCRIPTOR, 
                                    WMIDB_HANDLE_TYPE_VERSIONED, &pParentClass);

                                if (SUCCEEDED(hr))
                                {
                                    hr = pParentClass->QueryInterface(IID_IWbemClassObject, (void **)&pTemp3);           
                                }
                            }
                            //hr = GetObject(pScope, L"Parent1=2", WMIDB_HANDLE_TYPE_VERSIONED,
                            //        1, &pParentClass, &pTemp3);
                            GetLocalTime(&tEndTime);
                            RecordResult(hr, L"IWmiDbSession::GetObject (Parent1=2)", GetDiff(tEndTime,tStartTime));

                            if (pTemp3)
                            {
                                VARIANT vTemp;
                                VariantInit(&vTemp);
                                hr = pTemp3->Get(L"__SECURITY_DESCRIPTOR", 0, &vTemp, NULL, NULL);
                                RecordResult(vTemp.vt == CIM_UINT8+CIM_FLAG_ARRAY?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                                    L"IWmiDbSession::GetObject - security descriptor populated", 0);
                                VariantClear(&vTemp);

                                if (pTemp3) pTemp3->Release();
                                if (pParentClass) pParentClass->Release();

                                // We should be able to delete this permission.

                                GetLocalTime(&tStartTime);
                                hr = pTemp->Put(L"__SECURITY_DESCRIPTOR", 0, NULL, CIM_UINT8|CIM_FLAG_ARRAY);
                                if (SUCCEEDED(hr))
                                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pTemp, 
                                    WBEM_FLAG_USE_SECURITY_DESCRIPTOR | WBEM_FLAG_REMOVE_CHILD_SECURITY, 0, NULL);
                                RecordResult(hr, L"Removing security (Parent1=2)", 0);
                                GetLocalTime(&tEndTime);

                                // Make sure it's gone!!

                                hr = pSession->GetObject(pScope, pPath, WBEM_FLAG_USE_SECURITY_DESCRIPTOR, 
                                    WMIDB_HANDLE_TYPE_VERSIONED, &pParentClass);

                                if (SUCCEEDED(hr))
                                {
                                    hr = pParentClass->QueryInterface(IID_IWbemClassObject, (void **)&pTemp3);           
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pTemp3->Get(L"__SECURITY_DESCRIPTOR", 0, &vTemp, NULL, NULL);
                                        RecordResult(vTemp.vt == VT_NULL?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                                            L"IWmiDbSession::GetObject - security descriptor deleted", 0);
                                        VariantClear(&vTemp);

                                    }
                                }

                                pPath->Release();
                            }
                        }
                        pTemp->Release();
                    }
                }
             }

            CloseHandle (hToken);            
        }
        CloseHandle (hThread);        
    }   


    return hr;

}

// *****************************************************

HRESULT TestSuiteFunctionality::DeleteObjects()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    IWmiDbHandle *pRet = NULL;

    // Delete the objects we created.
    // They should be gone if we try to access them again.

    // Auto-delete handle.  On releasing the handle, the object should be automatically deleted.

    GetLocalTime(&tStartTime);
    hr = CreateClass(&pRet, pSession, pScope, L"DeleteMeWhenDone", NULL, CIM_UINT32,
                        NULL, NULL, NULL, WMIDB_HANDLE_TYPE_AUTODELETE);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"IWmiDbSession::PutObject - autodelete handle (DeleteMeWhenDone)", GetDiff(tEndTime,tStartTime));
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pInst = NULL;

        // Creating a nested object with an auto-delete handle should fail.

        hr = CreateInstance(&pInst, pSession, pScope, L"DeleteMeWhenDone", L"1", CIM_UINT32,
            NULL, NULL, WMIDB_HANDLE_TYPE_AUTODELETE);
        RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"IWmiDbSession::PutObject - nested autodelete handle (DeleteMeWhenDone=1)", 0);
        if (pInst) pInst->Release();
        
        hr = CreateInstance(&pInst, pSession, pScope, L"DeleteMeWhenDone", L"1", CIM_UINT32);
        RecordResult(hr, L"Creating instance DeleteMeWhenDone=1", 0);
        if (SUCCEEDED(hr))
        {
            pRet->Release();
            DWORD dwType = 0;
            pInst->GetHandleType(&dwType);

            RecordResult((dwType == WMIDB_HANDLE_TYPE_INVALID)?WBEM_E_FAILED:WBEM_S_NO_ERROR, 
                L"IWmiDbHandle::Release of autodeleted handle does not invalidate dependent object handles (DeleteMeWhenDone=1)", 0);
            pInst->Release();

            IWbemClassObject *pObj = NULL;
            hr = GetObject(pScope, L"DeleteMeWhenDone=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pObj);
            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR,L"Autodeleted dependent object deleted on release (DeleteMeWhenDone=1)",0);
            if (SUCCEEDED(hr))
            {
                pRet->Release();
                pObj->Release();
            }

            hr = GetObject(pScope, L"DeleteMeWhenDone", WMIDB_HANDLE_TYPE_COOKIE, 1, &pRet, &pObj);
            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR,L"Autodeleted object deleted on release (DeleteMeWhenDone)",0);
            if (SUCCEEDED(hr))
            {
                pRet->Release();
                pObj->Release();
            }
        }
    }

    // Create and Delete a class

    hr = CreateClass(&pRet, pSession, pScope, L"DeleteMe", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class DeleteMe", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateInstance(NULL, pSession, pScope, L"DeleteMe", L"1", CIM_UINT32);
        RecordResult(hr, L"Creating instance DeleteMe=1", 0);
        if (SUCCEEDED(hr))
        {
            GetLocalTime(&tStartTime);
            hr = pSession->DeleteObject(pScope, 0, IID_IWmiDbHandle, pRet);  // Give it the class handle.
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::DeleteObject (DeleteMe)", GetDiff(tEndTime,tStartTime));

            // The instance should be gone also.
            if (SUCCEEDED(hr))
            {
                IWmiDbHandle *pHand = NULL;
                IWbemClassObject *pObj = NULL;
                hr = GetObject(pScope, L"DeleteMe=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHand, &pObj);
                RecordResult(FAILED(hr)?WBEM_S_NO_ERROR:WBEM_E_FAILED,L"Verifying that instance was removed when class deleted (DeleteMe=1)", 0);
                if (SUCCEEDED(hr))
                {
                    pHand->Release();
                    pObj->Release();
                }
            }
        }
        pRet->Release();
    }

    // Create an association.
    // Deleting the end-points should leave a valid association.

    hr = CreateClass(NULL, pSession, pScope, L"DeleteAssociation", L"Association", CIM_REFERENCE, NULL, NULL, CIM_REFERENCE);
    RecordResult(hr, L"Creating class DeleteAssociation", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"Deleter", NULL, CIM_STRING);
        RecordResult(hr, L"IWmiDbSession::PutObject - Deleter", 0);
        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pLeft = NULL, *pRight = NULL, *pAssoc = NULL;
            hr = CreateInstance(&pLeft, pSession, pScope, L"Deleter", L"Left side", CIM_STRING);
            RecordResult(hr, L"IWmiDbSession::PutObject - Deleter=\"Left side\"", 0);
            if (SUCCEEDED(hr))
            {
                hr = CreateInstance(&pRight, pSession, pScope, L"Deleter", L"Right side", CIM_STRING);
                RecordResult(hr, L"IWmiDbSession::PutObject - Deleter=\"Right side\"", 0);
                if (SUCCEEDED(hr))
                {
                    hr = CreateInstance(&pAssoc, pSession, pScope, L"DeleteAssociation", L"test:Deleter=\"Left side\"",
                        CIM_REFERENCE, L"test:Deleter=\"Right side\"", CIM_REFERENCE);
                    RecordResult(hr, L"IWmiDbSession::PutObject - DeleteAssociation='Left side', 'Right side'", 0);
                    if (SUCCEEDED(hr))
                    {
                        GetLocalTime(&tStartTime);
                        hr = pSession->DeleteObject(pScope, 0, IID_IWmiDbHandle, pLeft);
                        GetLocalTime(&tEndTime);
                        RecordResult(hr, L"IWmiDbSession::DeleteObject (Deleter='Left side')", GetDiff(tEndTime, tStartTime));
                        if (SUCCEEDED(hr))
                        {
                            IWmiDbHandle *pHand = NULL;
                            IWbemClassObject *pObj = NULL;
                            hr = GetObject(pScope, L"DeleteAssociation.Key1=\"test:Deleter=\\\"Left side\\\"\",Key2=\"test:Deleter=\\\"Right side\\\"\"",
                                WMIDB_HANDLE_TYPE_COOKIE, 2, &pHand, &pObj);
                            RecordResult(hr, L"IWmiDbSession::GetObject - association with deleted left end-point "
                                L"(DeleteAssociation.Key1=\"test:Deleter=\\\"Left side\\\"\",Key2=\"test:Deleter=\\\"Right side\\\"\")",0);
                            if (SUCCEEDED(hr))
                            {
                                RecordResult(ValidateProperty(pObj, L"Key1", CIM_REFERENCE, L"test:Deleter=\"Left side\""), 
                                    L"Validating deleted reference property", 0);
                                pHand->Release();
                                pObj->Release();
                            }                               
                        }

                        // Deleting the association should leave alone the good end-point.

                        GetLocalTime(&tStartTime);
                        hr = pSession->DeleteObject(pScope, 0, IID_IWmiDbHandle, pAssoc);
                        GetLocalTime(&tEndTime);
                        RecordResult(hr, L"IWmiDbSession::DeleteObject (DeleteAssociation)", GetDiff(tEndTime,tStartTime));
                        if (SUCCEEDED(hr))
                        {
                            IWmiDbHandle *pHand = NULL;
                            IWbemClassObject *pObj = NULL;
                            hr = GetObject(pScope, L"Deleter=\"Right side\"", WMIDB_HANDLE_TYPE_COOKIE, 1, &pHand, &pObj);
                            RecordResult(hr, L"IWmiDbSession::GetObject - endpoint of deleted association (Deleter=\"Right side\")", 0);
                            if (SUCCEEDED(hr))
                            {
                                pHand->Release();
                                pObj->Release();
                            }
                        }
                        pAssoc->Release();
                    }

                    pRight->Release();
                }
                pLeft->Release();
            }
        }
    }

    // Create and Delete class - should erase derived classes

    hr = CreateClass(&pRet, pSession, pScope, L"DeleteParent", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class DeleteParent", 0);
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pChildClass = NULL;
        hr = CreateClass(&pChildClass, pSession, pScope, L"DeleteChild", NULL, CIM_UINT32, L"DeleteParent");
        RecordResult(hr, L"Creating class DeleteChild", 0);
        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pGrandChild = NULL;
            hr = CreateClass(&pGrandChild, pSession, pScope, L"DeleteGrandChild", NULL, CIM_UINT32, L"DeleteChild");
            RecordResult(hr, L"Creating class DeleteGrandChild", 0);
            if (SUCCEEDED(hr))
            {
                IWmiDbHandle *pChildInstance = NULL, *pParentInstance = NULL;
                hr = CreateInstance(&pChildInstance, pSession, pScope, L"DeleteGrandChild", L"1", CIM_UINT32);
                RecordResult(hr, L"Creating instance DeleteGrandChild=1", 0);
                if (SUCCEEDED(hr))
                {
                    hr = CreateInstance(&pParentInstance, pSession, pScope, L"DeleteParent", L"2", CIM_UINT32);
                    RecordResult(hr, L"Creating instance DeleteParent=1", 0);
                    if (SUCCEEDED(hr))
                    {
                        IWbemPath*pPath = NULL;
                        hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IWbemPath, (void **)&pPath); 
                        if (SUCCEEDED(hr))
                        {
                            IWmiDbHandle *pTest = NULL;
                            IWbemClassObject *pTestObj = NULL;

                            hr = GetObject(pScope, L"DeleteGrandChild=1", WMIDB_HANDLE_TYPE_VERSIONED, -1, &pTest, &pTestObj);
                            RecordResult(hr, L"Retrieving DeleteGrandChild=1", 0);
                            if (SUCCEEDED(hr))
                            {
                                pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"DeleteParent"); 
                                GetLocalTime(&tStartTime);
                                hr = pSession->DeleteObject(pScope, 0, IID_IWbemPath, pPath);
                                GetLocalTime(&tEndTime);
                                RecordResult(hr, L"IWmiDbSession::DeleteObject - class with subclasses (DeleteParent)", GetDiff(tEndTime,tStartTime));

                                if (SUCCEEDED(hr))
                                {
                                    DWORD dwType;
                                    pRet->GetHandleType(&dwType);
                                    RecordResult((dwType==WMIDB_HANDLE_TYPE_INVALID)?WBEM_E_FAILED:WBEM_S_NO_ERROR, 
                                        L"Verifying outstanding cookie object handle not invalidated on delete object (DeleteParent)", 0);

                                    pTest->GetHandleType(&dwType);
                                    RecordResult((dwType==WMIDB_HANDLE_TYPE_INVALID)?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                                        L"Verifying outstanding dependent versioned handle invalidated on delete object (DeleteGrandChild=1)", 0);
                           
                                    IWmiDbHandle *pTemp = NULL;
                                    IWbemClassObject *pTempObj = NULL;
                                
                                    hr = GetObject(pScope, L"DeleteGrandChild=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                                    RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying subclass instance (DeleteGrandChild=1) was deleted", 0);
                                    if (SUCCEEDED(hr))
                                    {
                                        pTemp->Release();
                                        pTempObj->Release();
                                    }

                                    hr = GetObject(pScope, L"DeleteGrandChild", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                                    RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying subclass (DeleteGrandChild) was deleted", 0);
                                    if (SUCCEEDED(hr))
                                    {
                                        pTemp->Release();
                                        pTempObj->Release();
                                    }

                                    hr = GetObject(pScope, L"DeleteChild", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                                    RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying subclass (DeleteChild) was deleted", 0);
                                    if (SUCCEEDED(hr))
                                    {
                                        pTemp->Release();
                                        pTempObj->Release();
                                    }
                                }
                                pTest->Release();
                                pTestObj->Release();
                            }

                            pPath->Release();
                        }
                        pParentInstance->Release();
                    }
                    pChildInstance->Release();
                }
                pGrandChild->Release();
            }
            pChildClass->Release();
        }
        pRet->Release();
    }

    // Create & Delete scope - should erase classes

    hr = CreateClass(&pRet, pSession, pScope, L"DeleteScope", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class DeleteScope", 0);
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pSubClass = NULL, *pSubInst = NULL;
        hr = CreateClass(&pSubClass, pSession, pRet, L"DeleteSubClass", NULL, CIM_UINT32);
        RecordResult(hr, L"Creating class DeleteSubClass", 0);
        if (SUCCEEDED(hr))
        {
            hr = CreateInstance(&pSubInst, pSession, pRet, L"DeleteSubClass", L"1", CIM_UINT32);
            RecordResult(hr, L"Creating instance DeleteSubClass=1", 0);
            if (SUCCEEDED(hr))
            {
                hr = CreateClass(NULL, pSession, pRet, L"DeleteSubClass2", NULL, CIM_STRING);
                RecordResult(hr, L"Creating class DeleteSubClass2", 0);
                if (SUCCEEDED(hr))
                {
                    GetLocalTime(&tStartTime);
                    hr = pSession->DeleteObject(pScope, 0, IID_IWmiDbHandle, pRet);
                    GetLocalTime(&tEndTime);
                    RecordResult(hr, L"IWmiDbSession::DeleteObject - scoping object (DeleteScope)", GetDiff(tEndTime,tStartTime));
                    if (SUCCEEDED(hr))
                    {
                        IWmiDbHandle *pTemp = NULL;
                        IWbemClassObject *pTempObj = NULL;
                        
                        hr = GetObject(pScope, L"DeleteSubClass=1", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                        RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying subclass instance (DeleteSubClass=1) was deleted", 0);
                        if (SUCCEEDED(hr))
                        {
                            pTemp->Release();
                            pTempObj->Release();
                        }
                        hr = GetObject(pScope, L"DeleteSubClass2", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                        RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying subclass (DeleteSubClass2) was deleted", 0);
                        if (SUCCEEDED(hr))
                        {
                            pTemp->Release();
                            pTempObj->Release();
                        }
                        hr = GetObject(pScope, L"DeleteSubClass", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                        RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying subclass (DeleteSubClass) was deleted", 0);
                        if (SUCCEEDED(hr))
                        {
                            pTemp->Release();
                            pTempObj->Release();
                        }
                        hr = GetObject(pScope, L"DeleteScope", WMIDB_HANDLE_TYPE_COOKIE, 1, &pTemp, &pTempObj);
                        RecordResult((SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR), L"Verifying scope object (DeleteScope) was deleted", 0);
                        if (SUCCEEDED(hr))
                        {
                            pTemp->Release();
                            pTempObj->Release();
                        }
                    }
                }
                pSubInst->Release();
            }
            pSubClass->Release();
        }
        pRet->Release();
    }

    hr = CreateInstance(&pRet, pSession, pScope, L"Parent1", L"1001", CIM_UINT32);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
        if (SUCCEEDED(hr))
        {
            hr = pSession->DeleteObject(pScope, 0, IID_IWbemClassObject, pObj);
            RecordResult(hr, L"DeleteObject by IWbemClassObject *", 0);
        }
    }

    GetLocalTime(&tEndTime);
    

    return hr;

}


// *****************************************************
//
//  TestSuiteErrorTest
//
// *****************************************************

BOOL TestSuiteErrorTest::StopOnFailure()
{
    return FALSE;
}

HRESULT TestSuiteErrorTest::RunSuite(IWmiDbSession *_pSession, IWmiDbController *_pController, IWmiDbHandle *_pScope)
{
    RecordResult (0, L" *** Error Verification Suite running... *** \n", 0);

    wprintf(L" *** Error Verification Suite running... *** \n");

    HRESULT hr = WBEM_S_NO_ERROR;
    pSession = _pSession;
    pController = _pController;
    pScope = _pScope;

    try
    {
        TryInvalidHierarchy();
    }
    catch (...)
    {
        RecordResult(WBEM_E_FAILED, L"Caught an exception of an unknown type during hierarchy testing.\n", 0);
        hr = WBEM_E_FAILED;
    }
    try 
    {
        TryChangeDataType();
    }
    catch (...)
    {
        RecordResult(WBEM_E_FAILED, L"Caught an exception of an unknown type during data type change testing.\n", 0);
        hr = WBEM_E_FAILED;
    }
    
    try
    {
        TryInvalidQuery();
    }
    catch (...)
    {
        RecordResult(WBEM_E_FAILED, L"Caught an exception of an unknown type during invalid query testing.\n", 0);
        hr = WBEM_E_FAILED;
    }
    
    try
    {
         TryLongStrings();
    }
    catch (...)
    {
        RecordResult(WBEM_E_FAILED, L"Caught an exception of an unknown type during long string testing.\n", 0);
        hr = WBEM_E_FAILED;
    }        
    
    try // Most likely to GPF last.
    {
        TryInvalidParams();
    }
    catch (...)
    {
        RecordResult(WBEM_E_FAILED, L"Caught an exception of an unknown type testing invalid parameters.\n", 0);
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// *****************************************************

TestSuiteErrorTest::TestSuiteErrorTest(const wchar_t *pszFile, int iNumThreads)
: TestSuite(pszFile)
{
    iThreads = iNumThreads;
    if(iThreads <= 0)
        iThreads = 1;
}
// *****************************************************

TestSuiteErrorTest::~TestSuiteErrorTest()
{
}
// *****************************************************

HRESULT TestSuiteErrorTest::TryInvalidParams()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwWaste = 0;
    IWmiDbHandle *pWaste1 = NULL;
    IWmiDbSession *pWaste2 = NULL;
    IWbemPath*pPath = NULL;
    IWbemClassObject *pObj = NULL;
    
    // Ensure that we get the appropriate error message back,
    // and that no crash occurs...

    // HRESULT IWmiDbController::Logon([in]  WMIDB_LOGON_TEMPLATE *pLogonParms,[in]  DWORD dwFlags,
    // [in]  DWORD dwRequestedHandleType,   [out] IWmiDbSession **ppSession, [out] IWmiDbHandle **ppRootNamespace );

    hr = pController->Logon(NULL, 0, WMIDB_HANDLE_TYPE_COOKIE, &pWaste2, &pWaste1);
    RecordResult((hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED), L"IWmiDbController::Logon - null logon template failed to return INVALID_PARAMETER", 0);
    if (SUCCEEDED(hr))
    {
        if (pWaste1) pWaste1->Release();
        if (pWaste2) pWaste2->Release();
    }

    // HRESULT IWmiDbController::GetLogonTemplate([in]   LCID  lLocale,[in]   DWORD dwFlags,[out]  WMIDB_LOGON_TEMPLATE **ppLogonTemplate);
    // HRESULT IWmiDbController::FreeLogonTemplate([in, out] WMIDB_LOGON_TEMPLATE **ppTemplate);

    
    WMIDB_LOGON_TEMPLATE *pTemplate = NULL;
    hr = pController->GetLogonTemplate(0, 0, &pTemplate);
    RecordResult(hr, L"IWmiDbController::GetLogonTemplate = zero Locale", 0);
    if (FAILED(hr))
    {
        hr = pController->GetLogonTemplate(0x409, 0, &pTemplate);
        RecordResult(hr, L"IWmiDbController::GetLogonTemplate - locale 0x409", 0);
    }

    if (pTemplate)
    {
        hr = pController->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, NULL);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbController::Logon - null session pointer returns INVALID_PARAMETER", 0);

        hr = pController->FreeLogonTemplate(NULL);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbController::FreeLogonTemplate - null parameter returns INVALID_PARAMETER", 0);
        hr = pController->FreeLogonTemplate(&pTemplate);
        RecordResult(hr, L"IWmiDbController::FreeLogonTemplate", 0);
        pTemplate = NULL;
        hr = pController->FreeLogonTemplate(&pTemplate);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR: WBEM_E_FAILED, L"IWmiDbController::FreeLogonTemplate - "
            L"pointer to null parameter returns INVALID_PARAMETER", 0);        
    }

    // HRESULT IWmiDbController::SetCallTimeout([in] DWORD dwMaxTimeout);

    hr = pController->SetCallTimeout(0);
    RecordResult(hr == WBEM_E_INVALID_PARAMETER || hr == E_NOTIMPL ?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
        L"IWmiDbController::SetCallTimeout 0 ms returns  INVALID_PARAMETER", 0);
    
    // HRESULT IWmiDbController::SetCacheValue([in] DWORD dwMaxBytes); // This is valid anywhere from 0 to 4g, if we have the memory.
    // HRESULT IWmiDbController::FlushCache([in] DWORD dwFlags);       // No invalid parameters here.  We also don't want to do this now.

    // HRESULT IWmiDbController::GetStatistics([in]  DWORD  dwParameter,[out] DWORD *pdwValue);

   hr = pController->GetStatistics(WMIDB_FLAG_TOTAL_HANDLES, 0);
   RecordResult(hr == WBEM_E_INVALID_PARAMETER || hr == E_NOTIMPL?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
       L"IWmiDbController::GetStatistics - null parameter returns INVALID_PARAMETER",0);

   hr = pController->GetStatistics(0, &dwWaste);
   RecordResult(SUCCEEDED(hr) ? WBEM_E_FAILED: WBEM_S_NO_ERROR, L"IWmiDbController::GetStatistics - null parameter fails", 0);

    // HRESULT IWmiDbSession::SetDecoration([in]  LPWSTR lpMachineName,[in]  LPWSTR lpNamespacePath);

    hr = pSession->SetDecoration(NULL, NULL);
    RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::SetDecoration - null parameters", 0);

    hr = pSession->SetDecoration(L"MACHINE1", NULL);
    RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::SetDecoration - null namespace parameter", 0);

    hr = pSession->SetDecoration(NULL, L"root\\test");
    RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::SetDecoration - null machine name parameter", 0);

    // HRESULT IWmiDbSession::GetObject([in]  IWmiDbHandle *pScope,[in]  IWbemPath*pPath,[in]  DWORD dwFlags,
    // [in]  DWORD dwRequestedHandleType,[out] IWmiDbHandle **ppResult );

    hr = pSession->GetObject(pScope, NULL, 0, WMIDB_HANDLE_TYPE_COOKIE, &pWaste1);
    RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::GetObject - null binary object path", 0);
    if (SUCCEEDED(hr)) pWaste1->Release();

    hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
        IID_IWbemPath, (void **)&pPath); 
    if (SUCCEEDED(hr))
    {
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"");

        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pWaste1);
        RecordResult(FAILED(hr)?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::GetObject - blank object path", 0);
        if (SUCCEEDED(hr)) pWaste1->Release();

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"__Namespace"); // this should be valid.
        hr = pSession->GetObject(NULL, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pWaste1);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::GetObject - null scope returns INVALID_PARAMETER", 0);
        if (SUCCEEDED(hr)) pWaste1->Release();

        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_INVALID, &pWaste1);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::GetObject - invalid handle type returns INVALID_PARAMETER", 0);
        if (SUCCEEDED(hr)) pWaste1->Release();

        hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::GetObject - null return pointer returns INVALID_PARAMETER", 0);

        pPath->Release();
    }
    else
        wprintf(L"WARNING: call failed to CoCreateInstance (IID_IWbemPath).  Tests skipped.\n");
    
    // HRESULT IWmiDbSession::PutObject([in]  IWmiDbHandle *pScope,[in]  IUnknown *pObjToPut,
    // [in]  DWORD dwFlags, [in]  DWORD dwRequestedHandleType, [out] IWmiDbHandle **ppResult);

    hr = pSession->PutObject(pScope, IID_IWbemClassObject, NULL, 0, WMIDB_HANDLE_TYPE_COOKIE, &pWaste1);
    RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::PutObject - null object returns INVALID_PARAMETER", 0);
    if (SUCCEEDED(hr)) pWaste1->Release();

    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pObj);
    if (SUCCEEDED(hr))
    {
        SetStringProp(pObj, L"__Class", L"ErrorTest1");
        SetIntProp(pObj, L"Key1", 0, true);

        hr = pSession->PutObject(NULL, IID_IUnknown, pObj, 0, WMIDB_HANDLE_TYPE_COOKIE, &pWaste1);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::PutObject - null scope returns INVALID_PARAMETER", 0);
        if (SUCCEEDED(hr)) pWaste1->Release();

        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, WMIDB_HANDLE_TYPE_INVALID, &pWaste1);
        RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::PutObject - invalid handle type returns INVALID_PARAMETER", 0);
        if (SUCCEEDED(hr)) pWaste1->Release();

        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, NULL, NULL);
        RecordResult(hr, L"IWmiDbSession::PutObject - null return pointer", 0);

        pObj->Release();
    }
    else
        wprintf(L"WARNING: call failed to CoCreateInstance (IID_IWbemClassObject).  Tests skipped.\n");
    
    // HRESULT IWmiDbSession::DeleteObject([in]  IWmiDbHandle *pScope,[in]  IUnknown *pObjId,[in]  DWORD dwFlags);

   hr = pSession->DeleteObject(NULL, NULL, IID_IWmiDbHandle, 0);
   RecordResult( hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::PutObject - null parameters", 0);
    
   hr = pSession->DeleteObject(pScope, NULL, IID_IUnknown, 0);
   RecordResult( hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"IWmiDbSession::PutObject - null IUnknown *", 0);  
   
   {
       IWbemQuery *pQuery = NULL;
       IWmiDbIterator *pResult = NULL;

        hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemQuery, (void **)&pQuery); 
        if (SUCCEEDED(hr))
        {
            // HRESULT IWmiDbSession::ExecQuery([in]  IWmiDbHandle *pScope,[in]  IWbemQuery *pQuery,
            //    [in]  DWORD dwFlags,[in]  DWORD dwRequestedHandleType,[out] DWORD *pFlags, [out] IWmiDbIterator **ppQueryResult);

            hr = pSession->ExecQuery(pScope, NULL, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pResult);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                L"IWmiDbSession::ExecQuery - null query returns INVALID_PARAMETER", 0);
            if (SUCCEEDED(hr)) pResult->Release();

            pQuery->Parse(L"SQL", L"select * from ErrorTest1", 0);
            hr = pSession->ExecQuery(NULL, pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pResult);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbSession::ExecQuery - null scope returns INVALID_PARAMETER", 0);
            if (SUCCEEDED(hr)) pResult->Release();

            hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_INVALID, NULL, NULL);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbSession::ExecQuery - null iterator parameter returns INVALID_PARAMETER", 0);

            RecordResult(hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pResult), 
                L"IWmiDbSession::ExecQuery - select * from ErrorTest1", 0);
            if (SUCCEEDED(hr))
            {           
                IUnknown * objs[5];

                hr = pResult->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwWaste, (void **)&objs);
                RecordResult(hr == WBEM_S_NO_MORE_DATA?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"IWmiDbIterator::NextBatch - end of rowset returns S_NO_MORE_DATA", 0);

                pResult->Release();
            }

            CreateInstance(NULL, pSession, pScope, L"ErrorTest1", L"1", CIM_UINT32);
            CreateInstance(NULL, pSession, pScope, L"ErrorTest1", L"2", CIM_UINT32);
            CreateInstance(NULL, pSession, pScope, L"ErrorTest1", L"3", CIM_UINT32);
            CreateInstance(NULL, pSession, pScope, L"ErrorTest1", L"4", CIM_UINT32);
            CreateInstance(NULL, pSession, pScope, L"ErrorTest1", L"5", CIM_UINT32);

            RecordResult(hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pResult), 
                L"IWmiDbSession::ExecQuery - select * from ErrorTest1", 0);
            if (SUCCEEDED(hr))
            {           
                IUnknown * objs[5];

                // HRESULT IWmiDbIterator::NextBatch([in] DWORD dwNumRequested,[in] DWORD dwTimeOutSeconds,[in] DWORD dwFlags,
                // [in] DWORD dwRequestedHandleType,[in] const IID *pIIDRequestedInterface,[out] DWORD *pdwNumReturned,
                // [out, size_is(dwNumRequested), length_is(*pdwNumReturned)]IUnknown **ppObjects     );

                hr = pResult->NextBatch(0, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwWaste, (void **)&objs);
                RecordResult(hr == WBEM_E_INVALID_PARAMETER ? WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                    L"IWmiDbIterator::NextBatch - dwNumRequested is zero returns INVALID_PARAMETER", 0);

                hr = pResult->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, &dwWaste, NULL);
                RecordResult(hr == WBEM_E_INVALID_PARAMETER ? WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                    L"IWmiDbIterator::NextBatch - NULL IUnknown ** returns INVALID_PARAMETER", 0);

                hr = pResult->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbHandle, NULL, (void **)&objs);
                RecordResult(hr, L"IWmiDbIterator::NextBatch - null num returned parameter", 0);

                hr = pResult->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_COOKIE, IID_IWmiDbBatchSession, &dwWaste, (void **)&objs);
                RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"IWmiDbIterator::NextBatch - invalid IID", 0);
                
                hr = pResult->NextBatch(1, 0, 0, WMIDB_HANDLE_TYPE_INVALID, IID_IWmiDbBatchSession, &dwWaste, (void **)&objs);
                RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"IWmiDbIterator::NextBatch - invalid handle type", 0);

                // HRESULT IWmiDbIterator::Cancel ( [in] DWORD dwFlags);

                hr = pResult->Cancel(0);
                RecordResult(hr, L"IWmiDbIterator::Cancel (0)", 0);
            }

            pQuery->Release();
        }
        else
            wprintf(L"WARNING: call failed to CoCreateInstance (IID_IWbemQuery).  Tests skipped.\n");
   }

   {
        IWmiDbBatchSession *pBatch = NULL;
        hr = pSession->QueryInterface(IID_IWmiDbBatchSession, (void **)&pBatch);
        if (SUCCEEDED(hr))
        {
            WMIOBJECT_BATCH batch;

            batch.dwArraySize = 3;
            batch.pElements = new WMI_BATCH_OBJECT_ACCESS[3];
            for (int i = 0; i < 3; i++)
            {
                batch.pElements[i].pReturnHandle = NULL;
                batch.pElements[i].dwFlags = 0;
                batch.pElements[i].pHandle = NULL;
                batch.pElements[i].hRes = 0;

                hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                    IID_IWbemPath, (void **)&pPath); 
                batch.pElements[i].pPath = pPath;
            }

            batch.pElements[0].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"ErrorTest1=5");
            batch.pElements[1].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"ErrorTest1=4");
            batch.pElements[2].pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, L"ErrorTest1=3");

            // HRESULT IWmiDbBatchSession::GetObjects([in] IWmiDbHandle *pScope,[in] DWORD dwFlags,
            // [in] DWORD dwRequestedHandleType,[in, out] WMIOBJECT_BATCH *pBatch);

            hr = pBatch->GetObjects(pScope, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::GetObjects - null batch", 0);

            hr = pBatch->GetObjects(NULL, 0, WMIDB_HANDLE_TYPE_COOKIE, &batch);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::GetObjects - null scope", 0);

            hr = pBatch->GetObjects(pScope, 0, WMIDB_HANDLE_TYPE_INVALID, &batch);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::GetObjects - invalid handle type", 0);

            // HRESULT IWmiDbBatchSession::DeleteObjects([in] IWmiDbHandle *pScope,[in] DWORD dwFlags,[in] WMIOBJECT_BATCH *pBatch);

            hr = pBatch->DeleteObjects(pScope, 0, NULL);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::DeleteObjects - null batch", 0);

            hr = pBatch->DeleteObjects(NULL, 0, &batch);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::DeleteObjects - null scope", 0);

            for (i = 0; i < 3; i++)
            {
                batch.pElements[i].pPath->Release();
                batch.pElements[i].pPath = NULL;
            }

            // HRESULT IWmiDbBatchSession::PutObjects([in] IWmiDbHandle *pScope,[in] DWORD dwFlags,
            // [in]  DWORD dwRequestedHandleType,[in, out] WMIOBJECT_BATCH *pBatch);

            hr = pBatch->PutObjects(pScope, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::PutObjects - null batch", 0);
  
            hr = pBatch->PutObjects(NULL, 0, WMIDB_HANDLE_TYPE_COOKIE, &batch);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::PutObjects - null scope", 0);

            hr = pBatch->PutObjects(pScope, 0, WMIDB_HANDLE_TYPE_INVALID, &batch);
            RecordResult(hr == WBEM_E_INVALID_PARAMETER?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                L"IWmiDbBatchSession::PutObjects - invalid handle type", 0);

            pBatch->Release();
        }
        else
            wprintf(L"WARNING: call failed to IWmiDbSession::QueryInterface (IWmiDbBatchSession).  Tests skipped\n");
   }

    return hr;

}
// *****************************************************

HRESULT TestSuiteErrorTest::TryInvalidHierarchy()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // key migration: An instance exists in one class, then
    // is persisted under a derived or superclass.  This 
    // should fail at the driver level.

    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorParent1", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"ErrorChild1", NULL, CIM_UINT32, L"ErrorParent1");
        RecordResult(hr, L"Creating class ErrorChild1", 0);
        if (SUCCEEDED(hr))
        {
            hr = CreateInstance(NULL, pSession, pScope, L"ErrorChild1", L"1", CIM_UINT32);
            RecordResult(hr, L"Creating instance ErrorChild1=1", 0);
            if (SUCCEEDED(hr))
            {
                hr = CreateInstance(NULL, pSession, pScope, L"ErrorParent1", L"1", CIM_UINT32);
                RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Driver prevents key migration (ErrorChild1=1)", 0);
                if (FAILED(hr))
                {
                    hr = CreateInstance(NULL, pSession, pScope, L"ErrorParent1", L"2", CIM_UINT32);
                    RecordResult(hr, L"Creating instance ErrorParent1=2", 0);
                    if (SUCCEEDED(hr))
                    {
                        hr = CreateInstance(NULL, pSession, pScope, L"ErrorChild1", L"2", CIM_UINT32);
                        RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Driver prevents key migration (ErrorParent1=2)", 0);
                    }
                    else
                        wprintf(L"WARNING: Failed to create instance ErrorParent1=2.  Tests skipped.\n");
                }
            }
            else
                wprintf(L"WARNING: Failed to create instance ErrorChild1=1.  Tests skipped.\n");
        }
        else
            wprintf(L"WARNING: Failed to create class ErrorChild1.  Tests skipped.\n");
    }
    else
        wprintf(L"WARNING: Failed to create class ErrorParent1.  Tests skipped.\n");

    // parent report to self.  ClassB reports to ClassA.
    // Driver should disallow updating ClassA to report to ClassB.

    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent2", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorParent2", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"ErrorChild2", NULL, CIM_UINT32, L"ErrorParent2");
        RecordResult(hr, L"Creating class ErrorChild2", 0);
        if (SUCCEEDED(hr))
        {
            hr = CreateClass(NULL, pSession, pScope, L"ErrorParent2", NULL, CIM_UINT32, L"ErrorChild2");
            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Driver prevents circular parent-child relationship. (ErrorParent2:ErrorChild2)", 0);
            if (FAILED(hr))
            {
                hr = CreateClass(NULL, pSession, pScope, L"ErrorGrandChild2", NULL, CIM_UINT32, L"ErrorChild2");
                RecordResult(hr, L"Creating class ErrorGrandChild2", 0);
                if (SUCCEEDED(hr))
                {
                    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent2", NULL, CIM_UINT32, L"ErrorGrandChild2");
                    RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, 
                        L"Driver prevents circular parent-child relationship. (ErrorParent2:ErrorGrandChild2)", 0);
                }
                else
                    wprintf(L"WARNING: Failed to create class ErrorGrandChild2.  Tests skipped\n");
            }
        }
        else
            wprintf(L"WARNING: Failed to create class ErrorChild2.  Tests skipped\n");
    }
    else
        wprintf(L"WARNING: Failed to create class ErrorParent2.  Tests skipped.\n");
    
    // Move child with instances.  ClassB reports to ClassA.
    // Driver should disallow changing ClassB's parent if
    // there are instances.
    // CORRECTION: This is OK if the classes have the same keys.
/*
    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent3", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorParent3", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"ErrorParent3_1", NULL, CIM_UINT32);
        RecordResult(hr, L"Creating class ErrorParent3_1", 0);
    }
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"ErrorChild3", NULL, CIM_UINT32, L"ErrorParent3");
        RecordResult(hr, L"Creating class ErrorChild3", 0);
        if (SUCCEEDED(hr))
        {
            hr = CreateInstance(NULL, pSession, pScope, L"ErrorChild3", L"1", CIM_UINT32);
            RecordResult(hr, L"Creating instance ErrorChild3=1", 0);
            if (SUCCEEDED(hr))
            {
                hr = CreateClass(NULL, pSession, pScope, L"ErrorChild3", NULL, CIM_UINT32, L"ErrorParent3_1");
                RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Driver prevents changing parent class when there are instances.", 0);

                if (FAILED(hr))
                {
                    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent3", NULL, CIM_UINT32, L"ErrorParent3_1");
                    RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, L"Driver prevents changing parent class when derived class has instances.", 0);
                }
            }
            else
                wprintf(L"WARNING: Failed to create instance ErrorChild3=1.  Tests skipped\n");
        }
        else
            wprintf(L"WARNING: Failed to create class ErrorChild3.  Tests skipped\n");
    }
    else
        wprintf(L"WARNING: Failed to create class ErrorParent3.  Tests skipped\n");
   */

    // Change key with subclasses or instances.  If a class
    // has instances, driver should disallow
    // adding or dropping key properties.

    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent4", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorParent4", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateClass(NULL, pSession, pScope, L"ErrorChild4", NULL, CIM_UINT32, L"ErrorParent4");
        RecordResult(hr, L"Creating class ErrorChild4", 0);
        if (SUCCEEDED(hr))
        {
            hr = CreateInstance(NULL, pSession, pScope, L"ErrorParent4", L"1", CIM_UINT32);
            RecordResult(hr, L"Creating instance ErrorParent4=1", 0);
            if (SUCCEEDED(hr))
            {
                hr = CreateClass(NULL, pSession, pScope, L"ErrorParent4", NULL, CIM_UINT32, NULL, NULL, CIM_UINT32);
                RecordResult(FAILED(hr)?WBEM_S_NO_ERROR:WBEM_E_FAILED, L"Driver prevents adding key property when instances exist (ErrorParent4).", 0);

                if (FAILED(hr))
                {
                    hr = CreateClass(NULL, pSession, pScope, L"ErrorChild4", NULL, CIM_UINT32, L"ErrorParent4", NULL, CIM_UINT32);
                    RecordResult(hr, L"Driver prevents changing key when there are instances (ErrorChild4)", 0);
                }
            }
        }
        else
            wprintf(L"WARNING: Failed to create class ErrorChild4.  Test skipped.\n");
    }
    else
        wprintf(L"WARNING: Failed to create class ErrorParent4.  Test skipped.\n");
   
    // Add property that exists in child.  Driver should
    // disallow adding a property to a parent class that
    // already exists in one of its derived classes.

    hr = CreateClass(NULL, pSession, pScope, L"ErrorParent5", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorParent5", 0);
    if (SUCCEEDED(hr))
    {
        IWmiDbHandle *pHandle = NULL;
        IWbemClassObject *pObj = NULL;

        hr = CreateClass(&pHandle, pSession, pScope, L"ErrorChild5", NULL, CIM_UINT32, L"ErrorParent5");
        RecordResult(hr, L"Creating class ErrorChild5", 0);
        if (SUCCEEDED(hr))
        {
            hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                SetStringProp(pObj, L"Prop1", L"");
                hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    IWmiDbHandle *pTemp1 = NULL;
                    IWbemClassObject *pTemp2 = NULL;
                    hr = GetObject(pScope, L"ErrorParent5", WMIDB_HANDLE_TYPE_COOKIE, -1, &pTemp1, &pTemp2);
                    RecordResult(hr, L"Retrieving ErrorParent5", 0);
                    if (SUCCEEDED(hr))
                    {
                        SetIntProp(pTemp2, L"Prop1", 0);
                        hr = pSession->PutObject(pScope, IID_IWbemClassObject, pTemp2, 0, NULL, NULL);
                        RecordResult(FAILED(hr)?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                            L"Driver denies parent property that overrides one in derived class.", 0);

                        pTemp1->Release();
                        pTemp2->Release();
                    }
                    else
                        wprintf(L"WARNING: Failed to retrieve class ErrorParent5.  Tests skipped\n");
                }
                else
                    wprintf(L"WARNING: Failed to persist ErrorChild5.  Tests skipped\n");

                pObj->Release();
            }
            pHandle->Release();
        }
        else
            wprintf(L"WARNING: Failed to create class ErrorChild5.  Test skipped.\n");
    }           
    else
        wprintf(L"WARNING: Failed to create class ErrorParent5.  Test skipped.\n");

    return hr;

}
// *****************************************************

HRESULT TestSuiteErrorTest::TryLongStrings()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    wchar_t * wLongText = new wchar_t [4096];
    wchar_t * wLongName = new wchar_t [512];

    for (int i = 0; i < 4090; i++)
        wLongText[i] = L'x';
    wLongText[4090] = L'\0';

    for (i = 0; i < 511; i++)
        wLongName[i] = L'z';
    wLongName[511] = L'\0';
    
    // Long class names, key names and values

    IWmiDbHandle *pRet = NULL;

    hr = CreateClass(NULL, pSession, pScope, wLongName, NULL, CIM_UINT32);
    RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR, 
        L"Driver denies class name greater than 255 characters.", 0);

    hr = CreateClass(&pRet, pSession, pScope, L"LongStrings1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class LongStrings1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pHand=NULL;
            SetStringProp(pObj, wLongName, L"");
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
            RecordResult(SUCCEEDED(hr)?WBEM_E_FAILED:WBEM_S_NO_ERROR,
                L"Driver denies property name greater than 255 characters.", 0);

            hr = pObj->Delete(wLongName);
            hr = SetIntProp(pObj, L"Key1", 0, TRUE);
            hr = SetStringProp(pObj, L"Prop1", L"");
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, WMIDB_HANDLE_TYPE_COOKIE, &pHand);
            if (SUCCEEDED(hr))
            {
                long lOrigLen = 0;
                IWbemClassObject *pObj2 = NULL;
                hr = pHand->QueryInterface(IID_IWbemClassObject, (void **)&pObj2);
                if (SUCCEEDED(hr))
                {
                    IWbemClassObject *pObj3 = NULL;
                    pObj2->SpawnInstance(0, &pObj3);

                    SetIntProp(pObj3, L"Key1", 1);
                    SetStringProp(pObj3, L"Prop1", wLongText);
                    lOrigLen = GetStringValue(pObj3, L"Prop1").length();

                    IWbemQualifierSet *pQS = NULL;
                    pObj3->GetQualifierSet(&pQS);
                    if (pQS)
                    {
                        VARIANT vTemp;
                        VariantInit(&vTemp);
                        vTemp.vt = VT_BSTR;
                        vTemp.bstrVal = SysAllocString(wLongText);
                        pQS->Put(L"Description", &vTemp, 0);
                        pQS->Release();
                        VariantClear(&vTemp);
                    }

                    GetLocalTime(&tStartTime);
                    hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj3, 0, 0, NULL);
                    GetLocalTime(&tEndTime);
                    RecordResult(hr, L"IWmiDbSession::PutObject - long string data (LongStrings1.Prop1)", GetDiff(tEndTime,tStartTime));
                    pObj3->Release();
                    pObj2->Release();
                }
                pHand->Release();

                GetLocalTime(&tStartTime);
                hr = GetObject(pScope, L"LongStrings1=1", WMIDB_HANDLE_TYPE_COOKIE, -1, &pHand, &pObj2);
                RecordResult(hr, L"Retrieving LongStrings1=1", 0);
                if (SUCCEEDED(hr))
                {
                    GetLocalTime(&tEndTime);
                    long lLen = GetStringValue(pObj2, L"Prop1").length();
                    RecordResult((lLen < lOrigLen)?WBEM_E_FAILED:WBEM_S_NO_ERROR,
                        L"Driver retrieves long strings", GetDiff(tEndTime,tStartTime));

                    IWbemQualifierSet *pQS = NULL;
                    pObj2->GetQualifierSet(&pQS);
                    if (pQS)
                    {
                        VARIANT vTemp;
                        VariantInit(&vTemp);
                        hr = pQS->Get(L"Description", NULL, &vTemp, NULL);                        
                        lLen = wcslen(vTemp.bstrVal);
                        RecordResult((SUCCEEDED(hr) && vTemp.vt == VT_BSTR && (int)lLen >= (int)lOrigLen) ? WBEM_S_NO_ERROR: WBEM_E_FAILED,
                            L"Driver retrieves long qualifiers", GetDiff(tEndTime, tStartTime));
                        VariantClear(&vTemp);
                        pQS->Release();
                    }

                    pObj2->Release();
                }
            }
            else
                wprintf(L"WARNING: Failed to create instance LongStrings1=1.  Tests skipped.\n");
            
            pObj->Release();
        }
        pRet->Release();
    }
    else
        wprintf(L"WARNING: Failed to create class LongStrings1.  Tests skipped.\n");

    delete wLongText;
    delete wLongName;
    
    return hr;

}

// *****************************************************

HRESULT TestSuiteErrorTest::TryChangeDataType()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We have already verified that we can make the
    // valid conversions.  Now try the invalid ones:

    IWmiDbHandle *pRet = NULL;
    hr = CreateClass(&pRet, pSession, pScope, L"ErrorTestDataType1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorTestDataType1", 0);
    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        hr = pRet->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
        if (SUCCEEDED(hr))
        {
            pObj->Put(L"string", NULL, NULL, CIM_STRING);            
            pObj->Put(L"datetime", NULL, NULL, CIM_DATETIME);            
            pObj->Put(L"real64", NULL, NULL, CIM_REAL64);
            pObj->Put(L"uint64", NULL, NULL, CIM_UINT64);
            pObj->Put(L"object", NULL, NULL, CIM_OBJECT);

            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL);
            if (SUCCEEDED(hr))
            {

                hr = CreateInstance(NULL, pSession, pScope, L"ErrorTestDataType1", L"1", CIM_UINT32);
                RecordResult(hr, L"Creating instance ErrorTestDataType1=1", 0);

                //pObj->Delete(L"string");
                //pObj->Put(L"string", NULL, NULL, CIM_DATETIME);
                //RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                //    L"Driver denies conversion from string to datetime", 0);

                pObj->Delete(L"string");
                pObj->Put(L"string", NULL, NULL, CIM_UINT32);
                RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Driver denies conversion from string to uint32", 0);
/* *** Sanj's ReconcileWith function doesn't catch these for some reason
                pObj->Delete(L"string");
                pObj->Put(L"string", NULL, NULL, CIM_REFERENCE);
                RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Driver denies conversion from string to reference", 0);

                pObj->Delete(L"string");
                pObj->Delete(L"uint64");
                pObj->Put(L"uint64", NULL, NULL, CIM_UINT32);
                RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Driver denies conversion from int64 to int32", 0);

                pObj->Delete(L"real64");
                pObj->Put(L"real64", NULL, NULL, CIM_UINT64);
                RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Driver denies conversion from int64 to real64", 0);

                pObj->Delete(L"real64");
                pObj->Delete(L"datetime");
                pObj->Put(L"datetime", NULL, NULL, CIM_STRING);
                RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Driver denies conversion from datetime to string", 0);

                pObj->Delete(L"datetime");
                pObj->Delete(L"object");
                pObj->Put(L"object", NULL, NULL, CIM_REFERENCE);
                RecordResult(FAILED(pSession->PutObject(pScope, IID_IWbemClassObject, pObj, 0, 0, NULL))?WBEM_S_NO_ERROR:WBEM_E_FAILED,
                    L"Driver denies conversion from object to reference", 0);
*/
            }
            else
                wprintf(L"WARNING: Failed to persist class ErrorTestDataType1.  Tests skipped\n");
        }
        pRet->Release();
    }
    else
        wprintf(L"WARNING: Failed to create class ErrorTestDataType1.  Tests skipped\n");
    
    return hr;

}

// *****************************************************

HRESULT TestSuiteErrorTest::TryInvalidQuery()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If we perform a query on a partially secured,
    // or partially locked result set.
    // This should succeed but return WBEM_S_PARTIAL_RESULTS
    // If the class itself is locked, we should get a denial.
    // If a child class is locked, we should get partial results.
        
    hr = CreateClass(NULL, pSession, pScope, L"ErrorTestQuery1", NULL, CIM_UINT32);
    RecordResult(hr, L"Creating class ErrorTestQuery1", 0);
    if (SUCCEEDED(hr))
    {
        hr = CreateInstance(NULL, pSession, pScope, L"ErrorTestQuery1", L"1", CIM_UINT32);
        RecordResult(hr, L"Creating instance ErrorTestQuery=1", 0);
        hr = CreateInstance(NULL, pSession, pScope, L"ErrorTestQuery1", L"2", CIM_UINT32);
        RecordResult(hr, L"Creating instance ErrorTestQuery=2", 0);
        if (SUCCEEDED(hr))
        {
            IWmiDbHandle *pRet = NULL;
            IWbemClassObject *pObj = NULL;

            hr = GetObject(pScope, L"ErrorTestQuery1=1", WMIDB_HANDLE_TYPE_EXCLUSIVE, -1, &pRet, &pObj);
            RecordResult(hr, L"Retrieving ErrorTestQuery1=1", 0);
            if (SUCCEEDED(hr))
            {
                IWbemQuery *pQuery = NULL;
                hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
                if (SUCCEEDED(hr))
                {
                    IWmiDbIterator *pIt = NULL;
                    pQuery->Parse(L"SQL", L"select * from ErrorTestQuery1", 0);
                    hr = pSession->ExecQuery(pScope, pQuery, 0,WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIt);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwNumRet = 0;
                        IUnknown * blah[2];
                        hr = pIt->NextBatch(2, 0, 0, WMIDB_HANDLE_TYPE_PROTECTED, IID_IWmiDbHandle, &dwNumRet, (void **)&blah);
                        RecordResult(hr == WBEM_S_PARTIAL_RESULTS || hr == WBEM_S_NO_MORE_DATA?WBEM_S_NO_ERROR:WBEM_E_FAILED, 
                            L"IWmiDbIterator::NextBatch returns PARTIAL_RESULTS when some results locked.", 0);
                        pIt->Release();         
                    }
                    pQuery->Release();
                }

                pRet->Release();
                pObj->Release();
            }
        }
    }
    
    return hr;

}

// *****************************************************
//
//  TestSuiteStressTest
//
// *****************************************************

BOOL TestSuiteStressTest::StopOnFailure()
{
    return FALSE;
}
// *****************************************************

HRESULT TestSuiteStressTest::RunSuite(IWmiDbSession *_pSession, IWmiDbController *_pController, IWmiDbHandle *_pScope)
{
    RecordResult(0, L" *** Stress Suite running... *** \n", 0);
    wprintf(L" *** Stress Suite running... *** \n");

    HRESULT hr = WBEM_S_NO_ERROR;
    pSession = _pSession;
    pController = _pController;
    pScope = _pScope;

    HANDLE hThread = 0;
    DWORD dwThreadID = 0;

    HANDLE hThreadEvent = CreateEvent(NULL, FALSE, FALSE, TESTMOD_NOTIF);

    for (int i = 0; i < iThreads; i++)
    {

        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)THREAD_RunTest, this, 0, &dwThreadID);

        if (hThread)
        {
            CloseHandle(hThread);
            printf("Created thread #%ld\n", i+1);
        }
        else
            printf("Failed to create thread #%ld\n", i+1);
    }

    if (WaitForSingleObject(hThreadEvent, 30*60*1000) != WAIT_OBJECT_0)
        hr = WBEM_S_TIMEDOUT;

    return hr;
}

// *****************************************************

TestSuiteStressTest::TestSuiteStressTest(const wchar_t *pszFile, int nDepth, int nMaxObjs, int nMaxThreads)
: TestSuite(pszFile)
{
    iDepth = nDepth;
    iObjs = nMaxObjs;
    iThreads = nMaxThreads;
    if (iThreads < 1)
        iThreads = 1;
}
// *****************************************************

TestSuiteStressTest::~TestSuiteStressTest()
{
}

// *****************************************************

HRESULT WINAPI TestSuiteStressTest::THREAD_RunTest(TestSuiteStressTest *pTest)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = CoInitialize(NULL);

    CRITICAL_SECTION crit;
    InitializeCriticalSection(&crit);
    
    EnterCriticalSection(&crit);
    iRunning++;
    LeaveCriticalSection(&crit);

    try
    {
        hr = CreateClass (NULL, pTest->pSession, pTest->pScope, L"IntKey1", NULL, CIM_UINT32);
        pTest->RecordResult(hr, L"Created stress class IntKey1", 0);
        if (SUCCEEDED(hr))
            hr = pTest->RunVanillaTest(L"IntKey1");

        hr = CreateClass (NULL, pTest->pSession, pTest->pScope, L"StringKey1", NULL, CIM_STRING);
        pTest->RecordResult(hr, L"Created stress class StringKey1", 0);
        if (SUCCEEDED(hr))
            hr = pTest->RunVanillaTest(L"StringKey1");

        hr = CreateClass (NULL, pTest->pSession, pTest->pScope, L"ReferenceKey1", L"Association", CIM_REFERENCE, NULL, NULL, CIM_REFERENCE);
        pTest->RecordResult(hr, L"Created stress class ReferenceKey1", 0);
        if (SUCCEEDED(hr))
            hr = pTest->RunVanillaTest(L"ReferenceKey1");
    }
    catch (...)
    {
        pTest->RecordResult(WBEM_E_FAILED,  L"Stress testing caught an exception of an unknown type on thread %ld\n", 0, GetCurrentThreadId());

    }
    
    // Sort out the order and the failure allowances

    try
    {
        hr = pTest->CreateNamespaces();

    } catch (...)
    {
        pTest->RecordResult(WBEM_E_FAILED, L"Stress testing caught an exception of an unknown type on thread %ld\n", 0, GetCurrentThreadId());
    }

    EnterCriticalSection(&crit);
    iRunning--;
    if (!iRunning)
    {
        HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TESTMOD_NOTIF);
        if (hEvent)
        {
            SetEvent(hEvent);
            CloseHandle(hEvent);
        }
    }
    LeaveCriticalSection(&crit);
    DeleteCriticalSection(&crit);
 
    return hr;
}

// *****************************************************
int GetNumNamespaces(int iTotal)
{
    int iRet = 1;
    
    int iTemp = iTotal/200;

    if (iTemp > iRet)
        iRet = iTemp;

    return iRet;
}

// *****************************************************
int GetNumClasses(int iTotal)
{
    int iRet = 1;    
    int iTemp = iTotal/20;

    if (iTemp > iRet)
        iRet = iTemp;
    
    return iRet;
}

// *****************************************************
int GetNumInstances(int iTotal)
{
    int iRet = 1;
    
    int iTemp = iTotal;
    iTemp -= (GetNumClasses(iTotal)*GetNumNamespaces(iTotal));

    iTemp = iTemp/GetNumClasses(iTotal);

    if (iTemp > iRet)
        iRet = iTemp;

    return iRet;
}

// *****************************************************

HRESULT TestSuiteStressTest::RunVanillaTest (LPWSTR lpClassName)
{
    DWORD arrTypes[50];
    CWStringArray arrKeys, arrPaths;
    _bstr_t sClassName;
    wchar_t wTemp[512];

    IWmiDbHandle *pHandle = NULL;
    IWbemClassObject *pClass = NULL;
    VARIANT vTemp;
    VariantInit(&vTemp);
    int iNum = 0;
    time_t tBegin, tEnd;
    int iActual = 0;
    wchar_t szTmp[100];

    HRESULT hr = GetObject(pScope, lpClassName, WMIDB_HANDLE_TYPE_COOKIE, -1, &pHandle, &pClass);
    RecordResult(hr, L"Retrieving %s", 0, lpClassName);
    if (SUCCEEDED(hr))
    {
        pClass->Get(L"__Genus", 0, &vTemp, NULL, NULL);
        if (vTemp.lVal == 1)
        {
            CIMTYPE cimtype;
            BSTR strName;

            VariantClear(&vTemp);

            // Get the keys.
            pClass->BeginEnumeration(0);
            while (pClass->Next(0, &strName, NULL, &cimtype, NULL) == S_OK)
            {
                IWbemQualifierSet *pQS = NULL;
                pClass->GetPropertyQualifierSet(strName, &pQS);
                if (pQS)
                {
                    if (pQS->Get(L"key", NULL, NULL, NULL) == S_OK)
                    {
                        arrKeys.Add((const wchar_t *)strName);
                        arrTypes[arrKeys.Size()-1] = cimtype;
                    }
                    pQS->Release();
                }
                SysFreeString(strName);
            }
            pClass->EndEnumeration();
                
            if (arrKeys.Size() > 0)
            {
                // Use keys to generate n objects.                        

                hr = pClass->Get(L"__Class", 0, &vTemp, NULL, NULL);
                sClassName = vTemp.bstrVal;
                VariantClear(&vTemp);

                iNum = iObjs;
                int iStart = 1;
                iActual = 0;

                __int64 dwTime = 0;

                WMIOBJECT_BATCH batch;
                batch.dwArraySize = 250;
                batch.pElements = new WMI_BATCH_OBJECT_ACCESS[250];

                IWmiDbBatchSession *pBatch = NULL;
                hr = pSession->QueryInterface(IID_IWmiDbBatchSession, (void **)&pBatch);        
                tBegin = time(0);
                int iCounter = 0;
                for (int i = iStart; i < iNum+iStart; i++)
                {
                    IWbemClassObject *pInst = NULL;
                    hr = pClass->SpawnInstance(0, &pInst);
                    if (SUCCEEDED(hr))
                    {
                        for (int j = 0; j < arrKeys.Size(); j++)
                        {                            
                            CIMTYPE ct = arrTypes[j];

                            switch(ct)
                            {
                            case CIM_STRING:
                                vTemp.vt = VT_BSTR;
                                swprintf(szTmp, L"%X=%ld", rand(), i);
                                V_BSTR(&vTemp) = SysAllocString(szTmp);
                                break;
                            case CIM_REFERENCE:
                                vTemp.vt = VT_BSTR;
                                swprintf(szTmp, L"root:XXX%X=%ld", rand(), i);
                                V_BSTR(&vTemp) = SysAllocString(szTmp);
                                break;
                            case CIM_UINT64:
                                vTemp.vt = VT_R8;
                                vTemp.dblVal = (double)i;
                                break;
                            default:
                                vTemp.vt = VT_I4;
                                V_I4(&vTemp) = i;
                                break;
                            }
                        
                            hr = pInst->Put((const wchar_t *)arrKeys.GetAt(j), 0, &vTemp, ct);

                            VariantClear(&vTemp);
                        }
                        pInst->Get(L"__RelPath", 0, &vTemp, NULL, NULL);
                        arrPaths.Add(vTemp.bstrVal);
                        VariantClear(&vTemp);

                        batch.pElements[iCounter].pHandle = pInst; 
                        iCounter++;
                    }
                    if (iCounter == 250 || i == (iNum+iStart-1))
                    {
                        for (int j = iCounter; j < 250; j++)
                            batch.pElements[j].pHandle = NULL;

                        batch.dwArraySize = iCounter;
                        iCounter = 0;
                        hr = pBatch->PutObjects(pScope, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_NO_CACHE, &batch);

                        for (j = 0; j < 250; j++)
                        {
                            if (batch.pElements[j].pHandle)
                            {
                                batch.pElements[j].pHandle->Release();
                                batch.pElements[j].pHandle = NULL;
                                if (batch.pElements[j].hRes == 0)
                                {
                                    batch.pElements[j].pReturnHandle->Release();
                                    iActual++;
                                }
                            }
                        }

                    }
                }

                tEnd = time(0);
                dwTime = (tEnd-tBegin);

                if (dwTime && iActual)
                {
                    swprintf(wTemp, L"Average time to put = %ld", ((dwTime)*1000)/iActual);
                    printf("Average PutObjects time (%S): %ld ms\n", lpClassName, ((dwTime)*1000)/iActual);
                    RecordResult(0, wTemp, 0);
                }
                else
                    printf("Average PutObjects time (%S): 0 ms\n", lpClassName);
                pBatch->Release();

                delete batch.pElements;

/*
                HANDLE hThisProcess = GetCurrentProcess();
                PROCESS_MEMORY_COUNTERS counters;

                if (GetProcessMemoryInfo(hThisProcess, &counters, sizeof(PROCESS_MEMORY_COUNTERS)))
                {
                    printf("=== CURRENT MEMORY USAGE === \n");
                    printf("PageFaultCount             %ld\n", counters.PageFaultCount);
                    printf("WorkingSetSize             %ld\n", counters.WorkingSetSize);
                    printf("PeakWorkingSetSize         %ld\n", counters.PeakWorkingSetSize);
                    printf("QuotaPeakPagedPoolUsage    %ld\n", counters.QuotaPeakPagedPoolUsage);
                    printf("QuotaPagedPoolUsage        %ld\n", counters.QuotaPagedPoolUsage);
                    printf("QuotaPeakNonPagedPoolUsage %ld\n", counters.QuotaPeakNonPagedPoolUsage);
                    printf("QuotaNonPagedPoolUsage     %ld\n", counters.QuotaNonPagedPoolUsage);
                    printf("PagefileUsage              %ld\n", counters.PagefileUsage);
                    printf("PeakPagefileUsage          %ld\n\n", counters.PeakPagefileUsage);
                }
*/

                // Query the entire class and time results.
                
                IWbemQuery *pQuery = NULL;
                DWORD dwFlags = 0;
                DWORD dwType = WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_NO_CACHE;
                IWmiDbIterator *pResult = NULL;
                iActual = 0;

                hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 

                swprintf(szTmp, L"select * from %s", (const wchar_t *)sClassName);
                pQuery->Parse(L"SQL", szTmp, 0);

                tBegin = time(0);
                hr = pSession->ExecQuery(pScope, pQuery, dwFlags, dwType, NULL, &pResult);
                if (SUCCEEDED(hr))
                {
                    while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
                    {
                        // Iterator
                        int iNum = 20;
                        DWORD dwNumRet = 0;
                        IUnknown **ppHandle = new IUnknown *[iNum];

                        hr = pResult->NextBatch(iNum, 0, 0, dwType, IID_IWmiDbHandle, &dwNumRet, (void **)ppHandle);

                        for (i = 0; i < (int)dwNumRet; i++)
                            ppHandle[i]->Release();
                        
                        delete ppHandle;
                        iActual += dwNumRet;

                        if (hr == WBEM_S_NO_MORE_DATA)
                            break;
                    }

                    pResult->Release();
                }
                tEnd = time(0);

                swprintf(wTemp, L"Retrieved %ld instances", iActual);
                RecordResult(hr, wTemp, (DWORD)(tEnd-tBegin)*1000);

                dwTime = (tEnd-tBegin);
                if (iActual && dwTime)
                    printf("Average ExecQuery (handle) time (%S): %ld ms\n", lpClassName, ((dwTime)*1000)/iActual);
                else
                    printf("Average ExecQuery (handle) time (%S): 0 ms\n", lpClassName);
                
                swprintf(szTmp, L"select * from %s", (const wchar_t *)sClassName);
                pQuery->Parse(L"SQL", szTmp, 0);

                iActual = 0;
                tBegin = time(0);
                hr = pSession->ExecQuery(pScope, pQuery, dwFlags, dwType, NULL, &pResult);
                if (SUCCEEDED(hr))
                {
                    while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
                    {
                        // Iterator
                        int iNum = 20;
                        DWORD dwNumRet = 0;
                        IUnknown **ppHandle = new IUnknown *[iNum];

                        hr = pResult->NextBatch(iNum, 0, 0, dwType, IID_IWbemClassObject, &dwNumRet, (void **)ppHandle);
                        for (i = 0; i < (int)dwNumRet; i++)
                        {                        
                            IWbemClassObject *pTemp2 = NULL;                        
                            IUnknown *pHand = ppHandle[i];
                            if (pHand)
                            {
                                hr = pHand->QueryInterface(IID_IWbemClassObject, (void **)&pTemp2);
                                if (SUCCEEDED(hr))
                                {
                                    iActual++;
                                    pTemp2->Release();
                                }
                                pHand->Release();
                            }
                        }      
                        delete ppHandle;
                        if (hr == WBEM_S_NO_MORE_DATA)
                            break;
                    }

                    pResult->Release();
                }
                pQuery->Release();
                tEnd = time(0);

                swprintf(wTemp, L"Retrieving %ld populated instances", iActual);
                RecordResult(hr, wTemp, (DWORD)(tEnd-tBegin)*1000);

                dwTime = (tEnd-tBegin);
                if (dwTime && iActual)
                    printf("Average ExecQuery (object) time (%S): %ld ms\n", lpClassName, ((dwTime)*1000)/iActual);
                else
                    printf("Average ExecQuery (object) time (%S): 0 ms\n", lpClassName);

                IWbemPath*pPath = NULL;
                hr = CoCreateInstance(CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, 
                    IID_IWbemPath, (void **)&pPath); 
                iActual = 0;

                tBegin = time(0);
                for (i = 0; i < arrPaths.Size(); i++)
                {
                    pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, arrPaths.GetAt(i));
                    IWmiDbHandle *pTemp2 = NULL;

                    hr = pSession->GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_VERSIONED|WMIDB_HANDLE_TYPE_NO_CACHE, &pTemp2);
                    RecordResult(hr, L"Retrieving %s", 0, lpClassName);
                    if (SUCCEEDED(hr))
                    {
                        pTemp2->Release();
                        iActual++;
                    }
                }
                pPath->Release();
                tEnd = time(0);

                dwTime = (tEnd-tBegin);
                if (dwTime && iActual)
                    printf("Average GetObject time (%S): %ld ms\n", lpClassName, ((dwTime)*1000)/iActual);
                else
                    printf("Average GetObject (handle) time (%S): 0 ms\n", lpClassName);

                swprintf(wTemp, L"Retrieving %ld handles by path", iActual);
                RecordResult(hr, wTemp, (DWORD)(tEnd-tBegin)*1000);

            }                
            pClass->Release();
        }
        pHandle->Release();
    }
    return hr;
}

// *****************************************************

HRESULT TestSuiteStressTest::CreateNamespaces()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    int iTotal = 0;

    IWmiDbHandle *pNamespace = NULL;
    IWbemClassObject *pClass = NULL;
    hr = GetObject(pScope, L"__Namespace", WMIDB_HANDLE_TYPE_COOKIE, 1, &pNamespace, &pClass);
    RecordResult(hr, L"Retrieving __Namespace", 0);
    if (SUCCEEDED(hr))
    {
        pNamespace->Release();
        for (int i = 0; i < GetNumNamespaces(iObjs); i++)
        {
            // This doesn't need to be random, since we 
            // want all threads to be working in the same namespaces.
            IWbemClassObject *pNs1 = NULL;

            pClass->SpawnInstance(0, &pNs1);

            wchar_t wTemp[500];
            swprintf(wTemp, L"Namespace%ld", i+1);
            SetStringProp(pNs1, L"Name", wTemp);
            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pNs1, 0, WMIDB_HANDLE_TYPE_PROTECTED, &pNamespace);
            GetLocalTime(&tEndTime);
            iTotal += GetDiff(tEndTime,tStartTime);

            RecordResult(hr, L"IWmiDbSession::PutObject (__Namespace = Namespace%ld) THREAD %ld", GetDiff(tEndTime,tStartTime), GetCurrentThreadId());

            if (SUCCEEDED(hr))
                hr = CreateClasses(pNamespace, NULL, 1);       
        }   
        iTotal =  iTotal/i;
        RecordResult(0, L"Average create time for namespaces: %ld ms", 0, iTotal);
    }

    wprintf(L"Thread %ld is done\n", GetCurrentThreadId());

    return hr;
}

// *****************************************************
int TrimNumber( int iMin, int iMax, int iLen, int iNumber)
{
    int iTemp = iNumber;
    int iOrigWidth = 0;
    while (iTemp > 0)
    {
        iTemp = iTemp/10;
        iOrigWidth++;
    }
    while (iOrigWidth > iLen)
    {
        iNumber = iNumber/10;
        iOrigWidth--;
    }

    if (iNumber > iMax)
    {
        if (iNumber > 10)
            iNumber = iNumber/10;
        else
            iNumber = iMax;
    }
    if (iNumber < iMin)
        iNumber = iMin;

    return iNumber;
}

// *****************************************************
_bstr_t GetRandomDate()
{
    _bstr_t sRet;
    int iYear=1,iMonth=1,iDay=1,iHour=1,iMinute=0,iSecond=0,iMs=0;

    iYear = TrimNumber(0, 9999, 4, rand());
    iMonth = TrimNumber(1, 12, 2, rand());
    iDay = TrimNumber(1, 29, 2, rand());
    iHour = TrimNumber(1, 23, 2, rand());
    iMinute = TrimNumber(0, 59, 2, rand());
    iSecond = TrimNumber(0, 59, 2, rand());
    iMs = TrimNumber(0, 999, 3, rand());
    
    wchar_t wTemp[30];
    swprintf(wTemp, L"%04ld%02ld%02ld%02ld%02ld%02ld.%06ld+000",
        iYear, iMonth, iDay, iHour, iMinute, iSecond, iMs);
    sRet = wTemp;
    return sRet;
}

// *****************************************************
_bstr_t GetRandomString()
{
    _bstr_t sRet;
    int iLen = TrimNumber(2, 999, 3, rand());
    
    char szTmp[1000];

    // Load it with a bunch of random characters.

    for (int i = 0; i < iLen/2; i++)
        szTmp[i] = (char)TrimNumber(48, 154, 3, rand());

    wchar_t *pNew = new wchar_t[iLen+1];
    swprintf(pNew, L"%S", szTmp);

    sRet = pNew;
    delete pNew;

    return sRet;
}

// *****************************************************
void SetClassProperties(IWbemClassObject *pClass)
{
    // Randomly select from all datatypes.
    // We need at least one key property
    // Some properties may be indexed    
    // There need to be anywhere from 1 to 99 properties
    // If there's a superclass, we won't bother adding more keys.

    CIMTYPE alltypes[] = 
    {CIM_SINT8,     CIM_UINT8,     CIM_SINT16,    CIM_UINT16,
	 CIM_SINT32,    CIM_UINT32,    CIM_DATETIME,  CIM_REFERENCE, 
     CIM_CHAR16,    CIM_STRING,    CIM_REAL32,    CIM_REAL64};

    bool bKeySet = false;
    if (GetStringValue(pClass, L"__SuperClass").length())
        bKeySet = true;
    
     int iTotalProps = TrimNumber(1, 9, 1, rand()); // 9 will allow room for growth.
     for (int i = 0; i < iTotalProps; i++)
     {
         wchar_t sPropName[100];
         CIMTYPE ct = alltypes[TrimNumber(0,11,1,rand())];
         swprintf(sPropName, L"Prop_%ld_%ld_%ld", ct, i, rand());

         pClass->Put(sPropName, 0, NULL, ct); // no defaults.
         
         if (!bKeySet)
         {
             pClass->Put(L"Key1", 0, NULL, CIM_UINT32);
             SetAsKey(pClass, L"Key1");

             if (ct == CIM_UINT32)
                 SetAsKey(pClass, sPropName);

             if (TrimNumber(0,1,1,rand()))
                 bKeySet = true;
         }
         if (!TrimNumber(0, 1, 1, rand()) && (ct == CIM_UINT32 || ct == CIM_STRING))
             SetBoolQualifier(pClass, L"indexed", sPropName);
     }
}

// *****************************************************

void TestSuiteStressTest::SetInstanceProperties(IWbemClassObject *pInstance)
{
    // Enumerate all properties 
    // and set each one with an appropriate value

    HRESULT hr;
    BSTR strName;
    VARIANT vTemp;
    VariantInit(&vTemp);
    CIMTYPE cimtype;
    long lPropFlavor;
    IWbemClassObject *pEmbedClass = NULL;
    IWbemClassObject *pEmbedInstance = NULL;
    IWmiDbHandle *pRet = NULL;

    pInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    while (pInstance->Next(0, &strName, &vTemp, &cimtype, &lPropFlavor) == S_OK)
    {
        switch(cimtype)
        {
            case CIM_BOOLEAN:
                V_BOOL(&vTemp) = (BOOL)rand();
                vTemp.vt = VT_BOOL;
                break;
            case CIM_SINT8:
            case CIM_UINT8:
            case CIM_CHAR16:
                V_UI1(&vTemp) = (unsigned char)rand();
                vTemp.vt = VT_UI1;
                break;
            case CIM_SINT16:
                V_I2(&vTemp) = (short)rand();
                vTemp.vt = VT_I2;
                break;
            case CIM_UINT16:
                V_I4(&vTemp) = rand()/100;
                vTemp.vt = VT_I4;
                break;

            case CIM_SINT32:
            case CIM_UINT32:
                V_I4(&vTemp) = rand();
                vTemp.vt = VT_I4;
                break;
            case CIM_SINT64:
            case CIM_UINT64:
            case CIM_REAL64:
                V_R8(&vTemp) = (double)rand();
                vTemp.vt = VT_R8;
                break;
            case CIM_REAL32:
                V_R4(&vTemp) = (float)rand();
                vTemp.vt = VT_R4;
                break;
            case CIM_STRING:
                // Randomly generate a string.
                V_BSTR(&vTemp) = SysAllocString(GetRandomString());
                vTemp.vt = VT_BSTR;
                break;
            case CIM_REFERENCE:                
                V_BSTR(&vTemp) = SysAllocString(L"Parent1=2");
                vTemp.vt = VT_BSTR;
                break;
            case CIM_DATETIME:
                // Randomly generate a date.                
                V_BSTR(&vTemp) = SysAllocString(GetRandomDate());
                vTemp.vt = VT_BSTR;
                break;
            case CIM_OBJECT:
                // Use an instance of Parent1.
                hr = GetObject(pScope, L"Parent1", WMIDB_HANDLE_TYPE_COOKIE, -1, &pRet, &pEmbedClass);
                RecordResult(hr, L"Retrieving Parent1", 0);
                if (SUCCEEDED(hr))
                {   
                    pRet->Release();
                    pEmbedClass->SpawnInstance(0, &pEmbedInstance);
                    SetIntProp(pEmbedInstance, L"Key1", rand(), TRUE);
                    V_UNKNOWN(&vTemp) = (IUnknown *)pEmbedInstance;
                    vTemp.vt = VT_UNKNOWN;
                }
                break;
        }

        hr = pInstance->Put(strName, 0, &vTemp, cimtype);
        if (FAILED(hr))
            wprintf(L"Failed to set property %s\n", strName);

        SysFreeString(strName);
        VariantClear(&vTemp);
    }
}

// *****************************************************

_bstr_t GetCIMType (CIMTYPE cimtype)
{
    _bstr_t sRet;
    bool bArray = false;

    if (cimtype & 0x2000)
        bArray = true;

    cimtype &= ~0x2000;

    switch(cimtype)
    {
    case CIM_STRING:
        sRet = L"string";
        break;
    case CIM_DATETIME:
        sRet = L"datetime";
        break;
    case CIM_BOOLEAN:
        sRet = L"boolean";
        break;
    case CIM_CHAR16:
        sRet = L"char16";
        break;
    case CIM_UINT8:
        sRet = L"uint8";
        break;
    case CIM_SINT8:
        sRet = L"sint8";
        break;
    case CIM_UINT16:
        sRet = L"uint16";
        break;
    case CIM_SINT16:
        sRet = L"sint16";
        break;
    case CIM_UINT32:
        sRet = L"uint32";
        break;
    case CIM_SINT32:
        sRet = L"sint32";
        break;
    case CIM_UINT64:
        sRet = L"uint64";
        break;
    case CIM_SINT64:
        sRet = L"sint64";
        break;
    case CIM_REAL32:
        sRet = L"real32";
        break;
    case CIM_REAL64:
        sRet = L"real64";
        break;
    case CIM_OBJECT:
        sRet = L"object";
        break;
    case CIM_REFERENCE:
        sRet = L"ref";
        break;
    default:
        sRet = L"string";
        break;
    }
    if (bArray)
        sRet += L"[]";

    return sRet;
}
// *****************************************************

_bstr_t GetBstr (DWORD dwValue)
{
    wchar_t szTmp[30];
    swprintf(szTmp, L"%ld", dwValue);

    return szTmp;
}

_bstr_t GetBstr (double dValue)
{
    wchar_t szTmp[30];
    swprintf(szTmp, L"%lG", dValue);

    return szTmp;
}

_bstr_t GetBstr (VARIANT &vValue)
{
    _bstr_t sRet;
    long i = 0;
    long lUBound = 0;
    long lTemp;
    double dTemp;
    BOOL bTemp;
    SAFEARRAY* psaArray = NULL;
    BSTR sTemp;
    HRESULT hr = 0;

    if (vValue.vt & CIM_FLAG_ARRAY)
    {       
        DWORD dwType = vValue.vt & 0xFF;

        psaArray = V_ARRAY(&vValue);
        if (psaArray)
        {
            hr = SafeArrayGetUBound(psaArray, 1, &lUBound);
            lUBound += 1;
            for (i = 0; i < lUBound; i++)
            {
                _bstr_t sTemp1;

                if (dwType == VT_BOOL)
                {
                    hr = SafeArrayGetElement(psaArray, &i, &bTemp);
                    sTemp1 = GetBstr((DWORD)bTemp);
                }
                else if (dwType == VT_BSTR)
                {
                    hr = SafeArrayGetElement(psaArray, &i, &sTemp);
                    if (wcslen(sTemp) == 0)
                        break;
                    sTemp1 = sTemp;
                }
                else if (dwType == VT_R8)
                {
                    hr = SafeArrayGetElement(psaArray, &i, &dTemp);
                    if (!dTemp)
                        break;
                    sTemp1 = GetBstr(dTemp);
                }
                else
                {
                    hr = SafeArrayGetElement(psaArray, &i, &lTemp);
                    if (!lTemp)
                        break;
                    sTemp1 = GetBstr((DWORD)lTemp);
                }

                if (i > 0)
                    sRet += L",";
                sRet += sTemp1;
            }
        }
        
    }
    else
    {
        switch( (vValue.vt & 0xFF))
        {
        case VT_I1:
            sRet = GetBstr((DWORD)vValue.cVal);
            break;
        case VT_UI1:
            sRet = GetBstr((DWORD)vValue.bVal);
            break;
        case VT_I2:
            sRet = GetBstr((DWORD)vValue.iVal);
            break;
        case VT_I4:
            sRet = GetBstr((DWORD)vValue.lVal);
            break;
        case VT_BOOL:
            sRet = GetBstr((DWORD)vValue.boolVal);
            break;
        case VT_R4:
            sRet = GetBstr((double)vValue.fltVal);
            break;
        case VT_R8:
            sRet = GetBstr((double)vValue.dblVal);
            break;
        case VT_NULL:
        case VT_EMPTY:
            sRet = "";
            break;
        case VT_BSTR:
            sRet = vValue.bstrVal;
            break;
        case VT_UNKNOWN:
            sRet = "";
            break;
        default:    // TO DO: Add all the other datatypes...
            sRet = "";
        }
    }

    return sRet;
}

// *****************************************************

void DumpObject(IWbemClassObject *pIn)
{
    BSTR strName;
    VARIANT vTemp;
    CIMTYPE cimtype;
    long lPropFlavor;

    wprintf(L"*** FAILED OBJECT ***\n");
    wprintf(L"instance of %s\n{\n", (const wchar_t *)GetStringValue(pIn, L"__Class"));

    pIn->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    while (pIn->Next(0, &strName, &vTemp, &cimtype, &lPropFlavor) == S_OK)
    {
        wprintf(L"\t%s %s = %s\n", (const wchar_t *)GetCIMType(cimtype), (const wchar_t *)strName,
            (const wchar_t *)GetBstr(vTemp));
        SysFreeString(strName);
        VariantClear(&vTemp);
    }
    pIn->EndEnumeration();
    wprintf(L"}\n\n");
}

// *****************************************************

HRESULT TestSuiteStressTest::CreateClasses(IWmiDbHandle *pNamespace, IWbemClassObject *pParent, int iCurrDepth)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    int iTotal = 0;

    srand((unsigned)time(NULL));

    for (int j = 0; j < GetNumClasses(iObjs)/iDepth; j++)
    {
        IWmiDbHandle *pClass = NULL;
        IWbemClassObject *pNewClass = NULL;

        if (pParent)
            hr = pParent->SpawnDerivedClass(0, &pNewClass);
        else
        {
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                    IID_IWbemClassObject, (void **)&pNewClass);            
        }
        if (SUCCEEDED(hr))
        {           
            int iRand = rand();
            wchar_t wClassName[255];
            swprintf(wClassName, L"Class%ld_%ld", iRand, GetCurrentThreadId()); // Random classes.  We can find them later by querying __Class.

            SetStringProp(pNewClass, L"__Class", wClassName);

            // Generate a class of random type with
            // random property types.

            SetClassProperties(pNewClass);

            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pNamespace, IID_IWbemClassObject, pNewClass, 0, WMIDB_HANDLE_TYPE_COOKIE, &pClass);
            GetLocalTime(&tEndTime);
            iTotal += GetDiff(tEndTime,tStartTime);

            RecordResult(hr, L"IWmiDbSession::PutObject (%s) THREAD %ld", GetDiff(tEndTime,tStartTime), 
                (const wchar_t *)wClassName, GetCurrentThreadId());
            if (hr == WBEM_E_RERUN_COMMAND)
            {
                int iTimes = 0;
                printf("WARNING: Encountered a deadlock.  Will attempt to rerun command.\n");
                DumpObject(pNewClass);

                while (hr == WBEM_E_RERUN_COMMAND && iTimes < 5)
                {
                    hr = pSession->PutObject(pNamespace, IID_IWbemClassObject, pNewClass, 0, WMIDB_HANDLE_TYPE_COOKIE, &pClass);
                    RecordResult(hr, L"IWmiDbSession::PutObject (%s) THREAD %ld", 0, 
                       (const wchar_t *)wClassName, GetCurrentThreadId());
                    if (SUCCEEDED(hr))
                        break;
                    iTimes++;
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = CreateInstances(pNamespace, pNewClass  );

                if (iDepth < iCurrDepth)
                    hr = CreateClasses(pNamespace, pNewClass, iCurrDepth+1);
                pClass->Release();                
                hr = GetObjects(pNamespace, wClassName);
            }
            else
            {
                IErrorInfo *pInfo = NULL;
                hr = GetErrorInfo(0, &pInfo);
                if (pInfo)
                {
                    BSTR sDescr = NULL;
                    pInfo->GetDescription(&sDescr);
                           
                    wprintf(L"SQL Error: %s\n", (const wchar_t *)sDescr);

                    SysFreeString(sDescr);
                    pInfo->Release();
                }
                DumpObject(pNewClass);
            }

            pNewClass->Release();
        }       
    }

    if (j)
        iTotal =  iTotal/j;

    RecordResult(hr, L"Average create time for classes: %ld ms", 0, iTotal);

    return hr;
}

// *****************************************************

HRESULT TestSuiteStressTest::CreateInstances(IWmiDbHandle *pNamespace, IWbemClassObject *pClass)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;
    int iTotal = 0;

    for (int k = 0; k < GetNumInstances(iObjs); k++)
    {
        IWmiDbHandle *pHandle = NULL;
        IWbemClassObject *pInst = NULL;
        hr = pClass->SpawnInstance(0, &pInst);
        if (SUCCEEDED(hr))
        {
            // Populate the instance.  Choose
            // random data based on the datatypes
            // of the properties.

            SetInstanceProperties(pInst);

            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pNamespace, IID_IWbemClassObject, pInst, 0, WMIDB_HANDLE_TYPE_COOKIE, &pHandle);
            GetLocalTime(&tEndTime);
            iTotal += GetDiff(tEndTime,tStartTime);

            RecordResult(hr, L"IWmiDbSession::PutObject (%s) THREAD %ld", GetDiff(tEndTime,tStartTime),
                (const wchar_t *)GetStringValue(pInst, L"__RelPath"), GetCurrentThreadId());

            if (FAILED(hr))
            {
                int iTimes = 0;
                if (hr == WBEM_E_RERUN_COMMAND)
                    printf("WARNING: Encountered a deadlock.  Will attempt to rerun command.\n");
                DumpObject(pInst);

                while (hr == WBEM_E_RERUN_COMMAND && iTimes < 5)
                {
                    hr = pSession->PutObject(pNamespace, IID_IWbemClassObject, pInst, 0, WMIDB_HANDLE_TYPE_COOKIE, &pHandle);
                    if (SUCCEEDED(hr))
                        pHandle->Release();
                    iTimes++;
                }
            }
            else
                pHandle->Release();

            pInst->Release();

        }
    }

    if (k)
        iTotal =  iTotal/k;

    RecordResult(hr, L"Average create time for instances: %ld ms", 0, iTotal);

    return hr;

}

// *****************************************************

HRESULT TestSuiteStressTest::GetObjects(IWmiDbHandle *pScope, LPWSTR lpClassName)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SYSTEMTIME tStartTime, tEndTime;

    if (Interfaces[IWbemQuery_pos])
    {
        IWmiDbIterator *pIt = NULL;

        IWbemQuery *pQuery = NULL;
        hr = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery); 
        wchar_t wQuery[100];
        swprintf(wQuery, L"select * from %s", lpClassName);
        pQuery->Parse(L"SQL", wQuery, 0);
        
        GetLocalTime(&tStartTime);
        hr = pSession->ExecQuery(pScope, pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIt);
        if (SUCCEEDED(hr))
            pIt->Release();
        GetLocalTime(&tEndTime);

        RecordResult(hr, L"IWmiDbSession::ExecQuery (%s)", GetDiff(tEndTime,tStartTime), wQuery);
    }

    IWmiDbHandle *pRet = NULL;
    IWbemClassObject *pTemp = NULL;
    GetLocalTime(&tStartTime);
    hr = GetObject(pScope, lpClassName, WMIDB_HANDLE_TYPE_COOKIE, -1, &pRet, &pTemp);
    GetLocalTime(&tEndTime);
    RecordResult(hr, L"IWmiDbSession::GetObject (%s)", GetDiff(tEndTime,tStartTime), lpClassName);
    if (SUCCEEDED(hr))
    {
        pRet->Release();
        if (pTemp)
        {
            // Set a bunch of values and update the class.
            SetInstanceProperties(pTemp);
            GetLocalTime(&tStartTime);
            hr = pSession->PutObject(pScope, IID_IWbemClassObject, pTemp, 0, 0, NULL);
            GetLocalTime(&tEndTime);
            RecordResult(hr, L"IWmiDbSession::PutObject (%s)", GetDiff(tEndTime,tStartTime), lpClassName);
            pTemp->Release();
        }
    }
  
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\testmods.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



// *****************************************************
//
//  Testmods.h
//
// *****************************************************


#define NUM_INITIAL_SUITES 4
#define SUITE_FUNC         1
#define SUITE_ERR          2
#define SUITE_STRESS       3
#define SUITE_ALL          0
#define SUITE_CUST         4

#define IWmiDbBatchSession_pos   0
#define IWbemQuery_pos           1
#define IWmiDbObjectSecurity_pos 2
#define IWmiDbIterator_pos       3

extern CLSID ridDriver;

#include <winbase.h>
#include <wmiutils.h>

HRESULT SetAsKey(IWbemClassObject *pObj, LPWSTR lpPropName);
HRESULT SetStringProp(IWbemClassObject *pObj, LPWSTR lpPropName, LPWSTR lpValue, BOOL bKey = FALSE, CIMTYPE ct = CIM_STRING);
HRESULT SetIntProp(IWbemClassObject *pObj, LPWSTR lpPropName, DWORD dwValue, BOOL bKey = FALSE, CIMTYPE ct = CIM_UINT32);
HRESULT ValidateProperty(IWbemClassObject *pObj, LPWSTR lpPropName, CIMTYPE cimtype, VARIANT *vDefault);
HRESULT ValidateProperty(IWbemClassObject *pObj, LPWSTR lpPropName, CIMTYPE cimtype, DWORD dwVal);
HRESULT ValidateProperty(IWbemClassObject *pObj, LPWSTR lpPropName, CIMTYPE cimtype, LPWSTR lpVal);

class TestSuite;

class SuiteManager
{
public:
    HRESULT RunSuite(int iSuiteNum, IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope);
    void DumpResults(BOOL bDetail=FALSE);

    SuiteManager(const wchar_t *pszFileName, const wchar_t *pszLogon, int iMaxThreads, int iMaxDepth, int iMaxNumObjs);
    ~SuiteManager();
private:
    int iMaxThreads;
    int iMaxDepth;
    int iMaxNumObjs;
    TestSuite **ppSuites;
    DWORD dwTotalSuites;
    DWORD dwNumRun;
    DWORD dwNumSuccess;
    DWORD dwNumFailed;
    time_t tStartTime;
    time_t tEndTime;
};

struct StatData
{
    wchar_t    szDescription[100];
    _bstr_t    sErrorInfo;
    DWORD      dwDuration;
    HRESULT    hrErrorCode;
    SYSTEMTIME EndTime;
    StatData   *pNext;
    StatData();
    ~StatData();
    void PrintData();
};

class TestSuite
{
public:
    void DumpResults();
    BOOL RecordResult(HRESULT hrInput, const wchar_t *pszDetails, long lMilliseconds, ...);
    DWORD GetNumRun() {return dwNumRun;}
    DWORD GetNumSuccess() {return dwNumSuccess;}
    DWORD GetNumFailed() {return dwNumFailed;}

    virtual BOOL StopOnFailure() = 0;
    virtual HRESULT RunSuite(IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope) = 0;

    TestSuite(const wchar_t *pszFileName);
    ~TestSuite();

protected:
    HRESULT hMajorResult;
    _bstr_t sResult;
    char szFileName[255];
    DWORD dwNumSuccess;
    DWORD dwNumFailed;
    DWORD dwNumRun;

    StatData *pStats;
    StatData *pEndStat;
    IWmiDbHandle *pScope;
    IWmiDbController *pController;
    IWmiDbSession *pSession;
    BOOL Interfaces[4];

    HRESULT GetObject(IWmiDbHandle *pScope, LPWSTR lpObjName, DWORD dwHandleType, DWORD dwNumObjects, 
                  IWmiDbHandle **pHandle, IWbemClassObject **pObj, LPWSTR lpParent = NULL);
};

// Functionality series

class TestSuiteFunctionality : public TestSuite
{
public:
    BOOL StopOnFailure();
    HRESULT RunSuite(IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope);

    TestSuiteFunctionality(const wchar_t *pszFileName, const wchar_t *pszLogon);
    ~TestSuiteFunctionality();

private:
    HRESULT ValidateAPIs();
    HRESULT CreateObjects();
    HRESULT GetObjects();
    HRESULT HandleTypes();
    HRESULT VerifyCIMClasses();
    HRESULT VerifyMethods();
    HRESULT VerifyCIMTypes();
    HRESULT UpdateObjects();
    HRESULT DeleteObjects();
    HRESULT Query();
    HRESULT Batch();
    HRESULT Security();
    HRESULT ChangeHierarchy();
    HRESULT VerifyContainers();
    HRESULT VerifyTransactions();

    _bstr_t sLogon;

};

// Error testing

class TestSuiteErrorTest : public TestSuite
{
public:
    BOOL StopOnFailure();
    HRESULT RunSuite(IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope);

    TestSuiteErrorTest(const wchar_t *pszFileName, int iNumThreads);
    ~TestSuiteErrorTest();
private:
    HRESULT TryInvalidParams();
    HRESULT TryInvalidHierarchy();
    HRESULT TryLongStrings();
    HRESULT TryChangeDataType();
    HRESULT TryInvalidQuery();

    int iThreads;
};

// Stress testing

class TestSuiteStressTest : public TestSuite
{
public:
    BOOL StopOnFailure();
    HRESULT RunSuite(IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pScope);

    TestSuiteStressTest(const wchar_t *pszFileName, int iDepth, int iMaxObjs, int iMaxThreads);
    ~TestSuiteStressTest();

private:
    HRESULT RunVanillaTest (LPWSTR lpClassName); 

    HRESULT CreateClasses(IWmiDbHandle *pNamespace, IWbemClassObject *pParent, int iCurrDepth);
    HRESULT CreateInstances(IWmiDbHandle *pNamespace, IWbemClassObject *pClass);
    HRESULT CreateNamespaces();
    void SetInstanceProperties(IWbemClassObject *pInstance);
    HRESULT GetObjects(IWmiDbHandle *pScope, LPWSTR lpClassName);
    static HRESULT WINAPI THREAD_RunTest(TestSuiteStressTest *);

    int iDepth;
    int iObjs;
    int iThreads;

    static int iRunning;
    
};

// Custom Repository Driver testing

class TestSuiteCustRepDrvr : public TestSuite
{
public:
    BOOL StopOnFailure();
    HRESULT RunSuite(IWmiDbSession *pSession, IWmiDbController *pController, IWmiDbHandle *pMappedNs);

    TestSuiteCustRepDrvr(const wchar_t *pszFileName);
    ~TestSuiteCustRepDrvr();

    HRESULT TestProducts();
    HRESULT TestCustomers();
    HRESULT TestOrders();
    HRESULT TestConfiguration();
    HRESULT TestEmbeddedEvents();
    HRESULT TestGenericEvents();
    HRESULT TestComputerSystem();
    HRESULT TestCIMLogicalDevice();
    HRESULT TestLogicalDisk();

private:
    IWmiDbSession *pSession;
    IWmiDbController *m_pController;
    IWmiDbHandle *pMappedNs;
    IWbemClassObject *pMappingProp;
    IWbemClassObject *pMappedObj;
    IWbemPath *pPath;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\autotest\winntsec.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.CPP

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#include "precomp.h"

#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <winntsec.h>
#include <tchar.h>

#include <genutils.h>
#include <dbgalloc.h>
#include "arena.h"
#include "reg.h"
#include "wbemutil.h"
#include "arrtempl.h"
extern "C"
{
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
};

//***************************************************************************
//
//  CNtSid::GetSize
//
//  Returns the size of the SID in bytes.
//
//***************************************************************************
// ok

DWORD CNtSid::GetSize()
{
    if (m_pSid == 0 || !IsValidSid(m_pSid))
        return 0;

    return GetLengthSid(m_pSid);
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(CNtSid &Src)
{
    m_pSid = 0;
    m_dwStatus = 0;
    m_pMachine = 0;
    *this = Src;
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(SidType st)
{
    m_pSid = 0;
    m_dwStatus = InternalError;
    m_pMachine = 0;
    if(st == CURRENT_USER ||st == CURRENT_THREAD)
    {
        HANDLE hToken;
        if(st == CURRENT_USER)
        {
            if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
                return;
        }
        else
        {
            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
                return;
        }

        // Get the user sid
        // ================

        TOKEN_USER tu;
        DWORD dwLen = 0;
        GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &dwLen);

        if(dwLen == 0)
        {
            CloseHandle(hToken);
            return;
        }

        BYTE* pTemp = new BYTE[dwLen];
        DWORD dwRealLen = dwLen;
        if(!GetTokenInformation(hToken, TokenUser, pTemp, dwRealLen, &dwLen))
        {
            CloseHandle(hToken);
            delete [] pTemp;
            return;
        }

        CloseHandle(hToken);

        // Make a copy of the SID
        // ======================

        PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;
        DWORD dwSidLen = GetLengthSid(pSid);
        m_pSid = new BYTE[dwSidLen];
        CopySid(dwSidLen, m_pSid, pSid);
        delete [] pTemp;
        m_dwStatus = 0;
    }
    return;
}



//***************************************************************************
//
//  CNtSid::CopyTo
//
//  An unchecked copy of the internal SID to the destination pointer.
//
//  Parameters:
//  <pDestination> points to the buffer to which to copy the SID. The
//  buffer must be large enough to hold the SID.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSid::CopyTo(PSID pDestination)
{
    if (m_pSid == 0 || m_dwStatus != NoError)
        return FALSE;

    DWORD dwLen = GetLengthSid(m_pSid);
    memcpy(pDestination, m_pSid, dwLen);

    return TRUE;
}


//***************************************************************************
//
//  CNtSid assignment operator
//
//***************************************************************************
// ok

CNtSid & CNtSid::operator =(CNtSid &Src)
{
    if (m_pMachine != 0)
    {
        delete [] m_pMachine;
        m_pMachine = 0;
    }

    if (m_pSid != 0)
    {
        delete [] m_pSid;
        m_pSid = 0;
    }

    if (Src.m_pSid == 0)
    {
        m_pSid = 0;
        m_dwStatus = NullSid;
        return *this;
    }

    if (!IsValidSid(Src.m_pSid))
    {
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return *this;
    }


    // If here, the source has a real SID.
    // ===================================

    DWORD dwLen = GetLengthSid(Src.m_pSid);

    m_pSid = (PSID) new BYTE [dwLen];
    ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, Src.m_pSid))
    {
        delete [] m_pSid;
        m_dwStatus = InternalError;
        return *this;
    }

    if (Src.m_pMachine)
    {
        m_pMachine = new wchar_t[wcslen(Src.m_pMachine) + 1];
        wcscpy(m_pMachine, Src.m_pMachine);
    }

    m_dwStatus = NoError;
    return *this;
}

//***************************************************************************
//
//  CNtSid comparison operator
//
//***************************************************************************
int CNtSid::operator ==(CNtSid &Comparand)
{
    if (m_pSid == 0 && Comparand.m_pSid == 0)
        return 1;
    if (m_pSid == 0 || Comparand.m_pSid == 0)
        return 0;

    return EqualSid(m_pSid, Comparand.m_pSid);
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructor which builds a SID directly from a user or group name.
//  If the machine is available, then its name can be used to help
//  distinguish the same name in different SAM databases (domains, etc).
//
//  Parameters:
//
//  <pUser>     The desired user or group.
//
//  <pMachine>  Points to a machine name with or without backslashes,
//              or else is NULL, in which case the current machine, domain,
//              and trusted domains are searched for a match.
//
//  After construction, call GetStatus() to determine if the constructor
//  succeeded.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    DWORD  dwRequired = 0;
    DWORD  dwDomRequired = 0;
    LPWSTR pszDomain = NULL;
    m_pSid = 0;
    m_pMachine = 0;

    if (pMachine)
    {
        m_pMachine = new wchar_t[wcslen(pMachine) + 1];
        wcscpy(m_pMachine, pMachine);
    }

    BOOL bRes = LookupAccountNameW(
        m_pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        m_pSid = 0;
        if (dwLastErr == ERROR_ACCESS_DENIED)
            m_dwStatus = AccessDenied;
        else
            m_dwStatus = InvalidSid;
        return;
    }

    m_pSid = (PSID) new BYTE [dwRequired];
    ZeroMemory(m_pSid, dwRequired);
    pszDomain = new wchar_t[dwDomRequired + 1];

    bRes = LookupAccountNameW(
        pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    if (!bRes || !IsValidSid(m_pSid))
    {
        delete [] m_pSid;
        delete [] pszDomain;
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return;
    }

    delete [] pszDomain;   // We never really needed this
    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructs a CNtSid object directly from an NT SID. The SID is copied,
//  so the caller retains ownership.
//
//  Parameters:
//  <pSrc>      The source SID upon which to base the object.
//
//  Call GetStatus() after construction to ensure the object was
//  constructed correctly.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(PSID pSrc)
{
    m_pMachine = 0;
    m_dwStatus = NoError;

    if (!IsValidSid(pSrc))
    {
        m_dwStatus = InvalidSid;
        return;
    }

    DWORD dwLen = GetLengthSid(pSrc);

    m_pSid = (PSID) new BYTE [dwLen];
    ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, pSrc))
    {
        delete [] m_pSid;
        m_dwStatus = InternalError;
        return;
    }
}

//***************************************************************************
//
//  CNtSid::GetInfo
//
//  Returns information about the SID.
//
//  Parameters:
//  <pRetAccount>       Receives a UNICODE string containing the account
//                      name (user or group).  The caller must use operator
//                      delete to free the memory.  This can be NULL if
//                      this information is not required.
//  <pRetDomain>        Returns a UNICODE string containing the domain
//                      name in which the account resides.   The caller must
//                      use operator delete to free the memory.  This can be
//                      NULL if this information is not required.
//  <pdwUse>            Points to a DWORD to receive information about the name.
//                      Possible return values are defined under SID_NAME_USE
//                      in NT SDK documentation.  Examples are
//                      SidTypeUser, SidTypeGroup, etc.  See CNtSid::Dump()
//                      for an example.
//
//  Return values:
//  NoError, InvalidSid, Failed
//
//***************************************************************************
// ok

int CNtSid::GetInfo(
    LPWSTR *pRetAccount,       // Account, use operator delete
    LPWSTR *pRetDomain,        // Domain, use operator delete
    DWORD  *pdwUse             // See SID_NAME_USE for values
    )
{
    if (pRetAccount)
        *pRetAccount = 0;
    if (pRetDomain)
        *pRetDomain  = 0;
    if (pdwUse)
        *pdwUse   = 0;

    if (!m_pSid || !IsValidSid(m_pSid))
        return InvalidSid;

    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPWSTR pUser = 0;
    LPWSTR pDomain = 0;
    SID_NAME_USE Use;


    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return Failed;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new wchar_t[dwNameLen + 1];
    pDomain = new wchar_t[dwDomainLen + 1];

    bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    if (!bRes)
    {
        delete [] pUser;
        delete [] pDomain;
        return Failed;
    }

    if (pRetAccount)
        *pRetAccount = pUser;
    else
        delete [] pUser;
    if (pRetDomain)
        *pRetDomain  = pDomain;
    else
        delete [] pDomain;
    if (pdwUse)
        *pdwUse = Use;

    return NoError;
}

//***************************************************************************
//
//  CNtSid::Dump
//
//  Dumps the SID to the console outuput for debugging.
//
//***************************************************************************
// ok

void CNtSid::Dump()
{
    LPWSTR pUser, pDomain;
    DWORD dwUse;

    printf("---SID DUMP---\n");

    if (m_pSid == 0)
    {
        printf("<NULL>\n");
        return;
    }

    if (!IsValidSid(m_pSid))
    {
        printf("<Invalid Sid>\n");
        return;
    }

    int nRes = GetInfo(&pUser, &pDomain, &dwUse);

    if (nRes != NoError)
        return;

    // Print out SID in SID-style notation.
    // ====================================

    // Print out human-readable info.
    // ===============================

    printf("User = %S  Domain = %S  Type = ", pUser, pDomain);

    delete [] pUser;
    delete [] pDomain;

    switch (dwUse)
    {
        case SidTypeUser:
            printf("SidTypeUser\n");
            break;

        case SidTypeGroup:
            printf("SidTypeGroup\n");
            break;

        case SidTypeDomain:
            printf("SidTypeDomain\n");
            break;

        case SidTypeAlias:
            printf("SidTypeAlias\n");
            break;

        case SidTypeWellKnownGroup:
            printf("SidTypeWellKnownGroup\n");
            break;

        case SidTypeDeletedAccount:
            printf("SidTypeDeletedAccount\n");
            break;

        case SidTypeUnknown:
            printf("SidTypeUnknown\n");
            break;

        case SidTypeInvalid:
        default:
            printf("SidTypeInvalid\n");
    }
}

//***************************************************************************
//
//  CNtSid destructor
//
//***************************************************************************

CNtSid::~CNtSid()
{
    if (m_pSid)
        delete [] m_pSid;
    if (m_pMachine)
        delete [] m_pMachine;
}

//***************************************************************************
//
//  CNtSid::GetTextSid
//
//  Converts the sid to text form.  The caller should passin a 130 character
//  buffer.
//
//***************************************************************************

BOOL CNtSid::GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen)
{
      PSID_IDENTIFIER_AUTHORITY psia;
      DWORD dwSubAuthorities = 0;
      DWORD dwSidRev=SID_REVISION;
      DWORD dwCounter = 0;
      DWORD dwSidSize = 0;

      // test if Sid is valid

      if(m_pSid == 0 || !IsValidSid(m_pSid))
          return FALSE;

      // obtain SidIdentifierAuthority

      psia=GetSidIdentifierAuthority(m_pSid);

      // obtain sidsubauthority count

      PUCHAR p = GetSidSubAuthorityCount(m_pSid);
      dwSubAuthorities = *p;

      // compute buffer length
      // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL

      dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

      // check provided buffer length.  If not large enough, indicate proper size.

      if (*dwBufferLen < dwSidSize)
      {
         *dwBufferLen = dwSidSize;
         return FALSE;
      }

      // prepare S-SID_REVISION-

      dwSidSize=wsprintf(pszSidText, TEXT("S-%lu-"), dwSidRev );

      // prepare SidIdentifierAuthority

      if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
      {
         dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),
                             TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                             (USHORT)psia->Value[0],
                             (USHORT)psia->Value[1],
                             (USHORT)psia->Value[2],
                             (USHORT)psia->Value[3],
                             (USHORT)psia->Value[4],
                             (USHORT)psia->Value[5]);
      }
      else
      {
         dwSidSize+=wsprintf(pszSidText + lstrlen(pszSidText),
                             TEXT("%lu"),
                             (ULONG)(psia->Value[5]      )   +
                             (ULONG)(psia->Value[4] <<  8)   +
                             (ULONG)(psia->Value[3] << 16)   +
                             (ULONG)(psia->Value[2] << 24)   );
      }

      // loop through SidSubAuthorities

      for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
      {
         dwSidSize+=wsprintf(pszSidText + dwSidSize, TEXT("-%lu"),
         *GetSidSubAuthority(m_pSid, dwCounter) );
      }
      return TRUE;
}


//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <sid>               CNtSid specifying the user or group for which the ACE is being
//                      created.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    CNtSid & Sid
    )
{
    m_pAce = 0;
    m_dwStatus = 0;

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) CWin32DefaultArena::WbemMemAlloc(dwTotal);
    ZeroMemory(m_pAce, dwTotal);

    // Build up the ACE info.
    // ======================

    m_pAce->Header.AceType  = BYTE(dwAceType);
    m_pAce->Header.AceFlags = BYTE(dwAceFlags);
    m_pAce->Header.AceSize = WORD(dwTotal);
    m_pAce->Mask = AccessMask;

    BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

    if (!bRes)
    {
        CWin32DefaultArena::WbemMemFree(m_pAce);
        m_pAce = 0;
        m_dwStatus = InvalidAce;
        return;
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <pUser>             The user or group for which the ACE is being
//                      created.
//  <pMachine>          If NULL, the current machine, domain, and trusted
//                      domains are searched for a match.  If not NULL,
//                      can point to a UNICODE machine name (with or without
//                      leading backslashes) which contains the account.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    m_pAce = 0;
    m_dwStatus = 0;

    // Create the SID of the user.
    // ===========================

    CNtSid Sid(pUser, pMachine);

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) CWin32DefaultArena::WbemMemAlloc(dwTotal);
    ZeroMemory(m_pAce, dwTotal);

    // Build up the ACE info.
    // ======================

    m_pAce->Header.AceType  = BYTE(dwAceType);
    m_pAce->Header.AceFlags = BYTE(dwAceFlags);
    m_pAce->Header.AceSize = WORD(dwTotal);
    m_pAce->Mask = AccessMask;

    BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

    if (!bRes)
    {
        CWin32DefaultArena::WbemMemFree(m_pAce);
        m_pAce = 0;
        m_dwStatus = InvalidAce;
        return;
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtAce::GetAccessMask
//
//  Returns the ACCESS_MASK of the ACe.
//
//***************************************************************************
ACCESS_MASK CNtAce::GetAccessMask()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Mask;
}

//***************************************************************************
//
//  CNtAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD CNtAce::GetSerializedSize()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Header.AceSize;
}

//***************************************************************************
//
//  CNtAce::DumpAccessMask
//
//  A helper function for CNtAce::Dump().  Illustrates the values
//  that the ACCESS_MASK for the ACE can take on.
//
//***************************************************************************
// ok

void CNtAce::DumpAccessMask()
{
    if (m_pAce == 0)
        return;

    ACCESS_MASK AccessMask = m_pAce->Mask;

    printf("Access Mask = 0x%X\n", AccessMask);
    printf("    User Portion = 0x%X\n", AccessMask & 0xFFFF);

    if (AccessMask & DELETE)
        printf("    DELETE\n");
    if (AccessMask & READ_CONTROL)
        printf("    READ_CONTROL\n");
    if (AccessMask & WRITE_DAC)
        printf("    WRITE_DAC\n");
    if (AccessMask & WRITE_OWNER)
        printf("    WRITE_OWNER\n");
    if (AccessMask & SYNCHRONIZE)
        printf("    SYNCHRONIZE\n");
    if (AccessMask & ACCESS_SYSTEM_SECURITY)
        printf("    ACCESS_SYSTEM_SECURITY\n");
    if (AccessMask & MAXIMUM_ALLOWED)
        printf("    MAXIMUM_ALLOWED\n");
    if (AccessMask & GENERIC_ALL)
        printf("    GENERIC_ALL\n");
    if (AccessMask & GENERIC_EXECUTE)
        printf("    GENERIC_EXECUTE\n");
    if (AccessMask & GENERIC_READ)
        printf("    GENERIC_READ\n");
    if (AccessMask & GENERIC_WRITE)
        printf("    GENERIC_WRITE\n");
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Returns a copy of the CNtSid object which makes up the ACE.
//
//  Return value:
//      A newly allocated CNtSid which represents the user or group
//      referenced in the ACE.  The caller must use operator delete to free
//      the memory.
//
//***************************************************************************
// ok

CNtSid* CNtAce::GetSid()
{
    if (m_pAce == 0)
        return 0;

    PSID pSid = 0;

    pSid = &m_pAce->SidStart;

    if (!IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Gets the SID in an alternate manner, by assigning to an existing
//  object instead of returning a dynamically allocated one.
//
//  Parameters:
//  <Dest>              A reference to a CNtSid to receive the SID.
//
//  Return value:
//  TRUE on successful assignment, FALSE on failure.
//
//***************************************************************************

BOOL CNtAce::GetSid(CNtSid &Dest)
{
    CNtSid *pSid = GetSid();
    if (pSid == 0)
        return FALSE;

    Dest = *pSid;
    delete pSid;
    return TRUE;
}


//***************************************************************************
//
//  CNtAce::Dump
//
//  Dumps the current ACE to the console for debugging purposes.
//  Illustrates the structure of the ACE and the values the different
//  fields can take on.
//
//***************************************************************************
// ok

void CNtAce::Dump(int iAceNum)
{
    if(iAceNum != -1)
        printf("\n---ACE DUMP FOR ACE #%d---\n", iAceNum);
    else
        printf("\n---ACE DUMP---\n");

    printf("Ace Type = ");

    if (m_pAce == 0)
    {
        printf("NULL ACE\n");
        return;
    }

    switch (m_pAce->Header.AceType)
    {
        case ACCESS_ALLOWED_ACE_TYPE:
            printf("ACCESS_ALLOWED_ACE_TYPE\n");
            break;

        case ACCESS_DENIED_ACE_TYPE:
            printf("ACCESS_DENIED_ACE_TYPE\n");
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            printf("SYSTEM_AUDIT_ACE_TYPE\n");
            break;

        default:
            printf("INVALID ACE\n");
            break;
    }

    // Dump ACE flags.
    // ===============

    printf("ACE FLAGS = ");

    if (m_pAce->Header.AceFlags & INHERITED_ACE)
        printf("INHERITED_ACE ");
    if (m_pAce->Header.AceFlags & CONTAINER_INHERIT_ACE)
        printf("CONTAINER_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & INHERIT_ONLY_ACE)
        printf("INHERIT_ONLY_ACE ");
    if (m_pAce->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE)
        printf("NO_PROPAGATE_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & OBJECT_INHERIT_ACE)
        printf("OBJECT_INHERIT_ACE ");
    if (m_pAce->Header.AceFlags & FAILED_ACCESS_ACE_FLAG)
        printf(" FAILED_ACCESS_ACE_FLAG");
    if (m_pAce->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        printf(" SUCCESSFUL_ACCESS_ACE_FLAG");
    printf("\n");

    // Dump the SID.
    // =============

    CNtSid *pSid = GetSid();
    pSid->Dump();
    delete pSid;

    DumpAccessMask();
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Alternate constructor which uses a normal NT ACE as a basis for
//  object construction.
//
//  Parameters:
//  <pAceSrc>       A read-only pointer to the source ACE upon which to
//                  base object construction.
//
//  After construction, GetStatus() can be used to determine if the
//  object constructed properly.  NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(PGENERIC_ACE pAceSrc)
{
    m_dwStatus = NoError;

    if (pAceSrc == 0)
    {
        m_dwStatus = NullAce;
        m_pAce = 0;
    }

    m_pAce = (PGENERIC_ACE) CWin32DefaultArena::WbemMemAlloc(pAceSrc->Header.AceSize);
    ZeroMemory(m_pAce, pAceSrc->Header.AceSize);
    memcpy(m_pAce, pAceSrc, pAceSrc->Header.AceSize);
}

//***************************************************************************
//
//  CNtAce copy constructor.
//
//***************************************************************************
// ok

CNtAce::CNtAce(CNtAce &Src)
{
    m_dwStatus = NoError;
    m_pAce = 0;
    *this = Src;
}

//***************************************************************************
//
//  CNtAce assignment operator.
//
//***************************************************************************
// ok

CNtAce &CNtAce::operator =(CNtAce &Src)
{
    if (m_pAce != 0)
        CWin32DefaultArena::WbemMemFree(m_pAce);

    if (Src.m_pAce == 0)
    {
        m_pAce = 0;
        m_dwStatus = NullAce;
        return *this;
    }

    m_pAce = (PGENERIC_ACE) CWin32DefaultArena::WbemMemAlloc(Src.m_pAce->Header.AceSize);
    ZeroMemory(m_pAce, Src.m_pAce->Header.AceSize);
    memcpy(m_pAce, Src.m_pAce, Src.m_pAce->Header.AceSize);
    m_dwStatus = Src.m_dwStatus;
    return *this;
}



//***************************************************************************
//
//  CNtAce destructor
//
//***************************************************************************
// ok

CNtAce::~CNtAce()
{
    if (m_pAce)
        CWin32DefaultArena::WbemMemFree(m_pAce);
}

//***************************************************************************
//
//  CNtAce::GetType
//
//  Gets the Ace Type as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returns ACCESS_ALLOWED_ACE_TYPE, ACCESS_DENIED_ACE_TYPE, or
//      SYSTEM_AUDIT_ACE_TYPE.  Returns -1 on error, such as a null ACE.
//
//      Returning -1 (or an analog) is required as an error code because
//      ACCESS_ALLOWED_ACE_TYPE is defined to be zero.
//
//***************************************************************************
// ok

int CNtAce::GetType()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceType;
}

//***************************************************************************
//
//  CNtAce::GetFlags
//
//  Gets the Ace Flag as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returning -1 if error, other wise the flags.
//
//***************************************************************************

int CNtAce::GetFlags()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceFlags;
}

//***************************************************************************
//
//  CNtAce::GetFullUserName
//
//  Gets the domain\user name.
//
//***************************************************************************

HRESULT CNtAce::GetFullUserName(WCHAR * pBuff, DWORD dwSize)
{
    CNtSid *pSid = GetSid();
    if(pSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtSid> d0(pSid);
    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk);
    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);
    WCHAR wTemp[256];
    wTemp[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
    {
        wcscpy(wTemp, pRetDomain);
        wcscat(wTemp, L"|");
    }
    wcscat(wTemp, pRetAccount);
    wcsncpy(pBuff, wTemp, dwSize-1);
    return S_OK;
}

HRESULT CNtAce::GetFullUserName2(WCHAR ** pBuff)
{
    CNtSid *pSid = GetSid();
    if(pSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtSid> d0(pSid);
    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    if(0 != pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk))
        return WBEM_E_FAILED;

    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);

    int iLen = 3;
    if(pRetAccount)
        iLen += wcslen(pRetAccount);
    if(pRetDomain)
        iLen += wcslen(pRetDomain);
    (*pBuff) = new WCHAR[iLen];
    if((*pBuff) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    (*pBuff)[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
        wcscpy(*pBuff, pRetDomain);
    else
        wcscpy(*pBuff, L".");
    wcscat(*pBuff, L"|");
    wcscat(*pBuff, pRetAccount);
    return S_OK;

}
//***************************************************************************
//
//  CNtAce::Serialize
//
//  Serializes the ace.
//
//***************************************************************************

bool CNtAce::Serialize(BYTE * pData)
{
    if(m_pAce == NULL)
        return false;
    DWORD dwSize = m_pAce->Header.AceSize;
    memcpy((void *)pData, (void *)m_pAce, dwSize);
    return true;
}

//***************************************************************************
//
//  CNtAce::Deserialize
//
//  Deserializes the ace.  Normally this isnt called since the
//  CNtAce(PGENERIC_ACE pAceSrc) constructor is fine.  However, this is
//  used for the case where the db was created on win9x and we are now
//  running on nt.  In that case, the format is the same as outlined in
//  C9XAce::Serialize
//
//***************************************************************************

bool CNtAce::Deserialize(BYTE * pData)
{
    BYTE * pNext;
    pNext = pData + 2*(wcslen((LPWSTR)pData) + 1);
    DWORD * pdwData = (DWORD *)pNext;
    DWORD dwFlags, dwType, dwAccess;
    dwFlags = *pdwData;
    pdwData++;
    dwType = *pdwData;
    pdwData++;
    dwAccess = *pdwData;
    pdwData++;
    CNtAce temp(dwAccess, dwType, dwFlags, (LPWSTR)pData);
    *this = temp;
    return true;

}

//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Constructs an empty ACL with a user-specified size.

//
//  Parameters:
//  <dwInitialSize>     Defaults to 128. Recommended values are 128 or
//                      higher in powers of two.
//
//  After construction, GetStatus() should be called to verify
//  the ACL initialized properly.  Expected value is NoError.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(DWORD dwInitialSize)
{
    m_pAcl = (PACL) CWin32DefaultArena::WbemMemAlloc(dwInitialSize);
    ZeroMemory(m_pAcl, dwInitialSize);
    BOOL bRes = InitializeAcl(m_pAcl, dwInitialSize, ACL_REVISION);

    if (!bRes)
    {
        CWin32DefaultArena::WbemMemFree(m_pAcl);
        m_pAcl = 0;
        m_dwStatus = NullAcl;
        return;
    }

    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtAcl copy constructor.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(CNtAcl &Src)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    *this = Src;
}

//***************************************************************************
//
//  CNtAcl assignment operator
//
//***************************************************************************
// ok

CNtAcl &CNtAcl::operator = (CNtAcl &Src)
{
    if (m_pAcl != 0)
        CWin32DefaultArena::WbemMemFree(m_pAcl);

    // Default to a NULL ACL.
    // ======================

    m_pAcl = 0;
    m_dwStatus = NullAcl;

    if (Src.m_pAcl == 0)
        return *this;

    // Now copy the source ACL.
    // ========================

    DWORD dwSize = Src.m_pAcl->AclSize;

    m_pAcl = (PACL) CWin32DefaultArena::WbemMemAlloc(dwSize);
    ZeroMemory(m_pAcl, dwSize);

    memcpy(m_pAcl, Src.m_pAcl, dwSize);

    // Verify it.
    // ==========

    if (!IsValidAcl(m_pAcl))
    {
        CWin32DefaultArena::WbemMemFree(m_pAcl);
        m_pAcl = 0;
        m_dwStatus = InvalidAcl;
        return *this;
    }

    m_dwStatus = Src.m_dwStatus;
    return *this;
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Returns an ACE at the specified index.  To enumerate ACEs, the caller
//  should determine the number of ACEs using GetNumAces() and then call
//  this function with each index starting from 0 to number of ACEs - 1.
//
//  Parameters:
//  <nIndex>        The index of the desired ACE.
//
//  Return value:
//  A newly allocated CNtAce object which must be deallocated using
//  operator delete.  This is only a copy.  Modifications to the returned
//  CNtAce do not affect the ACL from which it came.
//
//  Returns NULL on error.
//
//***************************************************************************
// ok

CNtAce *CNtAcl::GetAce(int nIndex)
{
    if (m_pAcl == 0)
        return 0;

    LPVOID pAce = 0;

    BOOL bRes = ::GetAce(m_pAcl, (DWORD) nIndex, &pAce);

    if (!bRes)
        return 0;

    return new CNtAce(PGENERIC_ACE(pAce));
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Alternate method to get ACEs to avoid dynamic allocation & cleanup,
//  since an auto object can be used as the parameter.
//
//  Parameters:
//  <Dest>          A reference to a CNtAce to receive the ACE value.
//
//  Return value:
//  TRUE if assigned, FALSE if not.
//
//***************************************************************************

BOOL CNtAcl::GetAce(int nIndex, CNtAce &Dest)
{
    CNtAce *pNew = GetAce(nIndex);
    if (pNew == 0)
        return FALSE;

    Dest = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  CNtAcl::DeleteAce
//
//  Removes the specified ACE from the ACL.
//
//  Parameters:
//  <nIndex>        The 0-based index of the ACE which should be removed.
//
//  Return value:
//  TRUE if the ACE was deleted, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::DeleteAce(int nIndex)
{
    if (m_pAcl == 0)
        return FALSE;

    BOOL bRes = ::DeleteAce(m_pAcl, DWORD(nIndex));

    return bRes;
}

//***************************************************************************
//
//  CNtAcl::GetSize()
//
//  Return value:
//  Returns the size in bytes of the ACL
//
//***************************************************************************
// ok

DWORD CNtAcl::GetSize()
{
    if (m_pAcl == 0 || !IsValidAcl(m_pAcl))
        return 0;

    return DWORD(m_pAcl->AclSize);
}


//***************************************************************************
//
//  CNtAcl::GetAclSizeInfo
//
//  Gets information about used/unused space in the ACL.  This function
//  is primarily for internal use.
//
//  Parameters:
//  <pdwBytesInUse>     Points to a DWORD to receive the number of
//                      bytes in use in the ACL.  Can be NULL.
//  <pdwBytesFree>      Points to a DWORD to receive the number of
//                      bytes free in the ACL.  Can be NULL.
//
//  Return value:
//  Returns TRUE if the information was retrieved, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::GetAclSizeInfo(
    PDWORD pdwBytesInUse,
    PDWORD pdwBytesFree
    )
{
    if (m_pAcl == 0)
        return 0;

    if (!IsValidAcl(m_pAcl))
        return 0;

    if (pdwBytesInUse)
        *pdwBytesInUse = 0;
    if (pdwBytesFree)
        *pdwBytesFree  = 0;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
        return FALSE;

    if (pdwBytesInUse)
        *pdwBytesInUse = inf.AclBytesInUse;
    if (pdwBytesFree)
        *pdwBytesFree  = inf.AclBytesFree;

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::AddAce
//
//  Adds an ACE to the ACL.
//  Ordering semantics for denial ACEs are handled automatically.
//
//  Parameters:
//  <pAce>      A read-only pointer to the CNtAce to be added.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::AddAce(CNtAce *pAce)
{
    // Verify we have an ACL and a valid ACE.
    // ======================================

    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (pAce->GetStatus() != CNtAce::NoError)
        return FALSE;

    // Inherited aces go after non inherited aces

    bool bInherited = (pAce->GetFlags() & INHERITED_ACE) != 0;
    int iFirstInherited = 0;

    // inherited aces must go after non inherited.  Find out
    // the position of the first inherited ace

    int iCnt;
    for(iCnt = 0; iCnt < m_pAcl->AceCount; iCnt++)
    {
        CNtAce *pAce = GetAce(iCnt);
        CDeleteMe<CNtAce> dm(pAce);
        if (pAce)
            if((pAce->GetFlags() & INHERITED_ACE) != 0)
                break;
    }
    iFirstInherited = iCnt;


    // Since we want to add access denial ACEs to the front of the ACL,
    // we have to determine the type of ACE.
    // ================================================================

    DWORD dwIndex;

    if (pAce->GetType() == ACCESS_DENIED_ACE_TYPE)
        dwIndex = (bInherited) ? iFirstInherited : 0;
    else
        dwIndex = (bInherited) ? MAXDWORD : iFirstInherited; 

    // Verify that there is enough room in the ACL.
    // ============================================

    DWORD dwRequiredFree = pAce->GetSize();

    DWORD dwFree = 0;
    DWORD dwUsed = 0;
    GetAclSizeInfo(&dwUsed, &dwFree);

    // If we don't have enough room, resize the ACL.
    // =============================================

    if (dwFree < dwRequiredFree)
    {
        BOOL bRes = Resize(dwUsed + dwRequiredFree);

        if (!bRes)
            return FALSE;
    }

    // Now actually add the ACE.
    // =========================

    BOOL bRes = ::AddAce(
        m_pAcl,
        ACL_REVISION,
        dwIndex,                      // Either beginning or end.
        pAce->GetPtr(),         // Get ptr to ACE.
        pAce->GetSize()                       // One ACE only.
        );

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::Resize()
//
//  Expands the size of the ACL to hold more info or reduces the size
//  of the ACL for maximum efficiency after ACL editing is completed.
//
//  Normally, the user should not attempt to resize the ACL to a larger
//  size, as this is automatically handled by AddAce.  However, shrinking
//  the ACL to its minimum size is recommended.
//
//  Parameters:
//  <dwNewSize>     The required new size of the ACL in bytes.  If set to
//                  the class constant MinimumSize (1), then the ACL
//                  is reduced to its minimum size.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::Resize(DWORD dwNewSize)
{
    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!IsValidAcl(m_pAcl))
        return FALSE;

    // If the ACL cannot be reduced to the requested size,
    // return FALSE.
    // ===================================================

    DWORD dwInUse, dwFree;

    if (!GetAclSizeInfo(&dwInUse, &dwFree))
        return FALSE;

    if (dwNewSize == MinimumSize)       // If user is requesting a 'minimize'
        dwNewSize = dwInUse;

    if (dwNewSize < dwInUse)
        return FALSE;

    // Allocate a new ACL.
    // ===================

    CNtAcl *pNewAcl = new CNtAcl(dwNewSize);

    if (pNewAcl->GetStatus() != NoError)
    {
        delete pNewAcl;
        return FALSE;
    }

    // Loop through ACEs and transfer them.
    // ====================================

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);

        if (pAce == NULL)
        {
            delete pNewAcl;
            return FALSE;
        }

        BOOL bRes = pNewAcl->AddAce(pAce);

        if (!bRes)
        {
            DWORD dwLast = GetLastError();
            delete pAce;
            delete pNewAcl;
            return FALSE;
        }

        delete pAce;
    }

    if (!IsValid())
    {
        delete pNewAcl;
        return FALSE;
    }

    // Now transfer the ACL.
    // =====================

    *this = *pNewAcl;
    delete pNewAcl;

    return TRUE;
}


//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Alternate constructor which builds the object based on a plain
//  NT ACL.
//
//  Parameters:
//  <pAcl>  Pointer to a read-only ACL.
//
//***************************************************************************
// ok
CNtAcl::CNtAcl(PACL pAcl)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    if (pAcl == 0)
    {
        m_dwStatus = NullAcl;
        return;
    }

    if (!IsValidAcl(pAcl))
    {
        m_dwStatus = InvalidAcl;
        return;
    }

    m_pAcl = (PACL) CWin32DefaultArena::WbemMemAlloc(pAcl->AclSize);
    ZeroMemory(m_pAcl, pAcl->AclSize);
    memcpy(m_pAcl, pAcl, pAcl->AclSize);
}

//***************************************************************************
//
//  CNtAcl::GetNumAces
//
//  Return value:
//  Returns the number of ACEs available in the ACL.  Zero is a legal return
//  value. Returns -1 on error
//
//  Aces can be retrieved using GetAce using index values from 0...n-1 where
//  n is the value returned from this function.
//
//***************************************************************************
// ok

int CNtAcl::GetNumAces()
{
    if (m_pAcl == 0)
        return -1;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
    {
        return -1;
    }

    return (int) inf.AceCount;
}

//***************************************************************************
//
//  CNtAcl destructor
//
//***************************************************************************
// ok

CNtAcl::~CNtAcl()
{
    if (m_pAcl)
        CWin32DefaultArena::WbemMemFree(m_pAcl);
}


//***************************************************************************
//
//  CNtAcl::Dump
//
//  Dumps the ACL to the console for debugging purposes.  Illustrates
//  how to traverse the ACL and extract the ACEs.
//
//***************************************************************************
// ok

void CNtAcl::Dump()
{
    printf("---ACL DUMP---\n");

    if (m_pAcl == 0)
    {
        switch (m_dwStatus)
        {
            case NullAcl:
                printf("NullAcl\n");
                break;

            case InvalidAcl:
                printf("InvalidAcl\n");
                break;

            default:
                printf("<internal error; unknown status>\n");
        }
        return;
    }

    DWORD InUse, Free;
    GetAclSizeInfo(&InUse, &Free);
    printf("%d bytes in use, %d bytes free, %d bytes total mem block\n",
        InUse, Free, CWin32DefaultArena::WbemMemSize(m_pAcl)
        );

    printf("Number of ACEs = %d\n", GetNumAces());

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);
        pAce->Dump(i+1);
        delete pAce;
    }

    printf("---END ACL DUMP---\n");

}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  Returns the DACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the DACL.   This object
//  is a copy of the DACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no DACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetDacl()
{
    BOOL bDaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pDacl;
    BOOL bRes = GetSecurityDescriptorDacl(
        m_pSD,
        &bDaclPresent,
        &pDacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bDaclPresent)  // No DACL present
        return 0;

    CNtAcl *pNewDacl = new CNtAcl(pDacl);

    return pNewDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  An alternate method to returns the DACL of the security descriptor.
//  This version uses an existing object instead of returning a
//  dynamically allocated object.
//
//  Parameters:
//  <DestAcl>           A object which will receive the DACL.
//
//  Return value:
//  TRUE on success, FALSE on failure
//
//***************************************************************************

BOOL CNtSecurityDescriptor::GetDacl(CNtAcl &DestAcl)
{
    CNtAcl *pNew = GetDacl();
    if (pNew == 0)
        return FALSE;

    DestAcl = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  SD Helpers
//
//***************************************************************************

SNtAbsoluteSD::SNtAbsoluteSD()
{
    m_pSD = 0;
    m_pDacl = 0;
    m_pSacl = 0;
    m_pOwner = 0;
    m_pPrimaryGroup = 0;
}

SNtAbsoluteSD::~SNtAbsoluteSD()
{
    if (m_pSD)
        CWin32DefaultArena::WbemMemFree(m_pSD);
    if (m_pDacl)
        CWin32DefaultArena::WbemMemFree(m_pDacl);
    if (m_pSacl)
        CWin32DefaultArena::WbemMemFree(m_pSacl);
    if (m_pOwner)
        CWin32DefaultArena::WbemMemFree(m_pOwner);
    if (m_pPrimaryGroup)
        CWin32DefaultArena::WbemMemFree(m_pPrimaryGroup);
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetAbsoluteCopy
//
//  Returns a copy of the current object's internal SD in absolute format.
//  Returns NULL on error.  The memory must be freed with LocalFree().
//
//***************************************************************************
// ok

SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy()
{
    if (m_dwStatus != NoError || m_pSD == 0 || !IsValid())
        return 0;

    // Prepare for conversion.
    // =======================

    DWORD dwSDSize = 0, dwDaclSize = 0, dwSaclSize = 0,
        dwOwnerSize = 0, dwPrimaryGroupSize = 0;

    SNtAbsoluteSD *pNewSD = new SNtAbsoluteSD;

    BOOL bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        delete pNewSD;
        return 0;
    }

    // Allocate the required buffers and convert.
    // ==========================================

    pNewSD->m_pSD = (PSECURITY_DESCRIPTOR) CWin32DefaultArena::WbemMemAlloc(dwSDSize);
    ZeroMemory(pNewSD->m_pSD, dwSDSize);
    pNewSD->m_pDacl   = (PACL) CWin32DefaultArena::WbemMemAlloc(dwDaclSize);
    ZeroMemory(pNewSD->m_pDacl, dwDaclSize);
    pNewSD->m_pSacl   = (PACL) CWin32DefaultArena::WbemMemAlloc(dwSaclSize);
    ZeroMemory(pNewSD->m_pSacl, dwSaclSize);
    pNewSD->m_pOwner  = (PSID) CWin32DefaultArena::WbemMemAlloc(dwOwnerSize);
    ZeroMemory(pNewSD->m_pOwner, dwOwnerSize);
    pNewSD->m_pPrimaryGroup  = (PSID) CWin32DefaultArena::WbemMemAlloc(dwPrimaryGroupSize);
    ZeroMemory(pNewSD->m_pPrimaryGroup, dwPrimaryGroupSize);

    bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (!bRes)
    {
        delete pNewSD;
        return 0;
    }

    return pNewSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetFromAbsoluteCopy
//
//  Replaces the current SD from an absolute copy.
//
//  Parameters:
//  <pSrcSD>    A read-only pointer to the absolute SD used as a source.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetFromAbsoluteCopy(
    SNtAbsoluteSD *pSrcSD
    )
{
    if (pSrcSD ==  0 || !IsValidSecurityDescriptor(pSrcSD->m_pSD))
        return FALSE;


    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSrcSD->m_pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
        return FALSE;

    if (ctrl & SE_SELF_RELATIVE)  // Source is not absolute!!
        return FALSE;

    // If here, we are committed to change.
    // ====================================

    if (m_pSD)
        CWin32DefaultArena::WbemMemFree(m_pSD);

    m_pSD = 0;
    m_dwStatus = NullSD;


    DWORD dwRequired = 0;

    bRes = MakeSelfRelativeSD(
            pSrcSD->m_pSD,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    m_pSD = CWin32DefaultArena::WbemMemAlloc(dwRequired);
    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pSrcSD->m_pSD,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        CWin32DefaultArena::WbemMemFree(m_pSD);
        m_pSD = 0;
        return FALSE;
    }

    m_dwStatus = NoError;
    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::SetDacl
//
//  Sets the DACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************

BOOL CNtSecurityDescriptor::SetDacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;


    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorDacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::Dump
//
//  Dumps the contents of the security descriptor to the console
//  for debugging purposes.
//
//***************************************************************************
// ?

void CNtSecurityDescriptor::Dump()
{
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRev;
    BOOL bRes;

    printf("--- SECURITY DESCRIPTOR DUMP ---\n");

    bRes = GetSecurityDescriptorControl(m_pSD, &Control, &dwRev);

    if (!bRes)
    {
        printf("SD Dump: Failed to get control info\n");
        return;
    }

    printf("Revision : 0x%X\n", dwRev);

    printf("Control Info :\n");

    if (Control & SE_SELF_RELATIVE)
        printf("    SE_SELF_RELATIVE\n");

    if (Control & SE_OWNER_DEFAULTED)
        printf("    SE_OWNER_DEFAULTED\n");

    if (Control & SE_GROUP_DEFAULTED)
        printf("    SE_GROUP_DEFAULTED\n");

    if (Control & SE_DACL_PRESENT)
        printf("    SE_DACL_PRESENT\n");

    if (Control & SE_DACL_DEFAULTED)
        printf("    SE_DACL_DEFAULTED\n");

    if (Control & SE_SACL_PRESENT)
        printf("    SE_SACL_PRESENT\n");

    if (Control & SE_SACL_DEFAULTED)
        printf("    SE_SACL_DEFAULTED\n");

    // Get owner.
    // =========

    CNtSid *pSid = GetOwner();

    if (pSid)
    {
        printf("Owner : ");
        pSid->Dump();
        delete pSid;
    }

    CNtAcl *pDacl = GetDacl();

    if (pDacl == 0)
    {
        printf("Unable to locate DACL\n");
        return;
    }

    printf("DACL retrieved\n");

    pDacl->Dump();

    delete pDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor constructor
//
//  A default constructor creates a no-access security descriptor.
//
//***************************************************************************
//  ok

CNtSecurityDescriptor::CNtSecurityDescriptor()
{
    m_pSD = 0;
    m_dwStatus = NoError;

    PSECURITY_DESCRIPTOR pTmp = CWin32DefaultArena::WbemMemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
    ZeroMemory(pTmp, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeSecurityDescriptor(pTmp, SECURITY_DESCRIPTOR_REVISION))
    {
        CWin32DefaultArena::WbemMemFree(pTmp);
        m_dwStatus = InvalidSD;
        return;
    }

    DWORD dwRequired = 0;

    BOOL bRes = MakeSelfRelativeSD(
            pTmp,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        CWin32DefaultArena::WbemMemFree(pTmp);
        return;
    }

    m_pSD = CWin32DefaultArena::WbemMemAlloc(dwRequired);
    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pTmp,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        CWin32DefaultArena::WbemMemFree(m_pSD);
        m_pSD = 0;
        CWin32DefaultArena::WbemMemFree(pTmp);
        return;
    }

    CWin32DefaultArena::WbemMemFree(pTmp);
    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetSize
//
//  Returns the size in bytes of the internal SD.
//
//***************************************************************************
//  ok

DWORD CNtSecurityDescriptor::GetSize()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    return GetSecurityDescriptorLength(m_pSD);
}


//***************************************************************************
//
//  CNtSecurityDescriptor copy constructor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(CNtSecurityDescriptor &Src)
{
    m_pSD = 0;
    m_dwStatus = NoError;
    *this = Src;
}

//***************************************************************************
//
//  CNtSecurityDescriptor assignment operator
//
//***************************************************************************
// ok

CNtSecurityDescriptor & CNtSecurityDescriptor::operator=(
    CNtSecurityDescriptor &Src
    )
{
    if (m_pSD)
        CWin32DefaultArena::WbemMemFree(m_pSD);

    m_dwStatus = Src.m_dwStatus;
    m_pSD = 0;

    if (Src.m_pSD == 0)
        return *this;

    SIZE_T dwSize = CWin32DefaultArena::WbemMemSize(Src.m_pSD);
    m_pSD = (PSECURITY_DESCRIPTOR) CWin32DefaultArena::WbemMemAlloc(dwSize);
    ZeroMemory(m_pSD, dwSize);
    CopyMemory(m_pSD, Src.m_pSD, dwSize);

    return *this;
}


//***************************************************************************
//
//  CNtSecurityDescriptor destructor.
//
//***************************************************************************
// ok

CNtSecurityDescriptor::~CNtSecurityDescriptor()
{
    if (m_pSD)
        CWin32DefaultArena::WbemMemFree(m_pSD);
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetSacl
//
//  Returns the SACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the SACL.   This object
//  is a copy of the SACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no SACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetSacl()
{
    BOOL bSaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pSacl;
    BOOL bRes = GetSecurityDescriptorSacl(
        m_pSD,
        &bSaclPresent,
        &pSacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bSaclPresent)  // No Sacl present
        return 0;

    CNtAcl *pNewSacl = new CNtAcl(pSacl);

    return pNewSacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetSacl
//
//  Sets the SACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetSacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorSacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetGroup
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetGroup()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorGroup(m_pSD, &pSid, &bDefaulted);

    if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);

}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetGroup
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetGroup(CNtSid *pSid)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;

    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorGroup(
        pTmp->m_pSD,
        pSid->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::HasOwner
//
//  Determines if a security descriptor has an owner.
//
//  Return values:
//      SDNotOwned, SDOwned, Failed
//
//***************************************************************************
// ok

int CNtSecurityDescriptor::HasOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return Failed;

    PSID pSid = 0;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, 0);

    if (!bRes || !IsValidSid(pSid))
        return Failed;

    if (pSid == 0)
        return SDNotOwned;

    return SDOwned;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetOwner
//
//  Returns the SID of the owner of the Security Descriptor or NULL
//  if an error occurred or there is no owner.  Use HasOwner() to
//  determine this.
//
//***************************************************************************
// ok

CNtSid *CNtSecurityDescriptor::GetOwner()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    PSID pSid = 0;
    BOOL bDefaulted;

    BOOL bRes = GetSecurityDescriptorOwner(m_pSD, &pSid, &bDefaulted);

    if (!bRes || !IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetOwner
//
//  Sets the owner of a security descriptor.
//
//  Parameters:
//  <pSid>  The SID of the new owner.
//
//  Return Value:
//  TRUE if owner was changed, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetOwner(CNtSid *pSid)
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!pSid->IsValid())
        return FALSE;

    // We must convert to absolute format to make the change.
    // =======================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = SetSecurityDescriptorOwner(pTmp->m_pSD, pSid->GetPtr(), FALSE);

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    // If here, we have managed the change, so we have to
    // convert *this back from the temporary absolute SD.
    // ===================================================

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return bRes;
}



//***************************************************************************
//
//  CNtSecurityDescriptor::CNtSecurityDescriptor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD,
    BOOL bAcquire
    )
{
    m_pSD = 0;
    m_dwStatus = NullSD;

    // Ensure that SD is not NULL.
    // ===========================

    if (pSD == 0)
    {
        if (bAcquire)
            CWin32DefaultArena::WbemMemFree(pSD);
        return;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            CWin32DefaultArena::WbemMemFree(pSD);
        return;
    }

    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        if (bAcquire)
            CWin32DefaultArena::WbemMemFree(pSD);
        return;
    }

    if ((ctrl & SE_SELF_RELATIVE) == 0)
    {
        // If here, we have to conver the SD to self-relative form.
        // ========================================================

        DWORD dwRequired = 0;

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                CWin32DefaultArena::WbemMemFree(pSD);
            return;
        }

        m_pSD = CWin32DefaultArena::WbemMemAlloc(dwRequired);
        ZeroMemory(m_pSD, dwRequired);

        bRes = MakeSelfRelativeSD(
            pSD,
            m_pSD,
            &dwRequired
            );

        if (!bRes)
        {
            m_dwStatus = InvalidSD;
            if (bAcquire)
                CWin32DefaultArena::WbemMemFree(pSD);
            return;
        }

        m_dwStatus = NoError;
        return;
    }


    // If here, the SD was already self-relative.
    // ==========================================

    if (bAcquire)
        m_pSD = pSD;
    else
    {
        DWORD dwRes = GetSecurityDescriptorLength(pSD);
        m_pSD = CWin32DefaultArena::WbemMemAlloc(dwRes);
        ZeroMemory(m_pSD, dwRes);
        memcpy(m_pSD, pSD, dwRes);
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSecurity::DumpPrivileges
//
//  Dumps current process token privileges to the console.
//
//***************************************************************************

BOOL CNtSecurity::DumpPrivileges()
{
    HANDLE hToken = 0;
    TOKEN_INFORMATION_CLASS tki;
    BOOL bRes;
    LPVOID pTokenInfo = 0;
    DWORD  dwRequiredBytes;
    BOOL   bRetVal = FALSE;
    TOKEN_PRIVILEGES *pPriv = 0;
    TCHAR *pName = 0;
    DWORD dwIndex;
    DWORD dwLastError;

    _tprintf(__TEXT("--- Current Token Privilege Dump ---\n"));

    // Starting point: open the process token.
    // =======================================

    bRes = OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    if (!bRes)
    {
        _tprintf(__TEXT("Unable to open process token\n"));
        goto Exit;
    }

    // Query for privileges.
    // =====================

    tki = TokenPrivileges;

    bRes = GetTokenInformation(
        hToken,
        tki,
        pTokenInfo,
        0,
        &dwRequiredBytes
        );

    dwLastError = GetLastError();

    if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        printf("Unable to get buffer size for token information\n");
        goto Exit;
    }

    pTokenInfo = CWin32DefaultArena::WbemMemAlloc(dwRequiredBytes);
    ZeroMemory(pTokenInfo, dwRequiredBytes);

    bRes = GetTokenInformation(
        hToken,
        tki,
        pTokenInfo,
        dwRequiredBytes,
        &dwRequiredBytes
        );

    if (!bRes)
    {
        printf("Unable to query token\n");
        goto Exit;
    }

    // Loop through the privileges.
    // ============================

    pPriv = (TOKEN_PRIVILEGES *) pTokenInfo;

    for (dwIndex = 0; dwIndex < pPriv->PrivilegeCount; dwIndex++)
    {
        pName = 0;
        dwRequiredBytes = 0;

        // Find the buffer size required for the name.
        // ===========================================

        bRes = LookupPrivilegeName(
            0,                          // System name
            &pPriv->Privileges[dwIndex].Luid,
            pName,
            &dwRequiredBytes
            );

        dwLastError = GetLastError();

        if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            printf("Failed to find privilege name\n");
            goto Exit;
        }

        // Allocate enough space to hold the privilege name.
        // =================================================

        pName = (TCHAR *) CWin32DefaultArena::WbemMemAlloc(dwRequiredBytes);
        ZeroMemory(pName, dwRequiredBytes);

        bRes = LookupPrivilegeName(
            0,                          // System name
            &pPriv->Privileges[dwIndex].Luid,
            pName,
            &dwRequiredBytes
            );

        printf("%s ", pName);
        CWin32DefaultArena::WbemMemFree(pName);

        // Determine the privilege 'status'.
        // =================================

        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_ENABLED)
            printf("<ENABLED> ");
        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
            printf("<ENABLED BY DEFAULT> ");
        if (pPriv->Privileges[dwIndex].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS)
            printf("<USED FOR ACCESS> ");

        printf("\n");

        pName = 0;
    }

    printf("--- End Privilege Dump ---\n");

    bRetVal = TRUE;

Exit:
    if (pTokenInfo)
        CWin32DefaultArena::WbemMemFree(pTokenInfo);
    if (hToken)
        CloseHandle(hToken);
    return bRetVal;
}

//***************************************************************************
//
//  CNtSecurity::SetPrivilege
//
//  Ensures a given privilege is enabled.
//
//  Parameters:
//
//  <pszPrivilegeName>  One of the SE_ constants defined in WINNT.H for
//                      privilege names.  Example: SE_SECURITY_NAME
//  <bEnable>           If TRUE, the privilege will be enabled. If FALSE,
//                      the privilege will be disabled.
//
//  Return value:
//  TRUE if the privilege was enabled, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtSecurity::SetPrivilege(
    TCHAR *pszPrivilegeName,     // An SE_ value.
    BOOL  bEnable               // TRUE=enable, FALSE=disable
    )
{
    HANDLE hToken = 0;
    TOKEN_PRIVILEGES tkp;
    LUID priv;
    BOOL bRes;
    BOOL bRetVal = FALSE;

    bRes = OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    if (!bRes)
        goto Exit;

    // Locate the privilege LUID based on the requested name.
    // ======================================================

    bRes = LookupPrivilegeValue(
        0,                          // system name, 0=local
        pszPrivilegeName,
        &priv
        );

    if (!bRes)
        goto Exit;

    // We now have the LUID.  Next, we build up the privilege
    // setting based on the user-specified <bEnable>.
    // ======================================================

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid  = priv;

    if (bEnable)
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tkp.Privileges[0].Attributes = 0;

    // Do it.
    // ======

    bRes = AdjustTokenPrivileges(
        hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        0,
        0
        );

    if (!bRes)
        goto Exit;

    bRetVal = TRUE;

Exit:
    if (hToken)
        CloseHandle(hToken);
    return bRetVal;
}


//***************************************************************************
//
//  CNtSecurity::GetFileSD
//
//  Gets the complete security descriptor for file or directory on NT systems.
//
//  Parameters:
//  <pszFile>       The path to the file or directory.
//
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//
//  <pReturnedSD>   Receives a pointer to the CNtSecurityDecriptor object
//                  which represents security on the file.  The caller
//                  becomes onwer of the object, which must be deallocated
//                  with operator delete.
//
//                  The returned object which is a copy of the
//                  underlying security descriptor.  Changes to the returned
//                  object are not propagated to the file.  SetFileSD must
//                  be used to do this.
//
//                  This will be set to point to NULL on error.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
// ok

int CNtSecurity::GetFileSD(
    IN  TCHAR *pszFile,
    IN SECURITY_INFORMATION SecInfo,
    OUT CNtSecurityDescriptor **pReturnedSD
    )
{
    // First, verify that the file/dir exists.
    // =======================================

#ifdef _UNICODE
    int nRes = _waccess(pszFile, 0);
#else
    int nRes = _access(pszFile, 0);
#endif

    if (nRes != 0)
    {
        if (errno == ENOENT)
            return NotFound;
        if (errno == EACCES)
            return AccessDenied;
        if (nRes == -1) // Other errors
            return Failed;
    }

    // If here, we think we can play with it.
    // ======================================

    PSECURITY_DESCRIPTOR pSD = 0;
    DWORD dwRequiredBytes;
    BOOL bRes;
    DWORD dwLastError;

    *pReturnedSD = 0;

    // Call once first to get the required buffer sizes.
    // =================================================

    bRes = GetFileSecurity(
        pszFile,
        SecInfo,
        pSD,
        0,
        &dwRequiredBytes
        );

    dwLastError = GetLastError();

    if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
    {
        // Analyze the error

        return Failed;
    }

    // Now call again with a buffer large enough to hold the SD.
    // =========================================================

    pSD = (PSECURITY_DESCRIPTOR) CWin32DefaultArena::WbemMemAlloc(dwRequiredBytes);
    ZeroMemory(pSD, dwRequiredBytes);

    bRes = GetFileSecurity(
        pszFile,
        SecInfo,
        pSD,
        dwRequiredBytes,
        &dwRequiredBytes
        );

    if (!bRes)
    {
        CWin32DefaultArena::WbemMemFree(pSD);
        return Failed;
    }

    // If here, we have a security descriptor.
    // =======================================

    CNtSecurityDescriptor *pNewSD = new CNtSecurityDescriptor(pSD, TRUE);
    *pReturnedSD = pNewSD;

    return NoError;
}

//***************************************************************************
//
//  CNtSecurity::GetRegSD
//
//  Retrieves the security descriptor for a registry key.
//
//  Parameters:
//  <hRoot>         The root key (HKEY_LOCAL_MACHINE, etc.)
//  <pszSubKey>     The subkey under the root key.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           Receives the pointer to the security descriptor if
//                  no error occurs.  Caller must use operator delete.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
int CNtSecurity::GetRegSD(
    IN HKEY hRoot,
    IN TCHAR *pszSubKey,
    IN SECURITY_INFORMATION SecInfo,
    OUT CNtSecurityDescriptor **pSD
    )
{
    HKEY hKey;
    *pSD = 0;

    ACCESS_MASK amAccess = KEY_ALL_ACCESS;
    if (SecInfo & SACL_SECURITY_INFORMATION)
        amAccess |= ACCESS_SYSTEM_SECURITY;

    LONG lRes = RegOpenKeyEx(hRoot, pszSubKey, 0, amAccess, &hKey);

    if (lRes == ERROR_ACCESS_DENIED)
        return AccessDenied;

    if (lRes != ERROR_SUCCESS)
        return Failed;

    // If here, the key is open.  Now we try to get the security descriptor.
    // =====================================================================

    PSECURITY_DESCRIPTOR pTmpSD = 0;
    DWORD dwRequired = 0;

    // Determine the buffer size required.
    // ===================================

    lRes = RegGetKeySecurity(hKey, SecInfo, pTmpSD, &dwRequired);

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    // Allocate room for the SD and get it.
    // ====================================
    pTmpSD = CWin32DefaultArena::WbemMemAlloc(dwRequired);
    ZeroMemory(pTmpSD, dwRequired);

    lRes = RegGetKeySecurity(hKey, SecInfo, pTmpSD, &dwRequired);

    if (lRes != 0 || !IsValidSecurityDescriptor(pTmpSD))
    {
        CWin32DefaultArena::WbemMemFree(pTmpSD);
        RegCloseKey(hKey);
        return Failed;
    }

    RegCloseKey(hKey);
    CNtSecurityDescriptor *pNewSD = new CNtSecurityDescriptor(pTmpSD, TRUE);
    *pSD = pNewSD;

    return NoError;
}


//***************************************************************************
//
//  CNtSecurity::SetRegSD
//
//  Sets the security descriptor for a registry key.
//
//  Parameters:
//  <hRoot>         The root key (HKEY_LOCAL_MACHINE, etc.)
//  <pszSubKey>     The subkey under the root key.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           The read-only pointer to the new security descriptor.
//
//  Return value:
//  NoError, NotFound, AccessDenied, Failed
//
//***************************************************************************
int CNtSecurity::SetRegSD(
    IN HKEY hRoot,
    IN TCHAR *pszSubKey,
    IN SECURITY_INFORMATION SecInfo,
    IN CNtSecurityDescriptor *pSD
    )
{
    HKEY hKey;

    if (!pSD->IsValid())
        return Failed;

    ACCESS_MASK amAccess = KEY_ALL_ACCESS;
    if (SecInfo & SACL_SECURITY_INFORMATION)
        amAccess |= ACCESS_SYSTEM_SECURITY;

    LONG lRes = RegOpenKeyEx(hRoot, pszSubKey, 0, amAccess, &hKey);

    if (lRes == ERROR_ACCESS_DENIED)
        return AccessDenied;

    if (lRes != ERROR_SUCCESS)
        return Failed;

    // If here, the key is open.  Now we try to get the security descriptor.
    // =====================================================================

    PSECURITY_DESCRIPTOR pTmpSD = 0;
    DWORD dwRequired = 0;

    // Determine the buffer size required.
    // ===================================

    lRes = RegSetKeySecurity(hKey, SecInfo, pSD->GetPtr());

    if (lRes != 0)
    {
        RegCloseKey(hKey);
        return Failed;
    }

    RegCloseKey(hKey);
    return NoError;
}



//***************************************************************************
//
//  CNtSecurity::SetFileSD
//
//  Sets the security descriptor for a file or directory.
//
//  Parameters:
//  <pszFile>       The file/dir for which to set security.
//  <SecInfo>       The information which will be manipulated.  See
//                  SECURITY_INFORMATION in NT SDK documentation.
//  <pSD>           Pointer to a valid CNtSecurityDescriptor
//
//***************************************************************************
//  ok
BOOL CNtSecurity::SetFileSD(
    IN TCHAR *pszFile,
    IN SECURITY_INFORMATION SecInfo,
    IN CNtSecurityDescriptor *pSD
    )
{
    // First, verify that the file/dir exists.
    // =======================================
#ifdef _UNICODE
    int nRes = _waccess(pszFile, 0);
#else
    int nRes = _access(pszFile, 0);
#endif

    if (nRes != 0)
        return FALSE;

    // Verify the SD is good.
    // ======================

    if (pSD->GetStatus() != NoError)
        return FALSE;

    BOOL bRes = ::SetFileSecurity(
        pszFile,
        SecInfo,
        pSD->GetPtr()
        );

    return bRes;
}

//***************************************************************************
//
//  CNtSecurity::GetDCName
//
//  Determines the domain controller for a given domain name.
//
//  Parameters:
//  <pszDomain>         The domain name for which to find the controller.
//  <pszDC>             Receives a pointer to the DC name.  Deallocate with
//                      operator delete.
//  <pszServer>         Optional remote helper server on which to execute
//                      the query. Defaults to NULL, which typically
//                      succeeds.
//
//  Return value:
//  NoError, NotFound, InvalidName
//
//***************************************************************************
/*
int CNtSecurity::GetDCName(
    IN  LPWSTR   pszDomain,
    OUT LPWSTR *pszDC,
    IN  LPWSTR   pszServer
    )
{
    LPBYTE pBuf;
    NET_API_STATUS Status;

    Status = NetGetDCName(pszServer, pszDomain, &pBuf);

    if (Status == NERR_DCNotFound)
        return NotFound;

    if (Status == ERROR_INVALID_NAME)
        return InvalidName;

    LPWSTR pRetStr = new wchar_t[wcslen(LPWSTR(pBuf)) + 1];
    wcscpy(pRetStr, LPWSTR(pBuf));
    NetApiBufferFree(pBuf);

    *pszDC = pRetStr;
    return NoError;
}
*/
//***************************************************************************
//
//  CNtSecurity::IsUserInGroup2
//
//  Determines if the use belongs to a particular NTLM group by checking the
//  group list in the access token.  This may be a better way than the
//  current implementation.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************
/*
BOOL CNtSecurity::IsUserInGroup2(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(!IsNT() || hAccessToken == NULL)
        return FALSE;       // No point in further testing

    DWORD dwErr;

    // Obtain and the groups from token.  Start off by determining how much
    // memory is required.

    TOKEN_GROUPS Groups;
    DWORD dwLen = 0;
    GetTokenInformation(hAccessToken, TokenGroups, &Groups, sizeof(Groups), &dwLen);
    if(dwLen == 0)
        return FALSE;

    // Load up the group list

    int BUFFER_SIZE = dwLen;
    BYTE * byteBuffer = new BYTE[BUFFER_SIZE];
    if(byteBuffer == NULL)
        return FALSE;
    DWORD dwSizeRequired = 0;
    BOOL bResult = GetTokenInformation( hAccessToken,
                                        TokenGroups,
                                        (void *) byteBuffer,
                                        BUFFER_SIZE,
                                        &dwSizeRequired );
    if ( !bResult ) {
        delete [] byteBuffer;
        dwErr = GetLastError();
        return ( FALSE );
    }

    // Loop through the group list looking for a match

    BOOL bFound = FALSE;
    PTOKEN_GROUPS pGroups = (PTOKEN_GROUPS) byteBuffer;
    for ( unsigned i = 0; i < pGroups->GroupCount; i++ )
    {
        CNtSid test(pGroups->Groups[i].Sid);
        if(test == Sid)
        {
            bFound = TRUE;
            break;
        }
    }

    delete [] byteBuffer;
    return bFound;
}*/

//***************************************************************************
//
//  CNtSecurity::IsUserInGroup
//
//  Determines if the use belongs to a particular NTLM group.
//
//  Parameters:
//  <hToken>            The user's access token.
//  <Sid>               Object containing the sid of the group being tested.
//
//  Return value:
//  TRUE if the user belongs to the group.
//
//***************************************************************************

BOOL CNtSecurity::IsUserInGroup(
        HANDLE hAccessToken,
        CNtSid & Sid)
{
    if(!IsNT() || hAccessToken == NULL)
        return FALSE;       // No point in further testing

    // create a security descriptor with a single entry which
    // is the group in question.

    CNtAce ace(1,ACCESS_ALLOWED_ACE_TYPE,0,Sid);
    if(ace.GetStatus() != 0)
        return FALSE;

    CNtAcl acl;
    acl.AddAce(&ace);
    CNtSecurityDescriptor sd;
    sd.SetDacl(&acl);
    CNtSid owner(CNtSid::CURRENT_USER);
    sd.SetGroup(&owner);            // Access check doesnt really care what you put, so long as you
                                    // put something for the owner
    sd.SetOwner(&owner);

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0;
    map.GenericExecute = 0;
    map.GenericAll = 0;
    PRIVILEGE_SET ps[10];
    DWORD dwSize = 10 * sizeof(PRIVILEGE_SET);


    DWORD dwGranted;
    BOOL bResult;

    BOOL bOK = ::AccessCheck(sd.GetPtr(), hAccessToken, 1, &map, ps, &dwSize, &dwGranted, &bResult);
    DWORD dwErr = GetLastError();
    if(bOK && bResult)
        return TRUE;
    else
        return FALSE;
}
//***************************************************************************
//
//  CNtSecurity::DoesGroupExist
//
//  Determines if a group exists.
//
//  Return value:
//  TRUE if the group exists
//
//***************************************************************************

bool CNtSecurity::DoesLocalGroupExist(
        LPWSTR pwszGroup,
        LPWSTR pwszMachine)
{
    bool bRet = false;
    HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
    if(hAPI)
    {
        NET_API_STATUS (NET_API_FUNCTION *pfnGetInfo)(LPWSTR , LPWSTR ,DWORD , LPBYTE *);
        (FARPROC&)pfnGetInfo = GetProcAddress(hAPI, "NetLocalGroupGetInfo");
        long lRes;
        if(pfnGetInfo)
        {
            LOCALGROUP_INFO_1 * info;

            lRes = pfnGetInfo(pwszMachine, pwszGroup, 1, (LPBYTE *)&info);
            if(lRes == NERR_Success)
            {
                NET_API_STATUS (NET_API_FUNCTION *pfnBufferFree)(LPVOID);
                (FARPROC&)pfnBufferFree = GetProcAddress(hAPI, "NetApiBufferFree");
                if(pfnBufferFree)
                    pfnBufferFree(info);

                bRet = true;
            }
        }
        FreeLibrary(hAPI);
    }
    return bRet;
}

//***************************************************************************
//
//  CNtSecurity::AddLocalGroup
//
//  Determines if a group exists.
//
//  Return value:
//  TRUE if the group exists
//
//***************************************************************************

bool CNtSecurity::AddLocalGroup(LPWSTR pwszGroupName, LPWSTR pwszGroupDescription)
{
    bool bRet = false;
    HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
    if(hAPI)
    {
        LOCALGROUP_INFO_1 info;
        info.lgrpi1_name = pwszGroupName;
        info.lgrpi1_comment = pwszGroupDescription;
        HINSTANCE hAPI = LoadLibraryEx(__TEXT("netapi32"), NULL, 0);
        if(hAPI)
        {
            NET_API_STATUS (*pfnLocalAdd)(LPWSTR ,DWORD , LPBYTE ,LPDWORD);

            (FARPROC&)pfnLocalAdd = GetProcAddress(hAPI, "NetLocalGroupAdd");
            if(pfnLocalAdd)
                pfnLocalAdd(NULL, 1, (LPBYTE)&info, NULL);
            FreeLibrary(hAPI);
        }
    }
    return bRet;
}

//***************************************************************************
//
//***************************************************************************
void ChangeSecurity(CNtSecurityDescriptor *pSD)
{
    CNtAcl Acl;


    ACCESS_MASK Mask = FULL_CONTROL;


    CNtSid Sid(L"Everyone", 0);
    CNtAce Ace(
        Mask,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
        Sid);

    if (Ace.GetStatus() != CNtAce::NoError)
    {
        printf("Bad ACE\n");
        return;
    }

    CNtAce Ace2(Ace);
    CNtAce Ace3;
    Ace3 = Ace2;

    Acl.AddAce(&Ace3);

    CNtAcl Acl2(Acl);
    CNtAcl Acl3;
    Acl3 = Acl2;

    pSD->SetDacl(&Acl);

    CNtSecurityDescriptor SD2(*pSD);
    CNtSecurityDescriptor SD3;
    SD3.SetDacl(&Acl3);

    SD3 = SD2;

    *pSD = SD3;

    CNtSid *pOwner = pSD->GetOwner();

    if (pOwner)
        pSD->SetOwner(pOwner);
}

//***************************************************************************
//
//***************************************************************************



void SidTest(char *pUser, char *pMachine)
{
    wchar_t User[128], Mach[128];

    MultiByteToWideChar(CP_ACP, 0, pUser, -1, User, 128);
    MultiByteToWideChar(CP_ACP, 0, pMachine, -1, Mach, 128);

    printf("------SID TEST----------\n");

    LPWSTR pMach2 = 0;
    if (pMachine)
        pMach2 = Mach;

    CNtSid TseSid(User, pMach2);

    printf("TseSid status = %d\n", TseSid.GetStatus());

    TseSid.Dump();
}


void TestRegSec()
{

    CNtSecurityDescriptor *pSD = 0;

    int nRes = CNtSecurity::GetRegSD(HKEY_LOCAL_MACHINE,WBEM_REG_WBEM,
        DACL_SECURITY_INFORMATION, &pSD);

    printf("----------------BEGIN SECURITY KEY DUMP-------------\n");
    pSD->Dump();
    printf("----------------END SECURITY KEY DUMP-------------\n");

    if (pSD->IsValid())
        nRes = CNtSecurity::SetRegSD(HKEY_LOCAL_MACHINE, WBEM_REG_WBEM,
                    DACL_SECURITY_INFORMATION, pSD);
}

/*
void main(int argc, char **argv)
{
    BOOL bRes;

    printf("Test\n");

    if (argc < 2)
        return;

    bRes = CNtSecurity::SetPrivilege(SE_SECURITY_NAME, TRUE);

    CNtSecurity::DumpPrivileges();

    CNtSecurityDescriptor *pSD = 0;

    int nRes = CNtSecurity::GetFileSD(argv[1], DACL_SECURITY_INFORMATION, &pSD);

    if (nRes == CNtSecurity::NotFound)
    {
        printf("No such file/dir\n");
        return;
    }

    if (nRes != 0)
    {
        printf("Cannot get security descriptor. Last=%d\n", GetLastError());
    }

    pSD->Dump();


    delete pSD;
}
*/
//***************************************************************************
//
//  FIsRunningAsService
//
//  Purpose:
//  Determines if the current process is running as a service.
//
//  Returns:
//      FALSE if running interactively
//      TRUE if running as a service.
//
//***************************************************************************

/*BOOL FIsRunningAsService(VOID)
{
    HWINSTA hws = GetProcessWindowStation();
    if(hws == NULL)
        return TRUE;

    DWORD LengthNeeded;

    BOOL bService = FALSE;
    USEROBJECTFLAGS fl;
    if(GetUserObjectInformation(hws, UOI_FLAGS, &fl, sizeof(USEROBJECTFLAGS), &LengthNeeded))
        if(fl.dwFlags & WSF_VISIBLE)
            bService = FALSE;
        else
            bService = TRUE;
    CloseWindowStation(hws);
    return bService;
}*/


C9XAce::C9XAce(
        ACCESS_MASK Mask,
        DWORD AceType,
        DWORD dwAceFlags,
        LPWSTR pUser
        )
{
    m_wszFullName = NULL;
    if(pUser)
        m_wszFullName = Macro_CloneLPWSTR(pUser);
    m_dwAccess = Mask;
    m_iFlags = dwAceFlags;
    m_iType = AceType;
}

C9XAce::~C9XAce()
{
    if(m_wszFullName)
        delete [] m_wszFullName;
}

HRESULT C9XAce::GetFullUserName(WCHAR * pBuff, DWORD dwSize)
{
    if(pBuff && m_wszFullName)
    {
        wcsncpy(pBuff, m_wszFullName, dwSize-1);
        pBuff[dwSize-1] = 0;
        return S_OK;
    }
    return WBEM_E_FAILED;
}

HRESULT C9XAce::GetFullUserName2(WCHAR ** pBuff)
{
    if(wcslen(m_wszFullName) < 1)
        return WBEM_E_FAILED;

    int iLen = wcslen(m_wszFullName)+4;
    *pBuff = new WCHAR[iLen];
    if(*pBuff == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // there are two possible formats, the first is "UserName", and the 
    // second is "domain\username".  

    WCHAR * pSlash;
    for(pSlash = m_wszFullName; *pSlash && *pSlash != L'\\'; pSlash++); // intentional

    if(*pSlash && pSlash > m_wszFullName)
    {
        // got a domain\user, convert to domain|user
        
        wcscpy(*pBuff, m_wszFullName);
        for(pSlash = *pBuff; *pSlash; pSlash++)
            if(*pSlash == L'\\')
            {
                *pSlash = L'|';
                break;
            }
    }
    else
    {
        // got a "user", convert to ".|user"
    
        wcscpy(*pBuff, L".|");
        wcscat(*pBuff, m_wszFullName);
    }
    return S_OK;
}

//***************************************************************************
//
//  C9XAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD C9XAce::GetSerializedSize()
{
    if (m_wszFullName == 0 || wcslen(m_wszFullName) == 0)
        return 0;
    return 2 * (wcslen(m_wszFullName) + 1) + 12;
}

//***************************************************************************
//
//  C9XAce::Serialize
//
//  Serializes the ace.  The serialized version will consist of
//  <DOMAIN\USERNAME LPWSTR><FLAGS><TYPE><MASK>
//
//  Note that the fields are dwords except for the name.
//
//***************************************************************************

bool C9XAce::Serialize(BYTE * pData)
{
    wcscpy((LPWSTR)pData, m_wszFullName);
    pData += 2*(wcslen(m_wszFullName) + 1);
    DWORD * pdwData = (DWORD *)pData;
    *pdwData = m_iFlags;
    pdwData++;
    *pdwData = m_iType;
    pdwData++;
    *pdwData = m_dwAccess;
    pdwData++;
    return true;
}

//***************************************************************************
//
//  C9XAce::Deserialize
//
//  Deserializes the ace.  See the comments for Serialize for comments.
//
//***************************************************************************

bool C9XAce::Deserialize(BYTE * pData)
{
    m_wszFullName = new WCHAR[wcslen((LPWSTR)pData) + 1];
    wcscpy(m_wszFullName, (LPWSTR)pData);
    pData += 2*(wcslen(m_wszFullName) + 1);

    DWORD * pdwData = (DWORD *)pData;

    m_iFlags = *pdwData;
    pdwData++;
    m_iType = *pdwData;
    pdwData++;
    m_dwAccess = *pdwData;
    pdwData++;
    return true;

}

//***************************************************************************
//
//  BOOL SetObjectAccess2
//
//  DESCRIPTION:
//
//  Adds read/open and set access for the everyone group to an object.
//
//  PARAMETERS:
//
//  hObj                Object to set access on.
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//
//***************************************************************************

BOOL SetObjectAccess2(IN HANDLE hObj)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLastErr = 0;
    BOOL bRet = FALSE;

    // no point if we arnt on nt

    if(!IsNT())
    {
        return TRUE;
    }

    // figure out how much space to allocate

    DWORD dwSizeNeeded;
    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    0,           // size of buffer for security descriptor
                    &dwSizeNeeded);  // address of required size of buffer

    if(bRet == TRUE || (ERROR_INSUFFICIENT_BUFFER != GetLastError()))
        return FALSE;

    pSD = new BYTE[dwSizeNeeded];
    if(pSD == NULL)
        return FALSE;

    // Get the data

    bRet = GetKernelObjectSecurity(
                    hObj,           // handle of object to query
                    DACL_SECURITY_INFORMATION, // requested information
                    pSD,  // address of security descriptor
                    dwSizeNeeded,           // size of buffer for security descriptor
                    &dwSizeNeeded ); // address of required size of buffer
    if(bRet == FALSE)
    {
        delete pSD;
        return FALSE;
    }
    
    // move it into object for

    CNtSecurityDescriptor sd(pSD,TRUE);    // Acquires ownership of the memory
    if(sd.GetStatus() != 0)
        return FALSE;
    CNtAcl acl;
    if(!sd.GetDacl(acl))
        return FALSE;

    // Create an everyone ace

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;;

    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        CNtAce * pace = new CNtAce(EVENT_MODIFY_STATE | SYNCHRONIZE, ACCESS_ALLOWED_ACE_TYPE, 0 
                                                , SidUsers);
        if(pace == NULL)
            return FALSE;
        if( pace->GetStatus() == 0)
            acl.AddAce(pace);
        delete pace;

    }

    if(acl.GetStatus() != 0)
        return FALSE;
    sd.SetDacl(&acl);
    bRet = SetKernelObjectSecurity(hObj, DACL_SECURITY_INFORMATION, sd.GetPtr());
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\esebackup.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   esebackup.cpp
//
//   cvadai     21-June-2000        created.
//
//***************************************************************************
#include "precomp.h"
#include <std.h>
#include <repdrvr.h>
#include <ese.h>
#include <sqlexec.h>
#include <smrtptr.h>
#include <reputils.h>

extern JET_INSTANCE gJetInst;

//***************************************************************************
//
//  CWmiDbSession::Backup
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Backup( 
    /* [in] */ LPCWSTR lpBackupPath,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // According to their docs, backup can take place even
    // when concurrent processes are accessing the database.

    // JET_PFNSTATUS status;
    // If status is desired, pass into last parameter.

    char *pPath = GetAnsiString((LPWSTR)lpBackupPath);
    CDeleteMe <char> d1 (pPath);

    hr = CSQLExecute::GetWMIError(JetBackup(pPath, JET_bitBackupAtomic, NULL));

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::Restore
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Restore( 
    /* [in] */ LPCWSTR lpRestorePath,
    /* [in] */ LPCWSTR lpDestination,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Restore has to take place before JetInit is called.
    // They have to have obtained this session with the WMIDB_FLAG_NO_INIT flag,
    // so JetInit will not have been called.
    // If a controller had been previously initialized, they will have to 
    // call Shutdown, unload it completely, and then obtain a new session 
    // on which to call Restore.

    // JET_PFNSTATUS status;
    // If status is desired, pass into last parameter.

    if (!m_pController || (((CWmiDbController *)m_pController)->m_bCacheInit))
        return WBEM_E_INVALID_OPERATION;

    char *pRestoreFrom = GetAnsiString((LPWSTR)lpRestorePath);
    char *pRestoreTo = GetAnsiString((LPWSTR)lpDestination);

    CDeleteMe <char> d1 (pRestoreFrom), d2 (pRestoreTo);

    hr = CSQLExecute::GetWMIError(JetRestore2(pRestoreFrom, pRestoreTo, NULL));  

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\QUASAR\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\dllentryjet.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  dllentry.cpp
//
//
//
//
//
//
//  History:
//
//      cvadai      4/1/1999    created.
//
//
//  Copyright (c)1999-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////////////////

//#define _AFXDLL

// #include <afxwin.h>
#include "precomp.h"
#include <comdef.h>
#include <std.h>
#include <clsfctry.h>
#include <reposit.h>

extern long g_cObj;
extern long g_cLock;

const wchar_t * g_pszComServerName   = L"WINMGMT Jet Repository Driver";
const wchar_t * g_pszThreadingModel  = L"Both";


// static AFX_EXTENSION_MODULE ExtDLL;
HINSTANCE       hHandle;

//******************************************************************************
//
//  DllMain()
//
//******************************************************************************
extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // If the process is attaching to this extension DLL, initialize:
    // ==============================================================

    if (dwReason == DLL_PROCESS_ATTACH) 
    {
        hHandle = GetModuleHandle(L"REPDRVJ.DLL");
    }

    // Return successfully.
    // ====================

    return(TRUE);
}


//-----------------------------------------------------------------------------
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    HRESULT hr = E_FAIL;

    if (CLSID_WmiRepository_Jet==rclsid)
    {
        CControllerFactory * pObj = new CControllerFactory();

        if (pObj != NULL)
        {
            hr = pObj->QueryInterface(riid, ppv);

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
        else
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
        }
    }

    return hr;
}

//-----------------------------------------------------------------------------
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//
//

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=( g_cObj < 1 && g_cLock < 1) ? S_OK : S_FALSE;
    return sc;
}

//-----------------------------------------------------------------------------
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//
//

STDAPI DllRegisterServer(void)
{   
    WCHAR   wcID[128];
    wchar_t szCLSID[128];
    wchar_t szModule[MAX_PATH];
    HKEY    hKey1;
    HKEY    hKey2;

    // Create the path.

    StringFromGUID2(CLSID_WmiRepository_Jet, wcID, 128);
    wcscpy(szCLSID, TEXT("CLSID\\"));
    wcscat(szCLSID, wcID);


    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)g_pszComServerName, wcslen(g_pszComServerName)*2);
    RegCreateKey(hKey1,L"InprocServer32",&hKey2);

    HINSTANCE hInst = GetModuleHandle(L"repdrvj.DLL");
    GetModuleFileName(hInst, szModule,  MAX_PATH);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, wcslen(szModule)*2);
    RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)g_pszThreadingModel, wcslen(g_pszThreadingModel)*2);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}


//-----------------------------------------------------------------------------
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//
//

STDAPI DllUnregisterServer(void)
{
    wchar_t szID[128];
    WCHAR   wcID[128];
    wchar_t szCLSID[128];
    HKEY    hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_WmiRepository_Jet, wcID,sizeof(wcID));
    wcscpy(szCLSID, L"CLSID\\");
    wcscat(szCLSID, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\eseitrtr.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   eseitrtr.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _ESEIT_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#include "precomp.h"

#include <std.h>
#include <smrtptr.h>
#include <repdrvr.h>
#include <eseitrtr.h>
#include <eseutils.h>
#include <eseobjs.h>
#include <reputils.h>
#include <wbemint.h>
#include <repcache.h>
#include <like.h>
#include <datepart.h>

typedef std::map <DWORD, DWORD> Properties;

//***************************************************************************
//
//  CWmiESEIterator::CWmiESEIterator
//
//***************************************************************************

CWmiESEIterator::CWmiESEIterator()
{
    m_pSession = NULL;
    m_uRefCount = 0;
    m_pConn = NULL;
    m_pToks = NULL;
    m_bFirst = TRUE;
    m_bEnum = FALSE;
    m_bWQL = FALSE;
    m_iStartPos = 0;
    m_iLastPos = 0;
    m_bClasses = FALSE;
}

//***************************************************************************
//
//  CWmiESEIterator::~CWmiESEIterator
//
//***************************************************************************
CWmiESEIterator::~CWmiESEIterator()
{
    Cancel(0);
    if (m_pSession)
        m_pSession->Release();

    delete m_pToks;
}

//***************************************************************************
//
//  CWmiESEIterator::QueryInterface
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiESEIterator::QueryInterface
        (REFIID riid,
        void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_IWmiDbIterator==riid )
    {
        *ppvObject = (IWmiDbIterator *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//  CWmiESEIterator::AddRef
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiESEIterator::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//  CWmiESEIterator::Release
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiESEIterator::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return WBEM_S_NO_ERROR;
}
//***************************************************************************
//
//  CWmiESEIterator::Cancel
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiESEIterator::Cancel( 
    /* [in] */ DWORD dwFlags) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_pConn)
    {
        if (m_pSession->m_pController)
            ((CWmiDbController *)m_pSession->m_pController)->ConnCache.ReleaseConnection(m_pConn, hr);        
        m_pConn = NULL;
    }       

    if (m_pSession)
        ((CWmiDbSession *)m_pSession)->UnlockDynasties();

    return hr;
}

//***************************************************************************
//
//  CWmiESEIterator::NextBatch
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiESEIterator::NextBatch( 
    /* [in] */ DWORD dwNumRequested,
    /* [in] */ DWORD dwTimeOutSeconds,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [in] */ REFIID riid,
    /* [out] */ DWORD __RPC_FAR *pdwNumReturned,
    /* [iid_is][length_is][size_is][out] */ LPVOID __RPC_FAR *ppObjects)
{

    HRESULT hr = WBEM_S_NO_ERROR, hrRet = WBEM_S_NO_ERROR;
    bool bImmediate = !(dwRequestedHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED);

    hr = TestDriverStatus();
    if (FAILED(hr))
        return hr;

    if (!dwNumRequested || !ppObjects)
        return WBEM_E_INVALID_PARAMETER;

    if (dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID &&
        riid == IID_IWmiDbHandle)
        return WBEM_E_INVALID_PARAMETER;
   
    if (dwFlags & WMIDB_FLAG_LOOKAHEAD || 
        (riid != IID_IWmiDbHandle &&
         riid != IID_IWbemClassObject &&
         riid != IID__IWmiObject))
        /// UuidCompare(pIIDRequestedInterface, &IID_IWmiDbHandle, NULL) ||
        // UuidCompare(pIIDRequestedInterface, &IID_IWbemClassObject, NULL))
        return WBEM_E_NOT_SUPPORTED;

    // Read the current row, compare it against m_pToks
    // Continue until we run out of rows, or meet the requested number.

    LPWSTR lpKey = NULL;

    try
    {
        SQL_ID dObjectId = 0, dClassId = 0, dScopeId = 0;
        int iNumRetrieved = 0;

        hr = GetFirstMatch(dObjectId, dClassId, dScopeId, &lpKey);
        while (SUCCEEDED(hr) )
        {
            CDeleteMe <wchar_t> d (lpKey);

            hr = ((CWmiDbSession *)m_pSession)->VerifyObjectSecurity(NULL, dObjectId, dClassId, dScopeId, 0, WBEM_ENABLE);
            if (SUCCEEDED(hr))
            {
                if (FAILED(hr = TestDriverStatus()))
                    break;

                if (riid == IID_IWmiDbHandle)
                {                            
                    CWmiDbHandle *pTemp = new CWmiDbHandle;
                    if (pTemp)
                    {
                        ((CWmiDbSession *)m_pSession)->AddRef_Lock();
                        DWORD dwVersion = 0;
                        // Obtain a lock for this object
                        // =============================                      

                        hr = ((CWmiDbController *)m_pSession->m_pController)->LockCache.AddLock(bImmediate, dObjectId, dwRequestedHandleType, pTemp, 
                            dScopeId, dClassId, &((CWmiDbController *)m_pSession->m_pController)->SchemaCache, false,
                            0, 0, &dwVersion);
                        
                        if (FAILED(hr))
                        {
                            delete pTemp;
                            // If they failed to get a handle, what do we do?
                            // Ignore it and continue, I guess.
                            hrRet = WBEM_S_PARTIAL_RESULTS;
                            ppObjects[iNumRetrieved] = NULL;
                            
                        }
                        else
                        {
                            pTemp->m_pSession = m_pSession;
                            pTemp->AddRef();
                            ((CWmiDbController *)m_pSession->m_pController)->AddHandle();
                            pTemp->m_dwVersion = dwVersion;
                            pTemp->m_dwHandleType = dwRequestedHandleType;
                            pTemp->m_dClassId = dClassId;
                            pTemp->m_dObjectId = dObjectId;

                            if (pTemp->m_dClassId == MAPPEDNSCLASSID)
                                pTemp->m_bDefault = FALSE;
                            if (dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
                                pTemp->m_bSecDesc = TRUE;

                            pTemp->m_dScopeId = dScopeId;

                            ppObjects[iNumRetrieved] = pTemp;                                                        
                        }
                        iNumRetrieved++;
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
                else if (riid == IID_IWbemClassObject ||
                            riid == IID__IWmiObject)
                {
                    IWbemClassObject *pTemp = NULL;
                    DWORD dwVer = 0;

                    if (m_dwOpenTable == OPENTABLE_CLASSMAP)
                    {
                        // If this is a class, we need to populate it on
                        // a different connection, so we don't lose our
                        // pointer into the db.

                        CSQLConnection *pConn = NULL;
                        if (((CWmiDbSession *)m_pSession)->m_pController)
                        {
                            hr = ((CWmiDbController *)((CWmiDbSession *)m_pSession)->m_pController)->ConnCache.GetConnection(&pConn, FALSE, FALSE);
                            if (SUCCEEDED(hr))
                            {
                                hr = ((CWmiDbSession *)m_pSession)->GetObjectData(pConn, dObjectId, dClassId, dScopeId,
                                    0, dwVer, &pTemp, TRUE, lpKey, dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR);
                                
                                if (((CWmiDbSession *)m_pSession)->m_pController)
                                    ((CWmiDbController *)((CWmiDbSession *)m_pSession)->m_pController)->ConnCache.ReleaseConnection(pConn, hr, FALSE);
                            }
                        }
                    }
                    else if (m_dwOpenTable == OPENTABLE_INDEXREF)
                    {
                        CSQLConnection *pConn = NULL;
                        if (((CWmiDbSession *)m_pSession)->m_pController)
                        {
                            hr = ((CWmiDbController *)((CWmiDbSession *)m_pSession)->m_pController)->ConnCache.GetConnection(&pConn, FALSE, FALSE);
                            if (SUCCEEDED(hr))
                            {
                                m_pSession->LoadClassInfo(pConn, dClassId, FALSE);

                                hr = ((CWmiDbSession *)m_pSession)->GetObjectData(pConn, dObjectId, dClassId, dScopeId,
                                    0, dwVer, &pTemp, TRUE, lpKey, dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR);

                                if (((CWmiDbSession *)m_pSession)->m_pController)
                                    ((CWmiDbController *)((CWmiDbSession *)m_pSession)->m_pController)->ConnCache.ReleaseConnection(pConn, hr, FALSE);
                            }
                        }
                    }
                    else
                    {
                        hr = ((CWmiDbSession *)m_pSession)->GetObjectData(m_pConn, dObjectId, dClassId, dScopeId,
                            0, dwVer, &pTemp, TRUE, lpKey, dwFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR);

                    }

                    ppObjects[iNumRetrieved] = pTemp;
                    if (FAILED(hr))
                        hrRet = WBEM_S_PARTIAL_RESULTS;
                    else
                        iNumRetrieved++;

                }
            }
            else
                hrRet = WBEM_S_PARTIAL_RESULTS;

            hr = TestDriverStatus();
            if (SUCCEEDED(hr))
            {
                if (m_pSession && ((CWmiDbSession *)m_pSession)->m_pController)
                    ((CWmiDbController *)m_pSession->m_pController)->IncrementHitCount(false);
            }
            else
                break;

            if (iNumRetrieved == dwNumRequested)
                break;

            hr = GetNextMatch(dObjectId, dClassId, dScopeId, &lpKey);
        }

        if (pdwNumReturned)
            *pdwNumReturned = iNumRetrieved;

        // Null out m_pStatus if there are no more results!!!
        if ((hr == WBEM_S_NO_MORE_DATA || !iNumRetrieved) &&
            hr != WBEM_E_SHUTTING_DOWN)
        {
            hrRet = WBEM_S_NO_MORE_DATA;
            Cancel(0);
        }
    }
    catch (...)
    {
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hrRet;
}

//***************************************************************************
//
//  CWmiESEIterator::GetFirstMatch
//
//***************************************************************************

HRESULT CWmiESEIterator::GetFirstMatch(SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID &dScopeId,
                                       LPWSTR * lpKey)
{
    HRESULT hr = 0;

    // Loop through the table we have chosen to 
    // scan on, and see if any objects match.

    hr = GetNextMatch(dObjectId, dClassId, dScopeId, lpKey, m_bFirst);
    m_bFirst = FALSE;

    return hr;
}

//***************************************************************************
//
//  CWmiESEIterator::GetNextMatch
//
//***************************************************************************

HRESULT CWmiESEIterator::GetNextMatch(SQL_ID &dObjectId, SQL_ID &dClassId, 
                                      SQL_ID &dScopeId, LPWSTR * lpKey, BOOL bFirst)
{
    HRESULT hr = 0;

    OBJECTMAP oj;
    CLASSMAP cd;
    CONTAINEROBJ co;
    INDEXDATA id;
    REFERENCEPROPERTIES pm;
    DWORD dwType = 0;

    if (lpKey)
        *lpKey = NULL;

    switch(m_dwOpenTable)
    {
    case OPENTABLE_CLASSMAP:
        if (!bFirst)
            hr = GetNext_ClassMap(m_pConn, cd);
        else
            hr = GetClassMapData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), m_tableid, cd);

        while (SUCCEEDED(hr))
        {
            hr = TestDriverStatus();
            if (FAILED(hr))
                break;

            hr = GetFirst_ObjectMap(m_pConn, cd.dClassId, oj);
            
            if (oj.dObjectId != dObjectId && oj.iObjectState != 2)
            {
                if (ObjectMatches(oj.dObjectId, oj.dClassId, oj.dObjectScopeId))
                {
                    dObjectId = oj.dObjectId;
                    dClassId = oj.dClassId;
                    dScopeId = oj.dObjectScopeId;
                    if (lpKey)
                    {
                        if (oj.sObjectKey)
                        {
                            LPWSTR lpNew = new wchar_t[wcslen(oj.sObjectKey)+1];
                            if (lpNew)
                            {
                                wcscpy(lpNew, oj.sObjectKey);
                                *lpKey = lpNew;
                            }
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    
                    oj.Clear();
                    break;
                }
            }

            oj.Clear();
            hr = GetNext_ClassMap(m_pConn, cd);
        }
        cd.Clear();

        break;
    case OPENTABLE_OBJECTMAP:
        // If here, the query is too complex to evaluate
        // through indices.  Scan on each participating
        // class.

        if (!bFirst)
            hr = GetNext_ObjectMap(m_pConn, oj);
        else
        {
            hr = GetObjectMapData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), m_tableid, oj);
        }

        while (TRUE)
        {
            while (SUCCEEDED(hr) )
            {
                hr = TestDriverStatus();
                if (FAILED(hr))
                    break;

                if (m_bClasses)
                {
                    if (oj.dClassId != 1)
                    {
                        hr = GetNext_ObjectMap(m_pConn, oj);            
                        continue;
                    }
                }

                if (oj.dObjectId != dObjectId && oj.iObjectState != 2)
                {
                    if (ObjectMatches(oj.dObjectId, oj.dClassId, oj.dObjectScopeId))
                    {
                        dObjectId = oj.dObjectId;
                        dClassId = oj.dClassId;
                        dScopeId = oj.dObjectScopeId;
                        if (lpKey)
                        {
                            if (oj.sObjectKey)
                            {
                                LPWSTR lpNew = new wchar_t[wcslen(oj.sObjectKey)+1];
                                if (lpNew)
                                {
                                    wcscpy(lpNew, oj.sObjectKey);
                                    *lpKey = lpNew;
                                }
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                        oj.Clear();
                        break;
                    }
                }
                hr = GetNext_ObjectMap(m_pConn, oj);            
            }
        
            if (!m_bEnum && hr == WBEM_E_NOT_FOUND)
            {
                // See if there is other class criteria
                // We expect each derived class to be
                // listed as separate tokens.

                DWORD dwNumToks = m_pToks->GetNumTokens();
                BOOL bEnd = TRUE;

                for (int i = m_iLastPos+1; i < dwNumToks; i++)
                {
                    ESEToken *pTok = m_pToks->GetToken(i);
                    if (pTok->tokentype == ESE_EXPR_TYPE_EXPR)
                    {
                        ESEWQLToken *pTok2 = (ESEWQLToken *)pTok;
                        if (pTok2->Value.valuetype == ESE_VALUE_TYPE_SYSPROP)
                        {
                            if (pTok2->dClassId)
                            {
                                hr = GetFirst_ObjectMapByClass(m_pConn, pTok2->dClassId, oj);
                                if (SUCCEEDED(hr))
                                {
                                    m_iLastPos = i;
                                    bEnd = FALSE;                                    
                                    break;
                                }
                            }
                        }
                    }
                }

                if (bEnd)
                    break;
            }
            else
                break;
        }

        break;

    case OPENTABLE_INDEXNUMERIC:
    case OPENTABLE_INDEXSTRING:
    case OPENTABLE_INDEXREAL:
    case OPENTABLE_INDEXREF:

        // If here, we should have ANDed criteria
        // only, or an A AND (B OR C) construct.
        // That means we only have to scan once.

        if (m_dwOpenTable == OPENTABLE_INDEXNUMERIC)
            dwType = SQL_POS_INDEXNUMERIC;
        else if (m_dwOpenTable == OPENTABLE_INDEXSTRING)
            dwType = SQL_POS_INDEXSTRING;
        else if (m_dwOpenTable == OPENTABLE_INDEXREAL)
            dwType = SQL_POS_INDEXREAL;
        else if (m_dwOpenTable == OPENTABLE_INDEXREF)
            dwType = SQL_POS_INDEXREF;
        if (m_tableid)
        {
            if (!bFirst)
                hr = GetNext_IndexData(m_pConn, m_tableid, dwType, id);
            else
                hr = GetIndexData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), 
                            m_tableid, dwType, id);
            while (SUCCEEDED(hr))
            {
                hr = TestDriverStatus();
                if (FAILED(hr))
                    break;

                if (id.dObjectId != dObjectId)
                {
                    hr = GetFirst_ObjectMap(m_pConn, id.dObjectId, oj);
                    if ((oj.iObjectState != 2) && ObjectMatches(id.dObjectId, oj.dClassId, oj.dObjectScopeId, &id,
                        NULL, &dObjectId, &dClassId, &dScopeId))
                    {
                        oj.Clear();
                        break;
                    }
                    oj.Clear();
                }
                hr = GetNext_IndexData(m_pConn, m_tableid, dwType, id);
            }
        }
        else
            hr = WBEM_E_INVALID_QUERY;
        break;

    case OPENTABLE_CONTAINEROBJS:
        if (!bFirst)
            hr = GetNext_ContainerObjs(m_pConn, co);
        else
            hr = GetContainerObjsData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), m_tableid, co);
        while (SUCCEEDED(hr))
        {
            hr = TestDriverStatus();
            if (FAILED(hr))
                break;

            if (co.dContaineeId != dObjectId)
            {
                hr = GetFirst_ObjectMap(m_pConn, co.dContaineeId, oj);
                if ((oj.iObjectState != 2) && ObjectMatches(co.dContaineeId, oj.dClassId, oj.dObjectScopeId))
                {
                    dObjectId = oj.dObjectId;
                    dClassId = oj.dClassId;
                    dScopeId = oj.dObjectScopeId;
                    oj.Clear();
                    break;
                }                
                oj.Clear();
            }
            hr = GetNext_ContainerObjs(m_pConn, co);
        }
        break;
    case OPENTABLE_REFPROPS:
        if (!bFirst)
            hr = GetNext_ReferenceProperties(m_pConn, pm);
        else
            hr = GetReferencePropertiesData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), m_tableid, pm);
        while (SUCCEEDED(hr))
        {
            hr = TestDriverStatus();
            if (FAILED(hr))
                break;

            if (pm.dClassId != dObjectId)
            {
                hr = GetFirst_ObjectMap(m_pConn, pm.dClassId, oj);
                if (oj.iObjectState != 2 && ObjectMatches(oj.dObjectId, oj.dClassId, oj.dObjectScopeId, NULL,
                        &pm, &dObjectId, &dClassId, &dScopeId))
                {
                    oj.Clear();
                    break;
                }                
                oj.Clear();
            }
            hr = GetNext_ReferenceProperties(m_pConn, pm);
        }
        break;
    default:
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


//***************************************************************************
//
//  CWmiESEIterator::SysMatch
//
//***************************************************************************

BOOL CWmiESEIterator::SysMatch (SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, ESEToken *pToken)
{
    BOOL bRet = FALSE;
    HRESULT hr = WBEM_S_NO_ERROR;
    ESEWQLToken *pTok = (ESEWQLToken *)pToken;

    _bstr_t sName;

    hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetPropertyInfo
                (pTok->dPropertyId, &sName);
    if (SUCCEEDED(hr))
    {
        if (!_wcsicmp(sName, L"__Class"))
        {
            SQL_ID dClass = 0;
            hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetClassID
                (pTok->Value.sValue, dScopeId, dClass);
            if (SUCCEEDED(hr))
            {
                // Compare if class or instance.
                if (dClassId == 1)
                    bRet = (dClass == dObjectId);
                else
                    bRet = (dClass == dClassId);
            }
        }
        else if (!_wcsicmp(sName, L"__SuperClass"))
        {
            CLASSMAP cd;
            SQL_ID dParent = 1, dClass = 1;            
            if (wcslen(pTok->Value.sValue))
            {                    
                hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetClassID
                    (pTok->Value.sValue, dScopeId, dClass);
                if (FAILED(hr))
                {
                    if (m_dwOpenTable != OPENTABLE_CLASSMAP)
                    {
                        hr = GetFirst_ClassMapByName(m_pConn, pTok->Value.sValue, cd);
                        dClass = cd.dClassId;
                        cd.Clear();
                    }
                    else
                        hr = WBEM_E_NOT_FOUND; // If this was going to match, it would be in the cache...
                }
            }
            if (dClassId == 1)
                hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetParentId(
                    dObjectId, dParent);
            else
                hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetParentId(
                    dClassId, dParent);
    
            if (FAILED(hr))
            {                
                if (dClassId == 1)
                {
                    if (m_dwOpenTable == OPENTABLE_CLASSMAP)
                        hr = GetClassMapData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), m_tableid, cd);
                    else
                        hr = GetFirst_ClassMap(m_pConn, dObjectId, cd);
                }
                else
                    hr = GetFirst_ClassMap(m_pConn, dClassId, cd);

                dParent = cd.dSuperClassId;
                cd.Clear();

            }
            bRet = (SUCCEEDED(hr) && (dParent == dClass));
        }
        else if (!_wcsicmp(sName, L"__Derivation"))
        {
            SQL_ID dClass = 0;
            hr =  ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetClassID
                (pTok->Value.sValue, dScopeId, dClass);
            if (SUCCEEDED(hr))
            {
                if (dClassId == 1)
                {
                    if (dObjectId == dClass)
                        bRet = TRUE;
                    else
                        bRet = (BOOL)((CWmiDbController *)m_pSession->m_pController)->
                            SchemaCache.IsDerivedClass(dClass, dObjectId);
                }
                else
                {
                    if (dClass == dClassId)
                        bRet = TRUE;
                    else
                        bRet = (BOOL)((CWmiDbController *)m_pSession->m_pController)->
                            SchemaCache.IsDerivedClass(dClass, dClassId);                          
                }
            }
        }
        else if (!_wcsicmp(sName, L"__Dynasty"))
        {
            SQL_ID dClass = 0;
            hr =  ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetClassID
                (pTok->Value.sValue, dScopeId, dClass);
            if (SUCCEEDED(hr))
            {
                if (dClassId == 1)
                    bRet = (BOOL)((CWmiDbController *)m_pSession->m_pController)->
                            SchemaCache.IsDerivedClass(dClass, dObjectId);
                else
                    bRet = (BOOL)((CWmiDbController *)m_pSession->m_pController)->
                            SchemaCache.IsDerivedClass(dClass, dClassId);      
                if (bRet)
                {
                    SQL_ID dParent = 0;
                    hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetParentId(
                            dClass, dParent);
                    if (SUCCEEDED(hr) && dParent == 1)
                        bRet = TRUE;
                }
            }
        }
        else if (!_wcsicmp(sName, L"__Genus"))
        {
            if (pTok->Value.dValue == 1)
                bRet = (dClassId == 1);
            else
                bRet = (dClassId != 1);
        }
        else if (!_wcsicmp(sName, L"__Server"))
        {
            bRet = (!_wcsicmp(pTok->Value.sValue, m_pSession->m_sMachineName));
        }
        else if (!_wcsicmp(sName, L"__Namespace"))
        {
            bRet = (!_wcsnicmp(pTok->Value.sValue, m_pSession->m_sNamespacePath, wcslen(m_pSession->m_sNamespacePath)));
            if (bRet)
            {
                _bstr_t sName;
                hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetNamespaceName(dScopeId, &sName);
                if (SUCCEEDED(hr))
                {
                    WCHAR *pTemp2 = (LPWSTR)pTok->Value.sValue;
                    pTemp2 += (wcslen(m_pSession->m_sNamespacePath)+1);

                    bRet = (!_wcsicmp(sName, pTemp2));
                }
            }
        }
        else if (!_wcsicmp(sName, L"__Property_Count"))
        {
            Properties props;
            DWORD dwNumProps = 0;
            if (dClassId == 1)
            {                
                hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetPropertyList(dObjectId, props, &dwNumProps);
                if (SUCCEEDED(hr))
                {
                    bRet = (dwNumProps == pTok->Value.dValue);
                }
            }
            else
            {
                hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetPropertyList(dClassId, props, &dwNumProps);
                if (SUCCEEDED(hr))
                {
                    bRet = (dwNumProps == pTok->Value.dValue);
                }
            }

        }
        else if (!_wcsicmp(sName, L"__Path"))
        {
            bRet = TRUE; // post-filter, since we don't know our true path.
        }
        else if (!_wcsicmp(sName, L"__RelPath"))
        {
            OBJECTMAP oj;
            hr = GetObjectMapData(m_pConn, ((CESEConnection *)m_pConn)->GetSessionID(), m_tableid, oj);
            if (SUCCEEDED(hr))
            {
                WCHAR *pPtr = (LPWSTR)oj.sObjectPath;
                WCHAR *pLast = NULL;
                while (pPtr && *pPtr)
                {
                    if (*pPtr == L':')
                        pLast = pPtr;

                    pPtr++;
                }
                if (pLast)
                    pLast++;
                else
                    pLast = (LPWSTR)pTok->Value.sValue;

                if (pLast)
                    bRet = (!_wcsicmp(pTok->Value.sValue, pLast));
                else
                    bRet = FALSE;

            }
            oj.Clear();
        }
        else 
        {
            bRet = FALSE; // Others not supported.
        }
    }

    // We only support equal and not equal for system properties.

    if (SUCCEEDED(hr) && pTok->optype == WQL_TOK_NE)
        bRet = !bRet;

    return bRet;
}

//***************************************************************************
//
//  Match helper functions
//
//***************************************************************************

BOOL MatchNumeric (SQL_ID dLeft, SQL_ID dRight, DWORD dwOp, SQL_ID dThird=0)
{
    BOOL bRet = FALSE;
    switch(dwOp)
    {
        case WQL_TOK_BETWEEN:
            bRet = (dLeft >= dRight);
            if (bRet)
                bRet = (dRight >= dThird);
            break;
        case WQL_TOK_EQ:
            bRet = (dLeft == dRight);
            break;
        case WQL_TOK_GT:
            bRet = (dLeft > dRight);
            break;
        case WQL_TOK_GE:
            bRet = (dLeft >= dRight);
            break;
        case WQL_TOK_LT:
            bRet = (dLeft < dRight);
            break;
        case WQL_TOK_LE:
            bRet = (dLeft <= dRight);
            break;
        case WQL_TOK_NE:
            bRet = (dLeft != dRight);
            break;
    }

    return bRet;
}

BOOL MatchString (LPWSTR lpLeft, LPWSTR lpRight, DWORD dwOp, LPWSTR lpThird=0)
{
    BOOL bRet = FALSE;

    if (!lpLeft || !lpRight)
        return FALSE;

    switch(dwOp)
    {
        case WQL_TOK_BETWEEN:
            bRet = (_wcsicmp(lpRight, lpLeft) >= 0) ? TRUE: FALSE;
            if (bRet)
                bRet = (_wcsicmp(lpRight, lpThird) >= 0)? TRUE: FALSE;
            break;
        case WQL_TOK_LIKE:
            {
                CLike c (lpRight);
                bRet = c.Match(lpLeft);
            }
            break;
        case WQL_TOK_NOT_LIKE:
            {
                CLike c (lpRight);
                bRet = !(c.Match(lpLeft));
            }
            break;
        case WQL_TOK_EQ:
            bRet = (!_wcsicmp(lpLeft, lpRight));               
            break;
        case WQL_TOK_GT:
            bRet = (_wcsicmp(lpLeft, lpRight) > 0 ? TRUE: FALSE);
            break;
        case WQL_TOK_GE:
            bRet = (_wcsicmp(lpLeft, lpRight) >= 0 ? TRUE: FALSE);
            break;
        case WQL_TOK_LT:
            bRet = (_wcsicmp(lpLeft, lpRight) < 0 ? TRUE: FALSE);
            break;
        case WQL_TOK_LE:
            bRet = (_wcsicmp(lpLeft, lpRight) <= 0 ? TRUE: FALSE);
            break;
        case WQL_TOK_NE:
            bRet = (_wcsicmp(lpLeft, lpRight));
            break;
    }

    return bRet;
}

BOOL MatchDouble (double dLeft, double dRight, DWORD dwOp, double dThird=0)
{
    BOOL bRet = FALSE;
    switch(dwOp)
    {
        case WQL_TOK_BETWEEN:
            bRet = (dRight >= dLeft);
            if (bRet)
                bRet = (dLeft >= dThird);
            break;
        case WQL_TOK_EQ:
            bRet = (dLeft == dRight);
            break;
        case WQL_TOK_GT:
            bRet = (dLeft > dRight);
            break;
        case WQL_TOK_GE:
            bRet = (dLeft >= dRight);
            break;
        case WQL_TOK_LT:
            bRet = (dLeft < dRight);
            break;
        case WQL_TOK_LE:
            bRet = (dLeft <= dRight);
            break;
        case WQL_TOK_NE:
            bRet = (dLeft != dRight);
            break;
    }
    return bRet;
}

SQL_ID GetDatePart(DWORD dwFunc, LPWSTR lpValue)
{
    int dValue = 0;
    HRESULT hr = 0;
    CDatePart dp;

    dp.SetDate(lpValue);

    switch(dwFunc)
    {
    case ESE_FUNCTION_DATEPART_MONTH:
        hr = dp.GetPart(DATEPART_MONTH, &dValue);                           
        break;
    case ESE_FUNCTION_DATEPART_YEAR:
        hr = dp.GetPart(DATEPART_YEAR, &dValue);
        break;
    case ESE_FUNCTION_DATEPART_DAY:
        hr = dp.GetPart(DATEPART_DAY, &dValue);
        break;
    case ESE_FUNCTION_DATEPART_HOUR:
        hr = dp.GetPart(DATEPART_HOUR, &dValue);
        break;
    case ESE_FUNCTION_DATEPART_MINUTE:
        hr = dp.GetPart(DATEPART_MINUTE, &dValue);
        break;
    case ESE_FUNCTION_DATEPART_SECOND:
        hr = dp.GetPart(DATEPART_SECOND, &dValue);
        break;
    case ESE_FUNCTION_DATEPART_MILLISECOND:
        hr = dp.GetPart(DATEPART_MILLISECOND, &dValue);
        break;
    default:
        break;
    }

    if (FAILED(hr))
        dValue = -1;
    
    return dValue;
}

//***************************************************************************
//
//  CWmiESEIterator::PropMatch
//
//***************************************************************************

BOOL CWmiESEIterator::PropMatch(CLASSDATA cd, CLASSDATA cd2, ESEWQLToken *pToken)
{
    BOOL bRet = FALSE;

    SQL_ID dValue = 0, dCompValue = 0;

    if (pToken->Value.dwFunc ||
        pToken->CompValue.dwFunc)
    {
        if (cd.sPropertyStringValue)
            dValue = GetDatePart(pToken->Value.dwFunc, cd.sPropertyStringValue);
        if (cd2.sPropertyStringValue)
            dCompValue = GetDatePart(pToken->CompValue.dwFunc, cd2.sPropertyStringValue);
    }

    switch(pToken->Value.valuetype)
    {
        case ESE_VALUE_TYPE_SQL_ID:
            if (!dValue)
                dValue = cd.dPropertyNumericValue;
            if (!dCompValue)
                dCompValue = cd2.dPropertyNumericValue;

            bRet = MatchNumeric(dValue, dCompValue, 
                pToken->optype, 0);

            break;
        case ESE_VALUE_TYPE_STRING:                   
            bRet = MatchString(cd.sPropertyStringValue, cd2.sPropertyStringValue,
                    pToken->optype, 0);

            break;
        case ESE_VALUE_TYPE_REAL:
            bRet = MatchDouble(cd.rPropertyRealValue, cd2.rPropertyRealValue,
                pToken->optype, 0);

            break;
        default:
            bRet = FALSE;
            break;
    }

    return bRet;
}

//***************************************************************************
//
//  CWmiESEIterator::Match
//
//***************************************************************************

BOOL CWmiESEIterator::Match (CLASSDATA cd, ESEToken *pTok)
{
    BOOL bRet = FALSE;

    ESEWQLToken *pToken = (ESEWQLToken *)pTok;

    if (pToken->tokentype == ESE_EXPR_TYPE_EXPR)
    {
        if (pToken->optype == WQL_TOK_ISNULL) 
        {
            if (cd.iFlags & ESE_FLAG_NULL)
                bRet = TRUE;
        }
        else if (pToken->optype == WQL_TOK_NOT_NULL)
        {
            if (!(cd.iFlags & ESE_FLAG_NULL))
                bRet = TRUE;
        }
        else
        {
            SQL_ID dValue = 0, dCompValue = 0;

            if (pToken->Value.dwFunc ||
                pToken->CompValue.dwFunc)
            {
                if (cd.sPropertyStringValue)
                {
                    dValue = GetDatePart(pToken->Value.dwFunc, cd.sPropertyStringValue);
                    dCompValue = GetDatePart(pToken->CompValue.dwFunc, cd.sPropertyStringValue);
                }
                else
                    return FALSE;
            }

            switch(pToken->Value.valuetype)
            {
                case ESE_VALUE_TYPE_SQL_ID:
                    if (!dValue)
                        dValue = cd.dPropertyNumericValue;

                    bRet = MatchNumeric(dValue, pToken->Value.dValue, 
                        pToken->optype, dCompValue);

                    break;
                case ESE_VALUE_TYPE_STRING:                   
                    bRet = MatchString(cd.sPropertyStringValue, pToken->Value.sValue,
                            pToken->optype, pToken->CompValue.sValue);

                    break;
                case ESE_VALUE_TYPE_REAL:
                    bRet = MatchDouble(cd.rPropertyRealValue, pToken->Value.rValue,
                        pToken->optype, pToken->CompValue.rValue);

                    break;
                case ESE_VALUE_TYPE_REF:

                switch(pToken->optype)
                {
                    case WQL_TOK_ISA:
                        
                        bRet = cd.dRefClassId == pToken->Value.dValue;
                        if (!bRet)
                        {
                            bRet = (((CWmiDbSession *)m_pSession)->GetSchemaCache()->IsDerivedClass
                                (pToken->Value.dValue, cd.dRefClassId));
                        }

                        break;
                }
                    break;
                case ESE_VALUE_TYPE_SYSPROP:
                    bRet = TRUE; // we already evaluated this.
                    break;
            }
        }
    }

    return bRet;
}

//***************************************************************************
//
//  CWmiESEIterator::ObjectMatches
//
//***************************************************************************

BOOL CWmiESEIterator::ObjectMatches (SQL_ID dObjectId, SQL_ID dClassId, 
                                     SQL_ID dScopeId, INDEXDATA *pData,
                                     REFERENCEPROPERTIES *pPData,SQL_ID *pObjectId, 
                                     SQL_ID *pClassId,SQL_ID *pScopeId)
{
    SQL_ID d1 = dObjectId, d2 = dClassId, d3 = dScopeId;
    BOOL bRet = FALSE;
    if (m_pToks->GetNumTokens())
    {
        TEMPQLTYPE tok = ESE_TEMPQL_TYPE_NONE;

        if (m_bWQL)
            bRet = ObjectMatchesWQL(d1, d2, d3);
        else
        {
            if (dClassId == 1)
                bRet = ObjectMatchesClass(d1, d2, d3, pPData);
            else
                bRet = ObjectMatchesRef(d1, d2, d3, pData);
        }
        if (bRet)
        {
            if (pObjectId)
                *pObjectId = d1;
            if (pClassId)
                *pClassId = d2;
            if (pScopeId)
                *pScopeId = d3;
        }

    }
    else
        bRet = TRUE;
    return bRet;
}

//***************************************************************************
//
//  CWmiESEIterator::ObjectMatchesClass
//
//***************************************************************************

BOOL CWmiESEIterator::ObjectMatchesClass (SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID &dScopeId, REFERENCEPROPERTIES*pm)
{
    BOOL bRet = FALSE;

    // The class with this ID contains a reference to our target class.
    // * Does the scope match?
    // * Do the other properties match?
    // * What is the actual endpoint (assoc or ref?)
    // => Dealing with a class, we need to look at PropertyMap, as well as
    //    ClassData for qualifiers!

    // NOTE: This is expected to be post-filtered anyway, so we will only
    //  perform rudimentary matching.

    int iNumTokens = m_pToks->GetNumTokens();
    TEMPQLTYPE qltype = m_pToks->GetToken(0)->qltype;
    OBJECTMAP oj;
    HRESULT hr = 0;
    SQL_ID dTargetId;
    _bstr_t sName;
    BOOL bAssoc = FALSE;
    
    for (int i = m_iStartPos; i < iNumTokens; i++)
    {
        ESEToken *pTok = m_pToks->GetToken(i);
        if (!(pTok->qltype == ESE_TEMPQL_TYPE_REF ||
              pTok->qltype == ESE_TEMPQL_TYPE_ASSOC))
        {
            continue;
        }

        if (pTok->qltype == ESE_TEMPQL_TYPE_ASSOC)
            bAssoc = TRUE;

        qltype = pTok->qltype;
        bRet = FALSE;
        if (pTok->tokentype == ESE_EXPR_TYPE_EXPR)
        {
            ESETempQLToken *pTok2 = (ESETempQLToken *)pTok;
            switch (pTok2->token)
            {
            case TEMPQL_TOKEN_TARGETID:
                dTargetId = pTok2->dValue;
                if (pm->dRefClassId == dTargetId)
                    bRet = TRUE;
                break;

            case TEMPQL_TOKEN_RESULTCLASS:
                if (qltype == ESE_TEMPQL_TYPE_REF)
                {
                    // Is this class ID derived from the one
                    // in question?

                    if (dObjectId == pTok2->dValue)
                        bRet = TRUE;
                    else if (((CWmiDbSession *)m_pSession)->GetSchemaCache()->IsDerivedClass
                        (pTok2->dValue, dObjectId))
                        bRet = TRUE;      
                }
                else
                {
                    // We can't move the pointer
                    // on PropertyMap, or we will mess up our cursor.

                    bRet = TRUE; // postfilter
                }

                break;
            case TEMPQL_TOKEN_ROLE:
                // Is the current property ID named the token in question?
                {
                    _bstr_t sVal;
                    ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetPropertyInfo(pm->iPropertyId, &sVal);
                    
                    if (!_wcsicmp(sVal, pTok2->sValue))
                        bRet = TRUE;
                }
                break;
            case TEMPQL_TOKEN_RESULTROLE:

                // We can't move the pointer
                // on PropertyMap, or we will mess up our cursor.

                bRet = TRUE; // postfilter

                break;
            case TEMPQL_TOKEN_ASSOCQUALIFIER:
            case TEMPQL_TOKEN_REQQUALIFIER:
                if (qltype == ESE_TEMPQL_TYPE_REF ||
                    pTok2->token == TEMPQL_TOKEN_ASSOCQUALIFIER)
                {
                    // Does this association instance have this qualifier?
                    CLASSDATA cd;
                    hr = GetFirst_ClassData(m_pConn, dObjectId, cd);
                    while (SUCCEEDED(hr))
                    {
                        if (pTok2->dValue == cd.iPropertyId)
                        {
                            bRet = TRUE;
                            cd.Clear();
                            break;
                        }
                        hr = GetNext_ClassData(m_pConn, cd);
                    }
                }
                else
                {
                    // We can't move the pointer
                    // on PropertyMap, or we will mess up our cursor.

                    bRet = TRUE; // postfilter
                }
                break;
            case TEMPQL_TOKEN_ASSOCCLASS:                
                // Is this association instance derived from this class?
                if (dObjectId == pTok2->dValue)
                    bRet = TRUE;
                else if (((CWmiDbSession *)m_pSession)->GetSchemaCache()->IsDerivedClass
                            (pTok2->dValue, dObjectId))
                    bRet = TRUE;      
                break;
            default:
                break;
            }
        }

        if (!bRet)
            break;
    }


    // FIXME: If the return object is an association, 
    // we need to retrieve the other object.
    


    return bRet;
}
      
//***************************************************************************
//
//  CWmiESEIterator::ObjectMatchesWQL
//
//***************************************************************************
 
BOOL CWmiESEIterator::ObjectMatchesWQL (SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId)
{
    BOOL bRet = FALSE;

    // Traverse the set of tokens to
    // see if this object matches.
    // Since we do *NOT* want to 
    // modify the position of the current
    // index, we will retrieve
    // the data from the ClassData table,
    // and see if it matches in toto.

    int i = 0;
    int iNumToks = m_pToks->GetNumTokens();

    int * results = new int [iNumToks];
    if (!results)
        return FALSE;

    CDeleteMe <int> d (results);

    for (i = m_iStartPos; i < iNumToks; i++)
    {
        ESEWQLToken *pTok = (ESEWQLToken *)m_pToks->GetToken(i);

        if (pTok->tokentype == ESE_EXPR_TYPE_EXPR &&
            pTok->optype != WQL_TOK_ISNULL &&
            pTok->Value.valuetype != ESE_VALUE_TYPE_SYSPROP)
            results[i] = 0;
        else 
            results[i] = -1;
    }

    int iNumSysToks = 0, iNumOther = 0;

    // Prematch on system criteria.

    BOOL bScopeMatch = FALSE, bClassMatch = FALSE;
    BOOL bScopeCrit = FALSE, bClassCrit = FALSE;
    
    for (i = m_iStartPos; i < iNumToks; i++)
    {
        ESEToken *pTok2 = m_pToks->GetToken(i);
        if (!pTok2->qltype && pTok2->tokentype == ESE_EXPR_TYPE_EXPR)
        {
            ESEWQLToken *pTok = (ESEWQLToken *)pTok2;
            if (pTok->Value.valuetype == ESE_VALUE_TYPE_SYSPROP)
            {
                // Make sure class and scope ID match
                // If there are multiple scopes and classes,
                // these are ORed together.

                if (!dScopeId && (dClassId == 1))
                    bScopeMatch = TRUE;

                if (pTok->dScopeId)
                {
                    bScopeCrit = TRUE;
                    if (dScopeId == pTok->dScopeId)
                        bScopeMatch = TRUE;
                }                        

                if (pTok->dClassId)
                {
                    bClassCrit = TRUE;
                    results[i] = TRUE;
                    if (dClassId == pTok->dClassId)
                        bClassMatch = TRUE;
                }
                iNumSysToks++;
            }
            else if (pTok->tokentype == ESE_EXPR_TYPE_EXPR)
                iNumOther++;
        }
    }

    if (!((bScopeMatch || !bScopeCrit) ))
        bRet = FALSE;
    else
    {
        if (iNumSysToks)
            bRet = TRUE;

        if (iNumOther)
        {
            BOOL bPropToProp = FALSE;
            CLASSDATA cd;
            HRESULT hr = 0;
            hr = GetFirst_ClassData(m_pConn, dObjectId, cd);
            while (SUCCEEDED(hr))
            {
                // See if this property matches any
                // line of criteria.

                for (i = m_iStartPos; i < iNumToks; i++)
                {
                    ESEToken *pTok2 = m_pToks->GetToken(i);
                    if (!pTok2->qltype && pTok2->tokentype == ESE_EXPR_TYPE_EXPR)
                    {
                        ESEWQLToken *pTok = (ESEWQLToken *)pTok2;
                        if (!pTok->bSysProp)
                        {                            
                            if (pTok->dPropertyId == cd.iPropertyId)
                            {
                                if (!pTok->dCompPropertyId)
                                {
                                    results[i] = Match(cd, pTok);
                                    cd.Clear();
                                }
                                else
                                    bPropToProp = TRUE;
                            }
                        }
                    }
                }

                hr = GetNext_ClassData(m_pConn, cd);
            }

            if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;

            if (SUCCEEDED(hr))
            {
                // Fishing around for specific property values 
                // is pretty expensive, so we do this last.
                // We could optimize this by caching each CLASSDATA
                // as we hit it the first time.

                if (bPropToProp)
                {
                    for (i = m_iStartPos; i < iNumToks; i++)
                    {
                        if (m_pToks->GetToken(i)->tokentype == ESE_EXPR_TYPE_EXPR)
                        {
                            ESEWQLToken *pTok = (ESEWQLToken *)m_pToks->GetToken(i);
                            if (pTok->dCompPropertyId)
                            {
                                CLASSDATA cd2;
                                hr = GetFirst_ClassData(m_pConn, dObjectId, cd, pTok->dPropertyId);
                                if (SUCCEEDED(hr))
                                {
                                    hr = GetFirst_ClassData(m_pConn, dObjectId, cd2, pTok->dCompPropertyId);
                                    if (SUCCEEDED(hr))
                                    {
                                        results[i] = PropMatch (cd, cd2, pTok);
                                        cd2.Clear();
                                    }
                                    else
                                        results[i] = FALSE;
                                    cd.Clear();
                                }
                                else
                                    results[i] = FALSE;
                            }
                        }
                    }
                    hr = WBEM_S_NO_ERROR;
                }
            }

            if (SUCCEEDED(hr))
            {
                // Check for System properties
                for (i = m_iStartPos; i < iNumToks; i++)
                {
                    if (m_pToks->GetToken(i)->tokentype == ESE_EXPR_TYPE_EXPR)
                    {
                        if (((ESEWQLToken *)m_pToks->GetToken(i))->bSysProp == TRUE)
                        {
                            results[i] = SysMatch(dObjectId, dClassId, dScopeId, m_pToks->GetToken(i));
                        }
                        // Post-filter ISA stuff.
                        if ((((ESEWQLToken *)m_pToks->GetToken(i))->optype) == WQL_TOK_ISA)
                            results[i] = TRUE;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Go through the array and make sure
                // we have the results we expected.

                for (i = m_iStartPos; i < iNumToks; i++)
                {
                    ESEToken *pTok = m_pToks->GetToken(i);
                    switch(pTok->tokentype)
                    {
                    case ESE_EXPR_TYPE_AND:
                        if (results[i-1] && results[i-2])
                            bRet = TRUE;
                        else
                            bRet = FALSE;
                        results[i] = bRet;
                        break;
                    case ESE_EXPR_TYPE_OR:
                        if (results[i-1] || results[i-2])
                            bRet = TRUE;
                        else
                            bRet = FALSE;
                        results[i] = bRet;
                        break;

                    case ESE_EXPR_TYPE_NOT:
                        if (bRet)
                            bRet = FALSE;
                        else
                            bRet = TRUE;
                        results[i] = bRet;
                        break;                        
                    case ESE_EXPR_TYPE_EXPR:
                        bRet = results[i];
                        break;
                    }
                }
            }
        }
        else 
        {
            if (bClassCrit && !bClassMatch)
                bRet = FALSE;
        }

    }

    return bRet;
}

//***************************************************************************
//
//  CWmiESEIterator::ObjectMatchesRef
//
//***************************************************************************
 
BOOL CWmiESEIterator::ObjectMatchesRef (SQL_ID &dObjectId, SQL_ID &dClassId, 
                                        SQL_ID &dScopeId, INDEXDATA *pData)
{
    BOOL bRet = TRUE;
    int iNumTokens = m_pToks->GetNumTokens();
    TEMPQLTYPE qltype = m_pToks->GetToken(0)->qltype;
    OBJECTMAP oj;
    HRESULT hr = 0;
    SQL_ID dTargetId;
    _bstr_t sName;
    BOOL bAssoc = FALSE;

    for (int i = m_iStartPos; i < iNumTokens; i++)
    {
        ESEToken *pTok = m_pToks->GetToken(i);
        if (!(pTok->qltype == ESE_TEMPQL_TYPE_REF ||
              pTok->qltype == ESE_TEMPQL_TYPE_ASSOC))
        {

            continue;
        }

        if (pTok->qltype == ESE_TEMPQL_TYPE_ASSOC)
            bAssoc = TRUE;

        qltype = pTok->qltype;
        bRet = FALSE;
        if (pTok->tokentype == ESE_EXPR_TYPE_EXPR)
        {
            ESETempQLToken *pTok2 = (ESETempQLToken *)pTok;
            switch (pTok2->token)
            {
            case TEMPQL_TOKEN_TARGETID:
                dTargetId = pTok2->dValue;
                if (pData)
                {
                    if (pData->dValue == pTok2->dValue)
                        bRet = TRUE;
                }
                break;

            case TEMPQL_TOKEN_RESULTCLASS:
                if (qltype == ESE_TEMPQL_TYPE_REF)
                {
                    // Is this class ID derived from the one
                    // in question?

                    if (dClassId == pTok2->dValue)
                        bRet = TRUE;
                    else if (((CWmiDbSession *)m_pSession)->GetSchemaCache()->IsDerivedClass
                        (pTok2->dValue, dClassId))
                        bRet = TRUE;      
                }
                else
                {
                    // Check the other endpoint of the association
                    // Get the other endpoint from CLASSDATA

                    CLASSDATA cd;
                    hr = GetFirst_ClassData(m_pConn, dObjectId, cd);
                    while (SUCCEEDED(hr))
                    {
                        if (cd.dRefId!= dTargetId)
                        {
                            hr = GetFirst_ObjectMap(m_pConn, cd.dRefId, oj);
                            if (SUCCEEDED(hr))
                            {
                                if (oj.dClassId == pTok2->dValue)
                                    bRet = TRUE;
                                else if (((CWmiDbSession *)m_pSession)->GetSchemaCache()->IsDerivedClass
                                    (pTok2->dValue, oj.dClassId))
                                    bRet = TRUE; 
                                cd.Clear();
                                oj.Clear();
                                break;
                            }
                            oj.Clear();
                        }
                        hr = GetNext_ClassData(m_pConn, cd);
                    }
                }

                break;
            case TEMPQL_TOKEN_ROLE:
                // Is the current property ID named the token in question?
                if (pData)
                {
                    hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetPropertyInfo
                                (pData->iPropertyId, &sName);
                    if (SUCCEEDED(hr))
                    {
                        if (!_wcsicmp(sName, pTok2->sValue))
                            bRet = TRUE;
                    }
                }
                break;
            case TEMPQL_TOKEN_RESULTROLE:
                // Is the property ID of the endpoint named the token in question?
                {
                    CLASSDATA cd;
                    hr = GetFirst_ClassData(m_pConn, dObjectId, cd);
                    while (SUCCEEDED(hr))
                    {
                        if (cd.dRefId != dTargetId)
                        {
                            hr = ((CWmiDbSession *)m_pSession)->GetSchemaCache()->GetPropertyInfo
                                        (cd.iPropertyId, &sName);
                            if (SUCCEEDED(hr))
                            {
                                if (!_wcsicmp(sName, pTok2->sValue))
                                    bRet = TRUE;
                                cd.Clear();
                                break;
                            }
                        }
                        hr = GetNext_ClassData(m_pConn, cd);
                    }
                }
                break;
            case TEMPQL_TOKEN_ASSOCQUALIFIER:
            case TEMPQL_TOKEN_REQQUALIFIER:
                if (qltype == ESE_TEMPQL_TYPE_REF ||
                    pTok2->token == TEMPQL_TOKEN_ASSOCQUALIFIER)
                {
                    // Does this association instance have this qualifier?
                    CLASSDATA cd;
                    hr = GetFirst_ClassData(m_pConn, dObjectId, cd);
                    while (SUCCEEDED(hr))
                    {
                        if (pTok2->dValue == cd.iPropertyId)
                        {
                            bRet = TRUE;
                            cd.Clear();
                            break;
                        }
                        hr = GetNext_ClassData(m_pConn, cd);
                    }
                    if (!bRet)
                    {
                        hr = GetFirst_ClassData(m_pConn, dClassId, cd);
                        while (SUCCEEDED(hr))
                        {
                            if (pTok2->dValue == cd.iPropertyId)
                            {
                                bRet = TRUE;
                                cd.Clear();
                                break;
                            }
                            hr = GetNext_ClassData(m_pConn, cd);
                        }
                    }
                }
                else
                {
                    // Does the endpoint contain this qualifier?
                    CLASSDATA cd;
                    hr = GetFirst_ClassData (m_pConn, dObjectId, cd);
                    while (SUCCEEDED(hr))
                    {       
                        if (cd.dRefId != dTargetId)
                        {
                            CLASSDATA cd2;
                            hr = GetFirst_ClassData(m_pConn, cd.dRefId, cd2);
                            while (SUCCEEDED(hr))
                            {
                                if (pTok2->dValue == cd2.iPropertyId)
                                {
                                    bRet = TRUE;
                                    cd2.Clear();
                                    break;
                                }
                                hr = GetNext_ClassData(m_pConn, cd2);
                            }
                            if (!bRet)
                            {
                                hr = GetFirst_ClassData(m_pConn, cd.dRefClassId, cd2);
                                while (SUCCEEDED(hr))
                                {
                                    if (pTok2->dValue == cd2.iPropertyId)
                                    {
                                        bRet = TRUE;
                                        cd2.Clear();
                                        break;
                                    }
                                    hr = GetNext_ClassData(m_pConn, cd2);
                                }
                            }
                            cd.Clear();
                            break;
                        }
                        hr = GetNext_ClassData(m_pConn, cd);
                    }
                }

                break;
            case TEMPQL_TOKEN_ASSOCCLASS:                
                // Is this association instance derived from this class?
                if (dClassId == pTok2->dValue)
                    bRet = TRUE;
                else if (((CWmiDbSession *)m_pSession)->GetSchemaCache()->IsDerivedClass
                            (pTok2->dValue, dClassId))
                    bRet = TRUE;      
                break;
            default:
                break;
            }
        }

        if (!bRet)
            break;
    }

    if (bRet && bAssoc)
    {
        CLASSDATA cd;
        hr = GetFirst_ClassData (m_pConn, dObjectId, cd);
        while (SUCCEEDED(hr))
        {
            if (cd.dRefId != dTargetId)
            {
                hr = GetFirst_ObjectMap(m_pConn, cd.dRefId, oj);
                if (SUCCEEDED(hr))
                {
                    dObjectId = oj.dObjectId;
                    dClassId = oj.dClassId;
                    dScopeId = oj.dObjectScopeId;
                    oj.Clear();
                    break;
                }
                oj.Clear();
            }
            hr = GetNext_ClassData(m_pConn, cd);
        }
        cd.Clear();

    }

    return bRet;
}

//***************************************************************************
//
//  CWmiESEIterator::TestDriverStatus
//
//***************************************************************************
 
HRESULT CWmiESEIterator::TestDriverStatus ()
{
   HRESULT hr = WBEM_S_NO_ERROR;

   if (!m_pSession || 
       !(m_pSession->m_pController) || 
       ((CWmiDbController *)m_pSession->m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
   {
        Cancel(0);
        hr = WBEM_E_SHUTTING_DOWN;
   }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\eseitrtr.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   eseitrtr.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _ESEIT_H_
#define _ESEIT_H_

#include <ese.h>
#include <wqltoese.h>
#include <eseutils.h>

#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

typedef enum
{
    OPENTABLE_OBJECTMAP    = 1,
    OPENTABLE_INDEXNUMERIC = 2,
    OPENTABLE_INDEXSTRING  = 3,
    OPENTABLE_INDEXREAL    = 4, 
    OPENTABLE_INDEXREF     = 5,
    OPENTABLE_CONTAINEROBJS= 6,
    OPENTABLE_REFPROPS     = 7,
    OPENTABLE_CLASSMAP     = 8
} OPENTABLETYPE;

//***************************************************************************
//  CWmiDbIterator
//***************************************************************************

class CWmiESEIterator : public IWmiDbIterator
{
    friend class CWmiDbSession;
public:
    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );

    virtual HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ DWORD dwFlags) ;
    
    virtual HRESULT STDMETHODCALLTYPE NextBatch( 
        /* [in] */ DWORD dwNumRequested,
        /* [in] */ DWORD dwTimeOutSeconds,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [in] */ REFIID riid,
        /* [out] */ DWORD __RPC_FAR *pdwNumReturned,
        /* [length_is][size_is][out] */ LPVOID __RPC_FAR *ppObjects) ;

    CWmiESEIterator();
    ~CWmiESEIterator();

protected:
    BOOL PropMatch(CLASSDATA cd1, CLASSDATA cd2, ESEWQLToken *pTok);
    BOOL Match (CLASSDATA cd, ESEToken *pTok);
    BOOL SysMatch(SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, ESEToken *pTok);
    HRESULT GetFirstMatch(SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID &dScopeId, LPWSTR *lpKey);
    HRESULT GetNextMatch(SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID &dScopeId, LPWSTR * lpKey, BOOL bFirst = FALSE);
    BOOL ObjectMatches (SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, INDEXDATA *pData = NULL,
        REFERENCEPROPERTIES*pm=NULL, SQL_ID *pObjectId=NULL, SQL_ID *pClassId=NULL,SQL_ID *pScopeId=NULL);
    BOOL ObjectMatchesWQL (SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId);
    BOOL ObjectMatchesClass (SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID &dScopeId, REFERENCEPROPERTIES *pm);
    BOOL ObjectMatchesRef (SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID &dScopeId, INDEXDATA *pData);
    HRESULT TestDriverStatus ();

    ULONG m_uRefCount;
    CWmiDbSession *m_pSession; // Pointer to our session
    CSQLConnection *m_pConn; // SQL connection to our rowset
    CESETokens *m_pToks;
    DWORD m_dwOpenTable;     // What did we prefilter on??
    JET_TABLEID m_tableid;   // the Index table in question
    int m_iLastPos;          // position of property to seek on
    int m_iStartPos;         // the first token of non-system criteria.
    BOOL m_bFirst;           // Have we started iterating yet?
    BOOL m_bWQL;             
    BOOL m_bEnum;            // We opened the whole table, so only scan once!
    BOOL m_bClasses;         // Classes only
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\rc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\QUASAR\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\rc\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\eseobjs.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   ESEOBJS.CPP
//
//   cvadai     02-2000      Created.
//
//***************************************************************************

#include "precomp.h"
#include <eseobjs.h>
#include <reposit.h>


CESEConnection::~CESEConnection()
{
    if (m_pTrans)
        m_pTrans->Abort();
    delete m_pTrans;

    DEBUGTRACE ((LOG_WBEMCORE, "Thread %ld closing connection %X, session %X, and dbid %ld\n", GetCurrentThreadId(), 
            this, &m_session, m_dbid));

    delete [] m_ppClassMapIDs;
    delete [] m_ppClassDataIDs;
    delete [] m_ppPropertyMapIDs;
    delete [] m_ppClassImagesIDs;
    delete [] m_ppObjectMapIDs;
    delete [] m_ppIndexStringIDs;
    delete [] m_ppIndexNumericIDs;
    delete [] m_ppIndexRealIDs;
    delete [] m_ppIndexRefIDs;
    delete [] m_ppContainerObjs;
    delete [] m_ppAutoDelete;
    delete [] m_ppClassKeys;
    delete [] m_ppRefProps;
    delete [] m_ppScopeMapIDs;

    JET_ERR err = JetCloseDatabase (m_session, m_dbid, 0);
    err = JetEndSession(m_session, 0);        
}


//***************************************************************************
//
//  CESEConnection::GetTableID
//
//***************************************************************************

JET_TABLEID CESEConnection::GetTableID(LPWSTR lpTableName)
{
    JET_TABLEID tableid = 0;

    if (!wcscmp(L"ClassMap", lpTableName))
        tableid = m_tClassMap;
    else if (!wcscmp(L"PropertyMap", lpTableName))
        tableid =  m_tPropertyMap;
    else if (!wcscmp(L"ObjectMap", lpTableName))
        tableid =  m_tObjectMap;
    else if (!wcscmp(L"ClassData", lpTableName))
        tableid =  m_tClassData;
    else if (!wcscmp(L"IndexStringData", lpTableName))
        tableid =  m_tIndexStringData;
    else if (!wcscmp(L"IndexNumericData", lpTableName))
        tableid =  m_tIndexNumericData;
    else if (!wcscmp(L"IndexRealData", lpTableName))
        tableid =  m_tIndexRealData;
    else if (!wcscmp(L"IndexRefData", lpTableName))
        tableid =  m_tIndexRefData;
    else if (!wcscmp(L"ClassImages", lpTableName))
        tableid =  m_tClassImages;
    else if (!wcscmp(L"ContainerObjs", lpTableName))
        tableid = m_tContainerObjs;
    else if (!wcscmp(L"AutoDelete", lpTableName))
        tableid = m_tAutoDelete;
    else if (!wcscmp(L"ReferenceProperties", lpTableName))
        tableid = m_tRefProps;
    else if (!wcscmp(L"ClassKeys", lpTableName))
        tableid = m_tClassKeys;
    else if (!wcscmp(L"ScopeMap", lpTableName))
        tableid = m_tScopeMap;

    if (tableid == 0xee)
        tableid = 0;

    return tableid;
}

//***************************************************************************
//
//  CESEConnection::SetTableID
//
//***************************************************************************

void CESEConnection::SetTableID (LPWSTR lpTableName, JET_TABLEID id)
{
    if (!wcscmp(L"ClassMap", lpTableName))
        m_tClassMap = id;
    else if (!wcscmp(L"PropertyMap", lpTableName))
        m_tPropertyMap =  id;
    else if (!wcscmp(L"ObjectMap", lpTableName))
        m_tObjectMap =  id;
    else if (!wcscmp(L"ClassData", lpTableName))
        m_tClassData =  id;
    else if (!wcscmp(L"IndexStringData", lpTableName))
        m_tIndexStringData =  id;
    else if (!wcscmp(L"IndexNumericData", lpTableName))
        m_tIndexNumericData =  id;
    else if (!wcscmp(L"IndexRealData", lpTableName))
        m_tIndexRealData =  id;
    else if (!wcscmp(L"IndexRefData", lpTableName))
        m_tIndexRefData =  id;
    else if (!wcscmp(L"ClassImages", lpTableName))
        m_tClassImages =  id;
    else if (!wcscmp(L"ContainerObjs", lpTableName))
        m_tContainerObjs = id;
    else if (!wcscmp(L"AutoDelete", lpTableName))
        m_tAutoDelete = id;
    else if (!wcscmp(L"ReferenceProperties", lpTableName))
        m_tRefProps = id;
    else if (!wcscmp(L"ClassKeys", lpTableName))
        m_tClassKeys = id;
    else if (!wcscmp(L"ScopeMap", lpTableName))
        m_tScopeMap = id;

}

//***************************************************************************
//
//  CESEConnection::GetColumnID
//
//***************************************************************************

JET_COLUMNID CESEConnection::GetColumnID (JET_TABLEID tableid, DWORD dwColPos)
{
    JET_COLUMNID colid = 0;

    if (tableid == m_tClassMap)
    {
        if (m_ppClassMapIDs)
            colid = m_ppClassMapIDs[dwColPos-1];
    }
    else if (tableid == m_tPropertyMap)
    {
        if (m_ppPropertyMapIDs)
            colid = m_ppPropertyMapIDs[dwColPos-1];
    }
    else if (tableid == m_tObjectMap)
    {
        if (m_ppObjectMapIDs)
            colid = m_ppObjectMapIDs[dwColPos-1];
    }
    else if (tableid == m_tClassData)
    {
        if (m_ppClassDataIDs)
            colid = m_ppClassDataIDs[dwColPos-1];
    }
    else if (tableid == m_tIndexStringData)
    {
        if (m_ppIndexStringIDs)
            colid = m_ppIndexStringIDs[dwColPos-1];
    }
    else if (tableid == m_tIndexNumericData)
    {
        if (m_ppIndexNumericIDs)
            colid = m_ppIndexNumericIDs[dwColPos-1];
    }
    else if (tableid == m_tIndexRealData)
    {
        if (m_ppIndexRealIDs)
            colid = m_ppIndexRealIDs[dwColPos-1];
    }
    else if (tableid == m_tIndexRefData)
    {
        if (m_ppIndexRefIDs)
            colid = m_ppIndexRefIDs[dwColPos-1];
    }
    else if (tableid == m_tClassImages)
    {
        if (m_ppClassImagesIDs)
            colid = m_ppClassImagesIDs[dwColPos-1];
    }
    else if (tableid == m_tContainerObjs)
    {
        if (m_ppContainerObjs)
            colid = m_ppContainerObjs[dwColPos-1];

    }
    else if (tableid == m_tAutoDelete)
    {
        if (m_ppAutoDelete)
            colid = m_ppAutoDelete[dwColPos-1];
    }
    else if (tableid == m_tRefProps)
    {
        if (m_ppRefProps)
            colid = m_ppRefProps[dwColPos-1];
    }
    else if (tableid == m_tClassKeys)
    {
        if (m_ppClassKeys)
            colid = m_ppClassKeys[dwColPos-1];
    }
    else if (tableid == m_tScopeMap)
    {
        if (m_ppScopeMapIDs)
            colid = m_ppScopeMapIDs[dwColPos-1];
    }

    return colid;
}

//***************************************************************************
//
//  CESEConnection::SetColumnID
//
//***************************************************************************

void CESEConnection::SetColumnID (JET_TABLEID tableid, DWORD dwColPos, JET_COLUMNID colid)
{
    if (tableid == m_tClassMap)
    {
        if (!m_ppClassMapIDs)
            m_ppClassMapIDs = new JET_COLUMNID[NUM_CLASSMAPCOLS];
        if (m_ppClassMapIDs)
            m_ppClassMapIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tPropertyMap)
    {
        if (!m_ppPropertyMapIDs)
            m_ppPropertyMapIDs = new JET_COLUMNID[NUM_PROPERTYMAPCOLS];
        if (m_ppPropertyMapIDs)
            m_ppPropertyMapIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tObjectMap)
    {
        if (!m_ppObjectMapIDs)
            m_ppObjectMapIDs = new JET_COLUMNID[NUM_OBJECTMAPCOLS];
        if (m_ppObjectMapIDs)
            m_ppObjectMapIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tClassData)
    {
        if (!m_ppClassDataIDs)
            m_ppClassDataIDs = new JET_COLUMNID[NUM_CLASSDATACOLS];
        if (m_ppClassDataIDs)
            m_ppClassDataIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tIndexStringData)
    {
        if (!m_ppIndexStringIDs)
            m_ppIndexStringIDs = new JET_COLUMNID[NUM_INDEXCOLS];
        if (m_ppIndexStringIDs)
            m_ppIndexStringIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tIndexNumericData)
    {
        if (!m_ppIndexNumericIDs)
            m_ppIndexNumericIDs = new JET_COLUMNID[NUM_INDEXCOLS];
        if (m_ppIndexNumericIDs)
            m_ppIndexNumericIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tIndexRealData)
    {
        if (!m_ppIndexRealIDs)
            m_ppIndexRealIDs = new JET_COLUMNID[NUM_INDEXCOLS];
        if (m_ppIndexRealIDs)
            m_ppIndexRealIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tIndexRefData)
    {
        if (!m_ppIndexRefIDs)
            m_ppIndexRefIDs = new JET_COLUMNID[NUM_INDEXCOLS];
        if (m_ppIndexRefIDs)
            m_ppIndexRefIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tClassImages)
    {
        if (!m_ppClassImagesIDs)
            m_ppClassImagesIDs = new JET_COLUMNID[NUM_CLASSIMAGESCOLS];
        if (m_ppClassImagesIDs)
            m_ppClassImagesIDs[dwColPos-1] = colid;
    }
    else if (tableid == m_tContainerObjs)
    {
        if (!m_ppContainerObjs)
            m_ppContainerObjs = new JET_COLUMNID[NUM_CONTAINERCOLS];
        if (m_ppContainerObjs)
            m_ppContainerObjs[dwColPos-1] = colid;
    }
    else if (tableid == m_tAutoDelete)
    {
        if (!m_ppAutoDelete)
            m_ppAutoDelete = new JET_COLUMNID[NUM_AUTODELETECOLS];
        if (m_ppAutoDelete)
            m_ppAutoDelete[dwColPos-1] = colid;
    }
    else if (tableid == m_tClassKeys)
    {
        if (!m_ppClassKeys)
            m_ppClassKeys = new JET_COLUMNID[NUM_CLASSKEYCOLS];
        if (m_ppClassKeys)
            m_ppClassKeys[dwColPos-1] = colid;
    }
    else if (tableid == m_tRefProps)
    {
        if (!m_ppRefProps)
            m_ppRefProps = new JET_COLUMNID[NUM_REFPROPCOLS];
        if (m_ppRefProps)
            m_ppRefProps[dwColPos-1] = colid;
    }
    else if (tableid == m_tScopeMap)
    {
        if (!m_ppScopeMapIDs)
            m_ppScopeMapIDs = new JET_COLUMNID[NUM_SCOPEMAPCOLS];
        if (m_ppScopeMapIDs)
            m_ppScopeMapIDs[dwColPos-1] = colid;
    }
}

//***************************************************************************
//
//  CWmiESETransaction::QueryInterface
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiESETransaction::QueryInterface
        (REFIID riid,
        void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_ITransaction==riid )
    {
        *ppvObject = (ITransaction *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//***************************************************************************
//
//  CWmiESETransaction::AddRef
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiESETransaction::AddRef( )
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}


//***************************************************************************
//
//  CWmiESETransaction::Release
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiESETransaction::Release( )
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return WBEM_S_NO_ERROR;

}

//***************************************************************************
//
//  CWmiESETransaction::StartTransaction
//
//***************************************************************************

HRESULT CWmiESETransaction::StartTransaction()
{
    HRESULT hr = 0;
    JET_ERR err;

    if (m_session)
    {
        m_ThreadID = GetCurrentThreadId();
        err = JetBeginTransaction(m_session);
        if (err != JET_errSuccess)
            hr = WBEM_E_FAILED;
    }
    else
        hr = WBEM_E_INVALID_OPERATION;

    return hr;
}

//***************************************************************************
//
//  CWmiESETransaction::Abort
//
//***************************************************************************

HRESULT CWmiESETransaction::Abort()
{  
    HRESULT hr = 0;
    JET_ERR err;

    if (GetCurrentThreadId() == m_ThreadID)
    {
        if (m_session)
        {
            err = JetRollback(m_session, 0);
            if (err != JET_errSuccess)
                hr = WBEM_E_FAILED;
        }
        else
            hr = WBEM_E_INVALID_OPERATION;
    }
    else
        hr = WBEM_E_INVALID_OPERATION;

    return hr;

}

//***************************************************************************
//
//  CWmiESETransaction::Commit
//
//***************************************************************************

HRESULT CWmiESETransaction::Commit ()
{
    HRESULT hr = 0;
    JET_ERR err;

    if (GetCurrentThreadId() == m_ThreadID)
    {
        if (m_session)
        {
            err = JetCommitTransaction(m_session, 0);
            if (err != JET_errSuccess)
                hr = WBEM_E_FAILED;
        }
        else
            hr = WBEM_E_INVALID_OPERATION;
    }
    else
        hr = WBEM_E_INVALID_OPERATION;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\eseobjs.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   ESEOBJS.H
//
//   cvadai     02-2000      Created.
//
//***************************************************************************

#ifndef _ESEOBJS_H_
#define _ESEOBJS_H_

// This file overloads OLE DB calls, so we can share the codebase with 
//  the SQL repository driver.

#include <ese.h>
#include <sqlcache.h>

#define NUM_OBJECTMAPCOLS      8
#define NUM_CLASSMAPCOLS       5
#define NUM_PROPERTYMAPCOLS    7
#define NUM_CLASSDATACOLS      11
#define NUM_CLASSIMAGESCOLS    4
#define NUM_INDEXCOLS          6 
#define NUM_CONTAINERCOLS      2
#define NUM_AUTODELETECOLS     1
#define NUM_CLASSKEYCOLS       2
#define NUM_REFPROPCOLS        3
#define NUM_SCOPEMAPCOLS       3

class CWmiESETransaction
{
public:
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );
    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    HRESULT Abort();
    HRESULT Commit();
    HRESULT StartTransaction();

    CWmiESETransaction(JET_SESID session) {m_uRefCount = 1; m_session = session;};
    ~CWmiESETransaction() {};

private:
    ULONG m_uRefCount;
    JET_SESID m_session;
    DWORD m_ThreadID;
};

class _declspec( dllexport ) CESEConnection : public CSQLConnection
{
public:
    friend class CSQLConnCache;

    CESEConnection(JET_SESID session) 
    {m_uRefCount = 1, m_session = session,
      m_tClassMap = NULL, m_tPropertyMap = NULL,
      m_tObjectMap = NULL, m_tClassData = NULL,
      m_tIndexStringData = NULL, m_tIndexNumericData = NULL,
      m_tIndexRealData = NULL, m_tIndexRefData = NULL,
      m_tClassImages = NULL, m_ppClassMapIDs = NULL,
      m_ppClassDataIDs = NULL, m_ppPropertyMapIDs = NULL,
      m_ppClassImagesIDs = NULL, m_ppObjectMapIDs = NULL,
      m_ppIndexStringIDs = NULL, m_ppIndexNumericIDs = NULL,
      m_ppIndexRealIDs = NULL, m_ppIndexRefIDs = NULL, m_pTrans = NULL,
      m_ppContainerObjs = NULL, m_tContainerObjs = NULL,
      m_ppAutoDelete = NULL, m_tAutoDelete = NULL,
      m_tClassKeys = NULL, m_tRefProps = NULL,
      m_ppClassKeys = NULL, m_ppRefProps = NULL,
      m_ppScopeMapIDs = NULL, m_tScopeMap = NULL;
    };
    ~CESEConnection();
    JET_SESID GetSessionID () {return m_session;};
    BOOL SetSessionID(JET_SESID session) {m_session = session; return TRUE;};
    JET_DBID GetDBID() {return m_dbid;};
    void SetDBID(JET_DBID dbid) {m_dbid = dbid;};
    JET_TABLEID GetTableID(LPWSTR lpTableName);
    void SetTableID (LPWSTR lpTableName, JET_TABLEID id);
    JET_COLUMNID GetColumnID (JET_TABLEID tableid, DWORD dwColPos);
    void SetColumnID (JET_TABLEID tableid, DWORD dwColPos, JET_COLUMNID colid);
    CWmiESETransaction * GetTransaction () {return m_pTrans;};
    void SetTransaction (CWmiESETransaction *pTrans) {if (m_pTrans) delete m_pTrans; m_pTrans = pTrans;};

private:
    ULONG m_uRefCount;
    JET_SESID m_session;
    JET_DBID m_dbid;
    CWmiESETransaction *m_pTrans;
    JET_TABLEID m_tClassMap;
    JET_TABLEID m_tPropertyMap;
    JET_TABLEID m_tObjectMap;
    JET_TABLEID m_tClassData;
    JET_TABLEID m_tIndexStringData;
    JET_TABLEID m_tIndexNumericData;
    JET_TABLEID m_tIndexRealData;
    JET_TABLEID m_tIndexRefData;
    JET_TABLEID m_tClassImages;
    JET_TABLEID m_tContainerObjs;
    JET_TABLEID m_tAutoDelete;
    JET_TABLEID m_tClassKeys;
    JET_TABLEID m_tRefProps;
    JET_TABLEID m_tScopeMap;
    JET_COLUMNID *m_ppClassMapIDs;
    JET_COLUMNID *m_ppClassDataIDs;
    JET_COLUMNID *m_ppPropertyMapIDs;
    JET_COLUMNID *m_ppClassImagesIDs;
    JET_COLUMNID *m_ppObjectMapIDs;
    JET_COLUMNID *m_ppIndexStringIDs;
    JET_COLUMNID *m_ppIndexNumericIDs;
    JET_COLUMNID *m_ppIndexRealIDs;
    JET_COLUMNID *m_ppIndexRefIDs;
    JET_COLUMNID *m_ppContainerObjs;
    JET_COLUMNID *m_ppAutoDelete;
    JET_COLUMNID *m_ppClassKeys;
    JET_COLUMNID *m_ppRefProps;
    JET_COLUMNID *m_ppScopeMapIDs;
    time_t         m_tCreateTime;
    bool           m_bInUse;

};



#endif // _ESEOBJS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\rc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by repdrvr.rc
//
#define IDS_WMI_SERVER                  1
#define IDS_WMI_DATABASE                2
#define IDS_WMI_USER_NAME               3
#define IDS_WMI_PASSWORD                4
#define IDS_WMI_LOCALE                  5
#define IDS_WMI_READMODE                6

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\eseutils.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   ESEUTILS.h
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#ifndef _ESEUTILS_H_
#define _ESEUTILS_H_

#include <ese.h>

#define ESE_FLAG_NULL                   0x10000000

void FreeBstr(BSTR * ppStr);

typedef struct tagOBJECTKEY
{
    BSTR sObjectKey;
    tagOBJECTKEY() {sObjectKey = NULL;};
//    ~tagOBJECTKEY() {Clear();};
    void Clear() {FreeBstr(&sObjectKey);};
} OBJECTKEY;

typedef struct tagWMIOBJECTID
{
    __int64 dObjectId;
} WMIOBJECTID;

typedef struct tagWMIPROPERTYID
{
    DWORD dwPropertyId;
} WMIPROPERTYID;

typedef struct tagOBJECTMAP
{
    __int64  dObjectId;
    __int64  dClassId;
    BSTR     sObjectPath;
    DWORD    iObjectState;
    DWORD    iRefCount;
    DWORD    iObjectFlags;
    __int64  dObjectScopeId;
    BSTR     sObjectKey;
    tagOBJECTMAP() {sObjectKey = NULL; sObjectPath = NULL;};
//    ~tagOBJECTMAP() { Clear();};
    void Clear() {FreeBstr(&sObjectKey); FreeBstr(&sObjectPath);};
} OBJECTMAP;

typedef struct tagSCOPEMAP
{
    SQL_ID dObjectId;
    BSTR   sScopePath;
    SQL_ID dParentId;
    tagSCOPEMAP() {sScopePath = NULL; dParentId = 0;};
    void Clear() { FreeBstr(&sScopePath); dParentId = 0;};
} SCOPEMAP;


typedef struct tagCLASSMAP
{
    __int64  dClassId;
    BSTR     sClassName;
    __int64  dSuperClassId;
    __int64  dDynastyId;
    BYTE    *pClassBuffer;
    DWORD    dwBufferLen;
    tagCLASSMAP() {sClassName = NULL, pClassBuffer = NULL, dwBufferLen = 0;};
//    ~tagCLASSMAP() {Clear();};
    void Clear() { FreeBstr(&sClassName); dwBufferLen = 0; delete pClassBuffer; pClassBuffer = NULL;};
} CLASSMAP;

typedef struct tagPROPERTYMAP
{
    DWORD    iPropertyId;
    __int64  dClassId;
    DWORD     iStorageTypeId;
    DWORD     iCIMTypeId;
    BSTR    sPropertyName;
    DWORD     iFlags;
    tagPROPERTYMAP() {sPropertyName = NULL;};
//    ~tagPROPERTYMAP() {Clear();};
    void Clear() {FreeBstr(&sPropertyName);};

} PROPERTYMAP;

typedef struct tagCLASSKEYS
{
    __int64 dClassId;
    DWORD   iPropertyId;

} CLASSKEYS;

typedef struct tagREFERENCEPROPERTIES
{
    __int64 dClassId;
    DWORD   iPropertyId;
    __int64 dRefClassId;

} REFERENCEPROPERTIES;

typedef struct tagCLASSIMAGES
{
    __int64   dObjectId;
    int       iPropertyId;
    DWORD     iArrayPos;
    BYTE     *pBuffer;
    long      dwBufferLen;

    tagCLASSIMAGES() {pBuffer = NULL; dwBufferLen = 0;};
//    ~tagCLASSIMAGES() { Clear();};
    void Clear() { delete pBuffer; pBuffer = NULL; dwBufferLen = 0;};
} CLASSIMAGES;


typedef struct tagCLASSDATA
{
    __int64   dObjectId;
    DWORD     iPropertyId;
    DWORD     iArrayPos;
    DWORD     iQfrPos;
    __int64   dClassId;
    BSTR      sPropertyStringValue;
    __int64   dPropertyNumericValue;
    double    rPropertyRealValue;
    DWORD     iFlags;
    __int64   dRefId;
    __int64   dRefClassId;
    BYTE    * pBuffer;
    DWORD     dwBufferLen;
    tagCLASSDATA() { sPropertyStringValue = NULL; pBuffer = NULL; dwBufferLen = 0;};
//    ~tagCLASSDATA() {Clear();};
    void Clear() {FreeBstr(&sPropertyStringValue); delete pBuffer; pBuffer = NULL; dwBufferLen = 0;};
    void operator= (tagCLASSDATA&cd)
    {
        Clear();
        dObjectId = cd.dObjectId;
        iPropertyId = cd.iPropertyId;
        iArrayPos = cd.iArrayPos;
        iQfrPos = cd.iQfrPos;
        dClassId = cd.dClassId;
        if (cd.sPropertyStringValue)
            sPropertyStringValue = SysAllocString(cd.sPropertyStringValue);
        dPropertyNumericValue = cd.dPropertyNumericValue;
        rPropertyRealValue = cd.rPropertyRealValue;
        iFlags = cd.iFlags;
        dRefId = cd.dRefId;
        dRefClassId = cd.dRefClassId;
        if (cd.dwBufferLen)
        {
            pBuffer = new BYTE[cd.dwBufferLen+2];
            if (pBuffer)
            {
                memcpy(pBuffer, cd.pBuffer, cd.dwBufferLen);
                pBuffer[cd.dwBufferLen] = L'\0';
                pBuffer[cd.dwBufferLen+1] = L'\0';
                dwBufferLen = cd.dwBufferLen;
            }
        }
    }
    void Copy (tagCLASSIMAGES &cd)
    {
        Clear();
        dObjectId = cd.dObjectId;
        iPropertyId = cd.iPropertyId;
        iArrayPos = cd.iArrayPos;
        iFlags = 0;
        if (cd.dwBufferLen)
        {
            pBuffer = new BYTE[cd.dwBufferLen+2];
            if (pBuffer)
            {
                memcpy(pBuffer, cd.pBuffer, cd.dwBufferLen);
                pBuffer[cd.dwBufferLen] = L'\0';
                pBuffer[cd.dwBufferLen+1] = L'\0';
                dwBufferLen = cd.dwBufferLen;
            }
        }

    }
} CLASSDATA;

typedef struct tagINDEXDATA
{
    BSTR       sValue;
    __int64 dValue;
    double     rValue;
    __int64 dObjectId;
    DWORD      iPropertyId;
    DWORD        iArrayPos;
    tagINDEXDATA() {sValue = NULL;}
//    ~tagINDEXDATA() { Clear();};
    void Clear() { FreeBstr(&sValue);};
} INDEXDATA;

typedef struct tagCONTAINEROBJ
{
    SQL_ID dContainerId;
    SQL_ID dContaineeId;
    void Clear() {};

} CONTAINEROBJ;

typedef struct tagAUTODELETE
{
    SQL_ID dObjectId;

} AUTODELETE;


HRESULT UpdateDBVersion (CSQLConnection *_pConn, DWORD iVersion);

HRESULT SetupObjectMapAccessor (CSQLConnection *pConn);
HRESULT SetupClassMapAccessor (CSQLConnection *pConn);
HRESULT SetupPropertyMapAccessor (CSQLConnection *pConn);
HRESULT SetupClassKeysAccessor (CSQLConnection *_pConn);
HRESULT SetupClassDataAccessor (CSQLConnection *pConn);
HRESULT SetupIndexDataAccessor (CSQLConnection *pConn, DWORD dwStorage, DWORD &dwPos, LPWSTR * lpTableName = NULL);
HRESULT InsertObjectMap(CSQLConnection *pConn, SQL_ID dObjectId, LPCWSTR lpKey, 
                        DWORD iState, LPCWSTR lpObjectPath, SQL_ID dScopeID, DWORD iClassFlags,
                        DWORD iRefCount, SQL_ID dClassId, BOOL bInsert = TRUE);
HRESULT InsertClassMap(CSQLConnection *pConn, SQL_ID dClassId, LPCWSTR lpClassName, SQL_ID dSuperClassId, SQL_ID dDynasty,
                       BYTE *pBuff, DWORD dwBufferLen, BOOL bInsert = TRUE);
HRESULT InsertPropertyMap (CSQLConnection *pConn, DWORD &iPropID, SQL_ID dClassId, DWORD iStorageTypeId, 
                           DWORD iCIMTypeId, LPCWSTR lpPropName, DWORD iFlags, BOOL bInsert = TRUE);
HRESULT InsertClassKeys (CSQLConnection *_pConn, SQL_ID dClassId, DWORD dwPropertyId,
                         BOOL bInsert = TRUE);
HRESULT InsertClassData_Internal (CSQLConnection *pConn, SQL_ID dObjectId, DWORD iPropID, DWORD iArrayPos, DWORD iQfrPos,
                         SQL_ID dClassId, LPCWSTR lpStringValue, SQL_ID dNumericValue, double fRealValue,
                         DWORD iFlags, SQL_ID dRefId, SQL_ID dRefClassId, BOOL bIsNull=FALSE);
HRESULT InsertIndexData (CSQLConnection *pConn, SQL_ID dObjectId, DWORD iPropID, DWORD iArrayPos, 
                           LPWSTR lpValue, SQL_ID dValue, double rValue, DWORD dwStorage);
HRESULT GetObjectMapData (CSQLConnection *pConn,JET_SESID session, JET_TABLEID tableid,
                OBJECTMAP &oj);
HRESULT GetFirst_ObjectMap (CSQLConnection *_pConn, SQL_ID dObjectId, OBJECTMAP &oj);
HRESULT GetFirst_ObjectMapByClass (CSQLConnection *_pConn, SQL_ID dClassId, OBJECTMAP &oj);
HRESULT GetNext_ObjectMap (CSQLConnection *pConn, OBJECTMAP &oj);
HRESULT InsertScopeMap_Internal(CSQLConnection *_pConn, SQL_ID dObjectId, LPCWSTR lpPath, SQL_ID dParentId);
HRESULT GetFirst_ClassMap (CSQLConnection *_pConn, SQL_ID dClassId, CLASSMAP &cd);
HRESULT GetFirst_ClassMapByName (CSQLConnection *_pConn, LPCWSTR lpName, CLASSMAP &cd);
HRESULT GetNext_ClassMap (CSQLConnection *_pConn, CLASSMAP &cd);
HRESULT GetClassMapData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                CLASSMAP &oj);
HRESULT GetPropertyMapData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                PROPERTYMAP &oj);
HRESULT GetFirst_PropertyMapByClass (CSQLConnection *_pConn, SQL_ID dClassId, PROPERTYMAP &pm);
HRESULT GetNext_PropertyMap (CSQLConnection *_pConn, PROPERTYMAP &pm);
HRESULT GetFirst_ReferencePropertiesByClass (CSQLConnection *_pConn, SQL_ID dClassId, 
                                      REFERENCEPROPERTIES &cd);
HRESULT GetNext_ReferenceProperties (CSQLConnection *_pConn, REFERENCEPROPERTIES &cd);
HRESULT GetReferencePropertiesData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                REFERENCEPROPERTIES &oj);
HRESULT GetFirst_ClassKeys (CSQLConnection *_pConn, SQL_ID dClassId, CLASSKEYS &cd);
HRESULT GetNext_ClassKeys (CSQLConnection *_pConn, CLASSKEYS &cd);
HRESULT GetFirst_ClassData (CSQLConnection *pConn, SQL_ID dId, CLASSDATA &cd,
                                   DWORD iPropertyId = -1, BOOL bMinimum = FALSE, CSchemaCache *pCache = NULL);
HRESULT GetNext_ClassData (CSQLConnection *pConn, CLASSDATA &cd, DWORD iPropertyId = -1, BOOL bMinimum=FALSE,
                           CSchemaCache *pCache = NULL);

HRESULT GetIndexData (CSQLConnection *pConn, JET_SESID session, JET_TABLEID tableid,
                        DWORD dwPos, INDEXDATA &is);
HRESULT GetFirst_IndexDataNumeric (CSQLConnection *pConn, SQL_ID dNumericValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid);
HRESULT GetFirst_IndexDataString (CSQLConnection *pConn, LPWSTR lpStringValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid);
HRESULT GetFirst_IndexDataReal (CSQLConnection *pConn, double dValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid);
HRESULT GetFirst_IndexDataRef  (CSQLConnection *pConn, SQL_ID dValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid);
HRESULT GetNext_IndexData (CSQLConnection *pConn, JET_TABLEID tableid, DWORD dwPos, INDEXDATA &cd);
HRESULT GetContainerObjsData (CSQLConnection *pConn, JET_SESID session, JET_TABLEID tableid,
                CONTAINEROBJ &oj);
HRESULT GetNext_ContainerObjs (CSQLConnection *pConn, CONTAINEROBJ &cd);
HRESULT DeleteObjectMap (CSQLConnection *_pConn, SQL_ID dObjectId, 
                         BOOL bDecRef = FALSE, SQL_ID dScope = 0);
HRESULT DeleteContainerObjs (CSQLConnection *_pConn, SQL_ID dContainerId, SQL_ID dContaineeId = 0);

HRESULT SetupAutoDeleteAccessor(CSQLConnection *pConn);
HRESULT OpenEnum_AutoDelete (CSQLConnection *pConn, AUTODELETE &ad);
HRESULT GetNext_AutoDelete(CSQLConnection *pConn, AUTODELETE &ad);
HRESULT InsertAutoDelete(CSQLConnection *pConn, SQL_ID dObjectId);
HRESULT DeleteAutoDelete(CSQLConnection *pConn, SQL_ID dObjectId);
HRESULT CleanAutoDeletes(CSQLConnection *pConn);

#endif // _ESEUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\wqltoese.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   wqltoese.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _WQLTOESE_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#include "precomp.h"

#include <windows.h>
#include <comutil.h>
#include <flexarry.h>
#include <wstring.h>
#include <wqlnode.h>
#include <reposit.h>
#include <time.h>
#include <map>
#include <vector>
#include <wbemcli.h>
#include <wbemint.h>
#include <wqltoese.h>
#include <repcache.h>
#include <reputils.h>
#include <smrtptr.h>
#include <sqlcache.h>
#include <repdrvr.h>

//***************************************************************************
//
//  GetNumeric
//  GetString
//  GetDouble
//
//***************************************************************************

SQL_ID GetNumeric(SWQLTypedConst *pExpr)
{
    SQL_ID dRet = 0;
    
    if (pExpr)
    {
        switch (pExpr->m_dwType)
        {
        case VT_LPWSTR:
            dRet = _wtoi64(pExpr->m_Value.m_pString);
            break;
        case VT_I4:
            dRet = pExpr->m_Value.m_lValue;
            break;
        case VT_R4:
            dRet = pExpr->m_Value.m_dblValue;
            break;
        case VT_BOOL:
            dRet = pExpr->m_Value.m_bValue;
        default:
            dRet = 0;
            break;
        }
    }

    return dRet;
}
LPWSTR GetString(SWQLTypedConst *pExpr)
{
    LPWSTR lpRet = 0;
    
    if (pExpr)
    {
        switch (pExpr->m_dwType)
        {
        case VT_LPWSTR:
            lpRet = StripQuotes(pExpr->m_Value.m_pString);
            break;
        case VT_I4:
            lpRet = GetStr((SQL_ID)pExpr->m_Value.m_lValue);
            break;
        case VT_R4:
            lpRet = GetStr(pExpr->m_Value.m_dblValue);
            break;
        case VT_BOOL:
            lpRet = GetStr((SQL_ID)pExpr->m_Value.m_bValue);
        default:
            lpRet = 0;
            break;
        }        
    }

    return lpRet;

}
double GetDouble(SWQLTypedConst *pExpr)
{
    double dRet = 0;
    wchar_t *pEnd = NULL;
    
    if (pExpr)
    {
        switch (pExpr->m_dwType)
        {
        case VT_LPWSTR:
            dRet = wcstod(pExpr->m_Value.m_pString, &pEnd);
            break;
        case VT_I4:
            dRet = pExpr->m_Value.m_lValue;
            break;
        case VT_R4:
            dRet = pExpr->m_Value.m_dblValue;
            break;
        case VT_BOOL:
            dRet = pExpr->m_Value.m_bValue;
        default:
            dRet = 0;
            break;
        }
    }
    return dRet;

}

//***************************************************************************
//
//  GetESEFunction
//
//***************************************************************************

ESEFUNCTION GetESEFunction(LPWSTR lpFuncName, SWQLNode *pFunction, LPWSTR * lpColName)
{
    ESEFUNCTION func = ESE_FUNCTION_NONE;

    if (!lpColName)
        return func;

    if (lpFuncName && pFunction)
    {
        if (!_wcsicmp(lpFuncName, L"upper"))
            func = ESE_FUNCTION_UPPER;
        else if (!_wcsicmp(lpFuncName, L"lower"))
            func = ESE_FUNCTION_LOWER;
        else if (!_wcsicmp(lpFuncName, L"datepart"))
        {
            if (pFunction->m_dwNodeType == TYPE_SWQLNode_Datepart)
            {
                switch(((SWQLNode_Datepart *)pFunction)->m_nDatepart)
                {
                case WQL_TOK_YEAR:
                    func = ESE_FUNCTION_DATEPART_YEAR;
                    break;
                case WQL_TOK_MONTH:
                    func = ESE_FUNCTION_DATEPART_MONTH;
                    break;
                case WQL_TOK_DAY:
                    func = ESE_FUNCTION_DATEPART_DAY;
                    break;
                case WQL_TOK_HOUR:
                    func = ESE_FUNCTION_DATEPART_HOUR;
                    break;
                case WQL_TOK_MINUTE:
                    func = ESE_FUNCTION_DATEPART_MINUTE;
                    break;
                case WQL_TOK_SECOND:
                    func = ESE_FUNCTION_DATEPART_SECOND;
                    break;
                case WQL_TOK_MILLISECOND:
                    func = ESE_FUNCTION_DATEPART_MILLISECOND;
                    break;
                } 
                if (func)
                {
                    *lpColName = ((SWQLNode_Datepart *)pFunction)->m_pColRef->m_pColName;
                }
            }
        }
    }

    return func;
}

//***************************************************************************
//
//  GetESEOperator
//
//***************************************************************************

int GetESEOperator(DWORD dwOp, DWORD StorageType)
{
    int iRet = 0;

    switch(dwOp)
    {
    case WQL_TOK_IN_SUBSELECT:
    case WQL_TOK_NOT_IN_SUBSELECT:
    case WQL_TOK_NOT_IN:
    case WQL_TOK_IN:
    case WQL_TOK_IN_CONST_LIST:
    case WQL_TOK_NOT_IN_CONST_LIST:
        iRet = 0; // not supported
        break;

    case WQL_TOK_GT:
    case WQL_TOK_AFTER:
    case WQL_TOK_NOT_AFTER:
        iRet = WQL_TOK_GT;
        break;
    case WQL_TOK_LT:
    case WQL_TOK_BEFORE:
    case WQL_TOK_NOT_BEFORE:
        iRet = WQL_TOK_LT;
        break;
    case WQL_TOK_LE:
    case WQL_TOK_GE:
    case WQL_TOK_EQ:
    case WQL_TOK_NE:   
    case WQL_TOK_ISNULL:
    case WQL_TOK_NOT_NULL:
    case WQL_TOK_LIKE:
    case WQL_TOK_NOT_LIKE:
        iRet = dwOp;
        break;
    case WQL_TOK_ISA:
        if (StorageType == WMIDB_STORAGE_REFERENCE ||
            StorageType == WMIDB_STORAGE_COMPACT)
            iRet = dwOp;
        break;
    case WQL_TOK_BETWEEN:
        if (StorageType != WMIDB_STORAGE_REFERENCE)
            iRet = dwOp;
        break;
    default:
        iRet = 0;
    }

    return iRet;
}

//***************************************************************************
//
//   CESETokens::AddToken
//
//***************************************************************************

HRESULT CESETokens::AddToken(ESEToken *pTok, ESETOKENTYPE type, int *iNumAdded, int iPos )
{
    HRESULT hr = 0;

    if (pTok)
    {
        if (iPos != -1)
            m_arrToks.InsertAt(iPos, pTok);
        else
            m_arrToks.Add(pTok);
        if (iNumAdded)
            (*iNumAdded)++;
    }

    if (type && m_arrToks.Size() > 1)
    {
        ESEToken *pTok = new ESEToken(type);
        if (pTok)
        {
            m_arrToks.Add(pTok);
            if (iNumAdded)
                *iNumAdded++;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    return hr;
}

//***************************************************************************
//
//   CESETokens::AddNumericExpr
//
//***************************************************************************

HRESULT CESETokens::AddNumericExpr (SQL_ID dClassId, SQL_ID dPropertyId, SQL_ID dValue, 
                 ESETOKENTYPE type, int op, BOOL bIndexed,
                 SQL_ID dCompValue , ESEFUNCTION func , int *iNumAdded, BOOL bSys)
{
    HRESULT hr = 0;

    ESEWQLToken *pToken = new ESEWQLToken(type);
    if (pToken)
    {
        pToken->Value.valuetype = ESE_VALUE_TYPE_SQL_ID;
        pToken->Value.dValue = dValue;
        pToken->Value.dwFunc = func;
        pToken->CompValue.valuetype = ESE_VALUE_TYPE_SQL_ID;
        pToken->CompValue.dValue = dCompValue;
        pToken->tokentype = ESE_EXPR_TYPE_EXPR;
        pToken->optype = op;
        pToken->dScopeId = 0;
        pToken->dClassId = dClassId;
        pToken->dPropertyId = dPropertyId;
        pToken->bIndexed = bIndexed;
        pToken->bSysProp = bSys;
        
        hr = AddToken(pToken, type, iNumAdded);

    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//   CESETokens::AddReferenceExpr
//
//***************************************************************************

HRESULT CESETokens::AddReferenceExpr (SQL_ID dClassId, SQL_ID dPropertyId, SQL_ID dValue, 
                 ESETOKENTYPE type, int op,BOOL bIndexed,
                 SQL_ID dCompValue, ESEFUNCTION func , int *iNumAdded)
{
    HRESULT hr = 0;

    ESEWQLToken *pToken = new ESEWQLToken(type);
    if (pToken)
    {
        pToken->Value.valuetype = ESE_VALUE_TYPE_REF;
        pToken->Value.dRefValue = dValue;
        pToken->Value.dwFunc = func;
        pToken->CompValue.valuetype = ESE_VALUE_TYPE_REF;
        pToken->CompValue.dValue = dCompValue;
        pToken->tokentype = ESE_EXPR_TYPE_EXPR;
        pToken->optype = op;
        pToken->dScopeId = 0;
        pToken->dClassId = dClassId;
        pToken->dPropertyId = dPropertyId;
        pToken->bIndexed = bIndexed;
        
        hr = AddToken(pToken, type, iNumAdded);

    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//   CESETokens::AddStringExpr
//
//***************************************************************************

HRESULT CESETokens::AddStringExpr (SQL_ID dClassId, SQL_ID dPropertyId, LPWSTR lpValue, 
                 ESETOKENTYPE type, int op,BOOL bIndexed,
                 LPWSTR lpCompValue , ESEFUNCTION func, int *iNumAdded, BOOL bSys)
{
    HRESULT hr = 0;
    ESEWQLToken *pToken = new ESEWQLToken(type);
    if (pToken)
    {
        pToken->Value.valuetype = ESE_VALUE_TYPE_STRING;
        pToken->Value.sValue = SysAllocString(lpValue);
        pToken->Value.dwFunc = func;
        pToken->CompValue.valuetype = ESE_VALUE_TYPE_STRING;
        pToken->CompValue.sValue = SysAllocString(lpCompValue);
        pToken->tokentype = ESE_EXPR_TYPE_EXPR;
        pToken->optype = op;
        pToken->dScopeId = 0;
        pToken->dClassId = dClassId;
        pToken->dPropertyId = dPropertyId;
        pToken->bIndexed = bIndexed;
        pToken->bSysProp = bSys;

        hr = AddToken(pToken, type, iNumAdded);

    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//   CESETokens::AddRealExpr
//
//***************************************************************************

HRESULT CESETokens::AddRealExpr (SQL_ID dClassId, SQL_ID dPropertyId, double rValue, 
                 ESETOKENTYPE type, int op,BOOL bIndexed,
                 double dCompValue, ESEFUNCTION func , int *iNumAdded)
{
    HRESULT hr = 0;

    ESEWQLToken *pToken = new ESEWQLToken(type);
    if (pToken)
    {
        pToken->Value.valuetype = ESE_VALUE_TYPE_REAL;
        pToken->Value.rValue = rValue;
        pToken->Value.dwFunc = func;
        pToken->CompValue.valuetype = ESE_VALUE_TYPE_REAL;
        pToken->CompValue.rValue = dCompValue;
        pToken->tokentype = ESE_EXPR_TYPE_EXPR;
        pToken->optype = op;
        pToken->dScopeId = 0;
        pToken->dClassId = dClassId;
        pToken->dPropertyId = dPropertyId;
        pToken->bIndexed = bIndexed;
        
        hr = AddToken(pToken, type, iNumAdded);

    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//   CESETokens::AddPropExpr
//
//***************************************************************************

HRESULT CESETokens::AddPropExpr (SQL_ID dClassId, SQL_ID dPropertyId, SQL_ID dPropertyId2,
                     DWORD StorageType, ESETOKENTYPE type, int op,
                     BOOL bIndexed , ESEFUNCTION func,
                     ESEFUNCTION func2, int *iNumAdded)
{
    HRESULT hr = 0;

    ESEWQLToken *pToken = new ESEWQLToken(type);
    if (pToken)
    {
        switch(StorageType)
        {
            case WMIDB_STORAGE_STRING:
                pToken->Value.valuetype = ESE_VALUE_TYPE_STRING;
                break;
            case WMIDB_STORAGE_REAL:
                pToken->Value.valuetype = ESE_VALUE_TYPE_REAL;
                break;
            case WMIDB_STORAGE_REFERENCE:
                pToken->Value.valuetype = ESE_VALUE_TYPE_REF;
                break;
            case WMIDB_STORAGE_NUMERIC:
                pToken->Value.valuetype = ESE_VALUE_TYPE_SQL_ID;
                break;
            default:
                hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                break;
        }

        if (SUCCEEDED(hr))
        {
            pToken->tokentype = ESE_EXPR_TYPE_EXPR;
            pToken->optype = op;
            pToken->dScopeId = 0;
            pToken->dClassId = dClassId;
            pToken->dPropertyId = dPropertyId;
            pToken->dCompPropertyId = dPropertyId2;
            pToken->bIndexed = bIndexed;
            pToken->Value.dwFunc = func;
            pToken->CompValue.dwFunc = func2;
        
            hr = AddToken(pToken, type, iNumAdded);
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//   CESETokens::AddTempQlExpr
//
//***************************************************************************

HRESULT CESETokens::AddTempQlExpr (TEMPQLTYPE type,  SQL_ID dTargetID, 
                                   SQL_ID dResultClass, LPWSTR lpRole, 
                                   LPWSTR lpResultRole, SQL_ID dQfr, 
                                   SQL_ID dAssocQfr, SQL_ID dAssocClass, int *iNumAdded)
{
    HRESULT hr = 0;

    ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
    if (pToken)
    {
        pToken->token = TEMPQL_TOKEN_TARGETID;
        pToken->dValue = dTargetID;
        hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto Exit;
    }
   

    if (dResultClass)
    {
        ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
        if (pToken)
        {
            pToken->token = TEMPQL_TOKEN_RESULTCLASS;
            pToken->dValue = dResultClass;
            hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
    }

    if (lpRole)
    {
        ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
        if (pToken)
        {
            pToken->token = TEMPQL_TOKEN_ROLE;
            pToken->sValue = SysAllocString(lpRole);
            hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
    }

    if (lpResultRole)
    {
        ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
        if (pToken)
        {
            pToken->token = TEMPQL_TOKEN_RESULTROLE;
            pToken->sValue = SysAllocString(lpResultRole);
            hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
    }

    if (dQfr)
    {
        ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
        if (pToken)
        {
            pToken->token = TEMPQL_TOKEN_REQQUALIFIER;
            pToken->dValue = dQfr;
            hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
    }

    if (dAssocQfr)
    {
        ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
        if (pToken)
        {
            pToken->token = TEMPQL_TOKEN_ASSOCQUALIFIER;
            pToken->dValue = dAssocQfr;
            hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
    }

    if (dAssocClass)
    {
        ESETempQLToken *pToken = new ESETempQLToken(ESE_EXPR_TYPE_EXPR, type);
        if (pToken)
        {
            pToken->token = TEMPQL_TOKEN_ASSOCCLASS;
            pToken->dValue = dAssocClass;
            hr = AddToken((ESEToken *)pToken, ESE_EXPR_TYPE_AND, iNumAdded);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
    }

Exit:

    return hr;
}

//***************************************************************************
//
//  CESETokens::AddSysExpr
//
//***************************************************************************

HRESULT CESETokens::AddSysExpr (SQL_ID dScopeId, SQL_ID dClassId, int *iNumAdded)
{
    HRESULT hr = 0;

    if (dScopeId)
    {
        m_dScopeId = dScopeId;
        ESEWQLToken *pTok = new ESEWQLToken (ESE_EXPR_TYPE_EXPR);
        if (pTok)
        {
            pTok->Value.valuetype = ESE_VALUE_TYPE_SYSPROP;
            pTok->dScopeId = dScopeId;
            hr = AddToken(pTok, ESE_EXPR_INVALID, iNumAdded, 0);
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (dClassId)
    {
        ESEWQLToken *pTok = new ESEWQLToken (ESE_EXPR_TYPE_EXPR);
        if (pTok)
        {
            pTok->Value.valuetype = ESE_VALUE_TYPE_SYSPROP;
            pTok->dClassId = dClassId;
            hr = AddToken(pTok, ESE_EXPR_INVALID, iNumAdded, 0);
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

//***************************************************************************
//
//  CESETokens::UnIndexTokens
//
//***************************************************************************

HRESULT CESETokens::UnIndexTokens(int iNum)
{
    HRESULT hr = 0;
    int i = GetNumTokens() - iNum;
    int iStop = GetNumTokens();

    // Reset the bIndexed flag on the last iNum tokens

    for (; i < iStop; i++)
    {
        ESEToken *pTok = GetToken(i);
        if (pTok->tokentype == ESE_EXPR_TYPE_EXPR)
        {
            ESEWQLToken *pTok2 = (ESEWQLToken *)pTok;
            pTok2->bIndexed = FALSE;
        }
    }

    return hr;
}

//***************************************************************************
//
//  TempQL Lex Table
//
//***************************************************************************

/*----------------------------------------------------

References of {objpath} where
    ResultClass=XXX
    Role=YYY
    RequiredQualifier=QualifierName
    ClassDefsOnly

Associators of {objpath} where
    ResultClass=XXX
    AssocClass=YYY
    Role=PPP
    RequiredQualifier=QualifierName
    RequiredAssocQualifier=QualifierName
    ClassDefsOnly

------------------------------------------------------*/

#define QASSOC_TOK_STRING       101
#define QASSOC_TOK_IDENT        102
#define QASSOC_TOK_DOT          103
#define QASSOC_TOK_EQU          104
#define QASSOC_TOK_COLON        105

#define QASSOC_TOK_ERROR        1
#define QASSOC_TOK_EOF          0

#define ST_IDENT                13
#define ST_STRING               19
#define ST_QSTRING              26
#define ST_QSTRING_ESC          30

LexEl AssocQuery_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'{',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,

/* 4 */  L'=',   GLEX_EMPTY, 0,  QASSOC_TOK_EQU, GLEX_ACCEPT|GLEX_RETURN,
/* 5 */  L'.',   GLEX_EMPTY, 0,  QASSOC_TOK_DOT, GLEX_ACCEPT|GLEX_RETURN,
/* 6 */  L':',   GLEX_EMPTY, 0,  QASSOC_TOK_COLON, GLEX_ACCEPT|GLEX_RETURN,

/* 7 */  L' ',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 8 */  L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 9 */  L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 10 */  L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 11 */  0,      GLEX_EMPTY, 0,  QASSOC_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 12 */  GLEX_ANY, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


/* ST_IDENT */

/* 13 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 14 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 15 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 16 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 17 */  GLEX_ANY, GLEX_EMPTY,  0,  QASSOC_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

/* ST_STRING */
/* 18 */  0, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 19 */  L'"', GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
/* 20 */  L'}',  GLEX_EMPTY, 0, QASSOC_TOK_STRING, GLEX_RETURN,
/* 21 */  L' ',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 22 */  L'\r',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 23 */  L'\n',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 24 */  L'\t',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 25 */  GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

/* ST_QSTRING */
/* 26 */   0,    GLEX_EMPTY,   0, QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 27 */   L'"', GLEX_EMPTY,   ST_STRING, 0, GLEX_ACCEPT,
/* 28 */   L'\\', GLEX_EMPTY,   ST_QSTRING_ESC, 0, GLEX_ACCEPT,
/* 29 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,

/* ST_QSTRING_ESC */
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
};


//***************************************************************************
//
//  CESEBuilder::FormatSQL
//
//***************************************************************************
HRESULT CESEBuilder::FormatSQL (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                IWbemQuery *pQuery, CESETokens **ppTokens,
                                DWORD dwFlags,
                                DWORD dwHandleType, SQL_ID *dClassId, BOOL *bHierarchyQuery,
                                BOOL *pIndexCols, BOOL *pSuperSet, BOOL *bDeleteQuery)
{

    // This needs to convert an entire query
    // into a set of ESE tokens.

    HRESULT hr = WBEM_S_NO_ERROR;

    if (!m_pSchema)
        return WBEM_E_NOT_FOUND;

    if (pSuperSet)
        *pSuperSet = FALSE;

    char szTmpNum[25];
    m_dwTableCount = 1;
    m_bClassSpecified = false;
    BOOL bDelete = FALSE;

    m_dNamespace = dScopeId;

    if (bHierarchyQuery)
        *bHierarchyQuery = FALSE;

    CESETokens *pTokens = new CESETokens;
    if (!pTokens)
        return WBEM_E_OUT_OF_MEMORY;
   
    if (m_dNamespace)
    {
        // Scope is an __Instances container
        // This is shallow by definition.
        if (dScopeClassId == INSTANCESCLASSID)
            pTokens->AddSysExpr(dSuperScope, dScopeId);
        else
        {
            // Shallow enumeration
            if (!(dwFlags & WMIDB_FLAG_QUERY_DEEP))
            {
                if (!(dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER))
                    pTokens->AddSysExpr(dScopeId, 0);
            }
            else
            {
                // Deep enumeration;
                // Enumerate all possible subscopes.
                SQL_ID dScopeToUse = dScopeId;
                if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
                    dScopeToUse = dSuperScope;                    

                pTokens->AddSysExpr(dScopeToUse, 0);

                SQL_ID *pIds = NULL;
                int iNumScopes = 0;

                hr = m_pSchema->GetSubScopes(dScopeToUse, &pIds, iNumScopes);
                if (SUCCEEDED(hr))
                {
                    for (int i = 0; i < iNumScopes; i++)
                    {
                        pTokens->AddSysExpr(pIds[i], 0);
                    }
                    delete pIds;
                }
            }
        }
    }

    if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
        m_dNamespace = dSuperScope; // Containers are not valid scopes.

    if (pQuery)
    {
        SWQLNode *pTop = NULL, *pRoot = NULL; 
        pQuery->GetAnalysis(WMIQ_ANALYSIS_RESERVED, 0, (void **)&pTop);
        if (pTop)
        {
            // Select or Delete... doesn't matter since we have 
            // to fire events for each item ANYWAY.

            if (pTop->m_pLeft != NULL)
            {
                pRoot = pTop->m_pLeft;

                if (pRoot->m_dwNodeType == TYPE_SWQLNode_Delete)
                    bDelete = TRUE;

                if (pRoot->m_pLeft != NULL)
                {
                    // Load the class information

                    hr = GetClassFromNode(pRoot->m_pLeft);
                    if (SUCCEEDED(hr))
                    {
                        if (m_dClassID == INSTANCESCLASSID)
                             pTokens->AddSysExpr(0, 1);
                        else
                             pTokens->AddSysExpr(0, m_dClassID);
                    }
                }           
                else
                    hr = WBEM_E_INVALID_SYNTAX;
            }

            if (SUCCEEDED(hr))
            {
                // Now we parse the where clause.
                if (pRoot->m_pRight && pRoot->m_pRight->m_pLeft)
                {
                    if (pRoot->m_pRight->m_pRight) // group by, having, order by
                    {
                        if (pSuperSet)
                        {
                            *pSuperSet = TRUE;
                            hr = WBEM_S_NO_ERROR;
                        }
                        else
                            hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                    }
                    if (SUCCEEDED(hr))
                    {
                        BOOL IndexCols = FALSE;
                        _bstr_t sNewSQL;
                        hr = FormatWhereClause((SWQLNode_RelExpr *)pRoot->m_pRight->m_pLeft, 
                                    pTokens, IndexCols, NULL, NULL, pSuperSet);
                        if (SUCCEEDED(hr) ||  hr == WBEM_E_PROVIDER_NOT_CAPABLE)
                        {
                            // Make sure the results are limited to instances of the requested class
                            // (Safeguard)

                            if (!m_bClassSpecified)
                            {
                                // __Instances is automatically a shallow hierarchy query

                                if (m_dClassID != INSTANCESCLASSID)
                                {
                                    if (bHierarchyQuery)
                                        *bHierarchyQuery = TRUE;
                                }
                            }
                            if (hr == WBEM_E_PROVIDER_NOT_CAPABLE)
                            {
                                if (pSuperSet)
                                {
                                    *pSuperSet = TRUE;
                                    hr = WBEM_S_NO_ERROR;
                                }
                            }
                        }
                        if (pIndexCols)
                            *pIndexCols = IndexCols;
                    }
                }
                else
                {
                    // __Instances is automatically a shallow hierarchy query

                    if (m_dClassID != INSTANCESCLASSID)
                    {
                        if (bHierarchyQuery)
                            *bHierarchyQuery = TRUE;
                    }
                }
                if (dClassId)
                {
                    if (m_dClassID == INSTANCESCLASSID)
                        *dClassId = 1;
                    else
                        *dClassId = m_dClassID;
                }
            }

            if (ppTokens)
                *ppTokens = pTokens;
        }
        else
            hr = WBEM_E_INVALID_QUERY;
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;

    if (bDeleteQuery)
        *bDeleteQuery = bDelete;

    return hr;
}


//***************************************************************************
//
//  CESEBuilder::FormatSQL
//
//***************************************************************************

HRESULT CESEBuilder::FormatSQL (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                SQL_ID dTargetObjID, LPWSTR pResultClass,
                                LPWSTR pAssocClass, LPWSTR pRole, LPWSTR pResultRole, LPWSTR pRequiredQualifier,
                                LPWSTR pRequiredAssocQualifier, DWORD dwQueryType, CESETokens **ppTokens, 
                                DWORD dwFlags,DWORD dwHandleType, SQL_ID *_dAssocClass, SQL_ID *_dResultClass,
                                BOOL *pSuperSet)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwRoleID = 0, dwResultRole = 0, dwAssocQfr = 0, dwQfrID = 0;
    SQL_ID dResultClass = 0;
    SQL_ID dAssocClass = 0, dTargetObj = 0;
    _bstr_t sName;
    SQL_ID dwSuperClassID;
    DWORD dwTemp;
    SQL_ID dwScopeID;
    TEMPQLTYPE type = ESE_TEMPQL_TYPE_ASSOC;

    if (pSuperSet)
        *pSuperSet = FALSE;

    // Containers are not valid scopes.

    if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
        m_dNamespace = dSuperScope;
    else
        m_dNamespace = dScopeId;  

    m_pSession->LoadClassInfo(m_pConn, sName, m_dNamespace);

    hr = m_pSchema->GetClassInfo(dTargetObjID, sName, dwSuperClassID, dwScopeID, dwTemp);

    CESETokens *pToks = new CESETokens;
    if (!pToks)
        return WBEM_E_OUT_OF_MEMORY;

    if (dwQueryType & QUERY_TYPE_CLASSDEFS_ONLY)
    {
        if (pSuperSet)
            *pSuperSet = TRUE;
        else
        {
            hr = WBEM_E_PROVIDER_NOT_CAPABLE;
            delete pToks;
            goto Exit;
        }
    }

    if (m_dNamespace)
    {
        if (dScopeClassId == INSTANCESCLASSID)
            pToks->AddSysExpr(dSuperScope, dScopeId);
        else
        {
            if (!(dwFlags & WMIDB_FLAG_QUERY_DEEP))
            {
                if (!(dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER))
                pToks->AddSysExpr(dScopeId, 0);
            }
            else
                hr = E_NOTIMPL;
        }
    }
   
    // RESULTCLASS
    if (pResultClass != NULL)
    {
        // Get the class ID of this class      
        m_pSession->LoadClassInfo(m_pConn, pResultClass, m_dNamespace);

        hr = m_pSchema->GetClassID(pResultClass, m_dNamespace, dResultClass);
        if (FAILED(hr))
            goto Exit;

        if (_dResultClass)
            *_dResultClass = dResultClass;
    }

    // REQUIREDQUALIFIER
    if (pRequiredQualifier != NULL)
    {
        if (pSuperSet)
            *pSuperSet = TRUE;

        // Since we are no longer storing class qualifiers as properties,
        // we have no way of prefiltering this information.

        //DWORD dwPropId = 0;
        //hr = m_pSchema->GetPropertyID(pRequiredQualifier, 1, 
        //        REPDRVR_FLAG_QUALIFIER, REPDRVR_IGNORE_CIMTYPE, dwQfrID, NULL, NULL, NULL, TRUE);
        //if (FAILED(hr))
        //    goto Exit;
    }

    // REQUIREDASSOCQUALIFIER
    if (pRequiredAssocQualifier)
    {    
        if (pSuperSet)
            *pSuperSet = TRUE;

        // Since we are no longer storing class qualifiers as properties,
        // we have no way of prefiltering this information.

        //hr = m_pSchema->GetPropertyID(pRequiredAssocQualifier, 1, 
         //       REPDRVR_FLAG_QUALIFIER, REPDRVR_IGNORE_CIMTYPE, dwAssocQfr, NULL, NULL, NULL, TRUE);
        //if (FAILED(hr))
        //    goto Exit;
    }

    // ASSOCCLASS
    if (pAssocClass)
    {
        m_pSession->LoadClassInfo(m_pConn, pAssocClass, m_dNamespace);

        hr = m_pSchema->GetClassID(pAssocClass, m_dNamespace, dAssocClass);
        if (FAILED(hr))
            goto Exit;

        if (_dAssocClass)
            *_dAssocClass = dAssocClass;
    }

    if (dwQueryType & QUERY_TYPE_GETREFS)
        type = ESE_TEMPQL_TYPE_REF;

    hr = pToks->AddTempQlExpr(type, dTargetObjID, dResultClass, pRole, pResultRole,
            dwQfrID, dwAssocQfr, dAssocClass);

    *ppTokens = pToks;

Exit:

    return hr;

}
//***************************************************************************
//
//  CESEBuilder::FormatWhereClause
//
//***************************************************************************

HRESULT CESEBuilder::FormatWhereClause (SWQLNode_RelExpr *pNode, CESETokens *pTokens, 
                                        BOOL &IndexCols, BOOL *bOrCrit, int *iNumToksAdded,
                                        BOOL *pSuperSet)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bDone = FALSE;
    SQL_ID dClassId = 0;

    if (pNode)
    {
        DWORD dwType = pNode->m_dwExprType;
        BOOL bOrLeft = FALSE, bOrRight = FALSE;
        BOOL bIndexLeft = FALSE, bIndexRight = FALSE;
        int iNumAdded = 0;

        switch(dwType)
        {
        case WQL_TOK_OR:
        case WQL_TOK_AND:

            if (pNode->m_pLeft)
            {
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pLeft, 
                        pTokens, bIndexLeft, &bOrLeft, &iNumAdded, pSuperSet);
                if (hr == WBEM_E_PROVIDER_NOT_CAPABLE)
                {
                    if (pSuperSet)
                        *pSuperSet = TRUE;
                    else 
                        goto Exit;
                }
                else if (FAILED(hr))
                    goto Exit;
            }

            if (pNode->m_pRight)
            {
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pRight, 
                        pTokens, bIndexRight, &bOrRight, &iNumAdded, pSuperSet);
                if (hr == WBEM_E_PROVIDER_NOT_CAPABLE)
                {
                    if (pSuperSet)
                        *pSuperSet = TRUE;
                    else
                        goto Exit;
                }
                else if (FAILED(hr))
                    goto Exit;
            }

            // Indexing logic.  If we have an AND token, see if there are 
            // any ORs underneath it.  If there are ORs on both sides, we
            // can't use this criteria as an index, or we will get 
            // possible duplicates.

            if (SUCCEEDED(hr))
            {
                if (dwType == WQL_TOK_AND)
                {
                    if (!(bOrLeft && bOrRight))
                    {
                        if (bIndexLeft || bIndexRight)
                            IndexCols = TRUE;
                    }
                    else
                    {
                        pTokens->UnIndexTokens(iNumAdded);
                        IndexCols = FALSE;  
                    }
                }
                else // WQL_TOK_OR
                {
                    pTokens->UnIndexTokens(iNumAdded);
                    IndexCols = FALSE;  
                    if (bOrCrit)
                        *bOrCrit = TRUE;
                }

                pTokens->AddToken(NULL, (ESETOKENTYPE)dwType, iNumToksAdded);
            }
            hr = WBEM_S_NO_ERROR;

            break;
        case WQL_TOK_NOT:
            // Supposedly, only a left clause follows not...
            if (pNode->m_pLeft)
            {
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pLeft, pTokens, IndexCols, pSuperSet);
                if (hr == WBEM_E_PROVIDER_NOT_CAPABLE)
                {
                    if (pSuperSet)
                        *pSuperSet = TRUE;
                    else
                        goto Exit;
                }
                else if (FAILED(hr))
                    goto Exit;
            }

            if (SUCCEEDED(hr))
            {
                m_bClassSpecified = false;  // whatever we've done probably negated the class qualifier.
                pTokens->AddToken(NULL, (ESETOKENTYPE)dwType, iNumToksAdded);
                IndexCols = FALSE;  // They have negated the index criteria.
            }

            hr = WBEM_S_NO_ERROR;

            break;

        default:    // Typed expression

            m_dwTableCount++;
            
            SWQLTypedExpr *pExpr = ((SWQLNode_RelExpr *)pNode)->m_pTypedExpr;
            if (pExpr != NULL)
            {
                DWORD dwProp1 = 0, dwProp2 = 0, dwOp = 0;
                DWORD dwStorage1 = 0, dwStorage2 = 0;
                DWORD dwKey1 = 0, dwKey2 = 0;
                ESEFUNCTION func1, func2;
              
                LPWSTR lpColName = pExpr->m_pColRef;
                func1 = GetESEFunction(pExpr->m_pIntrinsicFuncOnColRef, pExpr->m_pLeftFunction, &lpColName);

                hr = GetPropertyID(m_dClassID, pExpr->m_pQNLeft, lpColName, dwProp1, dwStorage1, dwKey1);

                if (SUCCEEDED(hr))
                {                    

                    // Can't query anything stored as image

                    if (dwStorage1 == WMIDB_STORAGE_IMAGE || dwStorage2 == WMIDB_STORAGE_IMAGE)
                    {
                        hr = WBEM_E_QUERY_NOT_IMPLEMENTED;
                        goto Exit;
                    }

                    dwOp = GetESEOperator(pExpr->m_dwRelOperator, dwStorage1);

                    if (!dwOp)
                        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                    else
                    {
                        // Property to property comparisons

                        BOOL bSysProp = FALSE;
                        if (dwStorage1 == WMIDB_STORAGE_COMPACT)
                        {
                            bSysProp = TRUE;
                            if (dwOp == WQL_TOK_ISA)
                                dwOp = WQL_TOK_EQ;

                            if ((dwOp != WQL_TOK_EQ) && (dwOp != WQL_TOK_NE))
                            {
                                hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                                goto Exit;
                            }
                        }

                        if ((dwKey1 & 12) && dwOp == WQL_TOK_EQ)
                            IndexCols = TRUE;

                        if (SUCCEEDED(hr) && pExpr->m_pJoinColRef != NULL)
                        {
                            LPWSTR lpColName2 = pExpr->m_pJoinColRef;
                            func2 = GetESEFunction(pExpr->m_pIntrinsicFuncOnJoinColRef, pExpr->m_pRightFunction, &lpColName2);

                            hr = GetPropertyID(m_dClassID, pExpr->m_pQNRight, lpColName2, dwProp2, dwStorage2, dwKey2);
                            if (SUCCEEDED(hr))
                            {
                                if (dwStorage1 != dwStorage2)
                                {
                                    hr = WBEM_E_INVALID_QUERY;
                                    goto Exit;
                                }

                                if (dwStorage1 == WMIDB_STORAGE_COMPACT ||
                                    dwStorage2 == WMIDB_STORAGE_COMPACT)
                                {
                                    hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                                    goto Exit;
                                }
                            }                            

                            hr = pTokens->AddPropExpr (m_dClassID, dwProp1, dwProp2,
                                             dwStorage1, ESE_EXPR_INVALID, dwOp,
                                             IndexCols, func1,func2, iNumToksAdded);
                        }
                        else if (SUCCEEDED(hr) && pExpr->m_pConstValue)
                        {
                            if (pExpr->m_pConstValue->m_dwType == VT_LPWSTR)
                            {
                                if (dwStorage1 == WMIDB_STORAGE_NUMERIC)
                                {
                                    SQL_ID dValue = _wtoi64(pExpr->m_pConstValue->m_Value.m_pString);
                                    SQL_ID dValue2 = GetNumeric(pExpr->m_pConstValue2);

                                    hr = pTokens->AddNumericExpr(m_dClassID, dwProp1, dValue,
                                        ESE_EXPR_INVALID, dwOp, IndexCols, dValue2, func1, iNumToksAdded,
                                        bSysProp);
                                }
                                else if (dwStorage1 == WMIDB_STORAGE_REFERENCE)
                                {
                                    if (dwOp != WQL_TOK_ISA)
                                        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                                    else
                                    {
                                        SQL_ID dRefClassId;

                                        m_pSession->LoadClassInfo(m_pConn, pExpr->m_pConstValue->m_Value.m_pString, m_dNamespace);

                                        hr = m_pSchema->GetClassID(pExpr->m_pConstValue->m_Value.m_pString, 
                                            m_dNamespace, dRefClassId);
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = pTokens->AddReferenceExpr(m_dClassID, dwProp1, dRefClassId,
                                                ESE_EXPR_INVALID, dwOp, FALSE, 0, func1, iNumToksAdded);

                                        }
                                    }
                                }
                                else
                                {
                                    LPWSTR lpTemp = StripQuotes(pExpr->m_pConstValue->m_Value.m_pString);
                                    LPWSTR lpTemp2 = GetString(pExpr->m_pConstValue2);
                                    CDeleteMe <wchar_t> r (lpTemp), r2 (lpTemp2);

                                    // See if this is a potential caching problem.
                                    if (m_dClassID == 1)
                                        m_pSession->LoadClassInfo(m_pConn, lpTemp, m_dNamespace);

                                    CIMTYPE ct=0;
                                    m_pSchema->GetPropertyInfo(dwProp1, NULL, NULL, NULL, (DWORD *)&ct);
                                    if (ct != CIM_DATETIME)
                                    {
                                        hr = pTokens->AddStringExpr(m_dClassID, dwProp1, lpTemp,
                                            ESE_EXPR_INVALID, dwOp, IndexCols, lpTemp2, func1, iNumToksAdded,
                                            bSysProp);
                                    }
                                    else
                                    {
                                        if (pSuperSet)
                                            *pSuperSet = TRUE;
                                    }
                                }
                            }
                            else if (pExpr->m_pConstValue->m_dwType == VT_NULL)
                                hr = WBEM_E_INVALID_QUERY;
                            else if (pExpr->m_pConstValue->m_dwType == VT_I4)
                            {
                                SQL_ID lVal1 = (long)pExpr->m_pConstValue->m_Value.m_lValue;
                                SQL_ID lVal2 = GetNumeric(pExpr->m_pConstValue2);

                                hr = pTokens->AddNumericExpr(m_dClassID, dwProp1, lVal1,
                                        ESE_EXPR_INVALID, dwOp, IndexCols, lVal2, func1, iNumToksAdded,
                                        bSysProp);
                            }
                            else if (pExpr->m_pConstValue->m_dwType == VT_R8)
                            {
                                double lVal1 = (double)pExpr->m_pConstValue->m_Value.m_dblValue;
                                double lVal2 = GetDouble(pExpr->m_pConstValue2);

                                hr = pTokens->AddRealExpr(m_dClassID, dwProp1, lVal1,
                                        ESE_EXPR_INVALID, dwOp, IndexCols, lVal2, func1, iNumToksAdded);
                            }
                            else if (pExpr->m_pConstValue->m_dwType == VT_BOOL)
                            {
                                SQL_ID lVal1 = (SQL_ID)pExpr->m_pConstValue->m_Value.m_bValue;
                                SQL_ID lVal2 = GetNumeric(pExpr->m_pConstValue2);

                                hr = pTokens->AddNumericExpr(m_dClassID, dwProp1, lVal1,
                                        ESE_EXPR_INVALID, dwOp, IndexCols, lVal2, func1, iNumToksAdded,
                                        bSysProp);

                            }
                        }                        
                    }
                }
            }
        }
    }

Exit:

    return hr;
}


//***************************************************************************
//
//  CESEBuilder::GetPropertyID
//
//***************************************************************************

HRESULT CESEBuilder::GetPropertyID (SQL_ID dClassID, SWQLQualifiedName *pQN, LPCWSTR pColRef, DWORD &PropID, DWORD &Storage, DWORD &Flags)
{

    // If this is an embedded object property,
    // we need the actual class ID.  The only way
    // to do that is the walk through all the properties,
    // and reconcile each layer.

    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dRefClassId = dClassID;

    if (pQN != NULL)
    {        
        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
        
        // This is too tricky, since we would have to
        // find the objects that match the query, 
        // find all objects that have that object as
        // an embedded object, and so on.  Too much
        // work, for now.

        /*
        for (int i = pQN->GetNumNames() - 1; i >= 0; i--)
        {
            SWQLQualifiedNameField *pNF = (SWQLQualifiedNameField *)pQN->m_aFields[i];
            if (pNF)
            {
                hr = m_pSchema->GetPropertyID(pNF->m_pName, dRefClassId, PropID, &dClassID, NULL, NULL, TRUE);
                if (SUCCEEDED(hr))
                {
                    // Look up the property ID for this class.
                    hr = m_pSchema->GetPropertyInfo(PropID, NULL, NULL, &Storage,
                        NULL, &Flags);
                }                    
            }
        }
        */
    }
    else if (pColRef != NULL)
    {
        wchar_t wName[1024];

        if (!_wcsicmp(pColRef, L"__this"))
            wcscpy(wName, L"__Derivation");
        else
            wcscpy(wName, pColRef);

        // Look up the property ID for this class.
        hr = m_pSchema->GetPropertyID(wName, m_dClassID, 0, REPDRVR_IGNORE_CIMTYPE, PropID, &dClassID, NULL, NULL, TRUE);
        if (SUCCEEDED(hr))
            hr = m_pSchema->GetPropertyInfo(PropID, NULL, NULL, &Storage,
                NULL, &Flags);
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;

    if (m_dClassID == dClassID)
        m_bClassSpecified = true;

    if (Flags & REPDRVR_FLAG_SYSTEM)    
        Storage = WMIDB_STORAGE_COMPACT;

    return hr;
}

//***************************************************************************
//
//  CESEBuilder::GetClassFromNode
//
//***************************************************************************

HRESULT CESEBuilder::GetClassFromNode (SWQLNode *pNode)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR lpTableName = NULL;

    switch(pNode->m_dwNodeType)
    {
    case TYPE_SWQLNode_TableRefs:

        if (((SWQLNode_TableRefs *)pNode)->m_nSelectType == WQL_FLAG_COUNT)
            return WBEM_E_PROVIDER_NOT_CAPABLE;
        
        if (pNode->m_pRight != NULL)
        {
            if (pNode->m_pRight->m_pLeft->m_dwNodeType != TYPE_SWQLNode_TableRef)
                hr = WBEM_E_PROVIDER_NOT_CAPABLE;
            else
            {
                SWQLNode_TableRef *pRef = (SWQLNode_TableRef *)pNode->m_pRight->m_pLeft;
                lpTableName = pRef->m_pTableName;
            }
        }
        else
            return WBEM_E_INVALID_SYNTAX;

        break;
    case TYPE_SWQLNode_TableRef:
        
        if (pNode->m_dwNodeType != TYPE_SWQLNode_TableRef)
            hr = WBEM_E_INVALID_SYNTAX;
        else
            lpTableName = ((SWQLNode_TableRef *)pNode)->m_pTableName;
        
        break;
    default:
        return WBEM_E_NOT_SUPPORTED;
        break;
    }
        
    // Query = "select * from __Instances" : fudge it so they get all classes in this namespace.

    m_pSession->LoadClassInfo(m_pConn, lpTableName, m_dNamespace);

    hr = m_pSchema->GetClassID(lpTableName, m_dNamespace, m_dClassID);
    if (FAILED(hr))
        hr = WBEM_E_INVALID_QUERY;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\jet\dllentryjet.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  dllentry.cpp
//
//
//
//
//
//
//  History:
//
//      cvadai      4/1/1999    created.
//
//
//  Copyright (c)1999-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////////////////

//#define _AFXDLL

// #include <afxwin.h>
#include "precomp.h"
#include <comdef.h>
#include <std.h>
#include <clsfctry.h>
#include <reposit.h>

const wchar_t * g_pszComServerName   = L"WINMGMT Jet Repository Driver";
const wchar_t * g_pszThreadingModel  = L"Both";

// static AFX_EXTENSION_MODULE ExtDLL;
HINSTANCE       hHandle;

//******************************************************************************
//
//  DllMain()
//
//******************************************************************************
extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // If the process is attaching to this extension DLL, initialize:
    // ==============================================================

    if (dwReason == DLL_PROCESS_ATTACH) 
    {
        hHandle = GetModuleHandle(L"REPDRVJ.DLL");
    }

    // Return successfully.
    // ====================

    return(TRUE);
}


//-----------------------------------------------------------------------------
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    HRESULT hr = E_FAIL;

    if (CLSID_WmiRepository_Jet==rclsid)
    {
        CFactory * pObj = new CFactory();

        if (pObj != NULL)
        {
            hr = pObj->QueryInterface(riid, ppv);

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
        else
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
        }
    }

    return hr;
}




//-----------------------------------------------------------------------------
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//
//

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=( g_cObj < 1 && g_cLock < 1) ? S_OK : S_FALSE;
    return sc;
}

//-----------------------------------------------------------------------------
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//
//

STDAPI DllRegisterServer(void)
{   
    WCHAR   wcID[128];
    wchar_t szCLSID[128];
    wchar_t szModule[MAX_PATH];
    HKEY    hKey1;
    HKEY    hKey2;

    // Create the path.

    StringFromGUID2(CLSID_WmiRepository_Jet, wcID, 128);
    wcscpy(szCLSID, TEXT("CLSID\\"));
    wcscat(szCLSID, wcID);


    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)g_pszComServerName, wcslen(g_pszComServerName)*2);
    RegCreateKey(hKey1,L"InprocServer32",&hKey2);

    HINSTANCE hInst = GetModuleHandle(L"repdrvj.DLL");
    GetModuleFileName(hInst, szModule,  MAX_PATH);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, wcslen(szModule)*2);
    RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)g_pszThreadingModel, wcslen(g_pszThreadingModel)*2);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}


//-----------------------------------------------------------------------------
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//
//

STDAPI DllUnregisterServer(void)
{
    wchar_t szID[128];
    WCHAR   wcID[128];
    wchar_t szCLSID[128];
    HKEY    hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_WmiRepository_Jet, wcID,sizeof(wcID));
    wcscpy(szCLSID, L"CLSID\\");
    wcscat(szCLSID, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\eseutils.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   ESEUTILS.cpp
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************
// #define OBJECT_BLOB_CRC

#define _JET_PROCS_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#include "precomp.h"
#include <std.h>
#include <cominit.h>
#include <ese.h>
#include <sqlexec.h>
#include <sqlcache.h>
#include <eseobjs.h>
#include <repdrvr.h>
#include <wbemint.h>
#include <math.h>
#include <objbase.h>
#include <resource.h>
#include <reputils.h>
#include <arena.h>
#include <crc64.h>
#include <smrtptr.h>
#include <eseitrtr.h>
#include <wqltoese.h>
#include <eseutils.h>
#include <repcache.h>
#include <objbase.h>
#include <wbemprov.h>

#define MAX_STRING_WIDTH                255

#define OBJECTMAP_COL_OBJECTID          1
#define OBJECTMAP_COL_OBJECTPATH        2
#define OBJECTMAP_COL_OBJECTKEY         3
#define OBJECTMAP_COL_REFERENCECOUNT    4
#define OBJECTMAP_COL_OBJECTSTATE       5
#define OBJECTMAP_COL_CLASSID           6
#define OBJECTMAP_COL_OBJECTFLAGS       7
#define OBJECTMAP_COL_OBJECTSCOPEID     8

#define CLASSMAP_COL_CLASSID            1
#define CLASSMAP_COL_CLASSNAME          2
#define CLASSMAP_COL_SUPERCLASSID       3
#define CLASSMAP_COL_DYNASTYID          4
#define CLASSMAP_COL_CLASSBUFFER        5

#define PROPERTYMAP_COL_CLASSID         1
#define PROPERTYMAP_COL_PROPERTYID      2
#define PROPERTYMAP_COL_STORAGETYPEID   3
#define PROPERTYMAP_COL_CIMTYPEID       4
#define PROPERTYMAP_COL_PROPERTYNAME    5
#define PROPERTYMAP_COL_FLAGS           6
#define PROPERTYMAP_COL_REFCLASSID      7

#define CLASSKEYS_COL_CLASSID           1
#define CLASSKEYS_COL_PROPERTYID        2

#define REFPROPS_COL_CLASSID            1
#define REFPROPS_COL_PROPERTYID         2
#define REFPROPS_COL_REFCLASSID         3

#define CLASSDATA_COL_OBJECTID          1
#define CLASSDATA_COL_PROPERTYID        2
#define CLASSDATA_COL_ARRAYPOS          3
#define CLASSDATA_COL_QFRPOS            4
#define CLASSDATA_COL_CLASSID           5
#define CLASSDATA_COL_STRINGVALUE       6
#define CLASSDATA_COL_NUMERICVALUE      7
#define CLASSDATA_COL_REFID             8
#define CLASSDATA_COL_REALVALUE         9
#define CLASSDATA_COL_REFCLASSID        10
#define CLASSDATA_COL_FLAGS             11

#define CLASSIMAGES_COL_OBJECTID        1
#define CLASSIMAGES_COL_PROPERTYID      2
#define CLASSIMAGES_COL_ARRAYPOS        3
#define CLASSIMAGES_COL_IMAGEVALUE      4

#define INDEXTBL_COL_OBJECTID           1
#define INDEXTBL_COL_PROPERTYID         2
#define INDEXTBL_COL_ARRAYPOS           3
#define INDEXTBL_COL_INDEXVALUE         4

#define CONTAINEROBJS_COL_CONTAINERID   1
#define CONTAINEROBJS_COL_CONTAINEEID   2

#define AUTODELETE_COL_OBJECTID         1

#define SCOPEMAP_COL_OBJECTID           1
#define SCOPEMAP_COL_SCOPEPATH          2
#define SCOPEMAP_COL_PARENTID           3

typedef std::vector <SQL_ID> SQLIDs;
typedef std::vector <DWORD> IDs;
typedef std::vector <_bstr_t> _bstr_ts;
typedef std::map <DWORD, DWORD> Properties;
JET_INSTANCE gJetInst = NULL;
typedef std::map <DWORD, SQLIDs> SessionDynasties;


LPWSTR StripQuotes2(LPWSTR lpText)
{
    wchar_t *pszTemp = new wchar_t [wcslen(lpText)+1];
    if (pszTemp)
    {
        int iPos = 0;
        BOOL bOnQuote = FALSE;
        int iLen = wcslen(lpText);
        if (iLen)
        {
            for (int i = 0; i < iLen; i++)
            {
                WCHAR t = lpText[i];
                if (t == '\'')
                {
                    if (!bOnQuote)
                    {
                        if (lpText[i+1] == '\'')
                        {
                            bOnQuote = TRUE;
                            continue;
                        }                    
                    }    
                }
                bOnQuote = FALSE;
                pszTemp[iPos] = t;
                iPos++;
            }
        }
        pszTemp[iPos] = '\0';
    }
    return pszTemp;
}

void FreeBstr(BSTR * ppStr)
{
    if (ppStr)
    {
        SysFreeString(*ppStr);
        *ppStr = NULL;
    }
}

HRESULT LoadSchemaProperties (CSQLConnection *pConn, CSchemaCache *pCache, SQL_ID dClassId)
{
    // Enumerate properties

    HRESULT hr = WBEM_S_NO_ERROR;

    PROPERTYMAP pm;
    hr = GetFirst_PropertyMapByClass(pConn, dClassId, pm);
    while (SUCCEEDED(hr))
    {
        hr = pCache->AddPropertyInfo (pm.iPropertyId, 
                pm.sPropertyName, pm.dClassId, pm.iStorageTypeId, pm.iCIMTypeId, pm.iFlags, 
                 0, L"", 0, 0);

        if (FAILED(hr))
        {
            pm.Clear();
            break;
        }

        hr = GetNext_PropertyMap(pConn, pm);
    }

    CLASSKEYS ck;
    hr = GetFirst_ClassKeys (pConn, dClassId, ck);
    while (SUCCEEDED(hr))
    {
        pCache->SetIsKey(ck.dClassId, ck.iPropertyId);

        hr = GetNext_ClassKeys(pConn, ck);
    }
    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}


//***************************************************************************
//
//  CWmiDbController::GetLogonTemplate
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::GetLogonTemplate( 
    /* [in] */ LCID lLocale,
    /* [in] */ DWORD dwFlags,
    /* [out] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *__RPC_FAR *ppTemplate) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (dwFlags != 0 || !ppTemplate)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        if (ppTemplate)
        {
            WMIDB_LOGON_TEMPLATE *pTemp = new WMIDB_LOGON_TEMPLATE;            
        
            if (pTemp)
            {
                pTemp->dwArraySize = 5;
                HINSTANCE hRCDll = GetResourceDll(lLocale);
                if (!hRCDll)
                {
                    LCID lTemp = GetUserDefaultLangID();
                    hRCDll = GetResourceDll(lTemp);
                    if (!hRCDll)
                    {
                        lTemp = GetSystemDefaultLangID();
                        hRCDll = GetResourceDll(lTemp);
                        if (!hRCDll)
                            hRCDll = LoadLibrary(L"reprc.dll"); // Last resort - try the current directory.
                    }
                }

                wchar_t wDB[101], wUser[101], wPwd[101], wLocale[101], wMode[101];
                pTemp->pParm = new WMIDB_LOGON_PARAMETER[6];
                if (pTemp->pParm)
                {

                    if (hRCDll)
                    {           
                        LoadString(hRCDll, IDS_WMI_USER_NAME, wUser, 100);
                        LoadString(hRCDll, IDS_WMI_PASSWORD, wPwd, 100);
                        LoadString(hRCDll, IDS_WMI_DATABASE, wDB, 100);
                        LoadString(hRCDll, IDS_WMI_LOCALE, wLocale, 100);
                        LoadString(hRCDll, IDS_WMI_READMODE, wMode, 100);
                        FreeLibrary(hRCDll);
                    }
                    else
                    {
                        wcscpy(wDB, L"Database");
                        wcscpy(wUser, L"UserID");
                        wcscpy(wPwd, L"Password");
                        wcscpy(wLocale, L"Locale");
                        wcscpy(wMode, L"Access Mode");
                    }

                    pTemp->pParm[0].dwId = DBPROP_INIT_MODE;
                    pTemp->pParm[0].strParmDisplayName = SysAllocString(wMode);
                    VariantInit(&(pTemp->pParm[0].Value));
                    pTemp->pParm[0].Value.vt = VT_I4;
                    pTemp->pParm[0].Value.lVal = DB_MODE_READWRITE ;

                    pTemp->pParm[1].dwId = DBPROP_AUTH_USERID;
                    pTemp->pParm[1].strParmDisplayName = SysAllocString(wUser);
                    VariantInit(&(pTemp->pParm[1].Value));

                    pTemp->pParm[2].dwId = DBPROP_AUTH_PASSWORD;
                    pTemp->pParm[2].strParmDisplayName = SysAllocString(wPwd);
                    VariantInit(&(pTemp->pParm[2].Value));

                    pTemp->pParm[3].dwId = DBPROP_INIT_DATASOURCE;
                    pTemp->pParm[3].strParmDisplayName = SysAllocString(wDB);
                    VariantInit(&(pTemp->pParm[3].Value));
           
                    pTemp->pParm[4].dwId = DBPROP_INIT_LCID;
                    pTemp->pParm[4].strParmDisplayName = SysAllocString(wLocale);
                    VariantInit(&(pTemp->pParm[4].Value));
                    pTemp->pParm[4].Value.lVal = lLocale;
                    pTemp->pParm[4].Value.vt = VT_I4;
                         
                    *ppTemplate = pTemp;
                }
                else
                {
                    delete pTemp;
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }          
            else
                hr = WBEM_E_OUT_OF_MEMORY;
            
        }
        else
            hr = WBEM_E_INVALID_PARAMETER;
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::GetLogonTemplate\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  GetPath
//
//***************************************************************************

LPWSTR GetPath (LPCWSTR lpDatabaseName)
{
    wchar_t *pPath = NULL;
    if (lpDatabaseName && wcslen(lpDatabaseName))
    {
        pPath = new wchar_t [(wcslen(lpDatabaseName))+1];
        if (pPath)
        {
            BOOL bDone = FALSE;
            wchar_t *Temp = new wchar_t [wcslen(lpDatabaseName)+1];
            if (Temp)
            {
                CDeleteMe <wchar_t> d2 (Temp);
                wcscpy(Temp, lpDatabaseName);

                wchar_t *pTemp = wcsstr(Temp, L"\\");

                while (!bDone)
                {
                    pTemp++;
                    wchar_t *pTemp2 = wcsstr(pTemp, L"\\");
                    if (!pTemp2)
                    {
                        bDone = TRUE;
                        int iLen = (pTemp - Temp);
                        wcsncpy(pPath, Temp, iLen);
                        pPath[iLen] = L'\0';
                        break;
                    }
                    else
                        pTemp = pTemp2;
                }
            }
        }
    }
    return pPath;

}

//***************************************************************************
//
//  DeleteDatabase
//
//***************************************************************************

HRESULT DeleteDatabase(LPCWSTR lpDatabaseName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Enumerate all files in the directory
    // and delete them all
    // Also check if there are any conflictingly-named
    // subdirectories.

    ERRORTRACE((LOG_WBEMCORE, "Database %sis out-of-date.  Deleting...\n", lpDatabaseName));

    if (!DeleteFile(lpDatabaseName))
    {
        DWORD err = GetLastError();
        RemoveDirectory(lpDatabaseName);
    }
        
    LPWSTR lpPath = GetPath(lpDatabaseName);
    if (lpPath)
    {
        wchar_t *pTemp = new wchar_t [wcslen(lpDatabaseName) + 50];
        CDeleteMe <wchar_t> d2 (pTemp);
        if (pTemp)
        {
            swprintf(pTemp, L"%sedb.log", lpPath);
            if (!DeleteFile(pTemp))
                RemoveDirectory(pTemp);

            swprintf(pTemp, L"%sedb.chk", lpPath);
            if (!DeleteFile(pTemp))
                RemoveDirectory(pTemp);

            swprintf(pTemp, L"%sres1.log", lpPath);
            if (!DeleteFile(pTemp))
                RemoveDirectory(pTemp);

            swprintf(pTemp, L"%sres2.log", lpPath);
            if (!DeleteFile(pTemp))
                RemoveDirectory(pTemp);

            swprintf(pTemp, L"%stmp.edb", lpPath);
            if (!DeleteFile(pTemp))
                RemoveDirectory(pTemp);

            swprintf(pTemp, L"%s*.log", lpPath);
            
            _bstr_ts names;
            WIN32_FIND_DATA fd;
            HANDLE hFile = FindFirstFile(pTemp, &fd);
            while (TRUE)
            {
                if (wcscmp(fd.cFileName, L".") &&
                    wcscmp(fd.cFileName, L".."))
                {
                    swprintf(pTemp, L"%s%s", lpPath, fd.cFileName);
                    names.push_back(pTemp);
                }
            
                if (!FindNextFile(hFile, &fd))
                    break;
            }        

            for (int i = 0; i < names.size(); i++)
            {
                if (!DeleteFile(names.at(i)))
                    RemoveDirectory(names.at(i));
            }
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
        hr = WBEM_E_FAILED;

    return hr;
}

BOOL CheckVersion (JET_SESID sesid, JET_DBID dbid, int iVersion)
{
    BOOL bDelete = FALSE;
    JET_ERR err;
    JET_TABLEID tableid;
    JET_COLUMNID id;
    DWORD dwCurrVer = 0;

    err = JetOpenTable (sesid, dbid, "DBVersion", NULL, 0, JET_bitTableUpdatable, &tableid);
    if (err >= JET_errSuccess)
    {
        JET_COLUMNDEF columnDef;
        err = JetGetColumnInfo(sesid, dbid, "DBVersion", "Version",
            &columnDef, sizeof(JET_COLUMNDEF), 0);

        if (err < JET_errSuccess)
        {
            columnDef.cp = 1200;    // Unicode?  Otherwise, its 1252.
            columnDef.wCountry = 1;
            columnDef.langid = 1033;  
            columnDef.wCollate = 0;
            columnDef.cbStruct = sizeof(JET_COLUMNDEF);

            columnDef.columnid = 1;
            columnDef.coltyp = JET_coltypLong;
            columnDef.grbit = 0 ;
            columnDef.cbMax = 0;
            err = JetAddColumn(sesid, tableid, "Version", &columnDef, "", 0, &id);
        }
        else
            id = columnDef.columnid;

        ULONG lLen;
        err = JetMove(sesid, tableid, JET_MoveFirst, 0);
        err = JetRetrieveColumn(sesid, tableid, id, 
                    &dwCurrVer, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
        if (JET_errSuccess == err && lLen != 0)
        {
            if (iVersion != dwCurrVer)
                bDelete = TRUE;
        } 
        JetCloseTable(sesid, tableid);
    }
    else
    {
        // Do any other tables exist?
        err = JetOpenTable(sesid, dbid, "ClassMap", NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err == JET_errSuccess)
        {
            bDelete = TRUE;
            JetCloseTable(sesid, tableid);
        }
    }

    return bDelete;
}

//***************************************************************************
//
//  AttachESEDatabase
//
//***************************************************************************

HRESULT AttachESEDatabase(DBPROPSET *pTemplate, CSQLConnection *pConn, BOOL bCheckVer = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
       
    CESEConnection *pConn2 = (CESEConnection *)pConn;

    JET_SESID sesid = pConn2->GetSessionID();
    JET_ERR err = JET_errSuccess;
    JET_DBID dbid;
    CLASSMAP cm;
    char *pDB = GetAnsiString(pTemplate->rgProperties[4].vValue.bstrVal);
    if (!pDB)
        hr = WBEM_E_OUT_OF_MEMORY;
    IWbemClassObject *pTest = NULL;
    CDeleteMe <char> d (pDB);

    if (SUCCEEDED(hr))
    {
        LPWSTR lpDatabase = pTemplate->rgProperties[4].vValue.bstrVal;
        err = JetAttachDatabase( sesid, pDB, 0 ) ;
        if (err < JET_errSuccess)
        {
            if (err == JET_errDatabaseCorrupted)
            {
                // DeleteDatabase(lpDatabase);
                hr = CSQLExecute::GetWMIError(err);
                return hr;
            }
            
            err = JetCreateDatabase(sesid, pDB, NULL, &dbid, 0);
            if (err == JET_errSuccess)
            {
                pConn2->SetDBID(dbid);
            }
            else
            {
                hr = CSQLExecute::GetWMIError(err);
                return hr;
            }
        }
        else
        {
            err = JetOpenDatabase (sesid, pDB, NULL, &dbid, 0); 
            if (err == JET_errSuccess)
            {
                if (bCheckVer)
                {
                    BOOL bDelete = CheckVersion(sesid, dbid, CURRENT_DB_VERSION);

                    // Ensure that this database is the proper version
                    JET_TABLEID tableid;

                    err = JetOpenTable (sesid, dbid, "ClassMap", NULL, 0, JET_bitTableUpdatable, &tableid);
                    if (err == JET_errSuccess)
                    {
                        JET_COLUMNDEF columnDef;

                        // If the table exists but the column doesn't, this is
                        // an old beta version, and we need to delete it and
                        // start over.

                        err = JetGetColumnInfo(sesid, dbid, "ClassMap", "ClassBlob",
                            &columnDef, sizeof(JET_COLUMNDEF), 0);
                        if (err != JET_errSuccess)
                            bDelete = TRUE;
                        JetCloseTable(sesid, tableid);
                    }
                    if (bDelete)
                    {
                        err = JetCloseDatabase(sesid, dbid, 0);
                        err = JetEndSession(sesid, 0);
                        err = JetTerm2(gJetInst, JET_bitTermComplete);
                        hr = DeleteDatabase(lpDatabase);                        
                        return WBEM_E_DATABASE_VER_MISMATCH;
                    }
                }
                pConn2->SetDBID(dbid);
            }
            else
            {
                hr = CSQLExecute::GetWMIError(err);
                return hr;
            }
        }

        // Initialize our data.

        DWORD dwPos;
        LPWSTR lpTableName = NULL;
        
        // Create the tables.

        err = JetBeginTransaction(sesid);

        if (FAILED(hr = UpdateDBVersion(pConn, CURRENT_DB_VERSION)) ||
            FAILED(hr = SetupObjectMapAccessor(pConn)) ||
            FAILED(hr = SetupClassMapAccessor(pConn)) ||
            FAILED(hr = SetupPropertyMapAccessor(pConn)) ||
            FAILED(hr = SetupClassDataAccessor(pConn)) ||
            FAILED(hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_STRING, dwPos, &lpTableName))||
            FAILED(hr = SetupClassKeysAccessor(pConn)))
            goto Exit;

        CDeleteMe<WCHAR> dmlpTableName( lpTableName );  

        hr = GetFirst_ClassMap(pConn, 1, cm);
        if (SUCCEEDED(hr))
        {
            cm.Clear();
            goto Exit;
        }

        // Default system classes.

        if (FAILED(hr = InsertObjectMap(pConn, 1, L"meta_class", 3, L"meta_class", 0, 0, 0, 0, TRUE)) ||
            FAILED(hr = InsertObjectMap(pConn, 2372429868687864876, L"__Namespace", 3, L"__Namespace", 0, 0, 0, 1, TRUE)) ||
            FAILED(hr = InsertObjectMap(pConn, -1411745643584611171, L"root", 3, L"root", 0, 0, 0, 2372429868687864876, TRUE)) ||
            FAILED(hr = InsertObjectMap(pConn, 3373910491091605771, L"__Instances", 3, L"__Instances", 0, 0, 0, 1, TRUE)) ||
            FAILED(hr = InsertScopeMap_Internal(pConn, -1411745643584611171, L"root", 0)) ||
            FAILED(hr = InsertObjectMap(pConn, -7316356768687527881, L"__Container_Association", 3, L"__Container_Association", 0, 0, 0, 1, TRUE)) ||
            FAILED(hr = InsertClassMap(pConn, 1, L"meta_class", 0, 1, NULL, 0, TRUE)))
            goto Exit;

        // Repository-specific system classes

        if (FAILED(GetFirst_ClassMap(pConn, 2372429868687864876, cm)))
        {
            _IWmiObject *pObj = NULL;
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                    IID__IWmiObject, (void **)&pObj);
            CReleaseMe r (pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.bstrVal = SysAllocString(L"__Namespace");
                vTemp.vt = VT_BSTR;

                pObj->Put(L"__Class", 0, &vTemp, CIM_STRING);
                VariantClear(&vTemp);
                pObj->Put(L"Name", 0, NULL, CIM_STRING);
                IWbemQualifierSet *pQS = NULL;

                hr = pObj->GetPropertyQualifierSet(L"Name", &pQS);
                if (SUCCEEDED(hr))
                {
                    vTemp.boolVal = 1;
                    vTemp.vt = VT_BOOL;
                    pQS->Put(L"key", &vTemp, 0);
                    pQS->Release();
                    VariantClear(&vTemp);
                }

                BYTE buff[128];
                DWORD dwLen = 0;
                hr = pObj->Unmerge(0, 128, &dwLen, &buff);

                if (dwLen > 0)
                {
                    BYTE *pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> r2 (pBuff);
                        DWORD dwLen1;
                        hr = pObj->Unmerge(0, dwLen, &dwLen1, pBuff);
                        if (SUCCEEDED(hr))
                        {
                            hr = InsertClassMap(pConn, 2372429868687864876, L"__Namespace", 1, 2372429868687864876, pBuff, dwLen, TRUE);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

            if (FAILED(hr))
                goto Exit;
        }
        cm.Clear();

        if (FAILED(GetFirst_ClassMap(pConn, 3373910491091605771, cm)))
        {
            _IWmiObject *pObj = NULL;
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                    IID__IWmiObject, (void **)&pObj);
            CReleaseMe r (pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.bstrVal = SysAllocString(L"__Instances");
                vTemp.vt = VT_BSTR;

                pObj->Put(L"__Class", 0, &vTemp, CIM_STRING);
                VariantClear(&vTemp);
                pObj->Put(L"ClassName", 0, NULL, CIM_STRING);
                IWbemQualifierSet *pQS = NULL;

                hr = pObj->GetPropertyQualifierSet(L"ClassName", &pQS);
                if (SUCCEEDED(hr))
                {
                    vTemp.boolVal = 1;
                    vTemp.vt = VT_BOOL;
                    pQS->Put(L"key", &vTemp, 0);
                    pQS->Release();
                    VariantClear(&vTemp);
                }

                BYTE buff[128];
                DWORD dwLen = 0;

                hr = pObj->Unmerge(0, 128, &dwLen, &buff);

                if (dwLen > 0)
                {
                    BYTE *pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> r2 (pBuff);
                        DWORD dwLen1;
                        hr = pObj->Unmerge(0, dwLen, &dwLen1, pBuff);
                        if (SUCCEEDED(hr))
                        {
                            hr = InsertClassMap(pConn, 3373910491091605771, L"__Instances", 1, 3373910491091605771, pBuff, dwLen, TRUE);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                }
            }

            if (FAILED(hr))
                goto Exit;
        }
        cm.Clear();

        if (FAILED(GetFirst_ClassMap(pConn, -7316356768687527881, cm)))
        {
            _IWmiObject *pObj = NULL;
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                    IID__IWmiObject, (void **)&pObj);
            CReleaseMe r (pObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.bstrVal = SysAllocString(L"__Container_Association");
                vTemp.vt = VT_BSTR;

                pObj->Put(L"__Class", 0, &vTemp, CIM_STRING);
                VariantClear(&vTemp);
                pObj->Put(L"Containee", 0, NULL, CIM_REFERENCE);
                pObj->Put(L"Container", 0, NULL, CIM_REFERENCE);

                IWbemQualifierSet *pQS = NULL;
                hr = pObj->GetPropertyQualifierSet(L"Containee", &pQS);
                if (SUCCEEDED(hr))
                {
                    vTemp.boolVal = 1;
                    vTemp.vt = VT_BOOL;
                    pQS->Put(L"key", &vTemp, 0);
                    pQS->Release();
                    VariantClear(&vTemp);
                }
                hr = pObj->GetPropertyQualifierSet(L"Container", &pQS);
                if (SUCCEEDED(hr))
                {
                    vTemp.boolVal = 1;
                    vTemp.vt = VT_BOOL;
                    pQS->Put(L"key", &vTemp, 0);
                    pQS->Release();
                    VariantClear(&vTemp);
                }

                BYTE buff[128];
                DWORD dwLen = 0;

                hr = pObj->Unmerge(0, 128, &dwLen, &buff);

                if (dwLen > 0)
                {
                    BYTE *pBuff;
                    pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> r2 (pBuff);
                        DWORD dwLen1;
                        hr = pObj->Unmerge(0, dwLen, &dwLen1, pBuff);
                        if (SUCCEEDED(hr))
                        {
                            hr = InsertClassMap(pConn, -7316356768687527881, L"__Container_Association", 1, -7316356768687527881, pBuff, dwLen, TRUE);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                }                    
            }

            if (FAILED(hr))
                goto Exit;
        }
        cm.Clear();

        // Properties for default classes

        DWORD iWaste = 0, dwPropID = 0;

        if (FAILED(hr = InsertPropertyMap(pConn, dwPropID, 2372429868687864876, 1, 8, L"Name", 4, TRUE)) ||
            FAILED(hr = InsertClassKeys(pConn, 2372429868687864876, dwPropID)) ||
            FAILED(hr = InsertPropertyMap(pConn, iWaste, 3373910491091605771, 1, 8, L"ClassName", 4, TRUE)) ||
            FAILED(hr = InsertClassKeys(pConn, 3373910491091605771, iWaste)) ||
            FAILED(hr = InsertPropertyMap(pConn, iWaste, -7316356768687527881, 4, 102, L"Containee", 4, TRUE)) ||
            FAILED(hr = InsertClassKeys(pConn, -7316356768687527881, iWaste)) ||
            FAILED(hr = InsertPropertyMap(pConn, iWaste, -7316356768687527881, 4, 102, L"Container", 4, TRUE)) ||
            FAILED(hr = InsertClassKeys(pConn, -7316356768687527881, iWaste)) ||
            FAILED(hr = InsertClassData_Internal(pConn, -1411745643584611171, dwPropID, 0, 0, 2372429868687864876,
                L"root", 0, 0, 4, 0, 0, FALSE)) ||
            FAILED(hr = InsertIndexData (pConn, -1411745643584611171, dwPropID, 0, L"root", 0, 0, 1)))
            goto Exit;

        // System properties.  Including them in the schema makes them queriable.

        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemClassObject, (void **)&pTest);
        if (SUCCEEDED(hr))
        {
            CReleaseMe r (pTest);
            BSTR strName;
            CIMTYPE cimtype;
            
            hr = pTest->BeginEnumeration(0);
            while (pTest->Next(0, &strName, NULL, &cimtype, NULL) == S_OK)
            {
                DWORD dwStorageType = 0;
                CFreeMe f1 (strName);
                DWORD dwFlags = REPDRVR_FLAG_SYSTEM;

                CIMTYPE ct = cimtype & 0xFFF;
                bool bArray = (cimtype & CIM_FLAG_ARRAY)? true: false;

                if (bArray)
                    dwFlags |= REPDRVR_FLAG_ARRAY;

                if (!_wcsicmp(strName, L"__Path") ||
                    !_wcsicmp(strName, L"__RelPath") ||
                    !_wcsicmp(strName, L"__Class") ||
                    !_wcsicmp(strName, L"__SuperClass") ||
                    !_wcsicmp(strName, L"__Dynasty") ||
                    !_wcsicmp(strName, L"__Derivation") ||
                    !_wcsicmp(strName, L"__Version") ||
                    !_wcsicmp(strName, L"__Genus") ||
                    !_wcsicmp(strName, L"__Property_Count") ||
                    !_wcsicmp(strName, L"__Server") ||
                    !_wcsicmp(strName, L"__Namespace"))
                    dwStorageType = WMIDB_STORAGE_COMPACT;
                else
                    dwStorageType = GetStorageType(ct, bArray);

                if (FAILED(hr = InsertPropertyMap(pConn, iWaste, 1, dwStorageType, ct, strName, dwFlags, TRUE)))
                    goto Exit;
            }
        }
        hr = WBEM_S_NO_ERROR;
    }
Exit:
    if (SUCCEEDED(hr))
    {
        hr = CSQLExecute::GetWMIError(err);
        JetCommitTransaction(sesid, 0);
    }
    else
        JetRollback(sesid, 0);

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::FinalRollback
//
//***************************************************************************

HRESULT CSQLConnCache::FinalRollback(CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Rollback this transaction and set Thread ID to zero

    CESEConnection *pConn2 = (CESEConnection *)pConn;
    CWmiESETransaction *pTrans = pConn2->m_pTrans;                        
    if (pTrans)
    {
        hr = pTrans->Abort();                        
        delete pTrans;
    }

    pConn2->m_pTrans = NULL;
    pConn2->m_bInUse = false;
    pConn2->m_tCreateTime = time(0); // We don't want to delete it immediately.

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::FinalCommit
//
//***************************************************************************

HRESULT CSQLConnCache::FinalCommit(CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Commit this transaction and erase the ThreadID
    // from this connection.

    CESEConnection *pConn2 = (CESEConnection *)pConn;
    CWmiESETransaction *pTrans = pConn2->m_pTrans;                        

    if (pTrans)
        hr = pTrans->Commit();  
    
    pConn2->m_tCreateTime = time(0); // We don't want to delete it immediately.
    delete pTrans;
	pConn2->m_pTrans = NULL;                    

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::ReleaseConnection
//
//***************************************************************************
HRESULT CSQLConnCache::ReleaseConnection(CSQLConnection *_pConn, 
                                         HRESULT retcode, BOOL bDistributed)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwNumFreed = 0;

    // If we're shutting down, the connection will be released anyway.

    if (m_dwStatus == WBEM_E_SHUTTING_DOWN)
    {
        hr = FinalRollback(_pConn);
        ((CESEConnection *)_pConn)->m_bInUse = false;
        return WBEM_E_SHUTTING_DOWN;  
    }

    CRepdrvrCritSec r (&m_cs);

    for (int i = m_Conns.size() -1; i >=0; i--)
    {
        CSQLConnection *pConn = m_Conns.at(i);
        if (pConn)
        {
            CESEConnection *pConn2 = (CESEConnection *)pConn;
            if (_pConn == pConn)
            {                       
                if (FAILED(retcode))
                {
                    // If this is a distributed transaction,
                    // they decide on the final commit.

                    if (!bDistributed)
                    {
                        hr = FinalRollback(pConn);

                        if (retcode == WBEM_E_CRITICAL_ERROR ||
                            retcode == WBEM_E_INVALID_QUERY ||
                            retcode == WBEM_E_OUT_OF_MEMORY)
                        {
                            delete pConn2;  // This deletes the transaction.
		                    pConn2 = NULL;

                            m_Conns.erase(&m_Conns.at(i));
                            DEBUGTRACE((LOG_WBEMCORE, "THREAD %ld deleted ESE connection %X.  Number of connections = %ld\n", 
                                GetCurrentThreadId(), pConn, m_Conns.size()));
                        }
                    }
                }
                else
                {   
                    // If this is a distributed transaction,
                    // they decide on the final commit.

                    if (!bDistributed)
                        hr = FinalCommit(pConn);                                                
                }                   
            
                if (pConn2)
                    pConn2->m_bInUse = false;
                dwNumFreed++;
                break;
            }
        }
    }

    // Notify waiting threads that there is 
    // an open connection.
    // =====================================

    {
        CRepdrvrCritSec r (&m_cs);
        for (int i = 0; i < m_WaitQueue.size(); i++)
        {
            if (i >= dwNumFreed)
                break;

            HANDLE hTemp = m_WaitQueue.at(i);
            SetEvent(hTemp);

            DEBUGTRACE((LOG_WBEMCORE, "Thread %ld released a connection...\n", GetCurrentThreadId()));
        }
    }
    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::Shutdown
//
//***************************************************************************

HRESULT CSQLConnCache::Shutdown()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    JET_ERR err = 0;
    time_t tStart = time(0), tEnd = time(0) + 5;
    m_dwStatus = WBEM_E_SHUTTING_DOWN;

    if (m_bInit)
    {
        CRepdrvrCritSec r (&m_cs);

        int iConnectionsLeftOpen = m_Conns.size();
        while (iConnectionsLeftOpen)
        {
            {
                CRepdrvrCritSec r (&m_cs);                
                iConnectionsLeftOpen = 0;

                for (int i = m_Conns.size()-1; i >= 0; i--)
                {
                    // Give threads up to 5 seconds to shut down.

                    if (((CESEConnection *)m_Conns.at(i))->m_bInUse)
                        iConnectionsLeftOpen++;
                    else if (!((CESEConnection *)m_Conns.at(i))->m_bInUse)
                    {
                        delete m_Conns.at(i);
                        m_Conns.erase(&m_Conns.at(i));
                    }
                }
            }

            if (!iConnectionsLeftOpen)
                break;
            else
            {
                if (tEnd >= tStart)
                {
                    Sleep(100); // Check every 50 ms.
                    tStart = time(0);
                }
                else
                    break;
            }
        }

        if (iConnectionsLeftOpen)
        {
            CRepdrvrCritSec r (&m_cs);
            for (int i = m_Conns.size()-1; i >= 0; i--)
            {
                // Give threads up to 5 seconds to shut down.

                if (((CESEConnection *)m_Conns.at(i))->m_bInUse)
                {
                    CESEConnection *pConn2 = (CESEConnection *)m_Conns.at(i);
                    if (pConn2)
                    {           
                        DEBUGTRACE((LOG_WBEMCORE, 
                            "CONNECTION: #%ld \n"
                            "  In Use = %ld\n"
                            "  Creation time = %ld\n"
                            "  Thread ID = %ld\n",
                            i,
                            ((CESEConnection *)pConn2)->m_bInUse,
                            ((CESEConnection *)pConn2)->m_tCreateTime,
                            ((CESEConnection *)pConn2)->m_dwThreadId));
                    }
                }
            }
            m_Conns.clear();
        }
        
        DEBUGTRACE((LOG_WBEMCORE, "Database shutting down in response to a Shutdown command.\n"));
        if (iConnectionsLeftOpen)
            ERRORTRACE((LOG_WBEMCORE, "%ld connections left open.  All threads did not release their connections!\n",
                        iConnectionsLeftOpen));

        // _ASSERT(iConnectionsLeftOpen == 0, "Shutdown was unable to close all db connections.");

        err = JetTerm2(gJetInst, JET_bitTermComplete);
        if (err >= JET_errSuccess)
        {
            gJetInst = NULL;
            m_bInit = FALSE;
        }
        hr = CSQLExecute::GetWMIError(err);
    }

    return hr;
}

//***************************************************************************
//
//  Startup
//
//***************************************************************************

HRESULT Startup(CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = CleanAutoDeletes(pConn);

    return hr;

}

//***************************************************************************
//
//  CSQLConnCache::DeleteUnusedConnections
//
//***************************************************************************

HRESULT CSQLConnCache::DeleteUnusedConnections(BOOL bDeadOnly)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwThreadId = GetCurrentThreadId();

    CRepdrvrCritSec r (&m_cs);

    for (int i = m_Conns.size()-1; i >= 0; i--)
    {
        CESEConnection *pConn = (CESEConnection *)m_Conns.at(i);
        if (pConn)
        {           
            if (!pConn->m_bInUse)
            {                    
                BOOL bDelete = FALSE;
                if (bDeadOnly)
                {
                    if (dwThreadId != pConn->m_dwThreadId)
                    {
                        HANDLE hTemp = OpenThread(STANDARD_RIGHTS_REQUIRED, FALSE, pConn->m_dwThreadId);
                        if (hTemp)
                        {
                            CloseHandle(hTemp);
                            time_t tNow = time(0);
                            if ((tNow - pConn->m_tCreateTime) > 60)
                                bDelete = TRUE;
                        }
                        else
                            bDelete = TRUE;
                    }
                }
                else
                    bDelete = TRUE;

                if (bDelete)
                {
                    delete pConn;  // This deletes the transaction, which should be NULL.
		            pConn = NULL;
                    m_Conns.erase(&m_Conns.at(i));

                    hr = WBEM_S_NO_ERROR;

                    if (!bDeadOnly)
                        break;
                }
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::GetConnection
//
//***************************************************************************
HRESULT CSQLConnCache::GetConnection(CSQLConnection **ppConn, BOOL bTransacted, BOOL bDistributed,
                                     DWORD dwTimeOutSecs)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bFound = false;
    JET_ERR err =  0;   
    BOOL bStartUp = FALSE;
    DWORD dwThreadId = GetCurrentThreadId();    

    if (!ppConn)
        return WBEM_E_INVALID_PARAMETER;

    if (m_dwStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (m_WaitQueue.size() && dwTimeOutSecs > 0)
        goto Queue;

    // Look for any connection that belongs
    // to a thread that has gone bye-bye
    // and kill it.
    // ===================================

    {
        CRepdrvrCritSec r (&m_cs);
        DeleteUnusedConnections(TRUE);

        // See if there are any free connections.
        // ======================================

        if (m_Conns.size() > 0)
        {
            for (int i = 0; i < m_Conns.size(); i++)
            {
                CESEConnection *pConn = (CESEConnection *)m_Conns.at(i);
                if (pConn)
                {
                    time_t tTemp = time(0);
            
                    if (!pConn->m_bInUse)
                    {
                        // We need
                        // to reuse the same connection,
                        // since Jet is apartment-model
                        // ============================

                        if (dwThreadId == pConn->m_dwThreadId)
                        {
                            pConn->m_bInUse = true;
                            pConn->m_tCreateTime = time(0);
                            *ppConn = pConn;
                            bFound = true;
                            break;
                        }
                    }
                }
            }

        }

        // If there were no free connections, try and obtain a new one.
        // ============================================================
        {
            if (!bFound && (m_Conns.size() < m_dwMaxNumConns))
            {              
                if (!m_bInit)
                {
                    // Get a new JET_INSTANCE from the parameters
                    // in m_pPropSet
                    // m_sDatabaseName = database name
                    // m_pPropSet[1].bstrVal = user name
                    // m_pPropSet[2].bstrVal = password

                    LPWSTR lpPath = GetPath(m_sDatabaseName);
                    if (lpPath)
                    {
                        CDeleteMe <wchar_t> d (lpPath);
                        char * pPath2 = GetAnsiString(lpPath);
                        if (!pPath2)
                            return WBEM_E_OUT_OF_MEMORY;

                        CDeleteMe <char> d3 (pPath2);
                        if (pPath2)
                        {
                            DWORD dwVal = 1024;

                            if ((err = JetSetSystemParameter (&gJetInst, 0, JET_paramMaxSessions, 25, NULL)) != JET_errSuccess ||
                                (err = JetSetSystemParameter (&gJetInst, 0, JET_paramCacheSizeMin, 100, NULL)) != JET_errSuccess ||
                                (err = JetSetSystemParameter (&gJetInst, 0, JET_paramCacheSizeMax, 1024, NULL)) != JET_errSuccess ||
                                (err = JetSetSystemParameter (&gJetInst, 0, JET_paramEventLogCache, 65536, NULL)) != JET_errSuccess ||
                                (err = JetSetSystemParameter (&gJetInst, 0, JET_paramCircularLog, TRUE, NULL)) != JET_errSuccess ||
                                (err = JetSetSystemParameter( &gJetInst, 0, JET_paramSystemPath, 0, pPath2)) != JET_errSuccess ||
                                (err = JetSetSystemParameter( &gJetInst, 0, JET_paramTempPath, 0, pPath2)) != JET_errSuccess ||
                                (err = JetSetSystemParameter( &gJetInst, 0, JET_paramLogFilePath, 0, pPath2)) != JET_errSuccess ||
                                (err = JetSetSystemParameter( &gJetInst, 0, JET_paramMaxVerPages, dwVal, NULL)) != JET_errSuccess)
                            {
                                hr = CSQLExecute::GetWMIError(err);
                            }
                            else
                            {
                                err = JetInit(&gJetInst);
                                //if (err < JET_errSuccess)
                               // {
                               //     hr = DeleteDatabase(m_sDatabaseName);
                               //     if (SUCCEEDED(hr))
                               //         err = JetInit(&gJetInst);
                               // }

                                if (err == JET_errSuccess)
                                {
                                    m_bInit = TRUE;
                                    bStartUp = TRUE;
                                }
                                else
                                    hr = CSQLExecute::GetWMIError(err);                            
                            }
                        }                    
                    }
                    else
                        hr = WBEM_E_INVALID_PARAMETER;            
                }

                // If that worked, get a new session,
                // and attach the current DB.

                if (SUCCEEDED(hr))
                {
                    char *pUser = GetAnsiString(m_pPropSet->rgProperties[2].vValue.bstrVal);
                    char *pPwd = GetAnsiString(m_pPropSet->rgProperties[3].vValue.bstrVal);
                    CDeleteMe <char> d3 (pUser), d4 (pPwd);

                    if (!pUser || !pPwd)
                        return WBEM_E_OUT_OF_MEMORY;
            
                    JET_SESID session;
                    err = JetBeginSession(gJetInst, &session, pUser, pPwd);
                    if (err == JET_errSuccess)
                    {
                        CSQLConnection *pConn = (CSQLConnection *)new CESEConnection(session);
                        if (pConn)
                        {
                            hr = AttachESEDatabase(m_pPropSet, pConn, bStartUp);
                            if (FAILED(hr) && hr == WBEM_E_DATABASE_VER_MISMATCH)
                            {
                                if ((JetInit(&gJetInst) != JET_errSuccess) ||
                                   (JetBeginSession(gJetInst, &session, pUser, pPwd) != JET_errSuccess) ||
                                   !((CESEConnection *)pConn)->SetSessionID(session) ||
                                   (FAILED(hr = AttachESEDatabase(m_pPropSet, pConn, bStartUp))))
                                    hr = WBEM_E_DATABASE_VER_MISMATCH;
                            }
                            if (SUCCEEDED(hr) && bStartUp)
                                hr = Startup(pConn);

                            if (SUCCEEDED(hr))
                            {
                                ((CESEConnection *)pConn)->m_bInUse = true;
                                ((CESEConnection *)pConn)->m_tCreateTime = time(0);
                                ((CESEConnection *)pConn)->m_dwThreadId = dwThreadId;

                                m_Conns.push_back(pConn);
                                DEBUGTRACE((LOG_WBEMCORE, "THREAD %ld obtained new ESE connection %X, session %X. Number of connections = %ld\n", 
                                    dwThreadId, pConn, &session, m_Conns.size()));
    #ifdef _DEBUG_CONNS
                                for (int i = 0; i < m_Conns.size()-1; i++)
                                {
                                    CESEConnection *pConn2 = (CESEConnection *)m_Conns.at(i);
                                    if (pConn)
                                    {           
                                        DEBUGTRACE((LOG_WBEMCORE, 
                                            "CONNECTION: #%ld \n"
                                            "  In Use = %ld\n"
                                            "  Creation time = %ld\n"
                                            "  Thread ID = %ld\n",
                                            i,
                                            ((CESEConnection *)pConn2)->m_bInUse,
                                            ((CESEConnection *)pConn2)->m_tCreateTime,
                                            ((CESEConnection *)pConn2)->m_dwThreadId));

                                    }
                                }
    #endif
                                *ppConn = pConn;
                            }                   
                            else
                                delete pConn;
                        }
                        else
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else
                    {
                        int iNumConns = m_Conns.size();
                        hr = CSQLExecute::GetWMIError(err);
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && *ppConn != NULL && (bTransacted || bDistributed))
        {
            CESEConnection *pConn = (CESEConnection *)*ppConn;        
            CWmiESETransaction *pTrans = pConn->GetTransaction();
            if (!pTrans)
            {
                pTrans = new CWmiESETransaction(((CESEConnection *)pConn)->GetSessionID());
                pConn->SetTransaction(pTrans);
            }

            if (pTrans)
                pTrans->StartTransaction();        
        }
    }

Queue:

    // Otherwise, wait for a connection to be released.
    // ================================================
    
    if (!*ppConn && (m_Conns.size() >= m_dwMaxNumConns || m_WaitQueue.size()) && dwTimeOutSecs > 0)
    {
        DEBUGTRACE((LOG_WBEMCORE, "WARNING: >> Number of ESE connections exceeded (%ld).  Thread %ld is waiting on one to be released...\n",
            m_Conns.size(), dwThreadId));
        BOOL bWait = FALSE;
        
        HANDLE hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hThreadEvent != INVALID_HANDLE_VALUE)
        {
            CRepdrvrCritSec r (&m_cs);
            // Reserve our spot in the queue so we get the very next connection.
            m_WaitQueue.push_back(hThreadEvent);

            // Check for a free connection one last time.

            hr = DeleteUnusedConnections(FALSE);
            if (SUCCEEDED(hr))
                hr = GetConnection(ppConn, bTransacted, bDistributed, 0);
            else
                bWait = TRUE;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;

        if (bWait)
        {
            if (WbemWaitForSingleObject(hThreadEvent, 30*1000) == WAIT_OBJECT_0)
            {
                hr = GetConnection(ppConn, bTransacted, bDistributed, 0);
                if (SUCCEEDED(hr))
                    DEBUGTRACE((LOG_WBEMCORE, "Thread %ld obtained a connection.\n", dwThreadId));
                else
                    DEBUGTRACE((LOG_WBEMCORE, "Thread %ld failed to obtain a connection.\n", dwThreadId));
            }
            else
                hr = WBEM_E_SERVER_TOO_BUSY;
        }
     
        // Remove ourself from the queue
        // This will happen whether the GetConnection
        // succeeded or failed
        // ==========================================

        {
            CRepdrvrCritSec r (&m_cs);
            for (int i = 0; i < m_WaitQueue.size(); i++)
            {
                if (hThreadEvent == m_WaitQueue.at(i))
                {
                    m_WaitQueue.erase(&m_WaitQueue.at(i));
                    break;
                }
            }
            CloseHandle(hThreadEvent);
        }

        CloseHandle(hThreadEvent);
    }

    if (!*ppConn && SUCCEEDED(hr))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Thread %ld was unable to obtain a connection.\n", dwThreadId));
        hr = WBEM_E_SERVER_TOO_BUSY;
    }
    
    return hr;
}

//***************************************************************************
//
//  CSQLExecute::GetWMIError
//
//***************************************************************************

HRESULT CSQLExecute::GetWMIError(long ErrorID)
{
    HRESULT hr = 0;

    switch(ErrorID)
    {
    case JET_errSuccess:
    case JET_errRecordDeleted:
        hr = WBEM_S_NO_ERROR;
        break;
    case JET_wrnNyi:
        hr = E_NOTIMPL;
        break;
    case JET_errOutOfMemory: 
    case JET_errOutOfDatabaseSpace:
    case JET_errOutOfCursors:
    case JET_errOutOfBuffers:
    case JET_errOutOfFileHandles:
    case JET_errVersionStoreOutOfMemory:
    case JET_errCurrencyStackOutOfMemory:
        hr = WBEM_E_OUT_OF_MEMORY;
        break;
    case JET_errInvalidParameter:
    case JET_errKeyTooBig:
    case JET_errInvalidGrbit:
    case JET_errInvalidName:
        hr = WBEM_E_INVALID_PARAMETER;
        break;
    case JET_errRecordNotDeleted:
    case JET_errWriteConflict:
        hr = WBEM_E_FAILED;
        break;
    case JET_errRecordNotFound:
    case JET_errDatabaseNotFound:
    case JET_errNoCurrentRecord:
    case JET_errFileNotFound:
        hr = WBEM_E_NOT_FOUND;
        break;
    case JET_errNTSystemCallFailed:
    case JET_errLogFileCorrupt:
    case JET_errDatabaseInconsistent:
    case JET_errConsistentTimeMismatch:
    case JET_errDatabasePatchFileMismatch:
    case JET_errInvalidDatabaseId:
    case JET_errDiskIO:
    case JET_errInvalidPath:
    case JET_errInvalidSystemPath:
    case JET_errInvalidLogDirectory:
    case JET_errInvalidDatabase:
    case JET_errInvalidFilename:
    case JET_errPageSizeMismatch:
        hr = WBEM_E_CRITICAL_ERROR;
        break;
    case JET_errFileAccessDenied:
    case JET_errPermissionDenied:
        hr = WBEM_E_ACCESS_DENIED;
        break;
    case JET_errOutOfSessions:
    case JET_errInvalidSesid:
        hr = WBEM_E_CONNECTION_FAILED;
        break;
    case JET_errQueryNotSupported:
    case JET_errSQLLinkNotSupported:
        hr = WBEM_E_INVALID_QUERY;
        break;
    default:
        if (ErrorID > 0)
            hr = WBEM_S_NO_ERROR;
        else
            hr = WBEM_E_INVALID_QUERY;
    }

    if (FAILED(hr) && hr != WBEM_E_NOT_FOUND)
        ERRORTRACE((LOG_WBEMCORE, "Jet returned the following error: %ld\n", ErrorID));

    return hr;
}


HRESULT SetInArray (VARIANT &vOriginal, DWORD iPos, VARIANT &vNew, CIMTYPE ct)
{
    HRESULT hr = 0;

    if (vOriginal.vt & CIM_FLAG_ARRAY)
    {
	    SAFEARRAY *pArray = V_ARRAY(&vOriginal);
        SAFEARRAYBOUND aBounds[1];
        long lLBound, lUBound;
        DWORD Comp = (DWORD)iPos+1;

        SafeArrayGetLBound(pArray, 1, &lLBound);
        SafeArrayGetUBound(pArray, 1, &lUBound);

        lUBound -= lLBound;
        lUBound += 1;

        if (Comp > lUBound)
        {
            aBounds[0].cElements = Comp;
            aBounds[0].lLbound = 0;
    
            SAFEARRAY *pNew = SafeArrayCreate(vNew.vt, 1, aBounds);  
            if (pNew)
            {
                for ( int i = 0; i < lUBound; i++ )
                {
                    long lTemp[1];
                    lTemp[0] = i;

                    if ( (ct & 0xFFF) == CIM_STRING ||
                         (ct & 0xFFF) == CIM_DATETIME || 
                         (ct & 0xFFF) == CIM_REFERENCE )
                    {
                        BSTR bstr;

                        if ( SUCCEEDED(SafeArrayGetElement( pArray, 
                                                            lTemp, 
                                                            &bstr) ) )
                        {
                            SafeArrayPutElement( pNew, lTemp, bstr );
                            SysFreeString( bstr );
                        }
                    }
                    else if ( (ct & 0xFFF) == CIM_OBJECT )
                    {

                        IUnknown* pObj;

                        if ( SUCCEEDED(SafeArrayGetElement( pArray, 
                                                            lTemp, 
                                                            &pObj) ) )
                        {
                            SafeArrayPutElement( pNew, lTemp, pObj );
                            pObj->Release();
                        }
                    }
                    else
                    {
                        double dbVal;

                        if ( SUCCEEDED(SafeArrayGetElement( pArray, 
                                                            lTemp, 
                                                            &dbVal ) ) )
                        {
                            SafeArrayPutElement( pNew, lTemp, &dbVal );
                        }
                    }
                }

                SafeArrayDestroy(pArray);
                pArray = pNew;
            }
        }

        hr = PutVariantInArray(&pArray, iPos, &vNew);
        if (SUCCEEDED(hr))
            V_ARRAY(&vOriginal) = pArray;                            
    
    }
    else
    {
        VariantClear(&vOriginal);
    
        // This is a new object.
        SAFEARRAYBOUND aBounds[1];
        aBounds[0].cElements = iPos+1;
        aBounds[0].lLbound = 0;
        SAFEARRAY* pArray = SafeArrayCreate(vNew.vt, 1, aBounds);   
        if (pArray)
        {
            hr = PutVariantInArray(&pArray, iPos, &vNew);
            vOriginal.vt = VT_ARRAY|vNew.vt;
            V_ARRAY(&vOriginal) = pArray;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }                        

    return hr;
}

//***************************************************************************
//
//  SetObjectData
//
//***************************************************************************

HRESULT SetObjectData(CSQLConnection *pConn, IWbemClassObject *pNewObj, IWmiDbSession *pSession, CSchemaCache *pSchema,
                      CLASSDATA cd, BOOL bBlobData, BOOL &bBigText, BOOL *bObject=NULL, BOOL bNoDefaults=FALSE)
{
    HRESULT hr = 0;

    _bstr_t sPropName;
    DWORD dwStorage, dwCIMType, dwPropFlags;
    VARIANT vValue;
    VariantInit(&vValue);
    vValue.vt = VT_NULL;
    wchar_t wTemp[455];
    BOOL bSkip = FALSE;
    int iLen = 0;
    SQL_ID dRefId, dClassId;

    if (bObject)
        *bObject = FALSE;
    
    dRefId = cd.dRefId;

    hr = pSchema->GetPropertyInfo (cd.iPropertyId, &sPropName, NULL, &dwStorage,
                    &dwCIMType, &dwPropFlags);

    if (SUCCEEDED(hr))
    {
        if (bNoDefaults && !(dwPropFlags & REPDRVR_FLAG_NONPROP))
            return WBEM_S_NO_ERROR;

        if (!(cd.iFlags & ESE_FLAG_NULL))
        {
            switch(dwStorage)
            {
            case WMIDB_STORAGE_REFERENCE: // Reference or object
            case WMIDB_STORAGE_STRING:
                if (bBlobData)
                {
                    if ((dwCIMType == CIM_STRING || dwCIMType == CIM_REFERENCE)
                             && cd.dwBufferLen > 0)
                    {
                        vValue.vt = VT_BSTR;
                        vValue.bstrVal = SysAllocString((LPWSTR)cd.pBuffer);
                        if (vValue.bstrVal)
                            iLen = wcslen(vValue.bstrVal);
                    }
                    else
                    {
                        vValue.vt = VT_NULL;
                        iLen = 0;
                    }
                }
                else
                {
                    if (cd.sPropertyStringValue != NULL)
                    {
                        vValue.bstrVal = SysAllocString(cd.sPropertyStringValue);
                        if (vValue.bstrVal)
                        {
                            vValue.vt = VT_BSTR;
                            iLen = wcslen(vValue.bstrVal);
                            bBigText = IsTruncated(vValue.bstrVal, 127);
                        }
                    }
                }                       

                break;
            case WMIDB_STORAGE_NUMERIC:
                // Set in one of the kajillion numeric types...
                if (dwCIMType == CIM_UINT64 || dwCIMType == CIM_SINT64)
                {
                    wchar_t wTemp[50];
                    swprintf(wTemp, L"%I64d", cd.dPropertyNumericValue);
                    vValue.bstrVal = SysAllocString(wTemp);
                    vValue.vt = VT_BSTR;
                }
                else if (dwCIMType == CIM_BOOLEAN)
                {
                    vValue.boolVal = (BOOL) cd.dPropertyNumericValue;
                    vValue.vt = VT_BOOL;
                }
                else
                {
                    vValue.lVal = (DWORD) cd.dPropertyNumericValue;
                    vValue.vt = VT_I4;
                }

                break;
            case WMIDB_STORAGE_REAL:
                // Set as 32 or 64-bit real

                if (dwCIMType == CIM_REAL32)
                {
                    vValue.fltVal = (float)cd.rPropertyRealValue;
                    vValue.vt = VT_R4;
                }
                else if (dwCIMType == CIM_REAL64)
                {
                    vValue.fltVal = (double)cd.rPropertyRealValue;
                    vValue.vt = VT_R8;
                }

                break;
            case WMIDB_STORAGE_IMAGE:
                if (dwCIMType != CIM_OBJECT)
                {
                    if (cd.dwBufferLen > 0)
                    {
                        long why[1];                        
                        unsigned char t;
                        SAFEARRAYBOUND aBounds[1];
                        aBounds[0].cElements = cd.dwBufferLen; 
                        aBounds[0].lLbound = 0;
                        SAFEARRAY* pArray = SafeArrayCreate(VT_UI1, 1, aBounds);                            
                        vValue.vt = VT_I1;
                        for (int i = 0; i < cd.dwBufferLen; i++)
                        {            
                            why[0] = i;
                            t = cd.pBuffer[i];
                            hr = SafeArrayPutElement(pArray, why, &t);                            
                        }
                        vValue.vt = VT_ARRAY|VT_UI1;
                        V_ARRAY(&vValue) = pArray;
                        dwCIMType |= CIM_FLAG_ARRAY;
                    }
                }
                else
                    vValue.vt = VT_NULL;
                break;
            default:
                hr = WBEM_E_NOT_SUPPORTED;
                break;
            }

            if (FAILED(hr))
            {
                goto Exit;
            }

            // If this is an object (not a reference), 
            // then we need to Get the object and set it in 
            // the variant.  Otherwise, the variant is simply
            // the string path to the object.
            // ===============================================

            if (dwCIMType == CIM_OBJECT)
            {
                if (bObject)
                {
                    *bObject = TRUE;
                    goto Exit;
                }
                else
                {
                    if (!bBlobData)
                    {
                        IWmiDbHandle *pHand = NULL;

                        if (vValue.vt == VT_BSTR)
                        {
                            hr = ((CWmiDbSession *)pSession)->GetObject_Internal((LPWSTR)vValue.bstrVal, (DWORD)0, 
                                (DWORD)WMIDB_HANDLE_TYPE_COOKIE, NULL, &pHand, pConn);
                            CReleaseMe r4 (pHand);
                            if (SUCCEEDED(hr))
                            {
                                IWbemClassObject *pEmbed = NULL;
                                hr = ((CWmiDbHandle *)pHand)->QueryInterface_Internal(pConn, (void **)&pEmbed);
                                if (SUCCEEDED(hr))
                                {        
                                    VariantClear(&vValue);
                                    V_UNKNOWN(&vValue) = (IUnknown *)pEmbed;
                                    vValue.vt = VT_UNKNOWN;
                                    // VariantClear will release this, right?
                                }
                            }
                        }
                    }
                    else
                    {
                        _IWmiObject *pNew = NULL;
                        hr = ConvertBlobToObject (pNewObj, cd.pBuffer, cd.dwBufferLen, &pNew);
                        if (SUCCEEDED(hr))
                        {
                            VariantClear(&vValue);
                            V_UNKNOWN(&vValue) = (IUnknown *)pNew;
                            vValue.vt = VT_UNKNOWN;
                        }
                    }
                }
            }

            // For array properties, what we actually need to do is
            // see if the property exists already.  If not, we
            // initialize the safe array and add the first element.
            // If so, we simply set the value in the existing array.
            // ======================================================

            if (dwPropFlags & REPDRVR_FLAG_ARRAY && (dwStorage != WMIDB_STORAGE_IMAGE))
            {
                dwCIMType |= CIM_FLAG_ARRAY;

                VARIANT vTemp;
                CClearMe c (&vTemp);
                long lTemp;
                CIMTYPE cimtype;
                if (SUCCEEDED(pNewObj->Get(sPropName, 0, &vTemp, &cimtype, &lTemp)))
                {
                    hr = SetInArray(vTemp, cd.iArrayPos, vValue, cimtype);
                    if (SUCCEEDED(hr))
                    {
                        hr = pNewObj->Put(sPropName, 0, &vTemp, dwCIMType);
                        bSkip = TRUE;
                    }
                }
            }              
        }

    if (!(dwPropFlags & REPDRVR_FLAG_QUALIFIER) &&
        !(dwPropFlags & REPDRVR_FLAG_IN_PARAM) && 
        !(dwPropFlags & REPDRVR_FLAG_OUT_PARAM) &&
        !bSkip)
    {
        if (wcslen(sPropName) == 127)
        {
            pNewObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
            BSTR strName = NULL;

            while (pNewObj->Next(0, &strName, NULL, NULL, NULL) == S_OK)
            {
                CFreeMe f (strName);
                if (!_wcsnicmp(strName, sPropName, 127))
                    sPropName = strName;
            }
        }
        hr = pNewObj->Put(sPropName, 0, &vValue, dwCIMType);
    }

    // If this is a qualifier on a class, get the qualifier set and set the value.
    else if (dwPropFlags & REPDRVR_FLAG_QUALIFIER )
    {                    
        if (dRefId != 0)
        {
            _bstr_t sProp2;
            DWORD dwFlags2, dwRefID;

            hr = pSchema->GetPropertyInfo (dRefId, &sProp2, NULL, NULL,
                    NULL, &dwFlags2, NULL, NULL, &dwRefID);
            if (SUCCEEDED(hr))
            {
                if (wcslen(sPropName) == 127)
                {
                    pNewObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
                    BSTR strName = NULL;

                    while (pNewObj->Next(0, &strName, NULL, NULL, NULL) == S_OK)
                    {
                        CFreeMe f (strName);
                        if (!_wcsnicmp(strName, sProp2, 127))
                            sProp2 = strName;
                    }
                }

                // This is a property qualifier.  See if its a property or a method.
                // and get all the pertinent info.

                // This is a qualifier on a method parameter.
                if (dwFlags2 & REPDRVR_FLAG_IN_PARAM || 
                    dwFlags2 & REPDRVR_FLAG_OUT_PARAM)
                {
                    IWbemClassObject *pIn = NULL;
                    IWbemClassObject *pOut = NULL;
                    IWbemQualifierSet *pQS = NULL;

                    _bstr_t sProp3;

                    hr = pSchema->GetPropertyInfo (dwRefID, &sProp3);
                    if (SUCCEEDED(hr))
                    {
                        hr = pNewObj->GetMethod(sProp3, 0, &pIn, &pOut);
                        CReleaseMe r5 (pIn), r6 (pOut);
                        if (SUCCEEDED(hr))
                        {
                            if (dwFlags2 & REPDRVR_FLAG_IN_PARAM && pIn)
                                hr = pIn->GetPropertyQualifierSet(sProp2, &pQS);
                            else if (dwFlags2 & REPDRVR_FLAG_OUT_PARAM && pOut)
                                hr = pOut->GetPropertyQualifierSet(sProp2, &pQS);

                            if (pQS)
                            {
                                CReleaseMe r7 (pQS);
                                if (!_wcsicmp(sPropName, L"id"))
                                    sPropName = L"repdrvr_id"; // Sneaky business.
                                                                // Because we can't set method parameters incrementally,
                                                                // we need to store the real position IDs as a different
                                                                // name and switch them back when we're done...

                                if (dwPropFlags & REPDRVR_FLAG_ARRAY)
                                {
                                    VARIANT vTemp;
                                    BOOL bExists = FALSE;
                                    CClearMe c (&vTemp);
                                    hr = pQS->Get(sPropName, 0, &vTemp, 0);
                                    if (vTemp.vt & CIM_FLAG_ARRAY)
                                        bExists = TRUE;
                                    hr = SetInArray(vTemp, cd.iArrayPos, vValue, dwCIMType);
                                    hr = pQS->Put(sPropName, &vTemp, cd.iFlags);
                                }
                                else
                                    hr = pQS->Put(sPropName, &vValue, cd.iFlags);
                                
                                hr = pNewObj->PutMethod(sProp3, 0, pIn, pOut);
                            }
                        }
                    }
                }
                // This is a qualifier on a method.

                else if (dwFlags2 & REPDRVR_FLAG_METHOD)
                {
                    IWbemQualifierSet *pQS = NULL;
                    hr = pNewObj->GetMethodQualifierSet(sProp2, &pQS);
                    CReleaseMe r4 (pQS);
                    if (SUCCEEDED(hr))
                    {
                        if (dwPropFlags & REPDRVR_FLAG_ARRAY)
                        {
                            VARIANT vTemp;
                            CClearMe c (&vTemp);
                            BOOL bExists = FALSE;
                            hr = pQS->Get(sPropName, 0, &vTemp, 0);
                            if (vTemp.vt & CIM_FLAG_ARRAY)
                                bExists = TRUE;
                            hr = SetInArray(vTemp, cd.iArrayPos, vValue, dwCIMType);
                            hr = pQS->Put(sPropName, &vTemp, cd.iFlags);
                        }
                        else
                            hr = pQS->Put(sPropName, &vValue, cd.iFlags);
                    }
                }
                // This is a qualifier on a property.
                else
                {
                    IWbemQualifierSet *pQS = NULL;
                    hr = pNewObj->GetPropertyQualifierSet(sProp2, &pQS);
                    CReleaseMe r4 (pQS);
                    if (SUCCEEDED(hr))
                    {
                        if (dwPropFlags & REPDRVR_FLAG_ARRAY)
                        {
                            VARIANT vTemp;
                            CClearMe c (&vTemp);
                            BOOL bExists = FALSE;
                            hr = pQS->Get(sPropName, 0, &vTemp, 0);
                            if (vTemp.vt & CIM_FLAG_ARRAY)
                                bExists = TRUE;
                            hr = SetInArray(vTemp, cd.iArrayPos, vValue, dwCIMType);                            
                            hr = pQS->Put(sPropName, &vTemp, cd.iFlags);
                        }
                        else
                            hr = pQS->Put(sPropName, &vValue, cd.iFlags);
                    }
                }
            }
        
        }
        else    // Its just a class/instance qualifier.  Set it.
        {
            IWbemQualifierSet *pQS = NULL;
            hr = pNewObj->GetQualifierSet(&pQS);
            CReleaseMe r5 (pQS);
            if (SUCCEEDED(hr))
            {
                if (dwPropFlags & REPDRVR_FLAG_ARRAY)
                {
                    VARIANT vTemp;
                    CClearMe c (&vTemp);
                    BOOL bExists = FALSE;
                    hr = pQS->Get(sPropName, 0, &vTemp, 0);
                    if (vTemp.vt & CIM_FLAG_ARRAY)
                        bExists = TRUE;
                    hr = SetInArray(vTemp, cd.iArrayPos, vValue, dwCIMType);                    
                    hr = pQS->Put(sPropName, &vTemp, cd.iFlags);
                }
                else
                    hr = pQS->Put(sPropName, &vValue, cd.iFlags);
            }
        }
        }
        else if (dwPropFlags & REPDRVR_FLAG_METHOD)
        {
            // This is a method. Skip it.
    
        }
        else if (dwPropFlags & REPDRVR_FLAG_IN_PARAM ||
            dwPropFlags & REPDRVR_FLAG_OUT_PARAM )
        {
            _bstr_t sProp2;
            IWbemClassObject *pTemp = NULL;

            hr = pSchema->GetPropertyInfo (dRefId, &sProp2);

            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pOther = NULL;

                if (dwPropFlags & REPDRVR_FLAG_IN_PARAM)
                    hr = pNewObj->GetMethod(sProp2, 0, &pTemp, &pOther);
                else
                    hr = pNewObj->GetMethod(sProp2, 0, &pOther, &pTemp);
                CReleaseMe r1 (pTemp), r2 (pOther);

                if (SUCCEEDED(hr))
                {
                    if (!pTemp)
                    {
                        hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IWbemClassObject, (void **)&pTemp);
                        VARIANT vTemp;
                        CClearMe c (&vTemp);
                        vTemp.bstrVal = SysAllocString(L"__Parameters");
                        vTemp.vt = VT_BSTR;
                        pTemp->Put(L"__Class", NULL, &vTemp, CIM_STRING);
                    }
                    pTemp->Put(sPropName, 0, &vValue, dwCIMType);

                    VARIANT vTemp;
                    CClearMe c2 (&vTemp);
                    long lNumProps = 0;
                    pTemp->Get(L"__Property_Count", NULL, &vTemp, NULL, NULL);
                    lNumProps = vTemp.lVal;
                    if (pOther)
                    {
                        VARIANT vTemp2;
                        CClearMe c2 (&vTemp2);
                        pOther->Get(L"__Property_Count", NULL, &vTemp2, NULL, NULL);
                        lNumProps+= vTemp2.lVal;                                
                    }
            
                    if (_wcsicmp(sPropName, L"ReturnValue"))
                    {
                        IWbemQualifierSet *pQS = NULL;
                        pTemp->GetPropertyQualifierSet(sPropName, &pQS);
                        CReleaseMe r5 (pQS);
                        if (pQS)
                        {
                            V_I4(&vTemp) = lNumProps - 1;
                            vTemp.vt = VT_I4;
                
                            pQS->Put(L"id", &vTemp, 0);
                        }
                    }

                    if (dwPropFlags & REPDRVR_FLAG_IN_PARAM)
                        hr = pNewObj->PutMethod(sProp2, 0, pTemp, pOther);
                    else
                        hr = pNewObj->PutMethod(sProp2, 0, pOther, pTemp);

                    hr = pSchema->SetAuxiliaryPropertyInfo(cd.iPropertyId, L"", dRefId);
                }
            }        
        }
    }

Exit:

    VariantClear(&vValue);
    return hr;
}

// structs for open rowsets.

//***************************************************************************
//
//  AddColumnToTable
//
//***************************************************************************

// Helper functions for setting up reusable accessors.

HRESULT AddColumnToTable (CESEConnection *pConn, JET_TABLEID tableid, LPSTR lpTableName, LPWSTR lpColumnName,
                          DWORD _colid, DWORD datatype, DWORD options, DWORD prec, JET_COLUMNID *colid)
                            
{
    HRESULT hr = WBEM_S_NO_ERROR;
    char *pColName = GetAnsiString(lpColumnName);

    if (!pColName)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe <char> d (pColName);
    JET_COLUMNDEF columnDef;

    JET_ERR err = JET_errSuccess;
    err = JetGetColumnInfo(pConn->GetSessionID(), pConn->GetDBID(), lpTableName, pColName,
        &columnDef, sizeof(JET_COLUMNDEF), 0);

    if (err < JET_errSuccess)
    {
        columnDef.cp = 1200;    // Unicode?  Otherwise, its 1252.
        columnDef.wCountry = 1;
        columnDef.langid = 1033;  
        columnDef.wCollate = 0;
        columnDef.cbStruct = sizeof(JET_COLUMNDEF);

        columnDef.columnid = _colid;
        columnDef.coltyp = datatype;
        columnDef.grbit = options ;
        columnDef.cbMax = prec;
        err = JetAddColumn(pConn->GetSessionID(), tableid, pColName, &columnDef, "", 0, colid);
    }
    else
        *colid = columnDef.columnid;

    hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  UpdateDBVersion
//
//***************************************************************************

HRESULT UpdateDBVersion (CSQLConnection *_pConn, DWORD iVersion)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    const LPSTR lpTbl = "DBVersion";

    JET_SESID session = pConn->GetSessionID();
    JET_DBID dbid = pConn->GetDBID();
    JET_TABLEID tableid;

    JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
    if (err < JET_errSuccess)
    {        
        CSQLExecute::GetWMIError(err);
        err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
        if (err < JET_errSuccess)
        {
            hr = CSQLExecute::GetWMIError(err);
            goto Exit;
        }
    }

    JET_COLUMNID colid;

    hr = AddColumnToTable(pConn, tableid, lpTbl, L"Version", 0, JET_coltypLong, 
        JET_bitColumnNotNULL, sizeof(DWORD), &colid);
    if (SUCCEEDED(hr))
    {
        // This is a one-row table.
        err = JetMove(session, tableid, JET_MoveFirst, 0);
        if (err >= JET_errSuccess)
            err = JetPrepareUpdate(session, tableid, JET_prepReplace);
        else
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
        if (err == JET_errSuccess)
        {
            err = JetSetColumn(session, tableid, colid, 
                            &iVersion, sizeof(DWORD), 0, NULL );
            err = JetUpdate(session, tableid, NULL, 0, NULL );
        }       
    }

    JetCloseTable(session, tableid);

    hr = CSQLExecute::GetWMIError(err);

Exit:
    return hr;
}

//***************************************************************************
//
//  SetupObjectMapAccessor
//
//***************************************************************************

HRESULT SetupObjectMapAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    const LPSTR lpTbl = "ObjectMap";

    if (!pConn->GetTableID(L"ObjectMap"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        JET_DBID dbid = pConn->GetDBID();

        JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        CSQLExecute::GetWMIError(err);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ObjectMap", tableid);

        JET_COLUMNID colid;

        // Unfortunately, they don't support a numeric type,
        // so we have to use currency.

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectId", OBJECTMAP_COL_OBJECTID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_OBJECTID, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectPath", OBJECTMAP_COL_OBJECTPATH, JET_coltypText, 
            0, MAX_STRING_WIDTH, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_OBJECTPATH, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectKey", OBJECTMAP_COL_OBJECTKEY, JET_coltypText, 
            0, MAX_STRING_WIDTH, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_OBJECTKEY, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ReferenceCount", OBJECTMAP_COL_REFERENCECOUNT, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_REFERENCECOUNT, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectState", OBJECTMAP_COL_OBJECTSTATE, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_OBJECTSTATE, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassId", OBJECTMAP_COL_CLASSID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_CLASSID, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectFlags", OBJECTMAP_COL_OBJECTFLAGS, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_OBJECTFLAGS, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectScopeId", OBJECTMAP_COL_OBJECTSCOPEID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, OBJECTMAP_COL_OBJECTSCOPEID, colid);
        else if (err != JET_errColumnDuplicate)
            goto Exit;

        err = JetCreateIndex(session, tableid, "ObjectMap_PK", JET_bitIndexPrimary | JET_bitIndexUnique,"+ObjectId\0", 11, 100);
        if (err >= JET_errSuccess || err == JET_errIndexHasPrimary)
        {
            err = JetCreateIndex(session, tableid, "ObjectScopeId_idx", JET_bitIndexDisallowNull ,"+ObjectScopeId\0", 16, 100);
            if (err >= JET_errSuccess|| err == JET_errIndexDuplicate)
            {
                err = JetCreateIndex(session, tableid, "ObjectClassId_idx", JET_bitIndexDisallowNull ,"+ClassId\0", 10, 100);
                if (err == JET_errIndexDuplicate)
                    err = JET_errSuccess;
            }
        }

        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupObjectMapAccessor(_pConn);
            }
        }

        if (err)
            hr = CSQLExecute::GetWMIError(err);
    }  

Exit:
    return hr;

}

//***************************************************************************
//
//  GetObjectMapData
//
//***************************************************************************

HRESULT GetObjectMapData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                OBJECTMAP &oj)
{
    HRESULT hr = WBEM_E_FAILED;
    oj.Clear();
    unsigned long lLen;
    wchar_t buff[1024];
    CESEConnection *pConn = (CESEConnection *)_pConn;
    oj.dObjectId = 0;

    JET_ERR err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTID), 
                &oj.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTKEY), 
                buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (lLen)
    {
        buff[lLen/2] = L'\0';
        oj.sObjectKey = SysAllocString(buff);
        if (wcslen(buff) && !oj.sObjectKey)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
    }
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTPATH), 
                buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (lLen)
    {
        buff[lLen/2] = L'\0';
        oj.sObjectPath = SysAllocString(buff);
        if (wcslen(buff) && !oj.sObjectPath)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            oj.Clear();
            goto exit;
        }
    }
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_REFERENCECOUNT), 
                &oj.iRefCount, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_CLASSID), 
                &oj.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTFLAGS), 
                &oj.iObjectFlags, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTSCOPEID), 
                &oj.dObjectScopeId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTSTATE), 
                &oj.iObjectState, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}


//***************************************************************************
//
//  OpenEnum_ObjectMap
//
//***************************************************************************

HRESULT OpenEnum_ObjectMap (CSQLConnection *_pConn, OBJECTMAP &oj)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupObjectMapAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMove(session, tableid, JET_MoveFirst, 0);
            if (err == JET_errSuccess)
                hr = GetObjectMapData(pConn, session, tableid, oj);
        }
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ObjectMap
//
//***************************************************************************

HRESULT GetFirst_ObjectMap (CSQLConnection *_pConn, SQL_ID dObjectId, OBJECTMAP &oj)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupObjectMapAccessor(pConn);    
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dObjectId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetObjectMapData(pConn, session, tableid, oj);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ObjectMapByScope
//
//***************************************************************************

HRESULT GetFirst_ObjectMapByScope (CSQLConnection *_pConn, SQL_ID dScopeId, OBJECTMAP &oj,
                                   DWORD seektype = JET_bitSeekEQ)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupObjectMapAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectScopeId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dScopeId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, seektype  );
                if (err == JET_errSuccess)
                {
                    if (seektype == JET_bitSeekEQ)
                    {
                        err = JetMakeKey(session, tableid, &dScopeId, sizeof(__int64), JET_bitNewKey);
                        if (err == JET_errSuccess)
                            err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                    }
                    else if (seektype == JET_bitSeekLT || seektype == JET_bitSeekLE  )
                    {
                        err = JetMakeKey(session, tableid, &dScopeId, sizeof(__int64), JET_bitNewKey);
                        if (err == JET_errSuccess)
                            err = JetSetIndexRange(session, tableid, JET_bitRangeUpperLimit);
                    }
                    if (err == JET_errSuccess)
                        hr = GetObjectMapData(pConn, session, tableid, oj);
                    else
                        hr = WBEM_E_NOT_FOUND;
                }
            }
        }

        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ObjectMapByClass
//
//***************************************************************************

HRESULT GetFirst_ObjectMapByClass (CSQLConnection *_pConn, SQL_ID dClassId, OBJECTMAP &oj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupObjectMapAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectClassId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dClassId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dClassId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetObjectMapData(pConn, session, tableid, oj);
                        }
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }

            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetNext_ObjectMap
//
//***************************************************************************

HRESULT GetNext_ObjectMap (CSQLConnection *_pConn, OBJECTMAP &oj)
{
    HRESULT hr = 0;

    oj.Clear();

    JET_ERR err = JET_errSuccess;    
    CESEConnection *pConn = (CESEConnection *)_pConn;

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetObjectMapData(pConn, session, tableid, oj);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  UpdateObjectMap
//
//***************************************************************************

HRESULT UpdateObjectMap (CSQLConnection *_pConn, OBJECTMAP oj, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupObjectMapAccessor(pConn);
    JET_ERR err = JET_errSuccess;
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

        err = JetSetCurrentIndex(session, tableid, "ObjectMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &oj.dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {      
                    if (err == JET_errSuccess)
                    {
                        err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                        if (err == JET_errSuccess)
                        {
                            if (oj.sObjectPath)
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTPATH), 
                                                oj.sObjectPath, wcslen(oj.sObjectPath)*2+2, 0, NULL );
                            else
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTPATH), 
                                                NULL, 0, 0, NULL );
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_CLASSID), 
                                                &oj.dClassId, sizeof(__int64), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTSCOPEID), 
                                                &oj.dObjectScopeId, sizeof(__int64), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;

                            if (oj.sObjectKey)
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTKEY), 
                                                oj.sObjectKey, wcslen(oj.sObjectKey)*2+2, 0, NULL);
                            else
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTKEY), 
                                                NULL, 0, 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_REFERENCECOUNT), 
                                                &oj.iRefCount, sizeof(DWORD), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTFLAGS), 
                                                &oj.iObjectFlags, sizeof(DWORD), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTSTATE), 
                                                &oj.iObjectState, sizeof(DWORD), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;

                            if (bDelete)
                                err = JetDelete(session, tableid);
                            else
                                err = JetUpdate(session, tableid, NULL, 0, NULL );
                        }
                    }
                }
            }
        }
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  InsertObjectMap
//
//***************************************************************************

HRESULT InsertObjectMap(CSQLConnection *_pConn, SQL_ID dObjectId, LPCWSTR lpKey, 
                        DWORD iState, LPCWSTR lpObjectPath, SQL_ID dScopeID, DWORD iClassFlags,
                        DWORD iRefCount, SQL_ID dClassId, BOOL bInsert)
{

    DEBUGTRACE((LOG_WBEMCORE, "InsertObjectMap %S\n", lpObjectPath));

    HRESULT hr = 0;
    JET_ERR err = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupObjectMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        OBJECTMAP oj;
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ObjectMap");

        if (FAILED(GetFirst_ObjectMap(_pConn, dObjectId, oj)))
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTID), &dObjectId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTPATH), lpObjectPath, wcslen(lpObjectPath)*2+2, 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_CLASSID), &dClassId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTSCOPEID), &dScopeID, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTKEY), lpKey, wcslen(lpKey)*2+2, 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_REFERENCECOUNT), &iRefCount, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTFLAGS), &iClassFlags, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, OBJECTMAP_COL_OBJECTSTATE), &iState, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
                hr = WBEM_S_NO_ERROR;
            }
        }
        else if (!bInsert)
        {
            oj.Clear();
            oj.dObjectId = dObjectId;
            oj.dClassId = dClassId;
            oj.sObjectPath = SysAllocString(lpObjectPath);
            oj.sObjectKey = SysAllocString(lpKey);
            if (!oj.sObjectPath || !oj.sObjectKey)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                oj.Clear();
                goto Exit;
            }
            oj.iRefCount = iRefCount;
            oj.iObjectFlags = iClassFlags;
            oj.dObjectScopeId = dScopeID;
            oj.iObjectState = iState;

            hr = UpdateObjectMap(pConn, oj, FALSE);
            oj.Clear();
        }
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  SetupScopeMapAccessor
//
//***************************************************************************

HRESULT SetupScopeMapAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"ScopeMap"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "ScopeMap";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();

        JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ScopeMap", tableid);

        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectId", SCOPEMAP_COL_OBJECTID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, SCOPEMAP_COL_OBJECTID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ScopePath", SCOPEMAP_COL_SCOPEPATH, JET_coltypLongBinary, 
            0, 0, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, SCOPEMAP_COL_SCOPEPATH, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ParentId", SCOPEMAP_COL_PARENTID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, SCOPEMAP_COL_PARENTID, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ScopeMap_PK", JET_bitIndexPrimary | JET_bitIndexUnique,"+ObjectId\0", 11, 100);
        if ((err >= JET_errSuccess || err == JET_errIndexHasPrimary) && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupScopeMapAccessor(_pConn);
            }
        }
        if (err == JET_errIndexHasPrimary)
            err = 0;

        if (err)
            hr = CSQLExecute::GetWMIError(err);
    }    

Exit:

    return hr;

}

//***************************************************************************
//
//  GetScopeMapData
//
//***************************************************************************

HRESULT GetScopeMapData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                SCOPEMAP &sm)
{
    HRESULT hr = WBEM_E_FAILED;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    wchar_t buff[1024];
    BYTE buff2[1024];
    sm.Clear();

    JET_ERR err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_OBJECTID), 
                &sm.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_SCOPEPATH), 
                buff2, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (lLen)
    {        
        BYTE *pBuff = new BYTE [lLen];
        if (pBuff)
        {
            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_SCOPEPATH), 
                pBuff, lLen, &lLen, JET_bitRetrieveCopy, NULL);
            sm.sScopePath = SysAllocString((LPWSTR)pBuff);
            if (!sm.sScopePath)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto exit;
            }
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;

    }
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_PARENTID), 
                &sm.dParentId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}

//***************************************************************************
//
//  OpenEnum_ScopeMap
//
//***************************************************************************

HRESULT OpenEnum_ScopeMap (CSQLConnection *_pConn, SCOPEMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    // Locate the first row for this ObjectID and bind the data.

    hr = SetupScopeMapAccessor(pConn);    

    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ScopeMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the SCOPEMAP object.
        JetSetIndexRange(session, tableid, JET_bitRangeRemove);
        JET_ERR err = JetSetCurrentIndex(session, tableid, "ScopeMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetMove(session, tableid, JET_MoveFirst, 0);
            if (err == JET_errSuccess)
                hr = GetScopeMapData(pConn, session, tableid, cd);
        }
    }

    return hr;
    
}

//***************************************************************************
//
//  GetFirst_ScopeMap
//
//***************************************************************************

HRESULT GetFirst_ScopeMap (CSQLConnection *_pConn, SQL_ID dScopeId, SCOPEMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupScopeMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ScopeMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the SCOPEMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ScopeMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dScopeId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dScopeId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            if (err == JET_errSuccess)
                                hr = GetScopeMapData(pConn, session, tableid, cd);
                            else
                                hr = WBEM_E_NOT_FOUND;
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
    
}


//***************************************************************************
//
//  GetNext_ScopeMap
//
//***************************************************************************

HRESULT GetNext_ScopeMap (CSQLConnection *_pConn, SCOPEMAP &cd)
{
    HRESULT hr = 0;

    cd.Clear();

    JET_ERR err = JET_errSuccess;    
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ScopeMap");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetScopeMapData(pConn, session, tableid, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  UpdateScopeMap
//
//***************************************************************************

HRESULT UpdateScopeMap (CSQLConnection *_pConn, SCOPEMAP cd, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;
    hr = SetupScopeMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ScopeMap");

        err = JetSetCurrentIndex(session, tableid, "ScopeMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &cd.dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {      
                    if (err == JET_errSuccess)
                    {
                        err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                        if (err == JET_errSuccess)
                        {
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_PARENTID),
                                            &cd.dParentId, sizeof(__int64), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;

                            if (cd.sScopePath)
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_SCOPEPATH), 
                                            cd.sScopePath, wcslen(cd.sScopePath)*2+2, 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;

                            if (bDelete)
                                err = JetDelete(session, tableid);
                            else
                                err = JetUpdate(session, tableid, NULL, 0, NULL );
                        }
                    }
                }
            }
        }
    }

Exit:
    hr = CSQLExecute::GetWMIError(err);

    if (bDelete && hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  InsertScopeMap_Internal
//
//***************************************************************************

HRESULT InsertScopeMap_Internal(CSQLConnection *_pConn, SQL_ID dObjectId, LPCWSTR lpPath, SQL_ID dParentId)
{
    JET_ERR err = 0;    
    HRESULT hr = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupScopeMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        SCOPEMAP oj;

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ScopeMap");

        if (FAILED(GetFirst_ScopeMap(_pConn, dObjectId, oj)))
        {
            int iLen = 2;
            BYTE *pBuff = (BYTE *)lpPath;
            if (lpPath)
            {
                iLen += wcslen(lpPath)*2;
            }
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_OBJECTID), 
                            &dObjectId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_SCOPEPATH), 
                            pBuff, iLen, 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, SCOPEMAP_COL_PARENTID), 
                            &dParentId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
                hr = WBEM_S_NO_ERROR;
            }
            oj.Clear();
        }
        else
        {
            oj.Clear();
            oj.dObjectId = dObjectId;
            oj.dParentId = dParentId;
            oj.sScopePath = SysAllocString(lpPath);
            if (!oj.sScopePath)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto Exit;
            }

            hr = UpdateScopeMap(pConn, oj, FALSE);
            SysFreeString(oj.sScopePath);    // The buffer is released by the caller.
        }

    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  DeleteScopeMap
//
//***************************************************************************

HRESULT DeleteScopeMap(CSQLConnection *_pConn, SQL_ID dObjectId)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupScopeMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ScopeMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ScopeMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetDelete(session, tableid);
                }
            }
        }

        hr = CSQLExecute::GetWMIError(err);

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;
    }

    return hr;    
}

//***************************************************************************
//
//  SetupClassMapAccessor
//
//***************************************************************************

HRESULT SetupClassMapAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"ClassMap"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "ClassMap";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();

        JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ClassMap", tableid);

        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassId", CLASSMAP_COL_CLASSID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSMAP_COL_CLASSID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassName", CLASSMAP_COL_CLASSNAME, JET_coltypText, 
            0, MAX_STRING_WIDTH, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSMAP_COL_CLASSNAME, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"SuperClassId", CLASSMAP_COL_SUPERCLASSID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSMAP_COL_SUPERCLASSID, colid);
        else
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"DynastyId", CLASSMAP_COL_DYNASTYID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSMAP_COL_DYNASTYID, colid);
        else
            goto Exit;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassBlob", CLASSMAP_COL_CLASSBUFFER, JET_coltypLongBinary, 
            0, 0, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSMAP_COL_CLASSBUFFER, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ClassMap_PK", JET_bitIndexPrimary | JET_bitIndexUnique,"+ClassId\0", 10, 100);
        if (err >= JET_errSuccess || err == JET_errIndexHasPrimary)
        {
            err = JetCreateIndex(session, tableid, "SuperClassId_idx", JET_bitIndexDisallowNull ,"+SuperClassId\0", 15, 100);
            if (err == JET_errIndexDuplicate)
                err = JET_errSuccess;
            err = JetCreateIndex(session, tableid, "DynastyId_idx", JET_bitIndexDisallowNull, "+DynastyId\0", 12, 80);
            if (err == JET_errIndexDuplicate)
                err = JET_errSuccess;
            err = JetCreateIndex(session, tableid, "ClassName_idx", JET_bitIndexDisallowNull, "+ClassName\0", 12, 80);
            if (err == JET_errIndexDuplicate)
                err = JET_errSuccess;
        }
        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupClassMapAccessor(_pConn);
            }
        }

        if (err)
            hr = CSQLExecute::GetWMIError(err);
    }    

Exit:

    return hr;

}

//***************************************************************************
//
//  GetClassMapData
//
//***************************************************************************

HRESULT GetClassMapData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                CLASSMAP &oj)
{
    HRESULT hr = WBEM_E_FAILED;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    wchar_t buff[1024];
    BYTE buff2[1024];
    oj.dClassId = 0;
    oj.dSuperClassId = 0;
    oj.dDynastyId = 0;

    oj.Clear();

    JET_ERR err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSID), 
                &oj.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSNAME), 
                buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (lLen)
    {
        buff[lLen/2] = L'\0';
        oj.sClassName = SysAllocString(buff);
        if (!oj.sClassName)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
    }
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_SUPERCLASSID), 
                &oj.dSuperClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_DYNASTYID), 
                &oj.dDynastyId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSBUFFER), 
                buff2, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (lLen)
    {
        oj.dwBufferLen = lLen;
        BYTE *pBuff = new BYTE [lLen];
        if (pBuff)
        {
            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSBUFFER), 
                pBuff, lLen, &oj.dwBufferLen, JET_bitRetrieveCopy, NULL);
            oj.pClassBuffer = pBuff;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            oj.Clear();
            goto exit;
        }
    }

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}

//***************************************************************************
//
//  OpenEnum_ClassMap
//
//***************************************************************************

HRESULT OpenEnum_ClassMap (CSQLConnection *_pConn, CLASSMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassMapAccessor(pConn);    

    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.
        JetSetIndexRange(session, tableid, JET_bitRangeRemove);
        JET_ERR err = JetSetCurrentIndex(session, tableid, "ClassMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetMove(session, tableid, JET_MoveFirst, 0);
            if (err == JET_errSuccess)
                hr = GetClassMapData(pConn, session, tableid, cd);
        }
    }

    return hr;
    
}

//***************************************************************************
//
//  GetFirst_ClassMap
//
//***************************************************************************

HRESULT GetFirst_ClassMap (CSQLConnection *_pConn, SQL_ID dClassId, CLASSMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ClassMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dClassId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dClassId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            if (err == JET_errSuccess)
                                hr = GetClassMapData(pConn, session, tableid, cd);
                            else
                                hr = WBEM_E_NOT_FOUND;
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
    
}

//***************************************************************************
//
//  GetFirst_ClassMapBySuperClass
//
//***************************************************************************

HRESULT GetFirst_ClassMapBySuperClass (CSQLConnection *_pConn, SQL_ID dSuperClassId, CLASSMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "SuperClassId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dSuperClassId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dSuperClassId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassMapData(pConn, session, tableid, cd);                        
                        }
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
    
}

//***************************************************************************
//
//  GetFirst_ClassMapByDynasty
//
//***************************************************************************

HRESULT GetFirst_ClassMapByDynasty (CSQLConnection *_pConn, SQL_ID dDynastyId, CLASSMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "DynastyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dDynastyId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dDynastyId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassMapData(pConn, session, tableid, cd);                        
                        }
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
    
}

//***************************************************************************
//
//  GetFirst_ClassMapByName
//
//***************************************************************************

HRESULT GetFirst_ClassMapByName (CSQLConnection *_pConn, LPCWSTR lpName, CLASSMAP &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if (!lpName)
        return WBEM_E_INVALID_PARAMETER;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ClassName_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, lpName, wcslen(lpName)*2+2, JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, lpName, wcslen(lpName)*2+2, JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassMapData(pConn, session, tableid, cd);                        
                        }
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
    
}

//***************************************************************************
//
//  GetNext_ClassMap
//
//***************************************************************************

HRESULT GetNext_ClassMap (CSQLConnection *_pConn, CLASSMAP &cd)
{
    HRESULT hr = 0;

    cd.Clear();

    JET_ERR err = JET_errSuccess;    
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetClassMapData(pConn, session, tableid, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  UpdateClassMap
//
//***************************************************************************

HRESULT UpdateClassMap (CSQLConnection *_pConn, CLASSMAP cd, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;
    hr = SetupClassMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        err = JetSetCurrentIndex(session, tableid, "ClassMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &cd.dClassId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {      
                    if (err == JET_errSuccess)
                    {
                        err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                        if (err == JET_errSuccess)
                        {
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSNAME), 
                                            cd.sClassName, wcslen(cd.sClassName)*2+2, 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_SUPERCLASSID), 
                                            &cd.dSuperClassId, sizeof(__int64), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_DYNASTYID), 
                                            &cd.dDynastyId, sizeof(__int64), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            if (cd.dwBufferLen)
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSBUFFER), 
                                            cd.pClassBuffer, cd.dwBufferLen, 0, NULL);
                            else
                                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSBUFFER), 
                                            NULL, 0, 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            if (bDelete)
                                err = JetDelete(session, tableid);
                            else
                                err = JetUpdate(session, tableid, NULL, 0, NULL );
                        }
                    }
                }
            }
        }
    }

Exit:
    hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  InsertClassMap
//
//***************************************************************************

HRESULT InsertClassMap(CSQLConnection *_pConn, SQL_ID dClassId, LPCWSTR lpClassName, SQL_ID dSuperClassId, 
                       SQL_ID dDynasty, BYTE *pBuff, DWORD dwBufferLen, BOOL bInsert)
{

    if (!dSuperClassId && dClassId != 1)
        dSuperClassId = 1;

    JET_ERR err = 0;    
    HRESULT hr = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {

        CLASSMAP oj;

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassMap");

        if (FAILED(GetFirst_ClassMap(_pConn, dClassId, oj)))
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSID), 
                            &dClassId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSNAME), 
                            lpClassName, wcslen(lpClassName)*2+2, 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_SUPERCLASSID), 
                            &dSuperClassId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_DYNASTYID), 
                            &dDynasty, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSMAP_COL_CLASSBUFFER), 
                            pBuff, dwBufferLen, 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
                hr = WBEM_S_NO_ERROR;
            }
            oj.Clear();
        }
        else if (!bInsert)
        {
            oj.Clear();
            oj.dClassId = dClassId;
            oj.dSuperClassId = dSuperClassId;
            oj.dDynastyId = dDynasty;
            oj.sClassName = SysAllocString(lpClassName);
            if (!oj.sClassName)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto Exit;
            }
            oj.pClassBuffer = pBuff;
            oj.dwBufferLen = dwBufferLen;

            hr = UpdateClassMap(pConn, oj, FALSE);
            SysFreeString(oj.sClassName);    // The buffer is released by the caller.
        }

    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  SetupPropertyMapAccessor
//
//***************************************************************************

HRESULT SetupPropertyMapAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"PropertyMap"))
    {
        JET_SESID session;
        JET_DBID dbid;
        JET_TABLEID tableid;
        const LPSTR lpTbl = "PropertyMap";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();
        JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"PropertyMap", tableid);

        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassId", PROPERTYMAP_COL_CLASSID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, PROPERTYMAP_COL_CLASSID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyId", PROPERTYMAP_COL_PROPERTYID, JET_coltypLong, 
            JET_bitColumnNotNULL|JET_bitColumnAutoincrement, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, PROPERTYMAP_COL_PROPERTYID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"StorageTypeId", PROPERTYMAP_COL_STORAGETYPEID, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, PROPERTYMAP_COL_STORAGETYPEID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"CIMTypeId", PROPERTYMAP_COL_CIMTYPEID, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, PROPERTYMAP_COL_CIMTYPEID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyName", PROPERTYMAP_COL_PROPERTYNAME, JET_coltypText, 
            JET_bitColumnNotNULL, MAX_STRING_WIDTH, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, PROPERTYMAP_COL_PROPERTYNAME, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"Flags", PROPERTYMAP_COL_FLAGS, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, PROPERTYMAP_COL_FLAGS, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "PropertyMap_PK", JET_bitIndexPrimary | JET_bitIndexUnique,"+PropertyId\0", 13, 100);
        if (err >= JET_errSuccess || err == JET_errIndexHasPrimary)
        {
            err = JetCreateIndex(session, tableid, "ClassId_idx", JET_bitIndexDisallowNull ,"+ClassId\0", 10, 100);        
            if (err >= JET_errSuccess || err == JET_errIndexDuplicate)
                err = JET_errSuccess;
            else
                hr = CSQLExecute::GetWMIError(err);
        }

        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupPropertyMapAccessor(_pConn);
            }
        }

        if (err)
            hr = CSQLExecute::GetWMIError(err);
    }    

Exit:
    return hr;
}

//***************************************************************************
//
//  GetPropertyMapData
//
//***************************************************************************

HRESULT GetPropertyMapData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                PROPERTYMAP &oj)
{
    HRESULT hr = WBEM_E_FAILED;
    oj.Clear();

    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    wchar_t buff[1024];
    oj.iPropertyId = 0;

    JET_ERR err = JET_errSuccess; 
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_PROPERTYID), 
                &oj.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_PROPERTYNAME),
                buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (lLen)
    {
        buff[lLen/2] = L'\0';
        oj.sPropertyName = SysAllocString(buff);
        if (!oj.sPropertyName)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto exit;
        }
    }
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_CLASSID), 
                &oj.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_STORAGETYPEID), 
                &oj.iStorageTypeId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_CIMTYPEID), 
                &oj.iCIMTypeId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_FLAGS), 
                &oj.iFlags, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}


//***************************************************************************
//
//  GetFirst_PropertyMap
//
//***************************************************************************

HRESULT GetFirst_PropertyMap (CSQLConnection *_pConn, DWORD iPropertyId, PROPERTYMAP &pm)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupPropertyMapAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"PropertyMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetPropertyMapData(pConn, session, tableid, pm);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


//***************************************************************************
//
//  GetFirst_PropertyMapByClass
//
//***************************************************************************

HRESULT GetFirst_PropertyMapByClass (CSQLConnection *_pConn, SQL_ID dClassId, PROPERTYMAP &pm)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupPropertyMapAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"PropertyMap");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ClassId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dClassId, sizeof(SQL_ID), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dClassId, sizeof(SQL_ID), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetPropertyMapData(pConn, session, tableid, pm);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetNext_PropertyMap
//
//***************************************************************************

HRESULT GetNext_PropertyMap (CSQLConnection *_pConn, PROPERTYMAP &pm)
{
    HRESULT hr = 0;

    pm.Clear();

    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = JET_errSuccess;    

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"PropertyMap");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetPropertyMapData(pConn, session, tableid, pm);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}


//***************************************************************************
//
//  UpdatePropertyMap
//
//***************************************************************************

HRESULT UpdatePropertyMap(CSQLConnection *_pConn, PROPERTYMAP pm, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;
    hr = SetupPropertyMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"PropertyMap");

        err = JetSetCurrentIndex(session, tableid, "PropertyMap_PK");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &pm.iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {      
                    if (err == JET_errSuccess)
                    {
                        err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                        if (err == JET_errSuccess)
                        {
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_PROPERTYNAME), 
                                pm.sPropertyName, wcslen(pm.sPropertyName)*2+2, 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_CLASSID), 
                                &pm.dClassId, sizeof(__int64), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_STORAGETYPEID), 
                                &pm.iStorageTypeId, sizeof(DWORD), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_FLAGS), 
                                &pm.iFlags, sizeof(DWORD), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_CIMTYPEID), 
                                &pm.iCIMTypeId, sizeof(DWORD), 0, NULL);
                            if (err < JET_errSuccess)
                                goto Exit;
                            if (bDelete)
                                err = JetDelete(session, tableid);
                            else
                                err = JetUpdate(session, tableid, NULL, 0, NULL );
                        }
                    }
                }
            }
        }
    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  InsertPropertyMap
//
//***************************************************************************

HRESULT InsertPropertyMap (CSQLConnection *_pConn, DWORD &iPropID, SQL_ID dClassId, DWORD iStorageTypeId, 
                           DWORD iCIMTypeId, LPCWSTR lpPropName, DWORD iFlags, BOOL bInsert)
{

    JET_ERR err = 0; 
    HRESULT hr = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupPropertyMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        if (bInsert)
            iPropID = 0;

        unsigned long lLen;
        PROPERTYMAP pm;
        DWORD dwOldFlags = 0;

        JET_SESID session = pConn->GetSessionID();
        BOOL bExists = FALSE;
        JET_TABLEID tableid = pConn->GetTableID(L"PropertyMap");

        hr = GetFirst_PropertyMapByClass(_pConn, dClassId, pm);
        while (SUCCEEDED(hr))
        {
            if (!_wcsicmp(pm.sPropertyName, lpPropName))
            {
                BOOL bMatch = TRUE;
                if ((iFlags & REPDRVR_FLAG_NONPROP) == (pm.iFlags & REPDRVR_FLAG_NONPROP))
                {
                    if (iFlags & REPDRVR_FLAG_NONPROP)
                    {
                        if (iStorageTypeId != pm.iStorageTypeId)
                            bMatch = FALSE;
                    }
                    if (bMatch)
                    {
                        iPropID = pm.iPropertyId;
                        dwOldFlags = pm.iFlags;
                        pm.Clear();
                        bExists = TRUE;
                        break;
                    }
                }
            }
            hr = GetNext_PropertyMap(_pConn, pm);
            if (pm.dClassId != dClassId)
                break;
        }
        hr = WBEM_S_NO_ERROR;

        if (!bExists)
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                // Now retrieve the auto-incremented ID...
                err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_PROPERTYID),
                        &iPropID, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL) ;

                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_PROPERTYNAME), 
                    lpPropName, wcslen(lpPropName)*2+2, 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_CLASSID), 
                    &dClassId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_STORAGETYPEID), 
                    &iStorageTypeId, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_FLAGS), 
                    &iFlags, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, PROPERTYMAP_COL_CIMTYPEID), 
                    &iCIMTypeId, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
                hr = WBEM_S_NO_ERROR;

            }
        }
        else if (!bInsert)
        {
            pm.Clear();
            pm.iPropertyId = iPropID;
            pm.sPropertyName = SysAllocString(lpPropName);
            if (!pm.sPropertyName)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto Exit;
            }
            pm.dClassId = dClassId;
            pm.iStorageTypeId = iStorageTypeId;
            pm.iCIMTypeId = iCIMTypeId;
            pm.iFlags = iFlags;

            hr = UpdatePropertyMap(pConn, pm, FALSE);
            pm.Clear();
        }

    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;

}

//***************************************************************************
//
//  SetupClassKeysAccessor
//
//***************************************************************************

HRESULT SetupClassKeysAccessor (CSQLConnection *_pConn)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"ClassKeys"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "ClassKeys";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();

        JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ClassKeys", tableid);

        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassId", CLASSKEYS_COL_CLASSID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSKEYS_COL_CLASSID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyId", CLASSKEYS_COL_PROPERTYID, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSKEYS_COL_PROPERTYID, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ClassId_idx", JET_bitIndexDisallowNull,"+ClassId\0", 10, 100);
        if (err >= JET_errSuccess || err == JET_errIndexDuplicate)
        {
            err = JetCreateIndex(session, tableid, "PropertyId_idx", JET_bitIndexDisallowNull ,"+PropertyId\0", 13, 100);
            if (err == JET_errIndexDuplicate)
                err = JET_errSuccess;
        }
        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupClassKeysAccessor(_pConn);
            }
        }

        if (err)
            hr = CSQLExecute::GetWMIError(err);
    }    

Exit:

    return hr;
}

//***************************************************************************
//
//  GetClassKeysData
//
//***************************************************************************

HRESULT GetClassKeysData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                CLASSKEYS &oj)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    oj.iPropertyId = 0;

    JET_ERR err = JET_errSuccess; 
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSKEYS_COL_PROPERTYID), 
                &oj.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSKEYS_COL_CLASSID), 
                &oj.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}

//***************************************************************************
//
//  GetFirst_ClassKeys
//
//***************************************************************************

HRESULT GetFirst_ClassKeys (CSQLConnection *_pConn, SQL_ID dClassId, CLASSKEYS &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassKeysAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassKeys");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ClassId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dClassId, sizeof(SQL_ID), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dClassId, sizeof(SQL_ID), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetClassKeysData(pConn, session, tableid, cd);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ClassKeysByPropertyId
//
//***************************************************************************

HRESULT GetFirst_ClassKeysByPropertyId (CSQLConnection *_pConn, 
                                        DWORD dwPropertyId, CLASSKEYS &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassKeysAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassKeys");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dwPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dwPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetClassKeysData(pConn, session, tableid, cd);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetNext_ClassKeys
//
//***************************************************************************

HRESULT GetNext_ClassKeys (CSQLConnection *_pConn, CLASSKEYS &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = JET_errSuccess;    

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ClassKeys");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetClassKeysData(pConn, session, tableid, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  UpdateClassKeys
//
//***************************************************************************

HRESULT UpdateClassKeys(CSQLConnection *_pConn, CLASSKEYS cd, BOOL bDelete = FALSE)
{
    HRESULT hr = 0;

    JET_ERR err = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassKeysAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassKeys");

        err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &cd.iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &cd.iPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        while (err == JET_errSuccess)
                        {    
                            CLASSKEYS ck;
                            ULONG lLen;

                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSKEYS_COL_CLASSID), 
                                        &ck.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;

                            if (ck.dClassId == cd.dClassId)
                            {               
                                if (bDelete)
                                    err = JetDelete(session, tableid);
                                break;
                            }
                            err = JetMove(session, tableid, JET_MoveNext, 0);
                        }
                    }
                }
            }
        }
    }

Exit:
    hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  InsertClassKeys
//
//***************************************************************************

HRESULT InsertClassKeys (CSQLConnection *_pConn, SQL_ID dClassId, DWORD dwPropertyId,
                         BOOL bInsert)
{
    HRESULT hr = 0;

    JET_ERR err = 0;    

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassKeysAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        CLASSKEYS oj;

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassKeys");

        oj.dClassId = dClassId;
        oj.iPropertyId = dwPropertyId;

        hr = UpdateClassKeys(pConn, oj, FALSE);
        if (FAILED(hr))
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSKEYS_COL_CLASSID), 
                            &dClassId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSKEYS_COL_PROPERTYID), 
                            &dwPropertyId, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
            }
            hr = WBEM_S_NO_ERROR;
        }
    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  DeleteClassKeys
//
//***************************************************************************

HRESULT DeleteClassKeys (CSQLConnection *_pConn, SQL_ID dClassId, DWORD dwPropertyId = 0)
{
    HRESULT hr = 0;

    CLASSKEYS ck;

    if (dwPropertyId)
        hr = GetFirst_ClassKeysByPropertyId(_pConn, dwPropertyId, ck);
    else
        hr = GetFirst_ClassKeys(_pConn, dClassId, ck);

    while (SUCCEEDED(hr))
    {
        hr = UpdateClassKeys(_pConn, ck, TRUE);
        
        hr = GetNext_ClassKeys(_pConn, ck);
    }

    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}


//***************************************************************************
//
//  SetupReferencePropertiesAccessor
//
//***************************************************************************

HRESULT SetupReferencePropertiesAccessor (CSQLConnection *_pConn)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"ReferenceProperties"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "ReferenceProperties";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();

        JET_ERR err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ReferenceProperties", tableid);

        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassId", REFPROPS_COL_CLASSID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, REFPROPS_COL_CLASSID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyId", REFPROPS_COL_PROPERTYID, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, REFPROPS_COL_PROPERTYID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"RefClassId", REFPROPS_COL_REFCLASSID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, REFPROPS_COL_REFCLASSID, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ClassId_idx", JET_bitIndexDisallowNull,"+ClassId\0", 10, 100);
        if (err >= JET_errSuccess || err == JET_errIndexDuplicate)
        {
            err = JetCreateIndex(session, tableid, "RefClassId_idx", JET_bitIndexDisallowNull,"+RefClassId\0", 13, 100);
            if (err >= JET_errSuccess || err == JET_errIndexDuplicate)
            {
                err = JetCreateIndex(session, tableid, "PropertyId_idx", JET_bitIndexDisallowNull ,"+PropertyId\0", 13, 100);
                if (err == JET_errIndexDuplicate)
                    err = JET_errSuccess;
            }
        }
        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupReferencePropertiesAccessor(_pConn);
            }
        }

        if (err)
            hr = CSQLExecute::GetWMIError(err);
    }    

Exit:

    return hr;
}

//***************************************************************************
//
//  GetReferencePropertiesData
//
//***************************************************************************

HRESULT GetReferencePropertiesData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                REFERENCEPROPERTIES &oj)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    oj.iPropertyId = 0;

    JET_ERR err = JET_errSuccess; 
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_PROPERTYID), 
                &oj.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_CLASSID), 
                &oj.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_REFCLASSID), 
                &oj.dRefClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}

//***************************************************************************
//
//  GetFirst_ReferenceProperties
//
//***************************************************************************

HRESULT GetFirst_ReferenceProperties (CSQLConnection *_pConn, DWORD dwPropertyId, 
                                      REFERENCEPROPERTIES &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupReferencePropertiesAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ReferenceProperties");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dwPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dwPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetReferencePropertiesData(pConn, session, tableid, cd);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ReferencePropertiesByRef
//
//***************************************************************************

HRESULT GetFirst_ReferencePropertiesByRef (CSQLConnection *_pConn, SQL_ID dRefClassId,
                                      REFERENCEPROPERTIES &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupReferencePropertiesAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ReferenceProperties");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "RefClassId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dRefClassId, sizeof(SQL_ID), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dRefClassId, sizeof(SQL_ID), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetReferencePropertiesData(pConn, session, tableid, cd);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ReferencePropertiesByClass
//
//***************************************************************************

HRESULT GetFirst_ReferencePropertiesByClass (CSQLConnection *_pConn, SQL_ID dClassId, 
                                      REFERENCEPROPERTIES &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupReferencePropertiesAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ReferenceProperties");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ClassId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dClassId, sizeof(SQL_ID), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dClassId, sizeof(SQL_ID), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                            hr = GetReferencePropertiesData(pConn, session, tableid, cd);
                        else
                            hr = WBEM_E_NOT_FOUND;
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetNext_ReferenceProperties
//
//***************************************************************************

HRESULT GetNext_ReferenceProperties (CSQLConnection *_pConn, REFERENCEPROPERTIES &cd)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = JET_errSuccess;    

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ReferenceProperties");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetReferencePropertiesData(pConn, session, tableid, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}


//***************************************************************************
//
//  UpdateReferenceProperties
//
//***************************************************************************

HRESULT UpdateReferenceProperties(CSQLConnection *_pConn, REFERENCEPROPERTIES cd, BOOL bDelete = FALSE,
                                  BOOL bAllowMultiple = FALSE)
{
    HRESULT hr = 0;
    JET_ERR err = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupReferencePropertiesAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ReferenceProperties");

        err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &cd.iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &cd.iPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        while (err == JET_errSuccess)
                        {    
                            REFERENCEPROPERTIES ck;
                            ULONG lLen;

                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_CLASSID), 
                                        &ck.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;

                            if (ck.dClassId == cd.dClassId)
                            {
                                BOOL bFound = TRUE;
                                if (bAllowMultiple)
                                {
                                    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_REFCLASSID), 
                                                &ck.dRefClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
                                    if (JET_errSuccess > err)
                                        goto Exit;

                                    if (ck.dRefClassId != cd.dRefClassId)
                                        bFound = FALSE;
                                }
                             
                                if (bFound)
                                {
                                    err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_REFCLASSID), 
                                                &ck.dRefClassId, sizeof(__int64), 0, NULL );
                                    if (err < JET_errSuccess)
                                        goto Exit;

                                    if (bDelete)
                                        err = JetDelete(session, tableid);
                                    else
                                        err = JetUpdate(session, tableid, 0, NULL, 0);
                                    break;
                                }
                            }
                            err = JetMove(session, tableid, JET_MoveNext, 0);
                        }
                    }
                }
            }
        }
    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}


//***************************************************************************
//
//  InsertReferenceProperties
//
//***************************************************************************

HRESULT InsertReferenceProperties (CSQLConnection *_pConn, SQL_ID dClassId, DWORD dwPropertyId,
                                   SQL_ID dRefClassId, BOOL bAllowMultiple = FALSE)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;    
    hr = SetupReferencePropertiesAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        REFERENCEPROPERTIES oj;

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ReferenceProperties");

        BOOL bFound = FALSE;
        hr = GetFirst_ReferenceProperties(_pConn, dClassId, oj);
        while (SUCCEEDED(hr))
        {
            if (oj.iPropertyId == dwPropertyId)
            {
                bFound = TRUE;
                if (bAllowMultiple)
                {
                    if (dRefClassId != oj.dRefClassId)
                        bFound = FALSE;
                }
            
                if (bFound)
                    break;
            }
            hr = GetNext_ReferenceProperties(_pConn, oj);
        }

        if (!bFound)
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_CLASSID), 
                            &dClassId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_REFCLASSID), 
                            &dRefClassId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, REFPROPS_COL_PROPERTYID), 
                            &dwPropertyId, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
            }
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            oj.dClassId = dClassId;
            oj.iPropertyId = dwPropertyId;
            oj.dRefClassId = dRefClassId;

            hr = UpdateReferenceProperties(pConn, oj, FALSE, bAllowMultiple);
        }

    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  DeleteReferenceProperties
//
//***************************************************************************

HRESULT DeleteReferenceProperties (CSQLConnection *_pConn, DWORD dwPropertyId, SQL_ID dClassId = 0)
{
    HRESULT hr = 0;

    REFERENCEPROPERTIES ck;

    hr = GetFirst_ReferenceProperties(_pConn, dwPropertyId, ck);
    while (SUCCEEDED(hr))
    {
        BOOL bMatch = TRUE;

        if (dClassId && dClassId != ck.dClassId)
            bMatch = FALSE;
        
        if (bMatch)
            hr = UpdateReferenceProperties(_pConn, ck, TRUE);
        
        hr = GetNext_ReferenceProperties(_pConn, ck);
    }

    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  DeleteReferencePropertiesByClass
//
//***************************************************************************

HRESULT DeleteReferencePropertiesByClass (CSQLConnection *_pConn, SQL_ID dClassId)
{
    HRESULT hr = 0;

    REFERENCEPROPERTIES ck;

    hr = GetFirst_ReferencePropertiesByClass(_pConn, dClassId, ck);
    while (SUCCEEDED(hr))
    {
        hr = UpdateReferenceProperties(_pConn, ck, TRUE);
        
        hr = GetNext_ReferenceProperties(_pConn, ck);
    }

    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;
    return hr;
}

//***************************************************************************
//
//  SetupClassDataAccessor
//
//***************************************************************************

HRESULT SetupClassDataAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;
    JET_ERR err = JET_errSuccess;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"ClassData"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "ClassData";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();
        err = JetOpenTable (session, dbid, lpTbl,  NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl,  10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ClassData", tableid);
        
        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectId", CLASSDATA_COL_OBJECTID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_OBJECTID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyId", CLASSDATA_COL_PROPERTYID, JET_coltypLong, 
            JET_bitColumnNotNULL, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_PROPERTYID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ArrayPos", CLASSDATA_COL_ARRAYPOS, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_ARRAYPOS, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"QfrPos", CLASSDATA_COL_QFRPOS, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_QFRPOS, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ClassId", CLASSDATA_COL_CLASSID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_CLASSID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"RefClassId", CLASSDATA_COL_REFCLASSID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_REFCLASSID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"RefId", CLASSDATA_COL_REFID, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_REFID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"Flags", CLASSDATA_COL_FLAGS, JET_coltypLong, 
            0, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_FLAGS, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyStringValue", CLASSDATA_COL_STRINGVALUE, JET_coltypText, 
            0, MAX_STRING_WIDTH, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_STRINGVALUE, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyNumericValue", CLASSDATA_COL_NUMERICVALUE, JET_coltypCurrency, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_NUMERICVALUE, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyRealValue", CLASSDATA_COL_REALVALUE, JET_coltypIEEEDouble, 
            0, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSDATA_COL_REALVALUE, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ObjectId_idx", JET_bitIndexDisallowNull,"+ObjectId\0", 11, 100);
        if (err >= JET_errSuccess || err == JET_errIndexDuplicate)
        {
            err = JetCreateIndex(session, tableid, "RefId_idx", JET_bitIndexDisallowNull ,"+RefId\0", 8, 100);
            if (err >= JET_errSuccess || err == JET_errIndexDuplicate)
            {
                err = JetCreateIndex(session, tableid, "PropertyId_idx", JET_bitIndexDisallowNull ,"+PropertyId\0", 13, 100);        
                if (err == JET_errIndexDuplicate)
                    err = JET_errSuccess;
            }
        }
        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupClassDataAccessor(_pConn);
            }
        }

    }    

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;   
}



//***************************************************************************
//
//  GetClassData
//
//***************************************************************************

HRESULT GetClassData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                CLASSDATA &oj, BOOL bMinimum=FALSE, CSchemaCache *pCache = NULL)
{
    HRESULT hr = WBEM_E_FAILED;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    wchar_t buff[1024];
    oj.Clear();
    oj.dRefId = 0, oj.dPropertyNumericValue = 0, oj.rPropertyRealValue = 0;

    JET_ERR err = JET_errSuccess; 

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_PROPERTYID), 
                &oj.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    if (!bMinimum)
    {
        err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_OBJECTID), 
                    &oj.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
        if (JET_errSuccess > err)
            goto exit;
        err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_CLASSID), 
                    &oj.dClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
        if (JET_errSuccess > err)
            goto exit;
        err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFCLASSID), 
                    &oj.dRefClassId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
        if (JET_errSuccess > err)
            goto exit;
        err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_QFRPOS), 
                    &oj.iQfrPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
        if (JET_errSuccess > err)
            goto exit;
    }

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_FLAGS), 
                &oj.iFlags, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_ARRAYPOS), 
                &oj.iArrayPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFID), 
                &oj.dRefId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    if (!lLen)
        oj.dRefId = 0;


    if (!(oj.iFlags & ESE_FLAG_NULL))
    {
        DWORD dwPropFlags = 0;
        DWORD dwStorage = 0;
        if (pCache)
        {
            hr = pCache->GetPropertyInfo (oj.iPropertyId, NULL, NULL, &dwStorage,
                        NULL, &dwPropFlags);
        }
        if (SUCCEEDED(hr) && dwStorage != 0)
        {
            switch(dwStorage)
            {
            case WMIDB_STORAGE_REFERENCE:
            case WMIDB_STORAGE_STRING:
                err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_STRINGVALUE), 
                            buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
                if (JET_errSuccess > err)
                    goto exit;
                if (lLen)
                {
                    buff[lLen/2] = L'\0';
                    oj.sPropertyStringValue = SysAllocString(buff);
                    if (wcslen(buff) && !oj.sPropertyStringValue)
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                        goto exit;
                    }
                }
                break;
            case WMIDB_STORAGE_NUMERIC:
                err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_NUMERICVALUE), 
                            &oj.dPropertyNumericValue, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
                if (JET_errSuccess > err)
                    goto exit;
                if (!lLen)
                    oj.dPropertyNumericValue = 0;

                break;
            case WMIDB_STORAGE_REAL:
                err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REALVALUE), 
                            &oj.rPropertyRealValue, sizeof(double), &lLen, JET_bitRetrieveCopy, NULL);
                if (JET_errSuccess > err)
                    goto exit;
                if (!lLen)
                    oj.rPropertyRealValue = 0;
                break;
            default:
                hr = WBEM_E_INVALID_OPERATION;
                break;
            }
        }
        else
        {
            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_STRINGVALUE), 
                        buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
            if (JET_errSuccess > err)
                goto exit;
            if (lLen)
            {
                buff[lLen/2] = L'\0';
                oj.sPropertyStringValue = SysAllocString(buff);
                if (wcslen(buff) && !oj.sPropertyStringValue)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    goto exit;
                }
            }
            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_NUMERICVALUE), 
                        &oj.dPropertyNumericValue, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
            if (JET_errSuccess > err)
                goto exit;
            if (!lLen)
                oj.dPropertyNumericValue = 0;
            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REALVALUE), 
                        &oj.rPropertyRealValue, sizeof(double), &lLen, JET_bitRetrieveCopy, NULL);
            if (JET_errSuccess > err)
                goto exit;
            if (!lLen)
                oj.rPropertyRealValue = 0;
            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFID), 
                        &oj.dRefId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
            if (JET_errSuccess > err)
                goto exit;
            if (!lLen)
                oj.dRefId = 0;
        }
    }

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}
//***************************************************************************
//
//  GetFirst_ClassData
//
//***************************************************************************

HRESULT GetFirst_ClassData (CSQLConnection *_pConn, SQL_ID dId, CLASSDATA &cd,
                                   DWORD iPropertyId, BOOL bMinimum, CSchemaCache *pCache)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassDataAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassData");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            while (err == JET_errSuccess)
                            {                    
                                if (FAILED(GetClassData(pConn, session, tableid, cd, bMinimum, pCache)))
                                    break;
                                else if (iPropertyId == -1 || cd.iPropertyId == iPropertyId)
                                {
                                    hr = WBEM_S_NO_ERROR;
                                    break;
                                }
                                err = JetMove(session, tableid, JET_MoveNext, 0);
                            }
                        }
                    }
                }
            }
        }
		if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ClassDataByRefId
//
//***************************************************************************

HRESULT GetFirst_ClassDataByRefId (CSQLConnection *_pConn, SQL_ID dRefId, CLASSDATA &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassDataAccessor(pConn);    
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassData");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "RefId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dRefId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dRefId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassData(pConn, session, tableid, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

//***************************************************************************
//
//  GetFirst_ClassDataByPropertyId
//
//***************************************************************************

HRESULT GetFirst_ClassDataByPropertyId (CSQLConnection *_pConn, DWORD iPropertyId, CLASSDATA &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassDataAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassData");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassData(pConn, session, tableid, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}
//***************************************************************************
//
//  GetNext_ClassData
//
//***************************************************************************

HRESULT GetNext_ClassData (CSQLConnection *_pConn, CLASSDATA &cd, DWORD iPropertyId, BOOL bMinimum,
                           CSchemaCache *pCache)
{
    HRESULT hr = 0;

    cd.Clear();
    CESEConnection *pConn = (CESEConnection *)_pConn;

    JET_ERR err = JET_errSuccess;    

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ClassData");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetClassData(pConn, session, tableid, cd, bMinimum, pCache);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  UpdateClassData_Internal
//
//***************************************************************************

HRESULT UpdateClassData_Internal(CSQLConnection *_pConn, CLASSDATA cd, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;

    hr = SetupClassDataAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        unsigned long lLen;
    
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassData");

        err = JetSetCurrentIndex(session, tableid, "ObjectId_idx");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &cd.dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {    
                    err = JetMakeKey(session, tableid, &cd.dObjectId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
            
                        while (err == JET_errSuccess)
                        {
                            CLASSDATA cd2;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_OBJECTID), 
                                        &cd2.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_ARRAYPOS), 
                                        &cd2.iArrayPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_QFRPOS), 
                                        &cd2.iQfrPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_PROPERTYID), 
                                        &cd2.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                
                            if (cd.dObjectId == cd2.dObjectId &&
                                cd.iPropertyId == cd2.iPropertyId &&
                                cd.iQfrPos == cd2.iQfrPos &&
                                cd.iArrayPos == cd2.iArrayPos)
                            {
                                err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                                if (err == JET_errSuccess)
                                {
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_OBJECTID), 
                                        &cd.dObjectId, sizeof(__int64), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_CLASSID), 
                                        &cd.dClassId, sizeof(__int64), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFID), 
                                        &cd.dRefId, sizeof(__int64), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_NUMERICVALUE), 
                                        &cd.dPropertyNumericValue, sizeof(__int64), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFCLASSID), 
                                        &cd.dRefClassId, sizeof(__int64), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_ARRAYPOS), 
                                        &cd.iArrayPos, sizeof(DWORD), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_QFRPOS), 
                                        &cd.iQfrPos, sizeof(DWORD), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_FLAGS), 
                                        &cd.iFlags, sizeof(DWORD), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_PROPERTYID), 
                                        &cd.iPropertyId, sizeof(DWORD), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REALVALUE), 
                                        &cd.rPropertyRealValue, sizeof(double), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    if (cd.sPropertyStringValue)
                                        err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_STRINGVALUE), 
                                            cd.sPropertyStringValue, wcslen(cd.sPropertyStringValue)*2+2, 0, NULL);
                                    else
                                        err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_STRINGVALUE), 
                                            NULL, 0, 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;

                                    if (bDelete)
                                        err = JetDelete(session, tableid);
                                    else
                                        err = JetUpdate(session, tableid, NULL, 0, NULL );
                                }
                                break;
                            }
                            else
                                err = JetMove(session, tableid, JET_MoveNext, 0);
                        }
                    }
                }
            }
        }
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  InsertClassData_Internal
//
//***************************************************************************

HRESULT InsertClassData_Internal (CSQLConnection *_pConn, SQL_ID dObjectId, DWORD iPropID, DWORD iArrayPos, DWORD iQfrPos,
                         SQL_ID dClassId, LPCWSTR lpStringValue, SQL_ID dNumericValue, double fRealValue,
                         DWORD iFlags, SQL_ID dRefId, SQL_ID dRefClassId, BOOL bIsNull)
{
    HRESULT hr = 0;

    JET_ERR err = 0;    
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassDataAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassData");

        CLASSDATA cd;

        cd.dObjectId = dObjectId;
        cd.dClassId = dClassId;
        cd.iArrayPos = iArrayPos;
        cd.iQfrPos = iQfrPos;
        cd.iPropertyId = iPropID;
        cd.iFlags = iFlags;
        if (bIsNull)
            cd.iFlags |= ESE_FLAG_NULL;
        if (!bIsNull)
        {
            cd.dRefId = dRefId;
            cd.dRefClassId = dRefClassId;
            cd.rPropertyRealValue = fRealValue;
            cd.dPropertyNumericValue = dNumericValue;
            if (lpStringValue)
            {
                LPWSTR lpVal = StripQuotes2((LPWSTR)lpStringValue);
                CDeleteMe <wchar_t> d (lpVal);
                cd.sPropertyStringValue = SysAllocString(lpVal);    
                if (!cd.sPropertyStringValue)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    goto Exit;
                }
            }
            else
                cd.sPropertyStringValue = NULL;
        }
        else
        {
            cd.dRefId =0;
            cd.dRefClassId = 0;
            cd.rPropertyRealValue = 0;
            cd.dPropertyNumericValue = 0;
            cd.sPropertyStringValue = NULL;
        }

        hr = UpdateClassData_Internal(pConn, cd, FALSE);
        if (FAILED(hr))
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_OBJECTID), 
                    &dObjectId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_CLASSID), 
                    &dClassId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                // NOTE: This can't be null, because we have an index on it...
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFID), 
                    &dRefId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                if (!bIsNull)
                {
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_NUMERICVALUE), 
                        &dNumericValue, sizeof(__int64), 0, NULL);
                    if (err < JET_errSuccess)
                        goto Exit;
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFCLASSID), 
                        &dRefClassId, sizeof(__int64), 0, NULL);
                    if (err < JET_errSuccess)
                        goto Exit;
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REALVALUE), 
                        &fRealValue, sizeof(double), 0, NULL);
                    if (err < JET_errSuccess)
                        goto Exit;
                    if (cd.sPropertyStringValue)
                        err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_STRINGVALUE), 
                            cd.sPropertyStringValue, wcslen(cd.sPropertyStringValue)*2+2, 0, NULL);                
                }
                else
                {
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_NUMERICVALUE), 
                        NULL, 0, 0, NULL);
                    if (err < JET_errSuccess)
                        goto Exit;
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REFCLASSID), 
                        NULL, 0, 0, NULL);
                    if (err < JET_errSuccess)
                        goto Exit;
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_REALVALUE), 
                        NULL, 0, 0, NULL);
                    if (err < JET_errSuccess)
                        goto Exit;
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_STRINGVALUE), 
                        NULL, 0, 0, NULL);
                }
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_ARRAYPOS), 
                    &iArrayPos, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_QFRPOS), 
                    &iQfrPos, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_FLAGS), 
                    &cd.iFlags, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSDATA_COL_PROPERTYID), 
                    &iPropID, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );
            }
        }
        hr = WBEM_S_NO_ERROR;
        cd.Clear();
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  SetupClassImagesAccessor
//
//***************************************************************************

HRESULT SetupClassImagesAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;
    JET_ERR err = JET_errSuccess; 
    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (!pConn->GetTableID(L"ClassImages"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        BOOL bCreate = FALSE;
        const LPSTR lpTbl = "ClassImages";

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();
        err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl,  10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ClassImages", tableid);
        
        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectId", CLASSIMAGES_COL_OBJECTID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSIMAGES_COL_OBJECTID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyId", CLASSIMAGES_COL_PROPERTYID, JET_coltypLong, 
            JET_bitColumnNotNULL, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSIMAGES_COL_PROPERTYID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ArrayPos", CLASSIMAGES_COL_ARRAYPOS, JET_coltypLong, 
            JET_bitColumnNotNULL, sizeof(DWORD), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSIMAGES_COL_ARRAYPOS, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"PropertyImageValue", CLASSIMAGES_COL_IMAGEVALUE, JET_coltypLongBinary, 
            0, 0, &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CLASSIMAGES_COL_IMAGEVALUE, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ObjectId_idx", JET_bitIndexDisallowNull,"+ObjectId\0", 11, 100);
        if (err >= JET_errSuccess ||err == JET_errIndexDuplicate)
        {
            err = JetCreateIndex(session, tableid, "PropertyId_idx", JET_bitIndexDisallowNull ,"+PropertyId\0", 13, 100);        
            if (err == JET_errIndexDuplicate)
                err = JET_errSuccess;
        }
        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupClassImagesAccessor(_pConn);
            }
        }

    }    

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;   

}

//***************************************************************************
//
//  GetClassImagesData
//
//***************************************************************************

HRESULT GetClassImagesData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                CLASSIMAGES &oj)
{
    HRESULT hr = WBEM_E_FAILED;
    JET_ERR err = JET_errSuccess; 
    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;
    BYTE buff[128];
    oj.Clear();

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_OBJECTID), 
                &oj.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_PROPERTYID), 
                &oj.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_ARRAYPOS), 
                &oj.iArrayPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_IMAGEVALUE), 
                buff, 128, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    if(lLen > 0)
    {
        oj.pBuffer = new BYTE[lLen];
        if (oj.pBuffer)
        {
            oj.dwBufferLen = lLen;

            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_IMAGEVALUE), 
                        oj.pBuffer, oj.dwBufferLen, &lLen, JET_bitRetrieveCopy, NULL);
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;

    }

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}

//***************************************************************************
//
//  GetFirst_ClassImages
//
//***************************************************************************

HRESULT GetFirst_ClassImages (CSQLConnection *_pConn, SQL_ID dId, CLASSIMAGES &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassImagesAccessor(pConn);    
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassImages");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassImagesData(pConn, session, tableid, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  GetFirst_ClassImagesByPropertyId
//
//***************************************************************************

HRESULT GetFirst_ClassImagesByPropertyId (CSQLConnection *_pConn, DWORD iPropertyId, CLASSIMAGES &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupClassImagesAccessor(pConn);    
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassImages");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetClassImagesData(pConn, session, tableid, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  GetNext_ClassImages
//
//***************************************************************************

HRESULT GetNext_ClassImages (CSQLConnection *_pConn, CLASSIMAGES &cd)
{
    HRESULT hr = 0;

    cd.Clear();
    CESEConnection *pConn = (CESEConnection *)_pConn;

    JET_ERR err = JET_errSuccess;

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ClassImages");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetClassImagesData(pConn, session, tableid, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}


//***************************************************************************
//
//  UpdateClassImages
//
//***************************************************************************

HRESULT UpdateClassImages (CSQLConnection *_pConn, CLASSIMAGES cd, BOOL bDelete = FALSE)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;
    hr = SetupClassImagesAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        unsigned long lLen;

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassImages");

        err = JetSetCurrentIndex(session, tableid, "ObjectId_idx");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &cd.dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {      
                    err = JetMakeKey(session, tableid, &cd.dObjectId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);

                        while (err == JET_errSuccess)
                        {
                            CLASSIMAGES cd2;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_OBJECTID), 
                                        &cd2.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_ARRAYPOS), 
                                        &cd2.iArrayPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                            err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_PROPERTYID), 
                                        &cd2.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                            if (JET_errSuccess > err)
                                goto Exit;
                    
                            if (cd.dObjectId == cd2.dObjectId &&
                                cd.iPropertyId == cd2.iPropertyId &&
                                cd.iArrayPos == cd2.iArrayPos)
                            {
                                err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                                if (err == JET_errSuccess)
                                {
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_OBJECTID), 
                                        &cd.dObjectId, sizeof(__int64), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_ARRAYPOS), 
                                        &cd.iArrayPos, sizeof(DWORD), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_PROPERTYID), 
                                        &cd.iPropertyId, sizeof(DWORD), 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_IMAGEVALUE), 
                                        cd.pBuffer, cd.dwBufferLen, 0, NULL);
                                    if (err < JET_errSuccess)
                                        goto Exit;

                                    if (bDelete)
                                        err = JetDelete(session, tableid);
                                    else
                                        err = JetUpdate(session, tableid, NULL, 0, NULL );
                                }
                                break;
                            }
                            else
                                err = JetMove(session, tableid, JET_MoveNext, 0);
                        }
                    }
                }
            }
        }
    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  InsertClassImages
//
//***************************************************************************

HRESULT InsertClassImages (CSQLConnection *_pConn, SQL_ID dObjectId, DWORD iPropID, DWORD iArrayPos, 
                           BYTE *pStream = NULL, DWORD dwLength = 0)
{
    HRESULT hr = 0;

    JET_ERR err = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupClassImagesAccessor(pConn);
    if (SUCCEEDED(hr))
    {
   
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ClassImages");

        CLASSIMAGES cd;

        cd.dObjectId = dObjectId;
        cd.iArrayPos = iArrayPos;
        cd.iPropertyId = iPropID;
        cd.pBuffer = pStream;
        cd.dwBufferLen = dwLength;

        hr = UpdateClassImages(pConn, cd, FALSE);
        if (FAILED(hr))
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_OBJECTID), 
                    &dObjectId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_ARRAYPOS), 
                    &iArrayPos, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_PROPERTYID), 
                    &iPropID, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CLASSIMAGES_COL_IMAGEVALUE), 
                    pStream, dwLength, 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );

            }
        }
        hr = WBEM_S_NO_ERROR;
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;

}

//***************************************************************************
//
//  SetupIndexDataAccessor
//
//***************************************************************************

HRESULT SetupIndexDataAccessor (CSQLConnection *_pConn, DWORD dwStorage, DWORD &dwPos, LPWSTR * lpTableName)
{
    HRESULT hr = 0;
    char szTable [30];
    wchar_t wTable[30];
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_COLTYP coltype;
    JET_TABLEID tableid;
    JET_ERR err = JET_errSuccess; 
    switch(dwStorage)
    {
        case WMIDB_STORAGE_STRING:
            dwPos = SQL_POS_INDEXSTRING;
            tableid = pConn->GetTableID(L"IndexStringData");
            strcpy(szTable, "IndexStringData");
            coltype = JET_coltypText;
            break;
        case WMIDB_STORAGE_REFERENCE:
            dwPos = SQL_POS_INDEXREF;
            strcpy(szTable, "IndexRefData");
            tableid = pConn->GetTableID(L"IndexRefData");
            coltype = JET_coltypCurrency;
            break;
        case WMIDB_STORAGE_NUMERIC:
            dwPos = SQL_POS_INDEXNUMERIC;
            strcpy(szTable, "IndexNumericData");
            tableid = pConn->GetTableID(L"IndexNumericData");
            coltype = JET_coltypCurrency;
            break;
        case WMIDB_STORAGE_REAL:
            dwPos = SQL_POS_INDEXREAL;
            coltype = JET_coltypIEEEDouble;
            strcpy(szTable, "IndexRealData");
            tableid = pConn->GetTableID(L"IndexRealData");
            break;
        default:
            dwPos = 0;
            break;
    }

    if (dwPos != 0)
    {
        swprintf(wTable, L"%S", szTable);

        if (!tableid)
        {
            JET_SESID session;
            JET_DBID dbid;      
            BOOL bCreate = FALSE;

            // Get the session and table ID
            // and create columns as needed.

            session = pConn->GetSessionID();
            dbid = pConn->GetDBID();
            err = JetOpenTable (session, dbid, szTable, NULL, 0, JET_bitTableUpdatable, &tableid);
            if (err < JET_errSuccess)
            {
                CSQLExecute::GetWMIError(err);
                bCreate = TRUE;
                err = JetCreateTable(session, dbid, szTable, 10, 80, &tableid);
                if (err < JET_errSuccess)
                {
                    hr = CSQLExecute::GetWMIError(err);
                    goto Exit;
                }

            }
            else
                pConn->SetTableID(wTable, tableid);

            JET_COLUMNID colid;
        
            hr = AddColumnToTable(pConn, tableid, szTable, L"ObjectId", INDEXTBL_COL_OBJECTID, JET_coltypCurrency, 
                JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
            if (SUCCEEDED(hr))
                pConn->SetColumnID(tableid, INDEXTBL_COL_OBJECTID, colid);
            else
                goto Exit;
            hr = AddColumnToTable(pConn, tableid, szTable, L"PropertyId", INDEXTBL_COL_PROPERTYID, JET_coltypLong, 
                JET_bitColumnNotNULL, sizeof(DWORD), &colid);
            if (SUCCEEDED(hr))
                pConn->SetColumnID(tableid, INDEXTBL_COL_PROPERTYID, colid);
            else
                goto Exit;
            hr = AddColumnToTable(pConn, tableid, szTable, L"ArrayPos", INDEXTBL_COL_ARRAYPOS, JET_coltypLong, 
                JET_bitColumnNotNULL, sizeof(DWORD), &colid);
            if (SUCCEEDED(hr))
                pConn->SetColumnID(tableid, INDEXTBL_COL_ARRAYPOS, colid);
            else
                goto Exit;
            hr = AddColumnToTable(pConn, tableid, szTable, L"IndexValue", INDEXTBL_COL_INDEXVALUE, coltype, 
                 0, 2, &colid);

            if (SUCCEEDED(hr))
                pConn->SetColumnID(tableid, INDEXTBL_COL_INDEXVALUE, colid);
            else
                goto Exit;

            err = JetCreateIndex(session, tableid, "ObjectId_idx", JET_bitIndexDisallowNull,"+ObjectId\0", 11, 100);
            if (err >= JET_errSuccess || JET_errIndexDuplicate == err)
            {
                err = JetCreateIndex(session, tableid, "PropertyId_idx", JET_bitIndexDisallowNull ,"+PropertyId\0", 13, 100);
                if (err >= JET_errSuccess || JET_errIndexDuplicate == err)
                {
                    err = JetCreateIndex(session, tableid, "IndexValue_idx", JET_bitIndexDisallowNull ,"+IndexValue\0", 13, 80);        
                    if (err == JET_errIndexDuplicate)
                        err = JET_errSuccess;
                }
            }
            if (err >= JET_errSuccess && bCreate)
            {
                err = JetCloseTable(session, tableid);
                if (err >= JET_errSuccess)
                {
                    hr = SetupIndexDataAccessor(_pConn,dwStorage, dwPos, lpTableName);
                }
            }

        }    

        if (lpTableName)
        {
            *lpTableName = new wchar_t [wcslen(wTable) + 1];
            if (!*lpTableName)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto Exit;
            }
            wcscpy(*lpTableName, wTable);
        }
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;   

}

//***************************************************************************
//
//  GetIndexData
//
//***************************************************************************

HRESULT GetIndexData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                        DWORD dwPos, INDEXDATA &is)
{
    HRESULT hr = WBEM_E_FAILED;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    BYTE buff[512];
    long lInLen = 0;
    unsigned long lLen;
    is.Clear();

    JET_ERR err = JET_errSuccess; 
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_OBJECTID), 
                &is.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_PROPERTYID), 
                &is.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_ARRAYPOS), 
                &is.iArrayPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    switch(dwPos)
    {
        case SQL_POS_INDEXNUMERIC:
        case SQL_POS_INDEXREF:
            lInLen = sizeof(SQL_ID);
            break;
        case SQL_POS_INDEXSTRING:
            lInLen = MAX_STRING_WIDTH;
            break;
        case SQL_POS_INDEXREAL:
            lInLen = sizeof(double);
            break;
    }

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                buff, MAX_STRING_WIDTH, &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    if (lLen > 0)
    {
        switch(dwPos)
        {
            case SQL_POS_INDEXNUMERIC:
            case SQL_POS_INDEXREF:
                is.dValue = *((SQL_ID *)buff);
                break;
           case SQL_POS_INDEXSTRING:
                is.sValue = SysAllocString((LPWSTR)buff);
                if (!is.sValue)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    goto exit;
                }
                break;
           case SQL_POS_INDEXREAL:
                is.rValue = *((double *)buff);
                break;
           default:
                break; // don't set anything - the caller doesn't want this data.
        }
    }

    hr = WBEM_S_NO_ERROR;
exit:

    return hr;
}


//***************************************************************************
//
//  GetFirst_IndexData
//
//***************************************************************************

HRESULT GetFirst_IndexData (CSQLConnection *_pConn, SQL_ID dObjectId, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    // Locate the first row for this ObjectID and bind the data.
    
    JET_SESID session = pConn->GetSessionID();

    JET_ERR err = JetSetCurrentIndex(session, tableid, "ObjectId_idx");
    if (err == JET_errSuccess)
    {
        err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
        err = JetMakeKey(session, tableid, &dObjectId, sizeof(SQL_ID), JET_bitNewKey);
        if (err == JET_errSuccess)
        {
            err = JetSeek( session, tableid, JET_bitSeekEQ  );
            if (err == JET_errSuccess)
            {
                err = JetMakeKey(session, tableid, &dObjectId, sizeof(SQL_ID), JET_bitNewKey);
                if (err == JET_errSuccess)
                {
                    err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                    if (err == JET_errSuccess)
                    {      
                        hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                    }
                }
            }
        }
    }
    if (err != JET_errSuccess)
        hr = WBEM_E_NOT_FOUND;

    return hr;

}


//***************************************************************************
//
//  GetFirst_IndexDataByProperty
//
//***************************************************************************

HRESULT GetFirst_IndexDataByProperty (CSQLConnection *_pConn, SQL_ID PropertyId, INDEXDATA &cd,
                                   JET_TABLEID tableid, DWORD dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.    

    JET_SESID session = pConn->GetSessionID();

    JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
    if (err == JET_errSuccess)
    {
        err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
        err = JetMakeKey(session, tableid, &PropertyId, sizeof(DWORD), JET_bitNewKey);
        if (err == JET_errSuccess)
        {
            err = JetSeek( session, tableid, JET_bitSeekEQ  );
            if (err == JET_errSuccess)
            {
                err = JetMakeKey(session, tableid, &PropertyId, sizeof(DWORD), JET_bitNewKey);
                if (err == JET_errSuccess)
                {
                    err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                    if (err == JET_errSuccess)
                    {      
                        hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                    }
                }
            }
        }
    }
    if (err != JET_errSuccess)
        hr = WBEM_E_NOT_FOUND;

    return hr;

}

//***************************************************************************
//
//  OpenEnum_IndexDataNumeric
//
//***************************************************************************

HRESULT OpenEnum_IndexDataNumeric (CSQLConnection *_pConn, SQL_ID dStartAt, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_NUMERIC, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d(lpTableName);    

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dStartAt, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekGE  );
                if (err == JET_errSuccess)
                {
                    hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  GetFirst_IndexDataNumeric
//
//***************************************************************************

HRESULT GetFirst_IndexDataNumeric (CSQLConnection *_pConn, SQL_ID dNumericValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_NUMERIC, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d(lpTableName);    

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dNumericValue, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dNumericValue, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  OpenEnum_IndexDataString
//
//***************************************************************************

HRESULT OpenEnum_IndexDataString (CSQLConnection *_pConn, LPWSTR lpStartAt, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_STRING, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d(lpTableName);    

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, lpStartAt, wcslen(lpStartAt)*2+2, JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekGE  );
                if (err == JET_errSuccess)
                {
                    hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  GetFirst_IndexDataString
//
//***************************************************************************

HRESULT GetFirst_IndexDataString (CSQLConnection *_pConn, LPWSTR lpStringValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_STRING, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d(lpTableName);

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, lpStringValue, wcslen(lpStringValue)*2+2, JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, lpStringValue, wcslen(lpStringValue)*2+2, JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            if (err == JET_errSuccess)
                                hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  OpenEnum_IndexDataReal
//
//***************************************************************************

HRESULT OpenEnum_IndexDataReal (CSQLConnection *_pConn, double dStartAt, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_REAL, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d(lpTableName);    

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dStartAt, sizeof(double), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekGE  );
                if (err == JET_errSuccess)
                {
                    hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  GetFirst_IndexDataReal
//
//***************************************************************************

HRESULT GetFirst_IndexDataReal (CSQLConnection *_pConn, double dValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_REAL, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d(lpTableName);

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dValue, sizeof(double), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dValue, sizeof(double), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  OpenEnum_IndexDataRef
//
//***************************************************************************

HRESULT OpenEnum_IndexDataRef (CSQLConnection *_pConn, SQL_ID dStartAt, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_REFERENCE, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {

        CDeleteMe <wchar_t> d(lpTableName);    

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dStartAt, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekGE  );
                if (err == JET_errSuccess)
                {
                    hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}
//***************************************************************************
//
//  GetFirst_IndexDataRef
//
//***************************************************************************

HRESULT GetFirst_IndexDataRef  (CSQLConnection *_pConn, SQL_ID dValue, INDEXDATA &cd,
                                   JET_TABLEID &tableid, DWORD &dwPos)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    LPWSTR lpTableName;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this value and bind the data.

    hr = SetupIndexDataAccessor(pConn, WMIDB_STORAGE_REFERENCE, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {

        CDeleteMe <wchar_t> d(lpTableName);

        JET_SESID session = pConn->GetSessionID();
        tableid = pConn->GetTableID(lpTableName);

        JET_ERR err = JetSetCurrentIndex(session, tableid, "IndexValue_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dValue, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dValue, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            if (err == JET_errSuccess)
                                hr = GetIndexData(pConn, session, tableid, dwPos, cd);
                        }
                    }
                }
            }
        }
        if (err != JET_errSuccess)
            hr = WBEM_E_NOT_FOUND;
    }

    return hr;

}

//***************************************************************************
//
//  GetNext_IndexData
//
//***************************************************************************

HRESULT GetNext_IndexData (CSQLConnection *_pConn, JET_TABLEID tableid, DWORD dwPos, INDEXDATA &cd)
{
    HRESULT hr = 0;

    cd.Clear();

    JET_ERR err = JET_errSuccess;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    JET_SESID session = pConn->GetSessionID();

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetIndexData(pConn, session, tableid, dwPos, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}

//***************************************************************************
//
//  UpdateIndexData
//
//***************************************************************************

HRESULT UpdateIndexData (CSQLConnection *_pConn, INDEXDATA is, LPWSTR lpTableName, DWORD dwStorage, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    JET_ERR err = JET_errSuccess;    
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(lpTableName);
    unsigned long lLen;

    err = JetSetCurrentIndex(session, tableid, "ObjectId_idx");
    if (err == JET_errSuccess)
    {
        err = JetMakeKey(session, tableid, &is.dObjectId, sizeof(__int64), JET_bitNewKey);
        if (err == JET_errSuccess)
        {
            err = JetSeek( session, tableid, JET_bitSeekEQ  );
            if (err == JET_errSuccess)
            {      
                err = JetMakeKey(session, tableid, &is.dObjectId, sizeof(__int64), JET_bitNewKey);
                if (err == JET_errSuccess)
                {
                    err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);

                    while (err == JET_errSuccess)
                    {
                        INDEXDATA is2;
                        err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_ARRAYPOS), 
                                    &is2.iArrayPos, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                        if (JET_errSuccess > err)
                            goto Exit;
                        err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_PROPERTYID), 
                                    &is2.iPropertyId, sizeof(DWORD), &lLen, JET_bitRetrieveCopy, NULL);
                        if (JET_errSuccess > err)
                            goto Exit;
                    
                        if (is.iPropertyId == is2.iPropertyId &&
                            is.iArrayPos == is2.iArrayPos)
                        {
                            err = JetPrepareUpdate(session, tableid, JET_prepReplace);
                            if (err == JET_errSuccess)
                            {
                                switch(dwStorage)
                                {
                                  case WMIDB_STORAGE_STRING:
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                                        is.sValue, wcslen(is.sValue)*2+2, 0, NULL);
                                    break;
                                  case WMIDB_STORAGE_NUMERIC:
                                  case WMIDB_STORAGE_REFERENCE:
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                                        &is.dValue, sizeof(SQL_ID), 0, NULL);
                                    break;
                                  case WMIDB_STORAGE_REAL:
                                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                                        &is.rValue, sizeof(SQL_ID), 0, NULL);
                                    break;
                                }
                                if (bDelete)
                                    err = JetDelete(session, tableid);
                                else
                                    err = JetUpdate(session, tableid, NULL, 0, NULL );
                            }
                            break;
                        }
                        else
                            err = JetMove(session, tableid, JET_MoveNext, 0);
                    }
                }
            }
        }
    }

Exit:
    hr = CSQLExecute::GetWMIError(err);
    return hr;
}

//***************************************************************************
//
//  InsertIndexData
//
//***************************************************************************

HRESULT InsertIndexData (CSQLConnection *_pConn, SQL_ID dObjectId, DWORD iPropID, DWORD iArrayPos, 
                           LPWSTR lpValue, SQL_ID dValue, double rValue, DWORD dwStorage)
{
    HRESULT hr = 0;
    DWORD dwPos = 0;
    LPWSTR lpTableName = NULL;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;

    hr = SetupIndexDataAccessor(pConn, dwStorage, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        if (dwStorage == WMIDB_STORAGE_IMAGE || !lpTableName)
            return 0;

        CDeleteMe <wchar_t> d (lpTableName);

        INDEXDATA is;
    
        is.dObjectId = dObjectId;
        is.iPropertyId = iPropID;
        is.iArrayPos = iArrayPos;
        is.sValue = SysAllocString(lpValue);
        if (lpValue && !is.sValue)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            goto Exit;
        }
        is.dValue = dValue;
        is.rValue = rValue;

        if (FAILED(UpdateIndexData(pConn, is, lpTableName, dwStorage)))
        {      
            JET_SESID session = pConn->GetSessionID();
            JET_TABLEID tableid = pConn->GetTableID(lpTableName);

            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_OBJECTID), 
                    &dObjectId, sizeof(__int64), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_ARRAYPOS), 
                    &iArrayPos, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_PROPERTYID), 
                    &iPropID, sizeof(DWORD), 0, NULL);
                if (err < JET_errSuccess)
                    goto Exit;
                switch(dwStorage)
                {
                  case WMIDB_STORAGE_STRING:
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                        lpValue, wcslen(lpValue)*2+2, 0, NULL);
                    break;
                  case WMIDB_STORAGE_NUMERIC:
                  case WMIDB_STORAGE_REFERENCE:
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                        &dValue, sizeof(SQL_ID), 0, NULL);
                    break;
                  case WMIDB_STORAGE_REAL:
                    err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, INDEXTBL_COL_INDEXVALUE), 
                        &rValue, sizeof(double), 0, NULL);
                    break;
                }
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetUpdate(session, tableid, NULL, 0, NULL );

            }
        }
        is.Clear();
        hr = WBEM_S_NO_ERROR;
    }
Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  SetupContainerObjsAccessor
//
//***************************************************************************

HRESULT SetupContainerObjsAccessor (CSQLConnection *_pConn)
{        
    HRESULT hr = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = JET_errSuccess; 
    if (!pConn->GetTableID(L"ContainerObjs"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "ContainerObjs";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();
        err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"ContainerObjs", tableid);
        
        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ContainerId", CONTAINEROBJS_COL_CONTAINERID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CONTAINEROBJS_COL_CONTAINERID, colid);
        else
            goto Exit;
        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ContaineeId", CONTAINEROBJS_COL_CONTAINEEID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, CONTAINEROBJS_COL_CONTAINEEID, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "ContainerObjs_PK", JET_bitIndexDisallowNull,"+ContainerId\0", 14, 100);
        if (err >= JET_errSuccess || JET_errIndexDuplicate == err) 
        {
            err = JetCreateIndex(session, tableid, "Containee_idx", JET_bitIndexDisallowNull ,"+ContaineeId\0", 14, 100);        
            if (err == JET_errIndexDuplicate)
                err = JET_errSuccess;
        }

        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupContainerObjsAccessor(_pConn);
            }
        }
    }    

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;

}

//***************************************************************************
//
//  GetContainerObjsData
//
//***************************************************************************

HRESULT GetContainerObjsData (CSQLConnection *_pConn, JET_SESID session, JET_TABLEID tableid,
                CONTAINEROBJ &co)
{
    HRESULT hr = WBEM_E_FAILED;
    JET_ERR err = JET_errSuccess; 
    CESEConnection *pConn = (CESEConnection *)_pConn;
    unsigned long lLen;

    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CONTAINEROBJS_COL_CONTAINERID), 
                &co.dContainerId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;
    err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, CONTAINEROBJS_COL_CONTAINEEID), 
                &co.dContaineeId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);
    if (JET_errSuccess > err)
        goto exit;

    hr = WBEM_S_NO_ERROR;

exit:
    return hr;
}

//***************************************************************************
//
//  GetFirst_ContainerObjs
//
//***************************************************************************

HRESULT GetFirst_ContainerObjs (CSQLConnection *_pConn, SQL_ID dContainerId, CONTAINEROBJ &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupContainerObjsAccessor(pConn);
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ContainerObjs");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "ContainerObjs_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dContainerId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dContainerId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            hr = GetContainerObjsData(pConn, session, tableid, cd);
                        }
                    }
                }
            }
        }
        hr = CSQLExecute::GetWMIError(err);
    }
    return hr;    
}

//***************************************************************************
//
//  GetFirst_ContainerObjsByContainee
//
//***************************************************************************

HRESULT GetFirst_ContainerObjsByContainee (CSQLConnection *_pConn, SQL_ID dContaineeId, CONTAINEROBJ &cd)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupContainerObjsAccessor(pConn);
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ContainerObjs");

        // Use the default index
        // Grab the first row,
        // and stuff it into the OBJECTMAP object.

        JET_ERR err = JetSetCurrentIndex(session, tableid, "Containee_idx");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dContaineeId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetMakeKey(session, tableid, &dContaineeId, sizeof(__int64), JET_bitNewKey);
                    if (err == JET_errSuccess)
                    {
                        err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);
                        if (err == JET_errSuccess)
                        {      
                            if (err == JET_errSuccess)
                                hr = GetContainerObjsData(pConn, session, tableid, cd);
                        }
                    }
                }
            }
        }

        hr = CSQLExecute::GetWMIError(err);
    }

    return hr;
    
}

//***************************************************************************
//
//  GetNext_ContainerObjs
//
//***************************************************************************

HRESULT GetNext_ContainerObjs (CSQLConnection *_pConn, CONTAINEROBJ &cd)
{
    HRESULT hr = 0;

    cd.Clear();

    JET_ERR err  = JET_errSuccess;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ContainerObjs");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
        hr = GetContainerObjsData(pConn, session, tableid, cd);
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;
}


//***************************************************************************
//
//  UpdateContainerObjs
//
//***************************************************************************

HRESULT UpdateContainerObjs (CSQLConnection *_pConn, CONTAINEROBJ co, BOOL bDelete = FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    JET_ERR err = JET_errSuccess;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    if (!bDelete)
        return 0;

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"ContainerObjs");

    err = JetSetCurrentIndex(session, tableid, "ContainerObjs_PK");
    if (err == JET_errSuccess)
    {
        err = JetMakeKey(session, tableid, &co.dContainerId, sizeof(__int64), JET_bitNewKey);
        if (err == JET_errSuccess)
        {
            err = JetSeek( session, tableid, JET_bitSeekEQ  );
            if (err == JET_errSuccess)
            {
                err = JetMakeKey(session, tableid, &co.dContainerId, sizeof(__int64), JET_bitNewKey);
                if (err == JET_errSuccess)
                {
                    err = JetSetIndexRange(session, tableid, JET_bitRangeInclusive|JET_bitRangeUpperLimit);

                    while (err == JET_errSuccess)
                    {     
                        CONTAINEROBJ co2;
                        hr = GetContainerObjsData(pConn, session, tableid, co2);                
                        if (co.dContainerId == co2.dContainerId &&
                            co.dContaineeId == co2.dContaineeId)
                        {
                            err = JetDelete(session, tableid);
                            break;
                        }
                        err = JetMove(session, tableid, JET_MoveNext, 0);
                    }
                }
            }
        }
    }

    hr = CSQLExecute::GetWMIError(err);
    return hr;
}

//***************************************************************************
//
//  InsertContainerObjs
//
//***************************************************************************

HRESULT InsertContainerObjs(CSQLConnection *pConn2, SQL_ID dContainerId, SQL_ID dContaineeId)
{

    HRESULT hr = 0;
    JET_ERR err = 0;
    CESEConnection *pConn = (CESEConnection *)pConn2;
    hr = SetupContainerObjsAccessor(pConn);
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"ContainerObjs");

        BOOL bFound = FALSE;
        CONTAINEROBJ co;
        hr = GetFirst_ContainerObjs(pConn2, dContainerId, co);
        while (SUCCEEDED(hr))
        {
            if (co.dContainerId == dContainerId &&
                co.dContaineeId == dContaineeId)
            {
                bFound = TRUE;
                break;
            }

            hr = GetNext_ContainerObjs(pConn2, co);
        }

        hr = WBEM_S_NO_ERROR;

        if (!bFound)
        {
            err = JetPrepareUpdate(session, tableid, JET_prepInsert);
            if (err == JET_errSuccess)
            {
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CONTAINEROBJS_COL_CONTAINERID), 
                            &dContainerId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;
                err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, CONTAINEROBJS_COL_CONTAINEEID), 
                            &dContaineeId, sizeof(__int64), 0, NULL );
                if (err < JET_errSuccess)
                    goto Exit;

                err = JetUpdate(session, tableid, NULL, 0, NULL );
                hr = WBEM_S_NO_ERROR;
            }
        }    
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  SetupAutoDeleteAccessor
//
//***************************************************************************

HRESULT SetupAutoDeleteAccessor(CSQLConnection *_pConn)
{
    HRESULT hr = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = JET_errSuccess; 
    if (!pConn->GetTableID(L"AutoDelete"))
    {
        JET_SESID session;
        JET_TABLEID tableid;
        JET_DBID dbid;
        const LPSTR lpTbl = "AutoDelete";
        BOOL bCreate = FALSE;

        // Get the session and table ID
        // and create columns as needed.

        session = pConn->GetSessionID();
        dbid = pConn->GetDBID();
        err = JetOpenTable (session, dbid, lpTbl, NULL, 0, JET_bitTableUpdatable, &tableid);
        if (err < JET_errSuccess)
        {
            CSQLExecute::GetWMIError(err);
            bCreate = TRUE;
            err = JetCreateTable(session, dbid, lpTbl, 10, 80, &tableid);
            if (err < JET_errSuccess)
            {
                hr = CSQLExecute::GetWMIError(err);
                goto Exit;
            }
        }
        else
            pConn->SetTableID(L"AutoDelete", tableid);
        
        JET_COLUMNID colid;

        hr = AddColumnToTable(pConn, tableid, lpTbl, L"ObjectId", CONTAINEROBJS_COL_CONTAINERID, JET_coltypCurrency, 
            JET_bitColumnNotNULL, sizeof(SQL_ID), &colid);
        if (SUCCEEDED(hr))
            pConn->SetColumnID(tableid, AUTODELETE_COL_OBJECTID, colid);
        else
            goto Exit;

        err = JetCreateIndex(session, tableid, "AutoDelete_PK", JET_bitIndexPrimary | JET_bitIndexUnique,"+ObjectId\0", 11, 100);
        if (err >= JET_errSuccess || JET_errIndexHasPrimary == err) 
            err = JET_errSuccess;

        if (err >= JET_errSuccess && bCreate)
        {
            err = JetCloseTable(session, tableid);
            if (err >= JET_errSuccess)
            {
                hr = SetupAutoDeleteAccessor(_pConn);
            }
        }
    }    

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;
}

//***************************************************************************
//
//  OpenEnum_AutoDelete
//
//***************************************************************************

HRESULT OpenEnum_AutoDelete (CSQLConnection *_pConn, AUTODELETE &ad)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // Locate the first row for this ObjectID and bind the data.

    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = SetupAutoDeleteAccessor(pConn);    
    if (SUCCEEDED(hr))
    {
        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"AutoDelete");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "AutoDelete_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMove(session, tableid, JET_MoveFirst, 0);
            if (err == JET_errSuccess)
            {
                ULONG lLen;
                err = JetRetrieveColumn(session, tableid, pConn->GetColumnID(tableid, AUTODELETE_COL_OBJECTID), 
                            &ad.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL);            
            }
        }

        hr = CSQLExecute::GetWMIError(err);
    }

    return hr;

}


//***************************************************************************
//
//  GetNext_AutoDelete
//
//***************************************************************************

HRESULT GetNext_AutoDelete(CSQLConnection *_pConn, AUTODELETE &ad)
{
    HRESULT hr = 0;

    JET_ERR err  = JET_errSuccess;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"AutoDelete");

    err = JetMove(session, tableid, JET_MoveNext, 0);
    if (err == JET_errSuccess)
    {
        ULONG lLen;
        hr = CSQLExecute::GetWMIError(JetRetrieveColumn(session, tableid, 
                    pConn->GetColumnID(tableid, AUTODELETE_COL_OBJECTID), 
                    &ad.dObjectId, sizeof(SQL_ID), &lLen, JET_bitRetrieveCopy, NULL));
    }
    else
        hr = WBEM_E_NOT_FOUND;

    return hr;

}

//***************************************************************************
//
//  InsertAutoDelete
//
//***************************************************************************

HRESULT InsertAutoDelete(CSQLConnection *_pConn, SQL_ID dObjectId)
{
    HRESULT hr = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    JET_ERR err = 0;
    hr = SetupAutoDeleteAccessor(pConn);
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"AutoDelete");

        hr = DeleteAutoDelete(pConn, dObjectId);

        err = JetPrepareUpdate(session, tableid, JET_prepInsert);
        if (err == JET_errSuccess)
        {
            err = JetSetColumn(session, tableid, pConn->GetColumnID(tableid, AUTODELETE_COL_OBJECTID), 
                        &dObjectId, sizeof(__int64), 0, NULL );
            if (err < JET_errSuccess)
                goto Exit;

            err = JetUpdate(session, tableid, NULL, 0, NULL );
            hr = WBEM_S_NO_ERROR;
        }
    }

Exit:
    if (err)
        hr = CSQLExecute::GetWMIError(err);

    return hr;

}

//***************************************************************************
//
//  DeleteAutoDelete
//
//***************************************************************************

HRESULT DeleteAutoDelete(CSQLConnection *_pConn, SQL_ID dObjectId)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Locate the first row for this ObjectID and bind the data.

    hr = SetupAutoDeleteAccessor(pConn);
    if (SUCCEEDED(hr))
    {

        JET_SESID session = pConn->GetSessionID();
        JET_TABLEID tableid = pConn->GetTableID(L"AutoDelete");

        JET_ERR err = JetSetCurrentIndex(session, tableid, "AutoDelete_PK");
        if (err == JET_errSuccess)
        {
            err = JetSetIndexRange(session, tableid, JET_bitRangeRemove);
            err = JetMakeKey(session, tableid, &dObjectId, sizeof(__int64), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {
                    err = JetDelete(session, tableid);
                }
            }
        }

        hr = CSQLExecute::GetWMIError(err);

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;
    }

    return hr;    
}

//***************************************************************************
//
//  CleanAutoDeletes
//
//***************************************************************************

HRESULT CleanAutoDeletes(CSQLConnection *pConn)
{
    HRESULT hr;
    AUTODELETE ad;
    SQLIDs ids;

    // These are objects created with the AUTODELETE handle.
    // If we have any left, we must have crashed before
    // the handles could be tidied up.

    hr = OpenEnum_AutoDelete(pConn, ad);
    while (SUCCEEDED(hr))
    {
        ids.push_back(ad.dObjectId);

        hr = GetNext_AutoDelete(pConn, ad);
    }

    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < ids.size(); i++)
        {
            hr = DeleteObjectMap(pConn, ids.at(i));
            if (FAILED(hr))
                break;
        }
    }

    return hr;
}

// Delete functions

//***************************************************************************
//
//  DeleteIndexDataByObjectId
//
//***************************************************************************

HRESULT DeleteIndexDataByObjectId (CSQLConnection *_pConn, DWORD dwStorage, SQL_ID dObjectId)
{
    HRESULT hr = 0;
    LPWSTR lpTableName = NULL;
    DWORD dwPos = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    hr = SetupIndexDataAccessor(pConn, dwStorage, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d (lpTableName);

        if (!lpTableName || dwStorage == WMIDB_STORAGE_IMAGE)
            return 0;

        INDEXDATA is;
        JET_TABLEID tableid = pConn->GetTableID(lpTableName);

        hr = GetFirst_IndexData(pConn, dObjectId, is, tableid, dwPos);
        while (SUCCEEDED(hr))
        {
            hr = UpdateIndexData(pConn, is, lpTableName, dwStorage, TRUE);
            if (FAILED(hr))
            {
                is.Clear();
                break;
            }

            hr = GetNext_IndexData(pConn, tableid, dwPos, is);
            if (hr == WBEM_E_NOT_FOUND)
            {
                hr = WBEM_S_NO_ERROR;
                break;
            }
            if (is.dObjectId != dObjectId)
                break;
        } 
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  DeletePropertyMap
//
//***************************************************************************

HRESULT DeletePropertyMap (CSQLConnection *_pConn, DWORD iPropertyId)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    PROPERTYMAP pm;
    hr = GetFirst_PropertyMap(pConn, iPropertyId, pm);
    if (SUCCEEDED(hr))
    {
        hr = DeleteReferenceProperties(_pConn, iPropertyId);
        if (SUCCEEDED(hr))
            hr = UpdatePropertyMap(pConn, pm, TRUE);
    }
    else
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  DeleteClassData
//
//***************************************************************************

HRESULT DeleteClassData (CSQLConnection *_pConn, DWORD iPropertyId, SQL_ID dObjectId=0, DWORD iArrayPos = -1)
{
    HRESULT hr = 0;

    CLASSDATA cd;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = GetFirst_ClassDataByPropertyId(pConn, iPropertyId, cd);
    while (SUCCEEDED(hr))
    {
        BOOL bMatch = TRUE;
        if (dObjectId && dObjectId != cd.dObjectId)
            bMatch = FALSE;
        if ((int)iArrayPos >= 0 && iArrayPos != cd.iArrayPos)
            bMatch = FALSE;

        if (bMatch)
        {   
            hr = UpdateClassData_Internal(pConn, cd, TRUE);
            if (FAILED(hr))
            {
                cd.Clear();
                break;
            }
        }
        
        hr = GetNext_ClassData(pConn, cd);

    }
    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}
//***************************************************************************
//
//  DeleteClassImages
//
//***************************************************************************

HRESULT DeleteClassImages (CSQLConnection *_pConn, DWORD iPropertyId, SQL_ID dObjectId=0, DWORD iArrayPos = -1)
{
    HRESULT hr = 0;
    CLASSIMAGES cd;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    hr = GetFirst_ClassImagesByPropertyId(pConn, iPropertyId, cd);
    while (SUCCEEDED(hr))
    {
        BOOL bMatch = TRUE;
        if (dObjectId && dObjectId != cd.dObjectId)
            bMatch = FALSE;
        if (iArrayPos != -1 && iArrayPos != cd.iArrayPos)
            bMatch = FALSE;

        if (bMatch)
        {   
            hr = UpdateClassImages(pConn, cd, TRUE);
            if (FAILED(hr))
            {
                cd.Clear();
                break;
            }
        }
        
        hr = GetNext_ClassImages(pConn, cd);
        if (cd.iPropertyId != iPropertyId)
            break;
    }
    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  DeleteContainerObjs
//
//***************************************************************************

HRESULT DeleteContainerObjs (CSQLConnection *_pConn, SQL_ID dContainerId, SQL_ID dContaineeId )
{
    HRESULT hr = 0;
    CONTAINEROBJ co;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    if (dContainerId)
        hr = GetFirst_ContainerObjs (pConn, dContainerId, co);
    else
        hr = GetFirst_ContainerObjsByContainee (pConn, dContaineeId, co);

    while (SUCCEEDED(hr))
    {
        BOOL bMatch = TRUE;
        if (dContainerId && co.dContainerId != dContainerId)
            bMatch = FALSE;
        if (dContaineeId && co.dContaineeId != dContaineeId)
            bMatch = FALSE;

        if (bMatch)
            hr = UpdateContainerObjs (pConn, co, TRUE);

        hr = GetNext_ContainerObjs(pConn, co);
    }
    
    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  DeleteQualifiers
//
//***************************************************************************

HRESULT DeleteQualifiers (CSQLConnection *_pConn, SQL_ID dObjectId)
{
    HRESULT hr = 0;

    CLASSDATA cd;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = GetFirst_ClassData (pConn, dObjectId, cd);
    while (SUCCEEDED(hr))
    {
        // Delete any properties with the qualifier flag set.

        if (cd.iFlags & 2)
        {
            hr = UpdateClassData_Internal(pConn, cd, TRUE);
            if (FAILED(hr))
            {
                cd.Clear();
                goto Exit;
            }
        }
        hr = GetNext_ClassData(pConn, cd);
        if (cd.dObjectId != dObjectId)
            break;
    }
    hr = WBEM_S_NO_ERROR;

Exit:

    return hr;
}
//***************************************************************************
//
//  DeletePropQualifiers
//
//***************************************************************************

HRESULT DeletePropQualifiers (CSQLConnection *_pConn, DWORD iPropertyId)
{
    HRESULT hr = 0;

    CLASSDATA cd;
    CESEConnection *pConn = (CESEConnection *)_pConn;
    hr = GetFirst_ClassDataByRefId (pConn, ((SQL_ID)iPropertyId), cd);
    while (SUCCEEDED(hr))
    {
        // Delete any properties with the qualifier flag set.
        if (cd.iFlags & 2)
        {
            hr = UpdateClassData_Internal(pConn, cd, TRUE);
            if (FAILED(hr))
            {
                cd.Clear();
                goto Exit;
            }
        }
        hr = GetNext_ClassData(pConn, cd);
        if (cd.iPropertyId != iPropertyId)
            break;
    }
    hr = WBEM_S_NO_ERROR;

Exit:
    return hr;
}



//***************************************************************************
//
//  DeleteIndexData
//
//***************************************************************************

HRESULT DeleteIndexData (CSQLConnection *_pConn, DWORD dwStorage, DWORD iPropertyId, SQL_ID dObjectId=0, DWORD iArrayPos = -1)
{
    HRESULT hr = 0;
    LPWSTR lpTableName = NULL;
    DWORD dwPos = 0;
    CESEConnection *pConn = (CESEConnection *)_pConn;

    hr = SetupIndexDataAccessor(pConn, dwStorage, dwPos, &lpTableName);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d (lpTableName);
        if (!lpTableName || dwStorage == WMIDB_STORAGE_IMAGE)
            return 0;

        INDEXDATA is;
        JET_TABLEID tableid = pConn->GetTableID(lpTableName);

        hr = GetFirst_IndexDataByProperty(pConn, iPropertyId, is, tableid, dwPos);
        while (SUCCEEDED(hr))
        {
            BOOL bMatch = TRUE;
            if (dObjectId && is.dObjectId != dObjectId)
                bMatch = FALSE;
            if (iArrayPos != -1 && iArrayPos != is.iArrayPos)
                bMatch = FALSE;

            if (bMatch)
            {
                hr = UpdateIndexData(pConn, is, lpTableName, dwStorage, TRUE);
                if (FAILED(hr))
                {
                    is.Clear();
                    break;
                }
            }

            hr = GetNext_IndexData(pConn, tableid, dwPos, is);
            if (hr == WBEM_E_NOT_FOUND)
            {
                hr = WBEM_S_NO_ERROR;
                break;
            }
            if (iPropertyId != is.iPropertyId)
                break;
        }    
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}


//***************************************************************************
//
//  DeleteObjectMap
//
//***************************************************************************

HRESULT DeleteObjectMap (CSQLConnection *_pConn, SQL_ID dObjectId, 
                         BOOL bDecRef, SQL_ID dScope)
{
    HRESULT hr = 0;

    CESEConnection *pConn = (CESEConnection *)_pConn;
    // Set up the maximum ref count that can exist
    // to physically delete the object.

    int iMaxRef = 0;
    if (bDecRef)
        iMaxRef = 1;
    OBJECTMAP oj;
    int i;

    BOOL bDelete = FALSE;

    hr = GetFirst_ObjectMap(pConn, dObjectId, oj);
    if (SUCCEEDED(hr))
    {
        DEBUGTRACE((LOG_WBEMCORE, "DeleteObjectMap %S (RefCount = %ld)\n", oj.sObjectPath, oj.iRefCount));

        // If we are calling this internally,
        // we need to determine if this is an embedded object
        // or a reference.  If an embedded object,
        // always delete it.  If a reference, only delete
        // if its in a deleted state, and ref count = 0
        // Otherwise, decrement its ref count.

        if (dScope)
        {
            if (oj.dObjectScopeId == dScope)
            {
                bDelete = TRUE;
            }
            else
            {
                if (bDecRef)
                {
                    if (oj.iRefCount > 0)
                        oj.iRefCount--;
                }
                if (oj.iObjectState == 2 &&
                    !oj.iRefCount)
                {
                    bDelete = TRUE;
                }
            }
        }
        else
        {
            if (oj.iRefCount <= iMaxRef)
            {
                bDelete = TRUE;
            }
            else
            {
                if (bDecRef)
                    oj.iRefCount--;
                oj.iObjectState = 2;
            }
        }

        // wprintf(L">> Deleting %I64d (%s) \n", dObjectId, (LPWSTR)oj.sObjectKey);
        
        if (bDelete)
        {
            // Delete from the INDEX tables...

            hr = DeleteIndexDataByObjectId(pConn, WMIDB_STORAGE_STRING, dObjectId);
            if (FAILED(hr))
                goto Exit;

            hr = DeleteIndexDataByObjectId(pConn, WMIDB_STORAGE_NUMERIC, dObjectId);
            if (FAILED(hr))
                goto Exit;

            hr = DeleteIndexDataByObjectId(pConn, WMIDB_STORAGE_REAL, dObjectId);
            if (FAILED(hr))
                goto Exit;

            hr = DeleteIndexDataByObjectId(pConn, WMIDB_STORAGE_REFERENCE, dObjectId);
            if (FAILED(hr))
                goto Exit;

            // If this was an autodelete handle, kill it.

            hr = DeleteAutoDelete(pConn, dObjectId);
            if (FAILED(hr))
                goto Exit;

            hr = DeleteReferencePropertiesByClass(pConn, dObjectId);
            if (FAILED(hr))
                goto Exit;

            hr = DeleteScopeMap(pConn, dObjectId);
            if (FAILED(hr))
                goto Exit;

            // DELETE CLASSDATA AND CLASSIMAGES

            SQLIDs ids;
            CLASSDATA cd;
            hr = GetFirst_ClassData(pConn, dObjectId, cd);
            while (SUCCEEDED(hr))
            {
                // If this is a reference or an embedded object,
                // decrement ref counts or delete

                if (cd.dRefId)
                    ids.push_back(cd.dRefId);

                hr = UpdateClassData_Internal(pConn, cd, TRUE);
                if (FAILED(hr))
                {
                    cd.Clear();
                    break;
                }

                hr = GetNext_ClassData(pConn, cd);
                if (cd.dObjectId != dObjectId)
                {
                    cd.Clear();
                    break;
                }
            }

            if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;
            if (FAILED(hr))
                goto Exit;

            CLASSIMAGES ci;
            hr = GetFirst_ClassImages(pConn, dObjectId, ci);
            while (SUCCEEDED(hr))
            {
                hr = UpdateClassImages(pConn, ci, TRUE);
                if (FAILED(hr))
                {
                    ci.Clear();
                    break;
                }

                hr = GetNext_ClassImages(pConn, ci);
                if (ci.dObjectId != dObjectId)
                    break;
            }

            if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;
            if (FAILED(hr))
                goto Exit;

            // If this is a class, delete CLASSMAP AND PROPERTYMAP

            if (oj.dClassId == 1)
            {
                PROPERTYMAP pm;
                hr = GetFirst_PropertyMapByClass(pConn, dObjectId, pm);
                while (SUCCEEDED(hr))
                {
                    hr = UpdatePropertyMap(pConn, pm, TRUE);
                    if (FAILED(hr))
                    {
                        pm.Clear();
                        goto Exit;
                    }

                    hr = GetNext_PropertyMap(pConn, pm);
                    if (dObjectId != pm.dClassId)
                        break;
                }
                
                if (hr == WBEM_E_NOT_FOUND)
                    hr = WBEM_S_NO_ERROR;

                if (FAILED(hr))
                    goto Exit;

                hr = DeleteClassKeys(pConn, dObjectId);
                
                CLASSMAP cm;
                hr = GetFirst_ClassMap(pConn, dObjectId, cm);
                if (SUCCEEDED(hr))
                    hr = UpdateClassMap(pConn, cm, TRUE);  
                cm.Clear();
            }

            if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;
            if (FAILED(hr))
                goto Exit;

            // Remove container memberships
            hr = DeleteContainerObjs (pConn, dObjectId, 0);
            if (SUCCEEDED(hr))
                hr = DeleteContainerObjs (pConn, 0, dObjectId);

            // Delete or decrement ref counts on
            // references and embedded objects

            for (i = 0; i < ids.size(); i++)
            {
                hr = DeleteObjectMap(_pConn, ids.at(i), TRUE, dObjectId);
                if (FAILED(hr))
                    goto Exit;
            }

            // FINALLY, delete from ObjectMap.

            if (SUCCEEDED(hr))
                hr = UpdateObjectMap(pConn, oj, TRUE);
        }
        
        // Otherwise, set the state of this object to "Deleted"
        // and leave it in the tables.

        else
            hr = UpdateObjectMap(pConn, oj);

        oj.Clear();
    }
    else
        hr = WBEM_S_NO_ERROR;

Exit:

    oj.Clear();
    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::Delete
//
//***************************************************************************

HRESULT CWmiDbSession::Delete(IWmiDbHandle *pHandle, CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwNumRows = 0;
    CWmiDbHandle *pTmp = (CWmiDbHandle *)pHandle;
    bool bLocalTrans = false;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    SQL_ID dID = pTmp->m_dObjectId;
    SQL_ID dClassID = pTmp->m_dClassId;

    hr = VerifyObjectLock(dID, pTmp->m_dwHandleType, pTmp->m_dwVersion);
    if (FAILED(hr) && IsDistributed())
    {
        if (LockExists(dID))
            hr = WBEM_S_NO_ERROR;
    }
       
    if (SUCCEEDED(hr))
    {      
        if (!pConn && m_pController)
        {
            bLocalTrans = true;
            hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
        }

        if (SUCCEEDED(hr))
        {
            hr = Delete(dID, pConn);

            if (bLocalTrans && m_pController)
                GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
        }
    }
    
    return hr;

}

HRESULT AddToSQLIDs (SQL_ID dID, SQLIDs *pToDel)
{
    HRESULT hr = 0;

    BOOL bFound = FALSE;
    for (int i = 0; i < pToDel->size(); i++)
    {
        if (pToDel->at(i) == dID)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
        pToDel->push_back(dID);

    return hr;
}

HRESULT GetIdsToDelete (SQL_ID dID, CSQLConnection *pConn, SQLIDs *pToDel)
{
    HRESULT hr  = 0;

    OBJECTMAP om;
    SQLIDs NewList;

    hr = GetFirst_ObjectMap(pConn, dID, om);
    if (SUCCEEDED(hr))
    {
        // Decrement ref counts on reference properties.

        CLASSDATA cd;
        SQLIDs ToUpd;
        hr = GetFirst_ClassDataByRefId(pConn, dID, cd);
        while (hr == WBEM_S_NO_ERROR)
        {
            ToUpd.push_back(cd.dObjectId);
            hr = GetNext_ClassData(pConn, cd);
            if (cd.dRefId != dID)
            {
                cd.Clear();
                break;
            }
        }

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;


        for (int i = 0; i < ToUpd.size(); i++)
        {
            hr = GetFirst_ObjectMap(pConn, ToUpd.at(i), om);
            if (hr == WBEM_S_NO_ERROR)
            {
                if (om.iRefCount > 0)
                    om.iRefCount--;
                hr = UpdateObjectMap(pConn, om);
                om.Clear();
            }
        }

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

        hr = GetFirst_ObjectMapByScope(pConn, dID, om);
        while (hr == WBEM_S_NO_ERROR)
        {
            SQL_ID dSubId = om.dObjectId;

            AddToSQLIDs(dSubId, &NewList);

            hr = GetNext_ObjectMap(pConn, om);
            if (om.dObjectScopeId != dID)
                break;
        }

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

        // Classes

        if (SUCCEEDED(hr))
        {
            hr = GetFirst_ObjectMapByClass(pConn, dID, om);
            while (hr == WBEM_S_NO_ERROR)
            {
                SQL_ID dSubId = om.dObjectId;
                AddToSQLIDs(dSubId, &NewList);

                hr = GetNext_ObjectMap(pConn, om);
                if (om.dClassId != dID)
                {
                    om.Clear();
                    break;
                }
            }
        }

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

        // Then all subclasses

        if (SUCCEEDED(hr))
        {
            CLASSMAP cd;

            hr = GetFirst_ClassMapBySuperClass(pConn, dID, cd);
            while (hr == WBEM_S_NO_ERROR)
            {      
                SQL_ID dSubId = cd.dClassId;
                AddToSQLIDs(dSubId, &NewList);

                hr = GetNext_ClassMap(pConn, cd);
                if (dID != cd.dSuperClassId)
                {
                    cd.Clear();
                    break;
                }
            }

            if (hr == WBEM_E_NOT_FOUND)
                hr = WBEM_S_NO_ERROR;
        }

        for (int j = 0; j < NewList.size(); j++)
        {
            hr = GetIdsToDelete(NewList.at(j), pConn, pToDel);
            AddToSQLIDs(NewList.at(j), pToDel);
        }        

        om.Clear();
    }

    return hr;
}

HRESULT CheckSecurity(SQLIDs *pToDel, CWmiDbSession *pSession, CSQLConnection *pConn)
{
    HRESULT hr = 0;

    for (int i = 0; i < pToDel->size(); i++)
    {
        OBJECTMAP om;
        hr = GetFirst_ObjectMap(pConn, pToDel->at(i), om);
        if (SUCCEEDED(hr))
        {
            hr = pSession->VerifyObjectSecurity(pConn, pToDel->at(i), om.dClassId, om.dObjectScopeId, 0, 
                pSession->GetSchemaCache()->GetWriteToken(pToDel->at(i), om.dClassId));
            if (FAILED(hr) && hr != WBEM_E_NOT_FOUND)
                break;
            om.Clear();
        }
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::Delete
//
//***************************************************************************

HRESULT CWmiDbSession::Delete(SQL_ID dID, CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int iPos = 0, iMax = 100;
    SQL_ID dClassId = 0, dScopeId = 0, dObjId = 0;
    DWORD dwNumRows = 0;
    wchar_t wBuffer1[550], wBuffer2[550];
    int iToUpd = 0, iToDel = 0;
    SQLIDs ToDel;
   
    // We need to enumerate every object that is underneath this one
    // in the hierarchy, and delete them one-by-one.
    // This function needs to recurse through all children,
    // remove the data from the tables, fix reference counts,
    // and clean the caches.  If all that worked, we can commit.
    // =========================================================== 

    hr = GetIdsToDelete(dID, pConn, &ToDel);
    if (SUCCEEDED(hr))
    {
        AddToSQLIDs(dID, &ToDel);
        hr = CheckSecurity(&ToDel, this, pConn);
        if (SUCCEEDED(hr))
        {
            for (int i = 0; i < ToDel.size(); i++)
            {
                hr = DeleteObjectMap(pConn, ToDel.at(i));
                if (FAILED(hr))
                    break;
                GetSchemaCache()->DeleteClass(ToDel.at(i));                
                CleanCache(ToDel.at(i));            
            }
        }
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::GetClassObject
//
//***************************************************************************

HRESULT CWmiDbSession::GetClassObject (CSQLConnection *pConn, SQL_ID dClassId, IWbemClassObject **ppObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _IWmiObject *pNew = NULL;
    SQL_ID dParentId = 0;

    // All we need to do is read the blob from the database.
    // This should be cached where space allows.

    CLASSMAP cm;

    BOOL bNeedToRelease = FALSE;

    if (!pConn && m_pController)
    {
        hr = GetSQLCache()->GetConnection(&pConn, 0, IsDistributed());
        bNeedToRelease = TRUE;
        if (FAILED(hr))
            return hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = GetFirst_ClassMap(pConn, dClassId, cm);
        if (SUCCEEDED(hr))
        {
            if (cm.dSuperClassId != 0 && cm.dSuperClassId != 1)
            {
                hr = GetObjectCache()->GetObject(cm.dSuperClassId, ppObj);
                if (FAILED(hr))
                    hr = GetClassObject(pConn, cm.dSuperClassId, ppObj);
                if (SUCCEEDED(hr))
                {
                    // Merge the class part.

                    _IWmiObject *pObj = (_IWmiObject *)*ppObj;
                    if (pObj)
                    {
                        hr = pObj->Merge (WMIOBJECT_MERGE_FLAG_CLASS, cm.dwBufferLen, cm.pClassBuffer, &pNew);
                        pObj->Release();
                        if (SUCCEEDED(hr))
                            *ppObj = pNew;
                    }
                    else
                        hr = WBEM_E_FAILED;
                }
            }
            else
            {
                _IWmiObject *pObj = NULL;
                hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                        IID__IWmiObject, (void **)&pObj);
                if (SUCCEEDED(hr))
                {
                    hr = pObj->Merge(WMIOBJECT_MERGE_FLAG_CLASS, cm.dwBufferLen, cm.pClassBuffer, &pNew);
                    pObj->Release();
                    if (SUCCEEDED(hr))
                        *ppObj = pNew;
                }
            }

            cm.Clear();
        }
    }

    if (bNeedToRelease && pConn && m_pController)
    {
        GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::GetObjectData
//
//***************************************************************************

HRESULT CWmiDbSession::GetObjectData (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dClassId, 
                                        SQL_ID dScopeId, DWORD dwHandleType, DWORD &dwVersion, 
                                        IWbemClassObject **ppObj, BOOL bNoDefaults, LPWSTR lpInKey,
                                        BOOL bGetSD )
{    
    HRESULT hr = WBEM_S_NO_ERROR;
    _bstr_t sClassPath;
    DWORD dwGenus = 1;
    DWORD dwRows;
    bool bUsedCache = false;
    LPWSTR lpKey = NULL;

    DWORD dwType = 0, dwVer = 0;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    //  Validate version if this is a versioned handle.
    // ================================================-

    try
    {
        if (!bNoDefaults)
        {
            hr = VerifyObjectLock(dObjectId, dwHandleType, dwVersion);
            if (FAILED(hr) && IsDistributed())
            {
                if (LockExists(dObjectId))
                    hr = WBEM_S_NO_ERROR;
            }
        }

        if (SUCCEEDED(hr))
        {    
            // Check the object cache to see if this
            // IWbemClassObject is already loaded.
            // Never cache an instance of __Instances
            // =====================================

            if (dClassId == INSTANCESCLASSID)
                hr = WBEM_E_NOT_FOUND;
            else
                hr = GetObjectCache()->GetObject(dObjectId, ppObj);

            if (FAILED(hr))
            {
                // Otherwise, we need to hit the database.
                // =======================================            

                VARIANT vTemp;
                VariantInit(&vTemp);

                if (dClassId == 1)
                {                    
                    dwGenus = 1;
                    dClassId = dObjectId;
                }
                else
                    dwGenus = 2;

                SQL_ID dTemp = 0;
                                

                // We now have an object path and class ID.
                // Now we have to instantiate a new IWbemClassObject,
                // populate all the system properties
                // ==================================================

                IWbemClassObject *pClass = NULL;
                IWbemClassObject *pTemp = NULL;

                hr = GetObjectCache()->GetObject(dClassId, &pClass);
                if (SUCCEEDED(hr))
                    bUsedCache = true;
                else
                    hr = GetClassObject(pConn, dClassId, &pClass);

                if (SUCCEEDED(hr))
                {
                    if (dwGenus == 2)
                    {
                        if (pClass)
                            pClass->SpawnInstance(0, &pTemp);    
                        {
                            if (pTemp)
                                hr = GetSchemaCache()->DecorateWbemObj(m_sMachineName, m_sNamespacePath, 
                                    dScopeId, pTemp, dClassId);
                        }                    
                    }
                    else
                    {
                        pTemp = pClass;

                        hr = GetSchemaCache()->DecorateWbemObj(m_sMachineName, m_sNamespacePath, 
                             dScopeId, pTemp, dClassId);

                    }

                    // Special case if this is an __Instances container,
                    // We need to instantiate an instance of __Instances,
                    // and plug the class name into the ClassName property.
                    // ===================================================

                    if (dClassId == INSTANCESCLASSID)
                    {
                        _bstr_t sName, sPath;
                        SQL_ID dTemp1, dTemp2;
                        DWORD dwFlags;

                        hr = GetSchemaCache()->GetClassInfo (dObjectId, sPath, dTemp1, dTemp2, dwFlags, &sName);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT vTemp;
                            VariantInit(&vTemp);
                            vTemp.bstrVal = SysAllocString(sName);                            
                            vTemp.vt = VT_BSTR;
                            pTemp->Put(L"ClassName", 0, &vTemp, CIM_STRING);
                            VariantClear(&vTemp);
                            *ppObj = pTemp;
                        }
                        else
                        {
                            pTemp->Release();
                            pTemp = NULL;
                        }
                    }
                    else
                    {    
                        if (lpInKey)
                        {
                            hr = GetObjectData2 (pConn, dObjectId, dClassId, dScopeId, pTemp, FALSE, NULL);
                            lpKey = lpInKey;
                        }
                        else
                            hr = GetObjectData2 (pConn, dObjectId, dClassId, dScopeId, pTemp, FALSE, &lpKey);

                        if (dwGenus == 2)
                        {                        
                            if (!bUsedCache && SUCCEEDED(hr) && !((dwHandleType & 0xF00) == WMIDB_HANDLE_TYPE_NO_CACHE))
                            {
                                if (lpKey)
                                {
                                    LPWSTR lpEqual = wcsrchr(lpKey, L'.');
                                    if (!lpEqual)
                                        lpEqual = wcsrchr(lpKey, L'=');

                                    if (lpEqual)
                                    {
                                        LPWSTR lpPath = Macro_CloneLPWSTR(lpKey);
                                        if (lpPath)
                                        {
                                            CDeleteMe <wchar_t> d10 (lpPath);
                                            int iPos = lpEqual - lpKey;
                                            lpPath[iPos] = L'\0';
                                       
                                            GetObjectCache()->PutObject(dClassId, 1, dScopeId, lpPath, 1, pClass);
                                        }
                                    }
                                }
                            }
                        }

                        if (FAILED(hr))
                        {
                            pTemp->Release();
                            pTemp = NULL;
                        }

                        *ppObj = pTemp;

                    }

                    if (dwGenus == 2 && pClass)
                        pClass->Release();
                }

                // If all that worked, try and cache this object.
                // ==============================================

                if (SUCCEEDED(hr) && ppObj && (dwHandleType & 0xF00) && dClassId != INSTANCESCLASSID)
                {
                    // This is allowed to fail, since its *just* a cache.
                    if ((dwHandleType & 0xF00) != WMIDB_HANDLE_TYPE_NO_CACHE && lpKey)
                    {
                        bool bCacheType = ((dwHandleType & 0xF00) == WMIDB_HANDLE_TYPE_STRONG_CACHE) ? 1 : 0;
                    
                        GetObjectCache()->PutObject(dObjectId, dClassId, dScopeId, lpKey, bCacheType, *ppObj);
                    }
                }
            
                if (!lpInKey)
                    delete lpKey;
            }
            else
            {
                // Make sure the decoration is up-to-date.
                hr = GetSchemaCache()->DecorateWbemObj(m_sMachineName, m_sNamespacePath, 
                    dScopeId, *ppObj, dClassId);
            }

            // Populate the security descriptor, if requested
            if (SUCCEEDED(hr) && bGetSD)
            {
                BOOL bNeedToRelease = FALSE;

                if (!pConn && m_pController)
                {
                    hr = GetSQLCache()->GetConnection(&pConn, 0, FALSE);
                    bNeedToRelease = TRUE;
                    if (FAILED(hr))
                    {
                        (*ppObj)->Release();
                        *ppObj = NULL;
                        return hr;
                    }
                }

                PNTSECURITY_DESCRIPTOR  pSD = NULL;
                DWORD dwLen = 0;
                if (SUCCEEDED(CSQLExecProcedure::GetSecurityDescriptor(pConn, dObjectId, &pSD, dwLen, 0)))
                {
                    ((_IWmiObject *)*ppObj)->WriteProp(L"__SECURITY_DESCRIPTOR", 0, dwLen, dwLen, CIM_UINT8|CIM_FLAG_ARRAY, pSD);

                    delete pSD;
                }
                if (bNeedToRelease && pConn && m_pController)
                {
                    GetSQLCache()->ReleaseConnection(pConn, hr, FALSE);
                }    

            }
        }
    }
    catch (...)
    {
        hr = WBEM_E_SHUTTING_DOWN;
    }

    return hr;

}

//***************************************************************************
//
//  CWmiDbSession::GetObjectData2 
//
//***************************************************************************

HRESULT CWmiDbSession::GetObjectData2 (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, 
            IWbemClassObject *pObj, BOOL bNoDefaults, LPWSTR * lpKey)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL bNeedToRelease = FALSE;

    if (!pObj)
        return WBEM_E_INVALID_PARAMETER;

    if (!pConn && m_pController)
    {
        hr = GetSQLCache()->GetConnection(&pConn, 0, FALSE);
        bNeedToRelease = TRUE;
        if (FAILED(hr))
            return hr;
    }
    
    if (SUCCEEDED(hr))
    {
        if (lpKey)
        {
            OBJECTMAP oj;
    
            hr = GetFirst_ObjectMap(pConn, dObjectId, oj);
            if (SUCCEEDED(hr))
            {
                if (oj.iObjectState == 2)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "Object %I64d is marked as deleted\n", dObjectId));
                    oj.Clear();
                    return WBEM_E_NOT_FOUND;
                }

                if (oj.sObjectKey)
                {
                    LPWSTR lpKey2 = new wchar_t [wcslen(oj.sObjectKey)+1];
                    if (lpKey2)
                    {
                        wcscpy(lpKey2, oj.sObjectKey);
                        *lpKey = lpKey2;
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                    hr = WBEM_E_INVALID_OBJECT;

                oj.Clear();
            }
            else
                hr = WBEM_E_NOT_FOUND;
        }

        if (FAILED(hr))
            goto Exit;

        if (dClassId != 1 && dClassId != dObjectId)
        {
            CLASSDATA cd;
            DWORD dwRows;
            BOOL bBigText = FALSE, bObjProp = FALSE;
            int i = 0;
            Properties props;

            typedef std::vector<CLASSDATA *> CDs;
            CDs cds;

            hr = GetFirst_ClassData(pConn, dObjectId, cd, -1, TRUE, GetSchemaCache());
            while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
            {
                SetObjectData(pConn, pObj, this, &((CWmiDbController *)m_pController)->SchemaCache, 
                    cd, FALSE, bBigText, &bObjProp, bNoDefaults);
                if (bObjProp)
                {
                    CLASSDATA *pCD = new CLASSDATA;
                    *pCD = cd;
                    cds.push_back(pCD);
                }
                hr = GetNext_ClassData(pConn, cd, -1, TRUE, GetSchemaCache());
            }
            hr = WBEM_S_NO_ERROR;

            // The embedded object properties, since there will 
            // be a move next conflict if we try to retrieve them earlier.

            for (i = 0; i < cds.size(); i++)
            {
                CLASSDATA *pCD = cds.at(i);
                SetObjectData(pConn, pObj, this, &((CWmiDbController *)m_pController)->SchemaCache, 
                    *pCD, FALSE, bBigText, NULL, bNoDefaults);
                pCD->Clear();
                delete pCD;
            }

            //if (bBigText || GetSchemaCache()->HasImageProp(dClassId))
            {
                // Finally, anything stored as long binary data.

                DWORD dwSecurity = 0;
                GetSchemaCache()->GetPropertyID(L"__SECURITY_DESCRIPTOR", 1, 
                    0, REPDRVR_IGNORE_CIMTYPE, dwSecurity);

                CLASSIMAGES ci;

                hr = GetFirst_ClassImages(pConn, dObjectId, ci);
                while (SUCCEEDED(hr))
                {
                    if (ci.iPropertyId != dwSecurity)
                    {
                        // Stuff this blob into the object.
                        cd.Copy(ci);
                        SetObjectData(pConn, pObj, this, &((CWmiDbController *)m_pController)->SchemaCache, 
                            cd, TRUE, bBigText, NULL, bNoDefaults);
                        cd.Clear();
                    }

                    hr = GetNext_ClassImages(pConn, ci);
                    if (ci.dObjectId != dObjectId)
                        break;
                }
            }
            hr = WBEM_S_NO_ERROR;
        }
    }

    hr = WBEM_S_NO_ERROR;

Exit:
    if (bNeedToRelease && pConn && m_pController)
    {
        GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
    }    

    return hr;    
}

//***************************************************************************
//
//  CSQLExecProcedure::GetHierarchy
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetHierarchy(CSQLConnection *pConn, SQL_ID dClassId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    // Not required for Jet.
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetNextUnkeyedPath
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetNextUnkeyedPath(CSQLConnection *pConn, SQL_ID dClassId, _bstr_t &sNewPath)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Generate a GUID for this object, and use this an artificial path.
    // The format doesn't matter to us internally.

    GUID guid;
    LPWSTR lpNewPath;

    hr = CoCreateGuid(&guid);
    if (SUCCEEDED(hr))
    {
        hr = UuidToString(&guid, &lpNewPath);
        if (SUCCEEDED(hr))
            sNewPath = lpNewPath;
        RpcStringFree(&lpNewPath);
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetNextKeyhole
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetNextKeyhole(CSQLConnection *pConn2, DWORD iPropertyId, SQL_ID &dNewId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CESEConnection *pConn = (CESEConnection *)pConn2;

    // Here we need to select the largest value plus one currently
    // in the table for this property ID.
    // If null, its one.

    dNewId = 1;
    JET_SESID session = pConn->GetSessionID();
    JET_TABLEID tableid = pConn->GetTableID(L"IndexNumericData");
 
    JET_ERR err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
    if (err == JET_errSuccess)
    {
        err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
        if (err == JET_errSuccess)
        {
            err = JetSeek( session, tableid, JET_bitSeekEQ  );
            if (err == JET_errSuccess)
            {      
                err = JetMove(session, tableid, JET_MoveLast, 0);
                if (err == JET_errSuccess)
                {
                    INDEXDATA is;
                    hr = GetIndexData(pConn, session, tableid, 0, is);
                    dNewId = is.dValue + 1;
                }
            }
        }
    }
    else
        hr = CSQLExecute::GetWMIError(err);

    if (dNewId == 1)
    {
        tableid = pConn->GetTableID(L"IndexStringData");
        err = JetSetCurrentIndex(session, tableid, "PropertyId_idx");
        if (err == JET_errSuccess)
        {
            err = JetMakeKey(session, tableid, &iPropertyId, sizeof(DWORD), JET_bitNewKey);
            if (err == JET_errSuccess)
            {
                err = JetSeek( session, tableid, JET_bitSeekEQ  );
                if (err == JET_errSuccess)
                {      
                    err = JetMove(session, tableid, JET_MoveLast, 0);
                    if (err == JET_errSuccess)
                    {                        
                        INDEXDATA is;
                        hr = GetIndexData(pConn, session, tableid, 0, is);                        
                        dNewId = _wtoi64(is.sValue) + 1;
                    }
                }
            }
        }
        else
            hr = CSQLExecute::GetWMIError(err);
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetObjectIdByPath
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetObjectIdByPath (CSQLConnection *pConn, LPCWSTR lpPath, 
                                              SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID *dScopeId, BOOL *bDeleted)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    if (!pConn)
        return WBEM_E_INVALID_PARAMETER;

    if (!dObjectId && lpPath)
        dObjectId = CRC64::GenerateHashValue(lpPath);

    OBJECTMAP oj;

    hr = GetFirst_ObjectMap(pConn, dObjectId, oj);
    if (SUCCEEDED(hr))
    {
        dClassId = oj.dClassId;
        if (dScopeId)
            *dScopeId = oj.dObjectScopeId;
        if (bDeleted)
        {
            if (oj.iObjectState == 2)
                *bDeleted = TRUE;
        }
        oj.Clear();
    }

    return hr;

}

//***************************************************************************
//
//  CSQLExecProcedure::DeleteProperty
//
//***************************************************************************

HRESULT CSQLExecProcedure::DeleteProperty(CSQLConnection *pConn, DWORD iPropertyId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This has to clean up reference counts, if any of these properties
    // are references.  If its an embedded object, we need to remove
    // all of the instances.
    // Remove data from all index tables and Class Data.  Then remove from
    // PropertyMap.
    // We can't allow them to delete a key property if there are instances.
    // We have to delete qualifiers on the property (Flags&2, RefId = PropertyId)
    // If a reference, delete object if the ref count is zero.
    
    PROPERTYMAP pm;

    hr = GetFirst_PropertyMap(pConn, iPropertyId, pm);
    if (SUCCEEDED(hr))
    {
        if (pm.iFlags & REPDRVR_FLAG_KEY)
        {
            // We can't remove a key when the class has instances.           
            CLASSDATA cd;

            hr = GetFirst_ClassDataByPropertyId (pConn, iPropertyId, cd);
            if (SUCCEEDED(hr))
                hr = WBEM_E_INVALID_OPERATION;
            cd.Clear();
        }

        if (SUCCEEDED(hr))
        {
            // We need to decrement reference counts on 
            // references we are deleting, delete 
            // deleted references with a zero ref count,
            // and remove embedded objects

            if (pm.iStorageTypeId == CIM_OBJECT || pm.iStorageTypeId == CIM_REFERENCE)
            {
                CLASSDATA cd;                
                SQLIDs ids;

                hr = GetFirst_ClassDataByPropertyId (pConn, iPropertyId, cd);
                while (SUCCEEDED(hr))
                {
                    ids.push_back(cd.dObjectId);
                    hr = GetNext_ClassData(pConn, cd);
                    if (cd.iPropertyId != iPropertyId)
                    {
                        cd.Clear();
                        break;
                    }
                }

                for (int i = 0; i < ids.size(); i++)
                {
                    // Embedded objects are deleted
                    
                    if (pm.iStorageTypeId == CIM_OBJECT)
                        hr = DeleteObjectMap(pConn, ids.at(i), TRUE);

                    // References have ref counts decremented.
                    // If their reference count is zero, and they are
                    // marked deleted, delete them now.
                    
                    else if (pm.iStorageTypeId == CIM_REFERENCE)
                    {
                        OBJECTMAP oj;
                        hr = GetFirst_ObjectMap(pConn, ids.at(i), oj);
                        if (SUCCEEDED(hr))
                        {
                            if (oj.iRefCount <= 1 && oj.iObjectState == 2)
                                hr = DeleteObjectMap(pConn, ids.at(i), TRUE);
                            else
                            {
                                oj.iRefCount--;
                                hr = UpdateObjectMap(pConn, oj, FALSE);
                            }
                            oj.Clear();
                        }
                    }
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            // Remove all data for this property..

            if (pm.iFlags & (REPDRVR_FLAG_KEY + REPDRVR_FLAG_INDEXED))
                hr = DeleteIndexData(pConn, pm.iStorageTypeId, iPropertyId);

            if (SUCCEEDED(hr))
            {
                // Delete qualifiers on this property.

                hr = DeletePropQualifiers(pConn, iPropertyId);
                if (SUCCEEDED(hr))
                {
                    // Delete all associated data.
                    hr = DeleteClassData(pConn, iPropertyId);
                    if (SUCCEEDED(hr))
                    {
                        hr = DeleteClassImages(pConn, iPropertyId);
                        if (SUCCEEDED(hr))
                        {
                            hr = DeletePropertyMap(pConn, iPropertyId);
                            if (SUCCEEDED(hr))
                            {
                                hr = DeleteClassKeys(pConn, 0, iPropertyId);
                            }
                        }
                    }
                }
            }
        }

    }
    else
        hr = WBEM_S_NO_ERROR; // OK if not found.

    return hr;
}


//***************************************************************************
//
//  CSQLExecProcedure::DeleteInstanceData
//
//***************************************************************************

HRESULT CSQLExecProcedure::DeleteInstanceData (CSQLConnection *pConn, SQL_ID dObjectId, 
                                               DWORD iPropertyId, DWORD iPos)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IRowset *pIRowset = NULL;
    DWORD dwNumRows = 0;
    wchar_t wSQL[512];    

    PROPERTYMAP pm;

    IAccessor *pAccessor = NULL;
    HACCESSOR hAcc = NULL;

    hr = GetFirst_PropertyMap(pConn, iPropertyId, pm);
    if (SUCCEEDED(hr))
    {
        if (pm.iFlags & (REPDRVR_FLAG_KEY + REPDRVR_FLAG_NOT_NULL))
            hr = WBEM_E_INVALID_OPERATION;
        else
        {
            if (pm.iStorageTypeId == CIM_OBJECT || pm.iStorageTypeId == CIM_REFERENCE)
            {
                CLASSDATA cd;
                SQLIDs ids;

                hr = GetFirst_ClassDataByPropertyId (pConn, iPropertyId, cd);
                while (SUCCEEDED(hr))
                {
                    ids.push_back(cd.dObjectId);
                    hr = GetNext_ClassData(pConn, cd);
                    if (cd.iPropertyId != iPropertyId)
                    {
                        cd.Clear();
                        break;
                    }
                }

                for (int i = 0; i < ids.size(); i++)
                {
                    // Embedded objects are deleted
                    
                    if (pm.iStorageTypeId == CIM_OBJECT)
                        hr = DeleteObjectMap(pConn, ids.at(i), TRUE);

                    // References have ref counts decremented.
                    // If their reference count is zero, and they are
                    // marked deleted, delete them now.
                    
                    else if (pm.iStorageTypeId == CIM_REFERENCE)
                    {
                        OBJECTMAP oj;
                        hr = GetFirst_ObjectMap(pConn, ids.at(i), oj);
                        if (SUCCEEDED(hr))
                        {
                            if (oj.iRefCount <= 1 && oj.iObjectState == 2)
                                hr = DeleteObjectMap(pConn, ids.at(i), TRUE);
                            else
                            {
                                oj.iRefCount--;
                                hr = UpdateObjectMap(pConn, oj, FALSE);
                            }
                            oj.Clear();
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = DeleteIndexData(pConn, pm.iStorageTypeId, iPropertyId, dObjectId, iPos);
                if (SUCCEEDED(hr))
                {
                    hr = DeleteClassImages(pConn, iPropertyId, dObjectId, iPos);
                    if (SUCCEEDED(hr))
                        hr = DeleteClassData(pConn, iPropertyId, dObjectId, iPos);
                }

            }
        }
    }
    
    return hr;
}


//***************************************************************************
//
//  CSQLExecProcedure::CheckKeyMigration
//
//***************************************************************************

HRESULT CSQLExecProcedure::CheckKeyMigration(CSQLConnection *pConn, LPWSTR lpObjectKey, LPWSTR lpClassName, SQL_ID dClassId,
                            SQL_ID dScopeID, SQL_ID *pIDs, DWORD iNumIDs)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure this object does not already exist with the same scope and different ClassID.
    
    SQL_ID dObjId = CRC64::GenerateHashValue(lpObjectKey);

    OBJECTMAP oj;
    hr = GetFirst_ObjectMap(pConn, dObjId, oj);
    if (SUCCEEDED(hr))
    {
        if (oj.dObjectScopeId == dScopeID &&
            dClassId != oj.dClassId)
            hr = WBEM_E_ALREADY_EXISTS;

        oj.Clear();
    }
    else if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;    // OK if not found.
    
    return hr;
}

HRESULT CSQLExecProcedure::NeedsToCheckKeyMigration(BOOL &bCheck)
{
    bCheck = TRUE;
    return 0;
}


HRESULT CSQLExecProcedure::Execute (CSQLConnection *pConn, LPCWSTR lpProcName, CWStringArray &arrValues,
                                    IRowset **ppIRowset)
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CSQLExecProcedure::HasInstances
//
//***************************************************************************

HRESULT CSQLExecProcedure::HasInstances(CSQLConnection *pConn, SQL_ID dClassId, SQL_ID *pDerivedIds, DWORD iNumDerived, BOOL &bInstancesExist)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    bInstancesExist = FALSE;

    // We need to query the table for any instance of this class
    // or any of its children.

    OBJECTMAP oj;

    hr = GetFirst_ObjectMapByClass(pConn, dClassId, oj);
    if (SUCCEEDED(hr))
    {
        while (SUCCEEDED(hr))
        {
            if (oj.iObjectState == 0)
            {
                bInstancesExist = TRUE;
                break;
            }
            hr = GetNext_ObjectMap(pConn, oj);
            if (oj.dClassId != dClassId)
                break;
        }
        oj.Clear();
    }

    if (!bInstancesExist)
    {
        for (int i = 0; i < iNumDerived; i++)
        {
            hr = GetFirst_ObjectMapByClass(pConn, pDerivedIds[i], oj);
            while (hr == WBEM_S_NO_ERROR)
            {
                if (oj.iObjectState == 0)
                {
                    bInstancesExist = TRUE;
                    break;
                }
                hr = GetNext_ObjectMap(pConn, oj);
                if (pDerivedIds[i] != oj.dClassId)
                    break;
            }
        }
    }
    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::InsertClass
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertClass (CSQLConnection *pConn, LPCWSTR lpClassName, LPCWSTR lpObjectKey, LPCWSTR lpObjectPath, SQL_ID dScopeID,
             SQL_ID dParentClassId, SQL_ID dDynasty, DWORD iState, BYTE *pClassBuff, DWORD dwClassBuffLen, DWORD iClassFlags, DWORD iInsertFlags, SQL_ID &dNewId)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    SQL_ID dClassId = 0;
    BOOL bExists = FALSE;
    BOOL bDeleted = FALSE;
    OBJECTMAP oj;

    if (!dNewId)
        dNewId = CRC64::GenerateHashValue(lpObjectKey);

    if (!dDynasty)
        dDynasty = dNewId; // Reports to self.

    hr = GetFirst_ObjectMap(pConn, dNewId, oj);
    if (SUCCEEDED(hr))
    {
        dClassId = oj.dClassId;
        bExists = TRUE;
        if (bDeleted && (iInsertFlags & WBEM_FLAG_UPDATE_ONLY))
            hr = WBEM_E_INVALID_OBJECT;
        else if (iInsertFlags & WBEM_FLAG_CREATE_ONLY && (!bDeleted))
            hr = WBEM_E_ALREADY_EXISTS;
        else
            hr = WBEM_S_NO_ERROR;
        oj.Clear();
    }
    else if (iInsertFlags & WBEM_FLAG_UPDATE_ONLY)
        hr = WBEM_E_INVALID_OBJECT;
    else
        hr = WBEM_S_NO_ERROR;

    if (dClassId != 1 && dParentClassId == 0)
        dParentClassId = 1;
    else if (dParentClassId == dNewId)
        hr = WBEM_E_CIRCULAR_REFERENCE;

    if (SUCCEEDED(hr))
    {
        BOOL bInsert = TRUE;
        if (bExists)
            bInsert = FALSE;

        if (!dNewId)
            dNewId = CRC64::GenerateHashValue(lpObjectKey);

        LPWSTR lpPath = StripQuotes((LPWSTR)lpObjectPath);
        CDeleteMe <wchar_t> d (lpPath);

        // Insert ObjectMap
        hr = InsertObjectMap(pConn, dNewId, lpObjectKey, iState, lpPath, dScopeID, iClassFlags, 0, 1, bInsert);
        if (SUCCEEDED(hr))
        {
            hr = InsertClassMap(pConn, dNewId, lpClassName, dParentClassId, dDynasty, pClassBuff, dwClassBuffLen, bInsert);
            if (SUCCEEDED(hr))
            {
                if (iInsertFlags & WMIDB_HANDLE_TYPE_AUTODELETE)
                {
                    hr = InsertAutoDelete(pConn, dNewId);
                }
            }
        }
    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::InsertClassData
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertClassData (CSQLConnection *pConn, IWbemClassObject *pObj, CSchemaCache *pCache, SQL_ID dScopeId, 
                                            SQL_ID dClassId, LPCWSTR lpPropName, 
                                            DWORD CIMType, DWORD StorageType,LPCWSTR lpValue, SQL_ID dRefClassId, DWORD iPropID, 
                                            DWORD iFlags, DWORD iFlavor, BOOL iSkipValid, DWORD &iNewPropId, SQL_ID dOrigClassId,
                                            BOOL *bIsKey)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    SQL_ID dClass = dOrigClassId;
    if (!dClass)
        dClass = dClassId;
    DWORD dwNumRows = 0;
    BOOL bHasKey = FALSE;

    if (iFlags & REPDRVR_FLAG_QUALIFIER)
        dClass = 1;

    if (iNewPropId)
    {
        BOOL bLocal = FALSE;
        BOOL bKey = pCache->IsKey(dClassId, iNewPropId, bLocal);

        PROPERTYMAP pm;
        hr = GetFirst_PropertyMap(pConn, iNewPropId, pm);
        if (SUCCEEDED(hr) && pm.iStorageTypeId != StorageType)
        {
            if (StorageType == WMIDB_STORAGE_REAL &&
                pm.iStorageTypeId == WMIDB_STORAGE_NUMERIC)
            {
                hr = InsertPropertyMap(pConn, iNewPropId, dClassId, StorageType, 
                    CIMType, lpPropName, iFlags, FALSE);

                // They changed the datatype.  If this used to be an int,
                // (the only acceptable move) we have to move the data,
                // including any default and index, to the new column, table.

                CLASSDATA pm;

                hr = GetFirst_ClassDataByPropertyId(pConn, iNewPropId, pm);
                while (SUCCEEDED(hr))
                {
                    pm.rPropertyRealValue = pm.dPropertyNumericValue;
                    pm.dPropertyNumericValue = 0;

                    hr = UpdateClassData_Internal(pConn, pm);
                    if (FAILED(hr))
                    {
                        pm.Clear();
                        break;
                    }

                    hr = GetNext_ClassData(pConn, pm);
                    if (pm.iPropertyId != iNewPropId)
                    {
                        pm.Clear();
                        break;
                    }
                }

                if (hr == WBEM_E_NOT_FOUND)
                    hr = WBEM_S_NO_ERROR;

                if (SUCCEEDED(hr))
                {
                    if (iFlags & (REPDRVR_FLAG_INDEXED + REPDRVR_FLAG_KEY))
                    {
                        INDEXDATA id;
                        JET_TABLEID tid = 0;
                        DWORD dwPos = 0;

                        hr = GetFirst_IndexDataByProperty(pConn, iNewPropId, id, 
                                tid, dwPos);
                        while (SUCCEEDED(hr))
                        {
                            hr = InsertIndexData(pConn, dClassId, iNewPropId, id.iArrayPos, 
                                    id.sValue, id.dValue, id.rValue, WMIDB_STORAGE_REAL);
                            if (FAILED(hr))
                                break;

                            hr = GetNext_IndexData(pConn, tid, dwPos, id);
                        }
                        if (hr == WBEM_E_NOT_FOUND)
                            hr = WBEM_S_NO_ERROR;

                        if (SUCCEEDED(hr))
                            DeleteIndexData(pConn, WMIDB_STORAGE_NUMERIC, iNewPropId);
                    }
                }
            }
            else
                hr = WBEM_E_INVALID_OPERATION;
        }

        if (dRefClassId)
            hr = InsertReferenceProperties (pConn, dClassId, iNewPropId, dRefClassId, FALSE);

        if (!bKey && (iFlags & REPDRVR_FLAG_KEY))
        {
            hr = InsertClassKeys(pConn, dClassId, iNewPropId);
            bKey = TRUE;
        }
        if (!bLocal && bKey)
            bKey =  FALSE;
        if (bIsKey)
            *bIsKey = bKey;

    }
    else
    {
        BOOL bInsert = TRUE;
        if (iNewPropId)
            bInsert = FALSE;

        hr = InsertPropertyMap(pConn, iNewPropId, dClassId, StorageType, CIMType, 
            lpPropName, iFlags, bInsert);
        if (SUCCEEDED(hr))
        {
            if (CIMType == CIM_REFERENCE)
            {
                if (dRefClassId)
                    hr = InsertReferenceProperties (pConn, dClassId, iNewPropId, dRefClassId, FALSE);
                else
                {
                    hr = DeleteReferenceProperties(pConn, iNewPropId, dClassId);
                    if (REPDRVR_FLAG_CLASSREFS & iFlags)
                    {
                        // Enumerate the class refs on this property.

                        IWbemQualifierSet *pQS = NULL;
                        hr = pObj->GetPropertyQualifierSet(lpPropName, &pQS);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT vValue;
                            VariantInit(&vValue);            
                            CReleaseMe r (pQS);
                            CClearMe c (&vValue);

                            hr = pQS->Get(L"ClassRef", 0, &vValue, NULL);
                            if (SUCCEEDED(hr) && vValue.vt == VT_BSTR+CIM_FLAG_ARRAY)
                            {
                                SAFEARRAY *psaArray = V_ARRAY(&vValue);
                                if (psaArray)
                                {
                                    VARIANT vVal;
                                    VariantInit(&vVal);
                                    CClearMe c (&vVal);
                                    long lLBound, lUBound;
                                    SafeArrayGetLBound(psaArray, 1, &lLBound);
                                    SafeArrayGetUBound(psaArray, 1, &lUBound);

                                    lUBound -= lLBound;
                                    lUBound += 1;
                                    for (int i = 0; i < lUBound; i++)
                                    {
                                        hr = GetVariantFromArray(psaArray, i, VT_BSTR, vVal);
                                        if (SUCCEEDED(hr))
                                        {
                                            SQL_ID dRefClass = 0; 
                                            hr = pCache->GetClassID(vVal.bstrVal, dScopeId, dRefClass);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = InsertReferenceProperties(pConn, dClassId, iNewPropId, dRefClass, TRUE); 
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                if ((iFlags & REPDRVR_FLAG_KEY))
                {
                    hr = InsertClassKeys(pConn, dClassId, iNewPropId);
                    if (bIsKey)
                        *bIsKey = TRUE;
                }
                else if (bIsKey)
                    *bIsKey = FALSE;
                   
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        BOOL bLocal = FALSE;
        if (!(iFlags & REPDRVR_FLAG_KEY) && pCache->IsKey(dClassId, iNewPropId, bLocal))
        {
            pCache->SetIsKey(dClassId, iNewPropId, FALSE);
            hr = DeleteClassKeys(pConn, dClassId, iNewPropId);
            if (bIsKey)
                *bIsKey = FALSE;
        }
    }
    
    return hr;

}

//***************************************************************************
//
//  CSQLExecProcedure::InsertBlobData
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertBlobData (CSQLConnection *pConn, SQL_ID dClassId, SQL_ID dObjectId, DWORD iPropertyId, 
                                           BYTE *pImage, DWORD iPos, DWORD dwNumBytes)
{
    return InsertClassImages (pConn, dObjectId, iPropertyId, iPos, pImage, dwNumBytes);
}

//***************************************************************************
//
//  CSQLExecProcedure::InsertPropertyBatch
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertPropertyBatch (CSQLConnection *pConn, LPCWSTR lpObjectKey, LPCWSTR lpPath, LPCWSTR lpClassName,
    SQL_ID dClassId, SQL_ID dScopeId, DWORD iInsertFlags, InsertPropValues *pVals, DWORD iNumVals, SQL_ID &dNewObjectId)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    BOOL bExists = FALSE;
    BOOL bDeleted = FALSE;
    

    // Find existing ID, based on lpObjectKey.  
    // Verify insert/update flags

    if (!dNewObjectId)
    {      
        SQL_ID dTemp;
        hr = GetObjectIdByPath(pConn, lpObjectKey, dNewObjectId, dTemp, NULL, &bDeleted);
        if (SUCCEEDED(hr))
        {
            bExists = TRUE;
            if ((!bDeleted) && iInsertFlags & WBEM_FLAG_CREATE_ONLY)
                hr = WBEM_E_ALREADY_EXISTS;
            else if (bDeleted && (iInsertFlags & WBEM_FLAG_UPDATE_ONLY))
                hr = WBEM_E_INVALID_OBJECT;
            else
                hr = WBEM_S_NO_ERROR;
        }
        else if (iInsertFlags & WBEM_FLAG_UPDATE_ONLY)
            hr = WBEM_E_INVALID_OBJECT;
        else
            hr = WBEM_S_NO_ERROR;

        dNewObjectId = CRC64::GenerateHashValue(lpObjectKey);
    }
    else
        bExists = TRUE;

    if (SUCCEEDED(hr))
    {
        BOOL bInsert = TRUE;
        if (bExists)
            bInsert = FALSE;

        LPWSTR lpPath2 = StripQuotes((LPWSTR)lpPath);
        CDeleteMe <wchar_t> d (lpPath2);

        hr = InsertObjectMap(pConn, dNewObjectId, lpObjectKey, 0, lpPath2, dScopeId, 0, 0, dClassId, bInsert);
        if (SUCCEEDED(hr) && bExists)
        {
            // Delete all qualifiers, since we will reinsert them all.
            // (Guess we can't do this through accessors.)

            hr = DeleteQualifiers(pConn, dNewObjectId);
            if (SUCCEEDED(hr))
            {
                if (iInsertFlags & WMIDB_HANDLE_TYPE_AUTODELETE)
                    hr = InsertAutoDelete(pConn, dNewObjectId);
            }
        }           

        if (SUCCEEDED(hr))
            hr = InsertBatch(pConn, dNewObjectId, dScopeId, dClassId, pVals, iNumVals);
    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::InsertBatch
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertBatch (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dScopeId, SQL_ID dClassId,
                        InsertQfrValues *pVals, DWORD iNumVals)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    // Insert each property/qualifier/method/method parameter:

    if (dClassId == CONTAINERASSOCID)
    {
        for (int i = 0; i < iNumVals; i++)
        {
            if (pVals[i].pRefKey != NULL)
            {
                SQL_ID dContaineeId = _wtoi64(pVals[i].pRefKey);
                SQL_ID dContainerId = _wtoi64(pVals[i+1].pRefKey);

                hr = InsertContainerObjs(pConn, dContainerId, dContaineeId);
                if (FAILED(hr))
                    goto Exit;
                break;
            }
        }
    }

    for (int i = 0; i < iNumVals; i++)
    {
        SQL_ID dRefID = 0, dRefClassID = 0;
        BOOL bExisting = FALSE, bEx2 = FALSE;
        IRowset *pIRowset = NULL;
        InsertQfrValues *pVal = &pVals[i];       
        DWORD dwRows = 0;
        LPWSTR lpVal = NULL;            
        BOOL bRefCount = FALSE;
        LPWSTR sVal = NULL;  
        SQL_ID dVal = 0;
        double rVal = 0;
        bool bStoreTextAsImage = false;
        BOOL bIsNull = FALSE;

        switch(pVal->iStorageType)
        {
        case WMIDB_STORAGE_STRING:

            if (pVal->pValue)
            {
                sVal = TruncateLongText(pVal->pValue, 127, bStoreTextAsImage, 127);
                if (bStoreTextAsImage)
                    pVal->bLong = TRUE;
            }
            else
                bIsNull = TRUE;

            // Clean up any previously-created string data stored as images.
            hr = DeleteClassImages(pConn, pVal->iPropID, dObjectId, pVal->iPos);

            hr = InsertClassData_Internal (pConn, dObjectId, pVal->iPropID, pVal->iPos, pVal->iQfrID,
                                     pVal->dClassId, sVal, 0, 0, pVal->iFlavor, pVal->iQfrID, 0, bIsNull);

            if (SUCCEEDED(hr) && pVal->bIndexed)
            {
                hr = InsertIndexData (pConn, dObjectId, pVal->iPropID, pVal->iPos, 
                       sVal, 0, 0, pVal->iStorageType);
            }
            
            delete sVal;

            break;

        case WMIDB_STORAGE_NUMERIC:
            if (pVal->pValue)
                dVal = _wtoi64(pVal->pValue);
            else
                bIsNull = TRUE;

            hr = InsertClassData_Internal (pConn, dObjectId, pVal->iPropID, pVal->iPos, pVal->iQfrID,
                                     pVal->dClassId, NULL, dVal, 0, pVal->iFlavor, pVal->iQfrID, 0, bIsNull);
            if (SUCCEEDED(hr) && pVal->bIndexed)
            {
                hr = InsertIndexData (pConn, dObjectId, pVal->iPropID, pVal->iPos, 
                       NULL, dVal, 0, pVal->iStorageType);
            }
            break;
        case WMIDB_STORAGE_REAL:
            if (pVal->pValue)
                rVal = wcstod(pVal->pValue, &lpVal);
            else
                bIsNull = TRUE;
            hr = InsertClassData_Internal (pConn, dObjectId, pVal->iPropID, pVal->iPos, pVal->iQfrID,
                                     pVal->dClassId, NULL, 0, rVal, pVal->iFlavor, pVal->iQfrID, 0, bIsNull);
            if (SUCCEEDED(hr) && pVal->bIndexed)
            {
                hr = InsertIndexData (pConn, dObjectId, pVal->iPropID, pVal->iPos, 
                       NULL, rVal, 0, pVal->iStorageType);
            }
            break;
        case WMIDB_STORAGE_REFERENCE:

            //   * If this is a reference, we need to get the ID from the key string.  
            //     If this object does not exist, we need to insert a bogus row.
            //     Bump up the ref count.
            //     If this is an update, decrement the ref count on previous row
            //     If previous row now has zero ref count, remove it.

            dRefID = _wtoi64(pVal->pRefKey);
            {
                IRowset *pRowset = NULL;
                IAccessor *pAccessor = NULL;
                HACCESSOR hAcc = NULL;
                CLASSDATA cd;
                BOOL bOldRow = FALSE;

                hr = GetFirst_ClassData(pConn, dObjectId, cd,pVal->iPropID);
                while (hr == WBEM_S_NO_ERROR)
                {
                    if (pVal->iPos == cd.iArrayPos &&
                        pVal->iQfrID == cd.iQfrPos)
                    {
                        bExisting = TRUE;
                        SQL_ID dOldRefID = cd.dRefId;
                        if (dRefID != dOldRefID)
                        {   
                            PROPERTYMAP pm;

                            hr = GetFirst_PropertyMap(pConn, pVal->iPropID, pm);

                            if (SUCCEEDED(hr))
                            {
                                if (pm.iCIMTypeId == CIM_OBJECT)
                                    hr = DeleteObjectMap(pConn, dOldRefID, TRUE);
                                else
                                {
                                    OBJECTMAP om;
                                    hr = GetFirst_ObjectMap(pConn, dOldRefID, om);

                                    if (SUCCEEDED(hr))
                                    {
                                        bOldRow = TRUE;
                                        bRefCount = TRUE;
                                        if (om.iRefCount)
                                            om.iRefCount--;
                                        hr = UpdateObjectMap(pConn, om);
                                        om.Clear();
                                    }
                                }
                            }
                        }
                        else
                            bOldRow = TRUE;
                        cd.Clear();
                        break;
                    }
                    hr = GetNext_ClassData(pConn, cd, pVal->iPropID);
                    if (cd.dObjectId != dObjectId)
                    {
                        cd.Clear();
                        break;
                    }
                }
                hr = 0;
                if (!bOldRow)
                    bRefCount = TRUE;
            }

            if (pVal->pValue)
            {
                lpVal = StripQuotes(pVal->pValue);

                ObjectExists(pConn, dRefID, bEx2, &dRefClassID, NULL, TRUE);
                if (!bEx2)
                {
                    // We need to insert this row and get the new ID.
                    LPWSTR lpKey = GetKeyString(pVal->pValue);
                    CDeleteMe <wchar_t> d (lpKey);

                    hr = InsertObjectMap(pConn, dRefID, lpKey, 2, lpVal, dObjectId, 1, 1, 0, TRUE);                    
                }
                else if (bRefCount)
                {
                    IRowset *pRowset = NULL;
                    IAccessor *pAccessor = NULL;
                    HACCESSOR hAcc = NULL;

                    OBJECTMAP om;
                    hr = GetFirst_ObjectMap(pConn, dRefID, om);

                    if (SUCCEEDED(hr))
                    {
                        om.iRefCount++;
                        hr = UpdateObjectMap(pConn, om);
                        om.Clear();
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // update/insert the new row

                    sVal = TruncateLongText(pVal->pValue, 127, bStoreTextAsImage, 127);
                    if (bStoreTextAsImage)
                        pVal->bLong = TRUE;

                    hr = InsertClassData_Internal (pConn, dObjectId, pVal->iPropID, pVal->iPos, pVal->iQfrID,
                                             pVal->dClassId, sVal, 0, 0, pVal->iFlavor, dRefID, dRefClassID, FALSE);
                
                    if (SUCCEEDED(hr) && pVal->bIndexed)
                    {
                        DWORD dwRows = 0;
                        hr = InsertIndexData (pConn, dObjectId, pVal->iPropID, pVal->iPos, 
                               sVal, dRefID, 0, pVal->iStorageType);
                    }

                    delete sVal;
                }
                delete lpVal;
            }
           
            break;

            // This should never be hit.
        default:
            pVal->bLong = TRUE;
            continue;
        }          

        if (FAILED(hr))
            break;
    }

    if (SUCCEEDED(hr))
    {
        // If our text was too long, we need to store it as an image.
        for (i = 0; i < iNumVals; i++)
        {
            if (pVals[i].bLong)
            {
                if (pVals[i].iStorageType == WMIDB_STORAGE_STRING || 
                    pVals[i].iStorageType == WMIDB_STORAGE_REFERENCE)
                {
                    LPWSTR lpTemp = StripQuotes2 (pVals[i].pValue);
                    CDeleteMe <wchar_t> d (lpTemp);
                    hr = InsertBlobData (pConn, dClassId, dObjectId, pVals[i].iPropID, (BYTE *)lpTemp, 0, wcslen(lpTemp)*2+2);
                }
                else if (pVals[i].pValue == NULL) // This is a null blob!
                    hr = DeleteClassImages(pConn, pVals[i].iPropID, dObjectId);
                else
                {
                    ERRORTRACE((LOG_WBEMCORE, "Invalid argument in InsertBatch (Obj %I64d, Class %I64d, Prop %ld)", \
                        dObjectId, dClassId, pVals[i].iPropID));
                }
            }
            delete pVals[i].pValue;
            delete pVals[i].pRefKey;
        }
    }

Exit:

    return hr;

}

//***************************************************************************
//
//  CSQLExecProcedure::ObjectExists
//
//***************************************************************************

HRESULT CSQLExecProcedure::ObjectExists (CSQLConnection *pConn, SQL_ID dId, BOOL &bExists, SQL_ID *_dClassId,
                                         SQL_ID *_dScopeId, BOOL bDeletedOK)
{

    SQL_ID dClassId, dScopeId;
    BOOL bDeleted = FALSE;
    OBJECTMAP oj;
    
    HRESULT hr = GetFirst_ObjectMap(pConn, dId, oj);
    if (SUCCEEDED(hr))
    {
        bExists = TRUE;
        if (oj.iObjectState == 2)
        {
            if (!bDeletedOK)
                bExists = FALSE;
        }

        if (bExists)
        {
            if (_dClassId) *_dClassId = oj.dClassId;
            if (_dScopeId) *_dScopeId = oj.dObjectScopeId;
        }
        oj.Clear();
    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::RenameSubscopes
//
//***************************************************************************

HRESULT CSQLExecProcedure::RenameSubscopes (CSQLConnection *pConn, LPWSTR lpOldPath, LPWSTR lpOldKey, LPWSTR lpNewPath, LPWSTR lpNewKey)
{
    HRESULT hr = 0;

    OBJECTMAP om;

    // Enumerate all objects, and rename any that begin with the old path string.

    hr = SetupObjectMapAccessor(pConn);
    if (SUCCEEDED(hr))
    {

        int iOldPathLen = wcslen(lpOldPath);
        int iOldKeyLen = wcslen(lpOldKey);

        SQL_ID OldId = CRC64::GenerateHashValue(lpOldKey);
        SQL_ID NewId = CRC64::GenerateHashValue(lpNewKey);

        hr = OpenEnum_ObjectMap(pConn, om);
        if (SUCCEEDED(hr))
        {
            if (!_wcsnicmp(om.sObjectPath, lpOldPath, iOldPathLen))
            {
                // Path = @NewPath + substring(ObjectPath, @OldPathLen+1, (datalength(ObjectPath)/2)- @OldPathLen),
                // Key = substring(ObjectKey, 1, charindex(@OldKey, ObjectKey)-1) +@NewKey

                LPWSTR lpTemp = NULL;
                if (wcslen(om.sObjectPath) > iOldPathLen)
                {
                    lpTemp = &om.sObjectPath[iOldPathLen];
                    LPWSTR lpNew = new wchar_t [wcslen(om.sObjectPath) + wcslen(lpNewPath)+1];
                    CDeleteMe <wchar_t> d(lpNew);
                    if (lpNew)
                    {
                        wcscpy(lpNew, lpNewPath);
                        wcscat(lpNew, lpTemp);
                        om.sObjectPath = SysAllocString(lpNew);                        

                        LPWSTR lpNew2 = new wchar_t [wcslen(om.sObjectKey) + wcslen(lpNewKey) + 1];
                        if (lpNew2 && om.sObjectPath)
                        {
                            lpTemp = om.sObjectKey;
                            lpTemp[iOldKeyLen] = L'\0';
                            wcscpy(lpNew2, lpTemp);
                            wcscat(lpNew2, lpNewKey);
                            om.sObjectKey = SysAllocString(lpNew2);

                            if (om.dObjectScopeId == OldId)
                                om.dObjectScopeId = NewId;
                            if (om.dClassId == OldId)
                                om.dClassId = NewId;
                            if (om.dObjectId == OldId)
                                om.dObjectId = NewId;

                            hr = UpdateObjectMap(pConn, om);
                        }
                        else
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    om.sObjectPath = SysAllocString(lpNewPath);
                    om.sObjectKey = SysAllocString(lpNewKey);

                    if (om.sObjectPath && om.sObjectKey)
                        hr = UpdateObjectMap(pConn, om);
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else if (om.sObjectPath[0] > lpOldPath[0])
                om.Clear();
            hr = GetNext_ObjectMap(pConn, om);
        }

        // FIXME: We don't currently update ClassData and IndexRefData!
        // IF this is a class, we don't update the ClassMap and PropertyMap!!!



        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetSecurityDescriptor
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetSecurityDescriptor(CSQLConnection *pConn, SQL_ID dObjectId, 
                                                 PNTSECURITY_DESCRIPTOR * ppSD, DWORD &dwBuffLen,
                                                 DWORD dwFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If this is a class , get the security for __ClassSecurity (WMIDB_SECURITY_FLAG_CLASS)
    //  or __Instances container (WMIDB_SECURITY_FLAG_INSTANCE)
    // If this is a namespace, get the security for __ThisNamespace
    // Otherwise, get it off the object itself.
    // Make sure its a valid security descriptor, before we
    // return anything.

    *ppSD = NULL;

    PNTSECURITY_DESCRIPTOR pSD = NULL;
    dwBuffLen = 0;
    OBJECTMAP oj;
    CLASSMAP cm;

    SQL_ID dID = 0;

    hr = GetFirst_ClassMap(pConn, dObjectId, cm);
    if (SUCCEEDED(hr))
    {
        LPWSTR lpRetrievalName = NULL;
        SQL_ID dScopeId = oj.dObjectScopeId;
        int iSize = 0;
        oj.Clear();

        // We need to generate the path of the class

        if (dwFlags == WMIDB_SECURITY_FLAG_INSTANCE)
        {                
            if (dScopeId)
            {
                hr = GetFirst_ObjectMap(pConn, dScopeId, oj);
                iSize = wcslen(oj.sObjectPath) + wcslen(cm.sClassName) + 128;
            }
            else
                iSize = wcslen(cm.sClassName) + 128;

            lpRetrievalName = new wchar_t [iSize];
            CDeleteMe <wchar_t> d (lpRetrievalName);
            if (lpRetrievalName)
            {
                if (dScopeId)
                    swprintf(lpRetrievalName, L"%s:__ClassInstancesSecurity=\"%s\"", oj.sObjectPath, cm.sClassName);
                else
                    swprintf(lpRetrievalName, L"__ClassInstancesSecurity=\"%s\"", cm.sClassName);

                LPWSTR lpKey = GetKeyString(lpRetrievalName);
                CDeleteMe <wchar_t> d2 (lpKey);
                if (lpKey)
                {
                    dID = CRC64::GenerateHashValue(lpKey);
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;

            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;

        }
        else
        {
            // Get the __ClassSecurity object

            if (dScopeId)
            {
                hr = GetFirst_ObjectMap(pConn, dScopeId, oj);
                iSize = wcslen(oj.sObjectPath) + wcslen(cm.sClassName) + 128;
            }
            else
                iSize = wcslen(cm.sClassName) + 128;

            lpRetrievalName = new wchar_t [iSize];
            CDeleteMe <wchar_t> d (lpRetrievalName);
            if (lpRetrievalName)
            {
                if (dScopeId)
                    swprintf(lpRetrievalName, L"%s:__ClassSecurity=\"%s\"", oj.sObjectPath, cm.sClassName);
                else
                    swprintf(lpRetrievalName, L"__ClassSecurity=\"%s\"", cm.sClassName);

                LPWSTR lpKey = GetKeyString(lpRetrievalName);
                CDeleteMe <wchar_t> d2 (lpKey);
                if (lpKey)
                {
                    dID = CRC64::GenerateHashValue(lpKey);
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;

        }
        cm.Clear();
        oj.Clear();
    }
    else
    {
        // Get the object itself.
        hr = WBEM_S_NO_ERROR;
        dID = dObjectId;
        oj.Clear();
    }

    if (SUCCEEDED(hr))
    {
        CLASSIMAGES ci;
        BOOL bFound = FALSE;

        hr = GetFirst_ClassImages(pConn, dID, ci);
        while (SUCCEEDED(hr))
        {
            PROPERTYMAP pm;
            hr = GetFirst_PropertyMap(pConn, ci.iPropertyId, pm);
            if (SUCCEEDED(hr) && (!_wcsicmp(pm.sPropertyName, L"__SECURITY_DESCRIPTOR")))
            {
                pSD = ci.pBuffer;
                bFound = TRUE;
                if (pSD != NULL)
                {
                    if (IsValidSecurityDescriptor(pSD))
                    {
                        // Make a copy of it.
                        pSD = (PNTSECURITY_DESCRIPTOR)CWin32DefaultArena::WbemMemAlloc(ci.dwBufferLen);
                        
                        ZeroMemory(pSD, ci.dwBufferLen);
                        memcpy(pSD, ci.pBuffer, ci.dwBufferLen);
                        *ppSD = pSD;
                        dwBuffLen = ci.dwBufferLen;
                    }
                }
            }
            pm.Clear();

            if (bFound)
                break;

            hr = GetNext_ClassImages(pConn, ci);
        }
        ci.Clear();
    }       

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::EnumerateSecuredChildren
//
//***************************************************************************

HRESULT CSQLExecProcedure::EnumerateSecuredChildren(CSQLConnection *pConn, CSchemaCache *pCache, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId,
                                                    SQLIDs &ObjIds, SQLIDs &ClassIds, SQLIDs &ScopeIds)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If __Classes instance, we need to enumerate all instances of __ClassSecurity
    // If this is a __ClassSecurity instance, we need to enumerate all instances
    //    of __ClassSecurity for all subclasses
    // If this is a __ClassInstancesSecurity instance, we need to enumerate all
    //    instances of this class
    // If this is a namespace (__ThisNamespace) or scope, we need all subscoped objects 

    SQL_ID dClassSecurityId = CLASSSECURITYID;
    SQL_ID dClassesId = CLASSESID;
    SQL_ID dClassInstSecurityId = CLASSINSTSECID;
    SQL_ID dThisNamespaceId = THISNAMESPACEID;

    DWORD dwSecPropID = 0;

    hr = pCache->GetPropertyID(L"__SECURITY_DESCRIPTOR", 1, 0, REPDRVR_IGNORE_CIMTYPE, dwSecPropID);

    if (dClassId == dClassesId)
    {
        // All classes in this namespace.
        OBJECTMAP oj;
        hr = GetFirst_ObjectMapByClass(pConn, dClassSecurityId, oj);
        while (SUCCEEDED(hr))
        {
            if (oj.dObjectScopeId == dScopeId)
            {
                // This is pointing to some class, we don't care
                // which one.

                CLASSIMAGES ci;
                hr = GetFirst_ClassImages(pConn, oj.dObjectId, ci);
                while (SUCCEEDED(hr))
                {
                    if (ci.iPropertyId == dwSecPropID)
                    {
                        ObjIds.push_back(oj.dObjectId);
                        ClassIds.push_back(oj.dClassId);
                        ScopeIds.push_back(oj.dObjectScopeId);
                        ci.Clear();
                        break;
                    }
                    hr = GetNext_ClassImages(pConn, ci);
                }
            }

            hr = GetNext_ObjectMap(pConn, oj);
        }
    }
    else if (dClassId == dClassSecurityId)
    {
        // All __ClassSecurity for subclasses of this class

        // Get the class name 
        // Get the ID for the class name in this namespace
        // Enumerate subclasses
        // Format the name
        // Generate the Object ID


        return E_NOTIMPL;

    }
    else if (dClassId == dClassInstSecurityId)
    {
        // All instances of this class and subclasses.

        // Get the class name 
        // Get the ID for the class name in this namespace
        // Enumerate subclasses
        // Enumerate all instances of each class

        return E_NOTIMPL;
    }
    else
    {
        // Regular instance.  Enumerate all objects 
        // scoped to this .

        SQL_ID dThis = dObjectId;

        if (dClassId == dThisNamespaceId)
            dThis = dScopeId;

        SQL_ID * pScopes = NULL;
        int iNumScopes = 0;

        hr = pCache->GetSubScopes(dThis, &pScopes, iNumScopes);
        for (int i = 0; i < iNumScopes; i++)
        {
            OBJECTMAP oj;
            hr = GetFirst_ObjectMapByScope(pConn, pScopes[i], oj);

            while (SUCCEEDED(hr))
            {
                CLASSIMAGES ci;
                hr = GetFirst_ClassImages(pConn, oj.dObjectId, ci);
                while (SUCCEEDED(hr))
                {
                    if (ci.iPropertyId == dwSecPropID)
                    {
                        ObjIds.push_back(oj.dObjectId);
                        ClassIds.push_back(oj.dClassId);
                        ScopeIds.push_back(oj.dObjectScopeId);
                        ci.Clear();
                        break;
                    }
                    hr = GetNext_ClassImages(pConn, ci);
                }

                hr = GetNext_ObjectMap(pConn, oj);
            }
        }
        delete pScopes;
    }

    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::EnumerateSubScopes
//
//***************************************************************************

HRESULT CSQLExecProcedure::EnumerateSubScopes (CSQLConnection *pConn, SQL_ID dScopeId)
{
    return E_NOTIMPL;

}

//***************************************************************************
//
//  CSQLExecProcedure::InsertScopeMap
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertScopeMap (CSQLConnection *pConn, SQL_ID dScopeId, LPCWSTR lpScopePath, SQL_ID dParentId)
{
    HRESULT hr = InsertScopeMap_Internal(pConn, dScopeId, lpScopePath, dParentId);
    return hr;
}


//***************************************************************************
//
//  CSQLExecProcedure::InsertUncommittedEvent
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertUncommittedEvent (CSQLConnection *pConn, LPCWSTR lpGUID, LPWSTR lpNamespace, 
                                                   LPWSTR lpClassName, IWbemClassObject *pOldObj, 
                                                   IWbemClassObject *pNewObj, CSchemaCache *pCache)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    static int iNumProps = 4;
    InsertPropValues *pVals = new InsertPropValues[iNumProps];

    if (!pVals)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe <InsertPropValues> d (pVals);
    LPWSTR lpObjectKey = NULL, lpPath = NULL;
    SQL_ID dScopeId = 1;
    SQL_ID dObjectId = 0;
    SQL_ID dKeyhole = 0;
    static SQL_ID dClassId = 0;
    static DWORD dwPropId1 = 0, dwPropId2 = 0, dwPropId3 = 0, dwPropId4 = 0, dwPropId5 = 0, dwPropId6 = 0, dwPropId7 = 0;

    if (!dwPropId1)
    {
        hr = pCache->GetClassID(L"__UncommittedEvent", 1, dClassId);
        if (SUCCEEDED(hr))
        {
            hr = pCache->GetPropertyID(L"EventID", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId1);
            hr = pCache->GetPropertyID(L"TransactionGUID", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId2);
            hr = pCache->GetPropertyID(L"NamespaceName", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId3);
            hr = pCache->GetPropertyID(L"ClassName", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId4);
            hr = pCache->GetPropertyID(L"OldObject", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId5);
            hr = pCache->GetPropertyID(L"NewObject", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId6);
            hr = pCache->GetPropertyID(L"Transacted", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId7);
        }
    }

    if (FAILED(hr))
        return hr;
        
    hr = GetNextKeyhole(pConn, dwPropId1, dKeyhole);
    if (SUCCEEDED(hr))
    {
        LPWSTR lpKey = new wchar_t [40];
        lpObjectKey = new wchar_t [100];
        lpPath = new wchar_t [100];

        CDeleteMe <wchar_t> d2 (lpKey), d3 (lpObjectKey), d4 (lpPath);

        if (!lpKey || !lpObjectKey || !lpPath)
            return WBEM_E_OUT_OF_MEMORY;

        swprintf(lpKey, L"%ld", dKeyhole);
        swprintf(lpObjectKey, L"%ld?__UncommittedEvent", dKeyhole);
        swprintf(lpObjectKey, L"__UncommittedEvent=%ld", dKeyhole);

        pVals[0].iPropID = dwPropId1;
        pVals[0].bIndexed = TRUE;
        pVals[0].iStorageType = WMIDB_STORAGE_NUMERIC;
        pVals[0].dClassId = dClassId;
        pVals[0].pValue = lpKey;
        pVals[1].iPropID = dwPropId2;
        pVals[1].bIndexed = TRUE;
        pVals[1].iStorageType = WMIDB_STORAGE_STRING;
        pVals[1].dClassId = dClassId;
        pVals[1].pValue = (LPWSTR)lpGUID;
        pVals[2].iPropID = dwPropId3;
        pVals[2].iStorageType = WMIDB_STORAGE_STRING;
        pVals[2].dClassId = dClassId;
        pVals[2].pValue = lpClassName;
        pVals[3].iPropID = dwPropId4;
        pVals[3].iStorageType = WMIDB_STORAGE_STRING;
        pVals[3].dClassId = dClassId;
        pVals[3].pValue = (LPWSTR)lpNamespace;
        pVals[4].iPropID = dwPropId6;
        pVals[4].iStorageType = WMIDB_STORAGE_NUMERIC;
        pVals[4].dClassId = dClassId;
        pVals[4].pValue = new wchar_t [1];
        if (!pVals[4].pValue)
            return WBEM_E_OUT_OF_MEMORY;

        wcscpy(pVals[4].pValue, L"1");

        hr = InsertPropertyBatch (pConn, lpObjectKey, lpPath, lpClassName,
                    dClassId, dScopeId, 0, pVals, iNumProps, dObjectId);
        if (SUCCEEDED(hr))
        {
            if (pOldObj)
            {                  
                _IWmiObject *pInt = NULL;
                hr = pOldObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
                if (SUCCEEDED(hr))
                {
                    DWORD dwLen = 0;
                    pInt->GetObjectMemory(NULL, 0, &dwLen);
                    BYTE *pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> d (pBuff);
                        DWORD dwLen1;
                        hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                        if (SUCCEEDED(hr))
                        {
                            hr = CSQLExecProcedure::InsertBlobData(pConn, dClassId, dObjectId,
                                        dwPropId4, pBuff, 0, dwLen);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                    pInt->Release();
                }                               
            }

            if (pNewObj)
            {                  
                _IWmiObject *pInt = NULL;
                hr = pNewObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
                if (SUCCEEDED(hr))
                {
                    DWORD dwLen = 0;
                    pInt->GetObjectMemory(NULL, 0, &dwLen);
                    BYTE *pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> d (pBuff);
                        DWORD dwLen1;
                        hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                        if (SUCCEEDED(hr))
                        {
                            hr = CSQLExecProcedure::InsertBlobData(pConn, dClassId, dObjectId,
                                        dwPropId4, pBuff, 0, dwLen);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                    pInt->Release();
                }                               
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::DeleteUncommittedEvents
//
//***************************************************************************

HRESULT CSQLExecProcedure::DeleteUncommittedEvents (CSQLConnection *pConn, LPCWSTR lpGUID, 
                                                    CSchemaCache *pCache, CObjectCache *pObjCache)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Delete all events by GUID
    // The simplest thing to do is to scan IndexStringData
    // for this GUID and delete each object that way

    INDEXDATA id;
    JET_TABLEID tableid;
    DWORD dwPos;
    SQLIDs ids;

    SQL_ID dClassId;
    hr = pCache->GetClassID(L"__UncommittedEvent", 1, dClassId);

    // Find all objects that match this GUID...

    hr = GetFirst_IndexDataString(pConn, (LPWSTR)lpGUID, id, tableid, dwPos);
    while (SUCCEEDED(hr))
    {
        ids.push_back(id.dObjectId);
        
        // Clean up object cache for each event
        
        pObjCache->DeleteObject(id.dObjectId);

        hr = GetNext_IndexData(pConn, tableid, dwPos, id);
    }

    // Delete 'em...

    for (int i = 0; i < ids.size(); i++)
    {
        OBJECTMAP oj;
        hr = GetFirst_ObjectMap(pConn, ids.at(i), oj);
        if (oj.dClassId == dClassId)
        {        
            oj.Clear();
            hr = DeleteObjectMap(pConn, ids.at(i));
            if (FAILED(hr))
                break;
        }
        oj.Clear();
    }
    
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::CommitEvents
//
//***************************************************************************

HRESULT CSQLExecProcedure::CommitEvents(CSQLConnection *pConn,_IWmiCoreServices *pESS,
                                        LPCWSTR lpRoot, LPCWSTR lpGUID, CSchemaCache *pCache, CObjectCache *pObjCache)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Enumerate event objects,
    // fire an event for each (distinguishing classes, instances, and namespaces,
    //    and creation, deletion, modification)
    // Delete each event.    

    INDEXDATA id;
    JET_TABLEID tableid;
    DWORD dwPos;
    SQLIDs ids;
    SQL_ID dClassId;
    hr = pCache->GetClassID(L"__UncommittedEvent", 1, dClassId);

    // Find all objects that match this GUID...

    hr = GetFirst_IndexDataString(pConn, (LPWSTR)lpGUID, id, tableid, dwPos);
    while (SUCCEEDED(hr))
    {
        ids.push_back(id.dObjectId);
    
        // Clean up object cache for each event
    
        pObjCache->DeleteObject(id.dObjectId);

        hr = GetNext_IndexData(pConn, tableid, dwPos, id);
    }

    // Fire an event, and delete the object...

    for (int i = 0; i < ids.size(); i++)
    {
        long lType = 0;
        _bstr_t sNamespace;
        _bstr_t sClassName;
        DWORD dwNumObjs = 1;
        _IWmiObject **pObjs = NULL;
        _IWmiObject *pOldObj = NULL;
        _IWmiObject *pNewObj = NULL;
        LPWSTR lpNewNs = NULL;

        OBJECTMAP oj;
        hr = GetFirst_ObjectMap(pConn, ids.at(i), oj);
        if (SUCCEEDED(hr))
        {
            if (oj.dClassId != dClassId)
            {
                oj.Clear();
                continue;
            }

            // Extract the data from the tables.
            // OldObject, NewObject, ClassName and NamespaceName
            // =================================================

            static DWORD dwPropId1 = 0, dwPropId2 = 0, dwPropId3 = 0, dwPropId4 = 0;

            if (!dwPropId1)
            {
                if (SUCCEEDED(hr))
                {
                    hr = pCache->GetPropertyID(L"NamespaceName", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId1);
                    hr = pCache->GetPropertyID(L"ClassName", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId2);
                    hr = pCache->GetPropertyID(L"OldObject", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId3);
                    hr = pCache->GetPropertyID(L"NewObject", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId4);
                }
            }

            CLASSDATA cd;
            hr = GetFirst_ClassData(pConn, ids.at(i), cd, dwPropId1);
            if (SUCCEEDED(hr))
            {
                sNamespace = cd.sPropertyStringValue;
            }
            cd.Clear();
            hr = GetFirst_ClassData(pConn, ids.at(i), cd, dwPropId2);
            if (SUCCEEDED(hr))
            {
                sClassName = cd.sPropertyStringValue;
            }
            cd.Clear();

            CLASSIMAGES ci;
            hr = GetFirst_ClassImages(pConn, ids.at(i), ci);
            while (SUCCEEDED(hr))
            {
                if (ci.iPropertyId == dwPropId3)
                    ConvertBlobToObject(NULL, ci.pBuffer, ci.dwBufferLen, &pOldObj);
                else if (ci.iPropertyId == dwPropId4)
                    ConvertBlobToObject(NULL, ci.pBuffer, ci.dwBufferLen, &pNewObj);

                hr = GetNext_ClassImages(pConn, ci);
            }
            ci.Clear();          

            // Namespace must be formatted with \\.\lpRoot\...
            // Unless the namespace is root, and then we 
            // have to strip off the beginning...
            // ===============================================

            lpNewNs = new wchar_t [wcslen(sNamespace) + 50];
            if (lpNewNs)
            {
                swprintf(lpNewNs, L"\\\\.\\%s\\%s", lpRoot, (LPCWSTR)sNamespace);
            }
        }

        CDeleteMe <wchar_t> d4 (lpNewNs);

        // Determine what type of event this is:
        //     Namespace | Class | Instance
        //  Creation | Modification | Deletion
        // =====================================

        if (!pNewObj && pOldObj)
        {
            pObjs = new _IWmiObject * [dwNumObjs];
            if (pObjs)
            {
                pObjs[0] = pOldObj;

                LPWSTR lpGenus = GetPropertyVal(L"__Genus", pOldObj);
                CDeleteMe <wchar_t> d (lpGenus);

                if (!wcscmp(lpGenus, L"1"))
                    lType = WBEM_EVENTTYPE_ClassDeletion;
                else
                {
                    if (IsDerivedFrom(pOldObj, L"__Namespace"))
                        lType = WBEM_EVENTTYPE_NamespaceDeletion;
                    else
                        lType = WBEM_EVENTTYPE_InstanceDeletion;
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
        else if (!pOldObj && pNewObj)
        {
            pObjs = new _IWmiObject *[dwNumObjs];
            if (pObjs)
            {
                pObjs[0] = pNewObj;

                LPWSTR lpGenus = GetPropertyVal(L"__Genus", pNewObj);
                CDeleteMe <wchar_t> d (lpGenus);

                if (!wcscmp(lpGenus, L"1"))
                    lType = WBEM_EVENTTYPE_ClassCreation;
                else
                {
                    if (IsDerivedFrom(pNewObj, L"__Namespace"))
                        lType = WBEM_EVENTTYPE_NamespaceCreation;
                    else
                        lType = WBEM_EVENTTYPE_InstanceCreation;
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            dwNumObjs = 2;
            pObjs = new _IWmiObject *[dwNumObjs];
            if (pObjs)
            {
                pObjs[0] = pOldObj;
                pObjs[1] = pNewObj;

                LPWSTR lpGenus = GetPropertyVal(L"__Genus", pNewObj);
                CDeleteMe <wchar_t> d (lpGenus);

                if (!wcscmp(lpGenus, L"1"))
                    lType = WBEM_EVENTTYPE_ClassModification;
                else
                {
                    if (IsDerivedFrom(pOldObj, L"__Namespace"))
                        lType = WBEM_EVENTTYPE_NamespaceModification;
                    else
                        lType = WBEM_EVENTTYPE_InstanceModification;
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }          

        // Deliver the event...
        // ====================

        pESS->DeliverIntrinsicEvent(lpNewNs, lType, NULL, 
                sClassName, lpGUID, dwNumObjs, pObjs);

        delete pObjs;
        if (pOldObj)
            pOldObj->Release();
        if (pNewObj)
            pNewObj->Release();

        oj.Clear();

        hr = DeleteObjectMap(pConn, ids.at(i));
        if (FAILED(hr))
            break;
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::UpdateClassBlob
//
//***************************************************************************

HRESULT CSQLExecProcedure::UpdateClassBlob (CSQLConnection *pConn, SQL_ID dClassId, _IWmiObject *pObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BYTE buff[128];
    DWORD dwLen = 0;
    hr = pObj->Unmerge(0, 128, &dwLen, &buff);

    if (dwLen > 0)
    {
        BYTE *pBuff = new BYTE [dwLen];
        if (pBuff)
        {
            CDeleteMe <BYTE> r2 (pBuff);
            DWORD dwLen1;
            hr = pObj->Unmerge(0, dwLen, &dwLen1, pBuff);
            if (SUCCEEDED(hr))
            {
                CLASSMAP cd;
                hr = GetFirst_ClassMap(pConn, dClassId, cd);
                if (SUCCEEDED(hr))
                {
                    delete cd.pClassBuffer;
                    cd.pClassBuffer = pBuff;
                    cd.dwBufferLen = dwLen;

                    hr = UpdateClassMap(pConn, cd);
                }
            }
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;

    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::LoadSchemaCache
//
//***************************************************************************

HRESULT CWmiDbSession::LoadSchemaCache ()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This needs to load the cache with all class, property,
    // and namespace data. We are going to call three straight
    // select queries and grab the columns.
    // ==========================================================

    DWORD dwNumRows;

    CSQLConnection *pConn = NULL;

    if (m_pController)
        hr = GetSQLCache()->GetConnection(&pConn);

    if (SUCCEEDED(hr) && pConn)
    {
        // Enumerate scopes.
        // =================

        SCOPEMAP sm;
        OBJECTMAP oj;
        CLASSIMAGES ci;
        DWORD dwSecurity;

        hr = OpenEnum_ScopeMap(pConn, sm);
        while (SUCCEEDED(hr))
        {
            hr = GetFirst_ObjectMap(pConn, sm.dObjectId, oj);
            
            hr = GetSchemaCache()->AddNamespace
                (sm.sScopePath, sm.sScopePath, sm.dObjectId, sm.dParentId, oj.dClassId);

            oj.Clear();

            if (FAILED(hr))
                break;

            hr = GetNext_ScopeMap(pConn, sm);
        }
        
        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

        // Enumerate system classes.

        if (FAILED(LoadClassInfo(pConn, L"meta_class", 0, FALSE)))
            goto Exit;
       
        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

        // IDs with security descriptors
        
        GetSchemaCache()->GetPropertyID(L"__SECURITY_DESCRIPTOR", 1, 
            0, REPDRVR_IGNORE_CIMTYPE, dwSecurity);

        hr = GetFirst_ClassImagesByPropertyId(pConn, dwSecurity, ci);
        while (SUCCEEDED(hr))
        {
            ((CWmiDbController *)m_pController)->AddSecurityDescriptor(ci.dObjectId);

            hr = GetNext_ClassImages(pConn, ci);
        }

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

    }

Exit:

    if (m_pController)
        GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());

    return hr;
}

//***************************************************************************
//
//  GetSuperClassInfo
//
//***************************************************************************

HRESULT GetSuperClassInfo(CSQLConnection *pConn, CSchemaCache *pCache, SQL_ID dClassId, BOOL &bKeyless,
                        SQLIDs *pLockedIDs)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLASSMAP cd;
    OBJECTMAP oj;
    SQL_ID dSuperClass = 0;

    hr = GetFirst_ClassMap(pConn, dClassId, cd);
    if (SUCCEEDED(hr))
    {        
        dSuperClass = cd.dSuperClassId;

        pCache->LockDynasty(dSuperClass);
        pLockedIDs->push_back(dSuperClass);       

        hr = GetFirst_ObjectMap(pConn, dClassId, oj);
        if (SUCCEEDED(hr))
        {
            //DEBUGTRACE((LOG_WBEMCORE, "GetSuperClassInfo %S\n", cd.sClassName));

            if (oj.iObjectFlags & REPDRVR_FLAG_ABSTRACT ||
                oj.iObjectFlags & REPDRVR_FLAG_UNKEYED)
                bKeyless = TRUE;

            hr = pCache->AddClassInfo(cd.dClassId, 
                    cd.sClassName, cd.dSuperClassId, cd.dDynastyId, oj.dObjectScopeId, oj.sObjectKey, oj.iObjectFlags);
            if (SUCCEEDED(hr))
            {
                hr = LoadSchemaProperties (pConn, pCache, dClassId);
                if (SUCCEEDED(hr) && dSuperClass && dSuperClass != 1)
                    hr = GetSuperClassInfo(pConn, pCache, dSuperClass, bKeyless, pLockedIDs);
            }
        }

        cd.Clear();
        oj.Clear();
    }    

    return hr;
}

//***************************************************************************
//
//  GetDerivedClassInfo
//
//***************************************************************************

HRESULT GetDerivedClassInfo(CSQLConnection *pConn, CSchemaCache *pCache, SQL_ID dClassId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    SQLIDs ids;
    
    CLASSMAP cd;
    OBJECTMAP oj;
    SQL_ID dClass = 0;

    if (dClassId != 1)
    {
        hr = GetFirst_ClassMapBySuperClass(pConn, dClassId, cd);
        while (SUCCEEDED(hr))
        {
            ids.push_back(cd.dClassId);        
        
            hr = GetNext_ClassMap(pConn, cd);
        }

        if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;

        for (int i = 0; i < ids.size(); i++)
        {
            dClass = ids.at(i);

            if (!pCache->Exists(dClass))
            {
                hr = GetFirst_ClassMap(pConn, dClass, cd);
                hr = GetFirst_ObjectMap(pConn, dClass, oj);
                if (SUCCEEDED(hr))
                {            
                    //DEBUGTRACE((LOG_WBEMCORE, "GetDerivedClassInfo %S\n", cd.sClassName));

                    hr = pCache->AddClassInfo(cd.dClassId, 
                            cd.sClassName, cd.dSuperClassId, cd.dDynastyId, oj.dObjectScopeId, oj.sObjectKey, oj.iObjectFlags);
                    if (SUCCEEDED(hr))
                    {
                        hr = LoadSchemaProperties (pConn, pCache, dClass);
                        if (SUCCEEDED(hr))
                            hr = GetDerivedClassInfo(pConn, pCache, dClass);
                    }
                }

                cd.Clear();
                oj.Clear();
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::LoadClassInfo
//
//***************************************************************************

HRESULT CWmiDbSession::LoadClassInfo (CSQLConnection *_pConn, SQL_ID dClassId, BOOL bDeep)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BOOL bRelease = FALSE;
    CSQLConnection *pConn = _pConn;
    _WMILockit lkt(GetCS());

    DWORD dwSize = GetSchemaCache()->GetTotalSize();
    DWORD dwMax = GetSchemaCache()->GetMaxSize();
    int i = 0;

    if (dwMax <= dwSize)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Repository schema cache has exceeded limit of %ld bytes (%ld).  Resizing...\n", dwMax, dwSize));

        // We do this here, so we ensure that *only* entire dynasties
        // get loaded.  Its OK if we exceed the cache as long as
        // everything in the cache is in use.

        hr = GetSchemaCache()->ResizeCache();
    }


    GetSchemaCache()->LockDynasty(dClassId);
    m_Dynasties[GetCurrentThreadId()].push_back(dClassId);

    // Check if this exists in the cache.
    // If so, stop now.

    //if (GetSchemaCache()->Exists(dClassId))
    //    return WBEM_S_NO_ERROR;

    if (!pConn && m_pController)
    {
        hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());
        if (SUCCEEDED(hr))
            bRelease = TRUE;
        else
            return hr;
    }

    // Now get all derived classes, and all parent classes.
    // ====================================================

    BOOL bKeyless = FALSE;
    hr = GetSuperClassInfo(pConn, GetSchemaCache(), dClassId, bKeyless, &m_Dynasties[GetCurrentThreadId()]);
    if (SUCCEEDED(hr) && (!bKeyless || bDeep))
        hr = GetDerivedClassInfo(pConn, GetSchemaCache(), dClassId);
    
    if (bRelease && m_pController)
        GetSQLCache()->ReleaseConnection(pConn);

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::LoadClassInfo
//
//***************************************************************************

HRESULT CWmiDbSession::LoadClassInfo (CSQLConnection *_pConn, LPCWSTR lpDynasty, SQL_ID dScopeId, BOOL bDeep)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    DWORD dwSize = GetSchemaCache()->GetTotalSize();
    DWORD dwMax = GetSchemaCache()->GetMaxSize();
    SQLIDs ids;
    int i = 0;

    if (dwMax <= dwSize)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Repository schema cache has exceeded limit of %ld bytes (%ld).  Resizing...\n", dwMax, dwSize));

        // We do this here, so we ensure that *only* entire dynasties
        // get loaded.  Its OK if we exceed the cache as long as
        // everything in the cache is in use.

        hr = GetSchemaCache()->ResizeCache();

    }

    BOOL bRelease = FALSE;
    CSQLConnection *pConn = _pConn;

    if (!pConn && m_pController)
    {
        hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());
        if (SUCCEEDED(hr))
            bRelease = TRUE;
        else
            return hr;
    }

    CLASSMAP cd;
    OBJECTMAP oj;

    if (!lpDynasty)
    {
        if ((GetSchemaCache()->Exists(1)))
            return WBEM_S_NO_ERROR;

        hr = OpenEnum_ClassMap(pConn, cd);
        while (SUCCEEDED(hr))
        {
            if (cd.dSuperClassId == 0)
                ids.push_back(cd.dClassId);
            hr = GetNext_ClassMap(pConn, cd);
        }

        for (i = 0; i < ids.size(); i++)
        {
            hr = GetFirst_ClassMap(pConn, ids.at(i), cd);
            hr = GetFirst_ObjectMap(pConn, ids.at(i), oj);
            if (SUCCEEDED(hr))
                hr = GetSchemaCache()->AddClassInfo(oj.dObjectId, 
                        cd.sClassName, cd.dSuperClassId, cd.dDynastyId, oj.dObjectScopeId, oj.sObjectKey, oj.iObjectFlags);
            cd.Clear();
            oj.Clear();

            if (FAILED(hr))
                break;

            hr = LoadSchemaProperties (pConn, &((CWmiDbController *)m_pController)->SchemaCache, ids.at(i));
            if (FAILED(hr))
                break;
        }       
    }
    else
    {
        // We need to find all classes derived from 
        // this dynasty. 

        SQL_ID dDynasty = 0;
        BOOL bFound = FALSE;

        hr = GetFirst_ClassMapByName(pConn, lpDynasty, cd);
        while (SUCCEEDED(hr))
        {
            hr = GetFirst_ObjectMap(pConn, cd.dClassId, oj);
            if (!oj.dObjectScopeId || oj.dObjectScopeId == dScopeId)
            {
                oj.Clear();
                cd.Clear();
                bFound = TRUE;
                dDynasty = cd.dClassId;
                break;
            }
            oj.Clear();
            hr = GetNext_ClassMap(pConn, cd);
        }

        if (bFound)
            hr = LoadClassInfo(pConn, dDynasty, bDeep);
        else
            hr = WBEM_E_NOT_FOUND;
    }

    if (bRelease && m_pController)
        GetSQLCache()->ReleaseConnection(pConn);

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::ExecQuery
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::ExecQuery( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ IWbemQuery __RPC_FAR *pQuery,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwHandleType,
    /* [out] */ DWORD *dwMessageFlags,
    /* [out] */ IWmiDbIterator __RPC_FAR *__RPC_FAR *pQueryResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;    

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwHandleType == WMIDB_HANDLE_TYPE_INVALID || !pQuery || !pQueryResult || !pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED)
            return WBEM_E_INVALID_PARAMETER;

    if (dwFlags & ~WMIDB_FLAG_QUERY_DEEP &~WMIDB_FLAG_QUERY_SHALLOW & ~WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        if (dwMessageFlags)
            *dwMessageFlags = WBEM_REQUIREMENTS_STOP_POSTFILTER;
    
        DWORD dwOpenTable = 0;
        SQL_ID dClassId = 0;
        JET_TABLEID tableid = 0;

        CSQLConnection *pConn = NULL;

        // Obtain a database connection

        if (m_pController)
            hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());

        if (FAILED(hr) || !pQuery || !pScope)
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
        else
        {
            BOOL bDeleteQuery = FALSE;

            SQL_ID dwNsId = 0;
            IWbemClassObject *pTemp = NULL;
            CESETokens *pToks = NULL;
            int iLastPos = 0;
            BOOL bEnum = FALSE;
            BOOL bWQL = TRUE;
            BOOL bClasses = FALSE;
            int iStartCrit = 0;
            HRESULT hrMatch = WBEM_S_NO_ERROR;

            dwNsId = ((CWmiDbHandle *)pScope)->m_dObjectId;
            SQL_ID dScopeClassId = ((CWmiDbHandle *)pScope)->m_dClassId;
            SQL_ID dSuperScope = ((CWmiDbHandle *)pScope)->m_dScopeId;
            DWORD dwScopeType = ((CWmiDbHandle *)pScope)->m_dwHandleType ;

            if (pScope && !(dwScopeType & WMIDB_HANDLE_TYPE_CONTAINER))
                hr=VerifyObjectSecurity (pConn, dwNsId, dScopeClassId, dSuperScope, 0, WBEM_ENABLE);

            
            SWbemAssocQueryInf *pNode = NULL;
            hr = pQuery->GetAnalysis(WMIQ_ANALYSIS_ASSOC_QUERY,
                        0, (void **)&pNode);
            if (FAILED(hr))
            {
                BOOL bIndexCols = FALSE, bHierarchy = 0, bSuperSet = FALSE;

                // Since ESE has no query engine, we need to:
                // Parse the query
                // Figure out which index to use and prefilter
                // slap the parsed output onto the iterator as a post-filter.
                // if the query includes elements that cannot be handled in memory,
                //   we need to return WBEM_E_INVALID_QUERY or WBEM_E_PROVIDER_NOT_CAPABLE
                // ================================================================

                CESEBuilder bldr(&((CWmiDbController *)m_pController)->SchemaCache, this, pConn);

                hr = bldr.FormatSQL(((CWmiDbHandle *)pScope)->m_dObjectId, ((CWmiDbHandle *)pScope)->m_dClassId,
                        ((CWmiDbHandle *)pScope)->m_dScopeId, pQuery, &pToks, dwFlags, 
                        ((CWmiDbHandle *)pScope)->m_dwHandleType, &dClassId, &bHierarchy, 
                        &bIndexCols, &bSuperSet, &bDeleteQuery);

                // Make sure we have access to the target class.
                // We won't check locks at this point, since that will 
                // be the iterator's job.

                // If we can't analyze this query, 
                // we certainly can't delete the results.
                if (bDeleteQuery && bSuperSet)
                    hr = WBEM_E_NOT_SUPPORTED;

                if (!pToks && SUCCEEDED(hr))
                    hr = WBEM_E_INVALID_QUERY;

                if (SUCCEEDED(hr))
                {
                    if (dwMessageFlags)
                        *dwMessageFlags = (bSuperSet ? WBEM_REQUIREMENTS_START_POSTFILTER : WBEM_REQUIREMENTS_STOP_POSTFILTER);

                    if (SUCCEEDED(hr))
                    {                      
                        int i;
                        BOOL bEnumSubClass = TRUE;
                        SQL_ID dClassCrit = 0, dSuperClassCrit = 0, dDynastyCrit = 0;

                        if (dClassId == 1) // meta_class - we only want classes
                        {
                            bClasses = TRUE;
                            bEnumSubClass = FALSE;

                            // * __Class = ...  => Limit to single class
                            // * __SuperClass = => Prescan on SuperClassId
                            // * __Dynasty =    => Prescan on DynastyId
                            // * __this isa     => Enum subclasses + list criteria.

                            DWORD dwClassPropID = 0, dwSuperClassPropID = 0, dwDynastyPropID = 0;
                            DWORD dwDerivationPropID = 0;
                            BOOL bClassCrit = FALSE, bSuperClassCrit = FALSE, bDynastyCrit = FALSE;

                            GetSchemaCache()->GetPropertyID(L"__Class", 1, 
                                0, REPDRVR_IGNORE_CIMTYPE, dwClassPropID);
                            GetSchemaCache()->GetPropertyID(L"__SuperClass", 1, 
                                0, REPDRVR_IGNORE_CIMTYPE, dwSuperClassPropID);
                            GetSchemaCache()->GetPropertyID(L"__Dynasty", 1, 
                                0, REPDRVR_IGNORE_CIMTYPE, dwDynastyPropID);
                            GetSchemaCache()->GetPropertyID(L"__Derivation", 1, 
                                0, REPDRVR_IGNORE_CIMTYPE, dwDerivationPropID);

                            BOOL bFound = FALSE;                                
                            for (i = 0; i < pToks->GetNumTokens(); i++)
                            {
                                ESEToken *pTok = pToks->GetToken(i);
                                if (pTok && pTok->tokentype == ESE_EXPR_TYPE_EXPR)
                                {                                        
                                    if (((ESEWQLToken *)pTok)->tokentype == ESE_EXPR_TYPE_OR ||
                                        ((ESEWQLToken *)pTok)->tokentype == ESE_EXPR_TYPE_NOT)
                                    {
                                        bClassCrit = 0;
                                        bSuperClassCrit = 0;
                                        bDynastyCrit = 0;
                                        break;
                                    }
                                    if (((ESEWQLToken *)pTok)->optype == WQL_TOK_EQ)
                                    {
                                        SQL_ID dClassId2 = 0, dDynasty = 0;
                                        
                                        if (wcslen((((ESEWQLToken *)pTok)->Value.sValue)))
                                        {
                                            hr =  GetSchemaCache()->GetClassID
                                                (((ESEWQLToken *)pTok)->Value.sValue, dwNsId, dClassId2, &dDynasty);
                                        }
                                        
                                        if ((((ESEWQLToken *)pTok)->dPropertyId == dwClassPropID))
                                        {
                                            bClassCrit = TRUE;
                                            dClassCrit = dClassId2;
                                        }
                                        else if ((((ESEWQLToken *)pTok)->dPropertyId == dwSuperClassPropID))
                                        {
                                            bSuperClassCrit = TRUE;
                                            dSuperClassCrit = dClassId2;
                                        }
                                        else if ((((ESEWQLToken *)pTok)->dPropertyId == dwDynastyPropID))
                                        {
                                            bDynastyCrit = TRUE;
                                            dDynastyCrit = dClassId2;
                                        }
                                        else if ((((ESEWQLToken *)pTok)->dPropertyId == dwDerivationPropID))
                                        {                                            
                                            bDynastyCrit = TRUE;
                                            dDynastyCrit = dDynasty;
                                            dClassId = dClassId2;
                                            if (dDynasty != dClassId2)
                                            {
                                                bEnumSubClass = TRUE;
                                            }
                                        }
                                    }
                                }
                            }
                            pToks->SetIsMetaClass(TRUE);    
                            
                            if (bClassCrit)
                            {
                                OBJECTMAP oj;
                                hrMatch = GetFirst_ObjectMap(pConn, dClassCrit, oj);
                                tableid = ((CESEConnection *)pConn)->GetTableID(L"ObjectMap");
                                dwOpenTable = OPENTABLE_OBJECTMAP;
                                oj.Clear();
                            }
                            else if (bSuperClassCrit)
                            {
                                CLASSMAP cm;
                                if (!dSuperClassCrit)
                                    dSuperClassCrit = 1;
                                hrMatch = GetFirst_ClassMapBySuperClass(pConn, dSuperClassCrit, cm);
                                tableid = ((CESEConnection *)pConn)->GetTableID(L"ClassMap");
                                dwOpenTable = OPENTABLE_CLASSMAP;
                                cm.Clear();
                            }
                            else if (bDynastyCrit)
                            {
                                CLASSMAP cm;
                                hrMatch = GetFirst_ClassMapByDynasty(pConn, dDynastyCrit, cm);
                                tableid = ((CESEConnection *)pConn)->GetTableID(L"ClassMap");
                                dwOpenTable = OPENTABLE_CLASSMAP;
                                cm.Clear();
                            }
                            else // Scan all ClassMap
                            {
                                pToks->AddSysExpr(0, dClassId);
                                CLASSMAP cm;
                                hrMatch = OpenEnum_ClassMap(pConn, cm);
                                tableid = ((CESEConnection *)pConn)->GetTableID(L"ClassMap");
                                dwOpenTable = OPENTABLE_CLASSMAP;
                                cm.Clear();
                            }

                        }
                        
                        if (bEnumSubClass)
                        {
                            // If we need to limit the classes by class ID
                            // get the derived class list.
                            // Disregard if this is meta_class - we're only
                            // interested in returning classes.

                            SQL_ID *pIDs = NULL;
                            int iNumChildren = 0;

                            GetSchemaCache()->GetDerivedClassList(dClassId, &pIDs, iNumChildren, FALSE);
                            if (pIDs)
                            {
                                for (i = iNumChildren-1; i >= 0; i--)
                                {
                                    SQL_ID d = pIDs[i];
                                    pToks->AddSysExpr(0, d);
                                }
                                delete pIDs;
                            }
                            // Optimization for class with no children.
                            if (!iNumChildren && pToks->IsMetaClass() && (dClassId != 1))
                            {
                                CLASSMAP cm;
                                hrMatch = GetFirst_ClassMap(pConn, dClassId, cm);
                                tableid = ((CESEConnection *)pConn)->GetTableID(L"ClassMap");
                                dwOpenTable = OPENTABLE_CLASSMAP;
                                cm.Clear();
                            }
                        }                            

                        if ( ((CWmiDbHandle *)pScope)->m_dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
                        {
                            CONTAINEROBJ co;
                            hrMatch = GetFirst_ContainerObjs(pConn, ((CWmiDbHandle *)pScope)->m_dObjectId, co);
                            co.Clear();
                            dwOpenTable = OPENTABLE_CONTAINEROBJS;
                            tableid = ((CESEConnection *)pConn)->GetTableID(L"ContainerObjs");
                        }
                        else
                        {
                            if (bIndexCols)
                            {
                                // Seek to property ID of first indexed criteria
                            
                                DWORD dwNumToks = pToks->GetNumTokens();
                                for (i = 0; i < dwNumToks; i++)
                                {
                                    ESEToken *pTok = pToks->GetToken(i);
                                    if (pTok && pTok->tokentype == ESE_EXPR_TYPE_EXPR)
                                    {
                                        INDEXDATA id;                                        
                                        iLastPos = i;
                                        DWORD dwPos = 0;

                                        ESEWQLToken *pTok2 = (ESEWQLToken *)pTok;
                                        if (pTok2->bIndexed)
                                        {
                                            switch(pTok2->Value.valuetype)
                                            {
                                            case ESE_VALUE_TYPE_SQL_ID:
                                                SetupIndexDataAccessor(pConn, WMIDB_STORAGE_NUMERIC, dwPos, NULL);
                                                tableid = ((CESEConnection *)pConn)->GetTableID(L"IndexNumericData");
                                                hrMatch = GetFirst_IndexDataByProperty(pConn, pTok2->dPropertyId,
                                                    id, tableid, SQL_POS_INDEXNUMERIC);
                                                dwOpenTable = OPENTABLE_INDEXNUMERIC;
                                                id.Clear();
                                                break;
                                            case ESE_VALUE_TYPE_STRING:
                                                SetupIndexDataAccessor(pConn, WMIDB_STORAGE_STRING, dwPos, NULL);
                                                tableid = ((CESEConnection *)pConn)->GetTableID(L"IndexStringData");
                                                hrMatch = GetFirst_IndexDataByProperty(pConn, pTok2->dPropertyId,
                                                    id, tableid, SQL_POS_INDEXSTRING);
                                                dwOpenTable = OPENTABLE_INDEXSTRING;
                                                id.Clear();
                                                break;
                                            case ESE_VALUE_TYPE_REAL:
                                                SetupIndexDataAccessor(pConn, WMIDB_STORAGE_REAL, dwPos, NULL);
                                                tableid = ((CESEConnection *)pConn)->GetTableID(L"IndexRealData");
                                                hrMatch = GetFirst_IndexDataByProperty(pConn, pTok2->dPropertyId,
                                                    id, tableid, SQL_POS_INDEXREAL);
                                                dwOpenTable = OPENTABLE_INDEXREAL;
                                                id.Clear();
                                                break;
                                            case ESE_VALUE_TYPE_REF:
                                                SetupIndexDataAccessor(pConn, WMIDB_STORAGE_REFERENCE, dwPos, NULL);
                                                tableid = ((CESEConnection *)pConn)->GetTableID(L"IndexRefData");
                                                hrMatch = GetFirst_IndexDataByProperty(pConn, pTok2->dPropertyId,
                                                    id, tableid, SQL_POS_INDEXREF);
                                                dwOpenTable = OPENTABLE_INDEXREF;
                                                id.Clear();
                                                break;
                                            default:
                                                break;
                                            }
                                            if (dwOpenTable)
                                                break;
                                        }
                                    }
                                }                                
                            }

                            if (!dwOpenTable)
                            {
                                dwOpenTable = OPENTABLE_OBJECTMAP;

                                OBJECTMAP oj;
                                // Find the first class that matches.
                                DWORD dwNumToks = pToks->GetNumTokens();
                                for (i = 0; i < dwNumToks; i++)
                                {
                                    ESEToken *pTok = pToks->GetToken(i);
                                    if (pTok->tokentype == ESE_EXPR_TYPE_EXPR)
                                    {
                                        ESEWQLToken *pTok2 = (ESEWQLToken *)pTok;
                                        if (pTok2->Value.valuetype == ESE_VALUE_TYPE_SYSPROP)
                                        {
                                            if (pTok2->dClassId)
                                            {
                                                hrMatch = GetFirst_ObjectMapByClass(pConn, pTok2->dClassId, oj);
                                                if (SUCCEEDED(hrMatch))
                                                {
                                                    oj.Clear();
                                                    iLastPos = i;
                                                    break;
                                                }
                                                oj.Clear();
                                            }
                                        }
                                    }
                                }
                                
                                tableid = ((CESEConnection *)pConn)->GetTableID(L"ObjectMap");
                            }
                            
                        }
                    }
                }
            }
            else
            {
                SQL_ID dObjId = 0;
                CESEBuilder bldr(&((CWmiDbController *)m_pController)->SchemaCache, this, pConn);

                if (SUCCEEDED(hr))
                {
                    // Get dObjId.
                    SQL_ID dAssocClassId = 0, dResultClassId = 0;

                    IWbemPath *pPath = NULL;
                    hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                            IID_IWbemPath, (LPVOID *) &pPath);

                    BOOL bIsClass = FALSE;
                    if (SUCCEEDED(hr))
                    {
                        CReleaseMe r (pPath);
                        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pNode->m_pszPath);
                        IWmiDbHandle *pTemp = NULL;
                        hr = GetObject(pScope, pPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE, &pTemp);
                        if (SUCCEEDED(hr))
                        {
                            // We need rudimentary tempQL support
                            BOOL bSuperSet = FALSE;

                            dObjId = ((CWmiDbHandle *)pTemp)->m_dObjectId;                       
                            bIsClass = ((CWmiDbHandle *)pTemp)->m_dClassId == 1 ? TRUE: FALSE;

                            pTemp->Release();
                            hr = bldr.FormatSQL(((CWmiDbHandle *)pScope)->m_dObjectId, ((CWmiDbHandle *)pScope)->m_dClassId,
                                    ((CWmiDbHandle *)pScope)->m_dScopeId, dObjId, pNode->m_pszResultClass, 
                                    pNode->m_pszAssocClass, pNode->m_pszRole, pNode->m_pszResultRole, pNode->m_pszRequiredQualifier, 
                                    pNode->m_pszRequiredAssocQualifier, pNode->m_uFeatureMask, &pToks, dwFlags, 
                                    ((CWmiDbHandle *)pScope)->m_dwHandleType, &dAssocClassId, &dResultClassId, &bSuperSet);

                            bWQL = FALSE;

                            if (!pToks && SUCCEEDED(hr))
                                hr = WBEM_E_INVALID_QUERY;

                            if (SUCCEEDED(hr))
                            {
                                if (dwMessageFlags)
                                {
                                    *dwMessageFlags = (bSuperSet ? WBEM_REQUIREMENTS_START_POSTFILTER : WBEM_REQUIREMENTS_STOP_POSTFILTER);

                                    if (pNode->m_uFeatureMask & (QUERY_TYPE_SCHEMA_ONLY + QUERY_TYPE_CLASSDEFS_ONLY))
                                        *dwMessageFlags = TRUE;
                                }

                                    hr=VerifyClassSecurity (pConn, dObjId, WBEM_ENABLE);
                                if (SUCCEEDED(hr) && dAssocClassId)
								{
									hr=VerifyClassSecurity (pConn, dAssocClassId, WBEM_ENABLE);
								}
								if (SUCCEEDED(hr) && dResultClassId)
								{
									hr=VerifyClassSecurity(pConn, dResultClassId, WBEM_ENABLE);
								}
                            }
                        }
                    }

                    pQuery->FreeMemory(pNode);

                    if (SUCCEEDED(hr))
                    {
                        if (!bIsClass)
                        {
                          // Use the target object, REFID

                            INDEXDATA is;
                            DWORD dwPos = 0;
                            hrMatch = GetFirst_IndexDataRef(pConn, dObjId, is, tableid, dwPos);
                            dwOpenTable = OPENTABLE_INDEXREF;
                            is.Clear();
                            tableid = ((CESEConnection *)pConn)->GetTableID(L"IndexRefData");
                        }
                        else
                        {
                            // We need to examine each class, and see if it contains 
                            // an association or reference to the target class.

                            REFERENCEPROPERTIES pm;
                            hrMatch = GetFirst_ReferencePropertiesByRef (pConn, dObjId, pm);
                            dwOpenTable = OPENTABLE_REFPROPS;
                            tableid = ((CESEConnection *)pConn)->GetTableID(L"ReferenceProperties");
                            if (dwMessageFlags)
                                *dwMessageFlags = WBEM_REQUIREMENTS_START_POSTFILTER;
                        }
                    }
                }
            }

            // Construct and return the iterator.
            // This contains the open SQL connection positioned
            // on the first valid row            

            if (SUCCEEDED(hr))
            {
                DWORD dwRows;
                CWmiESEIterator *pNew = new CWmiESEIterator;
                if (pNew)
                {
                    AddRef_Lock();
                    pNew->m_pSession = this;
                    pNew->m_pConn = pConn;
                    pNew->m_pToks = pToks;
                    if (SUCCEEDED(hrMatch))
                        pNew->m_dwOpenTable = dwOpenTable;
                    else
                        pNew->m_dwOpenTable = 0;

                    pNew->m_tableid = tableid;
                    pNew->m_iLastPos = iLastPos;
                    if (bEnum)
                        pNew->m_iStartPos = iStartCrit;
                    else 
                        pNew->m_iStartPos = 0;
                    pNew->m_bEnum = bEnum;
                    pNew->m_bWQL = bWQL;
                    pNew->m_bClasses = bClasses;
                    pNew->AddRef();
                    AddRef(); // The iterator releases us on its own release

                    // If this was a delete query,
                    // enumerate the results, and delete 'em

                    if (bDeleteQuery)
                    {
                        hr = DeleteRows(pScope, pNew, IID_IWmiDbHandle);
                        pNew->Release();
                        *pQueryResult = NULL;
                    }

                    // select query. Give them the iterator

                    else if (pQueryResult)
                    {
                        *pQueryResult = (IWmiDbIterator *)pNew;                        
                    }
                }
                else
                {                
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }
            else               
                delete pToks;
        }

        // If we failed, we need to release the connection
        // Otherwise, it will be attached to the iterator, 
        // and will be released when the last result row has been returned

        if (FAILED(hr) && pConn && m_pController)
            GetSQLCache()->ReleaseConnection(pConn);
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::ExecQuery\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }


    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::Enumerate
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Enumerate( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbIterator __RPC_FAR *__RPC_FAR *ppQueryResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID || !pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwRequestedHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED &~WMIDB_HANDLE_TYPE_CONTAINER
            &~ WMIDB_HANDLE_TYPE_SCOPE)
            return WBEM_E_INVALID_PARAMETER;

    try
    {
        {
            _WMILockit lkt(GetCS());

            if (!((CWmiDbController *)m_pController)->m_bCacheInit)
            {
                hr = LoadSchemaCache();
                if (SUCCEEDED(hr))
                    ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
                else
                    return hr;
            }
        }

        JET_TABLEID tableid = 0;
        MappedProperties *pProps;
        DWORD dwNumProps;
        BOOL bHierarchy = FALSE;

        SQL_ID dwNsId = 0, dClassId = 0;
        _bstr_t sPath;
        int iNumRows = 0;
        IWbemClassObject *pTemp = NULL;

        if (pScope)
        {
            // CVADAI: This is a container, not a scope, so this 
            // info won't be cached.

            dwNsId = ((CWmiDbHandle *)pScope)->m_dObjectId;
            dClassId = ((CWmiDbHandle *)pScope)->m_dClassId;
            //SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dScopeId;

		    //hr = VerifyObjectSecurity(dwNsId, dClassId, dScopeId, 0, WBEM_ENABLE);
        }
        if (SUCCEEDED(hr) && m_pController)
        {
            DWORD dwRows;
            IRowset *pRowset = NULL;
            CSQLConnection *pConn=NULL;        
            
            hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());
            if (SUCCEEDED(hr))
            {
                // Here we need to do the equivalent enumeration based
                // on table or index scan, and return a custom iterator
                // Basically, we stuff the filter conditions on the iterator,
                // and return it.
                // ====================================================

                DWORD dwOpenTable = 0;
                CESETokens *pToks = NULL;
                wchar_t sSQL [1024];
                DWORD dwHandleType = ((CWmiDbHandle *)pScope)->m_dwHandleType;

                if (dClassId == INSTANCESCLASSID)
                {
                    // ClassId = dwNsId AND
                    // ObjectScopeId = dScopeId

                    OBJECTMAP oj;
                    SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dScopeId;

                    hr = GetFirst_ObjectMapByClass(pConn, dwNsId, oj);
                    oj.Clear();
                    if (SUCCEEDED(hr))
                        dwOpenTable = OPENTABLE_OBJECTMAP;
                    tableid = ((CESEConnection *)pConn)->GetTableID(L"ObjectMap");

                    pToks = new CESETokens;
                    if (pToks)
                        pToks->AddSysExpr(dScopeId, dwNsId);
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                
                }
                else if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
                {
                    // ContainerId = dContainerId (Use ContainerObjs)

                    SQL_ID dContainerId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                    pToks = new CESETokens;
                    if (pToks)
                    {
                        CONTAINEROBJ co;
                        hr = GetFirst_ContainerObjs(pConn, dContainerId, co);
                        if (SUCCEEDED(hr))
                            dwOpenTable = OPENTABLE_CONTAINEROBJS;
                        co.Clear();
                        tableid = ((CESEConnection *)pConn)->GetTableID(L"ContainerObjs");
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
                // Scope
                else
                {
                    // ObjectScopeId = dwNsId
                    OBJECTMAP oj;
                    SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;

                    hr = GetFirst_ObjectMapByScope(pConn, dScopeId, oj);
                    oj.Clear();
                    if (SUCCEEDED(hr))
                        dwOpenTable = OPENTABLE_OBJECTMAP;
                    tableid = ((CESEConnection *)pConn)->GetTableID(L"ObjectMap");
                    pToks = new CESETokens;
                    if (pToks)
                        pToks->AddSysExpr(dScopeId, 0);
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }

                if (hr == WBEM_E_NOT_FOUND)
                    hr = WBEM_S_NO_ERROR; // create the iterator, for consistency.

                if (SUCCEEDED(hr))
                {
                    CWmiESEIterator *pNew = new CWmiESEIterator;
                    if (pNew)
                    {
                        *ppQueryResult = (IWmiDbIterator *)pNew;

                        pNew->m_pConn = pConn;  // Releasing the iterator will release this guy.
                        pNew->m_pSession = this;
                        pNew->m_pConn = pConn;
                        pNew->m_pToks = pToks;
                        pNew->m_dwOpenTable = dwOpenTable;
                        pNew->m_tableid = tableid;
                        pNew->AddRef();
                        AddRef();
                    }
                    else
                    {
                        if (m_pController)
                            GetSQLCache()->ReleaseConnection(pConn);
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    if (m_pController)
                        GetSQLCache()->ReleaseConnection(pConn);
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::Enumerate\n"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::InsertArray
//
//***************************************************************************

HRESULT CWmiDbSession::InsertArray(CSQLConnection *pConn,IWmiDbHandle *pScope, 
                                           SQL_ID dObjectId, SQL_ID dClassId, 
                                           DWORD dwPropertyID, VARIANT &vValue, long lFlavor, DWORD dwRefID,
                                           LPCWSTR lpObjectKey , LPCWSTR lpPath , SQL_ID dScope, CIMTYPE ct )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IRowset *pIRowset = NULL;
    DWORD dwRows = 0;
    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;
    
    if (vValue.vt == VT_UNKNOWN)
    {
        BYTE *pBuff = NULL;
        DWORD dwLen = 0;
        IUnknown *pUnk = V_UNKNOWN (&vValue);
        if (pUnk)
        {
            _IWmiObject *pInt = NULL;
            hr = pUnk->QueryInterface(IID__IWmiObject, (void **)&pInt);
            if (SUCCEEDED(hr))
            {
                pInt->GetObjectMemory(NULL, 0, &dwLen);
                pBuff = new BYTE [dwLen];
                if (pBuff)
                {
                    CDeleteMe <BYTE> d (pBuff);
                    DWORD dwLen1;
                    hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                    if (SUCCEEDED(hr))
                    {
                        hr = CSQLExecProcedure::InsertBlobData(pConn, dClassId, dObjectId,
                                    dwPropertyID, pBuff, dwRefID, dwLen);
                    }
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;

                pInt->Release();
            }                               
        }
    }
    else if (((vValue.vt & 0xFFF) == VT_UI1) || vValue.vt == VT_BSTR)
    {
        BYTE *pBuff = NULL;
        DWORD dwLen = 0;

        // Get the byte buffer out of the safearray.
    
        if ((vValue.vt & 0xFFF) == VT_UI1)
            GetByteBuffer(&vValue, &pBuff, dwLen);
        else // its a bstr.
        {
            dwLen = wcslen(vValue.bstrVal)*2+2;
            char * pTemp = new char[dwLen+1];
            if (pTemp)
            {
                sprintf(pTemp, "%S", vValue.bstrVal);
                pBuff = (unsigned char *)pTemp;
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }

        if (pBuff)
        {                      
            hr = CSQLExecProcedure::InsertBlobData (pConn, dClassId, dObjectId, 
                                       dwPropertyID, pBuff, 0, dwLen);
            delete pBuff;
        }
    }
    else
    {
        bool bIsQfr = FALSE;
        DWORD dwFlags = 0;
        SQL_ID dClassID = 0;
        DWORD dwStorage = 0;

        hr = GetSchemaCache()->GetPropertyInfo (dwPropertyID, NULL, &dClassID, &dwStorage,
            NULL, &dwFlags);

        bIsQfr = (dwFlags & REPDRVR_FLAG_QUALIFIER) ? TRUE : FALSE;        

        SAFEARRAY* psaArray = NULL;
        psaArray = V_ARRAY(&vValue);
        if (psaArray)
        {
            long i = 0;
            int iType = vValue.vt & 0xFF;

            VARIANT vTemp;
            VariantInit(&vTemp);

            long lLBound, lUBound;
            SafeArrayGetLBound(psaArray, 1, &lLBound);
            SafeArrayGetUBound(psaArray, 1, &lUBound);
    
            lUBound -= lLBound;
            lUBound += 1;

            InsertQfrValues *pQfr = NULL;
            int iPos = 0;
            pQfr = new InsertPropValues[lUBound];
            if (!pQfr)
                return WBEM_E_OUT_OF_MEMORY;

            ct = ct & 0xFF;

            for (i = 0; i < lUBound; i++)
            {
                if (ct != CIM_OBJECT)
                {
                    if (iType != VT_NULL && iType != VT_EMPTY)
                    {
                        hr = GetVariantFromArray(psaArray, i, iType, vTemp);
                        LPWSTR lpVal = GetStr(vTemp);
                        CDeleteMe <wchar_t> r1(lpVal);

                        VariantClear(&vTemp);
                        if (FAILED(hr))
                            break;

                        //if (wcslen(lpVal))
                        {
                            pQfr[iPos].iPos = i;
                            pQfr[iPos].iQfrID = dwRefID;
                            pQfr[iPos].iPropID = dwPropertyID;
                            pQfr[iPos].pRefKey = NULL;
                            pQfr[iPos].bLong = false;
                            pQfr[iPos].bIndexed = (dwFlags & (REPDRVR_FLAG_KEY + REPDRVR_FLAG_INDEXED)) ? TRUE : FALSE;
                            pQfr[iPos].iStorageType = dwStorage;
                            pQfr[iPos].dClassId = dClassID;
                            pQfr[iPos].iFlavor = lFlavor;

                            if (ct == CIM_REFERENCE)
                            {
                                pQfr[iPos].bIndexed = TRUE; // References are always keys

                                LPWSTR lpTemp = NULL;
                                IWbemPath *pPath = NULL;

                                hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemPath, (LPVOID *) &pPath);
                                CReleaseMe r8 (pPath);
                                if (SUCCEEDED(hr))
                                {
                                    if (lpVal)
                                    {
                                        LPWSTR lpStrip = StripQuotes2 (lpVal);
                                        CDeleteMe <wchar_t> d (lpStrip);

                                        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpStrip);

                                        hr = NormalizeObjectPathGet(pScope, pPath, &lpTemp, NULL, NULL, NULL, pConn);
                                        CDeleteMe <wchar_t> r1(lpTemp);
                                        if (SUCCEEDED(hr)) 
                                        {
                                            LPWSTR lpTemp2 = NULL;
                                            lpTemp2 = GetKeyString(lpStrip);
                                            CDeleteMe <wchar_t> d (lpTemp2);
                                            pQfr[iPos].pRefKey = new wchar_t [21];
                                            if (pQfr[iPos].pRefKey)
                                                swprintf(pQfr[iPos].pRefKey, L"%I64d", CRC64::GenerateHashValue(lpTemp2));
                                            else
                                                hr = WBEM_E_OUT_OF_MEMORY;
                                        }
                                        else
                                        {
                                            hr = WBEM_S_NO_ERROR;
                                            // Strip off the root namespace prefix and generate the
                                            // pseudo-name.  We have no way of knowing if they entered this
                                            // path correctly.

                                            LPWSTR lpTemp3 = StripUnresolvedName (lpStrip);
                                            CDeleteMe <wchar_t> d2 (lpTemp3);

                                            LPWSTR lpTemp2 = NULL;
                                            lpTemp2 = GetKeyString(lpTemp3);
                                            CDeleteMe <wchar_t> d (lpTemp2);
                                            pQfr[iPos].pRefKey = new wchar_t [21];
                                            if (lpTemp2 && pQfr[iPos].pRefKey)
                                                swprintf(pQfr[iPos].pRefKey, L"%I64d", CRC64::GenerateHashValue(lpTemp2));
                                            else
                                                hr = WBEM_E_OUT_OF_MEMORY;
                                        }

                                        pQfr[iPos].pValue = new wchar_t[wcslen(lpStrip)+1];
                                        if (pQfr[iPos].pValue)
                                            wcscpy(pQfr[iPos].pValue,lpStrip);
                                        else
                                            hr = WBEM_E_OUT_OF_MEMORY;
                                    }
                                    else
                                        pQfr[iPos].pValue = NULL;                                    
                                }                    
                                else 
                                    break;
                            }
                            else
                            {
                                if (lpVal)
                                {
                                    pQfr[iPos].pValue = new wchar_t[wcslen(lpVal)+1];
                                    if (pQfr[iPos].pValue)
                                        wcscpy(pQfr[iPos].pValue,lpVal);
                                    else
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                }
                                else
                                    pQfr[iPos].pValue = NULL;

                                pQfr[iPos].pRefKey = NULL;                    
                            }
                            iPos++;
                        }
                    }
                }
                else
                {
                    // Can't have default embedded object array values.

                    if (lpPath)
                    {
                        hr = GetVariantFromArray(psaArray, i, iType, vTemp);
                        IUnknown *pTemp = V_UNKNOWN(&vTemp);
                        if (pTemp)
                        {
                            BYTE *pBuff = NULL;
                            DWORD dwLen;
                            _IWmiObject *pInt = NULL;
                            hr = pTemp->QueryInterface(IID__IWmiObject, (void **)&pInt);
                            if (SUCCEEDED(hr))
                            {
                                pInt->GetObjectMemory(NULL, 0, &dwLen);
                                pBuff = new BYTE [dwLen];
                                if (pBuff)
                                {
                                    CDeleteMe <BYTE> d (pBuff);
                                    DWORD dwLen1;
                                    hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = CSQLExecProcedure::InsertBlobData(pConn, dClassId, dObjectId,
                                                    dwPropertyID, pBuff, i, dwLen);
                                    }
                                }
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;

                                pInt->Release();
                            }
                            else
                                break;
                        }                        
                    }
                }
            }
            if (SUCCEEDED(hr))
                hr = CSQLExecProcedure::InsertBatch (pConn, dObjectId, 0, 0, pQfr, iPos);

            // Finally clean up the upper array bounds 
            // (if this array used to be bigger...)
            // ====================================

            if (SUCCEEDED(hr))
            {
                CLASSDATA cd;
                IDs ids;

                hr = GetFirst_ClassData(pConn, dObjectId, cd, dwPropertyID);
                while (SUCCEEDED(hr))
                {
                    if (dwPropertyID == cd.iPropertyId &&
                        dwRefID == cd.iQfrPos &&
                        cd.iArrayPos >= i)
                    {
                        ids.push_back (cd.iArrayPos);
                    }
                    hr = GetNext_ClassData(pConn, cd);
                    if (dObjectId != cd.dObjectId)
                    {
                        cd.Clear();
                        break;
                    }
                }
                hr = WBEM_S_NO_ERROR;

                for (i = 0; i < ids.size(); i++)
                    hr = DeleteClassData(pConn, dwPropertyID, dObjectId, ids.at(i));
            }
            delete pQfr;
        }           
    }

    return hr;
}

HRESULT CWmiDbSession::CustomGetObject(IWmiDbHandle *pScope, IWbemPath *pPath, LPWSTR lpObjectKey, 
        DWORD dwFlags, DWORD dwRequestedHandleType, IWmiDbHandle **ppResult)
{return E_NOTIMPL;}
HRESULT CWmiDbSession::CustomGetMapping(CSQLConnection *pConn, IWmiDbHandle *pScope, LPWSTR lpClassName, IWbemClassObject **ppMapping)
{return E_NOTIMPL;}
HRESULT CWmiDbSession::CustomCreateMapping(CSQLConnection *pConn, LPWSTR lpClassName, IWbemClassObject *pClassObj, IWmiDbHandle *pScope)
{return E_NOTIMPL;}
HRESULT CWmiDbSession::CustomPutInstance(CSQLConnection *pConn, IWmiDbHandle *pScope, SQL_ID dClassId, 
    DWORD dwFlags, IWbemClassObject **ppObjToPut, LPWSTR lpClassName)
{return E_NOTIMPL;}
HRESULT CWmiDbSession::CustomFormatSQL(IWmiDbHandle *pScope, IWbemQuery *pQuery, _bstr_t &sSQL, SQL_ID *dClassId, 
    MappedProperties **ppMapping, DWORD *dwNumProps, BOOL *bCount)
{return E_NOTIMPL;}
HRESULT CWmiDbSession::CustomDelete(CSQLConnection *pConn, IWmiDbHandle *pScope, IWmiDbHandle *pHandle, LPWSTR lpClassName) 
{return E_NOTIMPL;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\ese\wqltoese.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   wqltoese.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _WQLTOESE_H_
#define _WQLTOESE_H_

#include <wqllex.h>

typedef __int64 SQL_ID;

class CWmiDbHandle;
class CWmiDbSession;
class CSchemaCache;
class CSQLConnection;

#define QUERY_TYPE_CLASSDEFS_ONLY 0x1
#define QUERY_TYPE_GETREFS        0x2
#define QUERY_TYPE_GETASSOCS      0x4
#define QUERY_TYPE_SCHEMA_ONLY    0x8

// WQL - ESE token converter

typedef enum
{
    ESE_TEMPQL_TYPE_NONE  = 0,
    ESE_TEMPQL_TYPE_REF   = 1,
    ESE_TEMPQL_TYPE_ASSOC = 2
} TEMPQLTYPE;

typedef enum 
{
    ESE_EXPR_INVALID      = 0,
    ESE_EXPR_TYPE_AND =     WQL_TOK_AND,
    ESE_EXPR_TYPE_OR =      WQL_TOK_OR,
    ESE_EXPR_TYPE_EXPR =    WQL_TOK_TYPED_EXPR,
    ESE_EXPR_TYPE_NOT     = WQL_TOK_NOT
} ESETOKENTYPE;

typedef enum
{
    ESE_VALUE_TYPE_INVALID= 0,
    ESE_VALUE_TYPE_SQL_ID = 1,
    ESE_VALUE_TYPE_STRING = 2,
    ESE_VALUE_TYPE_REAL   = 3,
    ESE_VALUE_TYPE_REF    = 4,
    ESE_VALUE_TYPE_SYSPROP= 5
} VALUETYPE;

typedef enum
{
    ESE_FUNCTION_NONE                 = 0,
    ESE_FUNCTION_UPPER                = 1,
    ESE_FUNCTION_LOWER                = 2,
    ESE_FUNCTION_DATEPART_MONTH       = 3,
    ESE_FUNCTION_DATEPART_YEAR        = 4,
    ESE_FUNCTION_DATEPART_DAY         = 5,
    ESE_FUNCTION_DATEPART_HOUR        = 6,
    ESE_FUNCTION_DATEPART_MINUTE      = 7,
    ESE_FUNCTION_DATEPART_SECOND      = 8,
    ESE_FUNCTION_DATEPART_MILLISECOND = 9

} ESEFUNCTION;

struct ESEValue
{
    VALUETYPE valuetype;
    SQL_ID dValue;
    BSTR sValue;
    double rValue;
    SQL_ID dRefValue;
    BSTR sPropName;
    ESEFUNCTION dwFunc;
    ESEValue()
    {
        valuetype = ESE_VALUE_TYPE_INVALID,
        dValue = 0, sValue = NULL, rValue = 0, dRefValue = 0,
        sPropName = NULL, dwFunc = ESE_FUNCTION_NONE;
    }
    ~ESEValue()
    {
        SysFreeString(sPropName);
        SysFreeString(sValue);
    }
};

class ESEToken
{
public:
    ESETOKENTYPE tokentype;
    TEMPQLTYPE qltype;
    ESEToken(ESETOKENTYPE type) {tokentype = type; qltype = ESE_TEMPQL_TYPE_NONE;};
    virtual ~ESEToken() {};
};

class ESEWQLToken : public ESEToken
{
public:
    int optype;
    SQL_ID dScopeId;
    SQL_ID dClassId;
    SQL_ID dPropertyId;
    SQL_ID dCompPropertyId;
    ESEValue Value;
    ESEValue CompValue;
    BOOL   bSysProp;

    BOOL bIndexed;

    ESEWQLToken(ESETOKENTYPE type) 
        : ESEToken(type)
    { 
        qltype = ESE_TEMPQL_TYPE_NONE;
        optype = 0;
        dScopeId = 0;
        bSysProp = FALSE;
        dClassId = 0;
        dPropertyId = 0;
        dCompPropertyId = 0;
    }
    ~ESEWQLToken() {};
};

typedef enum
{
    TEMPQL_TOKEN_INVALID        = 0,
    TEMPQL_TOKEN_RESULTCLASS    = 1,
    TEMPQL_TOKEN_ROLE           = 2,
    TEMPQL_TOKEN_RESULTROLE     = 3,
    TEMPQL_TOKEN_REQQUALIFIER   = 4,
    TEMPQL_TOKEN_ASSOCQUALIFIER = 5,
    TEMPQL_TOKEN_ASSOCCLASS     = 6,
    TEMPQL_TOKEN_TARGETID       = 7
} TEMPQLTOKEN;

class ESETempQLToken : public ESEToken
{
public:

    TEMPQLTOKEN token;
    SQL_ID dValue;
    BSTR sValue;

    ESETempQLToken(ESETOKENTYPE type, TEMPQLTYPE _ttype)
        : ESEToken (type)
    { 
        qltype = _ttype;
        sValue = NULL;
    }
    ~ESETempQLToken() {SysFreeString(sValue);};

};

class CESETokens
{
public:
    HRESULT AddToken (ESEToken *pTok, ESETOKENTYPE type, int *iNumAdded=NULL, int iPos = -1);

    HRESULT AddNumericExpr (SQL_ID dClassId, SQL_ID dPropertyId, SQL_ID dValue, 
                     ESETOKENTYPE type=ESE_EXPR_TYPE_AND, int op=WQL_TOK_EQ,
                     BOOL bIndexed=FALSE,
                     SQL_ID dCompValue = 0, 
                     ESEFUNCTION func = ESE_FUNCTION_NONE, int *iNumAdded=NULL,
                     BOOL bSysProp=FALSE);
    HRESULT AddReferenceExpr (SQL_ID dClassId, SQL_ID dPropertyId, SQL_ID dValue, 
                     ESETOKENTYPE type=ESE_EXPR_TYPE_AND, int op=WQL_TOK_EQ,
                     BOOL bIndexed=FALSE,
                     SQL_ID dCompValue = 0,
                     ESEFUNCTION func = ESE_FUNCTION_NONE, int *iNumAdded=NULL);
    HRESULT AddStringExpr (SQL_ID dClassId, SQL_ID dPropertyId, LPWSTR dValue, 
                     ESETOKENTYPE type=ESE_EXPR_TYPE_AND, int op=WQL_TOK_EQ,
                     BOOL bIndexed=FALSE,
                     LPWSTR dCompValue = 0, 
                     ESEFUNCTION func = ESE_FUNCTION_NONE, int *iNumAdded=NULL,
                     BOOL bSysProp = FALSE);
    HRESULT AddRealExpr (SQL_ID dClassId, SQL_ID dPropertyId, double dValue, 
                     ESETOKENTYPE type=ESE_EXPR_TYPE_AND, int op=WQL_TOK_EQ,
                     BOOL bIndexed=FALSE,
                     double dCompValue = 0, 
                     ESEFUNCTION func = ESE_FUNCTION_NONE, int *iNumAdded=NULL);
    HRESULT AddPropExpr (SQL_ID dClassId, SQL_ID dPropertyId, SQL_ID dPropertyId2,
                     DWORD StorageType, ESETOKENTYPE type=ESE_EXPR_TYPE_AND, int op=WQL_TOK_EQ,
                     BOOL bIndexed = FALSE, ESEFUNCTION func = ESE_FUNCTION_NONE,
                     ESEFUNCTION func2 = ESE_FUNCTION_NONE, int *iNumAdded=NULL);
    HRESULT AddTempQlExpr (TEMPQLTYPE type, SQL_ID dTargetID, SQL_ID dResultClass, LPWSTR lpRole, LPWSTR lpResultRole, 
        SQL_ID dQfr, SQL_ID dAssocQfr, SQL_ID dAssocClass, int *iNumAdded=NULL);

    HRESULT AddSysExpr (SQL_ID dScopeId, SQL_ID dClassId, int *iNumAdded=NULL);

    DWORD GetNumTokens() {return m_arrToks.Size();}
    ESEToken * GetToken(int iPos) {return (ESEToken *)m_arrToks.GetAt(iPos);};
    HRESULT UnIndexTokens(int iNum);
    void SetIsMetaClass (BOOL b = TRUE) { m_bMetaClass = b;};
    BOOL IsMetaClass () {return m_bMetaClass;};
    SQL_ID GetScopeID() {return m_dScopeId;};
    CESETokens() {m_bMetaClass = FALSE; m_dScopeId = 0;};
    ~CESETokens()
    {
        for (int i=0; i < m_arrToks.Size(); i++) 
            delete (ESEToken *)m_arrToks.GetAt(i);
    }
private:

    CFlexArray m_arrToks;
    BOOL m_bMetaClass;
    SQL_ID m_dScopeId;
};

class CESEBuilder
{
public:
    CESEBuilder(CSchemaCache *pSchema, CWmiDbSession *pSession, CSQLConnection *pConn) {m_pSchema = pSchema, m_pSession = pSession, m_pConn = pConn;};
    ~CESEBuilder(){};
    // Generic SQL
    HRESULT FormatSQL        (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                IWbemQuery *pQuery, CESETokens **pTokens, 
                                DWORD dwFlags, DWORD dwHandleType, SQL_ID *dClassId=0,
                                BOOL *bHierarchyQuery=0, BOOL *IndexCols = 0, BOOL *bSuperSet = 0, BOOL *bDelete = 0);
    HRESULT FormatSQL        (SQL_ID dScopeId, SQL_ID dScopeClassId, SQL_ID dSuperScope,
                                SQL_ID dTargetObjID, LPWSTR pResultClass,
                                LPWSTR pAssocClass, LPWSTR pRole, LPWSTR pResultRole, LPWSTR pRequiredQualifier,
                                LPWSTR pRequiredAssocQualifier, DWORD dwQueryType, CESETokens **pTokens, DWORD dwFlags,
                                DWORD dwHandleType, SQL_ID *dAssocClass=0, SQL_ID *dResultClass=0,
                                BOOL *pSuperSet = 0);

private:
    HRESULT FormatWhereClause (SWQLNode_RelExpr *pNode, CESETokens *pTokens, 
        BOOL &IndexCols, BOOL *bOrCri=NULL, int *iNumToksAdded=NULL, BOOL *pSuperSet = NULL);
    HRESULT GetPropertyID (SQL_ID dClassID, SWQLQualifiedName *pQN, LPCWSTR pColRef, DWORD &PropID, DWORD &Storage, DWORD &Flags);
    HRESULT GetClassFromNode (SWQLNode *pNode);

    SQL_ID m_dClassID;
    DWORD  m_dwTableCount;
    bool   m_bClassSpecified;
    SQL_ID m_dNamespace;
    CSchemaCache *m_pSchema;
    CWmiDbSession *m_pSession;
    CSQLConnection *m_pConn;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\QUASAR\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\genlex.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\dllentrysql.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  dllentry.cpp
//
//
//
//
//
//
//  History:
//
//      cvadai      4/1/1999    created.
//
//
//  Copyright (c)1999-2001 Microsoft Corporation, All Rights Reserved
///////////////////////////////////////////////////////////////////////////////

//#define _AFXDLL

// #include <afxwin.h>
#include "precomp.h"
#include <comdef.h>
#include <std.h>
#include <clsfctry.h>
#include <reposit.h>

extern long g_cObj;
extern long g_cLock;

const wchar_t * g_pszComServerName   = L"WINMGMT SQL Server Repository Driver";
const wchar_t * g_pszThreadingModel  = L"Both";

// static AFX_EXTENSION_MODULE ExtDLL;
HINSTANCE       hHandle;

//******************************************************************************
//
//  DllMain()
//
//******************************************************************************
extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // If the process is attaching to this extension DLL, initialize:
    // ==============================================================

    if (dwReason == DLL_PROCESS_ATTACH) 
    {
        hHandle = GetModuleHandle(L"REPDRVR.DLL");
    }

    // Return successfully.
    // ====================

    return(TRUE);
}


//-----------------------------------------------------------------------------
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    HRESULT hr = E_FAIL;

    if (CLSID_WmiRepository_SQL==rclsid)
    {
        CControllerFactory * pObj = new CControllerFactory();

        if (pObj != NULL)
        {
            hr = pObj->QueryInterface(riid, ppv);

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
        else
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
        }
    }

    return hr;
}




//-----------------------------------------------------------------------------
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//
//

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=( g_cObj < 1 && g_cLock < 1) ? S_OK : S_FALSE;
    return sc;
}

//-----------------------------------------------------------------------------
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//
//

STDAPI DllRegisterServer(void)
{   
    WCHAR   wcID[128];
    wchar_t szCLSID[128];
    wchar_t szModule[MAX_PATH];
    HKEY    hKey1;
    HKEY    hKey2;

    // Create the path.

    StringFromGUID2(CLSID_WmiRepository_SQL, wcID, 128);
    wcscpy(szCLSID, TEXT("CLSID\\"));
    wcscat(szCLSID, wcID);


    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)g_pszComServerName, wcslen(g_pszComServerName)*2);
    RegCreateKey(hKey1,L"InprocServer32",&hKey2);

    HINSTANCE hInst = GetModuleHandle(L"repdrvr.DLL");
    GetModuleFileName(hInst, szModule,  MAX_PATH);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, wcslen(szModule)*2);
    RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE *)g_pszThreadingModel, wcslen(g_pszThreadingModel)*2);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}


//-----------------------------------------------------------------------------
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//
//

STDAPI DllUnregisterServer(void)
{
    wchar_t szID[128];
    WCHAR   wcID[128];
    wchar_t szCLSID[128];
    HKEY    hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_WmiRepository_SQL, wcID,sizeof(wcID));
    wcscpy(szCLSID, L"CLSID\\");
    wcscat(szCLSID, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\crepdrvr.h ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   crepdrvr.h
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#ifndef _CREPDRVR_H_
#define _CREPDRVR_H_

#include <repdrvr.h>
#include <sqlit.h>

#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

//#define InterlockedIncrement(l) (++(*(l)))
//#define InterlockedDecrement(l) (--(*(l)))


class CWmiCustomDbIterator : public CWmiDbIterator
{
    friend class CWmiDbSession;

public:
    CWmiCustomDbIterator();
    ~CWmiCustomDbIterator();

    HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    ULONG STDMETHODCALLTYPE AddRef( );
    ULONG STDMETHODCALLTYPE Release( );

    virtual HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ DWORD dwFlags) ;
    
    virtual HRESULT STDMETHODCALLTYPE NextBatch( 
        /* [in] */ DWORD dwNumRequested,
        /* [in] */ DWORD dwTimeOutSeconds,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [in] */ REFIID riid,
        /* [out] */ DWORD __RPC_FAR *pdwNumReturned,
        /* [iid_is][length_is][size_is][out] */ LPVOID __RPC_FAR *ppObjects);
private:
    MappedProperties *m_pPropMapping;
    DWORD m_dwNumProps;
    SQL_ID m_dwScopeId;
    SQL_ID m_dClassId;
    BOOL   m_bCount;
    IWmiDbHandle *m_pScope;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\crepdrvr.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   crepdrvr.cpp
//
//   cvadai     19-Mar-99       Created as prototype for Quasar.
//
//***************************************************************************

#define _CREPDRVR_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class

#define DBINITCONSTANTS // Initialize OLE constants...
#define INITGUID        // ...once in each app.
#define _WIN32_DCOM
#include "precomp.h"

#include <std.h>
#include <sqlutils.h>
#include <repdrvr.h>
#include <crepdrvr.h>
#include <sqlexec.h>
#include <wbemint.h>
#include <math.h>
#include <objbase.h>
#include <resource.h>
#include <reputils.h>
#include <crc64.h>
#include <smrtptr.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>
#include <genlex.h>
#include <opathlex.h>

//***************************************************************************
//
//  HELPER FUNCTIONS for custom stuff
//
//***************************************************************************

void ClearPropArray (MappedProperties *pProps, DWORD dwNumProps)
{
    int i = 0, j = 0;

    for (i = 0; i < dwNumProps; i++)
    {
        delete pProps[i].wPropName;
        delete pProps[i].wTableName;
        delete pProps[i].wScopeClass;
        
        for (j = 0; j < pProps[i].dwNumColumns; j++)
            delete pProps[i].arrColumnNames[j];

        for (j = 0; j < pProps[i].dwNumForeignKeys; j++)
            delete pProps[i].arrForeignKeys[j];

        delete pProps[i].arrColumnNames;
        delete pProps[i].arrForeignKeys;
        delete pProps[i].wClassTable;
        delete pProps[i].wClassNameCol;
        delete pProps[i].wClassDataCol;
        delete pProps[i].wClassForeignKey;
    }
}

HRESULT GetClassBufferID (CSQLConnection *pConn, MappedProperties *pProp, 
                          LPWSTR lpTableName, LPWSTR lpClassName, 
                          BYTE *pClassBuff, DWORD dwClassBuffLen, DWORD &dwClassID, IMalloc *pMalloc)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Function to find an existing class buffer that matches this one
    // byte for byte, or create a new row and get the new ID.

    IRowset *pRowset = NULL;

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
        L"select %s, %s from %s where %s = '%s'", &pRowset, NULL,
        pProp->wClassForeignKey, pProp->wClassDataCol,
        lpTableName, pProp->wClassNameCol, lpClassName);
    if (SUCCEEDED(hr) && pRowset)
    {
        CReleaseMe r (pRowset);
        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);
        BYTE *pBuffer = NULL;
        DWORD dwLen = 0;

        // Get each result row, and compare it with the passed in buffer

        hr = CSQLExecute::GetColumnValue(pRowset, 1, pMalloc, &pRow, vTemp);
        while (SUCCEEDED(hr))
        {
            hr = CSQLExecute::ReadImageValue(pRowset, 2, &pRow, &pBuffer, dwLen);        
            if (!memcmp(pClassBuff, pBuffer, dwLen))
            {
                dwClassID = vTemp.lVal;
            }

            hr = pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;

            if (dwClassID)
                break;

            hr = CSQLExecute::GetColumnValue(pRowset, 1, pMalloc, &pRow, vTemp);
        }
    }

    // If here, we didn't find one.
    // Insert a new class buffer and grab its ID.

    if (!dwClassID)
    {
        wchar_t wSQL[1024];

        swprintf(wSQL, L"insert into %s (%s, %s) values (NULL, '%s') ",
            lpTableName, pProp->wClassDataCol, pProp->wClassNameCol, lpClassName);
        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), wSQL);

        IRowset *pRowset = NULL;

        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
            L"select @@identity", &pRowset, NULL);
        if (SUCCEEDED(hr))
        {
            CReleaseMe r (pRowset);
            HROW *pRow = NULL;
            VARIANT vTemp;
            CClearMe c (&vTemp);

            hr = CSQLExecute::GetColumnValue(pRowset, 1, pMalloc, &pRow, vTemp);
            hr = pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;

            if (vTemp.vt == VT_I4)
                dwClassID = vTemp.lVal;
            else if (vTemp.vt == VT_BSTR)
                dwClassID = _wtoi64(vTemp.bstrVal);

            swprintf(wSQL, L"select %s from %s where %s = %ld ",
                pProp->wClassDataCol, lpTableName,
                pProp->wClassForeignKey, dwClassID);

            hr = CSQLExecute::WriteImageValue(((COLEDBConnection *)pConn)->GetCommand(), wSQL, 1, pClassBuff, dwClassBuffLen);
        }
    }

    return hr;
}

BOOL SetBooleanProp (LPWSTR lpPropName, IWbemClassObject *pProp)
{
    BOOL bRet = FALSE;

    LPWSTR lpTemp = GetPropertyVal(lpPropName, pProp);    
    if (lpTemp && wcslen(lpTemp))
        bRet = _wtoi(lpTemp) == 0 ? FALSE : TRUE;
    delete lpTemp;

    return bRet;
}

LPWSTR FormatTableName(IWbemClassObject *pMapping, LPWSTR lpTableName = NULL)
{
    LPWSTR lpRet = NULL;
    BOOL bDelete = FALSE;
    LPWSTR lpTbl = lpTableName;
    if (!lpTbl)
    {
        bDelete = TRUE;
        lpTbl = GetPropertyVal(L"sTableName", pMapping);
    }

    LPWSTR lpDB = GetPropertyVal(L"sDatabaseName", pMapping);
    if (lpDB && wcslen(lpDB))
    {
        lpRet = new wchar_t [wcslen(lpTbl)+wcslen(lpDB)+5];
        if (lpRet)
            swprintf(lpRet, L"%s..%s", lpDB, lpTbl);
    }
    else
        lpRet = Macro_CloneLPWSTR(lpTbl);

    if (bDelete)
        delete lpTbl;

    return lpRet;
}

HRESULT LoadStringArray(LPWSTR lpPropName, IWbemClassObject *pProp, LPWSTR ** lpToSet, DWORD &dwNumElements)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vTemp;
    VariantInit(&vTemp);

    hr = pProp->Get(lpPropName, 0, &vTemp, 0, 0);
    if (SUCCEEDED(hr) && vTemp.vt != VT_NULL)
    {                        
        SAFEARRAY *pArray = V_ARRAY(&vTemp);
        long lLBound1, lUBound1;
        SafeArrayGetLBound(pArray, 1, &lLBound1);
        SafeArrayGetUBound(pArray, 1, &lUBound1);

        lUBound1 -= lLBound1;
        lUBound1 += 1;
        if (lUBound1 > 20)
            hr = WBEM_E_INVALID_CLASS;
        else
        {
            *lpToSet = new LPWSTR [lUBound1];
            if (lpToSet)
            {
                dwNumElements = lUBound1;
                for (int j = 0; j < lUBound1; j++)
                {
                    VARIANT vT3;
                    VariantInit(&vT3);
                    hr = GetVariantFromArray(pArray, j, VT_BSTR, vT3);
                    if (SUCCEEDED(hr))
                    {
                        BSTR sTemp = V_BSTR(&vT3);
                        *lpToSet[j] = Macro_CloneLPWSTR(sTemp);
                        VariantClear(&vT3);
                    }
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
        VariantClear(&vTemp);
    }
    else
    {
        *lpToSet = NULL;
        dwNumElements = 0;
    }

    return hr;

}

HRESULT SetProps(LPWSTR lpTableName, MappedProperties *pPropDef, IWbemClassObject *pProp)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR lpTemp = NULL;

    pPropDef->wPropName = GetPropertyVal(L"sPropertyName", pProp);
    pPropDef->wTableName = GetPropertyVal(L"sTableName", pProp);
    pPropDef->wClassTable = GetPropertyVal(L"sClassTableName", pProp);
    pPropDef->wClassNameCol = GetPropertyVal(L"sClassNameColumn", pProp);
    pPropDef->wClassDataCol = GetPropertyVal(L"sClassDataColumn", pProp);
    pPropDef->wClassForeignKey = GetPropertyVal(L"sClassForeignKey", pProp);
    pPropDef->wScopeClass = GetPropertyVal(L"sScopeClass", pProp);

    pPropDef->bReadOnly = SetBooleanProp(L"bReadOnly", pProp);
    pPropDef->bStoreAsNumber = SetBooleanProp(L"bStoreAsNumber", pProp);
    pPropDef->bDecompose = SetBooleanProp(L"bDecompose", pProp);
    pPropDef->bIsKey = SetBooleanProp(L"bIsKey", pProp);
    pPropDef->bStoreAsBlob = SetBooleanProp(L"bStoreAsBlob", pProp);

    hr = LoadStringArray(L"arrColumnNames", pProp, 
                &pPropDef->arrColumnNames, pPropDef->dwNumColumns);

    if (SUCCEEDED(hr))
    {
        hr = LoadStringArray(L"arrForeignKeys", pProp, 
                &pPropDef->arrForeignKeys, pPropDef->dwNumForeignKeys);
    }

    return hr;
}


HRESULT ConvertObjToStruct(IWbemClassObject *pMappingObj, MappedProperties **ppStruct, DWORD *NumProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT vTemp;
    CClearMe c (&vTemp);
    LPWSTR lpTableName = NULL;
    lpTableName = GetPropertyVal(L"sTableName", pMappingObj);
    CDeleteMe <wchar_t> d2 (lpTableName);

    hr = pMappingObj->Get(L"arrProperties", 0, &vTemp, NULL, NULL);
    if (SUCCEEDED(hr) && vTemp.vt == (VT_UNKNOWN + CIM_FLAG_ARRAY))
    {     
        SAFEARRAY *psaArray = V_ARRAY(&vTemp);
        if (psaArray)
        {
            long lLBound, lUBound;
            SafeArrayGetLBound(psaArray, 1, &lLBound);
            SafeArrayGetUBound(psaArray, 1, &lUBound);

            lUBound -= lLBound;
            lUBound += 1;

            *ppStruct = new MappedProperties[lUBound];
            if (*ppStruct)
            {
                MappedProperties *pProps = *ppStruct;
                *NumProps = lUBound;

                for (int i = 0; i < lUBound; i++)
                {
                    VARIANT vT2;
                    VariantInit(&vT2);
                    hr = GetVariantFromArray(psaArray, i, VT_UNKNOWN, vT2);

                    IUnknown *pUnk = V_UNKNOWN(&vT2);
                    if (pUnk)
                    {
                        IWbemClassObject *pProp = NULL;
                        hr = pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pProp);
                        CReleaseMe r (pProp);
                        if (SUCCEEDED(hr))
                        {
                            hr = SetProps(lpTableName, &pProps[i], pProp);
                        }
                    }
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
        hr = WBEM_E_INVALID_OBJECT;

    return hr;
}

HRESULT AddObjToStruct(IWbemClassObject *pMappingObj, MappedProperties **ppStruct, DWORD dwCurrProps, DWORD *NumProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    VARIANT vTemp;
    CClearMe c (&vTemp);
    DWORD dwNewSize = 0;

    LPWSTR lpTableName = NULL;
    lpTableName = GetPropertyVal(L"sTableName", pMappingObj);
    CDeleteMe <wchar_t> d2 (lpTableName);

    hr = pMappingObj->Get(L"arrProperties", 0, &vTemp, NULL, NULL);
    if (SUCCEEDED(hr) && vTemp.vt == (VT_UNKNOWN + CIM_FLAG_ARRAY))
    {     
        SAFEARRAY *psaArray = V_ARRAY(&vTemp);
        if (psaArray)
        {
            long lLBound, lUBound;
            SafeArrayGetLBound(psaArray, 1, &lLBound);
            SafeArrayGetUBound(psaArray, 1, &lUBound);

            lUBound -= lLBound;
            lUBound += 1;
            dwNewSize = dwCurrProps + lUBound;
            *NumProps = dwNewSize;

            MappedProperties *pProps = new MappedProperties[dwNewSize];
            if (pProps)
            {
                memcpy(pProps, *ppStruct, sizeof(MappedProperties) * dwCurrProps);
                delete *ppStruct;
                *ppStruct = pProps;

                for (int i = 0; i < lUBound; i++)
                {
                    int iCurrPos = i + dwCurrProps;

                    VARIANT vT2;
                    VariantInit(&vT2);
                    hr = GetVariantFromArray(psaArray, i, VT_UNKNOWN, vT2);

                    IUnknown *pUnk = V_UNKNOWN(&vT2);
                    if (pUnk)
                    {
                        IWbemClassObject *pProp = NULL;
                        hr = pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pProp);
                        CReleaseMe r (pProp);
                        if (SUCCEEDED(hr))
                        {
                            hr = SetProps(lpTableName, &pProps[iCurrPos], pProp);
                        }
                    }
                }
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
        hr = WBEM_E_INVALID_OBJECT;

    return hr;
}

_bstr_t GetDateTime(LPWSTR lpDMTFDate)
{
    char szTmp[50];
    wchar_t szTmp2[8];
    wchar_t *p = lpDMTFDate;
    int iYear = 0, iMonth = 0, iDay = 0, iHour=0, iMinute=0, iSecond=0;

    if (lpDMTFDate && _wcsicmp(lpDMTFDate, L"null"))
    {
        wcsncpy(szTmp2, p, 4);
        szTmp2[4] = '\0';
        iYear = _wtoi(szTmp2);
        p+=4;
        wcsncpy(szTmp2, p, 2);
        szTmp2[2] = '\0';
        iMonth= _wtoi(szTmp2);
        p+=2;
        wcsncpy(szTmp2, p, 2);
        szTmp2[2] = '\0';
        iDay= _wtoi(szTmp2);
        p+=2;

        wcsncpy(szTmp2, p, 2);
        szTmp2[2] = '\0';
        iHour= _wtoi(szTmp2);
        p+=2;
        wcsncpy(szTmp2, p, 2);
        szTmp2[2] = '\0';
        iMinute= _wtoi(szTmp2);
        p+=2;
        wcsncpy(szTmp2, p, 2);
        szTmp2[2] = '\0';
        iSecond = _wtoi(szTmp2);
    }

    // This won't work with no delimiters...
    // swscanf(lpDMTFDate, L"%04d%02d%02d%02d%02d02d.%06d",
    //    &iYear, &iMonth, &iDay, &iHour, &iMinute, &iSecond, &iMs);

    if (iYear)
    {
        sprintf(szTmp, "%04d-%02d-%02d %02d:%02d:%02d",
            iYear, iMonth, iDay, iHour, iMinute, iSecond);
    }
    else
        strcpy(szTmp, "null");

    return (const char *)szTmp;
}

LPWSTR GetColumnName(LPWSTR lpPropName, MappedProperties *pMapping, DWORD dwNumProps, BOOL *bQueriable, LPWSTR lpFunc = NULL,
                     SWQLNode *pFuncNode = NULL)
{
    LPWSTR lpRet = NULL;

    HRESULT hr = 0;
    
    // Special case: datepart nodes contain the property name.

    if (!lpPropName && pFuncNode)
    {
        lpPropName = ((SWQLNode_Datepart *)pFuncNode)->m_pColRef->m_pColName;
    }

    for (int i = 0; i < dwNumProps; i++)
    {
        if (!_wcsicmp(pMapping[i].wPropName, lpPropName))
        {
            // Queries on this type of column are invalid anyway.

            if (pMapping[i].dwNumColumns > 1)
                return NULL;

            int iLen = wcslen(pMapping[i].arrColumnNames[0])+31;

            if (lpFunc)
                iLen += wcslen(lpFunc) + 1;
            if (pFuncNode)
                iLen += 10;

            lpRet = new wchar_t [iLen];
            if (lpRet)
            {
                lpRet[0] = L'\0';
                BOOL bFinalParen = FALSE;

                if (lpFunc)
                {
                    if (!_wcsicmp(lpFunc, L"upper") ||
                        !_wcsicmp(lpFunc, L"lower") ||
                        !_wcsicmp(lpFunc, L"datepart"))
                    {
                        wcscpy(lpRet, lpFunc);
                        wcscat(lpRet, L"(");
                        bFinalParen = TRUE;
                    }
                    else 
                        hr = WBEM_E_NOT_SUPPORTED;
                }

                if (pFuncNode && pFuncNode->m_dwNodeType == TYPE_SWQLNode_Datepart)
                {              
                    switch(((SWQLNode_Datepart *)pFuncNode)->m_nDatepart)
                    {
                    case WQL_TOK_YEAR:
                        wcscat(lpRet, L"yy,");
                        break;
                    case WQL_TOK_MONTH:
                        wcscat(lpRet, L"mm,");
                        break;
                    case WQL_TOK_DAY:
                        wcscat(lpRet, L"dd,");
                        break;
                    case WQL_TOK_HOUR:
                        wcscat(lpRet, L"hh,");
                        break;
                    case WQL_TOK_MINUTE:
                        wcscat(lpRet, L"minute,");
                        break;
                    case WQL_TOK_SECOND:
                        wcscat(lpRet, L"second,");
                        break;
                    case WQL_TOK_MILLISECOND:
                        wcscat(lpRet, L"ms,");
                        break;
                    default:
                        hr = WBEM_E_INVALID_QUERY;
                        break;
                    }        
                }

                if (pMapping[i].wTableName && wcslen(pMapping[i].wTableName))
                    wcscat(lpRet, pMapping[i].wTableName);
                else
                    wcscat(lpRet, L"a");
                wcscat(lpRet, L".");

                wcscat(lpRet, pMapping[i].arrColumnNames[0]);

                if (bFinalParen)
                    wcscat(lpRet, L")");

                if (!pMapping[i].bStoreAsBlob)
                    *bQueriable = TRUE;
                break;
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    if (FAILED(hr))
    {

        delete lpRet;
        lpRet = NULL;
    }

    return lpRet;
}

LPWSTR GetRefKey (LPWSTR lpIn, BOOL bStoreAsNumber, BOOL &bNeedQuotes)
{
    LPWSTR lpRet = NULL;
    LPWSTR lpIn2 = lpIn;

    wchar_t *pTemp = new wchar_t [wcslen(lpIn) + 1];
    if (!pTemp)
        return NULL;

    int iLen = wcslen(lpIn);
    if (lpIn2[0] == L'\"')
    {
        iLen -= 2;
        lpIn2 ++;
    }

    wcsncpy(pTemp, lpIn2, iLen);
    pTemp[iLen] = L'\0';

    IWbemPathKeyList *pKeyList = NULL;
    IWbemPath *pPath = NULL;

    HRESULT hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemPath, (LPVOID *) &pPath);
    if (SUCCEEDED(hr))
    {
        CReleaseMe r (pPath);
        hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pTemp);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetKeyList(&pKeyList);
            if (SUCCEEDED(hr))
            {
                CReleaseMe r2 (pKeyList);
                DWORD dwLen = 255;
                DWORD dwLen2 = 255;
                BYTE    bBuff[255];
                wchar_t wName[255];
                ULONG ct;
                hr = pKeyList->GetKey(0, 0, &dwLen, wName, &dwLen2, bBuff, &ct);
                if (SUCCEEDED(hr))
                {
                    if ((ct == CIM_STRING || ct == CIM_REFERENCE) && bStoreAsNumber)
                        bNeedQuotes = TRUE;

                    WCHAR * pTempx = new wchar_t [1024];
                    if (pTempx)
                    {
                        ConvertDataToString(pTempx, bBuff, ct);

                        lpRet = (WCHAR *)pTempx;
                    }
                }
            }
        }
    }

    return lpRet;
}


BOOL IsEmbeddedProp (LPWSTR lpPropName)
{
    BOOL bRet = FALSE;

    WCHAR *pChar = NULL;

    pChar = wcsstr(lpPropName, L".");
    if (pChar)
        bRet = TRUE;
    pChar = wcsstr(lpPropName, L"[");
    if (pChar)
        bRet = TRUE;

    return bRet;
}

HRESULT GetEmbeddedProp(IWbemClassObject *pObj, LPWSTR lpPropName, VARIANT *vValue, CIMTYPE *ct)
{
    HRESULT hr = 0;

    SAFEARRAY *pArray = NULL;
    VARIANT vProp, vTemp;
    VariantInit(&vProp);
    VariantClear(&vTemp);
    CClearMe c (&vProp), c1 (&vTemp);
    CIMTYPE ctLocal = 0;
    IUnknown *pUnk = NULL;
    IWbemClassObject *pCurrent = pObj;
    int iCurrPos = -1;
    BOOL bArray = FALSE;

    CTextLexSource src(lpPropName);
    CGenLexer Lexer (WQL_LexTable, &src);

    wchar_t wTemp[128];

    pObj->AddRef();

    int iCurrTok = Lexer.NextToken();

    while (iCurrTok != OPATH_TOK_EOF)
    {        
        switch(iCurrTok)
        {
            // Embedded object property.
            case WQL_TOK_DOT:

                bArray = FALSE;
                
                // Retrieve the current embedded object.

                hr = pCurrent->Get(wTemp, 0, &vProp, ct, NULL);

                if (SUCCEEDED(hr) && vProp.vt == VT_UNKNOWN)
                {
                    pUnk = V_UNKNOWN(&vProp);
                    if (pUnk)
                    {
                        pCurrent->Release();
                        pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pCurrent);
                        iCurrPos = -1;
                        pUnk->Release();
                    }
                }
                break;

                // Array
            case WQL_TOK_OPEN_BRACKET:
                bArray = TRUE;
                iCurrTok = Lexer.NextToken();
                iCurrPos = _wtoi(Lexer.GetTokenText());

                hr = pCurrent->Get(wTemp, 0, &vProp, ct, NULL);                                
                if (SUCCEEDED(hr))
                {
                    pArray = V_ARRAY(&vProp);
                    if (pArray && (vProp.vt & 0xFF) == VT_UNKNOWN)
                    {
                        hr = GetVariantFromArray(pArray, iCurrPos, (vProp.vt & 0xFF), vTemp);
                        pUnk = V_UNKNOWN(&vTemp);
                        if (pUnk)
                        {
                            pCurrent->Release();
                            pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pCurrent);
                            bArray = FALSE;
                                
                            // This might reference an embedded-embedded object
                            iCurrTok = Lexer.NextToken();    // WQL_TOK_CLOSE_BRACKET
                            iCurrTok = Lexer.NextToken();    // WQL_TOK_DOT
                            iCurrTok = Lexer.NextToken();    // WQL_TOK_IDENT
                            iCurrTok = Lexer.NextToken();    // EOF or DOT

                        }
                        VariantClear(&vTemp);
                    }
                }

                break;

            case WQL_TOK_CLOSE_BRACKET:               
                break;

            case WQL_TOK_IDENT:
                wcscpy(wTemp, Lexer.GetTokenText());
                VariantClear(&vProp);
                break;
        }
        iCurrTok = Lexer.NextToken();

        if (FAILED(hr))
            break;
    }     
    
    // At this point, we should have the object in question.
    // Retrieve the value depending on what it is.

    if (bArray )
    {
        if (pArray)
            hr = GetVariantFromArray(pArray, iCurrPos, (vProp.vt & 0xFF), *vValue);
    }
    else
    {
        if (pCurrent)
        {
            pCurrent->Get(wTemp, 0, vValue, ct, NULL);
            pCurrent->Release();
        }
    }

    *ct &= ~CIM_FLAG_ARRAY;
    VariantClear(&vProp);
    pObj->Release();

    return hr;
}

HRESULT CWmiDbSession::GetEmbeddedClass (IWmiDbHandle *pScope, IWbemClassObject *pObj, LPWSTR lpEmbedProp, 
                                         IWbemClassObject **ppClass)
{
    HRESULT hr = 0;

    IWbemQualifierSet *pQS = NULL;
    hr = pObj->GetPropertyQualifierSet(lpEmbedProp, &pQS);
    if (SUCCEEDED(hr))
    {
        CReleaseMe r (pQS);
        VARIANT vTemp;
        CClearMe c (&vTemp);

        hr = pQS->Get(L"cimtype", 0, &vTemp, NULL);
        if (SUCCEEDED(hr))
        {
            if (vTemp.vt == VT_BSTR)
            {
                LPWSTR lpClassName = wcsstr(vTemp.bstrVal, L":")+1;
                
                if (!lpClassName)
                    hr = WBEM_E_INVALID_CLASS;
                else
                {
                    IWmiDbHandle *pHandle = NULL;

                    LPWSTR lpNewPath = NULL;
                    IWbemPath *pPath = NULL;
                    hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                            IID_IWbemPath, (LPVOID *) &pPath);
                    if (SUCCEEDED(hr))
                    {
                        CReleaseMe r8 (pPath);
                        if (pPath)
                        {
                            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpClassName);

                            hr = GetObject(pScope, pPath, 0, WMIDB_HANDLE_TYPE_STRONG_CACHE|WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);
                            CReleaseMe r (pHandle);

                            if (SUCCEEDED(hr))
                            {
                                IWbemClassObject *pClass = NULL;
                                hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pClass);
                                if (SUCCEEDED(hr))
                                    *ppClass = pClass;
                            }
                        }
                    }
                }
            }
        }
    }
    return hr;
}


HRESULT CWmiDbSession::SetEmbeddedProp (IWmiDbHandle *pScope, LPWSTR lpPropName, IWbemClassObject *pObj, 
                                        VARIANT &vValue, CIMTYPE ct)
{

    // Not so simple:
    // The path must be traversed once to find it,
    // then again in reverse and save the new value.

    HRESULT hr = 0;

    SAFEARRAY *pArray = NULL;
    VARIANT vProp, vTemp;
    VariantInit(&vProp);
    VariantClear(&vTemp);
    CClearMe c (&vProp), c1 (&vTemp);
    CIMTYPE ctLocal = 0;
    IUnknown *pUnk = NULL;
    IWbemClassObject *pCurrent = pObj;
    int iCurrPos = -1;
    BOOL bArray = FALSE;
    CIMTYPE ctCurr;

    struct Prop
    {
        wchar_t wPropName[128];
        int     iPos;
        CIMTYPE ct;
        VARIANT vValue;

        Prop(LPWSTR l, int i, CIMTYPE c, VARIANT* v)
        {
            wcscpy(wPropName, l);
            iPos = i;
            ct = c;
            VariantInit(&vValue);
            VariantCopy(&vValue, v);
        }
        ~Prop()
        {
            VariantClear(&vValue);
        }
    };

    CFlexArray arrProps;

    CTextLexSource src(lpPropName);
    CGenLexer Lexer (WQL_LexTable, &src);

    wchar_t wTemp[128];

    // Give ourself an extra ref count.
    BOOL bAddRefed = FALSE;

    int iCurrTok = Lexer.NextToken();

    while (iCurrTok != OPATH_TOK_EOF)
    {        
        switch(iCurrTok)
        {
            // Embedded object property.
            case WQL_TOK_DOT:

                if (!bAddRefed)
                    pObj->AddRef();
                bAddRefed = TRUE;

                bArray = FALSE;
                
                // Retrieve the current embedded object.

                hr = pCurrent->Get(wTemp, 0, &vProp, &ctCurr, NULL);
                if (SUCCEEDED(hr))
                {
                    pUnk = V_UNKNOWN(&vProp);
                    if (pUnk && vProp.vt == VT_UNKNOWN)
                    {
                        pCurrent->Release();
                        pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pCurrent);
                    }
                    else
                    {                       
                        IWbemClassObject *pNewObj = NULL;
                        IWbemClassObject *pClass = NULL;

                        hr = GetEmbeddedClass(pScope, pCurrent, wTemp, &pClass);
                        if (SUCCEEDED(hr))
                        {
                            hr = pClass->SpawnInstance(0, &pNewObj);
                            {
                                pCurrent->Release();
                                pCurrent = pNewObj;
                                V_UNKNOWN(&vProp) = pNewObj;
                                vProp.vt = VT_UNKNOWN;
                            }
                        }
                    }
                    iCurrPos = -1;
                    Prop *pProp = new Prop (wTemp, iCurrPos, ctCurr, &vProp);
                    if (!pProp)
                        hr = WBEM_E_OUT_OF_MEMORY;
                    else
                        arrProps.Add(pProp);
                }
                break;

                // Array
            case WQL_TOK_OPEN_BRACKET:
                bArray = TRUE;
                iCurrTok = Lexer.NextToken();
                iCurrPos = _wtoi(Lexer.GetTokenText());

                hr = pCurrent->Get(wTemp, 0, &vProp, &ctCurr, NULL);
                if (SUCCEEDED(hr))
                {
                    SAFEARRAY *pNew = NULL;
                    SAFEARRAYBOUND aBounds[1];
                    long lLBound, lUBound;

                    if (vProp.vt == VT_NULL)
                    {
                        // We have to create a new safearray.
                        // To avoid calculating the correct number of array elements,
                        // we need to use SafeArrayCopyData 
                        
                        aBounds[0].cElements = 1; 
                        aBounds[0].lLbound = 0;
                        pArray = SafeArrayCreate(ctCurr & 0xFF, 1, aBounds);                                                    
                    }
                    else
                    {
                        pArray = V_ARRAY(&vProp);
                        SafeArrayGetLBound(pArray, 1, &lLBound);
                        SafeArrayGetUBound(pArray, 1, &lUBound);

                        lUBound -= lLBound;
                        lUBound += 2;
                        aBounds[0].cElements = lUBound;
                        aBounds[0].lLbound = 0;
                        
                        pNew = SafeArrayCreate(ctCurr & 0xFF, 1, aBounds);                            
                        for (int i = 0; i < lUBound-1; i++)
                        {
                            void *data;
                            long lTemp[1];
                            lTemp[0] = i;
                            SafeArrayGetElement(pArray, lTemp, &data);
                            if ((ctCurr & 0xFFF) == CIM_STRING)
                                SafeArrayPutElement(pNew, lTemp, data);
                            else
                                SafeArrayPutElement(pNew, lTemp, &data);
                        }
                        SafeArrayDestroy(pArray);
                        pArray = pNew;
                    }

                    V_ARRAY(&vProp) = pArray;
                    vProp.vt = VT_ARRAY;
                    Prop *pProp = new Prop (wTemp, iCurrPos, ctCurr, &vProp);
                    if (pProp)
                        arrProps.Add(pProp);
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                    if (pArray && (ctCurr & 0xFF) == CIM_OBJECT)
                    {
                        hr = GetVariantFromArray(pArray, iCurrPos, (vProp.vt & 0xFF), vTemp);
                        if (SUCCEEDED(hr) )
                        {
                            bArray = FALSE;
                            pUnk = V_UNKNOWN(&vTemp);
                            if (pUnk && (vProp.vt & 0xFF) == VT_UNKNOWN)
                            {
                                pCurrent->Release();
                                pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pCurrent);
                        
                                // This might reference an embedded-embedded object
                                iCurrTok = Lexer.NextToken();    // WQL_TOK_CLOSE_BRACKET
                                iCurrTok = Lexer.NextToken();    // WQL_TOK_DOT
                                iCurrTok = Lexer.NextToken();    // WQL_TOK_IDENT
                            }
                            else
                            {
                                // We need to spawn an instance of whatever this is,
                                // assign it to our pCurrent pointer, and shove it
                                // in this array.
                                IWbemClassObject *pClass, *pNewObj = NULL;
                                hr = GetEmbeddedClass(pScope, pCurrent, wTemp, &pClass);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pClass->SpawnInstance(0, &pNewObj);
                                    if (SUCCEEDED(hr))
                                    {
                                        pCurrent->Release();
                                        pCurrent = pNewObj;
                                    }
                                }  
                            }
                            Prop *pProp = new Prop (Lexer.GetTokenText(), -1, VT_UNKNOWN, &vTemp);
                            if (pProp)
                            {
                                arrProps.Add(pProp);
                                iCurrTok = Lexer.NextToken();    // EOF or DOT
                            }
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;

                        }
                        VariantClear(&vTemp);
                    }
                }
                break;

            case WQL_TOK_CLOSE_BRACKET:               
                break;

            case WQL_TOK_IDENT:
                wcscpy(wTemp, Lexer.GetTokenText());
                VariantClear(&vProp);
                break;
        }
        iCurrTok = Lexer.NextToken();

        if (FAILED(hr))
            break;
    }     

    // Now we have to go through and set each value.
    // wTemp is our current property 
    // Set it in the last element of arrProps.

    if (arrProps.Size() > 0)
    {
        Prop *pProp = (Prop *)arrProps.GetAt(arrProps.Size()-1);
        if (bArray)
        {
            hr = PutVariantInArray(&pArray, pProp->iPos, &vValue);        
            VariantClear(&pProp->vValue);
            V_ARRAY(&pProp->vValue) = pArray;   
            pProp->vValue.vt = VT_ARRAY | pProp->ct;
        }
        else
            hr = pCurrent->Put(wTemp, 0, &vValue, ct);       
    
        for (int i = arrProps.Size() - 1; i > 0; i--)
        {
            Prop *pChild = (Prop *)arrProps.GetAt(i);
            Prop *pParent = (Prop *)arrProps.GetAt(i-1);

            if (pParent->iPos >= 0)
            {
                pArray = V_ARRAY(&pParent->vValue);
                hr = PutVariantInArray(&pArray, pParent->iPos, &pChild->vValue);        
            }
            else
            {
                IWbemClassObject *pTemp=NULL;
                CReleaseMe r (pTemp);
                pUnk = V_UNKNOWN(&pParent->vValue);
                pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pTemp);
                hr = pTemp->Put(pChild->wPropName, 0, &pChild->vValue, pChild->ct);       
            }
        }

        // Finally, set the final element in the object

        pProp = (Prop *)arrProps.GetAt(0);
        hr = pObj->Put(pProp->wPropName, 0, &pProp->vValue, (bArray ? pProp->ct | CIM_FLAG_ARRAY : pProp->ct ));
    }
    else
        hr = WBEM_E_INVALID_OBJECT;

    for (int i = 0; i < arrProps.Size(); i++)
        delete arrProps.GetAt(i);

    if (pCurrent != pObj)
        pCurrent->Release();

    VariantClear(&vProp);

    return hr;

}

HRESULT GetSelectClause(wchar_t *pSQL, MappedProperties *pProps, DWORD dwNumProps, SWQLNode *pColList = NULL)
{
    wcscpy(pSQL, L" SELECT ");
    BOOL bNeedComma = FALSE;

    for (int i = 0; i < dwNumProps; i++)
    {
        for (int j = 0; j < pProps[i].dwNumColumns; j++)
        {
            BOOL bFound = TRUE;
            if (pColList)
            {
                bFound = FALSE;
                SWQLNode_ColumnList *pList = (SWQLNode_ColumnList *)pColList;
                for (int i1 = 0; i1 < pList->m_aColumnRefs.Size(); i1++)
                {
                    SWQLColRef *pColRef = (SWQLColRef *)pList->m_aColumnRefs.GetAt(i1);
                    if (!_wcsicmp(pColRef->m_pColName, pProps[i].wPropName) ||
                        !(_wcsicmp(pColRef->m_pColName, L"*")))
                    {
                        bFound = TRUE;
                        break;
                    }
                }
            }
            else
            {
                bFound = TRUE;
            }

            if (!bFound)
                break;

            if (bNeedComma)
                wcscat(pSQL, L",");

            if (pProps[i].wTableName && wcslen(pProps[i].wTableName))
            {
                wcscat(pSQL, pProps[i].wTableName);
                wcscat(pSQL, L".");
            }
            else
                wcscat(pSQL, L"a.");

            wcscat(pSQL, pProps[i].arrColumnNames[j]);

            // Handle decomposed object columns.

            if (pProps[i].bDecompose &&
                pProps[i].wClassDataCol)
            {
                wcscat(pSQL, L",");

                if (pProps[i].wClassTable && wcslen(pProps[i].wClassTable))
                {
                    wcscat(pSQL, pProps[i].wClassTable);
                    wcscat(pSQL, L".");
                }
                else
                    wcscat(pSQL, L"a.");

                wcscat(pSQL, pProps[i].wClassDataCol);
            }

            bNeedComma = TRUE;
        }
    }

    return 0;
}

HRESULT GetFromClause(wchar_t *pSQL, IWbemClassObject *pMapping, MappedProperties *pProps, DWORD dwNumProps)
{
    HRESULT hr = 0;
    LPWSTR lpDatabaseName = NULL;
    LPWSTR lpTableName = NULL, lpPK = NULL;
    CWStringArray arrTables;

    lpDatabaseName = GetPropertyVal(L"sDatabaseName", pMapping);
    lpTableName = GetPropertyVal(L"sTableName", pMapping);
    lpPK = GetPropertyVal(L"sPrimaryKeyCol", pMapping);

    CDeleteMe <wchar_t> d1 (lpDatabaseName), d2 (lpTableName);

    wcscpy(pSQL, L" FROM ");

    if (lpDatabaseName && wcslen(lpDatabaseName))
    {
        wcscat(pSQL, lpDatabaseName);
        wcscat(pSQL, L"..");
    }

    if (!lpTableName || !wcslen(lpTableName))
        hr = WBEM_E_INVALID_OBJECT;
    else
    {
        wcscat(pSQL, lpTableName);
        wcscat(pSQL, L" AS a ");

        if (!lpPK || !wcslen(lpPK))
        {
            for (int i = 0; i < dwNumProps; i++)
            {
                // BUGBUG: Compound primary keys!

                if (pProps[i].bIsKey)
                {
                    delete lpPK;
                    lpPK = new wchar_t [wcslen(pProps[i].arrColumnNames[0]) + 1];
                    if (lpPK)
                        wcscpy(lpPK, pProps[i].arrColumnNames[0]);
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
            }
        }

        for (int i = 0; i < dwNumProps; i++)
        {
            LPWSTR lpTable = pProps[i].wTableName;
            
            if (lpTable && 
                wcslen(lpTable) &&
                _wcsicmp(lpTable, lpTableName))                
            {
                BOOL bFound = FALSE;
                for (int j = 0; j < arrTables.Size(); j++)
                {
                    if (!_wcsicmp(arrTables.GetAt(j), lpTable))
                        bFound = TRUE;
                }
                if (!bFound)
                {
                    wcscat(pSQL, L" LEFT OUTER JOIN ");
                    if (lpDatabaseName && wcslen(lpDatabaseName))
                    {
                        wcscat(pSQL, lpDatabaseName);
                        wcscat(pSQL, L"..");
                    }
                    wcscat(pSQL, lpTable);
                    wcscat(pSQL, L" AS " );
                    wcscat(pSQL, lpTable);
                    wcscat(pSQL, L" ON ");                
                    wcscat(pSQL, lpTable);
                    wcscat(pSQL, L".");
                    if (pProps[i].arrForeignKeys)
                        wcscat(pSQL, pProps[i].arrForeignKeys[0]); //BUGBUG: Compound foreign key columns!
                    else if (lpPK)
                        wcscat(pSQL, lpPK);
                    else
                        hr = WBEM_E_INVALID_OPERATION;
                    wcscat(pSQL, L" = ");
                    wcscat(pSQL, L"a.");
                    if (pProps[i].bDecompose && pProps[i].arrForeignKeys)
                        wcscat(pSQL, pProps[i].arrForeignKeys[0]);
                    else if (lpPK)
                        wcscat(pSQL, lpPK);
                    else
                        hr = WBEM_E_INVALID_OPERATION;

                    arrTables.Add(lpTable);
                }
            }
            if (pProps[i].bDecompose && pProps[i].wClassTable)                
            {
                lpTable = pProps[i].wClassTable;
                BOOL bFound = FALSE;
                for (int j = 0; j < arrTables.Size(); j++)
                {
                    if (!_wcsicmp(arrTables.GetAt(j), lpTable))
                        bFound = TRUE;
                }
                if (!bFound)
                {
                    if (!pProps[i].wClassForeignKey)
                        hr = WBEM_E_INVALID_OPERATION;
                    else
                    {
                        wcscat(pSQL, L" LEFT OUTER JOIN ");
                        if (lpDatabaseName && wcslen(lpDatabaseName))
                        {
                            wcscat(pSQL, lpDatabaseName);
                            wcscat(pSQL, L"..");
                        }
                        wcscat(pSQL, lpTable);
                        wcscat(pSQL, L" AS " );
                        wcscat(pSQL, lpTable);
                        wcscat(pSQL, L" ON ");                
                        wcscat(pSQL, lpTable);
                        wcscat(pSQL, L".");
                        wcscat(pSQL, pProps[i].wClassForeignKey); 
                        wcscat(pSQL, L" = ");
                        wcscat(pSQL, L"a.");
                        wcscat(pSQL, pProps[i].wClassForeignKey); // One screwy case, since the class table is the parent!

                        arrTables.Add(lpTable);
                    }
                }
            }

        }
    }

    delete lpPK;

    return hr;

}

HRESULT GetWhereClause(wchar_t *pSQL, IWbemClassObject *pMapping, IWbemClassObject *pClass, 
                       IWbemPath *pPath, MappedProperties *pProps, DWORD dwNumProps)
{
    HRESULT hr = 0;
    BOOL bNeedWhere = TRUE;
    wcscpy(pSQL, L"");
    IWbemPathKeyList *pKeyList = NULL;

    hr = pPath->GetKeyList(&pKeyList);
    CReleaseMe r (pKeyList);

    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < dwNumProps; i++)
        {
            if (pProps[i].bIsKey)
            {
           
                BOOL bFound = FALSE;
                
                BYTE    bBuff[255];
                wchar_t *pName = new wchar_t [255];
                if (!pName)
                    return WBEM_E_OUT_OF_MEMORY;

                CDeleteMe <wchar_t> d (pName);
                ULONG ct1;
                ULONG uCount;

                pKeyList->GetCount(&uCount);

                for (ULONG j = 0; j < uCount; j++)
                {
                    DWORD dwLen2 = 255;
                    DWORD dwLen = 255;

                    hr = pKeyList->GetKey(j, 0, &dwLen, pName, &dwLen2, bBuff, &ct1);
                    if (SUCCEEDED(hr) && (!wcslen(pName) || !_wcsicmp(pName, pProps[i].wPropName)))
                    {     
                        if (bNeedWhere)
                            wcscpy(pSQL, L" WHERE ");
                        else
                            wcscat(pSQL, L" AND ");
                        bNeedWhere = FALSE;
                        
                        CIMTYPE ct;
                        pClass->Get(pProps[i].wPropName, 0, NULL, &ct, NULL);

                        BOOL bNeedQuotes = FALSE;
                        if (ct == CIM_STRING || ct == CIM_DATETIME)
                        {
                            if (!pProps[i].bStoreAsNumber)
                                bNeedQuotes = TRUE;
                        }
                    
                        WCHAR * pTempx = new wchar_t [1024];
                        if (!pTempx)
                            return WBEM_E_OUT_OF_MEMORY;

                        ConvertDataToString(pTempx, bBuff, ct);
                        if (SUCCEEDED(hr))
                        {
                            if (ct == CIM_REFERENCE)
                            {
                                // Need to extract the value(s) 
                                // out of the object path.
                                // Ignoring compound keys for now.
                                LPWSTR lpTemp = GetRefKey(pTempx, pProps[i].bStoreAsNumber, bNeedQuotes);
                                if (lpTemp)
                                {
                                    delete pTempx;
                                    pTempx = lpTemp;
                                }
                                else
                                {
                                    delete pTempx;
                                    hr = WBEM_E_OUT_OF_MEMORY;
                                    break;
                                }
                            }

                            CDeleteMe <wchar_t> d (pTempx);

                            wcscat(pSQL, L"a.");
                            wcscat(pSQL, pProps[i].arrColumnNames[0]); //BUGBUG: Compound foreign keys
                            wcscat(pSQL, L"=");
                            if (bNeedQuotes)
                                wcscat(pSQL, L"'");
                            wcscat(pSQL, pTempx);
                            if (bNeedQuotes)
                                wcscat(pSQL, L"'");
                    
                            bFound = TRUE;

                            break;
                        }
                    }
                }

                if (!bFound)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    break;
                }
            }
        }
    }

    return hr;
}

HRESULT GetWhereClause(wchar_t *pSQL, IWbemClassObject *pMapping, IWbemClassObject *pInst, 
                       MappedProperties *pProps, DWORD dwNumProps, LPWSTR lpKeyColName=NULL)
{
    HRESULT hr = 0;
    wcscpy(pSQL, L"");
    BOOL bNeedWhere = TRUE;

    for (int i = 0; i < dwNumProps; i++)
    {
        if (pProps[i].bIsKey)
        {
            if (bNeedWhere)
                wcscpy(pSQL, L" WHERE ");
            else
                wcscat(pSQL, L" AND ");
            bNeedWhere = FALSE;
            
            VARIANT vTemp;
            CIMTYPE ct;
            VariantInit(&vTemp);
            CClearMe c (&vTemp);

            pInst->Get(pProps[i].wPropName, 0, &vTemp, &ct, NULL);

            BOOL bNeedQuotes = FALSE;
            if (ct == CIM_STRING || ct == CIM_DATETIME)
            {
                if (!pProps[i].bStoreAsNumber)
                    bNeedQuotes = TRUE;
            }

            if (lpKeyColName)
                wcscat(pSQL, lpKeyColName); 
            else
                wcscat(pSQL, pProps[i].arrColumnNames[0]); //BUGBUG: Compound primary key

            wcscat(pSQL, L"=");

            LPWSTR lpTemp;
            lpTemp = GetStr(vTemp);

            if (ct == CIM_REFERENCE)
            {
                // Need to extract the value(s) 
                // out of the object path.
                // Ignoring compound keys for now.

                LPWSTR lpTmp = GetRefKey(lpTemp, pProps[i].bStoreAsNumber, bNeedQuotes);
                delete lpTemp;
                lpTemp = lpTmp;
            }               
            
            CDeleteMe <wchar_t> d1 (lpTemp);

            if (bNeedQuotes)
                wcscat(pSQL, L"'");

            if (ct == CIM_DATETIME)
                wcscat(pSQL, (const wchar_t *)GetDateTime(lpTemp));
            else
                wcscat(pSQL, lpTemp);                         
                   
            if (bNeedQuotes)
                wcscat(pSQL, L"'");
        }
    }
    return hr;
}


HRESULT GetDeleteClause(wchar_t *pSQL, IWbemClassObject *pMapping, IWbemClassObject *pInst, 
                       MappedProperties *pProps, DWORD dwNumProps)
{
    HRESULT hr = 0;
    LPWSTR lpTableName = GetPropertyVal(L"sTableName", pMapping);
    LPWSTR lpDatabase = GetPropertyVal(L"sDatabaseName", pMapping);
    CWStringArray arrTables;

    wchar_t wWhere[1024];
    CDeleteMe <wchar_t> d1 (lpTableName), d2 (lpDatabase);

    wcscpy(pSQL, L"");

    // Delete from any other tables.

    for (int i = 0; i < dwNumProps; i++)
    {
        BOOL bFound = FALSE;
        if (pProps[i].wTableName && wcslen(pProps[i].wTableName) && _wcsicmp(pProps[i].wTableName, lpTableName))
        {
            for (int j = 0; j < arrTables.Size(); j++)
            {
                if (!_wcsicmp(pProps[i].wTableName, arrTables.GetAt(j)))
                {
                    bFound = TRUE;
                    break;
                }
            }
            if (!bFound)
            {
                LPWSTR lpKey = NULL;
                if (pProps[i].arrForeignKeys)
                    lpKey = pProps[i].arrForeignKeys[0];
                
                GetWhereClause(wWhere, pMapping, pInst, pProps, dwNumProps, lpKey);

                wcscat(pSQL, L" DELETE from ");
                if (lpDatabase && wcslen(lpDatabase))
                {
                    wcscat(pSQL, lpDatabase);
                    wcscat(pSQL, L"..");
                }
                wcscat(pSQL, pProps[i].wTableName);
                wcscat(pSQL, wWhere);   

                arrTables.Add(pProps[i].wTableName);
            }
        }
        if (pProps[i].wClassTable && wcslen(pProps[i].wClassTable))
        {
            GetWhereClause(wWhere, pMapping, pInst, pProps, dwNumProps, pProps[i].wClassForeignKey);

            wcscat(pSQL, L" DELETE from ");
            if (lpDatabase && wcslen(lpDatabase))
            {
                wcscat(pSQL, lpDatabase);
                wcscat(pSQL, L"..");
            }
            wcscat(pSQL, pProps[i].wClassTable);
            wcscat(pSQL, wWhere);   

            arrTables.Add(pProps[i].wClassTable);
        }
    }

    hr = GetWhereClause(wWhere, pMapping, pInst, pProps, dwNumProps);

    wcscat(pSQL, L" DELETE from ");
    if (lpDatabase && wcslen(lpDatabase))
    {
        wcscat(pSQL, lpDatabase);
        wcscat(pSQL, L"..");
    }
    wcscat(pSQL, lpTableName);
    wcscat(pSQL, wWhere);

    return 0;
}

HRESULT GetUpdateClause(wchar_t *pSQL, IWbemClassObject *pMapping, IWbemClassObject *pObj, 
                        MappedProperties *pProps, DWORD dwNumProps, LPWSTR lpTableName, 
                        BOOL bBaseTable = TRUE)
{
    HRESULT hr = 0;
    BOOL bNeedComma = FALSE;

    LPWSTR lpDatabase = GetPropertyVal(L"sDatabaseName", pMapping);
    CDeleteMe <wchar_t> d (lpDatabase);

    wcscpy(pSQL, L"UPDATE ");
    if (lpDatabase && wcslen(lpDatabase))
    {
        wcscat(pSQL, lpDatabase);
        wcscat(pSQL, L"..");
    }
    wcscat(pSQL, lpTableName);
    wcscat(pSQL, L" set ");

    for (int i = 0; i < dwNumProps; i++)
    {
        int iTableLen = 0;
        if (pProps[i].wTableName)
            iTableLen = wcslen(pProps[i].wTableName);

        if (!pProps[i].bReadOnly && 
            ((bBaseTable && !iTableLen) ||
            (iTableLen && !_wcsicmp(pProps[i].wTableName, lpTableName))))
        {
            VARIANT vTemp;
            CIMTYPE ct;
            CClearMe c (&vTemp);

            if (IsEmbeddedProp(pProps[i].wPropName))
                hr = GetEmbeddedProp(pObj, pProps[i].wPropName, &vTemp, &ct);
            else
                hr = pObj->Get(pProps[i].wPropName, 0, &vTemp, &ct, NULL);

            if (SUCCEEDED(hr))
            {
                BOOL bNull = FALSE;
                BOOL bNeedQuotes = FALSE;
                if (ct == CIM_STRING || ct == CIM_DATETIME)
                {
                    if (!pProps[i].bStoreAsNumber)
                        bNeedQuotes = TRUE;
                }

                LPWSTR lpVal = NULL;
                if (!pProps[i].bStoreAsBlob)
                    lpVal = GetStr(vTemp);

                if (ct == CIM_REFERENCE)
                {
                    LPWSTR lpTmp = GetRefKey(lpVal, pProps[i].bStoreAsNumber, bNeedQuotes);
                    delete lpVal;
                    lpVal = lpTmp;
                }
                
                CDeleteMe <wchar_t> d1 (lpVal);

                if (!lpVal || !wcslen(lpVal))
                    bNull = TRUE;

                if (bNeedComma)
                    wcscat(pSQL, L",");
                bNeedComma = TRUE;
                wcscat(pSQL, pProps[i].arrColumnNames[0]); // BUGBUG: compound primary key
                wcscat(pSQL, L"=");

                if (bNeedQuotes && !bNull)
                    wcscat(pSQL, L"'");

                if (ct == CIM_DATETIME)
                    wcscat(pSQL, (const wchar_t *)GetDateTime(lpVal));
                else if (bNull)
                    wcscat(pSQL, L"null");
                else
                    wcscat(pSQL, lpVal);

                if (bNeedQuotes && !bNull)
                    wcscat(pSQL, L"'");
            }
            else
                break;
        }
    }

    wchar_t wTemp[1024];
    
    hr = GetWhereClause(wTemp, pMapping, pObj, pProps, dwNumProps);
    wcscat(pSQL, wTemp);

    return hr;
}

HRESULT GetInsertClause(wchar_t *pSQL, IWbemClassObject *pMapping, IWbemClassObject *pObj, 
                        MappedProperties *pProps, DWORD dwNumProps, BOOL *bRetVal,
                        LPWSTR lpTableName, BOOL bBaseTable = TRUE)
{
    HRESULT hr = 0;
    BOOL bNeedComma = FALSE;
    wchar_t wPrefix[255], wSuffix[255], wInsert[1024];
    BOOL bNeedRetVal = FALSE;

    LPWSTR lpDatabase = GetPropertyVal(L"sDatabaseName", pMapping);
    LPWSTR lpPK = GetPropertyVal(L"sPrimaryKeyCol", pMapping);
    CDeleteMe <wchar_t> d (lpDatabase), d3(lpPK);

    wcscpy(wPrefix, L"set nocount on declare @RetVal varchar(50) ");

    if (lpPK && wcslen(lpPK))
    {
        wcscpy(wSuffix, L" select @RetVal = @@identity ");
        bNeedRetVal = TRUE;
    }
    else
        wcscpy(wSuffix, L"");

    wcscpy(wInsert, L"INSERT INTO ");
    if (lpDatabase && wcslen(lpDatabase))
    {
        wcscat(wInsert, lpDatabase);
        wcscat(wInsert, L"..");
    }
    wcscat(wInsert, lpTableName);
    wcscat(wInsert, L" ( ");

    for (int i = 0; i < dwNumProps; i++)
    {
        if (pProps[i].bReadOnly)
            continue;

        int iTableLen = 0;
        if (pProps[i].wTableName)
            iTableLen = wcslen(pProps[i].wTableName);

        if ((((bBaseTable && !iTableLen) ||
            (iTableLen && !_wcsicmp(pProps[i].wTableName, lpTableName)))) ||
            (!bBaseTable && pProps[i].bIsKey))
        {
            
            if (bNeedComma)
                wcscat(wInsert, L",");

            bNeedComma = TRUE;
            wcscat(wInsert, pProps[i].arrColumnNames[0]); // BUGBUG: Compound columns
        }
    }

    wcscat(wInsert, L") values (");
    bNeedComma = FALSE;

    for (i = 0; i < dwNumProps; i++)
    {
        int iTableLen = 0;
        if (pProps[i].wTableName)
            iTableLen = wcslen(pProps[i].wTableName);

        if ((((bBaseTable && !iTableLen) ||
            (iTableLen && !_wcsicmp(pProps[i].wTableName, lpTableName)))) ||
            (!bBaseTable && pProps[i].bIsKey))
        {
            VARIANT vTemp;
            CIMTYPE ct;
            CClearMe c (&vTemp);
    
            if (IsEmbeddedProp(pProps[i].wPropName))
                hr = GetEmbeddedProp(pObj, pProps[i].wPropName, &vTemp, &ct);
            else          
                hr = pObj->Get(pProps[i].wPropName, 0, &vTemp, &ct, NULL);

            if (SUCCEEDED(hr))
            {
                BOOL bNull = FALSE;
                IWbemQualifierSet *pQS = NULL;
                pObj->GetPropertyQualifierSet(pProps[i].wPropName, &pQS);
                CReleaseMe r (pQS);

                BOOL bNeedQuotes = FALSE;
                if (ct == CIM_STRING || ct == CIM_DATETIME)
                {
                    if (!pProps[i].bStoreAsNumber)
                        bNeedQuotes = TRUE;
                }
                
                LPWSTR lpVal = NULL;
                if (!pProps[i].bStoreAsBlob)
                    lpVal = GetStr(vTemp);

                if (pQS)
                {
                    DWORD dwKeyholeFlag = GetQualifierFlag(L"keyhole", pQS);
                    if (dwKeyholeFlag)
                    {
                        bNeedRetVal = TRUE;
                        if (bRetVal)
                            *bRetVal = TRUE;
                        if (ct == CIM_STRING && !(pProps[i].bStoreAsNumber))
                        {
                            bNeedQuotes = FALSE;
                            delete lpVal;
                            lpVal = new wchar_t [10];
                            if (lpVal)
                                wcscpy(lpVal, L"@RetVal");
                            wcscpy(wSuffix, L"");
                            wcscat(wPrefix, L" select @RetVal = convert(varchar(50),newid()) ");
                        }
                        else
                        {
                            wcscpy(wSuffix, L" select @RetVal = convert(varchar(50), @@identity) ");
                            delete lpVal;
                            continue;   // identity columns must be read-only.
                        }
                    }
                    else if (pProps[i].bReadOnly)
                    {
                        delete lpVal;
                        continue;
                    }
                }

                if (ct == CIM_REFERENCE)
                {
                    // Need to extract the value(s) 
                    // out of the object path.
                    // Ignoring compound keys for now.

                    LPWSTR lpTmp = GetRefKey(lpVal, pProps[i].bStoreAsNumber, bNeedQuotes);
                    delete lpVal;
                    lpVal = lpTmp;

                }                   

                CDeleteMe <wchar_t> d (lpVal);
                if (bNeedComma)
                    wcscat(wInsert, L",");
                bNeedComma = TRUE;

                if (!lpVal || !wcslen(lpVal))
                    bNull = TRUE;

                if (bNeedQuotes && !bNull)
                    wcscat(wInsert, L"'");

                if (ct == CIM_DATETIME)
                    wcscat(wInsert, (const wchar_t *)GetDateTime(lpVal));
                else if (bNull)
                    wcscat(wInsert, L"null");
                else
                    wcscat(wInsert, lpVal);

                if (bNeedQuotes && !bNull)
                    wcscat(wInsert, L"'");

                delete lpVal;

            }
            else
                break;
        }
    }

    wcscat(wInsert, L")");

    if (SUCCEEDED(hr))
    {
        swprintf(pSQL, L"%s %s %s", wPrefix, wInsert, wSuffix);
        if (bNeedRetVal)
            wcscat(pSQL, L"select @RetVal");
    }

    return hr;
}

HRESULT GetPutClause (wchar_t *pSQL, IWbemClassObject *pMapping, IWbemClassObject *pObj, 
                        MappedProperties *pProps, DWORD dwNumProps, LPWSTR lpTableName,
                        LPWSTR lpKeyholeVal, int iTablePos)
{

    // This function needs to format an IF ... ELSE statement
    // lpKeyholeVal is the new value, if its not present
    // in the object (e.g., implicit keys).

    wchar_t wTemp[1024];
    BOOL bNeedComma = FALSE;
    wchar_t wTable[128];
    HRESULT hr = 0;

    LPWSTR lpDatabase = GetPropertyVal(L"sDatabaseName", pMapping);
    CDeleteMe <wchar_t> d (lpDatabase);

    if (lpDatabase && wcslen(lpDatabase))
        swprintf(wTable, L"%s..%s", lpDatabase, lpTableName);
    else
        wcscpy(wTable, lpTableName);

    // If this is an implicit key, use the new keyhole value.
    if (!lpKeyholeVal || !wcslen(lpKeyholeVal) || 
          !pProps[iTablePos].arrForeignKeys || !wcslen(pProps[iTablePos].arrForeignKeys[0]))
        hr = GetWhereClause(wTemp, pMapping, pObj, pProps, dwNumProps);
    else
        swprintf(wTemp, L" WHERE %s = '%s'", pProps[iTablePos].arrForeignKeys[0], lpKeyholeVal);

    swprintf(pSQL, L" IF EXISTS (select * from %s %s) ", wTable, wTemp);
    
    // UPDATE

    hr = GetUpdateClause(wTemp, pMapping, pObj, pProps, dwNumProps, lpTableName, FALSE);
    wcscat(pSQL, L" ");
    wcscat(pSQL, wTemp);

    wcscat(pSQL, L" ELSE BEGIN ");

    // INSERT
    hr =  GetInsertClause(wTemp, pMapping, pObj, pProps, dwNumProps, NULL, lpTableName, FALSE);
    wcscat(pSQL, wTemp);
    wcscat(pSQL, L" END ");

    return hr;
}

HRESULT GetOrderByClause(SWQLNode_ColumnList *pList, _bstr_t &sSQL, MappedProperties *pProps,DWORD dwNumProps)
{
    BOOL bQueriable = FALSE;
    sSQL = L" order by ";
    BOOL bNeedComma = FALSE;

    for (int i = 0; i < pList->m_aColumnRefs.Size(); i++)
    {
        SWQLColRef *pRef = (SWQLColRef *)pList->m_aColumnRefs.GetAt(i);            
        if (bNeedComma)
            sSQL += L",";
        LPWSTR lpColName = GetColumnName(pRef->m_pColName, pProps, dwNumProps, &bQueriable);
        if (lpColName)
        {
            CDeleteMe <wchar_t> d (lpColName);
            sSQL += lpColName;
            bNeedComma = TRUE;
        }
        else
            bNeedComma = FALSE;
    }

    return 0;
}



HRESULT CWmiDbSession::CustomSetProperties (IWmiDbHandle *pScope, IRowset *pRowset, IMalloc *pMalloc, 
                             IWbemClassObject *pClassObj, MappedProperties *pProps,
                        DWORD dwNumProps, IWbemClassObject *pObj)
{
    HRESULT hr = 0;
    int j;

    if (SUCCEEDED(hr))
    {
        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);

        int iCurrPos = 0;
        while (hr == WBEM_S_NO_ERROR)
        {
            LPWSTR lpColumnName = NULL;
            hr = CSQLExecute::GetColumnValue(pRowset, iCurrPos+1, pMalloc, &pRow, vTemp, &lpColumnName);
            if (hr != WBEM_S_NO_ERROR)
            {
                if (iCurrPos)
                    hr = WBEM_S_NO_ERROR;
                else
                    hr = WBEM_E_NOT_FOUND;

                break;
            }

            CDeleteMe <wchar_t> d (lpColumnName);

            BOOL bMatch = FALSE;
            MappedProperties *pThis = NULL;
            for (; iCurrPos < dwNumProps; iCurrPos++)
            {
                for (int j = 0; j < pProps[iCurrPos].dwNumColumns; j++)
                {
                    if (!_wcsicmp(lpColumnName, pProps[iCurrPos].arrColumnNames[j]) ||
                        (pProps[iCurrPos].wClassDataCol && 
                        !_wcsicmp(lpColumnName, pProps[iCurrPos].wClassDataCol)))
                    {
                        bMatch = TRUE;
                        pThis = &pProps[iCurrPos];
                        break;
                    }
                }
                if (bMatch)
                    break;
            }

            if (bMatch)
            {
                CIMTYPE ct = 0;
                pClassObj->Get(pThis->wPropName, 0, NULL, &ct, NULL);

                // Handle blobs.

                if (pThis->bStoreAsBlob)
                {
                    BYTE *pBuffer = NULL;
                    DWORD dwLen = 0;
                    long why[1];                        
                    unsigned char t;
                    IWbemClassObject *pObj3 = NULL;
                    _IWmiObject *pInt = NULL;

                    SAFEARRAY* pArray = NULL, *pArrayNew;
                    SAFEARRAYBOUND aBounds[1];

                    hr = CSQLExecute::ReadImageValue(pRowset, iCurrPos+1, &pRow, &pBuffer, dwLen);
                    if (SUCCEEDED(hr) && dwLen)
                    {
                        LPVOID  pTaskMem = NULL;

                        switch(ct)
                        {
                        case CIM_FLAG_ARRAY+CIM_UINT8:                                                        
                            aBounds[0].cElements = dwLen; // This *should* be the max value!!!!
                            aBounds[0].lLbound = 0;
                            pArray = SafeArrayCreate(VT_UI1, 1, aBounds);                            
                            for (j = 0; j < dwLen; j++)
                            {            
                                why[0] = j;
                                t = pBuffer[j];
                                hr = SafeArrayPutElement(pArray, why, &t);                            
                            }
                            vTemp.vt = VT_ARRAY+VT_UI1;
                            V_ARRAY(&vTemp) = pArray;
                            CWin32DefaultArena::WbemMemFree(pBuffer);
                            break;
                        case CIM_FLAG_ARRAY + CIM_OBJECT:
                            pArray = (SAFEARRAY *)pBuffer;
                            SafeArrayCopy(pArray, &pArrayNew);
                            V_ARRAY(&vTemp) = pArrayNew;
                            vTemp.vt = VT_ARRAY+VT_UNKNOWN;
                            CWin32DefaultArena::WbemMemFree(pBuffer);
                            break;
                        case CIM_OBJECT:
                            vTemp.vt = VT_UNKNOWN;
                            hr = pClassObj->SpawnInstance(0, &pObj3);
                            if (SUCCEEDED(hr))
                            {
                                hr = pObj3->QueryInterface(IID__IWmiObject, (void **)&pInt);

                                // Allocate COM memory before we pass to SetObjectMemory() - This
                                // will acquire the memory and free the blob.

                                if (SUCCEEDED(hr))
                                {
                                    CReleaseMe r (pObj3);
                                    pTaskMem = CoTaskMemAlloc( dwLen );

                                    if ( NULL != pTaskMem )
                                    {
                                        // COpy the memory
                                        CopyMemory( pTaskMem, pBuffer, dwLen );

                                        // If this is a decomposed embedded object, must reassemble here.

                                        if (pThis->bDecompose)
                                        {
                                            // Read this part (instance part)
                                            // Read next part (class part)
                                            // recombine them and shove them in the instance

                                            hr = pInt->SetObjectParts(pTaskMem, dwLen, WBEM_OBJ_INSTANCE_PART|WBEM_OBJ_DECORATION_PART);
                                            if (SUCCEEDED(hr))
                                            {
                                                BYTE *pBuff = NULL;             
                                                DWORD dwLen2 = 0;
                                                iCurrPos++; // Skip to next row.
                                                hr = CSQLExecute::ReadImageValue(pRowset, iCurrPos+1, &pRow, &pBuff, dwLen2);
                                                if (SUCCEEDED(hr))
                                                {
                                                    CDeleteMe <BYTE> d (pBuff);
                                                    LPVOID pTaskMem2 = CoTaskMemAlloc(dwLen2);
                                                    if (pTaskMem)
                                                    {
                                                        CopyMemory(pTaskMem2, pBuff, dwLen2);

                                                        hr = pInt->SetClassPart(pTaskMem2, dwLen2);
                                                        if (SUCCEEDED(hr))
                                                        {
                                                            V_UNKNOWN(&vTemp) = pInt;
                                                            pInt->AddRef();

                                                            // We evidently don't need to free the buffers, 
                                                            // since SetObjectParts acquires the memory.
                                                        }                                                        
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            hr = pInt->SetObjectMemory(pTaskMem, dwLen);
                                            if (SUCCEEDED(hr))
                                            {
                                                V_UNKNOWN(&vTemp) = (IUnknown *)pInt;
                                                pInt->AddRef();                                                
                                            }                  
                                        }
                                    }
                                    else
                                    {
                                        pObj3->Release();
                                        CoTaskMemFree(pTaskMem);
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                    }
                                }
                                else
                                    pObj3->Release();
                            }

                            // Free the buffer
                            CWin32DefaultArena::WbemMemFree(pBuffer);

                            break;

                        default:
                            CSQLExecute::SetVariant(CIM_STRING, &vTemp, pBuffer, ct);
                            break;
                        }
                        hr = pObj->Put(pThis->wPropName, 0, &vTemp, ct);                        

                        if (!pThis->bDecompose)
                            CoTaskMemFree(pTaskMem);
                    }
                    else
                        hr = WBEM_S_PARTIAL_RESULTS;
                }
                else
                {
                    if (ct == CIM_REFERENCE)
                    {
                        // Need to construct the object path
                        // from the data in this column.
                
                        wchar_t wNewPath[1024];
                        LPWSTR lpClassName = NULL;
                        LPWSTR lpTemp = GetStr(vTemp);
                        CDeleteMe <wchar_t> d(lpTemp), d2 (lpClassName);

                        // Get the class name out of the 
                        // CIMTYPE qualifier
                        // =============================

                        VARIANT vVal;
                        VariantInit(&vVal);
                        IWbemQualifierSet *pQS = NULL;
                        pObj->GetPropertyQualifierSet(pThis->wPropName, &pQS);
                        CReleaseMe r (pQS);
                        hr = pQS->Get(L"cimtype", 0, &vVal, NULL);
                        lpClassName = wcsstr(vVal.bstrVal, L":")+1;

                        if (vTemp.vt == VT_BSTR)
                            swprintf(wNewPath, L"%s=\"%s\"", lpClassName, lpTemp);
                        else
                            swprintf(wNewPath, L"%s=%s", lpClassName, lpTemp);

                        VariantClear(&vTemp);
                        VariantClear(&vVal);
                        vTemp.vt = VT_BSTR;
                        vTemp.bstrVal = SysAllocString(wNewPath);                                                        
                    }

                    if (IsEmbeddedProp(pThis->wPropName))
                        hr = SetEmbeddedProp(pScope, pThis->wPropName, pObj, vTemp, ct);
                    else
                        hr = pObj->Put(pThis->wPropName, 0, &vTemp, ct);
                }
                VariantClear(&vTemp);
            }
            iCurrPos++;
            if (iCurrPos >= dwNumProps)
                break;
        }

        pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
        delete pRow;

        if (SUCCEEDED(hr) && pObj)
        {
            hr = GetSchemaCache()->DecorateWbemObj(m_sMachineName, m_sNamespacePath, 
                ((CWmiDbHandle *)pScope)->m_dObjectId, pObj, 0);
        }

    }                           

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::CustomGetObject
//
//***************************************************************************

HRESULT CWmiDbSession::CustomGetObject(IWmiDbHandle *pScope, IWbemPath *pPath, LPWSTR lpObjectKey, 
        DWORD dwFlags, DWORD dwRequestedHandleType, IWmiDbHandle **ppResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject *pObj = NULL;

    DWORD dwLen = 512;
    wchar_t wClassName[512];
    pPath->GetClassName(&dwLen, wClassName);

    IWbemClassObject *pMappingObj = NULL;
    BOOL bDone = FALSE;
  
    SQL_ID dObjId = 0, dClassId = 0;
    LPWSTR lpKeyString = GetKeyString(lpObjectKey);
    CDeleteMe <wchar_t> d (lpKeyString);
    if (lpKeyString)
    {
        dObjId = CRC64::GenerateHashValue(lpKeyString);
        hr = GetObjectCache()->GetObject(dObjId, &pObj);
        if (SUCCEEDED(hr))
        {
            if (m_pController)
                ((CWmiDbController *)m_pController)->IncrementHitCount(true);
            bDone = TRUE;
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;
    
    if (!bDone)
    {
        // Get a SQL connection.
        IWmiDbHandle *pClassHandle = NULL;
        IWbemPath *pParser = NULL;
        hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                IID_IWbemPath, (LPVOID *) &pParser);
        CReleaseMe r2 (pParser);
        if (SUCCEEDED(hr))
        {
            pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wClassName);

            hr = GetObject(pScope, pParser, 0, WMIDB_HANDLE_TYPE_STRONG_CACHE|WMIDB_HANDLE_TYPE_VERSIONED, &pClassHandle);
            CReleaseMe r1 (pClassHandle);
            if (SUCCEEDED(hr))
            {
                dClassId = ((CWmiDbHandle *)pClassHandle)->m_dObjectId;
                CSQLConnection *pConn = NULL;
                hr = GetSQLCache()->GetConnection(&pConn);
                if (SUCCEEDED(hr))
                {
                    hr = CustomGetMapping(pConn, pScope, wClassName, &pMappingObj);
                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pClassObj = NULL;
                        pClassHandle->QueryInterface(IID_IWbemClassObject, (void **)&pClassObj);
                        CReleaseMe r2 (pClassObj);

                        if (pClassObj)
                        {
                            hr = pClassObj->SpawnInstance(0, &pObj);
                            if (SUCCEEDED(hr))
                            {
                                CWStringArray arrKeyValues;
                                if (SUCCEEDED(hr))
                                {
                                    wchar_t * pSQL = new wchar_t [2048];
                                    CDeleteMe <wchar_t> d (pSQL);

                                    if (!pSQL)
                                    {
                                        GetSQLCache()->ReleaseConnection(pConn);                
                                        return WBEM_E_OUT_OF_MEMORY;
                                    }

                                    MappedProperties *pProps = NULL;
                                    DWORD dwNumProps;
                                    BOOL bNeedWhere = TRUE;

                                    // See if there are any parents, and if 
                                    // any of them are mapped.

                                    hr = ConvertObjToStruct(pMappingObj, &pProps, &dwNumProps);
                                    CDeleteMe <MappedProperties> d1 (pProps);
                                    if (SUCCEEDED(hr))
                                    {
                                        VARIANT vTemp;
                                        CClearMe c (&vTemp);
                                        hr = pObj->Get(L"__Derivation", 0, &vTemp, NULL, NULL);
                                        SAFEARRAY *psaArray = V_ARRAY(&vTemp);
                                        if (psaArray)
                                        {
                                            long lLBound, lUBound;
                                            SafeArrayGetLBound(psaArray, 1, &lLBound);
                                            SafeArrayGetUBound(psaArray, 1, &lUBound);

                                            lUBound -= lLBound;
                                            lUBound += 1;

                                            for (int i = 0; i < lUBound; i++)
                                            {
                                                IWbemClassObject *pMapping2 = NULL;
                                                VARIANT vT2;
                                                VariantInit(&vT2);
                                                LPWSTR lpValue = NULL;
                                                hr = GetVariantFromArray(psaArray, i, VT_BSTR, vT2);
                                                lpValue = GetStr(vT2);
                                                CDeleteMe <wchar_t> r (lpValue);
                                                VariantClear(&vT2);

                                                hr = CustomGetMapping(pConn, pScope, lpValue, &pMapping2);
                                                CReleaseMe r3 (pMapping2);
                                                if (SUCCEEDED(hr))
                                                    hr = AddObjToStruct(pMapping2, &pProps, dwNumProps, &dwNumProps);
                                            }                        
                                        }

                                        // Form the SQL statement.

                                        hr = GetSelectClause(pSQL, pProps, dwNumProps);

                                        wchar_t wTemp[1024];
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = GetFromClause(wTemp, pMappingObj, pProps, dwNumProps);
                                            if (SUCCEEDED(hr))
                                            {
                                                wcscat(pSQL, wTemp);
                                                hr = GetWhereClause(wTemp, pMappingObj, pClassObj, pPath, pProps, dwNumProps);
                                                if (SUCCEEDED(hr))
                                                    wcscat(pSQL, wTemp);
                                            }
                                        }

                                        if (SUCCEEDED(hr))
                                        {
                                            IRowset *pRowset = NULL;
                                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), pSQL, &pRowset, NULL);
                                            CReleaseMe r (pRowset);
                                            if (SUCCEEDED(hr))
                                                hr = CustomSetProperties(pScope, pRowset, m_pIMalloc, pClassObj, 
                                                                            pProps, dwNumProps, pObj);
                                        }
                                        ClearPropArray(pProps, dwNumProps);
                                    }
                                }
                            }
                        }

                        if (SUCCEEDED(hr))
                        {

                            if (m_pController)
                                ((CWmiDbController *)m_pController)->IncrementHitCount(false);

                            // Cache this object if needed.

                            if (GetObjectCache()->ObjectExists(dObjId) ||
                                (dwRequestedHandleType & 0xF00) == WMIDB_HANDLE_TYPE_WEAK_CACHE ||
                                (dwRequestedHandleType & 0xF00) == WMIDB_HANDLE_TYPE_STRONG_CACHE)
                            {
                                bool bCacheType = ((dwRequestedHandleType & 0xF00) == WMIDB_HANDLE_TYPE_STRONG_CACHE) ? 1 : 0;            
                                GetObjectCache()->PutObject(dObjId, dClassId, 
                                    ((CWmiDbHandle *)pScope)->m_dObjectId, lpKeyString, bCacheType, pObj);
                            }
                        }

                        if (FAILED(hr))
                        {
                            *ppResult = NULL;
                            pObj->Release();
                        }
                    }
                    GetSQLCache()->ReleaseConnection(pConn);                
                }    
            }
        }
    }

    if (hr == WBEM_S_NO_ERROR && pObj)
    {
        // Wrap this in an IWmiDbHandle
        CWmiDbHandle *pTemp = new CWmiDbHandle;
        if (pTemp)
        {        
            bool bImmediate = !(dwRequestedHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED);
            DWORD dwVersion = 0;
            pTemp->m_pSession = this;

            hr = VerifyObjectSecurity(NULL, dObjId, dClassId, ((CWmiDbHandle *)pScope)->m_dObjectId, 0, WBEM_ENABLE);
            if (SUCCEEDED(hr))
            {
                hr = ((CWmiDbController *)m_pController)->LockCache.AddLock(bImmediate, dObjId, dwRequestedHandleType, pTemp, 
                            ((CWmiDbHandle *)pScope)->m_dObjectId, dClassId, 
                            &((CWmiDbController *)m_pController)->SchemaCache, false, 0, 0, &dwVersion);
                if (SUCCEEDED(hr))
                {     
                    ((CWmiDbController *)m_pController)->AddHandle();
                    pTemp->AddRef();
                    pTemp->m_dwHandleType = dwRequestedHandleType;
                    pTemp->m_dObjectId = dObjId;
                    pTemp->m_bDefault = FALSE;
                    pTemp->m_dClassId = dClassId;
                    pTemp->m_dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;
                    pTemp->m_dwVersion = dwVersion;
                    pTemp->m_pData = pObj;
                    pObj->AddRef();
                    if (ppResult)
                        *ppResult = pTemp;
                }
            }

            if (FAILED(hr))
            {
                delete pTemp;
                *ppResult = NULL;
            }
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::CustomGetMapping
//
//***************************************************************************
HRESULT CWmiDbSession::CustomGetMapping(CSQLConnection *pConn, IWmiDbHandle *pScope, LPWSTR lpClassName, 
                                        IWbemClassObject **ppMapping)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    wchar_t *wTemp = new wchar_t [wcslen(lpClassName) + 50];
    if (!wTemp)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe <wchar_t> d (wTemp);

    swprintf(wTemp, L"__CustRepDrvrMapping.sClassName=\"%s\"", lpClassName);
    IWmiDbHandle *pMapping = NULL;  

    LPWSTR lpPath = NULL;
    hr = NormalizeObjectPath(pScope, wTemp, &lpPath, FALSE, NULL, NULL, pConn);
    if (SUCCEEDED(hr))
    {
        CDeleteMe <wchar_t> d (lpPath);

        SQL_ID dScopeId = 0;
        hr = GetObject_Internal(lpPath, 0, WMIDB_HANDLE_TYPE_STRONG_CACHE|WMIDB_HANDLE_TYPE_VERSIONED, &dScopeId,
            &pMapping, pConn);

        CReleaseMe r (pMapping);

        if (SUCCEEDED(hr))
        {
            IWbemClassObject *pMappingObj = NULL;
            hr = pMapping->QueryInterface(IID_IWbemClassObject, (void **)&pMappingObj);
            if (SUCCEEDED(hr))
                *ppMapping = pMappingObj;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::CustomCreateMapping
//
//***************************************************************************
HRESULT CWmiDbSession::CustomCreateMapping(CSQLConnection *pConn, LPWSTR lpClassName, IWbemClassObject *pObj,
                                           IWmiDbHandle *pScope)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject *pMapping = NULL; 
    hr = CustomGetMapping(pConn, pScope, lpClassName, &pMapping);
    CReleaseMe r (pMapping);

    if (FAILED(hr))
    {
        // If there's no mapping, this may be an abstract class.
        
        IWbemQualifierSet *pQS = NULL;
        pObj->GetQualifierSet(&pQS);
        CReleaseMe r (pQS);
        DWORD dwFlag = GetQualifierFlag(L"Abstract", pQS) ? REPDRVR_FLAG_ABSTRACT : 0;
        if (dwFlag != 0)
            hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::CustomPutInstance
//
//***************************************************************************
HRESULT CWmiDbSession::CustomPutInstance(CSQLConnection *pConn, IWmiDbHandle *pScope, SQL_ID dClassId, 
                                         DWORD dwFlags, IWbemClassObject **ppObjToPut, LPWSTR lpClass)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IWbemClassObject *pObj = *ppObjToPut;
    wchar_t wKeyhole[50];
    LPWSTR lpTableName = NULL;

    IWbemClassObject *pMapping = NULL;
    LPWSTR lpClassName = GetPropertyVal(L"__Class", pObj);
    CDeleteMe <wchar_t> d1 (lpClassName);

    if (!lpClass)
        hr = CustomGetMapping(pConn, pScope, lpClassName, &pMapping);
    else
        hr = CustomGetMapping(pConn, pScope, lpClass, &pMapping);
    CReleaseMe r2 (pMapping);
    if (SUCCEEDED(hr))
    {
        MappedProperties *pProps = NULL;
        DWORD dwNumProps = 0;
        BOOL bExists = FALSE;
        BOOL bKeyhole = FALSE;

        hr = ConvertObjToStruct(pMapping, &pProps, &dwNumProps);
        CDeleteMe <MappedProperties> d3 (pProps);
        if (SUCCEEDED(hr))
        {
            // Take the flags into account.  See if the object already exists.
            // If so (and not in violation of flags), update
            // If not (and not in violation of flags), insert
            // Special treatment for other tables.

            LPWSTR lpRelPath = GetPropertyVal(L"__RelPath", pObj);
            CDeleteMe <wchar_t> d3 (lpRelPath);

            IWbemPath *pParser = NULL;
            hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                    IID_IWbemPath, (LPVOID *) &pParser);
            if (SUCCEEDED(hr))
            {
                pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpRelPath);
                CReleaseMe r (pParser);
                IWmiDbHandle *pHandle = NULL;

                hr = GetObject(pScope, pParser, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pHandle);

                if (SUCCEEDED(hr))
                    bExists = TRUE;
                hr = 0;

                CReleaseMe r1 (pHandle);

                switch(dwFlags)
                {
                    case WBEM_FLAG_CREATE_ONLY:
                        if (bExists)
                            hr = WBEM_E_ALREADY_EXISTS;
                        break;
                    case WBEM_FLAG_UPDATE_ONLY:
                        if (!bExists)
                            hr = WBEM_E_NOT_FOUND;
                        break;
                    default:
                        break;
                }

                if (SUCCEEDED(hr))
                {
                    wchar_t wSQL[4096];
                    lpTableName = GetPropertyVal(L"sTableName", pMapping);

                    if (!lpTableName)
                        hr = WBEM_E_INVALID_OBJECT;
                    else
                    {
                        if (bExists)
                            hr = GetUpdateClause(wSQL, pMapping, pObj, pProps, dwNumProps, lpTableName);
                        else
                            hr = GetInsertClause(wSQL, pMapping, pObj, pProps, dwNumProps, &bKeyhole, lpTableName);

                        if (SUCCEEDED(hr))
                        {
                            IRowset *pRowset = NULL;                           
                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), wSQL, &pRowset);
                            CReleaseMe r (pRowset);

                            if (SUCCEEDED(hr))
                            {
                                if (bKeyhole)
                                {
                                    // Grab the new GUID and stick it in the keyhole.
                                    _bstr_t sKeyholeProp;
                                    DWORD dwKeyholePropID = 0;

                                    GetSchemaCache()->GetKeyholeProperty
                                                (dClassId, dwKeyholePropID, sKeyholeProp);
                                    HROW *pRow = NULL;
                                    VARIANT vTemp;
                                    CClearMe c (&vTemp);
                                    CIMTYPE ct = 0;

                                    pObj->Get(sKeyholeProp, 0, NULL, &ct, NULL);

                                    hr = CSQLExecute::GetColumnValue(pRowset, 1, m_pIMalloc, &pRow, vTemp);
                                    if (SUCCEEDED(hr) && sKeyholeProp.length())
                                        pObj->Put(sKeyholeProp, 0, &vTemp, ct);

                                    // Store this value for later use.

                                    wcscpy(wKeyhole, vTemp.bstrVal);

                                    pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                                    delete pRow;
                                }
                                else
                                    wcscpy(wKeyhole, L"");
                            }
                        }
                    }
                }
            }
        }       

        // At this point, we have inserted the base table, and wKeyhole
        // now contains the new ID.
        // Insert or update all other tables, and blobs, as needed.
        // ===========================================================

        if (SUCCEEDED(hr))
        {
            for (int i = 0; i < dwNumProps; i++)
            {
                CWStringArray arrTables;
                if ((pProps[i].wTableName && wcslen(pProps[i].wTableName)) || pProps[i].bStoreAsBlob)
                {
                    wchar_t wSQL[4096];
                    BOOL bFound = FALSE;

                    if (!pProps[i].wTableName || !wcslen(pProps[i].wTableName))
                    {
                        delete pProps[i].wTableName;
                        pProps[i].wTableName = new wchar_t [ wcslen(lpTableName) + 1];
                        if (pProps[i].wTableName)
                            wcscpy(pProps[i].wTableName, lpTableName);
                        else
                            return WBEM_E_OUT_OF_MEMORY;
                    }

                    for (int j = 0; j < arrTables.Size(); j++)
                    {
                        if (!_wcsicmp(arrTables.GetAt(j), pProps[i].wTableName))
                        {
                            bFound = TRUE;
                            break;
                        }
                    }
                    if (!bFound)
                        arrTables.Add(pProps[i].wTableName);
                    else if (!pProps[i].bStoreAsBlob)
                        continue;

                    // Decomposition on Put
                    // Locate the matching classes, memcmp and insert new if needed
                    // Obtain new foreign keys, insert them and update ClassId, InstanceId
                    // GetPutClause will fail since we expect the base table to be the 
                    // parent table, and in the special decomposition case, it will be the opposite.

                    if (pProps[i].bDecompose)
                    {
                        BYTE *pClassBuff = NULL, *pInstBuff = NULL;
                        DWORD dwClassBuffLen = 0, dwInstBuffLen = 0;

                        VARIANT vTemp;
                        VariantClear(&vTemp);
                        CIMTYPE ct = 0;

                        hr = pObj->Get(pProps[i].wPropName, 0, &vTemp, &ct, NULL);
                        if (SUCCEEDED(hr) && vTemp.vt == VT_UNKNOWN)
                        {
                            _IWmiObject *pInt = NULL;
                            IUnknown *pUnk = V_UNKNOWN(&vTemp);
                            hr = pUnk->QueryInterface(IID__IWmiObject, (void **)&pInt);
                            if (SUCCEEDED(hr))
                            {
                                CReleaseMe r (pInt);
                                LPWSTR lpClassName = GetPropertyVal(L"__Class", pInt);
                                LPWSTR lpTable = GetPropertyVal(L"sTableName", pMapping);
                                LPWSTR lpDatabase = GetPropertyVal(L"sDatabaseName", pMapping);

                                CDeleteMe <wchar_t> d1 (lpDatabase), d2 (lpTable), d3(lpClassName);

                                pInt->GetObjectParts(NULL, 0, WBEM_OBJ_INSTANCE_PART|WBEM_OBJ_DECORATION_PART, &dwInstBuffLen);
                                if (dwInstBuffLen)
                                {
                                    pInstBuff = new BYTE[dwInstBuffLen];
                                    if (pInstBuff)
                                        hr = pInt->GetObjectParts(pInstBuff, dwInstBuffLen, 
                                                WBEM_OBJ_INSTANCE_PART|WBEM_OBJ_DECORATION_PART, &dwInstBuffLen);                                    
                                    else
                                        return WBEM_E_OUT_OF_MEMORY;
                                }

                                pInt->GetObjectParts(NULL, 0, WBEM_OBJ_CLASS_PART, &dwClassBuffLen);
                                if (dwClassBuffLen)
                                {
                                    pClassBuff = new BYTE[dwClassBuffLen];
                                    if (pClassBuff)
                                        hr = pInt->GetObjectParts(pClassBuff, dwClassBuffLen, 
                                                WBEM_OBJ_CLASS_PART, &dwClassBuffLen);                                    
                                    else
                                        return WBEM_E_OUT_OF_MEMORY;
                                }

                                DWORD dwInstanceID = 0, dwClassID = 0;
                                wchar_t wWhere[1024];
                                GetWhereClause(wWhere, pMapping, pObj, pProps, dwNumProps);
                                LPWSTR lpBaseTable = FormatTableName(pMapping);
                                CDeleteMe <wchar_t> d4 (lpBaseTable);

                                // For existing instance, retrieve 
                                // existing Instance Id

                                IRowset *pRowset = NULL;
                                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
                                    L"select %s from %s %s", &pRowset, NULL,
                                    pProps[i].arrForeignKeys[0], lpBaseTable, wWhere);

                                if (SUCCEEDED(hr))
                                {
                                    CReleaseMe r (pRowset);
                                    HROW *pRow = NULL;
                                    VARIANT vTemp;
                                    CClearMe c (&vTemp);

                                    hr = CSQLExecute::GetColumnValue(pRowset, 1, m_pIMalloc, &pRow, vTemp);
                                    hr = pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                                    delete pRow;
                                    pRow = NULL;

                                    if (vTemp.vt == VT_I4)
                                        dwInstanceID = vTemp.lVal;
                                    else if (vTemp.vt == VT_BSTR)
                                        dwInstanceID = _wtoi64(vTemp.bstrVal);
                                    else
                                        dwInstanceID = 0;
                                }

                                wchar_t wSQL[1024];
                                LPWSTR lpInstTable = FormatTableName(pMapping, pProps[i].wTableName);
                                CDeleteMe <wchar_t> d (lpInstTable);
                                if (!dwInstanceID)
                                {
                                    swprintf(wSQL, L"insert into %s (%s) values (NULL) ",
                                        lpInstTable, pProps[i].arrColumnNames[0]);
                                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), wSQL);

                                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
                                        L"select @@identity", &pRowset, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        CReleaseMe r (pRowset);
                                        HROW *pRow = NULL;
                                        VARIANT vTemp;
                                        CClearMe c (&vTemp);

                                        hr = CSQLExecute::GetColumnValue(pRowset, 1, m_pIMalloc, &pRow, vTemp);
                                        hr = pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                                        delete pRow;
                                        pRow = NULL;

                                        if (vTemp.vt == VT_I4)
                                            dwInstanceID = vTemp.lVal;
                                        else if (vTemp.vt == VT_BSTR)
                                            dwInstanceID = _wtoi64(vTemp.bstrVal);
                                    }
                                }
                                else
                                {
                                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
                                        L"IF NOT EXISTS (select * from %s where %s = %ld) "
                                        L" insert into %s (%s) values (NULL) ", NULL, NULL,
                                        lpInstTable, pProps[i].arrColumnNames[0], dwInstanceID,
                                        lpInstTable, pProps[i].arrColumnNames[0]);
                                }

                                swprintf(wSQL, L"select %s from %s where %s = %ld ",
                                    pProps[i].arrColumnNames[0], lpInstTable,
                                    pProps[i].arrForeignKeys[0], dwInstanceID);

                                hr = CSQLExecute::WriteImageValue(((COLEDBConnection *)pConn)->GetCommand(), wSQL, 1, pInstBuff, dwInstBuffLen);
                                
                                // Obtain ID for class part.  Find match
                                // or insert new and retrieve ID.

                                LPWSTR lpClassTable = FormatTableName(pMapping, pProps[i].wClassTable);
                                CDeleteMe <wchar_t> d5 (lpClassTable);

                                hr = GetClassBufferID (pConn, &pProps[i], lpClassTable, lpClassName, 
                                                pClassBuff, dwClassBuffLen, dwClassID, m_pIMalloc);
                                
                                // Update main table with new Class + Instance IDs,
                                // if necessary.

                                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
                                    L"update %s set %s = %ld, %s = %ld %s",NULL, NULL,
                                    lpBaseTable, pProps[i].arrForeignKeys[0],
                                    dwInstanceID, pProps[i].wClassForeignKey,
                                    dwClassID, wWhere);                                
                            }
                        }
                        else
                        {
                            // Set both class and instance IDs to zero, 
                            // and delete the instance row.

                            if (bExists)
                            {
                                wchar_t wWhere[1024];
                                GetWhereClause(wWhere, pMapping, pObj, pProps, dwNumProps);
                                LPWSTR lpBaseTable = FormatTableName(pMapping);
                                CDeleteMe <wchar_t> d2 (lpBaseTable);

                                IRowset *pRowset = NULL;
                                DWORD dInstanceId = 0;

                                // Need to retrieve existing Instance ID, if any.

                                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
                                    L"select %s from %s %s", &pRowset, NULL,
                                    pProps[i].arrForeignKeys[0], lpBaseTable, wWhere);

                                if (SUCCEEDED(hr))
                                {
                                    CReleaseMe r (pRowset);
                                    HROW *pRow = NULL;
                                    VARIANT vTemp;
                                    CClearMe c (&vTemp);

                                    hr = CSQLExecute::GetColumnValue(pRowset, 1, m_pIMalloc, &pRow, vTemp);
                                    hr = pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                                    delete pRow;
                                    pRow = NULL;

                                    if (vTemp.vt == VT_I4)
                                        dInstanceId = vTemp.lVal;
                                }

                                if (dInstanceId)
                                {
                                    LPWSTR lpTableName = FormatTableName(pMapping, pProps[i].wTableName);
                                    CDeleteMe <wchar_t> d1 (lpTableName);

                                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
                                        L"delete from %s where %s = %ld ",NULL, NULL, lpTableName, 
                                        pProps[i].arrForeignKeys[0], dInstanceId);

                                    if (SUCCEEDED(hr))
                                    {
                                        // Update Existing IDs to zero
                                  
                                        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
                                            L"update %s set %s = 0, %s = 0 %s",NULL, NULL,
                                            lpBaseTable, pProps[i].arrForeignKeys[0],
                                            pProps[i].wClassForeignKey, wWhere);

                                    }
                                }
                            }
                        }
                    }
                    else
                    {

                        // Where are the keys at this point?
                        // We need the key values
                
                        hr = GetPutClause (wSQL, pMapping, pObj, 
                                        pProps, dwNumProps, pProps[i].wTableName, wKeyhole, i);

                        if (SUCCEEDED(hr))
                        {
                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), wSQL);
                            if (SUCCEEDED(hr) && pProps[i].bStoreAsBlob)
                            {
                                wchar_t wTemp[512];
                                wchar_t wTable[128];

                                LPWSTR lpDatabase = GetPropertyVal(L"sDatabaseName", pMapping);
                                CDeleteMe <wchar_t> d1 (lpDatabase);
                                if (lpDatabase && wcslen(lpDatabase))
                                    swprintf(wTable, L"%s..%s", lpDatabase, pProps[i].wTableName);
                                else
                                    wcscpy(wTable, pProps[i].wTableName);

                                // Write any blob data if needed.
                            
                                swprintf(wSQL, L"select %s from %s ", pProps[i].arrColumnNames[0], wTable);                   

                                GetWhereClause (wTemp, pMapping, pObj, pProps, dwNumProps);
                                wcscat(wSQL, wTemp);

                                BYTE *pBuff = NULL;
                                DWORD dwLen = 0;
                                VARIANT vTemp;
                                VariantInit(&vTemp);
                                CIMTYPE ct;

                                pObj->Get(pProps[i].wPropName, 0, &vTemp, &ct, NULL);
                                if (vTemp.vt != VT_NULL && vTemp.vt != VT_EMPTY)
                                {
                                    if (ct == (CIM_FLAG_ARRAY + CIM_UINT8))
                                        GetByteBuffer(&vTemp, &pBuff, dwLen);
                                    else if (ct == CIM_OBJECT)
                                    {
                                        pBuff = NULL;
                                        _IWmiObject *pInt = NULL;
                                        IUnknown *pUnk = V_UNKNOWN(&vTemp);

                                        hr = pUnk->QueryInterface(IID__IWmiObject, (void **)&pInt);
                                        if (SUCCEEDED(hr))
                                        {                                        
                                            pInt->GetObjectMemory(NULL, 0, &dwLen);
                                            pBuff = new BYTE [dwLen];
                                            if (pBuff)
                                            {
                                                DWORD dwLen1;
                                                hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);      
                                            }
                                            pInt->Release();
                                        }                               
                                    }
                                    else if (ct == CIM_OBJECT + CIM_FLAG_ARRAY)
                                    {
                                        // We're going to have to extract each element 
                                        // from the array, concatenate the blobs, and 
                                        // store them separately.

                                        hr = WBEM_E_NOT_SUPPORTED;
                                    }
                                    else
                                    {
                                        // We will only support storing text and 
                                        // uint8 arrays as blobs.

                                        switch(ct)
                                        {
                                        case VT_BSTR:
                                            pBuff = (BYTE *)vTemp.bstrVal;
                                            dwLen = wcslen(vTemp.bstrVal) * 2;
                                            break;
                                        default:
                                            hr = WBEM_E_NOT_SUPPORTED;
                                            break;
                                        }
                                    }
                        
                                    if (SUCCEEDED(hr) && dwLen > 0)
                                        hr = CSQLExecute::WriteImageValue(((COLEDBConnection *)pConn)->GetCommand(), wSQL, 1, pBuff, dwLen);
                                }
                            
                                delete pBuff;
                                VariantClear(&vTemp);
                            }
                        }
                    }
                }
            }
        }
        ClearPropArray(pProps, dwNumProps);
    }

    delete lpTableName;

    // Set data in the parent tables, if any.

    if (SUCCEEDED(hr))
    {
        LPWSTR lpParent = NULL;
        lpParent = GetPropertyVal(L"__SuperClass", pObj);
        CDeleteMe <wchar_t> d2 (lpParent);
        if (lpParent && wcslen(lpParent) && _wcsicmp(lpParent, L"__Class"))
            CustomPutInstance(pConn, pScope, dClassId, dwFlags, ppObjToPut, lpParent);
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::CustomDelete
//
//***************************************************************************
HRESULT CWmiDbSession::CustomDelete(CSQLConnection *pConn, IWmiDbHandle *pScope, IWmiDbHandle *pHandle, LPWSTR lpClass)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (((CWmiDbHandle *)pHandle)->m_dClassId == 1 ||
        (lpClass && lpClass[0] == L'_'))
        return WBEM_S_NO_ERROR; // Ignore classes and system objects.
    
    IWbemClassObject *pObj = NULL, *pMapping = NULL;
    hr = pHandle->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
    CReleaseMe r1 (pObj);
    if (SUCCEEDED(hr))
    {
        LPWSTR lpClassName = NULL;        
        lpClassName = GetPropertyVal(L"__Class", pObj);
        CDeleteMe <wchar_t> d1 (lpClassName);

        if (!lpClass)
            hr = CustomGetMapping(pConn, pScope, lpClassName, &pMapping);
        else
            hr = CustomGetMapping(pConn, pScope, lpClass, &pMapping);

        CReleaseMe r2 (pMapping);

        if (SUCCEEDED(hr))
        {
            // Just bind key properties 
            // and execute.

            MappedProperties *pProps = NULL;
            DWORD dwNumProps;

            hr = ConvertObjToStruct(pMapping, &pProps, &dwNumProps);
            CDeleteMe <MappedProperties> p (pProps);
            if (SUCCEEDED(hr))
            {
                // If decomposition, only instance part will be deleted (not class)
                wchar_t wSQL[2048];
                hr = GetDeleteClause(wSQL, pMapping, pObj, pProps, dwNumProps);

                if (SUCCEEDED(hr))
                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), wSQL);
                ClearPropArray(pProps, dwNumProps);
            }

            // Clean up the parent tables, if any.
            if (SUCCEEDED(hr))
            {
                LPWSTR lpParent = NULL;
                lpParent = GetPropertyVal(L"__SuperClass", pObj);
                CDeleteMe <wchar_t> d2 (lpParent);
                if (lpParent && wcslen(lpParent) && _wcsicmp(lpParent, L"__Class"))
                    hr = CustomDelete(pConn, pScope, pHandle, lpParent);
            }
        }
        // This may be an abstract class,
        // or otherwise have no mapping.

        else if (hr == WBEM_E_NOT_FOUND)
            hr = WBEM_S_NO_ERROR;
    }
    
    return hr;
}


//***************************************************************************
//
//  FormatWhereClause
//
//***************************************************************************

HRESULT FormatWhereClause (SWQLNode_RelExpr *pNode, _bstr_t &sSQL, MappedProperties *pMapping, DWORD dwNumProps)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (pNode)
    {
        DWORD dwType = pNode->m_dwExprType;
        _bstr_t sTemp;

        switch(dwType)
        {
        case WQL_TOK_OR:
        case WQL_TOK_AND:
            if (pNode->m_pLeft)
            {
                sTemp = "(";
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pLeft, sTemp, pMapping, dwNumProps);
            }
            if (dwType == WQL_TOK_OR)
                sTemp += " OR ";
            else 
                sTemp += " AND ";

            if (pNode->m_pRight)
            {                
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pRight, sTemp, pMapping, dwNumProps);
                sTemp += ")";
            }

            sSQL += sTemp;

            break;
        case WQL_TOK_NOT:
            sSQL += " NOT ";

            // Supposedly, only a left clause follows not...

            if (pNode->m_pLeft)
            {
                hr = FormatWhereClause((SWQLNode_RelExpr *)pNode->m_pLeft, sTemp, pMapping, dwNumProps);
                sSQL += sTemp;
            }
            break;

        default:    // Typed expression
            
            SWQLTypedExpr *pExpr = ((SWQLNode_RelExpr *)pNode)->m_pTypedExpr;
            if (pExpr != NULL)
            {
                DWORD dwOp = pExpr->m_dwRelOperator;  
                wchar_t wSQL[1024];
                BOOL bQueriable = FALSE;

                LPWSTR lpColName = GetColumnName(pExpr->m_pColRef, pMapping, dwNumProps, &bQueriable, pExpr->m_pIntrinsicFuncOnColRef,
                    pExpr->m_pLeftFunction);
                CDeleteMe <wchar_t> d2 (lpColName);

                if (!lpColName || !bQueriable)
                {
                    hr = WBEM_E_INVALID_QUERY;
                    break;
                }

                LPWSTR lpOp = GetOperator(dwOp);
                LPWSTR lpValue = NULL;
                CDeleteMe <wchar_t> d (lpOp);

                switch (dwOp)
                {
                case WQL_TOK_NULL:
                case WQL_TOK_ISNULL:
                  swprintf(wSQL, L" %s is null ", lpColName);
                  sSQL += wSQL;
                  break;
                case WQL_TOK_NOT_NULL:
                  swprintf(wSQL, L" %s is not null ", lpColName);
                  sSQL += wSQL;
                  break;
                case WQL_TOK_NOT_IN:
                case WQL_TOK_IN:
                case WQL_TOK_IN_CONST_LIST:
                case WQL_TOK_NOT_IN_CONST_LIST:
                case WQL_TOK_ISA:
                case WQL_TOK_BETWEEN:
                case WQL_TOK_IN_SUBSELECT:
                case WQL_TOK_NOT_IN_SUBSELECT:
                    hr = WBEM_E_NOT_SUPPORTED;
                    break;

                default: 
                    if (pExpr->m_pConstValue)
                    {
                        if (pExpr->m_pConstValue->m_dwType == VT_LPWSTR) 
                        {
                            lpValue = new wchar_t [10 + wcslen(pExpr->m_pConstValue->m_Value.m_pString)];
                            if (lpValue)
                            {
                                swprintf(lpValue, L"'%s'", pExpr->m_pConstValue->m_Value.m_pString);
                                // Double percents, since ExecQuery fries this character.
                                LPWSTR lpNew = StripQuotes(lpValue, '%');
                                if (lpNew)
                                {
                                    delete lpValue;
                                    lpValue = lpNew;
                                }
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;
                            }
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;
                        }
                        else if(pExpr->m_pConstValue->m_dwType == VT_NULL)
                            hr = WBEM_E_INVALID_QUERY;
                        else
                        {
                            lpValue = new wchar_t [20];
                            if (lpValue)
                                swprintf(lpValue, L"%ld", pExpr->m_pConstValue->m_Value.m_lValue);
                            else
                                hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    else
                    {
                        if (pExpr->m_pJoinColRef)
                        {
                            lpValue = GetColumnName(pExpr->m_pJoinColRef, pMapping, dwNumProps, &bQueriable,
                                pExpr->m_pIntrinsicFuncOnJoinColRef, pExpr->m_pRightFunction);
                            if (!bQueriable || ! lpValue)
                                hr = WBEM_E_INVALID_QUERY;
                        }
                    }

                    if (SUCCEEDED(hr))
                        swprintf(wSQL, L" %s %s %s ", lpColName, lpOp, lpValue);                    

                    sSQL += wSQL;

                    delete lpValue;
                    break;
                }                
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  GetClassFromNode
//
//***************************************************************************

HRESULT GetClassFromNode (SWQLNode *pNode, LPWSTR * lpClassName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR lpTableName = NULL;

    switch(pNode->m_dwNodeType)
    {
    case TYPE_SWQLNode_TableRefs:

        if (((SWQLNode_TableRefs *)pNode)->m_nSelectType == WQL_FLAG_COUNT)
            return WBEM_E_PROVIDER_NOT_CAPABLE;
        
        if (pNode->m_pRight != NULL)
        {
            if (pNode->m_pRight->m_pLeft->m_dwNodeType != TYPE_SWQLNode_TableRef)
                hr = WBEM_E_PROVIDER_NOT_CAPABLE;
            else
            {
                SWQLNode_TableRef *pRef = (SWQLNode_TableRef *)pNode->m_pRight->m_pLeft;
                lpTableName = pRef->m_pTableName;
            }
        }
        else
            return WBEM_E_INVALID_SYNTAX;

        break;
    case TYPE_SWQLNode_TableRef:
        
        if (pNode->m_dwNodeType != TYPE_SWQLNode_TableRef)
            hr = WBEM_E_INVALID_SYNTAX;
        else
            lpTableName = ((SWQLNode_TableRef *)pNode)->m_pTableName;
        
        break;
    default:
        return WBEM_E_NOT_SUPPORTED;
        break;
    }
           
    *lpClassName = lpTableName;

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::CustomFormatSQL
//
//***************************************************************************
HRESULT CWmiDbSession::CustomFormatSQL(IWmiDbHandle *pScope, IWbemQuery *pQuery, _bstr_t &sSQL, SQL_ID *dClassId,
                                       MappedProperties **ppMapping, DWORD *pwNumProps, BOOL *pCount)
{
    HRESULT hr = WBEM_S_NO_ERROR;
   
    MappedProperties *pProps = NULL;
    DWORD dwNumProps = 0;
    sSQL = "";
    BOOL bCount = FALSE;
    LPWSTR lpClassName = NULL;
    IWbemClassObject *pMapping = NULL;
    SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dObjectId;

    if (pQuery)
    {
        SWQLNode *pRoot = NULL, *pTop = NULL;
        pQuery->GetAnalysis(WMIQ_ANALYSIS_RESERVED, 0, (void **)&pTop);
        
        if (pTop && pTop->m_pLeft)
        {       
            pRoot = pTop->m_pLeft;

            if (pRoot->m_pRight != NULL)
            {
                if (pRoot->m_pRight->m_pRight != NULL)
                {
                    hr = WBEM_E_INVALID_QUERY;
                }
            }

            if (pRoot->m_pLeft != NULL)
            {
                if (((SWQLNode_TableRefs *)pRoot->m_pLeft)->m_nSelectType & WQL_FLAG_COUNT)
                    bCount = TRUE;

                hr = GetClassFromNode(pRoot->m_pLeft, &lpClassName);
            }           

            // Get the mapping information

            if (SUCCEEDED(hr))
            {
                CSQLConnection *pConn = NULL;
                hr = GetSQLCache()->GetConnection(&pConn);
                if (SUCCEEDED(hr))
                {
                    hr = CustomGetMapping(pConn, pScope, lpClassName, &pMapping);
                    CReleaseMe r2 (pMapping);
                    if (SUCCEEDED(hr))
                    {
                        BOOL bNeedWhere = TRUE;

                        hr = ConvertObjToStruct(pMapping, &pProps, &dwNumProps);
                        // CDeleteMe <wchar_t> d1 (pProps);  This is released by caller.
                        if (SUCCEEDED(hr))
                        {
                            VARIANT vTemp;
                            IWbemClassObject *pClassObj = NULL;
                            GetClassObject(pConn, *dClassId, &pClassObj);
                            CClearMe c (&vTemp);
                            hr = pClassObj->Get(L"__Derivation", 0, &vTemp, NULL, NULL);
                            SAFEARRAY *psaArray = V_ARRAY(&vTemp);
                            if (psaArray)
                            {
                                long lLBound, lUBound;
                                SafeArrayGetLBound(psaArray, 1, &lLBound);
                                SafeArrayGetUBound(psaArray, 1, &lUBound);

                                lUBound -= lLBound;
                                lUBound += 1;

                                for (int i = 0; i < lUBound; i++)
                                {
                                    IWbemClassObject *pMapping2 = NULL;
                                    VARIANT vT2;
                                    VariantInit(&vT2);
                                    LPWSTR lpValue = NULL;
                                    hr = GetVariantFromArray(psaArray, i, VT_BSTR, vT2);
                                    lpValue = GetStr(vT2);
                                    CDeleteMe <wchar_t> r (lpValue);
                                    VariantClear(&vT2);

                                    hr = CustomGetMapping(pConn, pScope, lpValue, &pMapping2);
                                    CReleaseMe r3 (pMapping2);
                                    if (SUCCEEDED(hr))
                                        hr = AddObjToStruct(pMapping2, &pProps, dwNumProps, &dwNumProps);
                                }                        
                            }
                            GetSQLCache()->ReleaseConnection(pConn, hr);

                            wchar_t wSQL[1024];
                            if (!bCount)
                                hr = GetSelectClause(wSQL, pProps, dwNumProps, pRoot->m_pLeft->m_pLeft);
                            else
                                wcscpy(wSQL, L"select count(*) __Count");

                            wchar_t wTemp[1024];
                            if (SUCCEEDED(hr))
                            {
                                hr = GetFromClause(wTemp, pMapping, pProps, dwNumProps);
                                if (SUCCEEDED(hr))
                                    wcscat(wSQL, wTemp);
                            }

                            if (SUCCEEDED(hr))
                                sSQL = wSQL;

                            // Now we parse the where clause.
                            if (pRoot->m_pRight && pRoot->m_pRight->m_pLeft)
                            {
                                _bstr_t sNewSQL;
                                hr = FormatWhereClause((SWQLNode_RelExpr *)pRoot->m_pRight->m_pLeft, sNewSQL, pProps, dwNumProps);
                                if (SUCCEEDED(hr) && wcslen(sNewSQL))
                                {
                                    sSQL += L" where ";                                    
                                    sSQL += sNewSQL;
                                }
                            }
                            if (pRoot->m_pRight && pRoot->m_pRight->m_pRight && pRoot->m_pRight->m_pRight->m_pRight)
                            {
                                SWQLNode_ColumnList *pList = (SWQLNode_ColumnList *)pRoot->m_pRight->m_pRight->m_pRight->m_pLeft;
                                _bstr_t sNewSQL;
                                hr = GetOrderByClause(pList, sNewSQL, pProps, dwNumProps);
                                if (SUCCEEDED(hr))
                                    sSQL += sNewSQL;
                            }
                        }
                    }
                }
            }
        }
        else 
            hr = WBEM_E_INVALID_QUERY;
    }
    else
        hr = WBEM_E_INVALID_QUERY;

    if (SUCCEEDED(hr))
    {
        if (pCount)
            *pCount = bCount;
        *ppMapping = pProps;
        *pwNumProps = dwNumProps;
    }
    else
        ClearPropArray(pProps, dwNumProps);

    return hr;
}

//***************************************************************************
//
//  CWmiCustomDbIterator::CWmiCustomDbIterator
//
//***************************************************************************

CWmiCustomDbIterator::CWmiCustomDbIterator()
{
    m_pStatus = NULL;
    m_pRowset = NULL;
    m_pSession = NULL;
    m_pIMalloc = NULL;
    m_pConn = NULL;
    m_uRefCount = 0;
    m_dwNumProps = 0;
    m_pPropMapping = NULL;
}

//***************************************************************************
//
//  CWmiCustomDbIterator::~CWmiCustomDbIterator
//
//***************************************************************************
CWmiCustomDbIterator::~CWmiCustomDbIterator()
{
    Cancel(0);
    if (m_pSession)
        m_pSession->Release();
    m_pSession = NULL;
    if (m_pIMalloc)
        m_pIMalloc->Release();
    m_pIMalloc = NULL;

    ClearPropArray(m_pPropMapping, m_dwNumProps);
}

//***************************************************************************
//
//  CWmiCustomDbIterator::QueryInterface
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiCustomDbIterator::QueryInterface
        (REFIID riid,
        void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = 0;

    if (IID_IUnknown==riid || IID_IWmiDbIterator==riid )
    {
        *ppvObject = (IWmiDbIterator *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//  CWmiCustomDbIterator::AddRef
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiCustomDbIterator::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//  CWmiCustomDbIterator::Release
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CWmiCustomDbIterator::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return WBEM_S_NO_ERROR;
}
//***************************************************************************
//
//  CWmiCustomDbIterator::Cancel
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiCustomDbIterator::Cancel( 
    /* [in] */ DWORD dwFlags) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = CSQLExecute::CancelQuery(m_pStatus);

    if (m_pStatus)
        m_pStatus->Release();
    m_pStatus = NULL;

    if (m_pConn)
    {
        ((CWmiDbController *)m_pSession->m_pController)->ConnCache.ReleaseConnection(m_pConn, hr);
        m_pConn = NULL;
    }

    if (m_pRowset)
        m_pRowset->Release();
    m_pRowset = NULL;

    return hr;
}

//***************************************************************************
//
//  CWmiCustomDbIterator::NextBatch
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiCustomDbIterator::NextBatch(  
        /* [in] */ DWORD dwNumRequested,
        /* [in] */ DWORD dwTimeOutSeconds,
        /* [in] */ DWORD dwFlags,
        /* [in] */ DWORD dwRequestedHandleType,
        /* [in] */ REFIID riid,
        /* [out] */ DWORD __RPC_FAR *pdwNumReturned,
        /* [iid_is][length_is][size_is][out] */ LPVOID __RPC_FAR *ppObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR, hrRet = WBEM_S_NO_ERROR;
    bool bImmediate = !(dwRequestedHandleType & WMIDB_HANDLE_TYPE_SUBSCOPED);

    if (!m_pStatus && !m_pRowset)
        return WBEM_S_NO_MORE_DATA;

    if (!m_pSession || !(m_pSession->m_pController) || 
        ((CWmiDbController *)m_pSession->m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (!dwNumRequested || !ppObjects)
        return WBEM_E_INVALID_PARAMETER;

    if (dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID)
        return WBEM_E_INVALID_PARAMETER;

    // FIXME: We need to create a readahead cache.
    
    if (dwFlags & WMIDB_FLAG_LOOKAHEAD || 
        (riid  != IID_IWmiDbHandle &&
         riid  != IID_IWbemClassObject &&
         riid  != IID__IWmiObject))
        /// UuidCompare(pIIDRequestedInterface, &IID_IWmiDbHandle, NULL) ||
        // UuidCompare(pIIDRequestedInterface, &IID_IWbemClassObject, NULL))
        return E_NOTIMPL;

    // For each ObjectId, do we instantiate a new handle,
    // and increment a background ref count on the object itself?
    // How do we keep track of the handles that are in use??

    try
    {
        HROW *pRow = NULL;
        VARIANT vTemp;
        VariantInit(&vTemp);
        int iNumRetrieved = 0;
        IRowset *pIRowset = NULL;
        IWbemClassObject *pClassObj = NULL;

        if (!m_bCount)
        {
            hr = ((CWmiDbController *)m_pSession->m_pController)->ObjectCache.GetObject(m_dClassId, &pClassObj);
            if (FAILED(hr))
                hr = m_pSession->GetClassObject(NULL, m_dClassId, &pClassObj);
        }
        else
        {
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                    IID_IWbemClassObject, (void **)&pClassObj);
            if (SUCCEEDED(hr))
            {
                VARIANT vTemp;
                VariantInit(&vTemp);
                vTemp.bstrVal = SysAllocString(L"__Generic");
                vTemp.vt = VT_BSTR;
                pClassObj->Put(L"__Class", 0, &vTemp, CIM_STRING);
                VariantClear(&vTemp);

                pClassObj->Put(L"Count", 0, NULL, CIM_UINT32);            
            }
        }

        CReleaseMe r (pClassObj);
        if (m_pStatus)
        {
            hr = CSQLExecute::IsDataReady(m_pStatus);
    
            // TO DO: Wait if we are pending.  Fail for now.

            if (SUCCEEDED(hr))
            {            
                hr = m_pStatus->QueryInterface(IID_IRowset, (void **)&pIRowset);
            }
        }
        else
            pIRowset = m_pRowset;

        if (SUCCEEDED(hr) && pIRowset)
        {
            // TO DO: Take the timeout value into consideration!!!
               
            while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA && iNumRetrieved < dwNumRequested)
            {

                if (!m_pSession || !(m_pSession->m_pController) || 
                    ((CWmiDbController *)m_pSession->m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
                {
                    hrRet = WBEM_E_SHUTTING_DOWN;
                    break;
                }

                IWbemClassObject *pNew = NULL;

                hr = pClassObj->SpawnInstance(0, &pNew);
                if (SUCCEEDED(hr))
                {
                    if (m_bCount)
                    {
                        VARIANT vTemp;
                        CClearMe c (&vTemp);

                        hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
                        pNew->Put(L"Count", 0, &vTemp, CIM_UINT32);
                    }
                    else
                    {
                        hr = ((CWmiDbSession *)m_pSession)->CustomSetProperties(m_pScope, pIRowset, m_pIMalloc, pClassObj, m_pPropMapping, m_dwNumProps, pNew);
                        if (FAILED(hr))
                            break;
                    }
                }
                else
                    break;
    
                // Generate the hash value from the key string.
                SQL_ID dID = 0;

                LPWSTR lpPath = GetPropertyVal(L"__RelPath", pNew);
                LPWSTR lpKey = GetKeyString(lpPath);
                CDeleteMe <wchar_t> d1 (lpPath), d2 (lpKey);
                dID = CRC64::GenerateHashValue(lpKey);
            
                hr = ((CWmiDbSession *)m_pSession)->VerifyObjectSecurity(NULL, dID, m_dClassId, m_dwScopeId, 0, WBEM_ENABLE);
                if (SUCCEEDED(hr))
                {
                    if (riid == IID_IWbemClassObject ||
                                riid == IID__IWmiObject)
                    {                    
                        ppObjects[iNumRetrieved] = pNew;
                    }
                    else
                    {
                        CWmiDbHandle *pTemp = new CWmiDbHandle;
                        if (pTemp)
                        {
                            DWORD dwVersion = 0;
                            // Obtain a lock for this object
                            // =============================  
                            pTemp->m_pSession = m_pSession;

                            hr = ((CWmiDbController *)m_pSession->m_pController)->LockCache.AddLock(bImmediate, dID, dwRequestedHandleType, pTemp, 
                                m_dwScopeId, m_dClassId, &((CWmiDbController *)m_pSession->m_pController)->SchemaCache, false,
                                0, 0, &dwVersion);

                            if (FAILED(hr))
                            {
                                delete pTemp;
                                // If they failed to get a handle, what do we do?
                                // Ignore it and continue, I guess.
                                hrRet = WBEM_S_PARTIAL_RESULTS;
                                ppObjects[iNumRetrieved] = NULL;
                    
                            }
                            else
                            {               
                                ((CWmiDbController *)m_pSession->m_pController)->AddHandle();
                                pTemp->AddRef();
                                pTemp->m_dwVersion = dwVersion;
                                pTemp->m_dwHandleType = dwRequestedHandleType;
                                pTemp->m_dClassId = m_dClassId;
                                pTemp->m_dObjectId = dID;
                                pTemp->m_pData = pNew;
                                pTemp->m_bDefault = FALSE;
                                pTemp->m_dScopeId = m_dwScopeId;                       
                                ppObjects[iNumRetrieved] = pTemp;
                            }
                        }
                        else
                        {
                            // *pQueryResult = NULL;  // What do we do here?  Cancel, I assume.
                            hrRet = WBEM_E_OUT_OF_MEMORY;
                            break;
                        }         
                    }
                
                    iNumRetrieved++;
                }
                else
                    hrRet = WBEM_S_PARTIAL_RESULTS;

                if (m_pSession && ((CWmiDbSession *)m_pSession)->m_pController)
                    ((CWmiDbController *)m_pSession->m_pController)->IncrementHitCount(false);

                VariantClear(&vTemp);

                hr = pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                delete pRow;
                pRow = NULL;
                if (m_bCount)
                {
                    hr = WBEM_S_NO_MORE_DATA;
                    break;
                }

                if (iNumRetrieved == dwNumRequested)
                    break;
                hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
            }
        }

        // Null out m_pStatus if there are no more results!!!
        if (hr == WBEM_S_NO_MORE_DATA)
        {
            hrRet = WBEM_S_NO_MORE_DATA;
            Cancel(0);
        }

        if (pdwNumReturned)
            *pdwNumReturned = iNumRetrieved;

    }
    catch (...)
    {
        hrRet = WBEM_E_CRITICAL_ERROR;
    }

    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\sqlbackup.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   sqlbackup.cpp
//
//   cvadai     21-June-2000        created.
//
//***************************************************************************
#include "precomp.h"
#include <std.h>
#include <repdrvr.h>

//***************************************************************************
//
//  CWmiDbSession::Backup
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Backup( 
    /* [in] */ LPCWSTR lpBackupPath,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr = E_NOTIMPL;

    // SQL Server uses backup devices, not directories.  The consumer is responsible for 
    // performing backups of their databases.

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::Restore
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Restore( 
    /* [in] */ LPCWSTR lpRestorePath,
    /* [in] */ LPCWSTR lpDestination,
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr = E_NOTIMPL;


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\wqllex.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>             

#define ST_STRING       27
#define ST_IDENT        32
#define ST_GE           38
#define ST_LE           40
#define ST_NE           43
#define ST_NUMERIC      45
#define ST_REAL         48
#define ST_STRING2      50
#define ST_STRING_ESC   55
#define ST_STRING2_ESC  58   
#define ST_DOT          61
#define ST_PROMPT       63
#define ST_PROMPT_END   69
#define ST_PROMPT_ESC   71

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  WQL_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  WQL_TOK_EQ,          GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, 0,  WQL_TOK_OPEN_BRACKET,  GLEX_ACCEPT,
/* 10 */  L']',   GLEX_EMPTY, 0,  WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,

/* 11 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 12 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 13 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 14 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 15 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 16 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 17 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 18 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME, // never

    // Whitespace, newlines, etc.
/* 19 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 20 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 21 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 22 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 23 */ 0,      GLEX_EMPTY, 0,  WQL_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 24 */ L',',   GLEX_EMPTY, 0,  WQL_TOK_COMMA, GLEX_ACCEPT,

    // Prompt user for constant
/* 25 */   L'#',     GLEX_EMPTY, ST_PROMPT,     0,           GLEX_CONSUME,

    // Unknown characters
/* 26 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 27 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT,
/* 29 */   L'"',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 30 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 31 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 32 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 37 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 38 */  L'=',   GLEX_EMPTY,  0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,  0,       WQL_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 40 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 41 */  L'>',   GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 42 */  GLEX_ANY, GLEX_EMPTY,    0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 43 */  L'=',   GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 44 */  GLEX_ANY,  GLEX_EMPTY,   0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 45 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 46 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 47 */  GLEX_ANY, GLEX_EMPTY, 0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 48 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 49 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 50 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT,
/* 52 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 53 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 55 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 56 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 57 */   GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 58 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 61 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 62 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,

// ST_PROMPT
/* 63 */   L'\n',    GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT|GLEX_LINEFEED,
/* 64 */   L'\r',    GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,
/* 65 */   L'\\',    GLEX_EMPTY, ST_PROMPT_ESC, 0,           GLEX_CONSUME,
/* 66 */   L'#',     GLEX_EMPTY, ST_PROMPT_END, 0,           GLEX_ACCEPT,
/* 67 */   0,        GLEX_EMPTY,    0,      WQL_TOK_ERROR,   GLEX_PUSHBACK|GLEX_RETURN, // Note forced return
/* 68 */   GLEX_ANY, GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,

// ST_PROMPT_END
/* 69 */   L'#',     GLEX_EMPTY,    0,      WQL_TOK_PROMPT,  GLEX_CONSUME,
/* 70 */  GLEX_ANY,  GLEX_EMPTY, ST_PROMPT,     0,           GLEX_PUSHBACK,

// ST_PROMPT_ESC
/* 71 */   L'#',     GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,
/* 72 */   L'\\',    GLEX_EMPTY, ST_PROMPT,     0,           GLEX_ACCEPT,
/* 73 */   GLEX_ANY, GLEX_EMPTY,    0,      WQL_TOK_ERROR,   GLEX_PUSHBACK|GLEX_RETURN,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51conv.h ===
#ifndef __A51_CONVERTER__H_
#define __A51_CONVERTER__H_

long ConvertA51ToRoswell();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\repdrvr\sql\sqlprocs.cpp ===
//***************************************************************************
//
//   (c) 1999-2001 by Microsoft Corp. All Rights Reserved.
//
//   SQLPROCS.cpp
//
//   cvadai     6-May-1999      created.
//
//***************************************************************************

#define _SQL_PROCS_CPP_
#pragma warning( disable : 4786 ) // identifier was truncated to 'number' characters in the 
#pragma warning( disable : 4251 ) //  needs to have dll-interface to be used by clients of class
#include "precomp.h"

#define DBINITCONSTANTS

#include <std.h>
#include <sqlutils.h>
#include <sqlexec.h>
#include <crepdrvr.h>
#include <sqloledb.h>
#include <repdrvr.h>
#include <wbemint.h>
#include <math.h>
#include <objbase.h>
#include <resource.h>
#include <reputils.h>
#include <sqlcache.h>
#include <arena.h>
#include <crc64.h>
#include <smrtptr.h>
#include <sqlit.h>

#if defined _WIN64
#define ULONG unsigned __int64
#define LONG __int64
#endif

BSTR OLEDBTruncateLongText(const wchar_t *pszData, long lMaxLen, bool &bChg, 
                            int iTruncLen=REPDRVR_MAX_LONG_STRING_SIZE, BOOL bAppend=TRUE)
{
    BSTR sRet = NULL;
    bChg = false;
    if (!pszData)
        return SysAllocString(L"");

    long lLen = wcslen(pszData);
    if (lLen <= lMaxLen)
        return SysAllocString(pszData);

    wchar_t *wTemp = new wchar_t [iTruncLen+1];
    if (wTemp)
    {
        if (bAppend)
        {
            wcsncpy(wTemp, pszData, iTruncLen-3);
	        wTemp[iTruncLen-3] = L'\0';
	        wcscat(wTemp, L"...\0");
        }
        else
        {
            wcsncpy(wTemp, pszData, iTruncLen);
            wTemp[iTruncLen] = L'\0';
        }
    
        bChg = true;
        sRet = SysAllocString(wTemp);
        delete wTemp;
    }

    return sRet;
}



//***************************************************************************
//
//  CWmiDbController::GetLogonTemplate
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbController::GetLogonTemplate( 
    /* [in] */ LCID lLocale,
    /* [in] */ DWORD dwFlags,
    /* [out] */ WMIDB_LOGON_TEMPLATE __RPC_FAR *__RPC_FAR *ppTemplate) 
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (dwFlags != 0 || !ppTemplate)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        if (!m_pIMalloc)
        {
            hr = CoGetMalloc(MEMCTX_TASK, &m_pIMalloc);
            if (FAILED(hr))
                return hr;
        }

        if (ppTemplate)
        {
            WMIDB_LOGON_TEMPLATE *pTemp = new WMIDB_LOGON_TEMPLATE;
            if (!pTemp)
                return WBEM_E_OUT_OF_MEMORY;

            pTemp->dwArraySize = 5;
        
            if (pTemp)
            {
                HINSTANCE hRCDll = GetResourceDll(lLocale);
                if (!hRCDll)
                {
                    LCID lTemp = GetUserDefaultLangID();
                    hRCDll = GetResourceDll(lTemp);
                    if (!hRCDll)
                    {
                        lTemp = GetSystemDefaultLangID();
                        hRCDll = GetResourceDll(lTemp);
                        if (!hRCDll)
                            hRCDll = LoadLibrary(L"reprc.dll"); // Last resort - try the current directory.
                    }
                }

                wchar_t wDB[101], wUser[101], wPwd[101], wLocale[101], wServer[101];
                pTemp->pParm = new WMIDB_LOGON_PARAMETER[5];
                if (!pTemp->pParm)
                {
                    delete pTemp;
                    return WBEM_E_OUT_OF_MEMORY;
                }

                if (hRCDll)
                {           
                    LoadString(hRCDll, IDS_WMI_DATABASE, wDB, 100);
                    LoadString(hRCDll, IDS_WMI_USER_NAME, wUser, 100);
                    LoadString(hRCDll, IDS_WMI_PASSWORD, wPwd, 100);
                    LoadString(hRCDll, IDS_WMI_LOCALE, wLocale, 100);
                    LoadString(hRCDll, IDS_WMI_SERVER, wServer, 100);
                    FreeLibrary(hRCDll);
                }
                else
                {
                    wcscpy(wDB, L"Database");
                    wcscpy(wUser, L"UserID");
                    wcscpy(wPwd, L"Password");
                    wcscpy(wLocale, L"Locale");
                    wcscpy(wServer, L"Server");
                }
        
                pTemp->pParm[0].dwId = DBPROP_INIT_DATASOURCE;
                pTemp->pParm[0].strParmDisplayName = SysAllocString(wServer);
                VariantInit(&(pTemp->pParm[0].Value));

                pTemp->pParm[1].dwId = DBPROP_AUTH_USERID;
                pTemp->pParm[1].strParmDisplayName = SysAllocString(wUser);
                VariantInit(&(pTemp->pParm[1].Value));

                pTemp->pParm[2].dwId = DBPROP_AUTH_PASSWORD;
                pTemp->pParm[2].strParmDisplayName = SysAllocString(wPwd);
                VariantInit(&(pTemp->pParm[2].Value));

                pTemp->pParm[3].dwId = DBPROP_INIT_LOCATION;
                pTemp->pParm[3].strParmDisplayName = SysAllocString(wDB);
                VariantInit(&(pTemp->pParm[3].Value));

                pTemp->pParm[4].dwId = DBPROP_INIT_LCID;
                pTemp->pParm[4].strParmDisplayName = SysAllocString(wLocale);
                VariantInit(&(pTemp->pParm[4].Value));
                pTemp->pParm[4].Value.lVal = lLocale;
                pTemp->pParm[4].Value.vt = VT_I4;

                *ppTemplate = pTemp;            
            }          
            else
                hr = WBEM_E_OUT_OF_MEMORY;
            
        }
        else
            hr = WBEM_E_INVALID_PARAMETER;
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbController::GetLogonTemplate"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::InsertArray
//
//***************************************************************************

HRESULT CWmiDbSession::InsertArray(CSQLConnection *pConn,IWmiDbHandle *pScope, 
                                           SQL_ID dObjectId, SQL_ID dClassId, 
                                           DWORD dwPropertyID, VARIANT &vValue, long lFlavor, DWORD dwRefID,
                                           LPCWSTR lpObjectKey , LPCWSTR lpPath , SQL_ID dScope, CIMTYPE ct )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IRowset *pIRowset = NULL;
    DWORD dwRows = 0;
    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();

    if (vValue.vt == VT_UNKNOWN)
    {
        BYTE *pBuff = NULL;
        DWORD dwLen = 0;
        IUnknown *pUnk = V_UNKNOWN (&vValue);
        if (pUnk)
        {
            _IWmiObject *pInt = NULL;
            hr = pUnk->QueryInterface(IID__IWmiObject, (void **)&pInt);
            if (SUCCEEDED(hr))
            {
                pInt->GetObjectMemory(NULL, 0, &dwLen);
                pBuff = new BYTE [dwLen];
                if (pBuff)
                {
                    DWORD dwLen1;
                    pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                    hr = CSQLExecProcedure::InsertBlobData (pConn, dClassId, dObjectId, 
                                               dwPropertyID, NULL, 0, 0);
                    wchar_t wSQL[1024];
                    swprintf(wSQL, L"select PropertyImageValue from ClassImages where ObjectId = %I64d and PropertyId = %ld",
                                    dObjectId, dwPropertyID);
       
                    hr = CSQLExecute::WriteImageValue(pCmd, wSQL, 1, pBuff, dwLen);

                    delete pBuff;
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
                pInt->Release();
            }                               
        }
    }
    else if (((vValue.vt & 0xFFF) == VT_UI1) || vValue.vt == VT_BSTR)
    {
        BYTE *pBuff = NULL;
        DWORD dwLen = 0;

        // Get the byte buffer out of the safearray.
    
        if ((vValue.vt & 0xFFF) == VT_UI1)
            GetByteBuffer(&vValue, &pBuff, dwLen);
        else // its a bstr.
        {
            dwLen = wcslen(vValue.bstrVal)*2;
            char * pTemp = new char[dwLen+1];
            if (pTemp)
            {
                sprintf(pTemp, "%S", vValue.bstrVal);
                pBuff = (unsigned char *)pTemp;
            }
        }

        if (pBuff)
        {                      
            hr = CSQLExecProcedure::InsertBlobData (pConn, dClassId, dObjectId, 
                                               dwPropertyID, NULL, 0, 0);
            wchar_t wSQL[1024];
            swprintf(wSQL, L"select PropertyImageValue from ClassImages where ObjectId = %I64d and PropertyId = %ld",
                            dObjectId, dwPropertyID);

            hr = CSQLExecute::WriteImageValue(pCmd, wSQL, 1, pBuff, dwLen);
            delete pBuff;
        }
    }
    else
    {
        bool bIsQfr = FALSE;
        DWORD dwFlags = 0;
        SQL_ID dClassID = 0;
        DWORD dwStorage = 0;

        hr = GetSchemaCache()->GetPropertyInfo (dwPropertyID, NULL, &dClassID, &dwStorage,
            NULL, &dwFlags);

        bIsQfr = (dwFlags & REPDRVR_FLAG_QUALIFIER) ? TRUE : FALSE;        

        SAFEARRAY* psaArray = NULL;
        psaArray = V_ARRAY(&vValue);
        if (psaArray)
        {
            long i = 0;
            int iType = vValue.vt & 0xFF;

            VARIANT vTemp;
            VariantInit(&vTemp);

            long lLBound, lUBound;
            SafeArrayGetLBound(psaArray, 1, &lLBound);
            SafeArrayGetUBound(psaArray, 1, &lUBound);
    
            lUBound -= lLBound;
            lUBound += 1;

            InsertQfrValues *pQfr = NULL;
            pQfr = new InsertQfrValues[lUBound];
            if (!pQfr)
                return WBEM_E_OUT_OF_MEMORY;

            int iPos = 0;

            for (i = 0; i < lUBound; i++)
            {
                if (iType != CIM_OBJECT)
                {
                    if (iType != VT_NULL && iType != VT_EMPTY)
                    {
                        hr = GetVariantFromArray(psaArray, i, iType, vTemp);
                        LPWSTR lpVal = GetStr(vTemp);
                        CDeleteMe <wchar_t> r1(lpVal);

                        VariantClear(&vTemp);
                        if (FAILED(hr))
                            break;

                        //if (wcslen(lpVal))
                        {
                            pQfr[iPos].iPos = i;
                            pQfr[iPos].iQfrID = dwRefID;
                            pQfr[iPos].iPropID = dwPropertyID;
                            pQfr[iPos].pRefKey = NULL;
                            pQfr[iPos].bLong = false;
                            pQfr[iPos].bIndexed = (dwFlags & (REPDRVR_FLAG_KEY + REPDRVR_FLAG_INDEXED)) ? TRUE : FALSE;
                            pQfr[iPos].iStorageType = dwStorage;
                            pQfr[iPos].dClassId = dClassID;
                            pQfr[iPos].iFlavor = lFlavor;

                            if (ct == CIM_REFERENCE)
                            {
                                pQfr[iPos].bIndexed = TRUE; // References are always keys

                                LPWSTR lpTemp = NULL;
                                IWbemPath *pPath = NULL;

                                hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemPath, (LPVOID *) &pPath);
                                CReleaseMe r8 (pPath);
                                if (SUCCEEDED(hr))
                                {
                                    if (lpVal)
                                    {
                                        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, lpVal);

                                        hr = NormalizeObjectPathGet(pScope, pPath, &lpTemp, NULL, NULL, NULL, pConn);
                                        CDeleteMe <wchar_t> r1(lpTemp);
                                        if (SUCCEEDED(hr)) 
                                        {
                                            LPWSTR lpTemp2 = NULL;
                                            lpTemp2 = GetKeyString(lpVal);
                                            CDeleteMe <wchar_t> d (lpTemp2);
                                            pQfr[iPos].pRefKey = new wchar_t [21];
                                            if (pQfr[iPos].pRefKey)
                                                swprintf(pQfr[iPos].pRefKey, L"%I64d", CRC64::GenerateHashValue(lpTemp2));
                                            else
                                                hr = WBEM_E_OUT_OF_MEMORY;
                                        }
                                        else
                                        {
                                            hr = WBEM_S_NO_ERROR;
                                            // Strip off the root namespace prefix and generate the
                                            // pseudo-name.  We have no way of knowing if they entered this
                                            // path correctly.

                                            LPWSTR lpTemp3 = StripUnresolvedName (lpVal);
                                            CDeleteMe <wchar_t> d2 (lpTemp3);

                                            LPWSTR lpTemp2 = NULL;
                                            lpTemp2 = GetKeyString(lpTemp3);
                                            CDeleteMe <wchar_t> d (lpTemp2);
                                            pQfr[iPos].pRefKey = new wchar_t [21];
                                            if (pQfr[iPos].pRefKey)
                                                swprintf(pQfr[iPos].pRefKey, L"%I64d", CRC64::GenerateHashValue(lpTemp2));
                                            else
                                                hr = WBEM_E_OUT_OF_MEMORY;
                                        }

                                        pQfr[iPos].pValue = new wchar_t[wcslen(lpVal)+1];
                                        if (pQfr[iPos].pValue)
                                            wcscpy(pQfr[iPos].pValue,lpVal);
                                        else
                                            hr = WBEM_E_OUT_OF_MEMORY;
                                    }
                                    else
                                        pQfr[iPos].pValue = NULL;                                                                        
                                }                    
                                else 
                                    break;
                            }
                            else
                            {
                                if (lpVal)
                                {
                                    pQfr[iPos].pValue = new wchar_t[wcslen(lpVal)+1];
                                    if (pQfr[iPos].pValue)
                                        wcscpy(pQfr[iPos].pValue,lpVal);
                                    else
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                }
                                else
                                    pQfr[iPos].pValue = NULL;

                                pQfr[iPos].pRefKey = NULL;                    
                            }
                            iPos++;
                        }
                    }
                }
                else
                {
                    if (lpPath)
                    {
                        hr = GetVariantFromArray(psaArray, i, iType, vTemp);
                        IUnknown *pTemp = V_UNKNOWN(&vTemp);
                        if (pTemp)
                        {
                            BYTE *pBuff = NULL;
                            DWORD dwLen;
                            _IWmiObject *pInt = NULL;
                            hr = pTemp->QueryInterface(IID__IWmiObject, (void **)&pInt);
                            if (SUCCEEDED(hr))
                            {
                                pInt->GetObjectMemory(NULL, 0, &dwLen);
                                pBuff = new BYTE [dwLen];
                                if (pBuff)
                                {
                                    CDeleteMe <BYTE> d (pBuff);
                                    DWORD dwLen1;
                                    hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = CSQLExecProcedure::InsertBlobData (pConn, dClassId, dObjectId, 
                                                                           dwPropertyID, NULL, i, 0);
                                        wchar_t wSQL[1024];
                                        swprintf(wSQL, L"select PropertyImageValue from ClassImages where ObjectId = %I64d and PropertyId = %ld"
                                                       L" and ArrayPos = %ld",
                                                        dObjectId, dwPropertyID, i);

                                        hr = CSQLExecute::WriteImageValue(pCmd, wSQL, 1, pBuff, dwLen);
                                    }
                                }
                                else
                                    hr = WBEM_E_OUT_OF_MEMORY;

                                pInt->Release();
                            }
                            else
                                break;
                        }                        
                    }
                }
            }
            if (SUCCEEDED(hr))
                hr = CSQLExecProcedure::InsertBatch (pConn, dObjectId, 0, 0, pQfr, iPos);

            // Finally clean up the upper array bounds 
            // (if this array used to be bigger...)
            // ====================================

            if (SUCCEEDED(hr))
            {
                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), L"delete from ClassData where ObjectId = %I64d and PropertyId = %ld and "
                       L" QfrPos = %ld and ArrayPos >= %ld", NULL, NULL, dObjectId, dwPropertyID, dwRefID, i);
            }
            delete pQfr;
        }           
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::Enumerate
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CWmiDbSession::Enumerate( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwRequestedHandleType,
    /* [out] */ IWmiDbIterator __RPC_FAR *__RPC_FAR *ppQueryResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwRequestedHandleType == WMIDB_HANDLE_TYPE_INVALID || !pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwRequestedHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED &~WMIDB_HANDLE_TYPE_CONTAINER
            &~ WMIDB_HANDLE_TYPE_SCOPE)
            return WBEM_E_INVALID_PARAMETER;

    try
    {
        if (!((CWmiDbController *)m_pController)->m_bCacheInit)
        {
            hr = LoadSchemaCache();
            if (SUCCEEDED(hr))
                ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
            else
                return hr;
        }

        MappedProperties *pProps;
        DWORD dwNumProps;
        BOOL bHierarchy = FALSE;

        SQL_ID dwNsId = 0, dClassId = 0;
        _bstr_t sPath;
        int iNumRows = 0;
        IWbemClassObject *pTemp = NULL;

        if (pScope)
        {
            dwNsId = ((CWmiDbHandle *)pScope)->m_dObjectId;
            dClassId = ((CWmiDbHandle *)pScope)->m_dClassId;
            // CVADAI: This is a container, not a scope: parent scopes not cached
		    // hr = VerifyObjectSecurity(dwNsId, 0, 0, 0, WBEM_ENABLE);
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwRows;
            IRowset *pRowset = NULL;
            CSQLConnection *pConn = NULL;

            hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());

            if (SUCCEEDED(hr))
            {
                wchar_t sSQL [1024];
                DWORD dwHandleType = ((CWmiDbHandle *)pScope)->m_dwHandleType;

                if (dClassId == INSTANCESCLASSID)
                {
                    SQL_ID dScopeId = ((CWmiDbHandle *)pScope)->m_dScopeId;
                    swprintf(sSQL, L"select ObjectId, ClassId, ObjectScopeId "
                                   L" from ObjectMap where ClassId = %I64d"
                                   L" and ObjectScopeId = %I64d",
                                   dwNsId, dScopeId);

                }
                else if (dwHandleType & WMIDB_HANDLE_TYPE_CONTAINER)
                {
                    DWORD dwContainerId = 0, dwContaineeId = 0;

                    swprintf(sSQL, L"select ObjectId, ClassId, ObjectScopeId from ObjectMap as o "
                                   L" inner join ContainerObjs as c on c.ContaineeId = o.ObjectId "
                                   L" and c.ContainerId = %I64d",
                         ((CWmiDbHandle *)pScope)->m_dObjectId);
                }
                // Scope
                else
                {
                    swprintf(sSQL, L"select ObjectId, ClassId, ObjectScopeId "
                                   L" from ObjectMap where ObjectScopeId = %I64d ",
                                   dwNsId);
                }

                if (SUCCEEDED(hr))
                {
                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), sSQL, &pRowset, &dwRows);
                    if (SUCCEEDED(hr))
                    {   
                        CWmiDbIterator *pNew = new CWmiDbIterator;
                        if (pNew)
                        {
                            *ppQueryResult = (IWmiDbIterator *)pNew;
                            pNew->m_pRowset = pRowset;

                            pNew->m_pConn = pConn;  // Releasing the iterator will release this guy.
                            pNew->m_pSession = this;
                            pNew->m_pIMalloc = m_pIMalloc;
                            pNew->AddRef();
                            AddRef();
                        }
                        else
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else if (pRowset)
                        pRowset->Release();
                }
            }
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::Enumerate"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}
//***************************************************************************
//
//  CWmiDbSession::ExecQuery
//
//***************************************************************************
HRESULT STDMETHODCALLTYPE CWmiDbSession::ExecQuery( 
    /* [in] */ IWmiDbHandle __RPC_FAR *pScope,
    /* [in] */ IWbemQuery __RPC_FAR *pQuery,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwHandleType,
    /* [out] */ DWORD *pMessageFlags,
    /* [out] */ IWmiDbIterator __RPC_FAR *__RPC_FAR *pQueryResult)
{
    HRESULT hr = WBEM_S_NO_ERROR;    

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    if (dwHandleType == WMIDB_HANDLE_TYPE_INVALID || !pQuery || !pQueryResult || !pScope)
        return WBEM_E_INVALID_PARAMETER;

    if (dwFlags & ~WMIDB_FLAG_QUERY_DEEP &~WMIDB_FLAG_QUERY_SHALLOW & ~WBEM_FLAG_USE_SECURITY_DESCRIPTOR)
        return WBEM_E_INVALID_PARAMETER;

    if (dwHandleType & ~WMIDB_HANDLE_TYPE_COOKIE 
            &~WMIDB_HANDLE_TYPE_VERSIONED &~WMIDB_HANDLE_TYPE_PROTECTED
            &~WMIDB_HANDLE_TYPE_EXCLUSIVE &~ WMIDB_HANDLE_TYPE_WEAK_CACHE
            &~WMIDB_HANDLE_TYPE_STRONG_CACHE &~ WMIDB_HANDLE_TYPE_NO_CACHE
            &~WMIDB_HANDLE_TYPE_SUBSCOPED &~ WMIDB_HANDLE_TYPE_SCOPE &~ WMIDB_HANDLE_TYPE_CONTAINER)
            return WBEM_E_INVALID_PARAMETER;

    if (pMessageFlags)
        *pMessageFlags = WBEM_REQUIREMENTS_STOP_POSTFILTER;

    try
    {
        if (!((CWmiDbController *)m_pController)->m_bCacheInit)
        {
            hr = LoadSchemaCache();
            if (SUCCEEDED(hr))
                ((CWmiDbController *)m_pController)->m_bCacheInit = TRUE;
            else
                return hr;
        }

        // ExecQuery needs to call into the custom repository code
        // if the scope is marked custom, and the query is not
        // against instances of system classes.
   

        // TO DO: We should allow cross-namespace
        // queries at some point, such as "select * from __Namespace"
        // Ignoring for now.

        MappedProperties *pProps;
        DWORD dwNumProps;
        BOOL bHierarchy = FALSE;
        SQL_ID dClassId = 0;
        BOOL bDeleteQuery = FALSE;
        BOOL bCountQuery = FALSE;
        BOOL bDefaultIt = FALSE;

        if (!pQuery)
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
        else
        {
            _bstr_t sSQL;
            CSQLBuilder bldr(&((CWmiDbController *)m_pController)->SchemaCache);
            SQL_ID dwNsId = 0;
            _bstr_t sPath;
            int iNumRows = 0;
            IWbemClassObject *pTemp = NULL;
            DWORD dwScopeType = ((CWmiDbHandle *)pScope)->m_dwHandleType ;

            if (pScope && !(dwScopeType & WMIDB_HANDLE_TYPE_CONTAINER))
		    {           
                dwNsId = ((CWmiDbHandle *)pScope)->m_dObjectId;
			    hr=VerifyObjectSecurity (NULL, pScope, WBEM_ENABLE);
		    }

            if (SUCCEEDED(hr))
            {

                SWbemAssocQueryInf *pNode = NULL;
                hr = pQuery->GetAnalysis(WMIQ_ANALYSIS_ASSOC_QUERY,
                            0, (void **)&pNode);
                if (FAILED(hr))
                {                                        
                    hr = bldr.FormatSQL(((CWmiDbHandle *)pScope)->m_dObjectId, ((CWmiDbHandle *)pScope)->m_dClassId,
                        ((CWmiDbHandle *)pScope)->m_dScopeId, pQuery, sSQL, dwFlags, 
                        ((CWmiDbHandle *)pScope)->m_dwHandleType, &dClassId, &bHierarchy, TRUE, &bDeleteQuery,
                        &bDefaultIt);                

                    // Special handling for non-meta-schema queries in 
                    // the custom mapped namespace.

                    if (((CWmiDbHandle *)pScope)->m_bDefault)
                        bDefaultIt = TRUE;                        

                    if (!bDefaultIt)
                    {
                        SWQLNode *pTop = NULL;
                        pQuery->GetAnalysis(WMIQ_ANALYSIS_RESERVED, 0, (void **)&pTop);
                        if (pTop)
                        {
                            if (pTop->m_pLeft != NULL)
                            {
                                if (pTop->m_pLeft->m_dwNodeType == TYPE_SWQLNode_Delete)
                                    bDeleteQuery = TRUE;
                            }
                        }
                        
                        hr = CustomFormatSQL(pScope, pQuery, sSQL, &dClassId, &pProps, &dwNumProps, &bCountQuery);
                    
                    }

                    if (hr == WBEM_E_PROVIDER_NOT_CAPABLE)
                    {
                        if (pMessageFlags)
                        {
                            *pMessageFlags = WBEM_REQUIREMENTS_START_POSTFILTER;
                            hr = WBEM_S_NO_ERROR;
                        }
                    }
                
                    // Make sure we have access to the target class.
                    // We won't check locks at this point, since that will 
                    // be the iterator's job.

                    if (SUCCEEDED(hr))
				    {
					    hr=VerifyClassSecurity (NULL, dClassId, WBEM_ENABLE);
				    }
                }
                else
                {
                    if (!((CWmiDbHandle *)pScope)->m_bDefault)
                    {
                        hr = WBEM_E_INVALID_QUERY;
                    }
                    else
                    {
                        bDefaultIt = TRUE;
                        SQL_ID dObjId = 0;
                        // Get dObjId.

                        IWbemPath *pPath = NULL;
                        hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                                IID_IWbemPath, (LPVOID *) &pPath);

                        CReleaseMe r8 (pPath);
                        if (SUCCEEDED(hr))
                        {
                            pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pNode->m_pszPath);
                            IWmiDbHandle *pTemp = NULL;

                            // WARNING: This fails if pScope is a container.
                            // We need to get the parent scope, or 
                            // use the absolute path
                            // We aren't supporting this scenario
                        
                            hr = GetObject(pScope, pPath, dwFlags, WMIDB_HANDLE_TYPE_COOKIE, &pTemp);
                            CReleaseMe r1 (pTemp);
                            if (SUCCEEDED(hr))
                            {
                                BOOL bIsClass = FALSE;
                                if (((CWmiDbHandle *)pTemp)->m_dClassId == 1)
                                    bIsClass = TRUE;

                                SQL_ID dAssocClassId = 0, dResultClassId = 0;
                                dObjId = ((CWmiDbHandle *)pTemp)->m_dObjectId;     
                                
                                hr = bldr.FormatSQL(((CWmiDbHandle *)pScope)->m_dObjectId, 
                                                    ((CWmiDbHandle *)pScope)->m_dClassId,
                                                    ((CWmiDbHandle *)pScope)->m_dScopeId, 
                                                    dObjId, 
                                                    pNode->m_pszResultClass, 
                                                    pNode->m_pszAssocClass, 
                                                    pNode->m_pszRole, 
                                                    pNode->m_pszResultRole, 
                                                    pNode->m_pszRequiredQualifier, 
                                                    pNode->m_pszRequiredAssocQualifier, 
                                                    pNode->m_uFeatureMask, sSQL, 
                                                    dwFlags, ((CWmiDbHandle *)pScope)->m_dwHandleType, 
                                                    &dAssocClassId, &dResultClassId, bIsClass);
                                if (SUCCEEDED(hr))
                                {
                                    if (pMessageFlags)
                                    {
                                        if (bIsClass ||
                                            pNode->m_pszRequiredQualifier ||
                                            pNode->m_pszRequiredAssocQualifier)
                                        {
                                            *pMessageFlags = WBEM_REQUIREMENTS_START_POSTFILTER;
                                            hr = WBEM_S_NO_ERROR;
                                        }
                                    }

                                    // Make sure we have read access on all these classes.
									hr=VerifyClassSecurity (NULL, dObjId, WBEM_ENABLE);
                                    if (SUCCEEDED(hr) && dAssocClassId)
									{
										hr=VerifyClassSecurity (NULL, dAssocClassId, WBEM_ENABLE);
									}
									if (SUCCEEDED(hr) && dResultClassId)
									{
										hr=VerifyClassSecurity(NULL, dResultClassId, WBEM_ENABLE);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                DWORD dwRows;
                IRowset *pRowset = NULL;
                CSQLConnection *pConn = NULL;

                hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());

                if (SUCCEEDED(hr))
                {
                    if (bHierarchy && SUCCEEDED(hr))                   
                        hr = CSQLExecProcedure::GetHierarchy(pConn, dClassId);

                    if (SUCCEEDED(hr) && dwFlags & WMIDB_FLAG_QUERY_DEEP)
                        hr = CSQLExecProcedure::EnumerateSubScopes(pConn, dwNsId);

                    if (!bDefaultIt)
                    {
                        IWbemClassObject *pObj = NULL;
                        hr = GetClassObject(pConn, dClassId, &pObj);
                        if (SUCCEEDED(hr))
                        {
                            hr = GetObjectCache()->PutObject(dClassId, 1, 
                                ((CWmiDbHandle *)pScope)->m_dObjectId, L"", 1, pObj);
                            pObj->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), sSQL, &pRowset, &dwRows);
                        if (SUCCEEDED(hr))
                        {   
                            if (bDefaultIt)
                            {
                                CWmiDbIterator *pNew = new CWmiDbIterator;
                                if (pNew)
                                {
                                    pNew->m_pRowset = pRowset;

                                    pNew->m_pConn = pConn;  // Releasing the iterator will release this guy.
                                    pNew->m_pSession = this;
                                    pNew->m_pIMalloc = m_pIMalloc;
                                    pNew->AddRef();
                                    AddRef();

                                    // If this is a delete query, we need to
                                    // stuff the results back into the DeleteObject
                                    // call, to keep ESS happy.

                                    if (bDeleteQuery)
                                    {
                                        hr = DeleteRows(pScope, pNew, IID_IWmiDbHandle);
                                        pNew->Release();
                                        *pQueryResult = NULL;
                                    }

                                    // select query. Give them the iterator

                                    else if (pQueryResult)
                                    {
                                        *pQueryResult = (IWmiDbIterator *)pNew;                        
                                    }


                                }
                                else
                                {
                                    pRowset->Release();
                                    hr = WBEM_E_OUT_OF_MEMORY;
                                    GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
                                }
                            }
                            else
                            {
                                // We need to create a custom iterator

                                CWmiCustomDbIterator *pNew = new CWmiCustomDbIterator;
                                if (pNew)
                                {
                                    pNew->m_pRowset = pRowset;

                                    pNew->m_pConn = pConn;  // Releasing the iterator will release this guy.
                                    pNew->m_pSession = this;
                                    pNew->m_pIMalloc = m_pIMalloc;
                                    pNew->m_pPropMapping = pProps;
                                    pNew->m_dwNumProps = dwNumProps;
                                    pNew->m_dwScopeId = dwNsId;
                                    pNew->m_pScope = pScope;
                                    pNew->m_dClassId = dClassId;
                                    pNew->m_bCount = bCountQuery;

                                    pNew->AddRef();
                                    AddRef();

                                    if (bDeleteQuery)
                                    {
                                        hr = DeleteRows(pScope, pNew, IID_IWbemClassObject);
                                        pNew->Release();
                                        *pQueryResult = NULL;
                                    }

                                    // select query. Give them the iterator

                                    else if (pQueryResult)
                                    {
                                        *pQueryResult = (IWmiDbIterator *)pNew;                        
                                    }

                                }

                            }
                        }
                        else if (pRowset)
                            pRowset->Release();
                    }
                }
            }
        }
    }
    catch (...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Fatal error in CWmiDbSession::ExecQuery"));
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::Delete
//
//***************************************************************************

HRESULT CWmiDbSession::Delete(IWmiDbHandle *pHandle, CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IRowset *pIRowset = NULL;
    DWORD dwNumRows = 0;
    CWmiDbHandle *pTmp = (CWmiDbHandle *)pHandle;
    bool bLocalTrans = false;

    if (!m_pController ||
        ((CWmiDbController *)m_pController)->m_dwCurrentStatus == WBEM_E_SHUTTING_DOWN)
        return WBEM_E_SHUTTING_DOWN;

    SQL_ID dID = pTmp->m_dObjectId;
    SQL_ID dClassID = pTmp->m_dClassId;

    hr = VerifyObjectLock(dID, pTmp->m_dwHandleType, pTmp->m_dwVersion);    
    if (FAILED(hr) && IsDistributed())
    {
        if (LockExists(dID))
            hr = WBEM_S_NO_ERROR;
    }
       
    if (SUCCEEDED(hr))
    {      
        if (!pConn)
        {
            bLocalTrans = true;
            hr = GetSQLCache()->GetConnection(&pConn, TRUE, IsDistributed());
            if (FAILED(hr))
                return hr;
        }

        if (SUCCEEDED(hr))
        {
            SQLIDs ObjIds, ClassIds, ScopeIds;

            // Was this a class or an instance?
            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), L"exec pDelete %I64d", &pIRowset, &dwNumRows, dID);
            CReleaseMe r (pIRowset);

            VARIANT vTemp;
            CClearMe c (&vTemp);
            HROW *pRow = NULL;
            SQL_ID dObjectId = 0, dClassId = 0, dScopeId = 0;

            if (SUCCEEDED(hr) && pIRowset)
            {
                hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
                while (SUCCEEDED(hr) && vTemp.vt != VT_EMPTY && vTemp.vt != VT_NULL)
                {                          
                    // Make sure we had permission to do this.
                    // We should probably somehow 'put back'
                    // whatever we removed from the cache.
                    // =======================================

                    dObjectId = _wtoi64(vTemp.bstrVal);
                    hr = CSQLExecute::GetColumnValue(pIRowset, 2, m_pIMalloc, &pRow, vTemp);
                    dClassId = _wtoi64(vTemp.bstrVal);
                    hr = CSQLExecute::GetColumnValue(pIRowset, 3, m_pIMalloc, &pRow, vTemp);
                    dScopeId = _wtoi64(vTemp.bstrVal);

                    // Just add these values to an array
                    // and remove them if everything else succeeds.
                    // ============================================

                    ObjIds.push_back(dObjectId);
                    ClassIds.push_back(dClassId);
                    ScopeIds.push_back(dScopeId);

                    if (pRow)
                        pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                    delete pRow;
                    pRow = NULL;
                    hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);            
                }
            }
           
            // Verify that we had security to do this...
            if (SUCCEEDED(hr))
            {
                for (int i = 0; i < ObjIds.size(); i++)
                {
                    dClassId = ClassIds.at(i);
                    dScopeId = ScopeIds.at(i);
                    if (dClassId && dScopeId)
                    {
                        hr = VerifyObjectSecurity(pConn, ObjIds.at(i), dClassId, dScopeId, 0, 
                            GetSchemaCache()->GetWriteToken(ObjIds.at(i), dClassId));
                        if (FAILED(hr))
                            break;
                    }
                }
            }

            if (bLocalTrans)
            {
                GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
            }

            if (SUCCEEDED(hr))
            {
                for (int i = 0; i < ObjIds.size(); i++)
                {
                    // We have no way of knowing by ID if this is a class or instance.
                    GetSchemaCache()->DeleteClass(ObjIds.at(i));    
                    CleanCache(ObjIds.at(i));                    
                }

            }
        }
    }

    return hr;

}


//***************************************************************************
//
//  CSQLConnCache::FinalRollback
//
//***************************************************************************

HRESULT CSQLConnCache::FinalRollback(CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Rollback this transaction and set Thread ID to zero

    COLEDBConnection *pConn2 = (COLEDBConnection *)pConn;
    ITransaction *pTrans = pConn2->m_pTrans;                        
    if (pTrans)
    {
        hr = pTrans->Abort(NULL, FALSE, FALSE);                        
        pTrans->Release();
    }

    pConn2->m_pTrans = NULL;
    pConn2->m_bInUse = false;
    pConn2->m_dwThreadId = 0;
    pConn2->m_tCreateTime = time(0); // We don't want to delete it immediately.

    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::FinalCommit
//
//***************************************************************************

HRESULT CSQLConnCache::FinalCommit(CSQLConnection *pConn)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Commit this transaction and erase the ThreadID
    // from this connection.

    COLEDBConnection *pConn2 = (COLEDBConnection *)pConn;
    ITransaction *pTrans = pConn2->m_pTrans;                        

    if (pTrans)
    {
        hr = pTrans->Commit(FALSE, XACTTC_SYNC, 0);  
        pTrans->Release();
    }
    
    pConn2->m_bInUse = false;
    pConn2->m_dwThreadId = 0;
    pConn2->m_tCreateTime = time(0); // We don't want to delete it immediately.
	pConn2->m_pTrans = NULL;                    

    return hr;
}


//***************************************************************************
//
//  CSQLConnCache::ReleaseConnection
//
//***************************************************************************
HRESULT CSQLConnCache::ReleaseConnection(CSQLConnection *_pConn, HRESULT retcode,
                                         BOOL bDistributed)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD dwNumFreed = 0;

    CRepdrvrCritSec r (&m_cs);

    for (int i = m_Conns.size() -1; i >=0; i--)
    {
        CSQLConnection *pConn = m_Conns.at(i);
        if (pConn)
        {
            COLEDBConnection *pConn2 = (COLEDBConnection *)pConn;
            if (_pConn == pConn)
            {                
                if (FAILED(retcode))
                {
                    if (!bDistributed)
                    {
                        hr = FinalRollback(pConn);
                        if (retcode == WBEM_E_INVALID_QUERY)
                        {
                            delete pConn;
                            pConn2 = NULL;
                            m_Conns.erase(&m_Conns.at(i));

                            DEBUGTRACE((LOG_WBEMCORE, "THREAD %ld deleted ESE connection %X.  Number of connections = %ld\n", 
                                GetCurrentThreadId(), pConn, m_Conns.size()));

                        }
                    }
                }
                else
                {                    
                    if (!bDistributed)
                        hr = FinalCommit(pConn);
                }

                if (pConn2)
                    pConn2->m_bInUse = false;
                dwNumFreed++;
                break;
            }
        }
    }

    // Notify waiting threads that there is 
    // an open connection.
    // =====================================

    for (int i = 0; i < m_WaitQueue.size(); i++)
    {
        if (i >= dwNumFreed)
            break;

        HANDLE hTemp = m_WaitQueue.at(i);
        SetEvent(hTemp);

        DEBUGTRACE((LOG_WBEMCORE, "Thread %ld released a connection...\n", GetCurrentThreadId()));
    }

    return hr;
}


//***************************************************************************
//
//  CWmiDbSession::LoadSchemaCache
//
//***************************************************************************

HRESULT CWmiDbSession::LoadSchemaCache ()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // This needs to load the cache with all class, property,
    // and namespace data. We are going to call three straight
    // select queries and grab the columns.
    // ==========================================================

    IRowset *pIRowset = NULL;
    DWORD dwNumRows;
    _bstr_t sSQL;

    CSQLConnection *pConn = NULL;
    hr = GetSQLCache()->GetConnection(&pConn, FALSE, FALSE);

    if (FAILED(hr))
        return hr;

    // FIXME: We need to sort out how to do this correctly,
    // and NOT compromise speed.

    GetSchemaCache()->SetMaxSize(0xFFFFFFFF);

    // Enumerate namespaces and scopes.
    // ================================

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), L"sp_EnumerateNamespaces", &pIRowset, &dwNumRows);
    if (SUCCEEDED(hr))
    {
        // Get the results and load the cache.

        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);
        hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
        while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
        {
            SQL_ID dObjectId = _wtoi64(vTemp.bstrVal);
            SQL_ID dParentId = 0, dClassId = 0;
            _bstr_t sObjectPath, sObjectKey;

            VariantClear(&vTemp);

            hr = CSQLExecute::GetColumnValue(pIRowset, 2, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                sObjectPath = vTemp.bstrVal;                

            hr = CSQLExecute::GetColumnValue(pIRowset, 3, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                sObjectKey = vTemp.bstrVal;                

            if (SUCCEEDED(hr))
            {
                hr = CSQLExecute::GetColumnValue(pIRowset, 4, m_pIMalloc, &pRow, vTemp);
                if (SUCCEEDED(hr))
                    dParentId = _wtoi64(vTemp.bstrVal);

                hr = CSQLExecute::GetColumnValue(pIRowset, 5, m_pIMalloc, &pRow, vTemp);
                if (SUCCEEDED(hr))
                    dClassId = _wtoi64(vTemp.bstrVal);

                hr = GetSchemaCache()->AddNamespace(sObjectPath, sObjectKey, dObjectId, dParentId, dClassId);
            }
            
            hr = pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;
            hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);

        }                
        pIRowset->Release();
        pIRowset = NULL;
    }

    if (FAILED(hr))
        return hr;

    if (FAILED(hr = LoadClassInfo(pConn, L"", 0)))
        return hr;

    DWORD dwSecurity = 0;
    GetSchemaCache()->GetPropertyID(L"__SECURITY_DESCRIPTOR", 1, 
        0, REPDRVR_IGNORE_CIMTYPE, dwSecurity);

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
        L"select ObjectId from ClassImages where PropertyId = %ld", &pIRowset, &dwNumRows, dwSecurity);
    if (SUCCEEDED(hr))
    {
        // Get the results and load the cache.

        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);
        hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
        while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
        {
            SQL_ID dObjectId = _wtoi64(vTemp.bstrVal);
            pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;

            ((CWmiDbController *)m_pController)->AddSecurityDescriptor(dObjectId);
           
            hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);                    
        }
        pIRowset->Release();
        pIRowset = NULL;
    }


    GetSQLCache()->ReleaseConnection(pConn, hr, FALSE);

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::LoadClassInfo
//
//***************************************************************************

HRESULT CWmiDbSession::LoadClassInfo (CSQLConnection *pConn, LPCWSTR lpDynasty, SQL_ID dScopeId, BOOL bDeep)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    IRowset *pIRowset = NULL;
    DWORD dwNumRows;

    // FIXME: We need to make this selective, but reading
    // this data is so slow!!

    // The cache relies on the numeric value of scope and super class objects.
    // =======================================================================

    if (((CWmiDbController *)m_pController)->m_bCacheInit)
        return hr;

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
           L"select c.ClassId, c.ClassName, c.SuperClassId, o.ObjectScopeId, o.ObjectPath,o.ObjectFlags from ClassMap as c "
           L" inner join ObjectMap as o on o.ObjectId = c.ClassId "
           L" order by c.ClassId ", &pIRowset, &dwNumRows);
    if (SUCCEEDED(hr))
    {
        // Get the results and load the cache.
        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);
        hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
        while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
        {
            SQL_ID dObjectId = _wtoi64(vTemp.bstrVal);
            _bstr_t sClassName, sPath;
            SQL_ID dParentId = 0, dScopeId = 0;
            DWORD dwFlags = 0;

            VariantClear(&vTemp);

            hr = CSQLExecute::GetColumnValue(pIRowset, 2, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                sClassName = vTemp.bstrVal;                

            hr = CSQLExecute::GetColumnValue(pIRowset, 3, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
            {
                if (vTemp.vt != VT_EMPTY && vTemp.vt != VT_NULL) 
                    dParentId = _wtoi64(vTemp.bstrVal);
                else
                    dParentId = 1;
            }

            hr = CSQLExecute::GetColumnValue(pIRowset, 4, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
            {
                if (vTemp.vt != VT_EMPTY && vTemp.vt != VT_NULL) 
                    dScopeId = _wtoi64(vTemp.bstrVal);
                else
                    dScopeId = 0;
            }
            hr = CSQLExecute::GetColumnValue(pIRowset, 5, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                sPath = vTemp.bstrVal;

            hr = CSQLExecute::GetColumnValue(pIRowset, 6, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                dwFlags = ((vTemp.vt == VT_EMPTY || vTemp.vt == VT_NULL) ? 0 : vTemp.lVal);
            else
                dwFlags = 0;

            hr = GetSchemaCache()->AddClassInfo(dObjectId, sClassName, dParentId, 0, dScopeId, sPath, dwFlags);
                        
            pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;

            if (FAILED(hr))
                break;
            
            hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
        }                
        pIRowset->Release();
        pIRowset = NULL;
    }

    if (FAILED(hr))
        return hr;

    //  Enumerate properties.
    // ======================

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
           L"select p.PropertyId, p.PropertyName, p.ClassId, p.StorageTypeId, p.CIMTypeId, p.Flags, 0, "
           L" c.PropertyId "
           L"from PropertyMap as p left outer join ClassKeys as c on c.ClassId = p.ClassId and c.PropertyId = p.PropertyId "
           L" order by p.PropertyId ",
           &pIRowset, &dwNumRows);
    if (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
    {
        // Get the results and load the cache.
        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);
        hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);
        while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
        {
            DWORD dwPropertyID=0, dwStorageType=0, dwCIMType=0, dwFlags=0, dwFlavor=0;
            _bstr_t sName, sDefault;
            SQL_ID dClassId = 0, dRefClassID = 0;
            DWORD dwRefPropID = 0;

            dwPropertyID = vTemp.lVal;
            VariantClear(&vTemp);
            hr = CSQLExecute::GetColumnValue(pIRowset, 2, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                sName = vTemp.bstrVal;

            hr = CSQLExecute::GetColumnValue(pIRowset, 3, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                dClassId = _wtoi64(vTemp.bstrVal);    // We want the applied class ID for qualifiers.

            hr = CSQLExecute::GetColumnValue(pIRowset, 4, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                dwStorageType = vTemp.lVal;

            hr = CSQLExecute::GetColumnValue(pIRowset, 5, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                dwCIMType = (vTemp.vt == VT_I4 ? vTemp.lVal : 0);
            else
                dwCIMType = 0;

            hr = CSQLExecute::GetColumnValue(pIRowset, 6, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr))
                dwFlags = (vTemp.vt == VT_I4 ? vTemp.lVal : 0);
            else
                dwFlags = 0;

            if (dwCIMType == CIM_REFERENCE || dwCIMType == CIM_OBJECT)
            {
                hr = CSQLExecute::GetColumnValue(pIRowset, 7, m_pIMalloc, &pRow, vTemp);
                if (SUCCEEDED(hr))
                    dRefClassID = _wtoi64(vTemp.bstrVal);
            }

            hr = GetSchemaCache()->AddPropertyInfo (dwPropertyID, sName, dClassId, dwStorageType, dwCIMType, dwFlags, 
                dRefClassID, sDefault, dwRefPropID, dwFlavor);

            hr = CSQLExecute::GetColumnValue(pIRowset, 8, m_pIMalloc, &pRow, vTemp);
            if (SUCCEEDED(hr) && vTemp.vt != VT_NULL)
                GetSchemaCache()->SetIsKey(dClassId, dwPropertyID);

            pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;

            if (FAILED(hr))
                break;
            
            hr = CSQLExecute::GetColumnValue(pIRowset, 1, m_pIMalloc, &pRow, vTemp);        
        }
        
        pIRowset->Release();
        pIRowset = NULL;
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::LoadClassInfo
//
//***************************************************************************

HRESULT CWmiDbSession::LoadClassInfo (CSQLConnection *_pConn, SQL_ID dClassId, BOOL bDeep)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Not implemented (yet). 

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::GetClassObject
//
//***************************************************************************

HRESULT CWmiDbSession::GetClassObject (CSQLConnection *pConn, SQL_ID dClassId, IWbemClassObject **ppObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _IWmiObject *pNew = NULL;
    SQL_ID dParentId = 0;
    SQL_ID dSuperClassId = 0;
    DWORD dwBufferLen = 0;
    BYTE *pBuffer = NULL;

    // All we need to do is read the blob from the database.
    // This should be cached where space allows.

    BOOL bNeedToRelease = FALSE;

    if (!pConn)
    {
        hr = GetSQLCache()->GetConnection(&pConn, 0, IsDistributed());
        bNeedToRelease = TRUE;
        if (FAILED(hr))
            return hr;
    }

    hr = CSQLExecProcedure::GetClassInfo(pConn, dClassId, dSuperClassId, &pBuffer, dwBufferLen);            
    if (SUCCEEDED(hr) && pBuffer)
    {
        if (dSuperClassId != 0 && dSuperClassId != 1)
        {
            hr = GetObjectCache()->GetObject(dSuperClassId, ppObj);
            if (FAILED(hr))
                hr = GetClassObject(pConn, dSuperClassId, ppObj);
            if (SUCCEEDED(hr))
            {
                // Merge the class part.

                _IWmiObject *pObj = (_IWmiObject *)*ppObj;
                hr = pObj->Merge (WMIOBJECT_MERGE_FLAG_CLASS, dwBufferLen, pBuffer, &pNew);
                pObj->Release();
                if (SUCCEEDED(hr))
                    *ppObj = pNew;
            }
        }
        else
        {
            _IWmiObject *pObj = NULL;
            hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                    IID__IWmiObject, (void **)&pObj);
            if (SUCCEEDED(hr))
            {
                hr = pObj->Merge(WMIOBJECT_MERGE_FLAG_CLASS, dwBufferLen, pBuffer, &pNew);
                pObj->Release();
                if (SUCCEEDED(hr))
                    *ppObj = pNew;
            }
        }
    }
    else
        hr = WBEM_E_NOT_FOUND;

    if (bNeedToRelease && pConn)
    {
        GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());
    }

    return hr;
}

//***************************************************************************
//
//  CWmiDbSession::GetObjectData
//
//***************************************************************************

HRESULT CWmiDbSession::GetObjectData (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId, 
                                      DWORD dwHandleType, DWORD &dwVersion, IWbemClassObject **ppObj, BOOL bWaste, 
                                      LPWSTR lpInKey, BOOL bGetSD )
{
    _WMILockit _Lk(GetCS());

    HRESULT hr = WBEM_S_NO_ERROR;
    SQL_ID dParentId;
    _bstr_t sClassPath = L"", sClassName = L"";
    DWORD dwGenus = 1;
    DWORD dwRows;
    IRowset *pIRowset = NULL;
    DWORD dwFlags;
    bool bUsedCache = false;

    DWORD dwType = 0, dwVer = 0;

    //  Validate version if this is a versioned handle.
    // ================================================-
    hr = VerifyObjectLock(dObjectId, dwHandleType, dwVersion);
    if (FAILED(hr) && IsDistributed())
    {
        if (LockExists(dObjectId))
            hr = WBEM_S_NO_ERROR;
    }

    if (SUCCEEDED(hr))
    {    
        // Check the object cache to see if this
        // IWbemClassObject is already loaded.
        // =====================================

        if (dClassId == INSTANCESCLASSID)
            hr = WBEM_E_NOT_FOUND;
        else
        {
            hr = GetObjectCache()->GetObject(dObjectId, ppObj);
        }
        if (FAILED(hr))
        {
            hr = WBEM_S_NO_ERROR;
            IDBInitialize *pDBInit = NULL;
            // Otherwise, we need to hit the database.
            // =======================================
            HROW *pRow = NULL;
            BOOL bNeedToRelease = FALSE;
            IDBCreateCommand *pCommand = NULL;

            if (!pConn)
            {
                hr = GetSQLCache()->GetConnection(&pConn, FALSE, IsDistributed());
                bNeedToRelease = TRUE;
                if (FAILED(hr))
                    return hr;
            }

            pCommand = ((COLEDBConnection *)pConn)->GetCommand();

            if (SUCCEEDED(hr))
            {
                if (dClassId == 1)
                {                    
                    dwGenus = 1;
                    dClassId = dObjectId;
                }
                else
                    dwGenus = 2;
                SQL_ID dTemp = 0;
                hr = GetSchemaCache()->GetClassInfo(dClassId, sClassPath, dParentId, dTemp, dwFlags);

                // We now have an object path and class ID.
                // Now we have to instantiate a new IWbemClassObject,
                // populate all the system properties
                // ==================================================

                IWbemClassObject *pClass = NULL;
                IWbemClassObject *pTemp = NULL;

                hr = GetObjectCache()->GetObject(dClassId, &pClass);
                if (FAILED(hr))
                    hr = GetClassObject (pConn, dClassId, &pClass);
                else
                    bUsedCache = true;

                if (SUCCEEDED(hr))
                {                    
                    if (dwGenus == 2)
                    {
                        if (pClass)
                        {
                            pClass->SpawnInstance(0, &pTemp);    
                        }
                    }
                    else
                    {
                        pTemp = pClass;
                    }
     
                    // Special case if this is an __Instances container,
                    // We need to instantiate an instance of __Instances,
                    // and plug the class name into the ClassName property.
                    // ===================================================

                    if (dClassId == INSTANCESCLASSID)
                    {
                        _bstr_t sPath;
                        _bstr_t sName;
                        SQL_ID dTemp1, dTemp2;
                        DWORD dwFlags;

                        hr = GetSchemaCache()->GetClassInfo (dObjectId, sPath, dTemp1, dTemp2, dwFlags, &sName);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT vTemp;
                            VariantInit(&vTemp);
                            vTemp.bstrVal = SysAllocString(sName);
                            vTemp.vt = VT_BSTR;
                            pTemp->Put(L"ClassName", 0, &vTemp, CIM_STRING);
                            VariantClear(&vTemp);
                            *ppObj = pTemp;
                        }
                    }
                    else
                    {

                        if (dwGenus == 2)
                        {
                            // Now we are ready to get the real data. 
                            // Basically, we have to select * from ClassData, and 
                            // let CSQLExecute correctly interpret the data therein.
                            // ====================================================

                            bool bBigText = false;
                            HROW *pRow = NULL;
                            Properties props;

                            hr = CSQLExecute::ExecuteQuery(pCommand, L"sp_GetInstanceData %I64d", &pIRowset, &dwRows, dObjectId);
                            while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
                            {
                                if (!dwRows || dwRows == 0xffffffff)
                                    dwRows = 20;

                                hr = CSQLExecuteRepdrvr::GetNextResultRows(dwRows, pIRowset, m_pIMalloc, pTemp, 
                                    &((CWmiDbController *)m_pController)->SchemaCache, this, props, &bBigText, false);
                            }  
                            if (pIRowset)
                                pIRowset->Release();

                            //if (bBigText || GetSchemaCache()->HasImageProp(dClassId))
                            {
                                hr = CSQLExecute::ExecuteQuery(pCommand, L"sp_GetInstanceImageData %I64d", &pIRowset, &dwRows, dObjectId);
                                while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)          
                                {
                                    if (!dwRows || dwRows == 0xffffffff)
                                        dwRows = 1;

                                    hr = CSQLExecuteRepdrvr::GetNextResultRows(dwRows, pIRowset, m_pIMalloc, pTemp, 
                                        &((CWmiDbController *)m_pController)->SchemaCache, this, props, NULL, true);
                                }
                                pIRowset->Release();
                            }
                        }
                    
                        *ppObj = pTemp;
                        hr = WBEM_S_NO_ERROR;

                        // Always cache the class object.

                        if (!bUsedCache && SUCCEEDED(hr) && !((dwHandleType & 0xF00) == WMIDB_HANDLE_TYPE_NO_CACHE))
                            GetObjectCache()->PutObject(dClassId, 1, dScopeId, sClassPath, 1, pClass);
                    }

                    if (pTemp)
                    {
                        hr = GetSchemaCache()->DecorateWbemObj(m_sMachineName, m_sNamespacePath, 
                            dScopeId, pTemp, dClassId);
                    }

                    // If all that worked, try and cache this object.
                    // ==============================================

                    if (SUCCEEDED(hr) && ppObj && (dwHandleType & 0xF00) && dClassId != INSTANCESCLASSID)
                    {
                        // This is allowed to fail, since its *just* a cache.
                        if ((dwHandleType & 0xF00) != WMIDB_HANDLE_TYPE_NO_CACHE)
                        {
                            bool bCacheType = ((dwHandleType & 0xF00) == WMIDB_HANDLE_TYPE_STRONG_CACHE) ? 1 : 0;
                    
                            LPWSTR lpPath = GetPropertyVal(L"__RelPath", *ppObj);
                            if (lpPath)
                                GetObjectCache()->PutObject(dObjectId, dClassId, dScopeId, lpPath, bCacheType, *ppObj);
                            delete lpPath;
                        }
                    }
                
                    if (dwGenus == 2 && pClass)
                        pClass->Release();
                }

                if (bNeedToRelease)
                {
                    GetSQLCache()->ReleaseConnection(pConn, hr, IsDistributed());                    
                }

             }
        }
        else
        {
            // Make sure the decoration is up-to-date.
            hr = GetSchemaCache()->DecorateWbemObj(m_sMachineName, m_sNamespacePath, 
                dScopeId, *ppObj, dClassId);
        }
    }

    // Populate the security descriptor, if requested   
    if (SUCCEEDED(hr) && bGetSD)
    {
        BOOL bNeedToRelease = FALSE;

        if (!pConn)
        {
            hr = GetSQLCache()->GetConnection(&pConn, 0, FALSE);
            bNeedToRelease = TRUE;
            if (FAILED(hr))
            {
                (*ppObj)->Release();
                *ppObj = NULL;
                return hr;
            }
        }

        PNTSECURITY_DESCRIPTOR  pSD = NULL;
        DWORD dwLen = 0;
        if (SUCCEEDED(CSQLExecProcedure::GetSecurityDescriptor(pConn, dObjectId, &pSD, dwLen, 0)))
        {
            ((_IWmiObject *)*ppObj)->WriteProp(L"__SECURITY_DESCRIPTOR", 0, dwLen, dwLen, CIM_UINT8|CIM_FLAG_ARRAY, pSD);

            delete pSD;
        }
        if (bNeedToRelease && pConn)
        {
            GetSQLCache()->ReleaseConnection(pConn, hr, FALSE);
        }    
    }

    return hr;

}

//***************************************************************************
//
//  CSQLConnCache::Shutdown
//
//***************************************************************************

HRESULT CSQLConnCache::Shutdown()
{
    return WBEM_S_NO_ERROR;
}

LPSTR EscapeChar (LPSTR lpText, char p = '%')
{
    int iPos = 0;
    int iLen = strlen(lpText);
    char *pszTemp = NULL;
    if (iLen)
    {
        pszTemp = new char [iLen+20];
        if (pszTemp)
        {
            for (int i = 0; i < iLen; i++)
            {
                char t = lpText[i];
                if (t == p)
                {
                    pszTemp[iPos] = t;
                    iPos++;
                }
                pszTemp[iPos] = t;
                iPos++;
            }
            pszTemp[iPos] = '\0';
        }
    }    
    return pszTemp;
}

//***************************************************************************
//
//  InitializeClass
//
//***************************************************************************

HRESULT InitializeClass (CSQLConnection *pConn, LPCWSTR lpClassName, IWbemClassObject **ppObj)
{
    HRESULT hr = 0;
    _IWmiObject *pObj = NULL;
    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
            IID__IWmiObject, (void **)&pObj);
    if (SUCCEEDED(hr))
    {
        VARIANT vTemp;
        VariantInit(&vTemp);
        vTemp.bstrVal = SysAllocString(lpClassName);
        vTemp.vt = VT_BSTR;
        pObj->Put(L"__Class", 0, &vTemp, CIM_STRING);
        VariantClear(&vTemp);
    }
    *ppObj = (IWbemClassObject *)pObj;

    return hr;
}

//***************************************************************************
//
//  AddPropertyToClass
//
//***************************************************************************

HRESULT AddPropertyToClass (IWbemClassObject *pObj, LPCWSTR lpPropName, 
                         CIMTYPE ct, BOOL bIsKey=FALSE, LPCWSTR lpCIMType = NULL)
{
    HRESULT hr = 0;

    VARIANT vTemp;
    VariantInit(&vTemp);
    pObj->Put(lpPropName, 0, NULL, ct);
    IWbemQualifierSet *pQS = NULL;

    if (bIsKey)
    {
        hr = pObj->GetPropertyQualifierSet(lpPropName, &pQS);
        if (SUCCEEDED(hr))
        {
            vTemp.boolVal = 1;
            vTemp.vt = VT_BOOL;
            pQS->Put(L"key", &vTemp, 0);
            pQS->Release();
            VariantClear(&vTemp);
        }
    }
    if (lpCIMType)
    {
        hr = pObj->GetQualifierSet(&pQS);
        if (SUCCEEDED(hr))
        {
            vTemp.bstrVal = SysAllocString(lpCIMType);
            vTemp.vt = VT_BSTR;
            pQS->Put(L"CIMTYPE", &vTemp, 0);
            pQS->Release();
            VariantClear(&vTemp);
        }
    }
    return hr;
}

//***************************************************************************
//
//  Startup
//
//***************************************************************************

HRESULT Startup(HRESULT hrDB, CSQLConnection *pConn, LPCWSTR lpDatabaseName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    wchar_t SysPath[1024];

    GetSystemDirectory(SysPath, 1023);
    if (!wcslen(SysPath))
        return WBEM_E_FAILED;

    wcscat(SysPath, L"\\wbem\\repository\\");

    _bstr_t sFile = SysPath;
    sFile += lpDatabaseName;
    sFile += L".tmp";
    BOOL bCreate = FALSE;

    if (FAILED(hrDB))
    {
        // Load and parse the file.
        // Execute each query to each "go"

        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"use master");
        if (SUCCEEDED(hr))
        {
            ERRORTRACE((LOG_WBEMCORE, "SQL Database Creation...\n"));
            printf ("Creating database %S...\n", lpDatabaseName);

            // Just create on the default device with the default settings.
            
            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), 
                       L" CREATE DATABASE %s", NULL, NULL, lpDatabaseName);

            if (SUCCEEDED(hr))
            {
                _bstr_t sFile = SysPath;
                sFile += lpDatabaseName;
                sFile += L".tmp";

                FILE *p = fopen(sFile, "at");
                if (p)
                    fclose(p);
                bCreate = TRUE;
            }
        }
    }
    else
    {
        IRowset *pRowset = NULL;
        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), 
            L" select Version from %s..DBVersion ", &pRowset, NULL, lpDatabaseName);
        if (SUCCEEDED(hr) && pRowset)
        {
            VARIANT vTemp;
            CClearMe c (&vTemp);
            HROW *pRow = NULL;
            IMalloc *pMalloc =NULL;
            CoGetMalloc(MEMCTX_TASK, &pMalloc);

            hr = CSQLExecute::GetColumnValue(pRowset, 1, pMalloc, &pRow, vTemp);
            pMalloc->Release();
            if (SUCCEEDED(hr) && vTemp.lVal != CURRENT_DB_VERSION)
            {
                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"use master");

                ERRORTRACE((LOG_WBEMCORE, "Version mismatch detected. Dropping database: %S\n", (const wchar_t *)lpDatabaseName));
                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"drop database %s",
                    NULL, NULL, lpDatabaseName);
                hr = WBEM_E_DATABASE_VER_MISMATCH;
            }
            else
                hr = WBEM_S_NO_ERROR;

            pRowset->Release();
        }
        else
            hr = WBEM_S_NO_ERROR;
    }

    if (SUCCEEDED(hr))
    {
        FILE *pTemp = fopen(sFile, "rt");
        if (pTemp || bCreate)
        {
            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                L"exec sp_dboption %s, 'trunc', true", NULL, NULL, lpDatabaseName);
            if (SUCCEEDED(hr))
            {
                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"use master");
                if (SUCCEEDED(hr))
                {
                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                        L" IF NOT EXISTS (select * from systypes where name = 'WMISQL_ID') "
                        L" BEGIN "
                        L"  exec sp_addtype WMISQL_ID, 'numeric(20,0)', 'NULL' "
                        L" END ");
                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"use tempdb");
                    if (SUCCEEDED(hr))
                    {
                        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                            L" IF NOT EXISTS (select * from systypes where name = 'WMISQL_ID') "
                            L" BEGIN "
                            L"  exec sp_addtype WMISQL_ID, 'numeric(20,0)', 'NULL' "
                            L" END ");

                        if (SUCCEEDED(hr))
                        {
                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                                L"use %s", NULL, NULL, lpDatabaseName);

                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                                L" IF NOT EXISTS (select * from systypes where name = 'WMISQL_ID') "
                                L" BEGIN "
                                L"  exec sp_addtype WMISQL_ID, 'numeric(20,0)', 'NULL' "
                                L" END ");
                        }
                    }
                }
            }               

            if (SUCCEEDED(hr))
            {
                hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                    L"begin transaction ");

                // Run the db scripts.

                GetSystemDirectory(SysPath, 1023);
                _bstr_t sPath = SysPath + _bstr_t(L"\\wbem\\createdb.sql");

                FILE *fp = fopen(sPath, "rt");

                if (fp)
                {
                    char LineBuffer[2048];
                    _bstr_t sCmd;

                    // Read each line.
                    // ===============

                    DWORD dwReturnCode = NO_ERROR;
                    DWORD dwLine = 0;

                    while (fgets(LineBuffer, 1024, fp)) {
                        LineBuffer[strlen(LineBuffer)-1] = 0;
                        dwLine++;
                        if (memcmp(LineBuffer, "go", 2) == 0 || memcmp(LineBuffer, "GO", 2) == 0) 
                        {
                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),sCmd);
                            if (FAILED(hr))
                                break;
                            sCmd = L"";
                        }
                        else 
                        {
                            int iRet = memcmp(LineBuffer, "/*", 2);
                            if (iRet)
                            {
                                LPSTR lpStr = EscapeChar(LineBuffer, '%');

                                sCmd += (const char *)lpStr;
                                sCmd += L"\r\n";
                                delete lpStr;
                            }
                        }
                    }

                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), 
                        L"update %s..DBVersion set Version = %ld", NULL, NULL, lpDatabaseName, CURRENT_DB_VERSION);

                    fclose(fp);

                    // Initialize meta_class with new properties
                    IWbemClassObject *pTest = NULL;
                    hr = CoCreateInstance(CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, 
                        IID_IWbemClassObject, (void **)&pTest);
                    if (SUCCEEDED(hr))
                    {
                        CReleaseMe r (pTest);
                        BSTR strName;
                        CIMTYPE cimtype;
            
                        hr = pTest->BeginEnumeration(0);
                        while (pTest->Next(0, &strName, NULL, &cimtype, NULL) == S_OK)
                        {
                            DWORD dwStorageType = 0;
                            CFreeMe f1 (strName);
                            DWORD dwFlags = REPDRVR_FLAG_SYSTEM;
                            bool bArray = false;
                            CIMTYPE ct = cimtype & 0xFFF;
                            if (cimtype & CIM_FLAG_ARRAY)
                            {
                                bArray = true;
                                dwFlags |= REPDRVR_FLAG_ARRAY;
                            }

                            if (_wcsicmp(strName, L"__Path") &&
                                _wcsicmp(strName, L"__RelPath") &&
                                _wcsicmp(strName, L"__Class") &&
                                _wcsicmp(strName, L"__SuperClass") &&
                                _wcsicmp(strName, L"__Dynasty") &&
                                _wcsicmp(strName, L"__Derivation") &&
                                _wcsicmp(strName, L"__Version") &&
                                _wcsicmp(strName, L"__Genus") &&
                                _wcsicmp(strName, L"__Property_Count") &&
                                _wcsicmp(strName, L"__Server") &&
                                _wcsicmp(strName, L"__Namespace"))
                            {
                                dwStorageType = GetStorageType(ct, bArray);

                                DWORD dwProp = 0;
                                hr = CSQLExecProcedure::InsertClassData (pConn,
                                    pTest, NULL, 0, 1, strName, ct, dwStorageType, L"", 0, 0, dwFlags, 0, 0, dwProp, 1);
                                if (FAILED(hr))
                                    goto Exit;
                            }
                        }
                    }

                    // Create the initial objects...
                    // __Namespace
                    // __Container_Association
                    // __Instances

                    IWbemClassObject *pObj = NULL, *pDerived = NULL;
                    hr = InitializeClass(pConn, L"__Namespace", &pObj);
                    if (FAILED(hr))
                        goto Exit;
                    hr = AddPropertyToClass(pObj, L"Name", CIM_STRING, TRUE);
                    hr = CSQLExecProcedure::UpdateClassBlob(pConn, 2372429868687864876, (_IWmiObject *)pObj);
                    ((_IWmiObject *)pObj)->SetDecoration(L".", L"root");
                    hr = pObj->SpawnDerivedClass(0, &pDerived);

                    pObj->Release();
                    if (FAILED(hr))
                        goto Exit;

                    hr = InitializeClass(pConn, L"__Instances", &pObj);
                    if (FAILED(hr))
                        goto Exit;
                    hr = AddPropertyToClass(pObj, L"ClassName", CIM_STRING, TRUE);
                    hr = CSQLExecProcedure::UpdateClassBlob(pConn, 3373910491091605771, (_IWmiObject *)pObj);
                    pObj->Release();
                    if (FAILED(hr))
                        goto Exit;

                    hr = InitializeClass(pConn, L"__Container_Association", &pObj);
                    if (FAILED(hr))
                        goto Exit;
                    hr = AddPropertyToClass(pObj, L"Containee", CIM_REFERENCE, TRUE);
                    hr = AddPropertyToClass(pObj, L"Container", CIM_REFERENCE, TRUE);
                    hr = CSQLExecProcedure::UpdateClassBlob(pConn, -7316356768687527881, (_IWmiObject *)pObj);
                    pObj->Release();
                    if (FAILED(hr))
                        goto Exit;

                    // Custom repository stuff
                    // __SqlMappedNamespace
                    // __CustRepDrvrMapping
                    // __CustRepDrvrMappingProperty

                    if (pDerived)
                    {
                        VARIANT vTemp;
                        VariantInit(&vTemp);
                        vTemp.bstrVal = SysAllocString(L"__SqlMappedNamespace");
                        vTemp.vt = VT_BSTR;

                        pDerived->Put(L"__Class", 0, &vTemp, CIM_STRING);
                        VariantClear(&vTemp);
                        hr = CSQLExecProcedure::UpdateClassBlob(pConn, -7061265575274197401, (_IWmiObject *)pDerived);
                        pDerived->Release();
                        if (FAILED(hr))
                            goto Exit;
                    }

                    hr = InitializeClass(pConn, L"__CustRepDrvrMapping", &pObj);
                    if (FAILED(hr))
                        goto Exit;
                    hr = AddPropertyToClass(pObj, L"sTableName", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sPrimaryKeyCol", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sDatabaseName", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sClassName", CIM_STRING, TRUE);
                    hr = AddPropertyToClass(pObj, L"sScopeClass", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"arrProperties", CIM_OBJECT+CIM_FLAG_ARRAY, FALSE, L"object:__CustRepDrvrMappingProperty");
                    hr = CSQLExecProcedure::UpdateClassBlob(pConn, -539347062633018661, (_IWmiObject *)pObj);
                    pObj->Release();
                    if (FAILED(hr))
                        goto Exit;

                    hr = InitializeClass(pConn, L"__CustRepDrvrMappingProperty", &pObj);
                    if (FAILED(hr))
                        goto Exit;
                    hr = AddPropertyToClass(pObj, L"arrColumnNames", CIM_STRING+CIM_FLAG_ARRAY);
                    hr = AddPropertyToClass(pObj, L"arrForeignKeys", CIM_STRING+CIM_FLAG_ARRAY);
                    hr = AddPropertyToClass(pObj, L"bIsKey", CIM_BOOLEAN);
                    hr = AddPropertyToClass(pObj, L"bStoreAsNumber", CIM_BOOLEAN);
                    hr = AddPropertyToClass(pObj, L"bReadOnly", CIM_BOOLEAN);
                    hr = AddPropertyToClass(pObj, L"bStoreAsBlob", CIM_BOOLEAN);
                    hr = AddPropertyToClass(pObj, L"bDecompose", CIM_BOOLEAN);
                    hr = AddPropertyToClass(pObj, L"bStoreAsMofText", CIM_BOOLEAN);
                    hr = AddPropertyToClass(pObj, L"sPropertyName", CIM_STRING, TRUE);
                    hr = AddPropertyToClass(pObj, L"sTableName", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sClassTableName", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sClassDataColumn", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sClassNameColumn", CIM_STRING);
                    hr = AddPropertyToClass(pObj, L"sClassForeignKey", CIM_STRING);
                    hr = CSQLExecProcedure::UpdateClassBlob(pConn, -3130657873239620716, (_IWmiObject *)pObj);
                    pObj->Release();
                    if (FAILED(hr))
                        goto Exit;
                }
                else
                    hr = WBEM_E_NOT_FOUND;

                if (pTemp)
                    fclose(pTemp);

                // Get rid of it so we don't run it again.
                if (SUCCEEDED(hr))
                {
                    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                        L"commit transaction ");

                    DeleteFile(sFile);
                }
                else
                    CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(),
                                    L"rollback transaction ");
            }
        }
    }

    if (SUCCEEDED(hr))
        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"exec sp_AutoDelete ");
Exit:

    return hr;

}
//***************************************************************************
//
//  CSQLConnCache::GetConnection
//
//***************************************************************************
HRESULT CSQLConnCache::GetConnection(CSQLConnection **ppConn, BOOL bTransacted, 
                                     BOOL bDistributed,DWORD dwTimeOutSecs)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bFound = false;
    DWORD dwThreadId = GetCurrentThreadId();
    CRepdrvrCritSec r (&m_cs);

    static BOOL bInit = FALSE;

    if (!ppConn)
        return WBEM_E_INVALID_PARAMETER;

    if (m_WaitQueue.size() && dwTimeOutSecs > 0)
        goto Queue;

    // See if there are any free connections.
    // ======================================

    if (m_Conns.size() > 0)
    {        
        for (int i = 0; i < m_Conns.size(); i++)
        {
            CSQLConnection *pConn = m_Conns.at(i);
            if (pConn)
            {
                COLEDBConnection *pConn2 = (COLEDBConnection *)pConn;
                time_t tTemp = time(0);
            
                if (!pConn2->m_bInUse)
                {
                    if (!bDistributed || (dwThreadId == pConn->m_dwThreadId))
                    {
                        pConn2->m_bInUse = true;
                        pConn2->m_tCreateTime = time(0);
                        *ppConn = pConn;
                        bFound = true;
                        break;
                    }
                }
            }
        }
    }

    // Look for any connection that has no 
    // thread ID and take ownership.
    // ===================================

    if (bDistributed && !bFound)
    {
        for (int i = 0; i < m_Conns.size(); i++)
        {
            COLEDBConnection *pConn = (COLEDBConnection *)m_Conns.at(i);
            if (pConn)
            {           
                if (!pConn->m_bInUse && !pConn->m_dwThreadId)
                {
                    pConn->m_bInUse = true;
                    pConn->m_tCreateTime = time(0);
                    *ppConn = pConn;
                    bFound = true;
                    break;
                }
            }
        }
    }

    // If there were no free connections, try and obtain a new one.
    // ============================================================

    if (!bFound && (m_Conns.size() < m_dwMaxNumConns))
    {
        IDBInitialize *pDBInit = NULL;
        IDBProperties*  pIDBProperties = NULL;

        hr = CoCreateInstance(CLSID_SQLOLEDB, NULL, CLSCTX_INPROC_SERVER,
            IID_IDBInitialize, (void**)&pDBInit);

        pDBInit->QueryInterface(IID_IDBProperties, (void**)&pIDBProperties);
        CReleaseMe r1 (pIDBProperties);
        hr = pIDBProperties->SetProperties(1, m_pPropSet);    

        hr = pDBInit->Initialize();
        if (SUCCEEDED(hr))
        {
            COLEDBConnection *pConn2 = new COLEDBConnection(pDBInit);
            CSQLConnection *pConn = (CSQLConnection *)pConn2;
            if (pConn)
            {
                pConn2->m_bInUse = true;
                pConn2->m_tCreateTime = time(0);
                
                if (SUCCEEDED(hr))
                {
                    ITransaction *pTrans = NULL;
                    IDBCreateCommand *pCmd = NULL;
                    IDBCreateSession *pSession = NULL;

                    hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                            (void**) &pSession);
                    if (SUCCEEDED(hr))
                    {
                        pConn2->SetSessionObj(pSession);
                        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
                            (IUnknown**) &pCmd);    
                        if (SUCCEEDED(hr))
                        {
                            pConn2->SetCommand(pCmd);
                            // Set the Session and Command objects.
                            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), 
                                        L"use %s", NULL, NULL, (LPWSTR)m_sDatabaseName);    
                            if (!bInit)
                            {
                                hr = Startup(hr, pConn, m_sDatabaseName);                                
                                if (SUCCEEDED(hr))
                                    bInit = TRUE;
                            }
                            if (SUCCEEDED(hr))
                                hr = ExecInitialQueries(pDBInit, pConn);
                        }
                    }

                }
                if (SUCCEEDED(hr))
                    m_Conns.push_back(pConn);
                else
                {
                    delete pConn;
                    pConn = NULL;
                }
            }
            *ppConn = pConn;
        }
        else
            hr = WBEM_E_CONNECTION_FAILED;
    }
    
    if (SUCCEEDED(hr))
    {
        if (bTransacted || bDistributed)
        {
            COLEDBConnection *pConn2 = (COLEDBConnection *)*ppConn;
            if (!pConn2->m_pTrans)
            {
                ITransaction *pTrans = NULL;
                hr = pConn2->GetCommand()->QueryInterface(IID_ITransactionLocal,(void**) &pTrans);
                if (SUCCEEDED(hr))
                {
                    hr = ((ITransactionLocal*) pTrans)->StartTransaction(ISOLATIONLEVEL_SERIALIZABLE, 0, NULL, NULL);
                    pConn2->m_pTrans = pTrans;
                }
            }
        }
    }

Queue:
    // Otherwise, wait for a connection to be released.
    // ================================================
    
    if (!*ppConn && (m_Conns.size() >= m_dwMaxNumConns) && dwTimeOutSecs > 0)
    {
        DEBUGTRACE((LOG_WBEMCORE, "WARNING: >> Number of SQL connections exceeded (%ld).  Thread %ld is waiting on one to be released...\n",
            m_Conns.size(), GetCurrentThreadId()));
        wchar_t wTemp[30];
        swprintf(wTemp, L"%ld", GetCurrentThreadId());

        HANDLE hThreadEvent = CreateEvent(NULL, TRUE, FALSE, wTemp);
        if (hThreadEvent != INVALID_HANDLE_VALUE)
        {
                m_WaitQueue.push_back(hThreadEvent);
            if (WaitForSingleObject(hThreadEvent, dwTimeOutSecs*1000) == WAIT_OBJECT_0)
            {
                hr = GetConnection(ppConn, bTransacted, bDistributed, 0);
                if (SUCCEEDED(hr))
                    DEBUGTRACE((LOG_WBEMCORE, "Thread %ld obtained a connection.\n", GetCurrentThreadId()));
            }
            else
                hr = WBEM_E_SERVER_TOO_BUSY;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;

        // Remove ourself from the queue
        // This will happen whether the GetConnection
        // succeeded or failed
        // ==========================================

        for (int i = 0; i < m_WaitQueue.size(); i++)
        {
            if (hThreadEvent == m_WaitQueue.at(i))
            {
                m_WaitQueue.erase(&m_WaitQueue.at(i));
                break;
            }
        }

        CloseHandle(hThreadEvent);
    }

    if (!*ppConn && SUCCEEDED(hr))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Thread %ld was unable to obtain a connection.\n", GetCurrentThreadId()));
        hr = WBEM_E_SERVER_TOO_BUSY;
    }
    
    return hr;
}

//***************************************************************************
//
//  CSQLConnCache::ExecInitialQueries
//
//***************************************************************************

HRESULT CSQLConnCache::ExecInitialQueries(IDBInitialize *pDBInit, CSQLConnection *pConn)
{
    HRESULT hr = 0;
    COLEDBConnection *pConn2 = (COLEDBConnection *)pConn;

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L"set nocount on ");    

    // This is expensive.  Only do this once per connection!

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection*)pConn)->GetCommand(), L" create table #Parents (ClassId numeric(20,0)) "
                               L" create table #Children (ClassId numeric(20,0), SuperClassId numeric(20,0)) "
                               L" create table #SubScopeIds (ID numeric(20,0)) ");

    return hr;
}

//***************************************************************************
//
//  CSQLExecute::GetWMIError
//
//***************************************************************************

HRESULT CSQLExecute::GetWMIError(IUnknown *pErrorObj)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IErrorInfo *pErrorInfo;
    IErrorRecords *pErrorRecords;
    ISupportErrorInfo *pSupportErrorInfo;
    DWORD dwLocaleID = 1033;    // TO DO: Figure this out later...

    ERRORINFO ErrorInfo;
    unsigned long ulNumErrorRecs;

    hr = ((IUnknown *)pErrorObj)->QueryInterface(IID_ISupportErrorInfo,
        (LPVOID FAR*) &pSupportErrorInfo);
    CReleaseMe d (pSupportErrorInfo);
    if (SUCCEEDED(hr))
    {
        GetErrorInfo(0, &pErrorInfo);
        CReleaseMe r2 (pErrorInfo);
        if (pErrorInfo)
        {
            pErrorInfo->QueryInterface(IID_IErrorRecords, (LPVOID FAR*) &pErrorRecords);
            CReleaseMe r1 (pErrorRecords);
            pErrorRecords->GetRecordCount(&ulNumErrorRecs);
            DWORD dwMinor = 0;
        
            if (ulNumErrorRecs)
            {
                pErrorRecords->GetBasicErrorInfo(0, &ErrorInfo);
                
                HRESULT temp = ErrorInfo.hrError;
                
                dwMinor = ErrorInfo.dwMinor;

                switch (dwMinor)
                {
                case 99103:
                    hr = WBEM_E_ACCESS_DENIED;
                    break;
                case 99106:
                case 99107:
                case 99108:
                case 99109:
                case 99124:
                    hr = WBEM_E_INVALID_PARAMETER;
                    break;
                case 99111:
                case 99112:
                case 99114:
                    hr = WBEM_E_INVALID_PROPERTY;
                    break;
                case 99115:
                    hr = WBEM_E_INVALID_QUERY;
                    break;
                case 99116:
                case 99117:
                case 99118:
                case 99119:
                case 99120:
                case 99121:
                case 99122:
                case 99123:
                case 99127:
                case 99130:
                case 99131:
                case 99133:
                    hr = WBEM_E_INVALID_OPERATION;
                    break;
                case 99102:
                case 99110:
                case 99113:
                case 99125:
                case 99132:
                case 99134:
                    hr = WBEM_E_ALREADY_EXISTS;
                    break;
                case 99126:
                case 99104:
                case 99105:
                case 99100:
                case 99101:
                    hr = WBEM_E_INVALID_OBJECT;
                    break;
                case 99128:
                    hr = WBEM_E_CLASS_HAS_INSTANCES;
                    break;
                case 1205: // Your transaction (process ID #%d) was deadlocked with another process and has been chosen as the deadlock victim.
                    hr = WBEM_E_RERUN_COMMAND;
                    break;
                case 99129:
                    hr = WBEM_E_CIRCULAR_REFERENCE;
                    break;
                default:
                    hr = WBEM_E_INVALID_QUERY;
                    break;
                }

                if (hr == WBEM_E_INVALID_QUERY)
                {
                    for (int i = 0; i < ulNumErrorRecs; i++)
                    {
                        IErrorInfo *pErrorInfoRec = NULL;
                        BSTR sSource, sDescr;
                        pErrorRecords->GetErrorInfo(i, dwLocaleID, &pErrorInfoRec);
                        CReleaseMe r (pErrorInfoRec);
                        sSource = NULL;
                        sDescr = NULL;
                        pErrorInfoRec->GetDescription(&sDescr);
                        ERRORTRACE((LOG_WBEMCORE, "SQL Error: %S\n", (const wchar_t *)sDescr));
                        wprintf(L"SQL Error: %s\n", (const wchar_t *)sDescr);
                        pErrorInfoRec->GetSource(&sSource);
                           
                        CFreeMe f1 (sDescr), f2 (sSource);

                        SetErrorInfo(0, pErrorInfoRec);
                    }
                }
            }
        }
    }

    return hr;
}




//***************************************************************************
//
//  CSQLExecProcedure::GetHierarchy
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetHierarchy(CSQLConnection *pConn, SQL_ID dClassId)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    const WCHAR *pszCmd = L"{call sp_GetHierarchy (?, 0) }";

    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 1;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    typedef struct tagSPROCPARAMS
    {
        DB_NUMERIC dClassId;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    CSQLExecute::SetDBNumeric(sprocparams.dClassId, dClassId);

    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);    
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
        ParamOrdinals[0] = 1;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, 
                                        sizeof(SPROCPARAMS), &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
                        int iNum = 0;
        
                        while (iNum < 5)
                        {
                            hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                            CReleaseMe r2 (pIRowset);
                            if (SUCCEEDED(hr))
                                break;
                            else
                                hr = CSQLExecute::GetWMIError(pICommandText);

                            if (hr != WBEM_E_RERUN_COMMAND)
                                break;
                            iNum++;
                        }

                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                }                       
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetNextUnkeyedPath
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetNextUnkeyedPath(CSQLConnection *pConn, SQL_ID dClassId, _bstr_t &sNewPath)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    const WCHAR *pszCmd = L"{call sp_GetNextUnkeyedPath (?, ?) }";

    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 2;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    typedef struct tagSPROCPARAMS
    {
        DB_NUMERIC dClassId;
        BSTR       wNewPath;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    CSQLExecute::SetDBNumeric(sprocparams.dClassId, dClassId);

    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);    
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
        ParamOrdinals[0] = 1;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_WVARCHAR", L"@NewPath", 450, DBPARAMFLAGS_ISOUTPUT, 11);
        ParamOrdinals[1] = 2;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(SPROCPARAMS, wNewPath), DBPARAMIO_OUTPUT, 450, DBTYPE_BSTR, 11);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(SPROCPARAMS), 
                                        &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        CFreeMe f1 (sprocparams.wNewPath);
                        if (SUCCEEDED(hr))
                            sNewPath = (const wchar_t *)sprocparams.wNewPath;
                        else
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                    else
                        hr = CSQLExecute::GetWMIError(pIAccessor);
                }                       
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetNextKeyhole
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetNextKeyhole(CSQLConnection *pConn, DWORD iPropertyId, SQL_ID &dNewId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    const WCHAR *pszCmd = L"{call sp_GetNextKeyhole (?, ?) }";

    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 2;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    typedef struct tagSPROCPARAMS
    {
        DB_NUMERIC dRetVal;
        int        iPropertyId;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    sprocparams.iPropertyId = iPropertyId;

    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);   
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_NUMERIC", L"@NextID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISOUTPUT, 20);
        ParamOrdinals[1] = 2;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_I4", L"@PropID", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[0] = 1;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(SPROCPARAMS, dRetVal), DBPARAMIO_OUTPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, iPropertyId), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(SPROCPARAMS), 
                                        &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        if (SUCCEEDED(hr))
                            dNewId = CSQLExecute::GetInt64(&(sprocparams.dRetVal));
                        else
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                    else
                        hr = CSQLExecute::GetWMIError(pIAccessor);
                }                       
            }
        }
    }

    return hr;
}

HRESULT CSQLExecProcedure::GetObjectIdByPath (CSQLConnection *pConn, LPCWSTR lpPath, 
                                              SQL_ID &dObjectId, SQL_ID &dClassId, SQL_ID *dScopeId, BOOL *bDeleted)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    const WCHAR *pszCmd = L"{call sp_GetInstanceID (?, ?, ?, ?) }";

    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pIDBCreate = NULL;
    IDBCreateCommand *pIDBCreateCommand = NULL;
    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 4;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    typedef struct tagSPROCPARAMS
    {
        BSTR       sPath;
        DB_NUMERIC dObjectId;
        DB_NUMERIC dClassId;
        DB_NUMERIC dScopeId;

    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    sprocparams.sPath = SysAllocString(lpPath);
    CFreeMe f1 (sprocparams.sPath);

    hr = pDBInit->QueryInterface(IID_IDBCreateSession,
            (void**) &pIDBCreate);
    CReleaseMe r1 (pIDBCreate);
    if (SUCCEEDED(hr))
    {
        hr = pIDBCreate->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pIDBCreateCommand);    
        CReleaseMe r2 (pIDBCreateCommand);
        if (SUCCEEDED(hr))
        {            
            hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
                (IUnknown**) &pICommandText);    
            CReleaseMe r3 (pICommandText);
            if (SUCCEEDED(hr))
            {               
                pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);

                CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_BSTR", L"@ObjectKey", 450, DBPARAMFLAGS_ISINPUT, 11);
                ParamOrdinals[0] = 1;
                CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_NUMERIC", L"@ObjectId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISOUTPUT, 20);
                ParamOrdinals[1] = 2;
                CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_NUMERIC", L"@ClassId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISOUTPUT, 20);
                ParamOrdinals[2] = 3;
                CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_NUMERIC", L"@ScopeId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISOUTPUT, 20);
                ParamOrdinals[3] = 4;

                if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
                {
                    CReleaseMe r4 (pICommandWithParams);
                    if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
                    {
                        for(i = 0; i < nParams; i++)
                            CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                        
                        CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, sPath), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
                        CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(SPROCPARAMS, dObjectId), DBPARAMIO_OUTPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                        CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(SPROCPARAMS, dClassId), DBPARAMIO_OUTPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                        CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(SPROCPARAMS, dScopeId), DBPARAMIO_OUTPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);

                        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                        CReleaseMe r5 (pIAccessor);
                        if (SUCCEEDED(hr))
                        {
                            hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(SPROCPARAMS), 
                                                &hAccessor,acDBBindStatus);
                            if (SUCCEEDED(hr))
                            {
                                Params.pData = &sprocparams;
                                Params.cParamSets = 1;
                                Params.hAccessor = hAccessor;
                
                                hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                                CReleaseMe r6 (pIRowset);
                                if (SUCCEEDED(hr))
                                {                                    
                                    dObjectId = CSQLExecute::GetInt64(&(sprocparams.dObjectId));
                                    dClassId = CSQLExecute::GetInt64(&(sprocparams.dClassId));
                                    if (dScopeId)
                                        *dScopeId = CSQLExecute::GetInt64(&(sprocparams.dScopeId));
                                }
                                else
                                    hr = CSQLExecute::GetWMIError(pICommandText);
                                pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                            }
                            else
                                hr = CSQLExecute::GetWMIError(pIAccessor);
                        }                       
                    }
                }
            }
        }        
    }            

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::DeleteProperty
//
//***************************************************************************

HRESULT CSQLExecProcedure::DeleteProperty(CSQLConnection *pConn, DWORD iPropertyId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    const WCHAR *pszCmd = L"{call sp_DeleteClassData (?) }";

    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 1;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;
    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();

    typedef struct tagSPROCPARAMS
    {
        int iPropertyId;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams = {iPropertyId};
    
    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText); 
    CReleaseMe r1 (pICommandText);    
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_I4", L"@PropertyID", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[0] = 1;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, iPropertyId), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 20);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, 
                                        sizeof(SPROCPARAMS), &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        if (FAILED(hr))
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                }                       
            }
        }
    }

    return hr;
}


//***************************************************************************
//
//  CSQLExecProcedure::DeleteInstanceData
//
//***************************************************************************

HRESULT CSQLExecProcedure::DeleteInstanceData (CSQLConnection *pConn, SQL_ID dObjectId, 
                                               DWORD iPropertyId, DWORD iPos)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    const WCHAR *pszCmd = L"{call sp_DeleteInstanceData (?, ?, ?) }";

    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 3;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;
    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();

    typedef struct tagSPROCPARAMS
    {
        DB_NUMERIC dObjectId;
        int        iPropertyId;
        int        iPos;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    sprocparams.iPropertyId = iPropertyId;
    sprocparams.iPos = iPos;
    CSQLExecute::SetDBNumeric(sprocparams.dObjectId, dObjectId);
    
    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);    
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ObjectID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
        ParamOrdinals[0] = 1;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_I4", L"@PropertyID", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[1] = 2;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_I4", L"@ArrayPos", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[2] = 3;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, dObjectId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(SPROCPARAMS, iPropertyId), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
                CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(SPROCPARAMS, iPos), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, 
                                        sizeof(SPROCPARAMS), &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        if (FAILED(hr))
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                }                       
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::InsertClass
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertClass (CSQLConnection *pConn, LPCWSTR lpClassName, LPCWSTR lpObjectKey, 
                                        LPCWSTR lpObjectPath, SQL_ID dScopeID,
                                        SQL_ID dParentClassId, SQL_ID dDynastyId, DWORD iState, BYTE *pClassBuff, DWORD dwClassBuffLen, 
                                        DWORD iClassFlags, DWORD iInsertFlags, SQL_ID &dNewId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    const WCHAR *pszCmd = L"{call sp_InsertClass (?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?) }";
    const ULONG nParams = 10;
    
    STRUCTINSERTCLASS params;
    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_INSERT_CLASS);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_INSERT_CLASS);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_INSERT_CLASS);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_INSERT_CLASS);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    dNewId = CRC64::GenerateHashValue(lpObjectKey);
    CSQLExecute::SetDBNumeric(params.dRetVal, dNewId);
    params.sClassName = SysAllocString(lpClassName);
    params.sObjectKey = SysAllocString(lpObjectKey);
    params.sObjectPath = SysAllocString(lpObjectPath);
    params.pClassBuff = pClassBuff;
    CSQLExecute::SetDBNumeric(params.dScopeID, dScopeID);
    CSQLExecute::SetDBNumeric(params.dParentClassId, dParentClassId);
    params.iClassState = iState;
    params.iClassFlags = iClassFlags;
    params.iInsertFlags = iInsertFlags;

    CFreeMe f1 (params.sClassName), f2 (params.sObjectKey), f3 (params.sObjectPath);

    for (i = 0; i < nParams; i++)
        ParamOrdinals[i] = i+1;

    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_BSTR", L"@ClassName", 450, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_BSTR", L"@ObjectKey", 450, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_BSTR", L"@ObjectPath", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_NUMERIC", L"@ScopeObjID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[4], L"DBTYPE_NUMERIC", L"@ParentID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[5], L"DBTYPE_I4", L"@ClassState", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[6], L"DBTYPE_LONGVARBINARY", L"@ClassBuffer", 0, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[7], L"DBTYPE_I4", L"@ClassFlags", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[8], L"DBTYPE_I4", L"@InsertFlags", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[9], L"DBTYPE_NUMERIC", L"@ObjectId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTINSERTCLASS, sClassName), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTINSERTCLASS, sObjectKey), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(STRUCTINSERTCLASS, sObjectPath), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(STRUCTINSERTCLASS, dScopeID), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[4], 5, offsetof(STRUCTINSERTCLASS, dParentClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[5], 6, offsetof(STRUCTINSERTCLASS, iClassState), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[6], 7, offsetof(STRUCTINSERTCLASS, pClassBuff), DBPARAMIO_INPUT, 0, DBTYPE_BYTES, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[7], 8, offsetof(STRUCTINSERTCLASS, iClassFlags), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[8], 9, offsetof(STRUCTINSERTCLASS, iInsertFlags), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[9], 10, offsetof(STRUCTINSERTCLASS, dRetVal), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);

    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_INSERT_CLASS, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_INSERT_CLASS, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_INSERT_CLASS, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTINSERTCLASS), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_INSERT_CLASS, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &params;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        int iNum = 0;
        while (iNum < 5)
        {
            // Try this query up to 5 times, in case we get a deadlock.

            hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
            CReleaseMe r4 (pIRowset);
            if (SUCCEEDED(hr))
                break;
            else
                hr = CSQLExecute::GetWMIError(pICommandText);

            if (hr != WBEM_E_RERUN_COMMAND)
                break;

            iNum++;
            Sleep(iNum*100);
        } 
        
        if(SUCCEEDED(hr))
        {
            wchar_t wBuff[256];
            swprintf(wBuff, L"select ClassBlob from ClassMap "
                            L" where ClassId = %I64d", dNewId);
            if (SUCCEEDED(hr))
            {
                hr = CSQLExecute::WriteImageValue 
                        (((COLEDBConnection *)pConn)->GetCommand(), wBuff, 1, pClassBuff, dwClassBuffLen);
            }
        }
    }

    return hr;
}



//***************************************************************************
//
//  CSQLExecProcedure::InsertClassData
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertClassData (CSQLConnection *pConn, IWbemClassObject *pObj, CSchemaCache *pCache, SQL_ID dScopeId, 
                                            SQL_ID dClassId, LPCWSTR lpPropName, 
                                            DWORD CIMType, DWORD StorageType,LPCWSTR lpValue, SQL_ID dRefClassId, DWORD iPropID, 
                                            DWORD iFlags, DWORD iFlavor, BOOL iSkipValid, DWORD &iNewPropId, SQL_ID dOrigClassId,
                                            BOOL *bIsKey)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    const WCHAR *pszCmd = L"{? = call sp_InsertClassData (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }";
    const ULONG nParams = 12;

    BOOL bLocal = FALSE;
    BOOL bKey = FALSE;

    if (pCache)
         pCache->IsKey(dClassId, iNewPropId, bLocal);
    
    if (iFlags & REPDRVR_FLAG_KEY)
    {
        if (!bKey)
            bKey = TRUE;
        else if (bKey && !bLocal)
            bKey = FALSE;
    }
    if (bIsKey)
        *bIsKey = bKey;

    STRUCTINSERTCLASSDATA params;
    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_INSERT_CLASSDATA);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_INSERT_CLASSDATA);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_INSERT_CLASSDATA);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_INSERT_CLASSDATA);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    bool bStoreTextAsImage = false;

    params.sPropName = SysAllocString(lpPropName);
    if (lpValue)
        params.sValue = OLEDBTruncateLongText(lpValue, SQL_STRING_LIMIT, bStoreTextAsImage);
    else
        params.sValue = SysAllocString(L"");
    CFreeMe f1 (params.sPropName), f2 (params.sValue);

    CSQLExecute::SetDBNumeric(params.dClassId, dClassId);
    CSQLExecute::SetDBNumeric(params.dRefClassId, dRefClassId);
    params.iCimType = CIMType;
    params.iStorageType = StorageType;
    params.iPropID = iPropID;
    params.iFlags = iFlags;
    params.iFlavor = iFlavor;
    params.iRetVal = 0;
    params.iKnownID = iNewPropId;
    params.bIsKey = bKey;

    for (i = 0; i < nParams; i++)
        ParamOrdinals[i] = i+1;

    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_I4", L"ReturnVal", sizeof(DWORD), DBPARAMFLAGS_ISOUTPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_BSTR", L"@PropName", 450, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_I4", L"@CIMType", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[4], L"DBTYPE_I4", L"@StorageType", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[5], L"DBTYPE_BSTR", L"@Value", 450, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[6], L"DBTYPE_NUMERIC", L"@RefClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[7], L"DBTYPE_I4", L"@PropID", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[8], L"DBTYPE_I4", L"@Flags", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[9], L"DBTYPE_I4", L"@Flavor", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[10], L"DBTYPE_I4", L"@PropertyId", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[11], L"DBTYPE_BOOL", L"@IsKey", sizeof(BOOL), DBPARAMFLAGS_ISINPUT, 1);

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTINSERTCLASSDATA, iRetVal), DBPARAMIO_OUTPUT, sizeof(DWORD), DBTYPE_I4, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTINSERTCLASSDATA, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(STRUCTINSERTCLASSDATA, sPropName), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(STRUCTINSERTCLASSDATA, iCimType), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[4], 5, offsetof(STRUCTINSERTCLASSDATA, iStorageType), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[5], 6, offsetof(STRUCTINSERTCLASSDATA, sValue), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[6], 7, offsetof(STRUCTINSERTCLASSDATA, dRefClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[7], 8, offsetof(STRUCTINSERTCLASSDATA, iPropID), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[8], 9, offsetof(STRUCTINSERTCLASSDATA, iFlags), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[9], 10, offsetof(STRUCTINSERTCLASSDATA, iFlavor), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[10], 11, offsetof(STRUCTINSERTCLASSDATA, iKnownID), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[11], 12, offsetof(STRUCTINSERTCLASSDATA, bIsKey), DBPARAMIO_INPUT, sizeof(BOOL), DBTYPE_BOOL, 1);

    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_INSERT_CLASSDATA, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_INSERT_CLASSDATA, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_INSERT_CLASSDATA, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTINSERTCLASSDATA), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_INSERT_CLASSDATA, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &params;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        int iNum = 0;
        while (iNum < 5)
        {
            // Try this query up to 5 times, in case we get a deadlock.

            hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
            CReleaseMe r4 (pIRowset);
            if (SUCCEEDED(hr))
            {
                iNewPropId = params.iRetVal;
                break;
            }
            else
                hr = CSQLExecute::GetWMIError(pICommandText);

            if (hr != WBEM_E_RERUN_COMMAND)
                break;

            iNum++;
            Sleep(iNum*100);
        }    
    }

    // If we need to store the default value as an image,
    // do it now.

    if (bStoreTextAsImage && lpValue)
    {
        hr = InsertBlobData (pConn, 1, dClassId, iNewPropId, NULL, 0, 0);

        wchar_t wSQL[1024];
        swprintf(wSQL, L"select PropertyImageValue from ClassImages where ObjectId = %I64d and PropertyId = %ld",
                        dClassId, iNewPropId);
               
        hr = CSQLExecute::WriteImageValue(pCmd, wSQL, 1, (BYTE *)lpValue, wcslen(lpValue)*2);


    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::InsertBlobData
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertBlobData (CSQLConnection *pConn, SQL_ID dClassId, SQL_ID dObjectId, 
                                           DWORD iPropertyId, BYTE *pImage, DWORD iPos, DWORD dwNumBytes)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    const WCHAR *pszCmd = L"{call sp_InsertInstanceBlobData (?, ?, ?, ?, ?) }";
    const ULONG nParams = 5;

    STRUCTINSERTBLOB params;
    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_INSERT_BLOBDATA);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_INSERT_BLOBDATA);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_INSERT_BLOBDATA);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_INSERT_BLOBDATA);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    CSQLExecute::SetDBNumeric(params.dClassId, dClassId);
    CSQLExecute::SetDBNumeric(params.dObjectId, dObjectId);
    params.iPropertyId = iPropertyId;
    params.iPos = iPos;
    params.pImage = pImage;

    for (i = 0; i < nParams; i++)
        ParamOrdinals[i] = i+1;

    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_NUMERIC", L"@ObjectID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_I4", L"@PropertyID", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_LONGVARBINARY", L"@Value", dwNumBytes, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[4], L"DBTYPE_I4", L"@ArrayPos", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 11);

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTINSERTBLOB, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTINSERTBLOB, dObjectId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(STRUCTINSERTBLOB, iPropertyId), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(STRUCTINSERTBLOB, pImage), DBPARAMIO_INPUT, dwNumBytes, DBTYPE_BYTES, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[4], 5, offsetof(STRUCTINSERTBLOB, iPos), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);

    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_INSERT_BLOBDATA, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_INSERT_BLOBDATA, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_INSERT_BLOBDATA, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTINSERTBLOB), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_INSERT_BLOBDATA, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &params;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
        CReleaseMe r4 (pIRowset);
        if (FAILED(hr))
            hr = CSQLExecute::GetWMIError(pICommandText);
    }
    return hr;
}



//***************************************************************************
//
//  CSQLExecProcedure::InsertPropertyBatch
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertPropertyBatch (CSQLConnection *pConn, LPCWSTR lpObjectKey, 
                                                LPCWSTR lpPath, LPCWSTR lpClassName, SQL_ID dClassId, 
                                                SQL_ID dScopeId, DWORD iFlags, 
                                                InsertPropValues *pVals, DWORD iNumVals, 
                                                SQL_ID &dNewObjectId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    const WCHAR *pszCmd = L"{call sp_BatchInsertProperty (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,"
        L"?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }";
    const ULONG nParams = 23;

    STRUCTINSERTPROPBATCH sp;
    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_INSERT_PROPBATCH);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_INSERT_PROPBATCH);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_INSERT_PROPBATCH);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_INSERT_PROPBATCH);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    dNewObjectId = CRC64::GenerateHashValue(lpObjectKey);
    CSQLExecute::SetDBNumeric(sp.dObjectId, dNewObjectId);
    CSQLExecute::SetDBNumeric(sp.dClassId, dClassId);
    CSQLExecute::SetDBNumeric(sp.dScopeId, dScopeId);
    sp.sObjectPath = SysAllocString(lpPath);
    sp.sObjectKey = SysAllocString(lpObjectKey);
    sp.bInit = TRUE;

    for (i = 0; i < 5; i++)
        sp.sPropValue[i] = NULL;
    sp.iInsertFlags = iFlags;

    // Grab only the first part of the key string - up to the class name.
    wchar_t *pTmp = wcsstr(lpObjectKey, lpClassName);
    if (pTmp)
    {
        int iLen = pTmp - lpObjectKey;
        wchar_t *pNew = new wchar_t [iLen+1];
        CDeleteMe <wchar_t> d (pNew);
        if (pNew)
        {
            wcsncpy(pNew, lpObjectKey, iLen);
            pNew[iLen] = L'\0';
            sp.sCompKey = SysAllocString(pNew);
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        wchar_t *pNew = new wchar_t [ wcslen(lpObjectKey) + 2];
        CDeleteMe <wchar_t> d (pNew);
        if (pNew)
        {
            swprintf(pNew, L"%s?", lpObjectKey);
            sp.sCompKey = SysAllocString(pNew); 
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    CFreeMe f1 (sp.sObjectPath), f2 (sp.sObjectKey), f3 (sp.sCompKey);

    for (i = 0; i < nParams; i++)
        ParamOrdinals[i] = i+1;

    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ObjectId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_BSTR", L"@ObjectKey", 450, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_BSTR", L"@ObjectPath", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[4], L"DBTYPE_NUMERIC", L"@ScopeID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[5], L"DBTYPE_I4", L"@InsertFlags", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[6], L"DBTYPE_BOOL", L"@Init", sizeof(BOOL), DBPARAMFLAGS_ISINPUT, 1);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[7], L"DBTYPE_I4", L"@PropID1", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[8], L"DBTYPE_BSTR", L"@PropValue1", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[9], L"DBTYPE_I4", L"@PropPos1", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[10], L"DBTYPE_I4", L"@PropID2", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[11], L"DBTYPE_BSTR", L"@PropValue2", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[12], L"DBTYPE_I4", L"@PropPos2", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[13], L"DBTYPE_I4", L"@PropID3", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[14], L"DBTYPE_BSTR", L"@PropValue3", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[15], L"DBTYPE_I4", L"@PropPos3", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[16], L"DBTYPE_I4", L"@PropID4", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[17], L"DBTYPE_BSTR", L"@PropValue4", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[18], L"DBTYPE_I4", L"@PropPos4", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[19], L"DBTYPE_I4", L"@PropID5", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[20], L"DBTYPE_BSTR", L"@PropValue5", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[21], L"DBTYPE_I4", L"@PropPos5", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[22], L"DBTYPE_BSTR", L"@CompKey", 450, DBPARAMFLAGS_ISINPUT, 11);

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);

    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTINSERTPROPBATCH, dObjectId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTINSERTPROPBATCH, sObjectKey), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(STRUCTINSERTPROPBATCH, sObjectPath), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(STRUCTINSERTPROPBATCH, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[4], 5, offsetof(STRUCTINSERTPROPBATCH, dScopeId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[5], 6, offsetof(STRUCTINSERTPROPBATCH, iInsertFlags), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[6], 7, offsetof(STRUCTINSERTPROPBATCH, bInit), DBPARAMIO_INPUT, sizeof(BOOL), DBTYPE_BOOL, 1);
    CSQLExecute::SetBindingInfo(&acDBBinding[7], 8, offsetof(STRUCTINSERTPROPBATCH, iPropId[0]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[8], 9, offsetof(STRUCTINSERTPROPBATCH, sPropValue[0]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[9], 10, offsetof(STRUCTINSERTPROPBATCH, iPos[0]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[10], 11, offsetof(STRUCTINSERTPROPBATCH, iPropId[1]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[11], 12, offsetof(STRUCTINSERTPROPBATCH, sPropValue[1]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[12], 13, offsetof(STRUCTINSERTPROPBATCH, iPos[1]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[13], 14, offsetof(STRUCTINSERTPROPBATCH, iPropId[2]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[14], 15, offsetof(STRUCTINSERTPROPBATCH, sPropValue[2]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[15], 16, offsetof(STRUCTINSERTPROPBATCH, iPos[2]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[16], 17, offsetof(STRUCTINSERTPROPBATCH, iPropId[3]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[17], 18, offsetof(STRUCTINSERTPROPBATCH, sPropValue[3]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[18], 19, offsetof(STRUCTINSERTPROPBATCH, iPos[3]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[19], 20, offsetof(STRUCTINSERTPROPBATCH, iPropId[4]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[20], 21, offsetof(STRUCTINSERTPROPBATCH, sPropValue[4]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[21], 22, offsetof(STRUCTINSERTPROPBATCH, iPos[4]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[22], 23, offsetof(STRUCTINSERTPROPBATCH, sCompKey), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);

    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_INSERT_PROPBATCH, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_INSERT_PROPBATCH, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_INSERT_PROPBATCH, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTINSERTPROPBATCH), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_INSERT_PROPBATCH, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &sp;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        i = 0;
        int j = 0;

        while (TRUE)
        {                                    
            // Set 5 parameters at a time.  
            for (j = 0; j < 5 && i < iNumVals; i++, j++)
            {
                SysFreeString(sp.sPropValue[j]);
                sp.iPropId[j] = pVals[i].iPropID;                                

                if (pVals[i].pRefKey != NULL)
                {
                    // We need to format the reference key and original value into this parameter.
                    LPWSTR lpTemp = pVals[i].pValue;
                    pVals[i].pValue = new wchar_t [wcslen(pVals[i].pValue) + wcslen(pVals[i].pRefKey) + 2];
                    if (pVals[i].pValue)
                        swprintf(pVals[i].pValue, L"%s?%s", lpTemp, pVals[i].pRefKey);
                    delete lpTemp;
                }

                sp.sPropValue[j] = OLEDBTruncateLongText(pVals[i].pValue, SQL_STRING_LIMIT, pVals[i].bLong);
                sp.iPos[j] = pVals[i].iPos;
            }

            // Clear other values
            for (; ((j % 5) || j == 0); j++)
            {
                sp.iPropId[j] = 0;
                if (sp.sPropValue[j])
                    SysFreeString(sp.sPropValue[j]);
                sp.sPropValue[j] = SysAllocString(L"");
                sp.iPos[j] = 0;
            }
            int iNum = 0;

            while (iNum < 5)
            {
                hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                CReleaseMe r4 (pIRowset);
                if (SUCCEEDED(hr))
                    break;
                else
                    hr = CSQLExecute::GetWMIError(pICommandText);

                if (hr != WBEM_E_RERUN_COMMAND)
                    break;

                iNum++;
                Sleep(iNum*100);
            }

            if (FAILED(hr) || i >= iNumVals)
                break;

            sp.bInit = FALSE;
            sp.iInsertFlags = 0;
        }
    }

    for (i = 0; i < 5; i++)
        SysFreeString(sp.sPropValue[i]);

    for (i = 0; i < iNumVals; i++)
    {
        // If our text was truncated, we need to store it as an image.
        if (pVals[i].bLong)
        {
            if (pVals[i].pValue && wcslen(pVals[i].pValue)*2)
            {
                hr = InsertBlobData (pConn, dClassId, dNewObjectId, pVals[i].iPropID, NULL, 0, 0);

                wchar_t wSQL[1024];
                swprintf(wSQL, L"select PropertyImageValue from ClassImages where ObjectId = %I64d and PropertyId = %ld",
                                dNewObjectId, pVals[i].iPropID);
               
                hr = CSQLExecute::WriteImageValue(pCmd, wSQL, 1, (BYTE *)pVals[i].pValue, wcslen(pVals[i].pValue)*2+2);
            }
            else 
            {
                hr = InsertBlobData (pConn, dClassId, dNewObjectId, pVals[i].iPropID, NULL, 0, 0);
            }
        }
        delete pVals[i].pValue;
        delete pVals[i].pRefKey;
    }

    return hr;
}


//***************************************************************************
//
//  CSQLExecProcedure::InsertBatch
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertBatch (CSQLConnection *pConn, SQL_ID dObjectId, SQL_ID dScopeId, SQL_ID dClassId,
                                                 InsertQfrValues *pVals, DWORD iNumVals)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    // Batch & execute if iNumVals > 5

    const WCHAR *pszCmd = L"{call sp_BatchInsert (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, "
        L"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }";
    const ULONG nParams = 28;

    STRUCTINSERTBATCH sp;
    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_INSERT_BATCH);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_INSERT_BATCH);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_INSERT_BATCH);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_INSERT_BATCH);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    CSQLExecute::SetDBNumeric(sp.dObjectId, dObjectId);
    CSQLExecute::SetDBNumeric(sp.dScopeId, dScopeId);
    CSQLExecute::SetDBNumeric(sp.dClassId, dClassId);
     for (i = 0; i < 5; i++)
        sp.sPropValue[i] = NULL;

    for (i = 0; i < nParams; i++)
        ParamOrdinals[i] = i+1;

    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ObjectId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_NUMERIC", L"@ScopeID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_I4", L"@QfrID1", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[4], L"DBTYPE_BSTR", L"@QfrValue1", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[5], L"DBTYPE_I4", L"@Flavor1", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[6], L"DBTYPE_I4", L"@PropID1", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[7], L"DBTYPE_I4", L"@QfrPos1", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[8], L"DBTYPE_I4", L"@QfrID2", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[9], L"DBTYPE_BSTR", L"@QfrValue2", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[10], L"DBTYPE_I4", L"@Flavor2", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[11], L"DBTYPE_I4", L"@PropID2", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[12], L"DBTYPE_I4", L"@QfrPos2", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[13], L"DBTYPE_I4", L"@QfrID3", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[14], L"DBTYPE_BSTR", L"@QfrValue3", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[15], L"DBTYPE_I4", L"@Flavor3", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[16], L"DBTYPE_I4", L"@PropID3", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[17], L"DBTYPE_I4", L"@QfrPos3", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[18], L"DBTYPE_I4", L"@QfrID4", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[19], L"DBTYPE_BSTR", L"@QfrValue4", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[20], L"DBTYPE_I4", L"@Flavor4", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[21], L"DBTYPE_I4", L"@PropID4", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[22], L"DBTYPE_I4", L"@QfrPos4", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[23], L"DBTYPE_I4", L"@QfrID5", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[24], L"DBTYPE_BSTR", L"@QfrValue5", 4000, DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[25], L"DBTYPE_I4", L"@Flavor5", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[26], L"DBTYPE_I4", L"@PropID5", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);
    CSQLExecute::SetParamBindInfo(ParamBindInfo[27], L"DBTYPE_I4", L"@QfrPos5", sizeof(DWORD), DBPARAMFLAGS_ISINPUT, 11);

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTINSERTBATCH, dObjectId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTINSERTBATCH, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(STRUCTINSERTBATCH, dScopeId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(STRUCTINSERTBATCH, iPropId[0]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[4], 5, offsetof(STRUCTINSERTBATCH, sPropValue[0]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[5], 6, offsetof(STRUCTINSERTBATCH, iFlavor[0]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[6], 7, offsetof(STRUCTINSERTBATCH, iQfrId[0]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[7], 8, offsetof(STRUCTINSERTBATCH, iPos[0]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[8], 9, offsetof(STRUCTINSERTBATCH, iPropId[1]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[9], 10, offsetof(STRUCTINSERTBATCH, sPropValue[1]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[10], 11, offsetof(STRUCTINSERTBATCH, iFlavor[1]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[11], 12, offsetof(STRUCTINSERTBATCH, iQfrId[1]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[12], 13, offsetof(STRUCTINSERTBATCH, iPos[1]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[13], 14, offsetof(STRUCTINSERTBATCH, iPropId[2]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[14], 15, offsetof(STRUCTINSERTBATCH, sPropValue[2]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[15], 16, offsetof(STRUCTINSERTBATCH, iFlavor[2]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[16], 17, offsetof(STRUCTINSERTBATCH, iQfrId[2]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[17], 18, offsetof(STRUCTINSERTBATCH, iPos[2]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[18], 19, offsetof(STRUCTINSERTBATCH, iPropId[3]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[19], 20, offsetof(STRUCTINSERTBATCH, sPropValue[3]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[20], 21, offsetof(STRUCTINSERTBATCH, iFlavor[3]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[21], 22, offsetof(STRUCTINSERTBATCH, iQfrId[3]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[22], 23, offsetof(STRUCTINSERTBATCH, iPos[3]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[23], 24, offsetof(STRUCTINSERTBATCH, iPropId[4]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[24], 25, offsetof(STRUCTINSERTBATCH, sPropValue[4]), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[25], 26, offsetof(STRUCTINSERTBATCH, iFlavor[4]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[26], 27, offsetof(STRUCTINSERTBATCH, iQfrId[4]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);
    CSQLExecute::SetBindingInfo(&acDBBinding[27], 28, offsetof(STRUCTINSERTBATCH, iPos[4]), DBPARAMIO_INPUT, sizeof(DWORD), DBTYPE_I4, 11);


    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_INSERT_BATCH, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_INSERT_BATCH, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_INSERT_BATCH, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTINSERTBATCH), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_INSERT_BATCH, hAccessor);
    }
    
    if (SUCCEEDED(hr))
    {
        Params.pData = &sp;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        i = 0;
        int j = 0;

        while (TRUE)
        {                                    
            // Set 5 parameters at a time.  
            for (j = 0; j < 5 && i < iNumVals; i++, j++)
            {
                if (pVals[i].pRefKey != NULL)
                {
                    // We need to format the reference key and original value into this parameter.
                    LPWSTR lpTemp = pVals[i].pValue;
                    pVals[i].pValue = new wchar_t [wcslen(pVals[i].pValue) + wcslen(pVals[i].pRefKey) + 2];
                    if (pVals[i].pValue)
                        swprintf(pVals[i].pValue, L"%s?%s", lpTemp, pVals[i].pRefKey);
                    delete lpTemp;
                }

                SysFreeString(sp.sPropValue[j]);
                sp.iPropId[j] = pVals[i].iPropID;
                sp.sPropValue[j] = OLEDBTruncateLongText(pVals[i].pValue, SQL_STRING_LIMIT, pVals[i].bLong);
                sp.iPos[j] = pVals[i].iPos;
                sp.iFlavor[j] = pVals[i].iFlavor;
                sp.iQfrId[j] = pVals[i].iQfrID;
            }

            // Clear other values
            for (; ((j % 5) || j == 0); j++)
            {
                sp.iPropId[j] = 0;
                if (sp.sPropValue[j])
                    SysFreeString(sp.sPropValue[j]);
                sp.sPropValue[j] = SysAllocString(L"");
                sp.iPos[j] = 0;
                sp.iFlavor[j] = 0;
                sp.iQfrId[j] = 0;
            }

            hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
            CReleaseMe r4 (pIRowset);
            if (FAILED(hr))
                hr = CSQLExecute::GetWMIError(pICommandText);

            if (FAILED(hr) || i >= iNumVals)
                break;
        }
    }

    for (i = 0; i < 5; i++)
        SysFreeString(sp.sPropValue[i]);

    // If our text was truncated, we need to store it as an image.
    for (i = 0; i < iNumVals; i++)
    {
        if (pVals[i].bLong)
        {
            if (pVals[i].pValue && wcslen(pVals[i].pValue)*2)
            {
                hr = InsertBlobData (pConn, dClassId, dObjectId, pVals[i].iPropID, NULL, 0, 0);

                wchar_t wSQL[1024];
                swprintf(wSQL, L"select PropertyImageValue from ClassImages where ObjectId = %I64d and PropertyId = %ld",
                                dObjectId, pVals[i].iPropID);
               
                hr = CSQLExecute::WriteImageValue(pCmd, wSQL, 1, (BYTE *)pVals[i].pValue, wcslen(pVals[i].pValue)*2+2);
            }
            else 
            {
                hr = InsertBlobData (pConn, dClassId, dObjectId, pVals[i].iPropID, NULL, 0, 0);
            }
        }
        
        delete pVals[i].pValue;
        delete pVals[i].pRefKey;
    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetClassInfo
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetClassInfo (CSQLConnection *pConn, SQL_ID dClassId, SQL_ID &dSuperClassId, BYTE **pBuffer, DWORD &dwBuffLen)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    const WCHAR *pszCmd = L"{call sp_GetClassInfo (?) }";
    const ULONG nParams = 1;

    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_GETCLASSOBJECT);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_GETCLASSOBJECT);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_GETCLASSOBJECT);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_GETCLASSOBJECT);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;
    STRUCTHASINSTANCES params;

    CSQLExecute::SetDBNumeric(params.dClassId, dClassId);

    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ClassId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    ParamOrdinals[0] = 1;

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTHASINSTANCES, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);


    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_GETCLASSOBJECT, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_GETCLASSOBJECT, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_GETCLASSOBJECT, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTHASINSTANCES), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_GETCLASSOBJECT, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &params;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
        CReleaseMe r4 (pIRowset);
        if (SUCCEEDED(hr))
        {
            HROW *pRow = NULL;
            VARIANT vTemp;
            CClearMe c (&vTemp);
            IMalloc *pMalloc = NULL;
            CoGetMalloc(MEMCTX_TASK, &pMalloc);

            hr = CSQLExecute::GetColumnValue(pIRowset, 1, pMalloc, &pRow, vTemp);            
            if (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
            {                
                dSuperClassId = _wtoi64(vTemp.bstrVal);
                hr =  CSQLExecute::ReadImageValue (pIRowset, 2, &pRow, pBuffer, dwBuffLen);
                pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            }
            pMalloc->Release();
        }
        else
            hr = CSQLExecute::GetWMIError(pICommandText);
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::HasInstances
//
//***************************************************************************

HRESULT CSQLExecProcedure::HasInstances(CSQLConnection *pConn, SQL_ID dClassId, SQL_ID *pDerivedIds, DWORD iNumDerived, BOOL &bInstancesExist)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    bInstancesExist = FALSE;
    const WCHAR *pszCmd = L"{call sp_HasInstances (?, ?) }";
    const ULONG nParams = 2;

    STRUCTHASINSTANCES params;

    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_HAS_INSTANCES);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_HAS_INSTANCES);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_HAS_INSTANCES);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_HAS_INSTANCES);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    CSQLExecute::SetDBNumeric(params.dClassId, dClassId);
    params.dwHasInst = 0;
    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ClassId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    ParamOrdinals[0] = 1;
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_I4", L"@HasInst", sizeof(DWORD), DBPARAMFLAGS_ISOUTPUT, 11);
    ParamOrdinals[1] = 2;

    // Instantiate any of the interfaces that don't exist already.
    // and stick them in the cache.

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTHASINSTANCES, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTHASINSTANCES, dwHasInst), DBPARAMIO_OUTPUT, sizeof(DWORD), DBTYPE_I4, 11);

    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_HAS_INSTANCES, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_HAS_INSTANCES, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_HAS_INSTANCES, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTHASINSTANCES), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_HAS_INSTANCES, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &params;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
        CReleaseMe r4 (pIRowset);
        if (SUCCEEDED(hr))
        {
            bInstancesExist = params.dwHasInst;
        }
        else
            hr = CSQLExecute::GetWMIError(pICommandText);
    }
    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::CheckKeyMigration
//
//***************************************************************************

HRESULT CSQLExecProcedure::CheckKeyMigration(CSQLConnection *pConn, LPWSTR lpObjectKey, LPWSTR lpClassName, SQL_ID dClassId,
                            SQL_ID dScopeID, SQL_ID *pIDs, DWORD iNumIDs)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Strip the classname out of the key string,
    // and send it to the procedure to check for existing key combinations in this class hierarchy.
//  CREATE PROCEDURE sp_CheckKeyMigration  @ScopeID numeric, @ClassID numeric,  @KeyString nvarchar(450),  @RetVal int output

    const WCHAR *pszCmd = L"{call sp_CheckKeyMigration (?, ?, ?, ?) }";

    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 4;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    typedef struct tagSPROCPARAMS
    {
        DB_NUMERIC dClassId;
        DB_NUMERIC dScopeId;
        BSTR       sKeyString;
        DWORD      dwRetVal;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    CSQLExecute::SetDBNumeric(sprocparams.dClassId, dClassId);
    CSQLExecute::SetDBNumeric(sprocparams.dScopeId, dScopeID);

    // Grab only the first part of the key string - up to the class name.
    wchar_t *pTmp = wcsstr(lpObjectKey, lpClassName);
    if (pTmp)
    {
        int iLen = pTmp - lpObjectKey;
        wchar_t *pNew = new wchar_t [iLen+1];
        CDeleteMe <wchar_t> d (pNew);
        if (pNew)
        {
            wcsncpy(pNew, lpObjectKey, iLen);
            pNew[iLen] = L'\0';
            sprocparams.sKeyString = SysAllocString(pNew);
        }
    }
    else
        sprocparams.sKeyString = SysAllocString(lpObjectKey); 
    CFreeMe f1 (sprocparams.sKeyString);
    
    hr = pCmd->CreateCommand(NULL, IID_ICommandText, (IUnknown**) &pICommandText);    
    CReleaseMe r1(pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ScopeID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
        ParamOrdinals[0] = 1;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_NUMERIC", L"@ClassID", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
        ParamOrdinals[1] = 2;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_BSTR", L"@KeyString", 450, DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[2] = 3;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_I4", L"@RetVal", sizeof(DWORD), DBPARAMFLAGS_ISOUTPUT, 11);
        ParamOrdinals[3] = 4;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, dScopeId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(SPROCPARAMS, dClassId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
                CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(SPROCPARAMS, sKeyString), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
                CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(SPROCPARAMS, dwRetVal), DBPARAMIO_OUTPUT, sizeof(DWORD), DBTYPE_I4, 11);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(SPROCPARAMS), 
                                        &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        if (SUCCEEDED(hr))
                        {
                            int iRet = sprocparams.dwRetVal;
                            if (iRet == 1)
                                hr = WBEM_E_INVALID_OPERATION;
                        }
                        else
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                    else
                        hr = CSQLExecute::GetWMIError(pIAccessor);
                }                       
            }
        }
    }

    return hr;
}

HRESULT CSQLExecProcedure::NeedsToCheckKeyMigration(BOOL &bCheck)
{
    bCheck = FALSE;
    return 0;

}

//***************************************************************************
//
//  CSQLExecProcedure::ObjectExists
//
//***************************************************************************

HRESULT CSQLExecProcedure::ObjectExists (CSQLConnection *pConn, SQL_ID dId, BOOL &bExists, 
                                         SQL_ID *dClassId, SQL_ID *dScopeId, BOOL bDeletedOK)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pConn || !((COLEDBConnection*)pConn)->GetDBInitialize())
        return WBEM_E_INVALID_PARAMETER;

    const WCHAR *pszCmd = L"{call sp_InstanceExists (?, ?, ?, ?) }";
    const ULONG nParams = 4;

    STRUCTOBJECTEXISTS params;
    IDBInitialize *pDBInit = ((COLEDBConnection*)pConn)->GetDBInitialize();
    IDBCreateSession *pSession = ((COLEDBConnection*)pConn)->GetSessionObj();
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = ((COLEDBConnection *)pConn)->GetCommandWithParams(SQL_POS_OBJECTEXISTS);
    ICommandText *pICommandText = ((COLEDBConnection *)pConn)->GetCommandText(SQL_POS_OBJECTEXISTS);
    IAccessor *pIAccessor = ((COLEDBConnection*)pConn)->GetIAccessor(SQL_POS_OBJECTEXISTS);
    HACCESSOR hAccessor = ((COLEDBConnection*)pConn)->GetAccessor(SQL_POS_OBJECTEXISTS);
    IRowset *pIRowset = NULL;

    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    CSQLExecute::SetDBNumeric(params.dClassId, 0);
    CSQLExecute::SetDBNumeric(params.dObjectId, dId);
    params.bExists = 0;
    CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ObjectId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
    ParamOrdinals[0] = 1;
    CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_BOOL", L"@Exists", sizeof(BOOL), DBPARAMFLAGS_ISOUTPUT, 1);
    ParamOrdinals[1] = 2;
    CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_NUMERIC", L"@ClassId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISOUTPUT, 20);
    ParamOrdinals[2] = 3;
    CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_NUMERIC", L"@ScopeId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISOUTPUT, 20);
    ParamOrdinals[3] = 4;

    for(i = 0; i < nParams; i++)
        CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
    
    CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(STRUCTOBJECTEXISTS, dObjectId), DBPARAMIO_INPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(STRUCTOBJECTEXISTS, bExists), DBPARAMIO_OUTPUT, sizeof(BOOL), DBTYPE_BOOL, 1);
    CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(STRUCTOBJECTEXISTS, dClassId), DBPARAMIO_OUTPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);
    CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(STRUCTOBJECTEXISTS, dScopeId), DBPARAMIO_OUTPUT, sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);

    if (!pSession)
    {
        hr = pDBInit->QueryInterface(IID_IDBCreateSession,
                (void**) &pSession);
        ((COLEDBConnection*)pConn)->SetSessionObj(pSession);
    }
    if (pSession && !pCmd)
    {
        hr = pSession->CreateSession(NULL, IID_IDBCreateCommand,
            (IUnknown**) &pCmd);    
        ((COLEDBConnection*)pConn)->SetCommand(pCmd);        
    }
    if (pCmd && !pICommandText)
    {
        hr = pCmd->CreateCommand(NULL, IID_ICommandText,
            (IUnknown**) &pICommandText);   
        if (SUCCEEDED(hr))
            pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        ((COLEDBConnection*)pConn)->SetCommandText(SQL_POS_OBJECTEXISTS, pICommandText);        
    }
    if (pICommandText && !pICommandWithParams)
    {
        hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams);
        if (SUCCEEDED(hr))
            hr = pICommandWithParams->SetParameterInfo(nParams, ParamOrdinals,ParamBindInfo);
        ((COLEDBConnection*)pConn)->SetCommandWithParams(SQL_POS_OBJECTEXISTS, pICommandWithParams);
    }
    if (pICommandWithParams && !pIAccessor)
    {
        hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
        ((COLEDBConnection*)pConn)->SetIAccessor(SQL_POS_OBJECTEXISTS, pIAccessor);
    }
    if (pIAccessor && !hAccessor)
    {
        hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, sizeof(STRUCTOBJECTEXISTS), 
                            &hAccessor,acDBBindStatus);
        ((COLEDBConnection*)pConn)->SetAccessor(SQL_POS_OBJECTEXISTS, hAccessor);
    }

    if (SUCCEEDED(hr))
    {
        Params.pData = &params;
        Params.cParamSets = 1;
        Params.hAccessor = hAccessor;

        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
        CReleaseMe r4 (pIRowset);
        if (SUCCEEDED(hr))
        {
            if (dClassId)
                *dClassId = CSQLExecute::GetInt64(&(params.dClassId));
            if (dScopeId)
                *dScopeId = CSQLExecute::GetInt64(&(params.dScopeId));
            bExists = params.bExists;
        }
        else
            hr = CSQLExecute::GetWMIError(pICommandText);
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::Execute
//
//***************************************************************************
HRESULT CSQLExecProcedure::Execute (CSQLConnection *pConn, LPCWSTR lpProcName, CWStringArray &arrValues,
                                    IRowset **ppIRowset)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    wchar_t wSQL[1024];
    IDBCreateCommand *pCmd = ((COLEDBConnection *)pConn)->GetCommand();

    swprintf(wSQL, L"exec %s ", lpProcName);
    for (int i = 0; i < arrValues.Size(); i++)
    {
        if (i > 0)
            wcscat(wSQL, L",");

        wcscat(wSQL, L"\"");
        wcscat(wSQL, arrValues.GetAt(i));
        wcscat(wSQL, L"\"");
    }

    hr = CSQLExecute::ExecuteQuery(pCmd, wSQL, ppIRowset);   

    return hr;

}

//***************************************************************************
//
//  CSQLExecProcedure::RenameSubscopes
//
//***************************************************************************

HRESULT CSQLExecProcedure::RenameSubscopes (CSQLConnection *pConn, LPWSTR lpOldPath, LPWSTR lpOldKey, LPWSTR lpNewPath, LPWSTR lpNewKey)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    const WCHAR *pszCmd = L"{call sp_RenameSubscopedObjs (?, ?, ?, ?) }";

    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 4;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;
    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();

    typedef struct tagSPROCPARAMS
    {
        BSTR       sOldPath;
        BSTR       sOldKey;
        BSTR       sNewPath;
        BSTR       sNewKey;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    sprocparams.sOldPath= SysAllocString(lpOldPath);
    sprocparams.sOldKey= SysAllocString(lpOldKey);
    sprocparams.sNewPath= SysAllocString(lpNewPath);
    sprocparams.sNewKey= SysAllocString(lpNewKey);
    
    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);    
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_BSTR", L"@OldPath", 4000, DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[0] = 1;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[1], L"DBTYPE_BSTR", L"@OldKey", 450, DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[1] = 2;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[2], L"DBTYPE_BSTR", L"@NewPath", 4000, DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[2] = 3;
        CSQLExecute::SetParamBindInfo(ParamBindInfo[3], L"DBTYPE_BSTR", L"@NewKey", 450, DBPARAMFLAGS_ISINPUT, 11);
        ParamOrdinals[3] = 4;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, sOldPath), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
                CSQLExecute::SetBindingInfo(&acDBBinding[1], 2, offsetof(SPROCPARAMS, sOldKey), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);
                CSQLExecute::SetBindingInfo(&acDBBinding[2], 3, offsetof(SPROCPARAMS, sNewPath), DBPARAMIO_INPUT, 4000, DBTYPE_BSTR, 11);
                CSQLExecute::SetBindingInfo(&acDBBinding[3], 4, offsetof(SPROCPARAMS, sNewKey), DBPARAMIO_INPUT, 450, DBTYPE_BSTR, 11);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, 
                                        sizeof(SPROCPARAMS), &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        if (FAILED(hr))
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                }                       
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::EnumerateSecuredChildren
//
//***************************************************************************

HRESULT CSQLExecProcedure::EnumerateSecuredChildren(CSQLConnection *pConn, CSchemaCache *pCache, SQL_ID dObjectId, SQL_ID dClassId, SQL_ID dScopeId,
                                                    SQLIDs &ObjIds, SQLIDs &ClassIds, SQLIDs &ScopeIds)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If __Classes instance, we need to enumerate all instances of __ClassSecurity
    // If this is a __ClassSecurity instance, we need to enumerate all instances
    //    of __ClassSecurity for all subclasses
    // If this is a __ClassInstancesSecurity instance, we need to enumerate all
    //    instances of this class
    // If this is a namespace (__ThisNamespace) or scope, we need all subscoped objects 

    SQL_ID dClassSecurityId = CLASSSECURITYID;
    SQL_ID dClassesId = CLASSESID;
    SQL_ID dClassInstSecurityId = CLASSINSTSECID;
    SQL_ID dThisNamespaceId = THISNAMESPACEID;

    DWORD dwSecPropID = 0;

    hr = pCache->GetPropertyID(L"__SECURITY_DESCRIPTOR", 1, 0, REPDRVR_IGNORE_CIMTYPE, dwSecPropID);

    if (dClassId == dClassesId)
    {
        IRowset *pIRowset = NULL;
        DWORD dwNumRows = 0;
        IMalloc *pMalloc = NULL;
        CoGetMalloc(MEMCTX_TASK, &pMalloc);
        CReleaseMe r (pMalloc);

        // Enumerate all secured classes in this namespace.

        hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
            L"select ObjectId, ClassId, ObjectScopeId from ObjectMap as o where ClassId = %I64d"
            L" and exists (select * from ClassImages as c where c.ObjectId = o.ObjectId "
            L" and c.PropertyId = %ld",
            &pIRowset, &dwNumRows, dClassSecurityId, dwSecPropID);
        if (SUCCEEDED(hr))
        {
            
            HROW *pRow = NULL;
            VARIANT vTemp;
            CClearMe c (&vTemp);
            hr = CSQLExecute::GetColumnValue(pIRowset, 1, pMalloc, &pRow, vTemp);
            while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
            {
                ObjIds.push_back(_wtoi64(vTemp.bstrVal));

                hr = CSQLExecute::GetColumnValue(pIRowset, 2, pMalloc, &pRow, vTemp);
                if (SUCCEEDED(hr))
                    ClassIds.push_back(_wtoi64(vTemp.bstrVal));
                else
                    break;
                            
                hr = CSQLExecute::GetColumnValue(pIRowset, 3, pMalloc, &pRow, vTemp);
                if (SUCCEEDED(hr))
                    ScopeIds.push_back(_wtoi64(vTemp.bstrVal));
                else
                    break;

                hr = pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                delete pRow;
                pRow = NULL;
                hr = CSQLExecute::GetColumnValue(pIRowset, 1, pMalloc, &pRow, vTemp);
            }
        }
        
        pIRowset->Release();
        pIRowset = NULL;

    }
    else if (dClassId == dClassSecurityId)
    {
        // All __ClassSecurity for subclasses of this class

        // Get the class name 
        // Get the ID for the class name in this namespace
        // Enumerate subclasses
        // Format the name
        // Generate the Object ID


        return E_NOTIMPL;

    }
    else if (dClassId == dClassInstSecurityId)
    {
        // All instances of this class and subclasses.

        // Get the class name 
        // Get the ID for the class name in this namespace
        // Enumerate subclasses
        // Enumerate all instances of each class

        return E_NOTIMPL;
    }
    else
    {
        // Regular instance.  Enumerate all objects 
        // scoped to this .

        SQL_ID dThis = dObjectId;

        if (dClassId == dThisNamespaceId)
            dThis = dScopeId;

        SQL_ID * pScopes = NULL;
        int iNumScopes = 0;

        hr = pCache->GetSubScopes(dThis, &pScopes, iNumScopes);
        for (int i = 0; i < iNumScopes; i++)
        {
            IRowset *pIRowset = NULL;
            DWORD dwNumRows = 0;
            IMalloc *pMalloc = NULL;
            CoGetMalloc(MEMCTX_TASK, &pMalloc);
            CReleaseMe r (pMalloc);

            // Enumerate all secured classes in this namespace.

            hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
                L"select ObjectId, ClassId, ObjectScopeId from ObjectMap as o where ObjectScopeId = %I64d"
                L" AND EXISTS (select * from ClassImages as c where c.ObjectId = c.ObjectId and c.PropertyId = %ld) ",
                &pIRowset, &dwNumRows, pScopes[i], dwSecPropID);
            if (SUCCEEDED(hr))
            {            
                HROW *pRow = NULL;
                VARIANT vTemp;
                CClearMe c (&vTemp);
                hr = CSQLExecute::GetColumnValue(pIRowset, 1, pMalloc, &pRow, vTemp);
                while (SUCCEEDED(hr) && hr != WBEM_S_NO_MORE_DATA)
                {
                    ObjIds.push_back(_wtoi64(vTemp.bstrVal));

                    hr = CSQLExecute::GetColumnValue(pIRowset, 2, pMalloc, &pRow, vTemp);
                    if (SUCCEEDED(hr))
                        ClassIds.push_back(_wtoi64(vTemp.bstrVal));
                    else
                        break;
                            
                    hr = CSQLExecute::GetColumnValue(pIRowset, 3, pMalloc, &pRow, vTemp);
                    if (SUCCEEDED(hr))
                        ScopeIds.push_back(_wtoi64(vTemp.bstrVal));
                    else
                        break;

                    hr = pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
                    delete pRow;
                    pRow = NULL;
                    hr = CSQLExecute::GetColumnValue(pIRowset, 1, pMalloc, &pRow, vTemp);
                }
            }
        
            pIRowset->Release();
            pIRowset = NULL;
        }

        delete pScopes;
    }

    if (hr == WBEM_E_NOT_FOUND)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::EnumerateSubScopes
//
//***************************************************************************

HRESULT CSQLExecProcedure::EnumerateSubScopes (CSQLConnection *pConn, SQL_ID dScopeId)
{

    HRESULT hr = WBEM_S_NO_ERROR;
    const WCHAR *pszCmd = L"{call sp_EnumerateSubscopes (?) }";

    IDBCreateCommand *pIDBCreateCommand = ((COLEDBConnection *)pConn)->GetCommand();
    ICommandWithParameters *pICommandWithParams = NULL;
    ICommandText *pICommandText = NULL;
    IAccessor *pIAccessor = NULL;
    IRowset *pIRowset = NULL;
    HACCESSOR hAccessor = NULL;
    const ULONG nParams = 1;
    DBPARAMBINDINFO     ParamBindInfo[nParams];
    DBBINDING           acDBBinding[nParams];
    DBBINDSTATUS        acDBBindStatus[nParams];
    ULONG               ParamOrdinals[nParams];
    DBPARAMS            Params;
    LONG                lRows = 0;
    int i;

    typedef struct tagSPROCPARAMS
    {
        DB_NUMERIC dScopeId;
    } SPROCPARAMS;

    SPROCPARAMS sprocparams;
    CSQLExecute::SetDBNumeric(sprocparams.dScopeId, dScopeId);
    
    hr = pIDBCreateCommand->CreateCommand(NULL, IID_ICommandText,
        (IUnknown**) &pICommandText);    
    CReleaseMe r1 (pICommandText);
    if (SUCCEEDED(hr))
    {               
        pICommandText->SetCommandText(DBGUID_DBSQL, pszCmd);
        CSQLExecute::SetParamBindInfo(ParamBindInfo[0], L"DBTYPE_NUMERIC", L"@ScopeId", sizeof(DB_NUMERIC), DBPARAMFLAGS_ISINPUT, 20);
        ParamOrdinals[0] = 1;

        if(SUCCEEDED(hr = pICommandText->QueryInterface(IID_ICommandWithParameters,(void**)&pICommandWithParams)))
        {
            CReleaseMe r2 (pICommandWithParams);
            if(SUCCEEDED(hr = pICommandWithParams->SetParameterInfo(nParams,ParamOrdinals,ParamBindInfo)))
            {
                for(i = 0; i < nParams; i++)
                    CSQLExecute::ClearBindingInfo(&acDBBinding[i]);
                
                CSQLExecute::SetBindingInfo(&acDBBinding[0], 1, offsetof(SPROCPARAMS, dScopeId), DBPARAMIO_INPUT, 
                    sizeof(DB_NUMERIC), DBTYPE_NUMERIC, 20);

                hr = pICommandWithParams->QueryInterface(IID_IAccessor, (void**)&pIAccessor);
                CReleaseMe r3 (pIAccessor);
                if (SUCCEEDED(hr))
                {
                    hr = pIAccessor->CreateAccessor(DBACCESSOR_PARAMETERDATA,nParams, acDBBinding, 
                                        sizeof(SPROCPARAMS), &hAccessor,acDBBindStatus);
                    if (SUCCEEDED(hr))
                    {
                        Params.pData = &sprocparams;
                        Params.cParamSets = 1;
                        Params.hAccessor = hAccessor;
        
                        hr = pICommandText->Execute(NULL, IID_IRowset, &Params, &lRows, (IUnknown **) &pIRowset);
                        CReleaseMe r4 (pIRowset);
                        if (FAILED(hr))
                            hr = CSQLExecute::GetWMIError(pICommandText);
                        pIAccessor->ReleaseAccessor(hAccessor, NULL);                           
                    }
                }                       
            }
        }
    }

    return hr;

}

//***************************************************************************
//
//  CSQLExecProcedure::InsertScopeMap
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertScopeMap (CSQLConnection *pConn, SQL_ID dScopeId, LPCWSTR lpScopePath, SQL_ID dParentId)
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CSQLExecProcedure::GetSecurityDescriptor
//
//***************************************************************************

HRESULT CSQLExecProcedure::GetSecurityDescriptor(CSQLConnection *pConn, SQL_ID dObjectId, 
                                                 PNTSECURITY_DESCRIPTOR  * ppSD, DWORD &dwBuffLen,
                                                 DWORD dwFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    // If this is a class , get the security for __ClassSecurity (WMIDB_SECURITY_FLAG_CLASS)
    //  or __Instances container (WMIDB_SECURITY_FLAG_INSTANCE)
    // If this is a namespace, get the security for __ThisNamespace
    // Otherwise, get it off the object itself.

    *ppSD = NULL;
    IRowset *pIRowset = NULL;
    DWORD dwNumRows = 0;
    IMalloc *pMalloc = NULL;
    CoGetMalloc(MEMCTX_TASK, &pMalloc);
    CReleaseMe r (pMalloc);

    HRESULT hres = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), 
           L"exec sp_GetSecurityInfo %I64d, %ld",
           &pIRowset, &dwNumRows, dObjectId, dwFlags);
    if (SUCCEEDED(hres) && hres != WBEM_S_NO_MORE_DATA)
    {
        // Get the results and load the cache.
        HROW *pRow = NULL;
        VARIANT vTemp;
        CClearMe c (&vTemp);
        hres = CSQLExecute::GetColumnValue(pIRowset, 1, pMalloc, &pRow, vTemp);
        if (SUCCEEDED(hres) && hres != WBEM_S_NO_MORE_DATA)
        {
            PNTSECURITY_DESCRIPTOR pSecDescr = NULL;
            VariantClear(&vTemp);
            BYTE *pBuffer = NULL;
            bool bThisObj = true;   
            
            // Get the image data for this security descriptor.
            hres = CSQLExecute::ReadImageValue(pIRowset, 1, &pRow, &pBuffer, dwBuffLen);
            if (SUCCEEDED(hres) && pBuffer != NULL)
            {
                pSecDescr = pBuffer;
                if (pSecDescr != NULL)
                {                    
                    if (IsValidSecurityDescriptor(pSecDescr))
                    {
                        hr = WBEM_S_NO_ERROR;
                        *ppSD = pSecDescr;
                    }
                    else
                        CWin32DefaultArena::WbemMemFree(pSecDescr);  // FIXME: This breakpoints...
                        
                }
                VariantClear(&vTemp);
                // DON'T DELETE pBuffer, since this is our copy.
            }

            hres = pIRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;
        }
        
        pIRowset->Release();
        pIRowset = NULL;
    }

    return hr;
}


//***************************************************************************
//
//  CSQLExecProcedure::InsertUncommittedEvent
//
//***************************************************************************

HRESULT CSQLExecProcedure::InsertUncommittedEvent (CSQLConnection *pConn, LPCWSTR lpGUID, LPWSTR lpNamespace, 
                                                   LPWSTR lpClassName, IWbemClassObject *pOldObj, 
                                                   IWbemClassObject *pNewObj, CSchemaCache *pCache)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    static int iNumProps = 5;
    InsertPropValues *pVals = new InsertPropValues[iNumProps];
    if (!pVals)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe <InsertPropValues> d (pVals);
    LPWSTR lpObjectKey = NULL, lpPath = NULL;
    SQL_ID dScopeId = 1;
    SQL_ID dObjectId = 0;
    SQL_ID dKeyhole = 0;
    static SQL_ID dClassId = 0;
    static DWORD dwPropId1 = 0, dwPropId2 = 0, dwPropId3 = 0, dwPropId4 = 0, dwPropId5 = 0, dwPropId6 = 0, dwPropId7 = 0;

    if (!dwPropId1)
    {
        hr = pCache->GetClassID(L"__UncommittedEvent", 1, dClassId);
        if (SUCCEEDED(hr))
        {
            hr = pCache->GetPropertyID(L"EventID", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId1);
            hr = pCache->GetPropertyID(L"TransactionGUID", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId2);
            hr = pCache->GetPropertyID(L"NamespaceName", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId3);
            hr = pCache->GetPropertyID(L"ClassName", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId4);
            hr = pCache->GetPropertyID(L"OldObject", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId5);
            hr = pCache->GetPropertyID(L"NewObject", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId6);
            hr = pCache->GetPropertyID(L"Transacted", dClassId, 0, REPDRVR_IGNORE_CIMTYPE, dwPropId7);
        }
    }

    if (FAILED(hr))
        return hr;
        
    hr = GetNextKeyhole(pConn, dwPropId1, dKeyhole);
    if (SUCCEEDED(hr))
    {
        LPWSTR lpKey = new wchar_t [40];
        lpObjectKey = new wchar_t [100];
        lpPath = new wchar_t [100];      
        CDeleteMe <wchar_t> d2 (lpKey), d3 (lpObjectKey), d4 (lpPath);

        if (!lpKey || !lpObjectKey || !lpPath)
            return WBEM_E_OUT_OF_MEMORY;

        swprintf(lpKey, L"%ld", dKeyhole);
        swprintf(lpObjectKey, L"%ld?__UncommittedEvent", dKeyhole);
        swprintf(lpPath, L"__UncommittedEvent=%ld", dKeyhole);

        pVals[0].iPropID = dwPropId1;
        pVals[0].bIndexed = TRUE;
        pVals[0].iStorageType = WMIDB_STORAGE_NUMERIC;
        pVals[0].dClassId = dClassId;
        pVals[0].pValue = Macro_CloneLPWSTR(lpKey);
        pVals[1].iPropID = dwPropId2;
        pVals[1].bIndexed = TRUE;
        pVals[1].iStorageType = WMIDB_STORAGE_STRING;
        pVals[1].dClassId = dClassId;
        pVals[1].pValue = Macro_CloneLPWSTR(lpGUID);
        pVals[2].iPropID = dwPropId3;
        pVals[2].iStorageType = WMIDB_STORAGE_STRING;
        pVals[2].dClassId = dClassId;
        pVals[2].pValue = Macro_CloneLPWSTR(lpClassName);
        pVals[3].iPropID = dwPropId4;
        pVals[3].iStorageType = WMIDB_STORAGE_STRING;
        pVals[3].dClassId = dClassId;
        pVals[3].pValue = Macro_CloneLPWSTR(lpNamespace);
        pVals[4].iPropID = dwPropId6;
        pVals[4].iStorageType = WMIDB_STORAGE_NUMERIC;
        pVals[4].dClassId = dClassId;
        pVals[4].pValue = new wchar_t [2];
        if (!pVals[4].pValue)
            return WBEM_E_OUT_OF_MEMORY;

        wcscpy(pVals[4].pValue, L"1");

        hr = InsertPropertyBatch (pConn, lpObjectKey, lpPath, lpClassName,
                    dClassId, dScopeId, 0, pVals, iNumProps, dObjectId);
        if (SUCCEEDED(hr))
        {
            if (pOldObj)
            {                  
                _IWmiObject *pInt = NULL;
                hr = pOldObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
                if (SUCCEEDED(hr))
                {
                    DWORD dwLen = 0;
                    pInt->GetObjectMemory(NULL, 0, &dwLen);
                    BYTE *pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> d (pBuff);
                        DWORD dwLen1;
                        hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                        if (SUCCEEDED(hr))
                        {
                            hr = CSQLExecProcedure::InsertBlobData(pConn, dClassId, dObjectId,
                                        dwPropId4, pBuff, 0, dwLen);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                    pInt->Release();
                }                               
            }

            if (pNewObj)
            {                  
                _IWmiObject *pInt = NULL;
                hr = pNewObj->QueryInterface(IID__IWmiObject, (void **)&pInt);
                if (SUCCEEDED(hr))
                {
                    DWORD dwLen = 0;
                    pInt->GetObjectMemory(NULL, 0, &dwLen);
                    BYTE *pBuff = new BYTE [dwLen];
                    if (pBuff)
                    {
                        CDeleteMe <BYTE> d (pBuff);
                        DWORD dwLen1;
                        hr = pInt->GetObjectMemory(pBuff, dwLen, &dwLen1);
                        if (SUCCEEDED(hr))
                        {
                            hr = CSQLExecProcedure::InsertBlobData(pConn, dClassId, dObjectId,
                                        dwPropId4, pBuff, 0, dwLen);
                        }
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                    pInt->Release();
                }                               
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::DeleteUncommittedEvents
//
//***************************************************************************

HRESULT CSQLExecProcedure::DeleteUncommittedEvents (CSQLConnection *pConn, LPCWSTR lpGUID, 
                                                    CSchemaCache *pCache, CObjectCache *pObjCache)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // FIXME: Bind and optimize later.

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(), L"exec sp_DeleteUncommittedEvents '%s'", NULL, NULL, lpGUID);

    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::CommitEvents
//
//***************************************************************************

HRESULT CSQLExecProcedure::CommitEvents(CSQLConnection *pConn,_IWmiCoreServices *pESS,
                                        LPCWSTR lpRoot, LPCWSTR lpGUID, CSchemaCache *pCache, CObjectCache *pObjCache)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VARIANT vValue;
    VariantInit(&vValue);
    CClearMe c (&vValue);
    IRowset *pRowset = NULL;
    DWORD dwNumRows = 0;
    IMalloc *pMalloc = NULL;
    CoGetMalloc(MEMCTX_TASK, &pMalloc);
    CReleaseMe r (pMalloc);
    SQL_ID dObjectId;
    _IWmiObject *pOldObj, *pNewObj;
    _IWmiObject **pObjs;
    DWORD dwNumObjs;
    _bstr_t sNamespace, sClassName;
    LPWSTR lpNewNs = NULL;
    HROW *pRow = NULL;
    long lType;

    hr = CSQLExecute::ExecuteQuery(((COLEDBConnection *)pConn)->GetCommand(),
        L"exec sp_GetUncommittedEvents '%s'", &pRowset, &dwNumRows, lpGUID);

    if (SUCCEEDED(hr))
    {
        hr = CSQLExecute::GetColumnValue(pRowset, 1, pMalloc, &pRow, vValue);
        while (hr == WBEM_S_NO_ERROR)
        {
       
            BYTE *pBuff = NULL;
            DWORD dwLen = 0;

            dObjectId = _wtoi64(vValue.bstrVal);
            hr = CSQLExecute::GetColumnValue(pRowset, 2, pMalloc, &pRow, vValue);
            sNamespace = vValue.bstrVal;
            hr = CSQLExecute::GetColumnValue(pRowset, 3, pMalloc, &pRow, vValue);
            sClassName = vValue.bstrVal;
            hr = CSQLExecute::ReadImageValue(pRowset, 4, &pRow, &pBuff, dwLen);
            if (SUCCEEDED(hr) && dwLen)
                hr = ConvertBlobToObject(NULL, pBuff, dwLen, &pOldObj);
            else
                pOldObj = NULL;
            delete pBuff;
            hr = CSQLExecute::ReadImageValue(pRowset, 5, &pRow, &pBuff, dwLen);
            if (SUCCEEDED(hr) && dwLen)
                hr = ConvertBlobToObject(NULL, pBuff, dwLen, &pNewObj);
            else
                pNewObj = NULL;
            delete pBuff;
        
            lpNewNs = new wchar_t [wcslen(sNamespace) + 50];
            if (lpNewNs)
            {
                swprintf(lpNewNs, L"\\\\.\\%s\\%s", lpRoot, (LPCWSTR)sNamespace);
            }

            CDeleteMe <wchar_t> d4 (lpNewNs);

            // Determine what type of event this is:
            //     Namespace | Class | Instance
            //  Creation | Modification | Deletion
            // =====================================

            if (!pNewObj && pOldObj)
            {
                pObjs = new _IWmiObject * [dwNumObjs];
                pObjs[0] = pOldObj;

                LPWSTR lpGenus = GetPropertyVal(L"__Genus", pNewObj);
                CDeleteMe <wchar_t> d (lpGenus);

                if (!wcscmp(lpGenus, L"1"))
                    lType = WBEM_EVENTTYPE_ClassDeletion;
                else
                {
                    if (IsDerivedFrom(pOldObj, L"__Namespace"))
                        lType = WBEM_EVENTTYPE_NamespaceDeletion;
                    else
                        lType = WBEM_EVENTTYPE_InstanceDeletion;
                }
            }
            else if (!pOldObj && pNewObj)
            {
                pObjs = new _IWmiObject *[dwNumObjs];
                if (pObjs)
                {
                    pObjs[0] = pNewObj;

                    LPWSTR lpGenus = GetPropertyVal(L"__Genus", pNewObj);
                    CDeleteMe <wchar_t> d (lpGenus);

                    if (!wcscmp(lpGenus, L"1"))
                        lType = WBEM_EVENTTYPE_ClassCreation;
                    else
                    {
                        if (IsDerivedFrom(pOldObj, L"__Namespace"))
                            lType = WBEM_EVENTTYPE_NamespaceCreation;
                        else
                            lType = WBEM_EVENTTYPE_InstanceCreation;
                    }
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                dwNumObjs = 2;
                pObjs = new _IWmiObject *[dwNumObjs];
                if (pObjs)
                {
                    pObjs[0] = pOldObj;
                    pObjs[1] = pNewObj;

                    LPWSTR lpGenus = GetPropertyVal(L"__Genus", pNewObj);
                    CDeleteMe <wchar_t> d (lpGenus);

                    if (!wcscmp(lpGenus, L"1"))
                        lType = WBEM_EVENTTYPE_ClassModification;
                    else
                    {
                        if (IsDerivedFrom(pOldObj, L"__Namespace"))
                            lType = WBEM_EVENTTYPE_NamespaceModification;
                        else
                            lType = WBEM_EVENTTYPE_InstanceModification;
                    }
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
            }          

            // Deliver the event...
            // ====================

            pESS->DeliverIntrinsicEvent(lpNewNs, lType, NULL, 
                    sClassName, lpGUID, dwNumObjs, pObjs);

            delete pObjs;
            if (pOldObj)
                pOldObj->Release();
            if (pNewObj)
                pNewObj->Release();              

            pObjCache->DeleteObject(dObjectId);

            if (pRow)
                pRowset->ReleaseRows(1, pRow, NULL, NULL, NULL);
            delete pRow;
            pRow = NULL;
            hr = CSQLExecute::GetColumnValue(pRowset, 1, pMalloc, &pRow, vValue);            
        }
    }

    // Remove all events for this GUID.
    // FIXME: Do this incrementally in the future.
    // The problem is, we would have to reissue the query
    // after doing this, which isn't terribly efficient.

    if (SUCCEEDED(hr))
        hr = DeleteUncommittedEvents(pConn, lpGUID, pCache, pObjCache);


    return hr;
}

//***************************************************************************
//
//  CSQLExecProcedure::UpdateClassBlob
//
//***************************************************************************

HRESULT CSQLExecProcedure::UpdateClassBlob (CSQLConnection *pConn, SQL_ID dClassId, _IWmiObject *pObj)
{
    HRESULT hr = 0;
    BYTE buff[128];
    DWORD dwLen = 0;
    hr = ((_IWmiObject *)pObj)->Unmerge(0, 128, &dwLen, &buff);

    if (dwLen > 0)
    {
        BYTE *pBuff = new BYTE [dwLen];
        if (pBuff)
        {
            CDeleteMe <BYTE> r2 (pBuff);
            DWORD dwLen1;
            hr = ((_IWmiObject *)pObj)->Unmerge(0, dwLen, &dwLen1, pBuff);
            if (SUCCEEDED(hr))
            {
                wchar_t wBuff[256];
                swprintf(wBuff, L"select ClassBlob from ClassMap "
                                L" where ClassId = %I64d", dClassId);
                if (SUCCEEDED(hr))
                {
                    hr = CSQLExecute::WriteImageValue 
                            (((COLEDBConnection *)pConn)->GetCommand(), wBuff, 1, pBuff, dwLen);
                }
            }
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51fib.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51fib.h"
#include <tls.h>

void CALLBACK A51FiberBase(void* p)
{
    CFiberTask* pTask = (CFiberTask*)p;
    pTask->Execute();

    //
    // No need to clean up --- it's the job of our caller
    //
}

void* CreateFiberForTask(CFiberTask* pTask)
{
    //
    // For now, just create it
    //

    void* pFiber = CreateFiber(0, A51FiberBase, pTask);
    return pFiber;
}

void ReturnFiber(void* pFiber)
{
    //
    // For now, just delete it
    //

    DeleteFiber(pFiber);
}
    
CTLS g_tlsInit;
void* CreateOrGetCurrentFiber()
{
    if(!g_tlsInit.IsValid())
        return NULL;

    void* pFiber = g_tlsInit.Get();
    if(pFiber == NULL)
    {
        //
        // We have never seen this thread before --- convert to fiber
        //

        pFiber = ConvertThreadToFiber(NULL);
        if(pFiber == NULL)
            return NULL;
        
        //
        // Remember it for the future
        //

        g_tlsInit.Set(pFiber);
    }

    return pFiber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51conv.cpp ===
#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <filecach.h>


#define A51_REPOSITORY_TEMPDIR_NAME L"A51Temp"

long FlushOldCache(LPCWSTR wszRepDir);

long GetRepositoryDirectory(LPWSTR wszRepDir);
long ConvertA51ToRoswell();
long CopyA51ToRoswell(LPCWSTR wszOldRepDir, LPCWSTR wszRepDir);
long CopyA51FromDirectoryToRoswell(LPCWSTR wszOldDir, DWORD dwOldBaseLen, 
                                    CFileCache& NewCache, LPCWSTR wszNewBase,
                                    bool bIgnoreFiles);

class CFindCloseMe
{
    HANDLE m_h;
public:
    CFindCloseMe(HANDLE h) : m_h(h){}
    ~CFindCloseMe() {FindClose(m_h);}
};

long GetRepositoryDirectory(LPWSTR wszRepDir)
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return lRes;
 
    CFileName wszTmp;
    if (wszTmp == NULL)
        return ERROR_OUTOFMEMORY;
    DWORD dwLen = wszTmp.Length();
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL,
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
    RegCloseKey(hKey);
    if(lRes)
    {
        ERRORTRACE((LOG_WBEMCORE, "Upgrade is unable to get the repository "
                    "directory from the registry: %d\n", lRes));
        return lRes;
    }
 
    if (ExpandEnvironmentStringsW(wszTmp,wszRepDir,wszTmp.Length()) == 0)
        return GetLastError();
    
    //
    // Append standard postfix --- that is our root
    //

    wcscat(wszRepDir, L"\\FS");
    return ERROR_SUCCESS;
}

long ConvertA51ToRoswell()
{
    long lRes;

    //
    // Figure out the repository directory
    //

    CFileName wszRepDir;
    if(wszRepDir == NULL)
        return ERROR_OUTOFMEMORY;
    lRes = GetRepositoryDirectory(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Construct a name for the backup
    //

    CFileName wszOldRepDir;
    if(wszRepDir == NULL)
        return ERROR_OUTOFMEMORY;
    
    wcscpy(wszOldRepDir, wszRepDir);
    WCHAR* pwcLastSlash = wcsrchr(wszOldRepDir, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_INVALID_PARAMETER;

    wcscpy(pwcLastSlash+1, A51_REPOSITORY_TEMPDIR_NAME);

    //
    // Remove the backup, if already there.  Disregard failure --- this is not
    // our real operations, we are just trying to get MoveFile to succeed
    //

    long lRemoveRes = A51RemoveDirectory(wszOldRepDir, false);
    
    //
    // Rename it
    //

    if(!MoveFileW(wszRepDir, wszOldRepDir))
    {
        lRes = GetLastError();
        ERRORTRACE((LOG_WBEMCORE, "Upgrade is unable to rename the repository "
            "directory \nfrom '%S' to \n'%S' even after attempting to delete "
            "the destination.  Deletion returned %d, rename returned %d\n", 
            (LPCWSTR)wszRepDir, (LPCWSTR)wszOldRepDir, lRemoveRes, lRes));
        return lRes;
    }
    
    lRes = EnsureDirectory(wszRepDir);
    if(lRes != ERROR_SUCCESS)
    {
        ERRORTRACE((LOG_WBEMCORE, "Upgrade is unable to create repository "
            "directory '%S'. Error code %d\n", (LPCWSTR)wszRepDir, lRes));
        return lRes;
    }

    //
    // Do the real work --- attempting to move everything from the old directory
    // to the new one
    //

    try
    {
        lRes = CopyA51ToRoswell(wszOldRepDir, wszRepDir);
    }
    catch(...)
    {
        ERRORTRACE((LOG_WBEMCORE, "Upgrade attempt threw an exception\n"));
        lRes = ERROR_INTERNAL_ERROR;
    }

    //
    // If a failure occurred, try to reinstate old repository
    //

    if(lRes != ERROR_SUCCESS)
    {
        long lMainRes = lRes;

        ERRORTRACE((LOG_WBEMCORE, "Upgrade failed to convert the repository, "
                "error code %d\n", lMainRes));

        lRemoveRes = A51RemoveDirectory(wszRepDir, false);
        if(!MoveFileW(wszOldRepDir, wszRepDir))
        {
            lRes = GetLastError();
            ERRORTRACE((LOG_WBEMCORE, "Upgrade failed to rename the repository "
                "back from '%S' to '%S' with error code %d, even after "
                "attempting to delete the destination (with error code %d).\n"
                "WMI is now unusable!\n", (LPCWSTR)wszOldRepDir, 
                    (LPCWSTR)wszRepDir, lRes, lRemoveRes));
        }
        else
        {
            ERRORTRACE((LOG_WBEMCORE, "Upgrade restored the old repository "
                "back. The old version is now functional\n"));
        }

        return lMainRes;
    }

    //
    // Time to delete the backup
    //

    lRes = A51RemoveDirectory(wszOldRepDir, false);
    if(lRes != ERROR_SUCCESS)
    {
        ERRORTRACE((LOG_WBEMCORE, "Upgrade is unable to remote the backup of "
                    "the repository in directory '%S', error code %d.  This "
                    "will not affect operations, except inasmuch as disk space "
                    "is being wasted\n", (LPCWSTR)wszOldRepDir, lRes));
    }

    return ERROR_SUCCESS;
}
                
long CopyA51ToRoswell(LPCWSTR wszOldRepDir, LPCWSTR wszRepDir)
{
    long lRes;

    lRes = FlushOldCache(wszOldRepDir);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    //
    // Instantiate the new file cache
    //

    CFileCache NewCache;
    lRes = NewCache.Initialize(wszRepDir);
    if(lRes != ERROR_SUCCESS)
        return lRes;
    
    //
    // Copy all files recursively, but not the files in this directory
    //

    lRes = CopyA51FromDirectoryToRoswell(wszOldRepDir, wcslen(wszOldRepDir), 
                                    NewCache, wszRepDir, true);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    return ERROR_SUCCESS;
}

long CopyA51FromDirectoryToRoswell(LPCWSTR wszOldDir, DWORD dwOldBaseLen, 
                                    CFileCache& NewCache, LPCWSTR wszNewBase,
                                    bool bIgnoreFiles)
{
    long lRes;

    //
    // Commence enumeration of everything in this directory
    //

    CFileName wszMask;
    if(wszMask == NULL)
        return ERROR_OUTOFMEMORY;

    wcscpy(wszMask, wszOldDir);
    wcscat(wszMask, L"\\*");

    WIN32_FIND_DATAW wfd;
    HANDLE hSearch = FindFirstFileW(wszMask, &wfd);

    if(hSearch == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        ERRORTRACE((LOG_WBEMCORE, "Upgrade is unable to enumerate files in "
            "directory '%S': error code %d\n", (LPCWSTR)wszOldDir, lRes));
        return lRes;
    }

    CFindCloseMe fcm(hSearch);

    do
    {
        if(wfd.cFileName[0] == L'.')
            continue;

        //
        // Construct full name
        //

        CFileName wszChildName;
        if(wszChildName == NULL)
            return ERROR_OUTOFMEMORY;

        wcscpy(wszChildName, wszOldDir);
        wcscat(wszChildName, L"\\");
        wcscat(wszChildName, wfd.cFileName);

        //
        // Recurse on directories
        //

        if(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            lRes = CopyA51FromDirectoryToRoswell(wszChildName, dwOldBaseLen,
                                                 NewCache, wszNewBase, false);
            if(lRes != ERROR_SUCCESS)
                return lRes;
        }
        else
        {
            //
            // Check if we are skipping files
            //

            if(bIgnoreFiles)
                continue;
    
            //
            // Read it in
            //

            HANDLE hFile = CreateFileW(wszChildName, GENERIC_READ, 
                FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 
                NULL);
            if(hFile == INVALID_HANDLE_VALUE)
            {
                lRes = GetLastError();
                ERRORTRACE((LOG_WBEMCORE, "Update cannot open file '%S', "
                    "error code %d\n", (LPCWSTR)wszChildName, lRes));
                return lRes;
            }
            CCloseMe cm(hFile);

            BY_HANDLE_FILE_INFORMATION fi;
            if(!GetFileInformationByHandle(hFile, &fi))
            {
                lRes = GetLastError();
                ERRORTRACE((LOG_WBEMCORE, "Update cannot open file '%S', "
                    "error code %d\n", (LPCWSTR)wszChildName, lRes));
                return lRes;
            }

            DWORD dwLen = fi.nFileSizeLow;
            BYTE* pBuffer = (BYTE*)TempAlloc(dwLen);
            if(pBuffer == NULL)
                return E_OUTOFMEMORY;
            CTempFreeMe tfm(pBuffer);

            DWORD dwRead;
            if(!::ReadFile(hFile, pBuffer, dwLen, &dwRead, NULL))
            {
                lRes = GetLastError();
                ERRORTRACE((LOG_WBEMCORE, "Update unable to read %d bytes "
                    "from file '%S' with error %d\n", 
                        dwLen, (LPCWSTR)wszChildName, lRes));
                return lRes;
            }

            //
            // Convert the name to the new directory name
            //

            CFileName wszNewChildName;
            if(wszNewChildName == NULL)
                return ERROR_OUTOFMEMORY;

            wcscpy(wszNewChildName, wszNewBase);
            wcscat(wszNewChildName, wszChildName + dwOldBaseLen);

            //
            // Write it out
            //

            lRes = NewCache.WriteFile(wszNewChildName, dwLen, pBuffer);
            if(lRes != ERROR_SUCCESS)
                return lRes;
        }
    }
    while(FindNextFile(hSearch, &wfd));

    lRes = GetLastError();
    if(lRes != ERROR_NO_MORE_FILES)
    {
        ERRORTRACE((LOG_WBEMCORE, "Upgrade is unable to enumerate files in "
            "directory '%S': error code %d\n", (LPCWSTR)wszOldDir, lRes));
        return lRes;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51exp.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    A51Exp.cpp

Abstract:

    Exports the repository into a interchange format that can easily be re-imported.
	
	Database has to be opened and available to us at the point we are called, and we 
	enumerate recursively writing all classes and instances to the interchange
	file.

	The import may well have to deal with changing system classes, and so all old
	system classes have to be written to the file format.

	The format of the interchange file is as follows:

 File Header Block:
		BYTE	wszFileHeader[8]							= A51_EXPORT_FILE_START_TAG ("a51exp1")

 Namespace Block:
		DWORD   dwObjectType								= A51_EXPORT_NAMESPACE_TAG (0x00000001)
		DWORD   dwNamespaceNameSize
		BYTE	wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
															  (\root\default\fred)

 Class Block:
		DWORD   dwObjectType								= A51_EXPORT_CLASS_TAG (0x00000002)
		DWORD   dwClassNameSize
		BYTE	wszClassName[dwClassNameSize]				= Class name (my_class_name)
		DWORD   dwClassObjectSize
		BYTE	adwClassObject[dwClassObjectSize]

 Instance Block - key of type string
		DWORD	dwObjectType								= A51_EXPORT_INST_TAG (0x00000003)
		DWORD	dwInstanceKeySize
		BYTE	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
		DWORD	dwInstanceObjectSize
		BYTE	adwInstanceObject[dwInstanceObjectSize]
		
 End of class block
		DWORD	dwObjectType								= A51_EXPORT_CLASS_END_TAG (0x00000005)

 End of namespace block
		DWORD	dwObjectType								= A51_EXPORT_NAMESPACE_END_TAG (0x00000006)

 End of file block
		DWORD	dwObjectType								= A51_EXPORT_FILE_END_TAG (0xFFFFFFFF)

 Ordering:
		File Header Block
			(one or more)
			Namespace Block
				(zero or more)
				{
					Namespace Block
						etc...
					End namespace block
					(or)
					Class Block
						(zero or more)
						{
							Instance Block
							(or)
							Class Block
								etc...
							End class block
						}
					End class block
				}
			End namespace block
		End of file block

History:

	08-Dec-2000		paulall		Created.

--*/

#include <windows.h>
#include <ql.h>
#include "A51Rep.h"
#include "A51Exp.h"


/*=============================================================================
 *
 *	A51Export::A51Export
 *
 *=============================================================================
 */
A51Export::A51Export(CLifeControl* pControl)
: m_hFile(INVALID_HANDLE_VALUE), m_pControl(pControl)
{
}

/*=============================================================================
 *
 *	A51Export::~A51Export
 *
 *=============================================================================
 */
A51Export::~A51Export()
{
}

/*=============================================================================
 *
 *	A51Export::Export
 *
 *=============================================================================
 */
HRESULT A51Export::Export(const wchar_t *wszFilename, DWORD dwFlags, CRepository *pRepository)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	m_pRepository = pRepository;

	m_hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
						  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
						  NULL);

	if (m_hFile == INVALID_HANDLE_VALUE)
		hRes = WBEM_E_FAILED;

	try
	{
		if (SUCCEEDED(hRes))
			hRes = ExportHeader();

		if (SUCCEEDED(hRes))
			hRes = ExportNamespace(L"root");

		if (SUCCEEDED(hRes))
			hRes = WriteObjectType(A51_EXPORT_FILE_END_TAG);
	}
	catch (...)
	{
		hRes = WBEM_E_CRITICAL_ERROR;
	}

	if (m_hFile)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	m_hFile = INVALID_HANDLE_VALUE;

	return hRes;
}

/*=============================================================================
 *
 *	A51Export::ExportHeader
 *
 *	 File Header Block:
 *			BYTE wszFileHeader[8]							= A51_EXPORT_FILE_START_TAG ("a51exp1")
 *
 *=============================================================================
 */
HRESULT A51Export::ExportHeader()
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	char *pszHeader = A51_EXPORT_FILE_START_TAG;
	DWORD dwSize = sizeof(A51_EXPORT_FILE_START_TAG);
	if ((!WriteFile(m_hFile, pszHeader, dwSize, &dwSize, NULL)) || (dwSize != sizeof(A51_EXPORT_FILE_START_TAG)))
		hRes = WBEM_E_FAILED;

	return hRes;
}

/*=============================================================================
 *
 *	A51Export::ExportNamespace
 *
 *	 Namespace Block:
 *			DWORD   dwObjectType								= A51_EXPORT_NAMESPACE_TAG (0x00000001)
 *			DWORD   dwNamespaceNameSize
 *			BYTE	wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *
 *	[classes]
 *	[child namespaces]
 *
 *	 End of namespace block
 *			DWORD	dwObjectType								= A51_EXPORT_NAMESPACE_END_TAG (0x00000006)
 *
 *=============================================================================
 */
HRESULT A51Export::ExportNamespace(const wchar_t *wszNamespace)
{
	DEBUGTRACE((LOG_WBEMCORE, "Namespace export for namespace <%S>\n", wszNamespace));
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwSize = 0;

	// First, we need to write the namespace header
	//--------------------------------------------
	hRes = WriteObjectType(A51_EXPORT_NAMESPACE_TAG);

	if (SUCCEEDED(hRes))
	{
		DWORD dwNamespaceNameSize = (lstrlenW(wszNamespace) + 1) * sizeof(wchar_t);
		hRes = WriteBufferWithLength(dwNamespaceNameSize, (void*)wszNamespace);
	}

	//Second, we need to attach to the namespace so we can process it
	//---------------------------------------------------------------
	CNamespaceHandle *pNs = NULL;
	
	if (SUCCEEDED(hRes))
		pNs = new CNamespaceHandle(m_pControl, m_pRepository);
	CReleaseMe rm1(pNs);
	if (pNs == NULL)
		hRes = WBEM_E_OUT_OF_MEMORY;

	if (SUCCEEDED(hRes))
	{
		pNs->AddRef();
		hRes = pNs->Initialize(wszNamespace);
	}

	//Third, we need to enumerate all the base classes and process them
	//-----------------------------------------------------------------
	if (SUCCEEDED(hRes))
		hRes = ExportClass(pNs, L"", NULL);

	//Fourth, we need to enumerate all the child namespaces and process them
	//--------------------------------------------------------------------
	if (SUCCEEDED(hRes))
		hRes = ExportChildNamespaces(pNs, wszNamespace);

	//Finally, we need to write the namespace terminator tag for this namespace
	//-------------------------------------------------------------------------
	if (SUCCEEDED(hRes))
	{
		hRes = WriteObjectType(A51_EXPORT_NAMESPACE_END_TAG);
	}

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Namespace export failed for namespace <%S>, error <0x%X>\n", wszNamespace, hRes));
	}

	return hRes;
}

/*=============================================================================
 *
 *	A51Export::ExportClass
 *
 *	 Class Block:
 *			DWORD   dwObjectType								= A51_EXPORT_CLASS_TAG (0x00000002)
 *			DWORD   dwClassNameSize
 *			BYTE	wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *			DWORD   dwClassObjectSize
 *			BYTE	adwClassObject[dwClassObjectSize]
 *
 *	[instances of this class]
 *	[child classes of this class]
 *
 *	 End of class block
 *			DWORD	dwObjectType								= A51_EXPORT_CLASS_END_TAG (0x00000005)
 *
 *=============================================================================
 */
HRESULT A51Export::ExportClass(CNamespaceHandle *pNs, const wchar_t *wszClass, _IWmiObject *pClass)
{
	DEBUGTRACE((LOG_WBEMCORE, "Class export for class <%S>\n", wszClass));
	HRESULT hRes = WBEM_S_NO_ERROR;
	if (pClass)
	{
		//Write this class to the file
		//----------------------------

		//Write tag header
		hRes = WriteObjectType(A51_EXPORT_CLASS_TAG);

		//Write class name length
		if (SUCCEEDED(hRes))
		{
			DWORD dwClassNameSize = (lstrlenW(wszClass) + 1) * sizeof(wchar_t);
			hRes = WriteBufferWithLength(dwClassNameSize, (void*)wszClass);
		}

		//Write the class object
		if (SUCCEEDED(hRes))
		{
			hRes = WriteObjectBlob(pClass);
		}

		//Enumerate all instances of this class and write them
		//----------------------------------------------------
		if (SUCCEEDED(hRes))
		{
			hRes = ExportClassInstances(pNs, wszClass);
		}
	}

	//Enumerate all child classes of this class and write them
	//--------------------------------------------------------
	if (SUCCEEDED(hRes))
	{
		hRes = ExportChildClasses(pNs, wszClass);
	}

	if (pClass && SUCCEEDED(hRes))
	{
		//Write the class trailer object
		//------------------------------

		hRes = WriteObjectType(A51_EXPORT_CLASS_END_TAG);
	}

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Class export failed for class <%S>, error <0x%X>\n", wszClass, hRes));
	}
	return hRes;
}

/*=============================================================================
 *
 *	A51Export::ExportInstance
 *
 *	 Instance Block - key of type string
 *			DWORD	dwObjectType								= A51_EXPORT_INST_TAG (0x00000003)
 *			DWORD	dwInstanceKeySize
 *			BYTE	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *			DWORD	dwInstanceObjectSize
 *			BYTE	adwInstanceObject[dwInstanceObjectSize]
 *=============================================================================
 */
HRESULT A51Export::ExportInstance(_IWmiObject *pInstance)
{
	HRESULT hRes;

	//Get the key
	BSTR bstrKeyString = NULL;
	hRes = pInstance->GetKeyString(0, &bstrKeyString);
	CSysFreeMe sfm1(bstrKeyString);

	if (SUCCEEDED(hRes))
	{
		DEBUGTRACE((LOG_WBEMCORE, "Instance export for key<%S>\n", bstrKeyString));
	}
	//Write tag header
	if (SUCCEEDED(hRes))
	{
		hRes = WriteObjectType(A51_EXPORT_INST_TAG);
	}

	//Write key and length
	if (SUCCEEDED(hRes))
	{
		DWORD dwInstanceKeySize = (lstrlenW(bstrKeyString) + 1) * sizeof(wchar_t);
		hRes = WriteBufferWithLength(dwInstanceKeySize, bstrKeyString);
	}

	//Write the instance object
	if (SUCCEEDED(hRes))
	{
		hRes = WriteObjectBlob(pInstance);
	}

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Instance export fail for instance <%S>, error <0x%X>\n", bstrKeyString, hRes));
	}

	return hRes;
}

/*=============================================================================
 *
 *	A51Export::ExportChildNamespaces
 *
 *=============================================================================
 */
HRESULT A51Export::ExportChildNamespaces(CNamespaceHandle *pNs, const wchar_t *wszNamespace)
{
	DEBUGTRACE((LOG_WBEMCORE, "Child namespace export for namespace <%S>\n", wszNamespace));
    HRESULT hRes = 0;
    IWbemQuery *pQuery = NULL;
    IWmiDbIterator *pIterator = NULL;


	hRes = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery);
	CReleaseMe rm1(pQuery);

	//Do the query
    try
    {
		if (SUCCEEDED(hRes))
		{
			hRes = pQuery->Parse(L"SQL", L"select * from __namespace", 0);
		}

		if (SUCCEEDED(hRes))
			hRes = pNs->ExecQuery(pQuery, WBEM_FLAG_DEEP, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIterator);
    }
    catch(...)
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }
	CReleaseMe rm2(pIterator);


	//Iterate through the results and process each namespace
    REFIID riid = IID__IWmiObject;
    DWORD dwObjects = 0;

    while (SUCCEEDED(hRes))
    {
        _IWmiObject *pInst = 0;
        DWORD dwReturned = 0;

        hRes = pIterator->NextBatch(1, 5, 0, WMIDB_HANDLE_TYPE_COOKIE, riid, &dwReturned, (LPVOID *) &pInst);
		CReleaseMe rm3(pInst);
		
		//TODO: HACK: Find out why this is happening!!!!
		if (hRes == WBEM_E_NOT_FOUND)
		{
			hRes = WBEM_S_NO_ERROR;
			break;
		}

        if (dwReturned == 0 || pInst == 0 || FAILED(hRes))
            break;

		BSTR bstrKeyString = NULL;
		hRes = pInst->GetKeyString(0, &bstrKeyString);
		CSysFreeMe sfm1(bstrKeyString);

		wchar_t *wszFullNamespace = new wchar_t[lstrlenW(wszNamespace) + lstrlenW(bstrKeyString) + lstrlenW(L"\\") + 1];
		CVectorDeleteMe<wchar_t> vdm2(wszFullNamespace);
		if (wszFullNamespace == NULL)
		{
			hRes = WBEM_E_OUT_OF_MEMORY;
			break;
		}
		lstrcpyW(wszFullNamespace, wszNamespace);
		lstrcatW(wszFullNamespace, L"\\");
		lstrcatW(wszFullNamespace, bstrKeyString);

		hRes = ExportNamespace(wszFullNamespace);
    }

    if (SUCCEEDED(hRes))
        hRes = WBEM_S_NO_ERROR;
 
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Child namespaces export failed for namespace <%S>, error <0x%X>\n", wszNamespace, hRes));
	}
    return hRes;
}
/*=============================================================================
 *
 *	A51Export::ExportChildClasses
 *
 *=============================================================================
 */
HRESULT A51Export::ExportChildClasses(CNamespaceHandle *pNs, const wchar_t *wszClassName)
{
	DEBUGTRACE((LOG_WBEMCORE, "Child classes export for class <%S>\n", wszClassName));
    HRESULT hRes = 0;
    IWbemQuery *pQuery = NULL;
    IWmiDbIterator *pIterator = NULL;

	//Build up the instance query
	wchar_t *wszQuery = new wchar_t[lstrlenW(wszClassName) + lstrlenW(L"select * from meta_class where __SUPERCLASS = \"\"") + 1];
	if (wszQuery == NULL)
		hRes = WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> vdm1(wszQuery);

	if (SUCCEEDED(hRes))
	{
		lstrcpyW(wszQuery, L"select * from meta_class where __SUPERCLASS = \"");
		lstrcatW(wszQuery, wszClassName);
		lstrcatW(wszQuery, L"\"");
	}

	if (SUCCEEDED(hRes))
		hRes = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery);
	CReleaseMe rm1(pQuery);

    try
    {
		if (SUCCEEDED(hRes))
		{
			hRes = pQuery->Parse(L"SQL", wszQuery, 0);
		}

		if (SUCCEEDED(hRes))
			hRes = pNs->ExecQuery(pQuery, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIterator);
    }
    catch(...)
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }
	CReleaseMe rm2(pIterator);

    // If here, there are results, I guess.
    // ====================================

    REFIID riid = IID__IWmiObject;
    DWORD dwObjects = 0;

    while (SUCCEEDED(hRes))
    {
        _IWmiObject *pClass = 0;
        DWORD dwReturned = 0;

        hRes = pIterator->NextBatch(1, 5, 0, WMIDB_HANDLE_TYPE_COOKIE, riid, &dwReturned, (LPVOID *) &pClass);
		CReleaseMe rm3(pClass);

		//TODO: HACK: Find out why this is happening!!!!
		if (hRes == WBEM_E_NOT_FOUND)
		{
			hRes = WBEM_S_NO_ERROR;
			break;
		}

        if (dwReturned == 0 || pClass == 0 || FAILED(hRes))
            break;

		VARIANT var;
		VariantInit(&var);
		hRes = pClass->Get(L"__class", 0, &var, NULL, NULL);
		if (SUCCEEDED(hRes))
			hRes = ExportClass(pNs, V_BSTR(&var), pClass);
		VariantClear(&var);
    }

    if (SUCCEEDED(hRes))
        hRes = WBEM_S_NO_ERROR;
 
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Child classes export failed for class <%S>, error <0x%X>\n", wszClassName, hRes));
	}
    return hRes;
}
/*=============================================================================
 *
 *	A51Export::ExportClassInstances
 *
 *=============================================================================
 */
HRESULT A51Export::ExportClassInstances(CNamespaceHandle *pNs, const wchar_t *wszClassName)
{
 	DEBUGTRACE((LOG_WBEMCORE, "Class instances export for class <%S>\n", wszClassName));
	HRESULT hRes = 0;
    IWbemQuery *pQuery = NULL;
    IWmiDbIterator *pIterator = NULL;

	//Build up the instance query
	wchar_t *wszQuery = new wchar_t[lstrlenW(wszClassName) + lstrlenW(L"select * from ") + 1];
	if (wszQuery == NULL)
		hRes = WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> vdm1(wszQuery);

	if (SUCCEEDED(hRes))
	{
		lstrcpyW(wszQuery, L"select * from ");
		lstrcatW(wszQuery, wszClassName);
	}

	if (SUCCEEDED(hRes))
		hRes = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery);
	CReleaseMe rm1(pQuery);

    try
    {
		if (SUCCEEDED(hRes))
		{
			hRes = pQuery->Parse(L"SQL", wszQuery, 0);
		}

		if (SUCCEEDED(hRes))
			hRes = pNs->ExecQuery(pQuery, WBEM_FLAG_SHALLOW, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIterator);
    }
    catch(...)
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }
	CReleaseMe rm2(pIterator);

    // If here, there are results, I guess.
    // ====================================

    REFIID riid = IID__IWmiObject;
    DWORD dwObjects = 0;

    while (SUCCEEDED(hRes))
    {
        _IWmiObject *pInst = 0;
        DWORD dwReturned = 0;

        hRes = pIterator->NextBatch(1, 5, 0, WMIDB_HANDLE_TYPE_COOKIE, riid, &dwReturned, (LPVOID *) &pInst);
		CReleaseMe rm3(pInst);
		
		//TODO: HACK: Find out why this is happening!!!!
		if (hRes == WBEM_E_NOT_FOUND)
		{
			hRes = WBEM_S_NO_ERROR;
			break;
		}

        if (dwReturned == 0 || pInst == 0 || FAILED(hRes))
            break;

		hRes = ExportInstance(pInst);
    }

    if (SUCCEEDED(hRes))
        hRes = WBEM_S_NO_ERROR;
 
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Child class instances export failed for class <%S>, error <0x%X>\n", wszClassName, hRes));
	}
    return hRes;
}


/*=============================================================================
 *
 *	A51Export::WriteBufferWithLength
 *
 *=============================================================================
 */
HRESULT A51Export::WriteBufferWithLength(DWORD dwBufferSize, void *pBuffer)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwSize;
	
	//Write buffer length
	if (!WriteFile(m_hFile, &dwBufferSize, sizeof(DWORD), &dwSize, NULL) || (dwSize != sizeof(DWORD)))
	{
		hRes = WBEM_E_FAILED;
	}

	//Write buffer
	if (SUCCEEDED(hRes) &&
		(!WriteFile(m_hFile, pBuffer, dwBufferSize, &dwSize, NULL) || (dwBufferSize != dwSize)))
	{
		hRes = WBEM_E_FAILED;
	}

	return hRes;
}

/*=============================================================================
 *
 *	A51Export::WriteObjectType
 *
 *=============================================================================
 */
HRESULT A51Export::WriteObjectType(DWORD dwObjectType)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwSize;

	if (!WriteFile(m_hFile, &dwObjectType, sizeof(DWORD), &dwSize, NULL) || (dwSize != sizeof(DWORD)))
	{
		hRes = WBEM_E_FAILED;
	}


	return hRes;
}

/*=============================================================================
 *
 *	A51Export::WriteObjectBlob
 *
 *=============================================================================
 */
HRESULT A51Export::WriteObjectBlob(_IWmiObject *pObject)
{
	HRESULT hRes;
	DWORD dwObjPartLen = 0;
	BYTE *pObjPart = NULL;

	//Get the size of the object
	hRes = pObject->Unmerge(0, 0, &dwObjPartLen, 0);

	//Allocate the size of the object
	if (hRes == WBEM_E_BUFFER_TOO_SMALL)
	{
		hRes = WBEM_S_NO_ERROR;
		pObjPart = new BYTE[dwObjPartLen];
		if (pObjPart == NULL)
			hRes = WBEM_E_OUT_OF_MEMORY;
	}
	CVectorDeleteMe<BYTE> vdm1(pObjPart);

	//retrieve the object blob
	if (SUCCEEDED(hRes))
	{
		DWORD dwLen;
		hRes = pObject->Unmerge(0, dwObjPartLen, &dwLen, pObjPart);
	}
		
	//Write object blob and length
	if (SUCCEEDED(hRes))
	{
		hRes = WriteBufferWithLength(dwObjPartLen, pObjPart);
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51exp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    A51Exp.h

Abstract:

    Exports the repository into a interchange format that can easily be re-imported.

History:

	08-Dec-2000		paulall		Created.

--*/

#define A51_EXPORT_FILE_START_TAG		"a51exp1"
#define A51_EXPORT_NAMESPACE_TAG		0x00000001
#define A51_EXPORT_CLASS_TAG			0x00000002
#define A51_EXPORT_INST_TAG				0x00000003
#define A51_EXPORT_CLASS_END_TAG		0x00000005
#define A51_EXPORT_NAMESPACE_END_TAG	0x00000006
#define A51_EXPORT_FILE_END_TAG			DWORD(-1)

class CLifeControl;

class A51Export
{
private:
	HANDLE m_hFile;
	CRepository *m_pRepository;
	CLifeControl* m_pControl;

protected:
			
	HRESULT ExportHeader();
	HRESULT ExportNamespace(const wchar_t *wszNamespace);
	HRESULT ExportClass(CNamespaceHandle *pNs, const wchar_t *wszClassName, _IWmiObject *pClass);
	HRESULT ExportInstance(_IWmiObject *pInstance);

	HRESULT ExportChildNamespaces(CNamespaceHandle *pNs, const wchar_t *wszNamespace);
	HRESULT ExportChildClasses(CNamespaceHandle *pNs, const wchar_t *wszClassName);
	HRESULT ExportClassInstances(CNamespaceHandle *pNs, const wchar_t *wszClassName);

	HRESULT WriteBufferWithLength(DWORD dwBufferSize, void *pBuffer);
	HRESULT WriteObjectType(DWORD dwTag);
	HRESULT WriteObjectBlob(_IWmiObject *pObject);

public:
	HRESULT Export(const wchar_t *wszFilename, DWORD dwFlags, CRepository *pRepository);
	A51Export(CLifeControl* pControl);
	~A51Export();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51imp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    A51Imp.h

Abstract:

    Imports a previously exported repository, dealing with class updates along the way.

History:

	08-Dec-2000		paulall		Created.

--*/

class A51Import
{
private:
	HANDLE m_hFile;
	CRepository *m_pRepository;
	bool m_bSkipMode;

protected:
	HRESULT ImportHeader();
	HRESULT ImportNamespace();
	HRESULT ImportClass(CNamespaceHandle *pNs, _IWmiObject *pOldParentClass, _IWmiObject *pNewParentClass);
	HRESULT ImportInstance(CNamespaceHandle *pNs, _IWmiObject *pOldParentClass, _IWmiObject *pNewParentClass);

	HRESULT ReadObjectType(DWORD *pdwType);
	HRESULT ReadBufferWithLength(DWORD *pdwLength, void** ppMemoryBlob);

	HRESULT BeginTransaction();
	HRESULT AbortTransaction();
	HRESULT CommitTransaction();

public:
	HRESULT Import(const wchar_t *wszFilename, DWORD dwFlags, CRepository *pRepository);
	A51Import();
	~A51Import();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51imp.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    A51Imp.cpp

Abstract:

    Imports an export file into the repository.  This uses the export file format defined 
	in A51Exp.cpp.
	

History:

	08-Dec-2000		paulall		Created.

--*/

#include <windows.h>
#include <ql.h>
#include "A51Rep.h"
#include "A51Exp.h"
#include "A51Imp.h"

//extern CFileCache* g_FileCache;
extern CGlobals g_Glob;

/*=============================================================================
 *
 *	A51Import::A51Import
 *
 *=============================================================================
 */
A51Import::A51Import()
: m_hFile(INVALID_HANDLE_VALUE),
  m_bSkipMode(false)
{
}

/*=============================================================================
 *
 *	A51Import::~A51Import
 *
 *=============================================================================
 */
A51Import::~A51Import()
{
}

/*=============================================================================
 *
 *	A51Import::Import
 *
 *=============================================================================
 */
HRESULT A51Import::Import(const wchar_t *wszFilename, DWORD dwFlags, CRepository *pRepository)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	m_pRepository = pRepository;

	//Open the import file for reading
	m_hFile = CreateFileW(wszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
						  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
						  NULL);

	if (m_hFile == INVALID_HANDLE_VALUE)
		hRes = WBEM_E_FAILED;

	try
	{
		//Check the header is valid, in case we were given an invalid file format
		if (SUCCEEDED(hRes))
			hRes = ImportHeader();

		//Retrieve the type of the next object to process
		DWORD dwObjectType;
		if (SUCCEEDED(hRes))
		{
			hRes = ReadObjectType(&dwObjectType);
		}

		//While we are not at the end of the file, loop through the items
		while (SUCCEEDED(hRes) && (dwObjectType != A51_EXPORT_FILE_END_TAG))
		{
			//Only namespace objects should reside at this level!
			switch (dwObjectType)
			{
				case A51_EXPORT_NAMESPACE_TAG:
				{
					hRes = ImportNamespace();
					break;
				}
				default:
				{
					hRes = WBEM_E_FAILED;
					break;
				}
			}

			//Get the next type of object
			if (SUCCEEDED(hRes))
			{
				hRes = ReadObjectType(&dwObjectType);
			}
		}
	}
	catch (...)
	{
		hRes = WBEM_E_CRITICAL_ERROR;
		ERRORTRACE((LOG_WBEMCORE, "Critical error happened while re-importing the repository, error <0x%X>\n", hRes));
	}

	if (m_hFile)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	m_hFile = INVALID_HANDLE_VALUE;

	return hRes;
}

/*=============================================================================
 *
 *	A51Import::ImportHeader
 *
 *	 File Header Block:
 *			BYTE wszFileHeader[8]		= A51_EXPORT_FILE_START_TAG ("a51exp1")
 *
 *=============================================================================
 */
HRESULT A51Import::ImportHeader()
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	char *pszExpectedHeader = A51_EXPORT_FILE_START_TAG;
	DWORD dwSize = sizeof(A51_EXPORT_FILE_START_TAG);
	char *pszActualHeader = new char[dwSize];
	CVectorDeleteMe<char> vdm1(pszActualHeader);
	if (pszActualHeader == NULL)
	{
		hRes = WBEM_E_OUT_OF_MEMORY;
	}

	//Read header
	if (SUCCEEDED(hRes) &&
		((!ReadFile(m_hFile, pszActualHeader, dwSize, &dwSize, NULL)) || 
		 (dwSize != sizeof(A51_EXPORT_FILE_START_TAG))))
	{
		hRes = WBEM_E_FAILED;
	}

	//If last character is not a NULL terminator then it fails outright!
	if (SUCCEEDED(hRes) && (pszActualHeader[sizeof(A51_EXPORT_FILE_START_TAG) - 1] != '\0'))
	{
		hRes = WBEM_E_FAILED;
	}

	//Do check to see if rest is the same....
	if ((SUCCEEDED(hRes)) && (lstrcmpA(pszExpectedHeader, pszActualHeader) != 0))
	{
		hRes = WBEM_E_FAILED;
	}

	return hRes;
}
/*=============================================================================
 *
 *	A51Import::ImportNamespace
 *
 *	Namespace Block:
 *		DWORD   dwObjectType							= A51_EXPORT_NAMESPACE_TAG
 *		DWORD   dwNamespaceNameSize
 *		BYTE	wszNamespaceName[dwNamespaceNameSize]	= Full namespace name
 *
 *=============================================================================
 */
HRESULT A51Import::ImportNamespace()
{
	HRESULT hRes;
	DWORD dwLength = 0;
	wchar_t *wszNamespaceName = NULL;

	//Retrieve the namespace name from the import file
	hRes = ReadBufferWithLength(&dwLength, (void**) &wszNamespaceName);
	CVectorDeleteMe<wchar_t> vdm1(wszNamespaceName);

	//Create a namespace object for this namespace
	CNamespaceHandle *pNs = NULL;
	if (SUCCEEDED(hRes))
	{
		DEBUGTRACE((LOG_WBEMCORE, "Namespace import for namespace <%S>\n", wszNamespaceName));
		pNs = new CNamespaceHandle(NULL, m_pRepository);
		if (pNs == NULL)
			hRes = WBEM_E_OUT_OF_MEMORY;
		else
		{
			pNs->AddRef();
			hRes = pNs->Initialize(wszNamespaceName);
		}
	}
	CReleaseMe rm1(pNs);

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Namespace import failed for namespace <%S>, error <0x%X>\n", wszNamespaceName, hRes));
	}

	//Retrieve the type of the next object in the import file
	DWORD dwObjectType;
	if (SUCCEEDED(hRes))
	{
		hRes = ReadObjectType(&dwObjectType);
	}

	//Loop through all things that hang off this namespace
	while (SUCCEEDED(hRes) && (dwObjectType != A51_EXPORT_NAMESPACE_END_TAG))
	{
		//Classes and namespaces are the only valid things to hang off a namespace
		switch (dwObjectType)
		{
		case A51_EXPORT_CLASS_TAG:
		{
			//TODO: Need to create an empty class to pass through here!
			hRes = ImportClass(pNs, NULL, NULL);
			break;
		}
		case A51_EXPORT_NAMESPACE_TAG:
		{
			hRes = ImportNamespace();
			break;
		}
		default:
			hRes = WBEM_E_FAILED;
			break;
		}

		if (SUCCEEDED(hRes))
		{
			hRes = ReadObjectType(&dwObjectType);
		}
	}

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Namespace import failed for child classes/namespace <%S>, error <0x%X>\n", wszNamespaceName, hRes));
	}
	return hRes;
}

/*=============================================================================
 *
 *	A51Import::ImportClass
 *
 * Class Block:
 *		DWORD   dwObjectType						= A51_EXPORT_CLASS_TAG
 *		DWORD   dwClassNameSize
 *		BYTE	wszClassName[dwClassNameSize]		= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		BYTE	adwClassObject[dwClassObjectSize]
 *
 *=============================================================================
 */
HRESULT A51Import::ImportClass(CNamespaceHandle *pNs, 
							   _IWmiObject *pOldParentClass, 
							   _IWmiObject *pNewParentClass)
{
	HRESULT hRes;
	DWORD dwLength = 0;
	_IWmiObject *pOldClass = NULL;
	_IWmiObject *pNewClass = NULL;
	wchar_t *wszClassName = NULL;

	//Retrieve the class name from the import file
	hRes = ReadBufferWithLength(&dwLength, (void**) &wszClassName);
	CVectorDeleteMe<wchar_t> vdm1(wszClassName );

	{//scope to free everything we don't need when recursing to lower levels

		//Retrieve the class object from the import file
		BYTE *pClassBlob = NULL;
		if (SUCCEEDED(hRes))
		{
			DEBUGTRACE((LOG_WBEMCORE, "Class import for class <%S>\n", wszClassName));
			hRes = ReadBufferWithLength(&dwLength, (void**) &pClassBlob);
		}
		CVectorDeleteMe<BYTE> vdm2(pClassBlob);

		//For Skip Mode we have to read everything from the import file, but not process anything
		//until the flag is reset...
		if (!m_bSkipMode)
		{

			//if pOldParentClass is NULL, we need to create a blank class
			if (SUCCEEDED(hRes) && (pOldParentClass == NULL))
			{
				hRes = pNs->GetObjectByPath(L"", 0, IID__IWmiObject, (void**)&pOldParentClass);
				if (FAILED(hRes))
				{
					ERRORTRACE((LOG_WBEMCORE, "Class import failed for class <%S>, error <0x%X>, GetObjectByPath(L\"\",...)\n", wszClassName, hRes));
				}

			}

			//Create the current version of this class
			if (SUCCEEDED(hRes))
			{
				hRes = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_CLASS, dwLength, pClassBlob, &pOldClass);
				if (FAILED(hRes))
				{
					ERRORTRACE((LOG_WBEMCORE, "Class import failed for class <%S>, error <0x%X>, Merge\n", wszClassName, hRes));
				}
			}

			//Now we need to upgrade this class based on the new parent class...
			_IWmiObject *pTmpNewClass = NULL;
			if (SUCCEEDED(hRes))
			{
				hRes = pOldClass->Upgrade(pNewParentClass, 0, &pTmpNewClass );
				if (FAILED(hRes))
				{
					ERRORTRACE((LOG_WBEMCORE, "Class import failed for class <%S>, error <0x%X>, Upgrade\n", wszClassName, hRes));
				}
			}
			CReleaseMe rm2(pTmpNewClass );

			//Write the new class back to the repository if it is not a system class
			if (SUCCEEDED(hRes) && (wszClassName[0] != L'_'))
			{
				hRes = BeginTransaction();
				if (SUCCEEDED(hRes))
				{
					try
					{
						CEventCollector aEvents;
						hRes = pNs->PutObject(IID__IWmiObject, pTmpNewClass , WBEM_FLAG_UPDATE_FORCE_MODE, 
											  WMIDB_HANDLE_TYPE_COOKIE, 0, aEvents);
						if (FAILED(hRes))
						{
							AbortTransaction();
							ERRORTRACE((LOG_WBEMCORE, "Class import failed for class <%S>, error <0x%X>, PutObject\n", wszClassName, hRes));
						}
						else
						{
							hRes = CommitTransaction();
							if (FAILED(hRes))
							{
								AbortTransaction();
							}
						}
					}
					catch (...)
					{
						AbortTransaction();
						throw;
					}
				}
			}

			//Now we need to get that object back from the repository before we do anything
			if (SUCCEEDED(hRes))
			{
				hRes = pNs->GetObjectByPath(wszClassName, 0, IID__IWmiObject, (void**)&pNewClass);
				if (FAILED(hRes))
				{
					ERRORTRACE((LOG_WBEMCORE, "Class import failed for class <%S>, error <0x%X>, GetObjectByPath(wszClassName,...)\n", wszClassName, hRes));
				}
				if (hRes == WBEM_E_NOT_FOUND)
				{
					m_bSkipMode = true;
					hRes = WBEM_S_NO_ERROR;
				}
			}
		}
	}
	CReleaseMe rm1(pOldClass);
	CReleaseMe rm3(pNewClass);

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Class import failed for class <%S>, error <0x%X>\n", wszClassName, hRes));
	}

	//Process the next object...
	DWORD dwObjectType;
	if (SUCCEEDED(hRes))
	{
		hRes = ReadObjectType(&dwObjectType);
	}

	//Loop through all things that hang off this class
	while (SUCCEEDED(hRes) && (dwObjectType != A51_EXPORT_CLASS_END_TAG))
	{
		//Classes and namespaces are the only valid things to hang off a namespace
		switch (dwObjectType)
		{
		case A51_EXPORT_CLASS_TAG:
		{
			hRes = ImportClass(pNs, pOldClass, pNewClass);
			break;
		}
		case A51_EXPORT_INST_TAG:
		{
			hRes = ImportInstance(pNs, pOldClass, pNewClass);
			break;
		}
		default:
			hRes = WBEM_E_FAILED;
			break;
		}

		if (SUCCEEDED(hRes))
		{
			hRes = ReadObjectType(&dwObjectType);
		}
	}

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Namespace import failed for child classes/instances <%S>, error <0x%X>\n", wszClassName, hRes));
	}
	m_bSkipMode = false;

	return hRes;
}

/*=============================================================================
 *
 *	A51Import::ImportInstance
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= A51_EXPORT_INST_TAG
 *		DWORD	dwInstanceKeySize
 *		BYTE	dwInstanceKey[dwInstanceKeySize]			= Instance key
 *		DWORD	dwInstanceObjectSize
 *		BYTE	adwInstanceObject[dwInstanceObjectSize]
 *
 *=============================================================================
 */
HRESULT A51Import::ImportInstance(CNamespaceHandle *pNs, 
								  _IWmiObject *pOldParentClass, 
								  _IWmiObject *pNewParentClass)
{
	HRESULT hRes;
	DWORD dwLength = 0;

	//Retrieve the key string from the import file
	wchar_t *wszKeyString = NULL;
	hRes = ReadBufferWithLength(&dwLength, (void**) &wszKeyString) ;
	CVectorDeleteMe<wchar_t> vdm1(wszKeyString);

	//Retrieve the instance object from the import file
	BYTE *pInstBlob = NULL;
	if (SUCCEEDED(hRes))
	{
		DEBUGTRACE((LOG_WBEMCORE, "Instance import for instance <%S>\n", wszKeyString));
		hRes = ReadBufferWithLength(&dwLength, (void**) &pInstBlob);
	}
	CVectorDeleteMe<BYTE> vdm2(pInstBlob);
	

	if (!m_bSkipMode)
	{
		_IWmiObject *pOldInstance = NULL;

		//Merge the old instance part with the old instance class
		if (SUCCEEDED(hRes))
		{
			hRes = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, 
									dwLength, pInstBlob, &pOldInstance);
		}
		CReleaseMe rm1(pOldInstance);

		//Upgrade the instance to work with the new class
		_IWmiObject *pNewInstance = NULL;
		if (SUCCEEDED(hRes))
		{
			hRes = pOldInstance->Upgrade(pNewParentClass, 0, &pNewInstance);
		}
		CReleaseMe rm2(pNewInstance);

		//Put the instance into the repository
		if (SUCCEEDED(hRes))
		{
			hRes = BeginTransaction();
			if (SUCCEEDED(hRes))
			{
				try
				{
					CEventCollector aEvents;
					hRes = pNs->PutObject(IID__IWmiObject, pNewInstance, 0, WMIDB_HANDLE_TYPE_COOKIE, NULL, aEvents);

					if (SUCCEEDED(hRes))
					{
						hRes = CommitTransaction();
						if (FAILED(hRes))
						{
							AbortTransaction();
						}
					}
					else
					{
						AbortTransaction();
					}

				}
				catch (...)
				{
					AbortTransaction();
					throw;
				}
			}
		}
	}

	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Instance import failed for instance <%S>, error <0x%X>\n", wszKeyString, hRes));
	}
	return hRes;
}

/*=============================================================================
 *
 *	A51Import::ReadBufferWithLength
 *
 *=============================================================================
 */
HRESULT A51Import::ReadBufferWithLength(DWORD *pdwBufferSize, void **ppBuffer)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwSize;
	
	//Write buffer length
	if (!ReadFile(m_hFile, pdwBufferSize, sizeof(DWORD), &dwSize, NULL) || (dwSize != sizeof(DWORD)))
	{
		hRes = WBEM_E_FAILED;
	}

	if (SUCCEEDED(hRes))
	{
		*ppBuffer = (void*)new BYTE[*pdwBufferSize];
		if (*ppBuffer == NULL)
			hRes = WBEM_E_OUT_OF_MEMORY;
	}

	//Write buffer
	if (SUCCEEDED(hRes) &&
		(!ReadFile(m_hFile, *ppBuffer, *pdwBufferSize, &dwSize, NULL) || (*pdwBufferSize != dwSize)))
	{
		hRes = WBEM_E_FAILED;
	}

	if (FAILED(hRes))
	{
		delete [] *ppBuffer;
		*ppBuffer = NULL;
		*pdwBufferSize = 0;
	}

	return hRes;
}

/*=============================================================================
 *
 *	A51Import::ReadObjectType
 *
 *
 *=============================================================================
 */
HRESULT A51Import::ReadObjectType(DWORD *pdwObjectType)
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwSize;

	if (!ReadFile(m_hFile, pdwObjectType, sizeof(DWORD), &dwSize, NULL) || (dwSize != sizeof(DWORD)))
	{
		hRes = WBEM_E_FAILED;
	}


	return hRes;
}

/*=============================================================================
 *
 *	A51Import::BeginTransaction
 *
 *
 *=============================================================================
 */
HRESULT A51Import::BeginTransaction()
{
	return A51TranslateErrorCode(g_Glob.GetFileCache()->BeginTransaction());
}

/*=============================================================================
 *
 *	A51Import::CommitTransaction
 *
 *
 *=============================================================================
 */
HRESULT A51Import::CommitTransaction()
{
	return A51TranslateErrorCode(g_Glob.GetFileCache()->CommitTransaction());
}

/*=============================================================================
 *
 *	A51Import::AbortTransaction
 *
 *
 *=============================================================================
 */
HRESULT A51Import::AbortTransaction()
{
	return A51TranslateErrorCode(g_Glob.GetFileCache()->AbortTransaction());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51fib.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_FIBER__H_
#define __A51_FIBER__H_

class CFiberTask
{
public:
    virtual ~CFiberTask(){}
    virtual HRESULT Execute() = 0;
};

void* CreateFiberForTask(CFiberTask* pTask);
void ReturnFiber(void* pFiber);

void* CreateOrGetCurrentFiber();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51tools.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51_TOOLS__H_
#define __A51_TOOLS__H_

#include <sync.h>
#include <newnew.h>
#include <xmemory>

#ifdef DBG
  #define _A51_INTERNAL_ASSERT
#endif

typedef LONGLONG TFileOffset;

#define MAX_HASH_LEN 32

void* TempAlloc(DWORD dwLen);
void TempFree(void* p, DWORD dwLen = 0);

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen);
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen = 0);

HRESULT A51TranslateErrorCode(long lRes);

#define TEMPFREE_ME

class CTempFreeMe
{
protected:
    void* m_p;
    DWORD m_dwLen;
public:
    CTempFreeMe(void* p, DWORD dwLen = 0) : m_p(p), m_dwLen(dwLen){}
    ~CTempFreeMe() {TempFree(m_p, m_dwLen);}
};

HANDLE A51GetNewEvent();
void A51ReturnEvent(HANDLE hEvent);

class CReturnMe
{
protected:
    HANDLE m_h;
public:
    CReturnMe(HANDLE h) : m_h(h){}
    ~CReturnMe() {A51ReturnEvent(m_h);}
};


inline void wbem_wcsupr(WCHAR* pwcTo, const WCHAR* pwcFrom)
{
    while(*pwcFrom)
    {
        if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
            *pwcTo = *pwcFrom + ('A'-'a');
        else if(*pwcFrom < 128)
            *pwcTo = *pwcFrom;
        else 
            *pwcTo = towupper(*pwcFrom);
        pwcTo++;
        pwcFrom++;
    }
    *pwcTo = 0;
}

class CFileName
{
private:
	wchar_t *m_wszFilename;

public:
	DWORD Length() { return MAX_PATH + 1; }
	CFileName() { m_wszFilename = (wchar_t*)TempAlloc(sizeof(wchar_t) * Length()); }
	~CFileName() { TempFree(m_wszFilename, sizeof(wchar_t) * Length()); }
	operator wchar_t *() { return m_wszFilename; }
};

long EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
long EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA = NULL);
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash);
long A51DeleteFile(LPCWSTR wszFullPath);
long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer);
long A51RemoveDirectory(LPCWSTR wszFullPath, bool bAbortOnFiles = true);
long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51WriteToFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);
long A51ReadFromFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen, OVERLAPPED* pov);
long A51ReadFromFileSync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
                        DWORD dwBufferLen);

extern __int64 g_nCurrentTime;

#undef _ASSERT

#ifdef _A51_INTERNAL_ASSERT
#define _ASSERT(X, MSG) {if(!(X)) {A51TraceFlush(); DebugBreak();}}
#else
#define _ASSERT(X, MSG)
#endif

extern FILE* g_fLog;

#ifdef _A51_INTERNAL_DEBUG
#define A51TRACE(X) A51Trace X
#else
#define A51TRACE(X)
#endif

void A51Trace(LPCSTR szFormat, ...);

void A51TraceFlush();

template<class T>
class CTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    char* _Charalloc(size_t n)
    {
        return (char*)TempAlloc(n);
    }

    void deallocate(void* p, size_t n)
    {
        TempFree(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
};

template<class T>
class CPrivateTempAllocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T *pointer;
    typedef const T *const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    CPrivateTempAllocator(CTempMemoryManager* pManager) 
        : m_pManager(pManager)
    {}
    
    char* _Charalloc(size_t n)
    {
        return (char*)m_pManager->Allocate(n);
    }

    void deallocate(void* p, size_t n)
    {
        m_pManager->Free(p, 0);
    }

    void construct(pointer p, const T& val)
    {
        new ((void*)p) T(val);
    }

    void destroy(pointer p)
    {
        p->T::~T();
    }
protected:
    CTempMemoryManager* m_pManager;
};

#ifdef A51_CHECK_HRESULTS

class CHR
{
protected:
    HRESULT m_hres;
    bool m_bTested;

public:
    CHR(HRESULT hres) : m_hres(hres), m_bTested(false){}
    ~CHR() {_ASSERT(m_bTested, L"");}
    operator HRESULT() {m_bTested = true; return m_hres;}
};
        
#else

typedef HRESULT CHR;

#endif
    
            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51rep.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "lock.h"
#include <persistcfg.h>
#include "a51fib.h"
#include "RepositoryPackager.h"
#include "a51conv.h"
#include "A51Exp.h"
#include "A51Imp.h"


//**************************************************************************************************



HRESULT STDMETHODCALLTYPE CSession::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWmiDbSession || 
                riid == IID_IWmiDbSessionEx)
    {
        AddRef();
        *ppv = this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CSession::Release()
{
    return CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>::Release();
}

CSession::~CSession()
{
}
    

HRESULT STDMETHODCALLTYPE CSession::GetObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
        {
            return WBEM_E_SHUTTING_DOWN;
        }
    
        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->GetObject(pPath, dwFlags, dwRequestedHandleType, 
                                        ppResult);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}


HRESULT STDMETHODCALLTYPE CSession::GetObjectDirect(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->GetObjectDirect(pPath, dwFlags, riid, pObj);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::GetObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		DWORD dwLen = wcslen(wszObjectPath)+1;
		LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
		if (wszPath == NULL)
        {
			return WBEM_E_OUT_OF_MEMORY;
        }
		wcscpy(wszPath, wszObjectPath);

		CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));
		hres = pNs->GetObjectByPath(wszPath, dwFlags, riid, pObj);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
    


HRESULT STDMETHODCALLTYPE CSession::PutObject(
     IWmiDbHandle *pScope,
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock, FALSE);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            lRes = g_Glob.GetFileCache()->BeginTransaction();
            if(lRes != ERROR_SUCCESS)
                return A51TranslateErrorCode(lRes);
            g_Glob.GetForestCache()->BeginTransaction();
        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;


        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                g_Glob.GetFileCache()->AbortTransaction();
                g_Glob.GetForestCache()->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

		hres =  pNs->PutObject(riid, pObj, dwFlags, dwRequestedHandleType, ppResult, *aEvents);
        
        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                g_Glob.GetFileCache()->AbortTransaction();
                g_Glob.GetForestCache()->AbortTransaction();
            }
            else
            {
                lRes = g_Glob.GetFileCache()->CommitTransaction();
                if(lRes != ERROR_SUCCESS)
                {
                    hres = A51TranslateErrorCode(lRes);
                    g_Glob.GetFileCache()->AbortTransaction();
                    g_Glob.GetForestCache()->AbortTransaction();
                }
                else
                {
                    g_Glob.GetForestCache()->CommitTransaction();
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }
    
		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObject(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj
    )
{
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock, FALSE);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            lRes = g_Glob.GetFileCache()->BeginTransaction();
            if(lRes != ERROR_SUCCESS)
                return A51TranslateErrorCode(lRes);

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                g_Glob.GetFileCache()->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }

		hres = pNs->DeleteObject(dwFlags, riid, pObj, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                g_Glob.GetFileCache()->AbortTransaction();
            }
            else
            {
                lRes = g_Glob.GetFileCache()->CommitTransaction();
                if(lRes != ERROR_SUCCESS)
                {
                    hres = A51TranslateErrorCode(lRes);
                    g_Glob.GetFileCache()->AbortTransaction();
                }
                else
                {
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);                    
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::DeleteObjectByPath(
     IWmiDbHandle *pScope,
     LPCWSTR wszObjectPath,
     DWORD dwFlags
    )
{
	try
	{
        HRESULT hres;
        long lRes;
        CAutoWriteLock lock(&g_readWriteLock, FALSE);
        CEventCollector aNonTransactedEvents;
        CEventCollector *aEvents = &m_aTransactedEvents;

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
            if (g_bShuttingDown)
                return WBEM_E_SHUTTING_DOWN;
            aEvents = &aNonTransactedEvents;
            lRes = g_Glob.GetFileCache()->BeginTransaction();
            if(lRes != ERROR_SUCCESS)
                return A51TranslateErrorCode(lRes);

        }
        else if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            if(!m_bInWriteTransaction)
            {
                g_Glob.GetFileCache()->AbortTransaction();
            }
            return pNs->GetErrorStatus();
        }
		DWORD dwLen = wcslen(wszObjectPath)+1;
		LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
		if (wszPath == NULL)
        {
            if(!m_bInWriteTransaction)
            {
                g_Glob.GetFileCache()->AbortTransaction();
            }
			return WBEM_E_OUT_OF_MEMORY;
        }
		wcscpy(wszPath, wszObjectPath);

		CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

		hres = pNs->DeleteObjectByPath(dwFlags, wszPath, *aEvents);

        if(!m_bInWriteTransaction)
        {
            if (FAILED(hres))
            {
                g_Glob.GetFileCache()->AbortTransaction();
            }
            else
            {
                lRes = g_Glob.GetFileCache()->CommitTransaction();
                if(lRes != ERROR_SUCCESS)
                {
                    hres = A51TranslateErrorCode(lRes);
                    g_Glob.GetFileCache()->AbortTransaction();
                }
                else
                {
                    lock.Unlock();
                    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
                    CReleaseMe rm(pSvcs);
                    aNonTransactedEvents.SendEvents(pSvcs);                    
                }
            }
            aNonTransactedEvents.DeleteAllEvents();
        }

		return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuery(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		//If we are in a transaction, we have to get a message to the iteratir
		//on create so it does not mess around with the locks!
		if (m_bInWriteTransaction)
			pNs->TellIteratorNotToLock();

		hres = pNs->ExecQuery(pQuery, dwFlags,
				 dwRequestedHandleType, dwMessageFlags, ppQueryResult);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT STDMETHODCALLTYPE CSession::ExecQuerySink(
     IWmiDbHandle *pScope,
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
     IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
	try
	{
        HRESULT hres;
        CAutoReadLock lock(&g_readWriteLock, FALSE);

        if (!m_bInWriteTransaction)
        {
		    lock.Lock();
        }
        if (g_bShuttingDown)
            return WBEM_E_SHUTTING_DOWN;

        CNamespaceHandle* pNs = (CNamespaceHandle*)pScope;
        if(FAILED(pNs->GetErrorStatus()))
        {
            return pNs->GetErrorStatus();
        }

		hres = pNs->ExecQuerySink(pQuery, dwFlags,
				 dwRequestedHandleType, pSink, dwMessageFlags);

        return hres;
	}
	catch (...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}
                    
    
HRESULT STDMETHODCALLTYPE CSession::RenameObject(
     IWbemPath *pOldPath,
     IWbemPath *pNewPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::Enumerate(
     IWmiDbHandle *pScope,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbIterator **ppQueryResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::AddObject(
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::RemoveObject (
     IWmiDbHandle *pScope,
     IWbemPath *pPath,
     DWORD dwFlags
    )
{
    DebugBreak();
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSession::SetDecoration(
     LPWSTR lpMachineName,
     LPWSTR lpNamespacePath
    )
{
    //
    // As the default driver, we really don't care.
    //

    return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CSession::BeginWriteTransaction(DWORD dwFlags)
{
    g_readWriteLock.WriteLock();
    if (g_bShuttingDown)
    {
        g_readWriteLock.WriteUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    long lRes = g_Glob.GetFileCache()->BeginTransaction();
    if(lRes != ERROR_SUCCESS)
    {
        g_readWriteLock.WriteUnlock();
        return A51TranslateErrorCode(lRes);
    }

    m_bInWriteTransaction = true;
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::BeginReadTransaction(DWORD dwFlags)
{
    g_readWriteLock.ReadLock();
    if (g_bShuttingDown)
    {
        g_readWriteLock.ReadUnlock();
        return WBEM_E_SHUTTING_DOWN;
    }

    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::CommitTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        long lRes = g_Glob.GetFileCache()->CommitTransaction();
        if(lRes != ERROR_SUCCESS)
        {
            HRESULT hres = A51TranslateErrorCode(lRes);
            AbortTransaction(0);
            return hres;
        }

        m_bInWriteTransaction = false;

        //Copy the event list and delete the original.  We need to deliver
        //outside the write lock.
        CEventCollector aTransactedEvents;
        aTransactedEvents.TransferEvents(m_aTransactedEvents);

        g_readWriteLock.WriteUnlock();

        _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
        CReleaseMe rm(pSvcs);
        aTransactedEvents.SendEvents(pSvcs);
        aTransactedEvents.DeleteAllEvents();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
		{
            _ASSERT(false, L"Read transaction has events to send");
		}
        g_readWriteLock.ReadUnlock();
   }
    return ERROR_SUCCESS;
}

HRESULT STDMETHODCALLTYPE CSession::AbortTransaction(DWORD dwFlags)
{
    if (m_bInWriteTransaction)
    {
        m_bInWriteTransaction = false;
        g_Glob.GetFileCache()->AbortTransaction();
        m_aTransactedEvents.DeleteAllEvents();
        g_readWriteLock.WriteUnlock();
    }
    else
    {
        if (m_aTransactedEvents.GetSize())
		{
            _ASSERT(false, L"Read transaction has events to send");
		}
        g_readWriteLock.ReadUnlock();
    }
    return ERROR_SUCCESS;
}

//
//
//
//
///////////////////////////////////////////////////////////////////////

long CNamespaceHandle::s_lActiveRepNs = 0;

CNamespaceHandle::CNamespaceHandle(CLifeControl* pControl,CRepository * pRepository)
    : TUnkBase(pControl), m_pClassCache(NULL),
       m_pNullClass(NULL), m_bCached(false), m_pRepository(pRepository),
	   m_bUseIteratorLock(true)
{    
    m_pRepository->AddRef();
    // unrefed pointer to a global
    m_ForestCache = g_Glob.GetForestCache(); 
    InterlockedIncrement(&s_lActiveRepNs);
}

CNamespaceHandle::~CNamespaceHandle()
{
    if(m_pClassCache)
    {
        // give-up our own reference
        // m_pClassCache->Release();
        // remove from the Forest cache this namespace
        m_ForestCache->ReleaseNamespaceCache(m_wsNamespace, m_pClassCache);
    }

    m_pRepository->Release();
    if(m_pNullClass)
        m_pNullClass->Release();
    InterlockedDecrement(&s_lActiveRepNs);
}

CHR CNamespaceHandle::GetErrorStatus()
{
    //
    // TEMP CODE: Someone is calling us on an impersonated thread.  Let's catch
    // the, ahem, culprit
    //

    HANDLE hToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        //_ASSERT(false, L"Called with a thread token");
        ERRORTRACE((LOG_WBEMCORE, "Repository called with a thread token! "
                        "It shall be removed\n"));
        CloseHandle(hToken);
        SetThreadToken(NULL, NULL);
    }

    return m_pClassCache->GetError();
}

void CNamespaceHandle::SetErrorStatus(HRESULT hres)
{
    m_pClassCache->SetError(hres);
}

CHR CNamespaceHandle::Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope)
{
    HRESULT hres;

    m_wsNamespace = wszNamespace;
    m_wsFullNamespace = L"\\\\.\\";
    m_wsFullNamespace += wszNamespace;

    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerNameW(m_wszMachineName, &dwSize);

    if(wszScope)
        m_wsScope = wszScope;

    //
    // Ask the forest for the cache for this namespace
    //

    m_pClassCache = g_Glob.GetForestCache()->
                        GetNamespaceCache(wszNamespace);
    if(m_pClassCache == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wcscpy(m_wszClassRootDir, g_Glob.GetRootDir());

    //
    // Append namespace-specific prefix
    //

    wcscat(m_wszClassRootDir, L"\\NS_");

    //
    // Append hashed namespace name
    //

    if (!Hash(wszNamespace, m_wszClassRootDir + wcslen(m_wszClassRootDir)))
		return WBEM_E_OUT_OF_MEMORY;
	m_lClassRootDirLen = wcslen(m_wszClassRootDir);

    //
    // Constuct the instance root dir
    //

    if(wszScope == NULL)
    {
        //
        // Basic namespace --- instances go into the root of the namespace
        //

        wcscpy(m_wszInstanceRootDir, m_wszClassRootDir);
        m_lInstanceRootDirLen = m_lClassRootDirLen;
    }   
    else
    {
        wcscpy(m_wszInstanceRootDir, m_wszClassRootDir);
        wcscat(m_wszInstanceRootDir, L"\\" A51_SCOPE_DIR_PREFIX);
        if(!Hash(m_wsScope, 
                 m_wszInstanceRootDir + wcslen(m_wszInstanceRootDir)))
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        m_lInstanceRootDirLen = wcslen(m_wszInstanceRootDir);
    }
        

    return WBEM_S_NO_ERROR;
}



CHR CNamespaceHandle::GetObject(
     IWbemPath *pPath,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    HRESULT hres;

    if((dwRequestedHandleType & WMIDB_HANDLE_TYPE_COOKIE) == 0)
    {
        DebugBreak();
        return E_NOTIMPL;
    }

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);
    if(FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL)
        return hres;

    WCHAR* wszBuffer = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
    if(wszBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszBuffer, dwLen * sizeof(WCHAR));

    if(FAILED(pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszBuffer)))
        return WBEM_E_FAILED;

    return GetObjectHandleByPath(wszBuffer, dwFlags, dwRequestedHandleType, 
        ppResult);
}

CHR CNamespaceHandle::GetObjectHandleByPath(
     LPWSTR wszBuffer,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult
    )
{
    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszBuffer)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    HRESULT hres = ComputeKeyFromPath(wszBuffer, wszKey, &wszClassName, 
                                        &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    //
    // Check if it exists (except for ROOT --- it's fake)
    //

    _IWmiObject* pObj = NULL;
    if(m_wsNamespace.Length() > 0)
    {
        hres = GetInstanceByKey(wszClassName, wszKey, IID__IWmiObject, 
            (void**)&pObj);
        if(FAILED(hres))
            return hres;
    }
    CReleaseMe rm1(pObj);

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl,m_pRepository);
	if (pNewHandle == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewHandle->AddRef();
    CReleaseMe rm2(pNewHandle);

    //
    // Check if this is a namespace or not
    //

    if(pObj == NULL || pObj->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // It's a namespace.  Open a basic handle pointing to it
        //

        WString wsName = m_wsNamespace;
        if(wsName.Length() > 0)
            wsName += L"\\";
        wsName += wszKey;
    
        hres = pNewHandle->Initialize(wsName);

        //
        // Since our namespace is for real, tell the cache that it is now valid.
        // The cache might have been invalidated if this namespace was deleted 
        // in the past
        //

        pNewHandle->SetErrorStatus(S_OK);
    }
    else
    {
        // 
        // It's a scope.  Construct the new scope name by appending this 
        // object's path to our own scope
        //

        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);
        hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        WString wsScope = m_wsScope;
        if(wsScope.Length() > 0)
            wsScope += L":";
        wsScope += V_BSTR(&v);

        hres = pNewHandle->Initialize(m_wsNamespace, wsScope);
    }
        
    if(FAILED(hres))
        return hres;

    return pNewHandle->QueryInterface(IID_IWmiDbHandle, (void**)ppResult);
}
    
CHR CNamespaceHandle::ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey,
                                            TEMPFREE_ME LPWSTR* pwszClass,
                                            bool* pbIsClass,
                                            TEMPFREE_ME LPWSTR* pwszNamespace)
{
    HRESULT hres;

    *pbIsClass = false;

    //
    // Get and skip the namespace portion.
    //

    if(wszPath[0] == '\\' || wszPath[0] == '/')
    {
        //
        // Find where the server portion ends
        //

        WCHAR* pwcNextSlash = wcschr(wszPath+2, wszPath[0]);
        if(pwcNextSlash == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
        
        //
        // Find where the namespace portion ends
        //

        WCHAR* pwcColon = wcschr(pwcNextSlash, L':');
        if(pwcColon == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
    
        if(pwszNamespace)
        {
            DWORD dwLen = pwcColon - pwcNextSlash;
            *pwszNamespace = (WCHAR*)TempAlloc(dwLen * sizeof(WCHAR));
            if(*pwszNamespace == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            
            *pwcColon = 0;
            wcscpy(*pwszNamespace, pwcNextSlash+1);
        }

        //
        // Advance wszPath to beyond the namespace portion
        //

        wszPath = pwcColon+1;
    }
    else if(pwszNamespace)
    {
        *pwszNamespace = NULL;
    }

    // Get the first key

    WCHAR* pwcFirstEq = wcschr(wszPath, L'=');
    if(pwcFirstEq == NULL)
    {
        //
        // It's a class!
        //

        *pbIsClass = true;
        // path to the "class" to distinguish from its  instances
        wszKey[0] = 1;
        wszKey[1] = 0;

        *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
        if(*pwszClass == NULL)
        {
            if(pwszNamespace)
                TempFree(*pwszNamespace);
            return WBEM_E_OUT_OF_MEMORY;
        }
        wcscpy(*pwszClass, wszPath);
        return S_OK;
    }

    WCHAR* pwcFirstDot = wcschr(wszPath, L'.');

    if(pwcFirstDot == NULL || pwcFirstDot > pwcFirstEq)
    {
        // No name on the first key

        *pwcFirstEq = 0;

        *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
        if(*pwszClass == NULL)
		{
			if(pwszNamespace)
				TempFree(*pwszNamespace);
			return WBEM_E_OUT_OF_MEMORY;
		}
        wcscpy(*pwszClass, wszPath);
    
        WCHAR* pwcThisKey = NULL;
        WCHAR* pwcEnd = NULL;
        hres = ParseKey(pwcFirstEq+1, &pwcThisKey, &pwcEnd);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
        if(*pwcEnd != NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }

        wcscpy(wszKey, pwcThisKey);
        return S_OK;
    }

    //
    // Normal case
    //

    //
    // Get all the key values
    //

    struct CKeyStruct
    {
        WCHAR* m_pwcValue;
        WCHAR* m_pwcName;
    } * aKeys = (CKeyStruct*)TempAlloc(sizeof(CKeyStruct[256]));

    if (0==aKeys)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
      return WBEM_E_OUT_OF_MEMORY;
    }
    CTempFreeMe release_aKeys(aKeys);

    DWORD dwNumKeys = 0;

    *pwcFirstDot = NULL;

    *pwszClass = (WCHAR*)TempAlloc((wcslen(wszPath)+1) * sizeof(WCHAR));
    if(*pwszClass == NULL)
    {
        if(pwszNamespace)
            TempFree(*pwszNamespace);
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(*pwszClass, wszPath);

    WCHAR* pwcNextKey = pwcFirstDot+1;

    do
    {
        pwcFirstEq = wcschr(pwcNextKey, L'=');
        if(pwcFirstEq == NULL)
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        *pwcFirstEq = 0;

        aKeys[dwNumKeys].m_pwcName = pwcNextKey;
        hres = ParseKey(pwcFirstEq+1, &(aKeys[dwNumKeys].m_pwcValue), 
                            &pwcNextKey);
        if(FAILED(hres))
        {
            TempFree(*pwszClass);
            if(pwszNamespace)
                TempFree(*pwszNamespace);

            return hres;
        }
		dwNumKeys++;
    }
    while(*pwcNextKey);

    if(*pwcNextKey != 0)
    {
        TempFree(*pwszClass);
        if(pwszNamespace)
            TempFree(*pwszNamespace);

        return WBEM_E_INVALID_OBJECT_PATH;
    }
    
    //
    // We have the array of keys --- sort it
    //

    DWORD dwCurrentIndex = 0;
    while(dwCurrentIndex < dwNumKeys-1)
    {
        if(wbem_wcsicmp(aKeys[dwCurrentIndex].m_pwcName, 
                        aKeys[dwCurrentIndex+1].m_pwcName) > 0)
        {
            CKeyStruct Temp = aKeys[dwCurrentIndex];
            aKeys[dwCurrentIndex] = aKeys[dwCurrentIndex+1];
            aKeys[dwCurrentIndex+1] = Temp;
            if(dwCurrentIndex)
                dwCurrentIndex--;
            else
                dwCurrentIndex++;
        }
        else
            dwCurrentIndex++;
    }

    //
    // Now generate the result
    //
    
    WCHAR* pwcKeyEnd = wszKey;
    for(DWORD i = 0; i < dwNumKeys; i++)
    {
        wcscpy(pwcKeyEnd, aKeys[i].m_pwcValue);
        pwcKeyEnd += wcslen(aKeys[i].m_pwcValue);
        if(i < dwNumKeys-1)
            *(pwcKeyEnd++) = -1;
    }
    *pwcKeyEnd = 0;
    return S_OK;
}

CHR CNamespaceHandle::ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey)
{
    if(wszKeyStart[0] == L'"' || wszKeyStart[0] == L'\'')
    {
        WCHAR wcStart = wszKeyStart[0];
        WCHAR* pwcRead = wszKeyStart+1;
        WCHAR* pwcWrite = wszKeyStart+1;
        while(*pwcRead && *pwcRead != wcStart)  
        {
            if(*pwcRead == '\\')
                pwcRead++;

            *(pwcWrite++) = *(pwcRead++);
        }
        if(*pwcRead == 0)
            return WBEM_E_INVALID_OBJECT_PATH;

        *pwcWrite = 0;
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart+1;

        //
        // Check separator
        //
    
        if(pwcRead[1] && pwcRead[1] != L',')
            return WBEM_E_INVALID_OBJECT_PATH;
            
        if(pwcNextKey)
		{
			//
			// If there is a separator, skip it.  Don't skip end of string!
			//

			if(pwcRead[1])
	            *pwcNextKey = pwcRead+2;
			else
				*pwcNextKey = pwcRead+1;
		}
    }
    else
    {
        if(pwcRealStart)
            *pwcRealStart = wszKeyStart;
        WCHAR* pwcComma = wcschr(wszKeyStart, L',');
        if(pwcComma == NULL)
        {
            if(pwcNextKey)
                *pwcNextKey = wszKeyStart + wcslen(wszKeyStart);
        }
        else
        {
            *pwcComma = 0;
            if(pwcNextKey)
                *pwcNextKey = pwcComma+1;
        }
    }

    return S_OK;
}
            

CHR CNamespaceHandle::GetObjectDirect(
     IWbemPath *pPath,
     DWORD dwFlags,
     REFIID riid,
    LPVOID *pObj
    )
{
    HRESULT hres;

    DWORD dwLen = 0;
    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, NULL);

    LPWSTR wszPath = (WCHAR*)TempAlloc(dwLen*sizeof(WCHAR));
	if (wszPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(wszPath, dwLen * sizeof(WCHAR));

    hres = pPath->GetText(WBEMPATH_GET_ORIGINAL, &dwLen, wszPath);
    if(FAILED(hres))
        return hres;


    return GetObjectByPath(wszPath, dwFlags, riid, pObj);
}

CHR CNamespaceHandle::GetObjectByPath(
     LPWSTR wszPath,
     DWORD dwFlags,
     REFIID riid,
     LPVOID *pObj
    )
{
    HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return GetClassDirect(wszClassName, riid, pObj, true, NULL, NULL, NULL);
    }
    else
    {
        return GetInstanceByKey(wszClassName, wszKey, riid, pObj);
    }
}

CHR CNamespaceHandle::GetInstanceByKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey,
                                REFIID riid, void** ppObj)
{
    HRESULT hres;

    //
    // Get the class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Construct directory path
    //

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Construct the file path
    //

    int nLen = wcslen(wszFilePath);
    wszFilePath[nLen] = L'\\';

    hres = ConstructInstanceDefName(wszFilePath+nLen+1, wszKey);
    if(FAILED(hres))
        return hres;
    
    //
    // Get the object from that file
    //

    _IWmiObject* pInst;
    hres = FileToInstance(wszFilePath, &pInst);
    if(FAILED(hres))
        return hres;
	CReleaseMe rm2(pInst);

    //
    // Return
    //

    return pInst->QueryInterface(riid, (void**)ppObj);
}

CHR CNamespaceHandle::GetClassByHash(LPCWSTR wszHash, bool bClone, 
                                            _IWmiObject** ppClass,
                                            __int64* pnTime,
                                            bool* pbRead,
											bool *pbSystemClass)
{
    HRESULT hres;

    //
    // Check the cache first
    //

    *ppClass = m_pClassCache->GetClassDefByHash(wszHash, bClone, pnTime, pbRead, pbSystemClass);
    if(*ppClass)
        return S_OK;

    //
    // Not found --- construct the file name and read it
    //

    if(pbRead)
        *pbRead = true;

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    hres = FileToClass(wszFilePath, ppClass, bClone, pnTime, pbSystemClass);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

    
CHR CNamespaceHandle::GetClassDirect(LPCWSTR wszClassName,
                                REFIID riid, void** ppObj, bool bClone,
                                __int64* pnTime, bool* pbRead, 
								bool *pbSystemClass)
{
    HRESULT hres;

    if(wszClassName == NULL || wcslen(wszClassName) == 0)
    {
        if(m_pNullClass == NULL)
        {
            hres = CoCreateInstance(CLSID_WbemClassObject, NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID__IWmiObject, (void **)&m_pNullClass);
            if (FAILED(hres))
                return hres;
        }

        IWbemClassObject* pRawObj;
        hres = m_pNullClass->Clone(&pRawObj);
		if (FAILED(hres))
			return hres;
        CReleaseMe rm(pRawObj);
        if(pnTime)
            *pnTime = 0;
        if(pbRead)
            *pbRead = false;

        return pRawObj->QueryInterface(riid, ppObj);
    }

    _IWmiObject* pClass;

    //
    // Check the cache first
    //

    pClass = m_pClassCache->GetClassDef(wszClassName, bClone, pnTime, pbRead);
    if(pClass)
    {
        CReleaseMe rm1(pClass);
        return pClass->QueryInterface(riid, ppObj);
    }

    if(pbRead)
        *pbRead = true;

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    //
    // Read it from the file
    //

    hres = FileToClass(wszFilePath, &pClass, bClone, pnTime, pbSystemClass);
    if(FAILED(hres))
	    return hres;
    CReleaseMe rm1(pClass);

    return pClass->QueryInterface(riid, ppObj);
}

CHR CNamespaceHandle::FileToInstance(LPCWSTR wszFileName, 
                    _IWmiObject** ppInstance, bool bMustBeThere)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	DWORD dwSize;
	BYTE* pBlob;
	long lRes = g_Glob.GetFileCache()->ReadFile(wszFileName, &dwSize, &pBlob, 
                                         bMustBeThere);
	if(lRes != ERROR_SUCCESS)
	{
		if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else
			return WBEM_E_FAILED;
	}

	CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Instance blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Extract the class hash
    //

    WCHAR wszClassHash[MAX_HASH_LEN+1];
    DWORD dwClassHashLen = MAX_HASH_LEN*sizeof(WCHAR);
    memcpy(wszClassHash, pBlob, MAX_HASH_LEN*sizeof(WCHAR));
    wszClassHash[MAX_HASH_LEN] = 0;

    __int64 nInstanceTime;
    memcpy(&nInstanceTime, pBlob + dwClassHashLen, sizeof(__int64));

    __int64 nOldClassTime;
    memcpy(&nOldClassTime, pBlob + dwClassHashLen + sizeof(__int64), 
            sizeof(__int64));

    BYTE* pInstancePart = pBlob + dwClassHashLen + sizeof(__int64)*2;
    DWORD dwInstancePartSize = dwSize - dwClassHashLen - sizeof(__int64)*2;

    //
    // Get the class def
    //

    _IWmiObject* pClass = NULL;
    __int64 nClassTime;
    bool bRead;
	bool bSystemClass = false;
    hres = GetClassByHash(wszClassHash, false, &pClass, &nClassTime, &bRead, &bSystemClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

#ifdef A51_CHECK_TIMESTAMPS
    _ASSERT(nClassTime <= nInstanceTime, L"Instance is older than its class");
    _ASSERT(nClassTime == nOldClassTime, L"Instance verified with the wrong "
                        L"class definition");
#endif

    //
    // Construct the instance
    //
                    
    _IWmiObject* pInst = NULL;
    hres = pClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, 
                            dwInstancePartSize, pInstancePart, &pInst);
    if(FAILED(hres))
        return hres;

    //
    // Decorate it
    //

    pInst->SetDecoration(m_wszMachineName, m_wsNamespace);

    A51TRACE(("Read instance from %S in namespace %S\n", 
        wszFileName, (LPCWSTR)m_wsNamespace));

    *ppInstance = pInst;
    return S_OK;
}


CHR CNamespaceHandle::FileToSystemClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime)
{
    //
    // Note: we must always clone the result of the system class retrieval,
    // since it will be decorated by the caller
    //

	return GetClassByHash(wszFileName + (wcslen(wszFileName) - MAX_HASH_LEN), 
                            true, 
                            ppClass, pnTime, NULL, NULL);
}
CHR CNamespaceHandle::FileToClass(LPCWSTR wszFileName, 
                                    _IWmiObject** ppClass, bool bClone,
                                    __int64* pnTime, bool *pbSystemClass)
{
    HRESULT hres;

    //
    // Read the data from the file
    //

	__int64 nTime;
	DWORD dwSize;
	BYTE* pBlob;
    VARIANT vClass;
	long lRes = g_Glob.GetFileCache()->ReadFile(wszFileName, &dwSize, &pBlob);
	if(lRes != ERROR_SUCCESS)
	{
		//We didn't find it here, so lets try and find it in the default namespace!
		//If we are not in the __SYSTEMCLASS namespace then we need to call into that...
		if((lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND) && g_pSystemClassNamespace && wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0)
		{
			hres = g_pSystemClassNamespace->FileToSystemClass(wszFileName, ppClass, bClone, &nTime);
			if (FAILED(hres))
				return hres;

			if (pnTime)
				*pnTime = nTime;

			//need to cache this item in the local cache
			hres = (*ppClass)->Get(L"__CLASS", 0, &vClass, NULL, NULL);
			if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
				return WBEM_E_INVALID_OBJECT;
			CClearMe cm1(&vClass);

			A51TRACE(("Read class %S from disk in namespace %S\n", V_BSTR(&vClass), m_wsNamespace));

			(*ppClass)->SetDecoration(m_wszMachineName, m_wsNamespace);

			m_pClassCache->AssertClass((*ppClass), V_BSTR(&vClass), bClone, nTime, true);

			if (pbSystemClass)
				*pbSystemClass = true;

			return hres;
		}
		else if (lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else
			return WBEM_E_FAILED;
	}

	CTempFreeMe tfm1(pBlob, dwSize);

    _ASSERT(dwSize > sizeof(__int64), L"Class blob too short");
    if(dwSize <= sizeof(__int64))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Read off the superclass name
    //

    DWORD dwSuperLen;
    memcpy(&dwSuperLen, pBlob, sizeof(DWORD));
    LPWSTR wszSuperClass = (WCHAR*)TempAlloc(dwSuperLen*sizeof(WCHAR)+2);
	if (wszSuperClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm1(wszSuperClass, dwSuperLen*sizeof(WCHAR)+2);

    wszSuperClass[dwSuperLen] = 0;
    memcpy(wszSuperClass, pBlob+sizeof(DWORD), dwSuperLen*sizeof(WCHAR));
    DWORD dwPrefixLen = sizeof(DWORD) + dwSuperLen*sizeof(WCHAR);

    memcpy(&nTime, pBlob + dwPrefixLen, sizeof(__int64));

    //
    // Get the superclass
    //

    _IWmiObject* pSuperClass;
    __int64 nSuperTime;
    bool bRead;
    hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pSuperClass,
                            false, &nSuperTime, &bRead, NULL);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;

    CReleaseMe rm1(pSuperClass);

#ifdef A51_CHECK_TIMESTAMPS
    _ASSERT(nSuperTime <= nTime, L"Parent class is older than child");
#endif

    DWORD dwClassLen = dwSize - dwPrefixLen - sizeof(__int64);
    _IWmiObject* pNewObj;
    hres = pSuperClass->Merge(0, dwClassLen, 
                              pBlob + dwPrefixLen + sizeof(__int64), &pNewObj);
    if(FAILED(hres))
        return hres;

    //
    // Decorate it
    //

    pNewObj->SetDecoration(m_wszMachineName, m_wsNamespace);

    //
    // Cache it!
    //

    hres = pNewObj->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm1(&vClass);

    A51TRACE(("Read class %S from disk in namespace %S\n",
        V_BSTR(&vClass), m_wsNamespace));

    m_pClassCache->AssertClass(pNewObj, V_BSTR(&vClass), bClone, nTime, false);

    *ppClass = pNewObj;
    if(pnTime)
        *pnTime = nTime;
	if (pbSystemClass)
		*pbSystemClass = false;
    return S_OK;
}

CHR CNamespaceHandle::PutObject(
     REFIID riid,
    LPVOID pObj,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWmiDbHandle **ppResult,
	CEventCollector &aEvents
    )
{
    HRESULT hres;

    _IWmiObject* pObjEx = NULL;
    ((IUnknown*)pObj)->QueryInterface(IID__IWmiObject, (void**)&pObjEx);
	CReleaseMe rm1(pObjEx);
    
    if(pObjEx->IsObjectInstance() == S_OK)
    {
        hres = PutInstance(pObjEx, dwFlags, aEvents);
    }
    else
    {
        hres = PutClass(pObjEx, dwFlags, aEvents);
    }

    if(FAILED(hres))
        return hres;

    if(ppResult)
    {
        //
        // Got to get a handle
        //

        VARIANT v;
        hres = pObjEx->Get(L"__RELPATH", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;

        hres = GetObjectHandleByPath(V_BSTR(&v), 0, WMIDB_HANDLE_TYPE_COOKIE, 
            ppResult);
        if(FAILED(hres))
            return hres;
    }
    return S_OK;
}

CHR CNamespaceHandle::PutInstance(_IWmiObject* pInst, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
	// Get the class so we can compare to make sure it is the same class used to
    // create the instance
    //

    _IWmiObject* pClass = NULL;
    __int64 nClassTime;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, &nClassTime, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm2(pClass);

    if(wszClassName[0] != L'_')
	{
        hres = pInst->IsParentClass(0, pClass);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_FALSE)
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Get the path
    //

    BSTR strKey = NULL;
    hres = pInst->GetKeyString(0, &strKey);
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm(strKey);

    A51TRACE(("Putting instance %S of class %S\n", strKey, wszClassName));

    //
    // Get the old copy
    //

    _IWmiObject* pOldInst = NULL;
    hres = GetInstanceByKey(wszClassName, strKey, IID__IWmiObject, 
            (void**)&pOldInst);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
    CReleaseMe rm1(pOldInst);

	if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres != WBEM_E_NOT_FOUND))
		return WBEM_E_ALREADY_EXISTS;
	else if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (hres != WBEM_S_NO_ERROR))
		return WBEM_E_NOT_FOUND;

    if(pOldInst)
    {
        // 
        // Check that this guy is of the same class as the new one
        //

        //
        // Get the class name
        //
    
        VARIANT vClass;
        hres  = pOldInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
        if(FAILED(hres))
            return hres;
        if(V_VT(&vClass) != VT_BSTR)
            return WBEM_E_INVALID_OBJECT;
    
        CClearMe cm1(&vClass);

        if(wbem_wcsicmp(V_BSTR(&vClass), wszClassName))
            return WBEM_E_INVALID_CLASS;
    }

    //
    // Construct the hash for the file
    //

    CFileName wszInstanceHash;
	if (wszInstanceHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!Hash(strKey, wszInstanceHash))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Construct the path to the instance file in key root
    //

    CFileName wszInstanceFilePath;
	if (wszInstanceFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszInstanceFilePath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceFilePath, L"\\" A51_INSTDEF_FILE_PREFIX);
    wcscat(wszInstanceFilePath, wszInstanceHash);

    //
    // Clean up what was there, if anything
    //

    if(pOldInst)   
    {
        //
        // Just delete it, but be careful not to delete the scope!
        //

        hres = DeleteInstanceSelf(wszInstanceFilePath, pOldInst, false);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }
        
    //
    // Create the actual instance def under key root
    //

    hres = InstanceToFile(pInst, wszClassName, wszInstanceFilePath, nClassTime);
    if(FAILED(hres))
	    return hres;

    //
    // Create the link under the class
    //

    hres = WriteInstanceLinkByHash(wszClassName, wszInstanceHash);
    if(FAILED(hres))
	    return hres;

    //
    // Write the references
    //

    hres = WriteInstanceReferences(pInst, wszClassName, wszInstanceFilePath);
    if(FAILED(hres))
	    return hres;
    
    if(!bDisableEvents)
    {
        //
        // Fire Event
        //
    
        if(pInst->InheritsFrom(L"__Namespace") == S_OK)
        {
            //
            // Get the namespace name
            //

            VARIANT vClass;
            VariantInit(&vClass);
            CClearMe cm1(&vClass);

            hres = pInst->Get(L"Name", 0, &vClass, NULL, NULL);
            if(FAILED(hres) || V_VT(&vClass) != VT_BSTR)
                return WBEM_E_INVALID_OBJECT;

            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceModification,
                            V_BSTR(&vClass), pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceCreation, 
                            V_BSTR(&vClass), pInst);
            }
        }
        else
        {
            if(pOldInst)
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceModification, 
                            wszClassName, pInst, pOldInst);
            }
            else
            {
                hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceCreation, 
                            wszClassName, pInst);
            }
        }
    }

	A51TRACE(("PutInstance for %S of class %S succeeded\n", 
                strKey, wszClassName));
    return S_OK;
}

CHR CNamespaceHandle::GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    HRESULT hres;

    //
    // Look in the cache first
    //

    hres = m_pClassCache->GetKeyRoot(wszClass, pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // Walk up the tree getting classes until you hit an unkeyed one
    //

    WString wsThisName = wszClass;
    WString wsPreviousName;

    while(1)
    {
        _IWmiObject* pClass = NULL;

        hres = GetClassDirect(wsThisName, IID__IWmiObject, (void**)&pClass, 
                                false, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        //
        // Check if this class is keyed
        //

        unsigned __int64 i64Flags = 0;
        hres = pClass->QueryObjectFlags(0, WMIOBJECT_GETOBJECT_LOFLAG_KEYED,
                                        &i64Flags);
        if(FAILED(hres))
            return hres;
    
        if(i64Flags == 0)
        {
            //
            // It is not keyed --- the previous class wins!
            //

            if(wsPreviousName.Length() == 0)    
                return WBEM_E_CANNOT_BE_ABSTRACT;

            DWORD dwLen = (wsPreviousName.Length()+1)*sizeof(WCHAR);
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen);
			if (*pwszKeyRootClass == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            wcscpy(*pwszKeyRootClass, (LPCWSTR)wsPreviousName);
            return S_OK;
        }

        //
        // It is keyed --- get the parent and continue;
        //

        VARIANT vParent;
        VariantInit(&vParent);
        CClearMe cm(&vParent);
        hres = pClass->Get(L"__SUPERCLASS", 0, &vParent, NULL, NULL);
        if(FAILED(hres))
            return hres;

        if(V_VT(&vParent) != VT_BSTR)
        {
            //
            // We've reached the top --- return this class
            //
        
            DWORD dwLen = (wsThisName.Length()+1)*sizeof(WCHAR);
            *pwszKeyRootClass = (WCHAR*)TempAlloc(dwLen);
			if (*pwszKeyRootClass == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            wcscpy(*pwszKeyRootClass, (LPCWSTR)wsThisName);
            return S_OK;
        }

        wsPreviousName = wsThisName;
        wsThisName = V_BSTR(&vParent);
    }

    // Never here

    DebugBreak();
    return WBEM_E_CRITICAL_ERROR;
}

CHR CNamespaceHandle::GetKeyRootByHash(LPCWSTR wszClassHash, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass)
{
    //
    // Look in the cache first
    //

    HRESULT hres = m_pClassCache->GetKeyRootByKey(wszClassHash, 
                                                  pwszKeyRootClass);
    if(hres == S_OK)
        return S_OK;
    else if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
        return WBEM_E_CANNOT_BE_ABSTRACT;

    //
    // NOTE: this could be done more efficiently, but it happens once in a 
    // lifetime, so it's not worth the complexity.
    //

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || (V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Now get it by name
    //

    return GetKeyRoot(wszClassName, pwszKeyRootClass);
}

CHR CNamespaceHandle::ConstructKeyRootDirFromClass(LPWSTR wszDir,
                                            LPCWSTR wszClassName)
{
    HRESULT hres;

    //
    // NULL class stands for "meta-class"
    //

    if(wszClassName == NULL)
        return ConstructKeyRootDirFromKeyRoot(wszDir, L"");

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRoot(wszClassName, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}

CHR CNamespaceHandle::ConstructKeyRootDirFromClassHash(LPWSTR wszDir,
                                            LPCWSTR wszClassHash)
{
    HRESULT hres;

    //
    // Figure out the key root for the class
    //

    LPWSTR wszKeyRootClass = NULL;

    hres = GetKeyRootByHash(wszClassHash, &wszKeyRootClass);
    if(FAILED(hres))
        return hres;
    if(wszKeyRootClass == NULL)
    {
        // Abstract class --- bad error
        return WBEM_E_INVALID_CLASS;
    }
    CTempFreeMe tfm(wszKeyRootClass, (wcslen(wszKeyRootClass)+1)*sizeof(WCHAR));

    return ConstructKeyRootDirFromKeyRoot(wszDir, wszKeyRootClass);
}

CHR CNamespaceHandle::ConstructKeyRootDirFromKeyRoot(LPWSTR wszDir, 
                                                LPCWSTR wszKeyRootClass)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_KEYROOTINST_DIR_PREFIX);
    if(!Hash(wszKeyRootClass, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_KEYROOTINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

CHR CNamespaceHandle::ConstructLinkDirFromClass(LPWSTR wszDir, 
                                                LPCWSTR wszClassName)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_CLASSINST_DIR_PREFIX);
    if(!Hash(wszClassName, 
             wszDir+m_lInstanceRootDirLen+wcslen(A51_CLASSINST_DIR_PREFIX)+1))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

CHR CNamespaceHandle::ConstructLinkDirFromClassHash(LPWSTR wszDir, 
                                                LPCWSTR wszClassHash)
{
    wcscpy(wszDir, m_wszInstanceRootDir);
    wszDir[m_lInstanceRootDirLen] = L'\\';
    wcscpy(wszDir+m_lInstanceRootDirLen+1, A51_CLASSINST_DIR_PREFIX);
    wcscat(wszDir, wszClassHash);

    return S_OK;
}
    
                        

CHR CNamespaceHandle::WriteInstanceLinkByHash(LPCWSTR wszClassName,
                                            LPCWSTR wszInstanceHash)
{
    HRESULT hres;

    //
    // Construct the path to the link file under the class
    //

    CFileName wszInstanceLinkPath;
	if (wszInstanceLinkPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceLinkPath, L"\\" A51_INSTLINK_FILE_PREFIX);
    wcscat(wszInstanceLinkPath, wszInstanceHash);

    //
    // Create an empty file there
    //

    long lRes = g_Glob.GetFileCache()->WriteFile(wszInstanceLinkPath, 0, NULL);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}
    



CHR CNamespaceHandle::WriteInstanceReferences(_IWmiObject* pInst, 
                                                    LPCWSTR wszClassName,
                                                    LPCWSTR wszFilePath)
{
    HRESULT hres;

    hres = pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    VARIANT v;
    BSTR strName;
    while((hres = pInst->Next(0, &strName, &v, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
        {
            hres = WriteInstanceReference(wszFilePath, wszClassName, strName, 
                                        V_BSTR(&v));
            if(FAILED(hres))
                return hres;
        }
    }

    if(FAILED(hres))
        return hres;

    pInst->EndEnumeration();
    
    return S_OK;
}

// NOTE: will clobber wszTargetPath
CHR CNamespaceHandle::ConstructReferenceDir(LPWSTR wszTargetPath,
                                            LPWSTR wszReferenceDir)
{
    //
    // Deconstruct the target path name so that we could get a directory
    // for it
    //

    DWORD dwKeySpace = (wcslen(wszTargetPath)+1) * sizeof(WCHAR);
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwKeySpace);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm2(wszKey, dwKeySpace);

    LPWSTR wszClassName = NULL;
    LPWSTR wszTargetNamespace = NULL;
    bool bIsClass;
    HRESULT hres = ComputeKeyFromPath(wszTargetPath, wszKey, &wszClassName,
                                        &bIsClass, &wszTargetNamespace);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName);
    wszTargetPath = NULL; // invalidated by parsing

    CTempFreeMe tfm3(wszTargetNamespace);

    //
    // Check if the target namespace is the same as ours
    //

    CNamespaceHandle* pTargetHandle = NULL;
    if(wszTargetNamespace && wbem_wcsicmp(wszTargetNamespace, m_wsNamespace))
    {
        //
        // It's different --- open it!
        //

        hres = m_pRepository->GetNamespaceHandle(wszTargetNamespace,
                                &pTargetHandle);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to open target namespace "
                "'%S' in namespace '%S'\n", wszTargetNamespace,
                (LPCWSTR)m_wsNamespace));
            return hres;
        }
    }
    else
    {
        pTargetHandle = this;
        pTargetHandle->AddRef();
    }

    CReleaseMe rm1(pTargetHandle);

    if(bIsClass)
    {
        return pTargetHandle->ConstructReferenceDirFromKey(NULL, wszClassName, 
                                            wszReferenceDir);
    }
    else
    {
        return pTargetHandle->ConstructReferenceDirFromKey(wszClassName, wszKey,
                                            wszReferenceDir);
    }
}

CHR CNamespaceHandle::ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, LPWSTR wszReferenceDir)
{
    HRESULT hres;

    //
    // Construct the class directory for this instance
    //

    hres = ConstructKeyRootDirFromClass(wszReferenceDir, wszClassName);
    if(FAILED(hres))
        return hres;

    int nLen = wcslen(wszReferenceDir);
    wcscpy(wszReferenceDir+nLen, L"\\" A51_INSTREF_DIR_PREFIX);
    nLen += 1 + wcslen(A51_INSTREF_DIR_PREFIX);

    //
    // Write instance hash
    //

    if(!Hash(wszKey, wszReferenceDir+nLen))
        return WBEM_E_OUT_OF_MEMORY;

    return S_OK;
}

    

    
    
    
// NOTE: will clobber wszReference
CHR CNamespaceHandle::ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, LPWSTR wszReferenceFile)
{
    HRESULT hres = ConstructReferenceDir(wszReference, wszReferenceFile);
    if(FAILED(hres))
        return hres;
    wszReference = NULL; // invalid

    //
    // It is basically 
    // irrelevant, we should use a randomly constructed name.  Right now, we
    // use a hash of the class name of the referrer --- THIS IS A BUG, THE SAME
    // INSTANCE CAN POINT TO THE SAME ENDPOINT TWICE!!
    //

    wcscat(wszReferenceFile, L"\\"A51_REF_FILE_PREFIX);
    DWORD dwLen = wcslen(wszReferenceFile);
    if (!Hash(wszReferringFile, wszReferenceFile+dwLen))
		return WBEM_E_OUT_OF_MEMORY;
    return S_OK;
}

// NOTE: will clobber wszReference
CHR CNamespaceHandle::WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference)
{
	HRESULT hres;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszReferringFile, 
                                wszReferenceFile);
	if(FAILED(hres))
	{
		if(hres == WBEM_E_NOT_FOUND)
		{
			//
			// Oh joy. A reference to an instance of a *class* that does not
			// exist (not a non-existence instance, those are normal).
			// Forget it (BUGBUG)
			//

			return S_OK;
		}
		else
			return hres;
	}
	
    //
    // Construct the buffer
    //

    DWORD dwTotalLen = 4 * sizeof(DWORD) + 
                (wcslen(wszReferringClass) + wcslen(wszReferringProp) + 
                    wcslen(wszReferringFile) - g_Glob.GetRootDirLen() + 
                    wcslen(m_wsNamespace) + 4) 
                        * sizeof(WCHAR);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Write namespace name
    //

    dwStringLen = wcslen(m_wsNamespace);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    memcpy(pCurrent, m_wsNamespace, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write the referring class name
    //

    dwStringLen = wcslen(wszReferringClass);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringClass, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring property name
    //

    dwStringLen = wcslen(wszReferringProp);
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringProp, sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Write referring file name minus the database root path. Notice that we 
    // cannot skip the namespace-specific prefix lest we break cross-namespace
    // associations
    //

    dwStringLen = wcslen(wszReferringFile) - g_Glob.GetRootDirLen();
    memcpy(pCurrent, &dwStringLen, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    memcpy(pCurrent, wszReferringFile + g_Glob.GetRootDirLen(), 
        sizeof(WCHAR)*dwStringLen);
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // All done --- create the file
    //

    long lRes = g_Glob.GetFileCache()->WriteFile(wszReferenceFile, dwTotalLen,
                    pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    
    return S_OK;
}

    
    
    
    

    
    
    



CHR CNamespaceHandle::PutClass(_IWmiObject* pClass, DWORD dwFlags, 
                                        CEventCollector &aEvents)
{
    HRESULT hres;

    bool bDisableEvents = ((dwFlags & WMIDB_DISABLE_EVENTS)?true:false);

    //
    // Get the class name
    //

    VARIANT vClass;

    hres  = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres) || (V_VT(&vClass) != VT_BSTR) || 
        !V_BSTR(&vClass) || !wcslen(V_BSTR(&vClass)))
    {
        return WBEM_E_INVALID_OBJECT;
    }

    CClearMe cm1(&vClass);
    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
	// Check to make sure this class was created from a valid parent class
    //

    VARIANT vSuperClass;

    hres  = pClass->Get(L"__SUPERCLASS", 0, &vSuperClass, NULL, NULL);
    if (FAILED(hres))
        return WBEM_E_INVALID_OBJECT;
    CClearMe cm2(&vSuperClass);

    _IWmiObject* pSuperClass = NULL;
    if ((V_VT(&vSuperClass) == VT_BSTR) && V_BSTR(&vSuperClass) && 
        wcslen(V_BSTR(&vSuperClass)))
    {
        LPCWSTR wszSuperClassName = V_BSTR(&vSuperClass);

        // do not clone
        hres = GetClassDirect(wszSuperClassName, IID__IWmiObject, 
                                (void**)&pSuperClass, false, NULL, NULL, NULL); 
        if (hres == WBEM_E_NOT_FOUND)
            return WBEM_E_INVALID_SUPERCLASS;
        if (FAILED(hres))
            return hres;

	    if(wszClassName[0] != L'_')
	    {
            hres = pClass->IsParentClass(0, pSuperClass);
            if(FAILED(hres))
                return hres;
            if(hres == WBEM_S_FALSE)
                return WBEM_E_INVALID_SUPERCLASS;
        }
	}
    CReleaseMe rm(pSuperClass);

    //
    // Retrieve the previous definition, if any
    //

    _IWmiObject* pOldClass = NULL;
    __int64 nOldTime = 0;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pOldClass,
                            false, &nOldTime, NULL, NULL); // do not clone
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;
	CReleaseMe rm1(pOldClass);

	if ((dwFlags & WBEM_FLAG_CREATE_ONLY) && (hres !=  WBEM_E_NOT_FOUND))
		return WBEM_E_ALREADY_EXISTS;

	if ((dwFlags & WBEM_FLAG_UPDATE_ONLY) && (FAILED(hres)))
		return WBEM_E_NOT_FOUND;

    //
	// If the class exists, we need to check the update scenarios to make sure 
    // we do not break any
    //

	bool bNoClassChangeDetected = false;
	if (pOldClass)
	{
		hres = pClass->CompareDerivedMostClass(0, pOldClass);
		if ((hres != WBEM_S_FALSE) && (hres != WBEM_S_NO_ERROR))
			return hres;
		else if (hres == WBEM_S_NO_ERROR)
			bNoClassChangeDetected = true;
	}

    A51TRACE(("Putting class %S, dwFlags=0x%X.  Old was %p, changed=%d\n",
                wszClassName, dwFlags, pOldClass, !bNoClassChangeDetected));

	if (!bNoClassChangeDetected)
	{
		if (pOldClass != NULL) 
		{
			hres = CanClassBeUpdatedCompatible(dwFlags, wszClassName, pOldClass,
                                                pClass);            
            if(FAILED(hres))
            {
				if((dwFlags & WBEM_FLAG_UPDATE_SAFE_MODE) == 0 &&
                    (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
                {
                    // Can't compatibly, not allowed any other way
                    return hres;
                }

                if(hres != WBEM_E_CLASS_HAS_CHILDREN &&
                    hres != WBEM_E_CLASS_HAS_INSTANCES)
                {
                    // some serious failure!
                    return hres;
                }

                //
				// This is a safe mode or force mode update which takes more 
                // than a compatible update to carry out the operation
                //

				return UpdateClassSafeForce(pSuperClass, dwFlags, wszClassName, 
                                            pOldClass, pClass, aEvents);
			}
		}

        //
        // Either there was no previous copy, or it is compatible with the new
        // one, so we can perform a compatible update
        //

		hres = UpdateClassCompatible(pSuperClass, wszClassName, pClass, 
                                            pOldClass, nOldTime);
		if (FAILED(hres))
			return hres;

	}

    if(!bDisableEvents)
    {
        if(pOldClass)
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, 
                                wszClassName, pClass, pOldClass);
        }
        else
        {
            hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassCreation, 
                                wszClassName, pClass);
        }
    }

    return S_OK;
}

CHR CNamespaceHandle::UpdateClassCompatible(_IWmiObject* pSuperClass, 
            LPCWSTR wszClassName, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
	HRESULT hres;

	//
	// Construct the path for the file
	//
    CFileName wszHash;
    if (wszHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

	A51TRACE(("Class %S has has %S\n", wszClassName, wszHash));

	return UpdateClassCompatibleHash(pSuperClass, wszHash, pClass, pOldClass, 
                                        nFakeUpdateTime);
}

CHR CNamespaceHandle::UpdateClassCompatibleHash(_IWmiObject* pSuperClass,
            LPCWSTR wszClassHash, _IWmiObject *pClass, _IWmiObject *pOldClass, 
            __int64 nFakeUpdateTime)
{
	HRESULT hres;

	CFileName wszFileName;
	CFileName wszFilePath;
	if ((wszFileName == NULL) || (wszFilePath == NULL))
		return WBEM_E_OUT_OF_MEMORY;

	wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
	wcscat(wszFileName, wszClassHash);

	wcscpy(wszFilePath, m_wszClassRootDir);
	wcscat(wszFilePath, L"\\");
	wcscat(wszFilePath, wszFileName);

	//
	// Write it into the file
	//

	hres = ClassToFile(pSuperClass, pClass, wszFilePath, 
                        nFakeUpdateTime);
	if(FAILED(hres))
		return hres;

	//
	// Add all needed references --- parent, pointers, etc	
	//

	if (pOldClass)
	{
		VARIANT v;
		VariantInit(&v);
		hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
		CClearMe cm(&v);

		if(SUCCEEDED(hres))
		{
			hres = EraseClassRelationships(V_BSTR(&v), pOldClass, wszFileName);
		}
		if (FAILED(hres))
			return hres;
	}

	hres = WriteClassRelationships(pClass, wszFileName);

	return hres;

}



CHR CNamespaceHandle::UpdateClassSafeForce(_IWmiObject* pSuperClass,
            DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pOldClass, 
            _IWmiObject *pNewClass, CEventCollector &aEvents)
{
	HRESULT hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                        pNewClass, pOldClass, aEvents);

    // 
    // If this is a force mode update and we failed for anything other than 
    // out of memory then we should delete the class and try again.
    //

    if (FAILED(hres) && (hres != WBEM_E_OUT_OF_MEMORY) && 
        (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE))
    {
        //
        // We need to delete the class and try again.
        //

        hres = DeleteClass(wszClassName, aEvents);
        if(FAILED(hres))
            return hres;

        hres = UpdateClassAggressively(pSuperClass, dwFlags, wszClassName, 
                                        pNewClass, pOldClass, aEvents);
    }

	return hres;
}

CHR CNamespaceHandle::UpdateClassAggressively(_IWmiObject* pSuperClass,
           DWORD dwFlags, LPCWSTR wszClassName, _IWmiObject *pNewClass, 
           _IWmiObject *pOldClass, CEventCollector &aEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    if ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
    {
        //
        // If we have instances we need to quit as we cannot update them.
        // 

        hres = ClassHasInstances(wszClassName);
        if(FAILED(hres))
            return hres;

        if (hres == WBEM_S_NO_ERROR)
            return WBEM_E_CLASS_HAS_INSTANCES;

        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code!");
    }
    else if (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)
    {
        //
        // We need to delete the instances
        //

        hres = DeleteClassInstances(wszClassName, pOldClass, aEvents);
        if(FAILED(hres))
            return hres;
    }

    //
    // Retrieve all child classes and update them
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for (int i = 0; i != wsChildHashes.Size(); i++)
    {
        hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                    pNewClass, aEvents);
        if (FAILED(hres))
            return hres;
    }

    //
    // Now we need to write the class back, update class refs etc.
    //

    hres = UpdateClassCompatible(pSuperClass, wszClassName, pNewClass, 
                                        pOldClass);
    if(FAILED(hres))
        return hres;

    //
    // Generate the class modification event...
    //

    if(!(dwFlags & WMIDB_DISABLE_EVENTS))
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassModification, wszClassName, pNewClass, pOldClass);
    }

    return S_OK;
}

CHR CNamespaceHandle::UpdateChildClassAggressively(DWORD dwFlags, 
            LPCWSTR wszClassHash, _IWmiObject *pNewParentClass, 
            CEventCollector &aEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    dwFlags &= (WBEM_FLAG_UPDATE_FORCE_MODE | WBEM_FLAG_UPDATE_SAFE_MODE);

    if ((dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE) == 0)
    {
        hres = ClassHasInstancesFromClassHash(wszClassHash);
        if(FAILED(hres))
            return hres;

        if (hres == WBEM_S_NO_ERROR)
            return WBEM_E_CLASS_HAS_INSTANCES;

        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code!");
    }

    //
    // Get the old class definition
    //

    _IWmiObject *pOldClass = NULL;
    hres = GetClassByHash(wszClassHash, true, &pOldClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pOldClass);

    if (dwFlags & WBEM_FLAG_UPDATE_FORCE_MODE)
    {
        //
        // Need to delete all its instances, if any
        //

        VARIANT v;
        VariantInit(&v);
        hres = pOldClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        if(FAILED(hres))
            return hres;

        CClearMe cm(&v);

        hres = DeleteClassInstances(V_BSTR(&v), pOldClass, aEvents);
        if(FAILED(hres))
            return hres;
    }

    //
    // Update the existing class definition to work with the new parent class
    //

    _IWmiObject *pNewClass = NULL;
    hres = pNewParentClass->Update(pOldClass, dwFlags, &pNewClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pNewClass);

    //
    // Now we have to recurse through all child classes and do the same
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszClassHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for (int i = 0; i != wsChildHashes.Size(); i++)
    {
        hres = UpdateChildClassAggressively(dwFlags, wsChildHashes[i], 
                                    pNewClass, aEvents);
        if (FAILED(hres))
            return hres;
    }

    // 
    // Now we need to write the class back, update class refs etc
    //


    hres = UpdateClassCompatibleHash(pNewParentClass, wszClassHash, 
                                            pNewClass, pOldClass);
    if(FAILED(hres))
        return hres;

    return S_OK;
}

CHR CNamespaceHandle::CanClassBeUpdatedCompatible(DWORD dwFlags, 
        LPCWSTR wszClassName, _IWmiObject *pOldClass, _IWmiObject *pNewClass)
{
	HRESULT hres;

    HRESULT hresError = WBEM_S_NO_ERROR;

    //
    // Do we have subclasses?
    //

    hres = ClassHasChildren(wszClassName);
    if(FAILED(hres))
        return hres;

    if(hres == WBEM_S_NO_ERROR)
    {
        hresError = WBEM_E_CLASS_HAS_CHILDREN;
    }
    else
    {
        _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code");
    
        //
        // Do we have instances belonging to this class?  Don't even need to
        // worry about sub-classes because we know we have none at this point!
        //
    
        hres = ClassHasInstances(wszClassName);
        if(FAILED(hres))
            return hres;

        if(hres == WBEM_S_NO_ERROR)
        {
            hresError = WBEM_E_CLASS_HAS_INSTANCES;
        }
        else
        {
            _ASSERT(hres == WBEM_S_FALSE, L"Unknown success code");

            //
            // No nothing!
            //

            return WBEM_S_NO_ERROR;
        }
    }

    _ASSERT(hresError != WBEM_S_NO_ERROR, L"");

    //
    // We have either subclasses or instances.
    // Can we reconcile this class safely?
    //

    hres = pOldClass->ReconcileWith(
                        WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE, pNewClass);

    if(hres == WBEM_S_NO_ERROR)
    {
        // reconcilable, so OK
        return WBEM_S_NO_ERROR;
    }
    else if(hres == WBEM_E_FAILED) // awful, isn't it
    {
        // irreconcilable
        return hresError;
    }
    else
    {
        return hres;
    }
}

CHR CNamespaceHandle::FireEvent(CEventCollector &aEvents, 
									DWORD dwType, LPCWSTR wszArg1,
                                    _IWmiObject* pObj1, _IWmiObject* pObj2)
{
	try
	{
		CRepEvent *pEvent = new CRepEvent(dwType, m_wsFullNamespace, wszArg1, 
                                            pObj1, pObj2);
		if (pEvent == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		if (!aEvents.AddEvent(pEvent))
        {
            delete pEvent;
			return WBEM_E_OUT_OF_MEMORY;
        }
		return WBEM_S_NO_ERROR;
	}
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}
HRESULT CNamespaceHandle::SendEvents(CEventCollector &aEvents)
{
    _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
    CReleaseMe rm(pSvcs);    
    aEvents.SendEvents(pSvcs);

    //
    // Ignore ESS return codes --- they do not invalidate the operation
    //

	return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::WriteClassRelationships(_IWmiObject* pClass,
                                                LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);

    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        hres = WriteParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        hres = WriteParentChildRelationship(wszFileName, L"");

	if(FAILED(hres))
		return hres;

    //
    // Write references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        hres = WriteClassReference(pClass, wszFileName, strName);
		if(FAILED(hres))
			return hres;
    }

    pClass->EndEnumeration();

	if(FAILED(hres))
		return hres;

    return S_OK;
}

CHR CNamespaceHandle::WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
	HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Create the empty file
    //

    long lRes = g_Glob.GetFileCache()->WriteFile(wszReferenceFile, 0, NULL);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::WriteParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
	if (wszParentChildFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
												wszParentChildFileName);

    //
    // Create the file
    //

    long lRes = g_Glob.GetFileCache()->WriteFile(wszParentChildFileName, 0, NULL);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::ConstructParentChildFileName(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName,
							LPWSTR wszParentChildFileName)
{
    //
    // Construct the name of the directory where the parent class keeps its
    // children
    //

    HRESULT hres = ConstructClassRelationshipsDir(wszParentName, 
                                                    wszParentChildFileName);
    if(FAILED(hres))
        return hres;

    //
    // Append the filename of the child, but substituting the child-class prefix
    // for the class-def prefix
    //

    wcscat(wszParentChildFileName, L"\\" A51_CHILDCLASS_FILE_PREFIX);
    wcscat(wszParentChildFileName, 
        wszChildFileName + wcslen(A51_CLASSDEF_FILE_PREFIX));

    return S_OK;
}


CHR CNamespaceHandle::ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                LPWSTR wszDirPath)
{
    wcscpy(wszDirPath, m_wszClassRootDir);
    wcscpy(wszDirPath + m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    
    if(!Hash(wszClassName, 
        wszDirPath + m_lClassRootDirLen + 1 + wcslen(A51_CLASSRELATION_DIR_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

CHR CNamespaceHandle::ConstructClassRelationshipsDirFromHash(
                                LPCWSTR wszHash, LPWSTR wszDirPath)
{
    wcscpy(wszDirPath, m_wszClassRootDir);
    wcscpy(wszDirPath + m_lClassRootDirLen, L"\\" A51_CLASSRELATION_DIR_PREFIX);
    wcscpy(wszDirPath + m_lClassRootDirLen + 1 +wcslen(A51_CLASSRELATION_DIR_PREFIX),
            wszHash);
    return S_OK;
}

CHR CNamespaceHandle::ConstructClassReferenceFileName(
                                LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                LPWSTR wszFileName)
{
    HRESULT hres;

    hres = ConstructClassRelationshipsDir(wszReferredToClass, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Extract the portion of the referring file containing the class hash
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszReferringFile, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;
    LPCWSTR wszReferringClassHash = pwcLastUnderscore+1;

    wcscat(wszFileName, L"\\" A51_REF_FILE_PREFIX);
    wcscat(wszFileName, wszReferringClassHash);
    return S_OK;
}

CHR CNamespaceHandle::DeleteObject(
     DWORD dwFlags,
     REFIID riid,
     LPVOID pObj,
	 CEventCollector &aEvents
    )
{
	DebugBreak();
	return E_NOTIMPL;
}

CHR CNamespaceHandle::DeleteObjectByPath(DWORD dwFlags,	LPWSTR wszPath, 
                                                CEventCollector &aEvents)
{
	HRESULT hres;

    //
    // Get the key from path
    //

    DWORD dwLen = wcslen(wszPath)*sizeof(WCHAR)+2;
    LPWSTR wszKey = (WCHAR*)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    bool bIsClass;
    LPWSTR wszClassName = NULL;
    hres = ComputeKeyFromPath(wszPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));

    if(bIsClass)
    {
        return DeleteClass(wszClassName, aEvents);
    }
    else
    {
        return DeleteInstance(wszClassName, wszKey, aEvents);
    }
}

CHR CNamespaceHandle::DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, 
                                            CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClass);

    //
    // Create its directory
    //

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromClass(wszFilePath, wszClassName);
    if(FAILED(hres))
        return hres;
    
    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructInstanceDefName(wszFileName, wszKey);
    if(FAILED(hres))
        return hres;

    wcscat(wszFilePath, L"\\");
    wcscat(wszFilePath, wszFileName);

    _IWmiObject* pInst;
    hres = FileToInstance(wszFilePath, &pInst);
    if(FAILED(hres))
        return hres;
	CReleaseMe rm2(pInst);

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
		//Make sure this is not a deletion of the root\default namespace
		VARIANT vName;
		VariantInit(&vName);
	    CClearMe cm1(&vName);
		hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
		if(FAILED(hres))
			return WBEM_E_INVALID_OBJECT;

		LPCWSTR wszName = V_BSTR(&vName);
		if ((_wcsicmp(m_wsFullNamespace, L"\\\\.\\root") == 0) && (_wcsicmp(wszName, L"default") == 0))
			return WBEM_E_ACCESS_DENIED;
	}
	hres = DeleteInstanceByFile(wszFilePath, pInst, false, aEvents);
    if(FAILED(hres))
        return hres;

    //
    // Fire an event
    //

    if(pInst->InheritsFrom(L"__Namespace") == S_OK)
    {
        //
        // There is no need to do anything --- deletion of namespaces
        // automatically fires events in DeleteInstanceByFile (because we need
        // to accomplish it in the case of deleting a class derived from 
        // __NAMESPACE.
        //

    }
    else
    {
        hres = FireEvent(aEvents, WBEM_EVENTTYPE_InstanceDeletion, wszClassName,
                        pInst);
    }

	A51TRACE(("DeleteInstance for class %S succeeded\n", wszClassName));
    return S_OK;
}

CHR CNamespaceHandle::DeleteInstanceByFile(LPCWSTR wszFilePath, 
                                _IWmiObject* pInst, bool bClassDeletion,
                                CEventCollector &aEvents)
{
    HRESULT hres;

    hres = DeleteInstanceSelf(wszFilePath, pInst, bClassDeletion);
    if(FAILED(hres))
        return hres;

    hres = DeleteInstanceAsScope(pInst, aEvents);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
    {
        return hres;
    }

    return S_OK;
}

CHR CNamespaceHandle::DeleteInstanceSelf(LPCWSTR wszFilePath, 
                                            _IWmiObject* pInst,
                                            bool bClassDeletion)
{
    HRESULT hres;

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteFile(wszFilePath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_NOT_FOUND;
    }
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    hres = DeleteInstanceLink(pInst, wszFilePath);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    hres = DeleteInstanceReferences(pInst, wszFilePath);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    if(bClassDeletion)
    {
        //
        // We need to remove all dangling references to this instance, 
        // because they make no sense once the class is deleted --- we don't
        // know what key structure the new class will even have.  In the future,
        // we'll want to move these references to some class-wide location
        //

        hres = DeleteInstanceBackReferences(wszFilePath);
        if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
            return hres;
    }

    return S_OK;
}

CHR CNamespaceHandle::ConstructReferenceDirFromFilePath(
                                LPCWSTR wszFilePath, LPWSTR wszReferenceDir)
{
    //
    // It's the same, only with INSTDEF_FILE_PREFIX replaced with 
    // INSTREF_DIR_PREFIX
    //

    CFileName wszEnding;
	if (wszEnding == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    WCHAR* pwcLastSlash = wcsrchr(wszFilePath, L'\\');
    if(pwcLastSlash == NULL)
        return WBEM_E_FAILED;
    
    wcscpy(wszEnding, pwcLastSlash + 1 + wcslen(A51_INSTDEF_FILE_PREFIX));

    wcscpy(wszReferenceDir, wszFilePath);
    wszReferenceDir[(pwcLastSlash+1)-wszFilePath] = 0;

    wcscat(wszReferenceDir, A51_INSTREF_DIR_PREFIX);
    wcscat(wszReferenceDir, wszEnding);
    return S_OK;
}

CHR CNamespaceHandle::DeleteInstanceBackReferences(LPCWSTR wszFilePath)
{
    HRESULT hres;

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromFilePath(wszFilePath, wszReferenceDir);
    if(FAILED(hres))
        return hres;
    wcscat(wszReferenceDir, L"\\");

    CFileName wszReferencePrefix;
	if (wszReferencePrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferencePrefix, wszReferenceDir);
    wcscat(wszReferencePrefix, A51_REF_FILE_PREFIX);

    // 
    // Enumerate all files in it
    //

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = g_Glob.GetFileCache()->FindFirst(wszReferencePrefix, &fd, &hSearch);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(g_Glob.GetFileCache(), hSearch);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszFullFileName, wszReferenceDir);
    long lDirLen = wcslen(wszFullFileName);

    do
    {
        if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            continue;

        wcscpy(wszFullFileName+lDirLen, fd.cFileName);

        long lRes = g_Glob.GetFileCache()->DeleteFile(wszFullFileName);
        if(lRes != ERROR_SUCCESS)
        {
            ERRORTRACE((LOG_WBEMCORE, "Cannot delete reference file '%S' with "
                "error code %d\n", wszFullFileName, lRes));
            return WBEM_E_FAILED;
        }
    }
    while(g_Glob.GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return S_OK;
}



CHR CNamespaceHandle::DeleteInstanceLink(_IWmiObject* pInst,
                                                LPCWSTR wszInstanceDefFilePath)
{
    HRESULT hres;

    //
    // Get the class name
    //
    
    VARIANT vClass;
    VariantInit(&vClass);
    CClearMe cm1(&vClass);
    
    hres = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

    LPCWSTR wszClassName = V_BSTR(&vClass);

    //
    // Construct the link directory for the class
    //

    CFileName wszInstanceLinkPath;
	if (wszInstanceLinkPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszInstanceLinkPath, wszClassName);
    if(FAILED(hres))
        return hres;

    wcscat(wszInstanceLinkPath, L"\\" A51_INSTLINK_FILE_PREFIX);

    //
    // It remains to append the instance-specific part of the file name.  
    // Convineintly, it is the same material as was used for the def file path,
    // so we can steal it.  ALERT: RELIES ON ALL PREFIXES ENDING IN '_'!!
    //

    WCHAR* pwcLastUnderscore = wcsrchr(wszInstanceDefFilePath, L'_');
    if(pwcLastUnderscore == NULL)
        return WBEM_E_CRITICAL_ERROR;

    wcscat(wszInstanceLinkPath, pwcLastUnderscore+1);

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteFile(wszInstanceLinkPath);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
        return WBEM_E_NOT_FOUND;
    else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

    


CHR CNamespaceHandle::DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // For now, just check if it is a namespace
    //

    hres = pInst->InheritsFrom(L"__Namespace");
    if(FAILED(hres))
        return hres;

    if(hres != S_OK) // not a namespace
        return S_FALSE;

    //
    // It is a namespace --- construct full path
    //

    WString wsFullName = m_wsNamespace;
    wsFullName += L"\\";

    VARIANT vName;
    VariantInit(&vName);
    CClearMe cm(&vName);
    hres = pInst->Get(L"Name", 0, &vName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&vName) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    wsFullName += V_BSTR(&vName);

    //
    // Delete it
    //

    CNamespaceHandle* pNewHandle = new CNamespaceHandle(m_pControl,
                                                        m_pRepository);
    if(pNewHandle == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewHandle->AddRef();
    CReleaseMe rm1(pNewHandle);

    hres = pNewHandle->Initialize(wsFullName);
    if(FAILED(hres))
        return hres;

    //
    // Mind to only fire child namespace deletion events from the inside
    //

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = pNewHandle->DeleteSelf(aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

    //
    // Fire the event
    //

    hres = FireEvent(aEvents, WBEM_EVENTTYPE_NamespaceDeletion, 
                    V_BSTR(&vName), pInst);

    return S_OK;
}

CHR CNamespaceHandle::DeleteSelf(CEventCollector &aEvents)
{
    //
    // Delete all top-level classes. This will delete all namespaces    
    // (as instances of __Namespace), all classes (as children of top-levels)
    // and all instances
    //

    HRESULT hres = DeleteDerivedClasses(L"", aEvents);
    if(FAILED(hres))
        return hres;

	//
	// One extra thing --- clean up relationships for the empty class
	//

    CFileName wszRelationshipDir;
	if (wszRelationshipDir== NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(L"", wszRelationshipDir);
    if(FAILED(hres))
        return hres;

    long lRes = g_Glob.GetFileCache()->RemoveDirectory(wszRelationshipDir);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_FAILED;
    }

    //
    // Delete our own root directory -- it should be empty by now
    //

    if(g_Glob.GetFileCache()->RemoveDirectory(m_wszInstanceRootDir) != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // We do not delete our class root directory --- if we are a namespace, it
    // is the same as our instance root directory so we are already done; if not
    // we should not be cleaning up all the classes!
    //

    m_pClassCache->SetError(WBEM_E_INVALID_NAMESPACE);

    return S_OK;
}
    

CHR CNamespaceHandle::DeleteInstanceReferences(_IWmiObject* pInst, 
                                                LPCWSTR wszFilePath)
{
    HRESULT hres;

    hres = pInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    VARIANT v;
    while((hres = pInst->Next(0, NULL, &v, NULL, NULL)) == S_OK)
    {
        CClearMe cm(&v);

        if(V_VT(&v) == VT_BSTR)
        {
            hres = DeleteInstanceReference(wszFilePath, V_BSTR(&v));
            if(FAILED(hres))
                return hres;
        }
    }

    if(FAILED(hres))
        return hres;

    pInst->EndEnumeration();
    return S_OK;
}
    
// NOTE: will clobber wszReference
CHR CNamespaceHandle::DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference)
{
    HRESULT hres;

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceFileName(wszReference, wszOurFilePath, wszReferenceFile);
	if(FAILED(hres))
	{
		if(hres == WBEM_E_NOT_FOUND)
		{
			//
			// Oh joy. A reference to an instance of a *class* that does not
			// exist (not a non-existence instance, those are normal).
			// Forget it (BUGBUG)
			//

			return S_OK;
		}
		else
			return hres;
	}

    long lRes = g_Glob.GetFileCache()->DeleteFile(wszReferenceFile);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_FILE_NOT_FOUND)
            return WBEM_E_NOT_FOUND;
        else
            return WBEM_E_FAILED;
        }
    else
        return WBEM_S_NO_ERROR;
}


CHR CNamespaceHandle::DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents)
{
    HRESULT hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
	bool bSystemClass = false;
    hres = GetClassByHash(wszHash, false, &pClass, NULL, NULL, &bSystemClass);
    CReleaseMe rm1(pClass);
    if(FAILED(hres))
        return hres;

    //
    // Get the actual class name
    //

    VARIANT v;
    hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&v);

    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_CLASS;

    //
    // Construct definition file name
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileNameFromHash(wszHash, wszFileName);
    if(FAILED(hres))
        return hres;

    return DeleteClassInternal(V_BSTR(&v), pClass, wszFileName, aEvents, bSystemClass);
}
    
CHR CNamespaceHandle::DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents)
{
    HRESULT hres;

	A51TRACE(("Deleting class %S\n", wszClassName));

    //
    // Construct the path for the file
    //

    CFileName wszFileName;
	if (wszFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassDefFileName(wszClassName, wszFileName);
    if(FAILED(hres))
        return hres;

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
	bool bSystemClass = false;
    hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass, 
                            false, NULL, NULL, &bSystemClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    return DeleteClassInternal(wszClassName, pClass, wszFileName, aEvents, bSystemClass);
}

CHR CNamespaceHandle::DeleteClassInternal(LPCWSTR wszClassName,
                                              _IWmiObject* pClass,
                                              LPCWSTR wszFileName,
											  CEventCollector &aEvents,
											  bool bSystemClass)
{
    HRESULT hres;

    CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

    //
    // Delete all derived classes
    //

    hres = DeleteDerivedClasses(wszClassName, aEvents);

    if(FAILED(hres))
        return hres;

	//
	// Delete all instances.  Only fire events if namespaces are deleted
	//

    bool bNamespaceOnly = aEvents.IsNamespaceOnly();
    aEvents.SetNamespaceOnly(true);
    hres = DeleteClassInstances(wszClassName, pClass, aEvents);
    if(FAILED(hres))
        return hres;
    aEvents.SetNamespaceOnly(bNamespaceOnly);

	if (!bSystemClass)
	{
		//
		// Clean up references
		//

		hres = EraseClassRelationships(wszClassName, pClass, wszFileName);
		if(FAILED(hres))
			return hres;

		//
		// Delete the file
		//

		long lRes = g_Glob.GetFileCache()->DeleteFile(wszFilePath);
		if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
			return WBEM_E_NOT_FOUND;
		else if(lRes != ERROR_SUCCESS)
			return WBEM_E_FAILED;

	}

    m_pClassCache->InvalidateClass(wszClassName);

    //
    // Fire an event
    //

    hres = FireEvent(aEvents, WBEM_EVENTTYPE_ClassDeletion, wszClassName, pClass);

    return S_OK;
}

CHR CNamespaceHandle::DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents)
{
    HRESULT hres;

    CWStringArray wsChildHashes;
    hres = GetChildHashes(wszClassName, wsChildHashes);
    if(FAILED(hres))
        return hres;

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        hres = DeleteClassByHash(wsChildHashes[i], aEvents);

        if(FAILED(hres) && (hres != WBEM_E_NOT_FOUND))
        {
            return hres;
        }
    }

    return S_OK;
}

CHR CNamespaceHandle::GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildDefsByHash(wszHash, bRecursive, pSink, bClone);
}

CHR CNamespaceHandle::GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

	long lStartIndex = m_pClassCache->GetLastInvalidationIndex();

    //
    // Get the hashes of the child filenames
    //

    CWStringArray wsChildHashes;
    hres = GetChildHashesByHash(wszHash, wsChildHashes);
    if(FAILED(hres))
        return hres;

    //
    // Get their class definitions
    //

    for(int i = 0; i < wsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = wsChildHashes[i];

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszChildHash, bClone, &pClass, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pClass);

        hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
        if(FAILED(hres))
            return hres;
        
        //
        // Continue recursively if indicated
        //

        if(bRecursive)
        {
            hres = GetChildDefsByHash(wszChildHash, bRecursive, pSink, bClone);
            if(FAILED(hres))
                return hres;
        }
    }

    //
    // Mark cache completeness
    //

	m_pClassCache->DoneWithChildrenByHash(wszHash, bRecursive, lStartIndex);
    return S_OK;
}

    
CHR CNamespaceHandle::GetChildHashes(LPCWSTR wszClassName, 
                                        CWStringArray& wsChildHashes)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    return GetChildHashesByHash(wszHash, wsChildHashes);
}

CHR CNamespaceHandle::GetChildHashesByHash(LPCWSTR wszHash, 
                                        CWStringArray& wsChildHashes)
{
    HRESULT hres;
    long lRes;

	//Try retrieving the system classes namespace first...
	if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
	{
		hres = g_pSystemClassNamespace->GetChildHashesByHash(wszHash, wsChildHashes);
		if (FAILED(hres))
			return hres;
	}

    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
	if (wszChildPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    wcscat(wszChildPrefix, L"\\" A51_CHILDCLASS_FILE_PREFIX);

    //
    // Enumerate all such files in the cache
    //

    void* pHandle = NULL;
    WIN32_FIND_DATAW wfd;
    lRes = g_Glob.GetFileCache()->FindFirst(wszChildPrefix, &wfd, &pHandle);
    
    while(lRes == ERROR_SUCCESS)
    {
        wsChildHashes.Add(wfd.cFileName + wcslen(A51_CHILDCLASS_FILE_PREFIX));
        lRes = g_Glob.GetFileCache()->FindNext(pHandle, &wfd);
    }

	if(pHandle)
		g_Glob.GetFileCache()->FindClose(pHandle);

    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_NO_MORE_FILES)
        return WBEM_E_FAILED;
    else
        return S_OK;
}

CHR CNamespaceHandle::ClassHasChildren(LPCWSTR wszClassName)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;
    
	HRESULT hres;
    long lRes;

	//Try retrieving the system classes namespace first...
	if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
	{
		hres = g_pSystemClassNamespace->ClassHasChildren(wszClassName);
		if (FAILED(hres) || (hres == WBEM_S_NO_ERROR))
			return hres;
	}
    //
    // Construct the prefix for the children classes
    //

    CFileName wszChildPrefix;
	if (wszChildPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDirFromHash(wszHash, wszChildPrefix);
    if(FAILED(hres))
        return hres;

    wcscat(wszChildPrefix, L"\\" A51_CHILDCLASS_FILE_PREFIX);

    void* pHandle = NULL;
    WIN32_FIND_DATAW wfd;
    lRes = g_Glob.GetFileCache()->FindFirst(wszChildPrefix, &wfd, &pHandle);

    A51TRACE(("FindFirst %S returned %d\n", wszChildPrefix, lRes));
    
	if(pHandle)
		g_Glob.GetFileCache()->FindClose(pHandle);

    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
    {
        ERRORTRACE((LOG_WBEMCORE, "Unexpected error code %d from FindFirst on "
                        "'%S'", lRes, wszChildPrefix));
        return WBEM_E_FAILED;
    }
	else if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_S_FALSE;
    else
        return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ClassHasInstances(LPCWSTR wszClassName)
{
    CFileName wszHash;
	if (wszHash == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    if(!A51Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

	return ClassHasInstancesFromClassHash(wszHash);
}

CHR CNamespaceHandle::ClassHasInstancesFromClassHash(LPCWSTR wszClassHash)
{
    HRESULT hres;
    long lRes;

    //
    // Check the instances in this namespace first.  The instance directory in
    // default scope is the class directory of the namespace
    //

    hres = ClassHasInstancesInScopeFromClassHash(m_wszClassRootDir, 
                                                    wszClassHash);
    if(hres != WBEM_S_FALSE)
        return hres;

    //
    // No instances in the namespace --- have to enumerate all the scopes
    //

/*
    CFileName wszScopeDir;
	if (wszScopeDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszScopeDir, m_wszClassRootDir);
    wcscat(wszScopeDir, L"\\" A51_SCOPE_DIR_PREFIX);

    void* pScopeHandle = NULL;
    WIN32_FIND_DATAW fdScope;
    lRes = g_Glob.GetFileCache()->FindFirst(wszScopeDir, &fdScope, &pScopeHandle);
    if(lRes != ERROR_SUCCESS)
    {
*/
    return WBEM_S_FALSE;
}
        
CHR CNamespaceHandle::ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash)
{
    CFileName wszFullDirName;
	if (wszFullDirName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszFullDirName, wszInstanceRootDir);
    wcscat(wszFullDirName, L"\\" A51_CLASSINST_DIR_PREFIX);
    wcscat(wszFullDirName, wszClassHash);
    wcscat(wszFullDirName, L"\\" A51_INSTLINK_FILE_PREFIX);

    void* pHandle = NULL;
    WIN32_FIND_DATAW fd;
	LONG lRes;
    lRes = g_Glob.GetFileCache()->FindFirst(wszFullDirName, &fd, &pHandle);

	if(pHandle)
	    g_Glob.GetFileCache()->FindClose(pHandle);

    if(lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_NO_MORE_FILES && lRes != S_OK)
	{
		A51TRACE(("ClassHasInstances returning WBEM_E_FAILED for %S\\CD_%S\n", m_wsFullNamespace, wszClassHash));
        return WBEM_E_FAILED;
	}
	else if (lRes == ERROR_FILE_NOT_FOUND)
	{
		A51TRACE(("ClassHasInstances returning WBEM_S_FALSE for %S\\CD_%S\n", m_wsFullNamespace, wszClassHash));
		return WBEM_S_FALSE;
	}
    else
	{
		A51TRACE(("ClassHasInstances returning WBEM_S_NO_ERROR for %S\\CD_%S\n", m_wsFullNamespace, wszClassHash));
        return WBEM_S_NO_ERROR;
	}
}

CHR CNamespaceHandle::EraseParentChildRelationship(
                            LPCWSTR wszChildFileName, LPCWSTR wszParentName)
{
    CFileName wszParentChildFileName;
	if (wszParentChildFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres = ConstructParentChildFileName(wszChildFileName,
                                                wszParentName,
                                                wszParentChildFileName);

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteFile(wszParentChildFileName);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::EraseClassRelationships(LPCWSTR wszClassName,
                            _IWmiObject* pClass, LPCWSTR wszFileName)
{
    HRESULT hres;

    //
    // Get the parent
    //

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__SUPERCLASS", 0, &v, NULL, NULL);
    CClearMe cm(&v);


    if(FAILED(hres))
        return hres;

    if(V_VT(&v) == VT_BSTR)
        hres = EraseParentChildRelationship(wszFileName, V_BSTR(&v));
    else
        hres = EraseParentChildRelationship(wszFileName, L"");

	if(FAILED(hres))
		return hres;

    //
    // Erase references
    //

    hres = pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if(FAILED(hres))
        return hres;
    
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strName);

        hres = EraseClassReference(pClass, wszFileName, strName);
		if(FAILED(hres) && (hres != WBEM_E_NOT_FOUND))
			return hres;
    }

    pClass->EndEnumeration();

    //
    // Erase our relationship directories.  For now, they must be
    // empty at this point, BUT THIS WILL BREAK WHEN WE ADD CLASS REFERENCES.
    //

    CFileName wszRelationshipDir;
	if (wszRelationshipDir == NULL)
    {
		return WBEM_E_OUT_OF_MEMORY;
    }
    hres = ConstructClassRelationshipsDir(wszClassName, wszRelationshipDir);
    if(FAILED(hres))
        return hres;

    long lRes = g_Glob.GetFileCache()->RemoveDirectory(wszRelationshipDir, false);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND && lRes != ERROR_DIR_NOT_EMPTY)
    {
        return WBEM_E_FAILED;
    }


    return S_OK;
}

CHR CNamespaceHandle::EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp)
{
	HRESULT hres;

    //
    // Figure out the class we are pointing to
    //

    DWORD dwSize = 0;
    DWORD dwFlavor = 0;
    CIMTYPE ct;
    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, 0,
            &ct, &dwFlavor, &dwSize, NULL);
    if(dwSize == 0)
        return WBEM_E_OUT_OF_MEMORY;

    LPWSTR wszQual = (WCHAR*)TempAlloc(dwSize);
    if(wszQual == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszQual, dwSize);

    hres = pReferringClass->GetPropQual(wszReferringProp, L"CIMTYPE", 0, dwSize,
            &ct, &dwFlavor, &dwSize, wszQual);
    if(FAILED(hres))
        return hres;
    
    //
    // Parse out the class name
    //

    WCHAR* pwcColon = wcschr(wszQual, L':');
    if(pwcColon == NULL)
        return S_OK; // untyped reference requires no bookkeeping

    LPCWSTR wszReferredToClass = pwcColon+1;

    //
    // Figure out the name of the file for the reference.  
    //

    CFileName wszReferenceFile;
	if (wszReferenceFile == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassReferenceFileName(wszReferredToClass, 
                                wszReferringFile, wszReferringProp,
                                wszReferenceFile);
    if(FAILED(hres))
        return hres;

    //
    // Delete the file
    //

    long lRes = g_Glob.GetFileCache()->DeleteFile(wszReferenceFile);
	if (lRes == ERROR_FILE_NOT_FOUND)
		return WBEM_E_NOT_FOUND;
	else if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    return S_OK;
}

CHR CNamespaceHandle::DeleteClassInstances(LPCWSTR wszClassName, 
											   _IWmiObject* pClass,
											   CEventCollector &aEvents)
{
	HRESULT hres;

    //
    // Find the link directory for this class
    //

    CFileName wszLinkDir;
	if (wszLinkDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClass(wszLinkDir, wszClassName);
    if(FAILED(hres))
        return hres;
    
    // 
    // Enumerate all links in it
    //

    CFileName wszSearchPrefix;
	if (wszSearchPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszSearchPrefix, wszLinkDir);
    wcscat(wszSearchPrefix, L"\\" A51_INSTLINK_FILE_PREFIX);

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = g_Glob.GetFileCache()->FindFirst(wszSearchPrefix, &fd, &hSearch);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes != ERROR_FILE_NOT_FOUND)
        {
            return WBEM_E_FAILED;
        }

        // Still need to do directory cleanup!
    }
    else
    {
        CFileCache::CFindCloseMe fcm(g_Glob.GetFileCache(), hSearch);

        //
        // Prepare a buffer for instance definition file path
        //
    
        CFileName wszFullFileName;
        if (wszFullFileName == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        hres = ConstructKeyRootDirFromClass(wszFullFileName, wszClassName);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_CANNOT_BE_ABSTRACT)
                return WBEM_S_NO_ERROR;
    
            return hres;
        }
    
        long lDirLen = wcslen(wszFullFileName);
        wszFullFileName[lDirLen] = L'\\';
        lDirLen++;
    
        do
        {
            hres = ConstructInstDefNameFromLinkName(wszFullFileName+lDirLen, 
                                                        fd.cFileName);
            if(FAILED(hres))
                return hres;

            _IWmiObject* pInst;
            hres = FileToInstance(wszFullFileName, &pInst);
            if(FAILED(hres))
				return hres;

            CReleaseMe rm1(pInst);
    
            //
            // Delete the instance, knowing that we are deleting its class. That
            // has an affect on how we deal with the references
            //
    
            hres = DeleteInstanceByFile(wszFullFileName, pInst, true, aEvents);
            if(FAILED(hres))
                return hres;
        }
        while(g_Glob.GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);
    }

    //
    // Erase our instance directories.  It must be
    // empty at this point
    //

    lRes = g_Glob.GetFileCache()->RemoveDirectory(wszLinkDir);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_FAILED;
    }

    //
    // Erase our key root directory, if we have a key root directory
    //

    CFileName wszPutativeKeyRootDir;
	if (wszPutativeKeyRootDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructKeyRootDirFromKeyRoot(wszPutativeKeyRootDir, wszClassName);
    if(FAILED(hres))
        return hres;

    lRes = g_Glob.GetFileCache()->RemoveDirectory(wszPutativeKeyRootDir);
    if(lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND && 
            lRes != ERROR_PATH_NOT_FOUND)
    {
        return WBEM_E_FAILED;
    }

    return S_OK;
}

class CExecQueryObject : public CFiberTask
{
protected:
    IWbemQuery* m_pQuery;
    CDbIterator* m_pIter;
    CNamespaceHandle* m_pNs;
	DWORD m_lFlags;

public:
    CExecQueryObject(CNamespaceHandle* pNs, IWbemQuery* pQuery, 
                        CDbIterator* pIter, DWORD lFlags)
        : m_pQuery(pQuery), m_pIter(pIter), m_pNs(pNs), m_lFlags(lFlags)
    {
        m_pQuery->AddRef();
        m_pNs->AddRef();

        //
        // Does not AddRef the iterator --- iterator owns and cleans up the req
        //
    }

    ~CExecQueryObject()
    {
        if(m_pQuery)
            m_pQuery->Release();
        if(m_pNs)
            m_pNs->Release();
    }
    
    HRESULT Execute()
    {
        HRESULT hres = m_pNs->ExecQuerySink(m_pQuery, m_lFlags, 0, m_pIter, NULL);
        m_pIter->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
        return hres;
    }
};


CHR CNamespaceHandle::ExecQuery(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    DWORD *dwMessageFlags,
    IWmiDbIterator **ppQueryResult
    )
{
    CDbIterator* pIter = new CDbIterator(m_pControl, m_bUseIteratorLock);
	m_bUseIteratorLock = true;
	if (pIter == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pIter->AddRef();
    CReleaseMe rm1((IWmiDbIterator*)pIter);

    //
    // Create a fiber execution object
    //

    CExecQueryObject* pReq = new CExecQueryObject(this, pQuery, pIter, dwFlags);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

#ifdef A51_USE_FIBER
    //
    // Create a fiber for it
    //

    void* pFiber = CreateFiberForTask(pReq);
    if(pFiber == NULL)
    {
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    pIter->SetExecFiber(pFiber, pReq);
#else
    HRESULT hRes = pReq->Execute();
    delete pReq;
    if (FAILED(hRes))
        return hRes;
#endif

    return pIter->QueryInterface(IID_IWmiDbIterator, (void**)ppQueryResult);
}

CHR CNamespaceHandle::ExecQuerySink(
     IWbemQuery *pQuery,
     DWORD dwFlags,
     DWORD dwRequestedHandleType,
    IWbemObjectSink* pSink,
    DWORD *dwMessageFlags
    )
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    LPWSTR wszQuery = NULL;
    hres = pQuery->GetAnalysis(WMIQ_ANALYSIS_QUERY_TEXT, 0, (void**)&wszQuery);
	if (FAILED(hres))
		return hres;

    DWORD dwLen = ((wcslen(wszQuery) + 1) * sizeof(wchar_t));
    LPWSTR strParse = (LPWSTR)TempAlloc(dwLen);
    if(strParse == NULL)
    {
		pQuery->FreeMemory(wszQuery);
        return WBEM_E_OUT_OF_MEMORY;
    }
    CTempFreeMe tfm(strParse, dwLen);
    wcscpy(strParse, wszQuery);

     if(!_wcsicmp(wcstok(strParse, L" "), L"references"))
    {
        hres = ExecReferencesQuery(wszQuery, pSink);
		pQuery->FreeMemory(wszQuery);
		return hres;
    }

    QL_LEVEL_1_RPN_EXPRESSION* pExpr = NULL;
    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    int nRet = Parser.Parse(&pExpr);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

	pQuery->FreeMemory(wszQuery);

    if (nRet == QL1_Parser::OUT_OF_MEMORY)
        return WBEM_E_OUT_OF_MEMORY;
    if (nRet != QL1_Parser::SUCCESS)
        return WBEM_E_FAILED;

    if(!_wcsicmp(pExpr->bsClassName, L"meta_class"))
    {
        return ExecClassQuery(pExpr, pSink, dwFlags);
    }
    else
    {
        return ExecInstanceQuery(pExpr, pExpr->bsClassName, 
								 (dwFlags & WBEM_FLAG_SHALLOW ? false : true), 
                                    pSink);
    }
}


CHR CNamespaceHandle::ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
                                            IWbemObjectSink* pSink,
											DWORD dwFlags)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hres = ERROR_SUCCESS;

    //
    // Optimizations:
    //

    LPCWSTR wszClassName = NULL;
    LPCWSTR wszSuperClass = NULL;
    LPCWSTR wszAncestor = NULL;
	bool bDontIncludeAncestorInResultSet = false;

    if(pExpr->nNumTokens == 1)
    {
        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;
        if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__SUPERCLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszSuperClass = V_BSTR(&pToken->vConstValue);
        }
        else if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__THIS") &&
            pToken->nOperator == QL1_OPERATOR_ISA)
        {
            wszAncestor = V_BSTR(&pToken->vConstValue);
        }
        else if(!_wcsicmp(pToken->PropertyName.GetStringAt(0), L"__CLASS") &&
            pToken->nOperator == QL1_OPERATOR_EQUALS)
        {
            wszClassName = V_BSTR(&pToken->vConstValue);
        }
    }
	else if (pExpr->nNumTokens == 3)
	{
        //
		// This is a special optimisation used for deep enumeration of classes,
        // and is expecting a query of:
		//   select * from meta_class where __this isa '<class_name>' 
        //                                  and __class <> '<class_name>'
		// where the <class_name> is the same class iin both cases.  This will 
        // set the wszAncestor to <class_name> and propagate a flag to not 
        // include the actual ancestor in the list.
        //

		QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens;

		if ((pToken[0].nTokenType == QL1_OP_EXPRESSION) &&
			(pToken[1].nTokenType == QL1_OP_EXPRESSION) &&
			(pToken[2].nTokenType == QL1_AND) &&
			(pToken[0].nOperator == QL1_OPERATOR_ISA) &&
			(pToken[1].nOperator == QL1_OPERATOR_NOTEQUALS) &&
			(_wcsicmp(pToken[0].PropertyName.GetStringAt(0), L"__THIS") == 0) &&
			(_wcsicmp(pToken[1].PropertyName.GetStringAt(0), L"__CLASS") == 0) 
            &&
			(wcscmp(V_BSTR(&pToken[0].vConstValue), 
                    V_BSTR(&pToken[1].vConstValue)) == 0)
           )
		{
			wszAncestor = V_BSTR(&pToken[0].vConstValue);
			bDontIncludeAncestorInResultSet = true;
		}
	}

    if(wszClassName)
    {
        _IWmiObject* pClass = NULL;
        hres = GetClassDirect(wszClassName, IID__IWmiObject, (void**)&pClass,
                                true, NULL, NULL, NULL);
        if(hres == WBEM_E_NOT_FOUND)
        {
            //
            // Class not there --- but that's success for us!
            //
			if (dwFlags & WBEM_FLAG_VALIDATE_CLASS_EXISTENCE)
				return hres;
			else
				return S_OK;
        }
        else if(FAILED(hres))
        {
            return hres;
        }
        else 
        {
            CReleaseMe rm1(pClass);

            //
            // Get the class
            //

            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;

            return S_OK;
        }
    }
	if (dwFlags & WBEM_FLAG_VALIDATE_CLASS_EXISTENCE)
	{
        _IWmiObject* pClass = NULL;
		if (wszSuperClass)
			hres = GetClassDirect(wszSuperClass, IID__IWmiObject, (void**)&pClass, false, NULL, NULL, NULL);
		else if (wszAncestor)
			hres = GetClassDirect(wszAncestor, IID__IWmiObject, (void**)&pClass, false, NULL, NULL, NULL);
		if (FAILED(hres))
			return hres;
		if (pClass)
			pClass->Release();
	}
    
    hres = EnumerateClasses(pSink, wszSuperClass, wszAncestor, true, 
                                bDontIncludeAncestorInResultSet);
    if(FAILED(hres))
        return hres;
    
    return S_OK;
}

CHR CNamespaceHandle::EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, 
                                bool bDontIncludeAncestorInResultSet)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    CWStringArray wsClasses;
    HRESULT hres;

    //
    // If superclass is given, check if its record is complete wrt children
    //

    if(wszSuperClass)
    {
        hres = m_pClassCache->EnumChildren(wszSuperClass, false, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            return GetChildDefs(wszSuperClass, false, pSink, bClone);
        }
        else
        {
            if(FAILED(hres))
                return hres;
                
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
    else
    {
        if(wszAncestor == NULL)
            wszAncestor = L"";

        hres = m_pClassCache->EnumChildren(wszAncestor, true, wsClasses);
        if(hres == WBEM_S_FALSE)
        {
            //
            // Not in cache --- get the info from files
            //

            hres = GetChildDefs(wszAncestor, true, pSink, bClone);
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
                //
                // The class is derived from itself
                //

                _IWmiObject* pClass =  NULL;
                hres = GetClassDirect(wszAncestor, IID__IWmiObject, 
                        (void**)&pClass, bClone, NULL, NULL, NULL);
                if(FAILED(hres))
                    return hres;
				CReleaseMe rm1(pClass);

				hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
				if(FAILED(hres))
			        return hres;
            }

            return S_OK;
        }
        else
        {
            if(FAILED(hres))
                return hres;

            if(*wszAncestor && !bDontIncludeAncestorInResultSet)
            {
	          wsClasses.Add(wszAncestor);
            }
            return ListToEnum(wsClasses, pSink, bClone);
        }
    }
}
    
CHR CNamespaceHandle::ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone)
{
    HRESULT hres;

    for(int i = 0; i < wsClasses.Size(); i++)
    {
        _IWmiObject* pClass = NULL;
        if(wsClasses[i] == NULL || wsClasses[i][0] == 0)
            continue;

        hres = GetClassDirect(wsClasses[i], IID__IWmiObject, (void**)&pClass, 
                                bClone, NULL, NULL, NULL);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
            {
                // That's OK --- class got removed
            }
            else
                return hres;
        }
        else
        {
            CReleaseMe rm1(pClass);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    WCHAR wszHash[MAX_HASH_LEN+1];
    if(!Hash(wszClassName, wszHash))
        return WBEM_E_OUT_OF_MEMORY;

    if(bDeep)
        hres = ExecDeepInstanceQuery(pQuery, wszHash, pSink);
    else
        hres = ExecShallowInstanceQuery(pQuery, wszHash, pSink);

    if(FAILED(hres))
        return hres;
        
    return S_OK;
}

CHR CNamespaceHandle::ExecDeepInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Get all our instances
    //

    hres = ExecShallowInstanceQuery(pQuery, wszClassHash, pSink);
    if(FAILED(hres))
        return hres;

    CWStringArray awsChildHashes;

    //
    // Check if the list of child classes is known to the cache
    //

    hres = m_pClassCache->EnumChildKeysByKey(wszClassHash, awsChildHashes);
	if (hres == WBEM_S_FALSE)
	{
        //
        // OK --- get them from the disk
        //

        hres = GetChildHashesByHash(wszClassHash, awsChildHashes);
	}
	
	if (FAILED(hres))
	{
		return hres;
	}

    //
    // We have our hashes --- call them recursively
    //

    for(int i = 0; i < awsChildHashes.Size(); i++)
    {
        LPCWSTR wszChildHash = awsChildHashes[i];
        hres = ExecDeepInstanceQuery(pQuery, wszChildHash, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}
        
CHR CNamespaceHandle::ExecShallowInstanceQuery(
                                QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink)
{    
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hres;

    // 
    // Enumerate all files in the link directory
    //

    CFileName wszSearchPrefix;
	if (wszSearchPrefix == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructLinkDirFromClassHash(wszSearchPrefix, wszClassHash);
    if(FAILED(hres))
        return hres;

    wcscat(wszSearchPrefix, L"\\" A51_INSTLINK_FILE_PREFIX);

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = g_Glob.GetFileCache()->FindFirst(wszSearchPrefix, &fd, &hSearch);
    if(lRes != ERROR_SUCCESS)
    {
        if(lRes == ERROR_FILE_NOT_FOUND)
            return WBEM_S_NO_ERROR;
        else
            return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(g_Glob.GetFileCache(), hSearch);

    //
    // Get Class definition
    //

    _IWmiObject* pClass = NULL;
    hres = GetClassByHash(wszClassHash, false, &pClass, NULL, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClass);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    hres = ConstructKeyRootDirFromClassHash(wszFullFileName, wszClassHash);
    if(FAILED(hres))
        return hres;

    long lDirLen = wcslen(wszFullFileName);
    wszFullFileName[lDirLen] = L'\\';
    lDirLen++;

    do
    {
        hres = ConstructInstDefNameFromLinkName(wszFullFileName+lDirLen, 
                                                fd.cFileName);
        if(FAILED(hres))
            return hres;

        _IWmiObject* pInstance = NULL;
        hres = FileToInstance(wszFullFileName, &pInstance, true);
        if(FAILED(hres))
            return hres;

        CReleaseMe rm1(pInstance);
        hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
        if(FAILED(hres))
            return hres;
    }
    while(g_Glob.GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return S_OK;
}

CHR CNamespaceHandle::ExecReferencesQuery(LPCWSTR wszQuery, 
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Make a copy for parsing
    //

    LPWSTR wszParse = new WCHAR[wcslen(wszQuery)+1];
	if (wszParse == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(wszParse);
    wcscpy(wszParse, wszQuery);

    //
    // Extract the path of the target object.
    //

    //
    // Find the first brace
    //

    WCHAR* pwcStart = wcschr(wszParse, L'{');
    if(pwcStart == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Find the beginning of the path
    //

    while(*pwcStart && iswspace(*pwcStart)) pwcStart++;
    if(!*pwcStart)
        return WBEM_E_INVALID_QUERY;

    pwcStart++;
    
    //
    // Find the ending curly brace
    //

    WCHAR* pwc = pwcStart;
    WCHAR wcCurrentQuote = 0;
    while(*pwc && (wcCurrentQuote || *pwc != L'}'))
    {
        if(wcCurrentQuote)
        {
            if(*pwc == L'\\')
            {
                pwc++;
            }
            else if(*pwc == wcCurrentQuote)
                wcCurrentQuote = 0;
        }
        else if(*pwc == L'\'' || *pwc == L'"')
            wcCurrentQuote = *pwc;

        pwc++;
    }

    if(*pwc != L'}')
        return WBEM_E_INVALID_QUERY;

    //
    // Find the end of the path
    //
    
    WCHAR* pwcEnd = pwc-1;
    while(iswspace(*pwcEnd)) pwcEnd--;

    pwcEnd[1] = 0;
    
    LPWSTR wszTargetPath = pwcStart;
    if(wszTargetPath == NULL)
        return WBEM_E_INVALID_QUERY;

    //
    // Parse the path
    //

    DWORD dwLen = (wcslen(wszTargetPath)+1) * sizeof(WCHAR);
    LPWSTR wszKey = (LPWSTR)TempAlloc(dwLen);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe tfm(wszKey, dwLen);

    LPWSTR wszClassName = NULL;
    bool bIsClass;
    hres = ComputeKeyFromPath(wszTargetPath, wszKey, &wszClassName, &bIsClass);
    if(FAILED(hres))
        return hres;
    CTempFreeMe tfm1(wszClassName, (wcslen(wszClassName)+1) * sizeof(WCHAR*));
    
    if(bIsClass)
    {
        //
        // Need to execute an instance reference query to find all instances
        // pointing to this class
        //

        hres = ExecInstanceRefQuery(wszQuery, NULL, wszClassName, pSink);
        if(FAILED(hres))
            return hres;

        hres = ExecClassRefQuery(wszQuery, wszClassName, pSink);
        if(FAILED(hres))
            return hres;
    }
    else
    {
        hres = ExecInstanceRefQuery(wszQuery, wszClassName, wszKey, pSink);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}

CHR CNamespaceHandle::ExecInstanceRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                LPCWSTR wszKey,
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

    //
    // Find the instance's ref dir.
    //

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructReferenceDirFromKey(wszClassName, wszKey, wszReferenceDir);
    if(FAILED(hres))
        return hres;

    CFileName wszReferenceMask;
	if (wszReferenceMask == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferenceMask, wszReferenceDir);
    wcscat(wszReferenceMask, L"\\" A51_REF_FILE_PREFIX);

    // 
    // Enumerate all files in it
    //

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = g_Glob.GetFileCache()->FindFirst(wszReferenceMask, &fd, &hSearch);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(g_Glob.GetFileCache(), hSearch);

    //
    // Prepare a buffer for file path
    //

    CFileName wszFullFileName;
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszFullFileName, wszReferenceDir);
    wcscat(wszFullFileName, L"\\");
    long lDirLen = wcslen(wszFullFileName);

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    CFileName wszReferrerFileName;
	if (wszReferrerFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    wcscpy(wszReferrerFileName, g_Glob.GetRootDir());

    do
    {
        if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            continue;

        wcscpy(wszFullFileName+lDirLen, fd.cFileName);

        LPWSTR wszReferrerClass = NULL;
        LPWSTR wszReferrerProp = NULL;
        LPWSTR wszReferrerNamespace = NULL;
        hres = GetReferrerFromFile(wszFullFileName, 
                        wszReferrerFileName + g_Glob.GetRootDirLen(), 
                        &wszReferrerNamespace, 
                        &wszReferrerClass, &wszReferrerProp);
        if(FAILED(hres))
            continue;
        CVectorDeleteMe<WCHAR> vdm1(wszReferrerClass);
        CVectorDeleteMe<WCHAR> vdm2(wszReferrerProp);
        CVectorDeleteMe<WCHAR> vdm3(wszReferrerNamespace);

        //
        // Check if the namespace of the referring object is the same as ours
        //

        CNamespaceHandle* pReferrerHandle = NULL;
        if(wbem_wcsicmp(wszReferrerNamespace, m_wsNamespace))
        {
            //
            // Open the other namespace
            //

            hres = m_pRepository->GetNamespaceHandle(wszReferrerNamespace,
                                    &pReferrerHandle);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_WBEMCORE, "Unable to open referring namespace "
                    "'%S' in namespace '%S'\n", wszReferrerNamespace,
                    (LPCWSTR)m_wsNamespace));
                hresGlobal = hres;
                continue;
            }
        }
        else
        {
            pReferrerHandle = this;
            pReferrerHandle->AddRef();
        }

        CReleaseMe rm1(pReferrerHandle);


        _IWmiObject* pInstance = NULL;
        hres = pReferrerHandle->FileToInstance(wszReferrerFileName, &pInstance);
        if(FAILED(hres))
        {
            // Oh well --- continue;
            hresGlobal = hres;
        }
        else
        {
            CReleaseMe rm1(pInstance);
            hres = pSink->Indicate(1, (IWbemClassObject**)&pInstance);
            if(FAILED(hres))
                return hres;
        }
    }
    while(g_Glob.GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return hresGlobal;
}

CHR CNamespaceHandle::GetReferrerFromFile(LPCWSTR wszReferenceFile,
                            LPWSTR wszReferrerRelFile, 
                            LPWSTR* pwszReferrerNamespace,
                            LPWSTR* pwszReferrerClass,
                            LPWSTR* pwszReferrerProp)
{
    //
    // Get the entire buffer from the file
    //

    BYTE* pBuffer = NULL;
    DWORD dwBufferLen = 0;
    long lRes = g_Glob.GetFileCache()->ReadFile(wszReferenceFile, &dwBufferLen,
                                            &pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    CTempFreeMe tfm(pBuffer, dwBufferLen);

    if(dwBufferLen == 0)
        return WBEM_E_OUT_OF_MEMORY;

    BYTE* pCurrent = pBuffer;
    DWORD dwStringLen;

    //
    // Get the referrer namespace
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerNamespace = new WCHAR[dwStringLen+1];
	if (*pwszReferrerNamespace == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerNamespace)[dwStringLen] = 0;
    memcpy(*pwszReferrerNamespace, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;
    
    //
    // Get the referrer class name
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerClass = new WCHAR[dwStringLen+1];
	if (*pwszReferrerClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    (*pwszReferrerClass)[dwStringLen] = 0;
    memcpy(*pwszReferrerClass, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get the referrer property
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);
    
    *pwszReferrerProp = new WCHAR[dwStringLen+1];
	if (*pwszReferrerProp == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    (*pwszReferrerProp)[dwStringLen] = 0;
    memcpy(*pwszReferrerProp, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    //
    // Get referrer file path
    //

    memcpy(&dwStringLen, pCurrent, sizeof(DWORD));
    pCurrent += sizeof(DWORD);

    wszReferrerRelFile[dwStringLen] = 0;
    memcpy(wszReferrerRelFile, pCurrent, dwStringLen*sizeof(WCHAR));
    pCurrent += sizeof(WCHAR)*dwStringLen;

    return S_OK;
}
    

CHR CNamespaceHandle::ExecClassRefQuery(LPCWSTR wszQuery, 
                                                LPCWSTR wszClassName,
                                                IWbemObjectSink* pSink)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
    HRESULT hres;

	//Execute against system class namespace first
	if (g_pSystemClassNamespace && (wcscmp(m_wsNamespace, A51_SYSTEMCLASS_NS) != 0))
	{
		hres = g_pSystemClassNamespace->ExecClassRefQuery(wszQuery, wszClassName, pSink);
		if (FAILED(hres))
			return hres;
	}
			
	//
    // Find the class's ref dir.
    //

    CFileName wszReferenceDir;
	if (wszReferenceDir == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    hres = ConstructClassRelationshipsDir(wszClassName, wszReferenceDir);

    CFileName wszReferenceMask;
	if (wszReferenceMask == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    wcscpy(wszReferenceMask, wszReferenceDir);
    wcscat(wszReferenceMask, L"\\" A51_REF_FILE_PREFIX);

    // 
    // Enumerate all files in it
    //

    WIN32_FIND_DATAW fd;
    void* hSearch;
    long lRes = g_Glob.GetFileCache()->FindFirst(wszReferenceMask, &fd, &hSearch);
    if(lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_PATH_NOT_FOUND)
    {
        //
        // No files in dir --- no problem
        //
        return WBEM_S_NO_ERROR;
    }
    else if(lRes != ERROR_SUCCESS)
    {
        return WBEM_E_FAILED;
    }

    CFileCache::CFindCloseMe fcm(g_Glob.GetFileCache(), hSearch);

    do
    {
        //  
        // Extract the class hash from the name of the file
        //

        LPCWSTR wszReferrerHash = fd.cFileName + wcslen(A51_REF_FILE_PREFIX);
        
        //
        // Get the class from that hash
        //

        _IWmiObject* pClass = NULL;
        hres = GetClassByHash(wszReferrerHash, true, &pClass, NULL, NULL, NULL);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
                continue;
            else
                return hres;
        }

        CReleaseMe rm1(pClass);
        hres = pSink->Indicate(1, (IWbemClassObject**)&pClass);
        if(FAILED(hres))
            return hres;
    }
    while(g_Glob.GetFileCache()->FindNext(hSearch, &fd) == ERROR_SUCCESS);

    return S_OK;
}

bool CNamespaceHandle::Hash(LPCWSTR wszName, LPWSTR wszHash)
{
    return A51Hash(wszName, wszHash);
}

CHR CNamespaceHandle::InstanceToFile(IWbemClassObject* pInst, 
                            LPCWSTR wszClassName, LPCWSTR wszFileName,
                            __int64 nClassTime)
{
    HRESULT hres;

    //
    // Allocate enough space for the buffer
    //

    _IWmiObject* pInstEx;
    pInst->QueryInterface(IID__IWmiObject, (void**)&pInstEx);
    CReleaseMe rm1(pInstEx);

    DWORD dwInstancePartLen = 0;
    hres = pInstEx->Unmerge(0, 0, &dwInstancePartLen, NULL);

    //
    // Add enough room for the class hash
    //

    DWORD dwClassHashLen = MAX_HASH_LEN * sizeof(WCHAR);
    DWORD dwTotalLen = dwInstancePartLen + dwClassHashLen + sizeof(__int64)*2;

    BYTE* pBuffer = (BYTE*)TempAlloc(dwTotalLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwTotalLen);

    //
    // Write the class hash
    //

    if(!Hash(wszClassName, (LPWSTR)pBuffer))
        return WBEM_E_OUT_OF_MEMORY;

    memcpy(pBuffer + dwClassHashLen, &g_nCurrentTime, sizeof(__int64));
    g_nCurrentTime++;

    memcpy(pBuffer + dwClassHashLen + sizeof(__int64), &nClassTime, 
            sizeof(__int64));

    //
    // Unmerge the instance into a buffer
    // 

    DWORD dwLen;
    hres = pInstEx->Unmerge(0, dwInstancePartLen, &dwLen, 
                            pBuffer + dwClassHashLen + sizeof(__int64)*2);
    if(FAILED(hres))
        return hres;

    //
    // Write to the file only as much as we have actually used!
    //

    long lRes = g_Glob.GetFileCache()->WriteFile(wszFileName, 
                    dwClassHashLen + sizeof(__int64)*2 + dwLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;
    
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ClassToFile(_IWmiObject* pParentClass, 
                _IWmiObject* pClass, LPCWSTR wszFileName, 
                __int64 nFakeUpdateTime)
{
    HRESULT hres;

    //
    // Get superclass name
    //

    VARIANT vSuper;
    hres = pClass->Get(L"__SUPERCLASS", 0, &vSuper, NULL, NULL);
    if(FAILED(hres))
        return hres;

    CClearMe cm1(&vSuper);

    LPCWSTR wszSuper;
    if(V_VT(&vSuper) == VT_BSTR)
        wszSuper = V_BSTR(&vSuper);
    else
        wszSuper = L"";

    VARIANT vClassName;
    hres = pClass->Get(L"__CLASS", 0, &vClassName, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm2(&vClassName);

    LPCWSTR wszClassName;
    if(V_VT(&vClassName) == VT_BSTR)
        wszClassName = V_BSTR(&vClassName);
    else
        wszClassName = L"";

    //
    // Get unmerge length
    //

    DWORD dwUnmergedLen = 0;
    hres = pClass->Unmerge(0, 0, &dwUnmergedLen, NULL);

    //
    // Add enough space for the parent class name and the timestamp
    //

    DWORD dwSuperLen = sizeof(DWORD) + wcslen(wszSuper)*sizeof(WCHAR);

    DWORD dwLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    BYTE* pBuffer = (BYTE*)TempAlloc(dwLen);
	if (pBuffer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(pBuffer, dwLen);

    //
    // Write superclass name
    //

    DWORD dwActualSuperLen = wcslen(wszSuper);
    memcpy(pBuffer, &dwActualSuperLen, sizeof(DWORD));
    memcpy(pBuffer + sizeof(DWORD), wszSuper, wcslen(wszSuper)*sizeof(WCHAR));

    //
    // Write the timestamp
    //

    if(nFakeUpdateTime == 0)
    {
        nFakeUpdateTime = g_nCurrentTime;
        g_nCurrentTime++;
    }

    memcpy(pBuffer + dwSuperLen, &nFakeUpdateTime, sizeof(__int64));

    //
    // Write the unmerged portion
    //

    BYTE* pUnmergedPortion = pBuffer + dwSuperLen + sizeof(__int64);
    hres = pClass->Unmerge(0, dwUnmergedLen, &dwUnmergedLen, 
                            pUnmergedPortion);
    if(FAILED(hres))
        return hres;

    //
    // Stash away the real length
    //

    DWORD dwFileLen = dwUnmergedLen + dwSuperLen + sizeof(__int64);

    long lRes = g_Glob.GetFileCache()->WriteFile(wszFileName, dwFileLen, pBuffer);
    if(lRes != ERROR_SUCCESS)
        return WBEM_E_FAILED;

    //
    // To properly cache the new class definition, first invalidate it
    //

    hres = m_pClassCache->InvalidateClass(wszClassName);
    if(FAILED(hres))
        return hres;

    //
    // Now, remerge the unmerged portion back in
    //

    if(pParentClass == NULL)
    {
        //
        // Get the empty class
        //

        hres = GetClassDirect(NULL, IID__IWmiObject, (void**)&pParentClass, 
                                false, NULL, NULL, NULL);
        if(FAILED(hres))
            return hres;
    }
    else
        pParentClass->AddRef();
    CReleaseMe rm0(pParentClass);

    _IWmiObject* pNewObj;
    hres = pParentClass->Merge(0, dwUnmergedLen, pUnmergedPortion, &pNewObj);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pNewObj);

    hres = pNewObj->SetDecoration(m_wszMachineName, m_wsNamespace);
    if(FAILED(hres))
        return hres;

    hres = m_pClassCache->AssertClass(pNewObj, wszClassName, false, 
                                        nFakeUpdateTime, false); 
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}


CHR CNamespaceHandle::ConstructInstanceDefName(LPWSTR wszInstanceDefName,
                                                    LPCWSTR wszKey)
{
    wcscpy(wszInstanceDefName, A51_INSTDEF_FILE_PREFIX);
    if(!Hash(wszKey, wszInstanceDefName + wcslen(A51_INSTDEF_FILE_PREFIX)))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ConstructInstDefNameFromLinkName(
                                                    LPWSTR wszInstanceDefName,
                                                    LPCWSTR wszInstanceLinkName)
{
    wcscpy(wszInstanceDefName, A51_INSTDEF_FILE_PREFIX);
    wcscat(wszInstanceDefName, 
        wszInstanceLinkName + wcslen(A51_INSTLINK_FILE_PREFIX));
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ConstructClassDefFileName(LPCWSTR wszClassName, 
                                            LPWSTR wszFileName)
{
    wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
    if(!Hash(wszClassName, wszFileName+wcslen(A51_CLASSDEF_FILE_PREFIX)))
        return WBEM_E_INVALID_OBJECT;
    return WBEM_S_NO_ERROR;
}

CHR CNamespaceHandle::ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            LPWSTR wszFileName)
{
    wcscpy(wszFileName, A51_CLASSDEF_FILE_PREFIX);
    wcscat(wszFileName, wszHash);
    return WBEM_S_NO_ERROR;
}

//=============================================================================
//
// CNamespaceHandle::CreateSystemClasses
//
// We are in a pseudo namespace.  We need to determine if we already have
// the system classes in this namespace.  The system classes that we create
// are those that exist in all namespaces, and no others.  If they do not exist
// we create them.
// The whole creation process happens within the confines of a transaction
// that we create and own within this method.
//
//=============================================================================
HRESULT CNamespaceHandle::CreateSystemClasses(CFlexArray &aSystemClasses)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	//Now we need to determine if the system classes already exist.  Lets do this by looking for the __thisnamespace
	//class!
	_IWmiObject *pObj = NULL;
	hRes = GetClassDirect(L"__thisnamespace", IID__IWmiObject, (void**)&pObj, false, NULL, NULL, NULL);
	if (SUCCEEDED(hRes))
	{
		//All done!  They already exist!
		pObj->Release();
		return WBEM_S_NO_ERROR;
	}
	else if (hRes != WBEM_E_NOT_FOUND)
	{
		//Something went bad, so we just fail!
		return hRes;
	}

	//There are no system classes so we need to create them.
    hRes = g_Glob.GetFileCache()->BeginTransaction();
    if(hRes != ERROR_SUCCESS)
        hRes = A51TranslateErrorCode(hRes);
	
	CEventCollector eventCollector;
    _IWmiObject *Objects[256];
    _IWmiObject **ppObjects = NULL;
    ULONG uSize = 256;
	
	if (SUCCEEDED(hRes) && aSystemClasses.Size())
	{
		//If we have a system-class array we need to use that instead of using the ones retrieved from the core
		//not doing so will cause a mismatch.  We retrieved these as part of the upgrade process...
		uSize = aSystemClasses.Size();
		ppObjects = (_IWmiObject**)&aSystemClasses[0];
	}
	else if (SUCCEEDED(hRes))
	{
		//None retrieved from upgrade process so we must be a clean install.  Therefore we should 
		//get the list from the core...
        _IWmiCoreServices * pSvcs = g_Glob.GetCoreSvcs();
        CReleaseMe rm(pSvcs);		
		hRes = pSvcs->GetSystemObjects(GET_SYSTEM_STD_OBJECTS, &uSize, Objects);
		ppObjects = Objects;
	}
    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = ppObjects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS, 0, 0, eventCollector);
                    pObj->Release();
					if (FAILED(hRes))
					{
				        ERRORTRACE((LOG_WBEMCORE, "Creation of system class failed during repository creation <0x%X>!\n", hRes));
					}
                }
            }
            ppObjects[i]->Release();
        }
    }

	//Clear out the array that was sent to us.
	aSystemClasses.Empty();

    if (FAILED(hRes))
    {
        g_Glob.GetFileCache()->AbortTransaction();
    }
    else
    {
        hRes = g_Glob.GetFileCache()->CommitTransaction();
        if(hRes != ERROR_SUCCESS)
        {
            hRes = A51TranslateErrorCode(hRes);
            g_Glob.GetFileCache()->AbortTransaction();
        }
	}
	return hRes;
}

class CSystemClassDeletionSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
	CWStringArray &m_aChildNamespaces;
public:
	CSystemClassDeletionSink(CWStringArray &aChildNamespaces) 
		: m_aChildNamespaces(aChildNamespaces) 
	{
	}
	~CSystemClassDeletionSink() 
	{
	}
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
	{
		HRESULT hRes;
		for (int i = 0; i != lNumObjects; i++)
		{
			if (apObjects[i] != NULL)
			{
				_IWmiObject *pInst = NULL;
				hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
				if (FAILED(hRes))
					return hRes;
				CReleaseMe rm(pInst);

				BSTR strKey = NULL;
				hRes = pInst->GetKeyString(0, &strKey);
				if(FAILED(hRes))
					return hRes;
				CSysFreeMe sfm(strKey);
				if (m_aChildNamespaces.Add(strKey) != CWStringArray::no_error)
					return WBEM_E_OUT_OF_MEMORY;
			}
		}

		return WBEM_S_NO_ERROR;
	}
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*) 
	{ 
		return WBEM_S_NO_ERROR; 
	}

};
//=============================================================================
//
// CNamespaceHandle::RecursiveDeleteSystemClasses
//
// Delete the system class representation object from this namespace, then 
// recurse through all sub-namespaces and do the same.  It is expected that 
// we already have a lock, and if anything fails we return and error, and 
// the caller fails the owning transaction.
//
//=============================================================================
HRESULT CNamespaceHandle::RecursiveDeleteSystemClasses(CWStringArray &aSystemClasses, 
													   CWStringArray &aSystemClassesSuperclass)
{
    if (g_bShuttingDown)
        return WBEM_E_SHUTTING_DOWN;
        
	HRESULT hRes;

	// Query for all child namespaces so we delete classes in them first...
	CWStringArray aChildNamespaces;
	CSystemClassDeletionSink *pSink = new CSystemClassDeletionSink(aChildNamespaces);
	if (pSink == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pSink->AddRef();
	CReleaseMe rm(pSink);
	hRes = ExecInstanceQuery(NULL, L"__namespace", true, pSink);
	if (FAILED(hRes))
		return hRes;

	//Now iterate through the list of namespaces... and do the deletion on them...
	for (int i = 0; i != aChildNamespaces.Size(); i++)
	{
		CNamespaceHandle *pNs = new CNamespaceHandle(m_pControl, m_pRepository);
		if (pNs == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CReleaseMe rm2(pNs);
		pNs->AddRef();
		int pNsPathLen = (wcslen(m_wsNamespace) + wcslen(aChildNamespaces[i]) + wcslen(L"\\") + 1) * sizeof(wchar_t);
		wchar_t *pNsPath = (wchar_t*)TempAlloc(pNsPathLen);
		if (pNsPath == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CTempFreeMe tfm(pNsPath, pNsPathLen);
		wcscpy(pNsPath, m_wsNamespace);
		wcscat(pNsPath, L"\\");
		wcscat(pNsPath, aChildNamespaces[i]);
		pNs->Initialize(pNsPath);

		hRes = pNs->RecursiveDeleteSystemClasses(aSystemClasses, aSystemClassesSuperclass);

		if (FAILED(hRes))
			return hRes;
	}

	//Now the children are done, loop through each of the system classes to 
	//delete them from this one...
	//----------------------------------------------------------------------
	for (i = 0; i != aSystemClasses.Size(); i++)
	{
		//Construct class filename
		//------------------------
		CFileName wszFileName;
		if (wszFileName == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		hRes = ConstructClassDefFileName(aSystemClasses[i], wszFileName);
		if(FAILED(hRes))
			return hRes;

		//Construct the full path and filename of the class
		//-------------------------------------------------
		CFileName wszFilePath;
		if (wszFilePath == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		swprintf(wszFilePath, L"%s\\%s", m_wszClassRootDir, wszFileName);

		//Need to delete our parent/child class relationship...
		//--------------------------------------------------------
		EraseParentChildRelationship(wszFileName, aSystemClassesSuperclass[i]);

		//Next we need to delete our representation object
		//------------------------------------------------
		hRes = g_Glob.GetFileCache()->DeleteFile(wszFilePath);
		if(hRes == ERROR_FILE_NOT_FOUND || hRes == ERROR_PATH_NOT_FOUND)
			hRes = WBEM_S_NO_ERROR;
		else if(hRes != ERROR_SUCCESS)
			return WBEM_E_FAILED;
	
		m_pClassCache->InvalidateClass(aSystemClasses[i]);
	}

	return WBEM_S_NO_ERROR;
}

//=============================================================================
//=============================================================================
CDbIterator::CDbIterator(CLifeControl* pControl, bool bUseLock)
        : TUnkBase(pControl), m_lCurrentIndex(0), m_hresStatus(WBEM_S_FALSE),
            m_pMainFiber(NULL), m_pExecFiber(NULL), m_dwNumRequested(0),
            m_pExecReq(NULL), m_hresCancellationStatus(WBEM_S_NO_ERROR),
            m_bExecFiberRunning(false), m_bUseLock(bUseLock)
{
}

CDbIterator::~CDbIterator()
{
#ifdef A51_USE_FIBER
    if(m_pExecFiber)
        Cancel(0);
#endif
    if(m_pExecReq)
        delete m_pExecReq;
}

void CDbIterator::SetExecFiber(void* pFiber, CFiberTask* pReq)
{
    m_pExecFiber = pFiber;
    m_pExecReq = pReq;
}

STDMETHODIMP CDbIterator::Cancel(DWORD dwFlags)
{
    CInCritSec ics(&m_cs);

    m_qObjects.Clear();
#ifdef A51_USE_FIBER

    //
    // Mark the iterator as cancelled and allow the execution fiber to resume
    // and complete --- that guarantees that any memory it allocated will be
    // cleaned up.  The exception to this rule is if the fiber has not started
    // execution yet; in that case, we do not want to switch to it, as it would
    // have to run until the first Indicate to find out that it's been
    // cancelled.  (In the normal case, the execution fiber is suspended    
    // inside Indicate, so when we switch back we will immediately give it
    // WBEM_E_CALL_CANCELLED so that it can clean up and return)
    //

    m_hresCancellationStatus = WBEM_E_CALL_CANCELLED;

    if(m_pExecFiber)
    {
        if(m_bExecFiberRunning)
        {
            _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, 
                    L"Fiber trouble");

            //
            // Make sure the calling thread has a fiber
            //

            m_pMainFiber = CreateOrGetCurrentFiber();
            if(m_pMainFiber == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            SwitchToFiber(m_pExecFiber);
        }
        
        // 
        // At this point, the executing fiber is dead.  We know, because in the
        // cancelled state we do not switch to the main fiber in Indicate. 
        //

        ReturnFiber(m_pExecFiber);
        m_pExecFiber = NULL;
    }

#endif
    return S_OK;
}

STDMETHODIMP CDbIterator::NextBatch(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     )
{
    CInCritSec ics(&m_cs);

    //
    // TEMP CODE: Someone is calling us on an impersonated thread.  Let's catch
    // the, ahem, bastard
    //

    HANDLE hToken;
    BOOL bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        //_ASSERT(false, L"Called with a thread token");
        ERRORTRACE((LOG_WBEMCORE, "Repository called with a thread token! "
                        "It shall be removed\n"));
        CloseHandle(hToken);
        SetThreadToken(NULL, NULL);
    }

    _ASSERT(SUCCEEDED(m_hresCancellationStatus), L"Next called after Cancel");
    

#ifdef A51_USE_FIBER

    m_bExecFiberRunning = true;

    //
    // Wait until it's over or the right number of objects has been received
    //

    if(m_qObjects.GetQueueSize() < dwNumRequested)
    {
        _ASSERT(m_pMainFiber == NULL && m_pExecFiber != NULL, L"Fiber trouble");

        //
        // Make sure the calling thread has a fiber
        //

        m_pMainFiber = CreateOrGetCurrentFiber();
        if(m_pMainFiber == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        m_dwNumRequested = dwNumRequested;

        //
        // We need to acquire the read lock for the duration of the continuation
        // of the retrieval
        //

	    {
			CAutoReadLock lock(&g_readWriteLock, FALSE);

			if (m_bUseLock)
			{
				lock.Lock();
			}
            if (g_bShuttingDown)
            {
                m_pMainFiber = NULL;
                return WBEM_E_SHUTTING_DOWN;
            }

            SwitchToFiber(m_pExecFiber);
        }

        m_pMainFiber = NULL;
    }
#endif
    //
    // We have as much as we are going to have!
    //
    
    DWORD dwReqIndex = 0;
    while(dwReqIndex < dwNumRequested)
    {
        if(0 == m_qObjects.GetQueueSize())
        {
            //
            // That's it --- we waited for production, so there are simply no 
            // more objects in the enumeration
            //

            *pdwNumReturned = dwReqIndex;
            return m_hresStatus;
        }

        IWbemClassObject* pObj = m_qObjects.Dequeue();
        CReleaseMe rm1(pObj);
        pObj->QueryInterface(riid, ppObjects + dwReqIndex);

        dwReqIndex++;
    }

    //
    // Got everything
    //

    *pdwNumReturned= dwNumRequested;
    return S_OK;
}

HRESULT CDbIterator::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
#ifdef A51_USE_FIBER
    if(FAILED(m_hresCancellationStatus))
    {
        //
        // --- the fiber called back with Indicate even after we 
        // cancelled! Oh well.
        //
        
        _ASSERT(false, L"Execution code ignored cancel return code!");
        return m_hresCancellationStatus;
    }
#endif

    //
    // Add the objects received to the array
    //

    for(long i = 0; i < lNumObjects; i++)
    {
        m_qObjects.Enqueue(apObjects[i]);
    }

#ifdef A51_USE_FIBER
    //
    // Check if we have compiled enough for the current request and should
    // therefore interrupt the gatherer
    //

    if(m_qObjects.GetQueueSize() >= m_dwNumRequested)
    {
        //
        // Switch us back to the original fiber
        //

        SwitchToFiber(m_pMainFiber);
    }
#endif

    return m_hresCancellationStatus;
}

HRESULT CDbIterator::SetStatus(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*)
{
    _ASSERT(m_hresStatus == WBEM_S_FALSE, L"SetStatus called twice!");
    _ASSERT(lFlags == WBEM_STATUS_COMPLETE, L"SetStatus flags invalid");

    m_hresStatus = hresResult;

#ifdef A51_USE_FIBER
    //
    // Switch us back to the original thread, we are done
    //

    m_bExecFiberRunning = false;
    SwitchToFiber(m_pMainFiber);
#endif

    return WBEM_S_NO_ERROR;
}



    
            


CRepEvent::CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
            _IWmiObject* pObj1, _IWmiObject* pObj2)
{
    m_dwType = dwType;
    m_pObj1 = 0;
    m_pObj2 = 0;
    m_wszArg1 = m_wszNamespace = NULL;

    if (wszArg1)
    {
        m_wszArg1 = (WCHAR*)TempAlloc((wcslen(wszArg1)+1)*sizeof(WCHAR));
        if (m_wszArg1 == NULL)
            throw CX_MemoryException();
        wcscpy(m_wszArg1, wszArg1);
    }

    if (wszNamespace)
    {
        m_wszNamespace = (WCHAR*)TempAlloc((wcslen(wszNamespace)+1)*sizeof(WCHAR));
        if (m_wszNamespace == NULL)
            throw CX_MemoryException();
        wcscpy(m_wszNamespace, wszNamespace);
    }
    if (pObj1)
    {
        m_pObj1 = pObj1;
        pObj1->AddRef();
    }
    if (pObj2)
    {
        m_pObj2 = pObj2;
        pObj2->AddRef();
    }
}

CRepEvent::~CRepEvent()
{
    TempFree(m_wszArg1, (wcslen(m_wszArg1)+1)*sizeof(WCHAR));
    TempFree(m_wszNamespace, (wcslen(m_wszNamespace)+1)*sizeof(WCHAR));
    if (m_pObj1)
        m_pObj1->Release();
    if (m_pObj2)
        m_pObj2->Release();
};

HRESULT CEventCollector::SendEvents(_IWmiCoreServices* pCore)
{
	HRESULT hresGlobal = WBEM_S_NO_ERROR;
	for (int i = 0; i != m_apEvents.GetSize(); i++)
	{
		CRepEvent *pEvent = m_apEvents[i];

		_IWmiObject* apObjs[2];
		apObjs[0] = pEvent->m_pObj1;
		apObjs[1] = pEvent->m_pObj2;

		HRESULT hres = pCore->DeliverIntrinsicEvent(
				pEvent->m_wszNamespace, pEvent->m_dwType, NULL, 
                pEvent->m_wszArg1, NULL, (pEvent->m_pObj2?2:1), apObjs);
        if(FAILED(hres))
            hresGlobal = hres;
	}

    return hresGlobal;
}

bool CEventCollector::AddEvent(CRepEvent* pEvent)
{
    EnterCriticalSection(&m_csLock);

    if(m_bNamespaceOnly)
    {
        if(pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceCreation &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceDeletion &&
           pEvent->m_dwType != WBEM_EVENTTYPE_NamespaceModification)
        {
            delete pEvent;
            LeaveCriticalSection(&m_csLock);
            return true;
        }
    }

    bool bRet = (m_apEvents.Add(pEvent) >= 0);
    LeaveCriticalSection(&m_csLock);
    return bRet;
}

void CEventCollector::DeleteAllEvents()
{
    EnterCriticalSection(&m_csLock);
    m_bNamespaceOnly = false;
    m_apEvents.RemoveAll();
    LeaveCriticalSection(&m_csLock);
}

void CEventCollector::TransferEvents(CEventCollector &aEventsToTransfer)
{
    m_bNamespaceOnly = aEventsToTransfer.m_bNamespaceOnly;

	while(aEventsToTransfer.m_apEvents.GetSize())
	{
		CRepEvent *pEvent = 0;
        aEventsToTransfer.m_apEvents.RemoveAt(0, &pEvent);

        m_apEvents.Add(pEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51rep.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#ifndef __A51PROV__H_
#define __A51PROV__H_

#include <windows.h>
#include <wbemidl.h>
#include <unk.h>
#include <wbemcomn.h>
#include <sync.h>
#include <reposit.h>
#include <wmiutils.h>
#include <objpath.h>
#include <filecach.h>
#include <hiecache.h>
#include <corex.h>
#include "a51fib.h"
#include "creposit.h"

class CDbIterator;
class CRepEvent
{
public:
	DWORD m_dwType;
	LPWSTR m_wszArg1;
    LPWSTR m_wszNamespace;
	_IWmiObject* m_pObj1;
	_IWmiObject* m_pObj2;

	CRepEvent(DWORD dwType, LPCWSTR wszNamespace, LPCWSTR wszArg1, 
                _IWmiObject* pObj1, _IWmiObject* pObj2);
	~CRepEvent();

    void* operator new(size_t) {return TempAlloc(sizeof(CRepEvent));}
    void operator delete(void* p) {return TempFree(p, sizeof(CRepEvent));}
};

class CEventCollector
{
protected:
    CUniquePointerArray<CRepEvent> m_apEvents;
    bool m_bNamespaceOnly;
    CRITICAL_SECTION m_csLock;

public:
    CEventCollector() : m_bNamespaceOnly(false){ InitializeCriticalSection(&m_csLock);}
    ~CEventCollector() { DeleteCriticalSection(&m_csLock); }
    bool AddEvent(CRepEvent* pEvent);
    void SetNamespaceOnly(bool bNamespaceOnly) 
        {m_bNamespaceOnly = bNamespaceOnly;}
    bool IsNamespaceOnly() {return m_bNamespaceOnly;}

    HRESULT SendEvents(_IWmiCoreServices* pCore);

    void DeleteAllEvents();

    void TransferEvents(CEventCollector &aEventsToTransfer);

    int GetSize() { return m_apEvents.GetSize(); }
};
    


class CSession : public CUnkBase<IWmiDbSessionEx, &IID_IWmiDbSessionEx>
{
private:
    CEventCollector m_aTransactedEvents;
    bool m_bInWriteTransaction;

public:
    CSession(CLifeControl* pControl = NULL) : TUnkBase(pControl), m_bInWriteTransaction(false) {}

    virtual ~CSession();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE GetObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE GetObjectDirect(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    HRESULT STDMETHODCALLTYPE PutObject(
         IWmiDbHandle *pScope,
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE DeleteObject(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj
        );

    HRESULT STDMETHODCALLTYPE ExecQuery(
         IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );
    HRESULT STDMETHODCALLTYPE RenameObject(
         IWbemPath *pOldPath,
         IWbemPath *pNewPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE Enumerate(
         IWmiDbHandle *pScope,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbIterator **ppQueryResult
        );

    HRESULT STDMETHODCALLTYPE AddObject(
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    HRESULT STDMETHODCALLTYPE RemoveObject (
         IWmiDbHandle *pScope,
         IWbemPath *pPath,
         DWORD dwFlags
        );

    HRESULT STDMETHODCALLTYPE SetDecoration(
         LPWSTR lpMachineName,
         LPWSTR lpNamespacePath
        );

    HRESULT STDMETHODCALLTYPE SupportsQueries( 
         DWORD *dwQuerySupportLevel
         ) {return WBEM_E_FAILED;};

    HRESULT STDMETHODCALLTYPE GetObjectByPath(
         IWmiDbHandle *pScope,
         LPCWSTR wszPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

	HRESULT STDMETHODCALLTYPE DeleteObjectByPath(
		IWmiDbHandle *pScope,
		LPCWSTR wszObjectPath,
		DWORD dwFlags
    );

    HRESULT STDMETHODCALLTYPE ExecQuerySink(
		IWmiDbHandle *pScope,
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

	HRESULT STDMETHODCALLTYPE BeginWriteTransaction(DWORD dwFlags);

    HRESULT STDMETHODCALLTYPE BeginReadTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE CommitTransaction(DWORD dwFlags);

	HRESULT STDMETHODCALLTYPE AbortTransaction(DWORD dwFlags);
protected:
};

class CNamespaceHandle : public CUnkBase<IWmiDbHandle, &IID_IWmiDbHandle>
{
protected:

    static long s_lActiveRepNs;

    CRepository * m_pRepository;
    WString m_wsNamespace;
    WString m_wsScope;
    WString m_wsFullNamespace;
    WCHAR m_wszMachineName[MAX_COMPUTERNAME_LENGTH+1];

    WCHAR m_wszClassRootDir[MAX_PATH];
    long m_lClassRootDirLen;

    WCHAR m_wszInstanceRootDir[MAX_PATH];
    long m_lInstanceRootDirLen;

    CHierarchyCache* m_pClassCache;
    CForestCache* m_ForestCache;

    _IWmiObject* m_pNullClass;
    bool m_bCached;

	bool m_bUseIteratorLock;

public:
    CNamespaceHandle(CLifeControl* pControl, CRepository * pRepository);
    ~CNamespaceHandle();
    

    STDMETHOD(GetHandleType)(DWORD* pdwType) {*pdwType = 0; return S_OK;}

    CHR Initialize(LPCWSTR wszNamespace, LPCWSTR wszScope = NULL);

    CHR GetObject(
         IWbemPath *pPath,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult
        );

    CHR GetObjectDirect(
         IWbemPath *pPath,
         DWORD dwFlags,
         REFIID riid,
        LPVOID *pObj
        );

    CHR PutObject(
         REFIID riid,
        LPVOID pObj,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWmiDbHandle **ppResult,
		CEventCollector &aEvents
        );

    CHR DeleteObject(
         DWORD dwFlags,
         REFIID riid,
         LPVOID pObj,
		 CEventCollector &aEvents
        );

    CHR ExecQuery(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        DWORD *dwMessageFlags,
        IWmiDbIterator **ppQueryResult
        );

    CHR GetObjectByPath(
        LPWSTR wszPath,
        DWORD dwFlags,
        REFIID riid,
        LPVOID *pObj
       );

    CHR ExecQuerySink(
         IWbemQuery *pQuery,
         DWORD dwFlags,
         DWORD dwRequestedHandleType,
        IWbemObjectSink* pSink,
        DWORD *dwMessageFlags
        );

	CHR DeleteObjectByPath(DWORD dwFlags, LPWSTR wszPath, CEventCollector &aEvents);
	HRESULT SendEvents(CEventCollector &aEvents);
    CHR GetErrorStatus();
    void SetErrorStatus(HRESULT hres);

	HRESULT CreateSystemClasses(CFlexArray &aSystemClasses);

	HRESULT RecursiveDeleteSystemClasses(CWStringArray &aSystemClasses, CWStringArray &aSystemClassesSuperclass);

	void TellIteratorNotToLock() { m_bUseIteratorLock = false; }

protected:
    CHR GetObjectHandleByPath(LPWSTR wszBuffer, DWORD dwFlags,
            DWORD dwRequestedHandleType, IWmiDbHandle **ppResult);
    CHR PutInstance(_IWmiObject* pInst, DWORD dwFlags, CEventCollector &aEvents);
    CHR PutClass(_IWmiObject* pClass, DWORD dwFlags, CEventCollector &aEvents);
    CHR ConstructClassRelationshipsDir(LPCWSTR wszClassName,
                                LPWSTR wszDirPath);
    CHR WriteParentChildRelationship(LPCWSTR wszChildFileName, 
                                LPCWSTR wszParentName);
    CHR WriteClassReferences(_IWmiObject* pClass, LPCWSTR wszFileName);
    CHR ExecClassQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                            IWbemObjectSink* pSink, DWORD dwFlags);
    CHR ExecInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 

                                LPCWSTR wszClassName, bool bDeep,
                                IWbemObjectSink* pSink);
    CHR GetClassDirect(LPCWSTR wszClassName, REFIID riid, void** ppObj,
                            bool bClone, __int64* pnTime,
                            bool* pbRead, bool *pbSystemClass);
    CHR GetInstanceDirect(ParsedObjectPath* pPath,
                                REFIID riid, void** ppObj);
	CHR DeleteInstance(LPCWSTR wszClassName, LPCWSTR wszKey, CEventCollector &aEvents);
	CHR DeleteInstanceByFile(LPCWSTR wszFilePath, _IWmiObject* pClass, 
                            bool bClassDeletion, CEventCollector &aEvents);
	CHR DeleteClass(LPCWSTR wszClassName, CEventCollector &aEvents);
	CHR DeleteClassInstances(LPCWSTR wszClassName, _IWmiObject* pClass, CEventCollector &aEvents);
    CHR FileToSystemClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime = NULL);
    CHR FileToClass(LPCWSTR wszFileName, _IWmiObject** ppClass, 
                            bool bClone, __int64* pnTime, 
							bool *pbSystemClass);
    CHR FileToInstance(LPCWSTR wszFileName, _IWmiObject** ppInstance,
                            bool bMustBeThere = false);
    CHR WriteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszClassName,
                                    LPCWSTR wszFilePath);
    CHR WriteInstanceReference(LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringClass,
                            LPCWSTR wszReferringProp, LPWSTR wszReference);
    CHR CalculateInstanceFileBase(LPCWSTR wszInstancePath, 
                            LPWSTR wszFilePath);
    CHR ExecClassRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                                    IWbemObjectSink* pSink);
    CHR ExecReferencesQuery(LPCWSTR wszQuery, IWbemObjectSink* pSink);
    CHR ExecInstanceRefQuery(LPCWSTR wszQuery, LPCWSTR wszClassName,
                                    LPCWSTR wszKey, IWbemObjectSink* pSink);
    CHR GetReferrerFromFile(LPCWSTR wszReferenceFile,
                                LPWSTR wszReferrerRelFile, 
                                LPWSTR* pwszReferrerNamespace,
                                LPWSTR* pwszReferrerClass,
                                LPWSTR* pwszReferrerProp);
    CHR DeleteInstanceReference(LPCWSTR wszOurFilePath,
                                            LPWSTR wszReference);
    CHR DeleteInstanceReferences(_IWmiObject* pInst, LPCWSTR wszFilePath);

    CHR EnumerateClasses(IWbemObjectSink* pSink,
                                LPCWSTR wszSuperClass, LPCWSTR wszAncestor,
                                bool bClone, bool bDontIncludeAncestorInResultSet);
    CHR ListToEnum(CWStringArray& wsClasses, 
                                        IWbemObjectSink* pSink, bool bClone);

    bool Hash(LPCWSTR wszName, LPWSTR wszHash);
    CHR InstanceToFile(IWbemClassObject* pInst, LPCWSTR wszClassName,
                            LPCWSTR wszFileName, __int64 nClassTime);
    CHR ConstructInstanceDefName(LPWSTR wszInstanceDefName, LPCWSTR wszKey);
    CHR ClassToFile(_IWmiObject* pSuperClass, _IWmiObject* pClass, 
                        LPCWSTR wszFileName, __int64 nFakeUpdateTime = 0);
    CHR ConstructClassName(LPCWSTR wszClassName, 
                                            LPWSTR wszFileName);
    CHR TryGetShortcut(LPWSTR wszPath, DWORD dwFlags, REFIID riid,
                            LPVOID *pObj);
    CHR ComputeKeyFromPath(LPWSTR wszPath, LPWSTR wszKey, 
                                LPWSTR* pwszClassName, bool* pbIsClass,
                                LPWSTR* pwszNamespace = NULL);
    CHR ParseKey(LPWSTR wszKeyStart, LPWSTR* pwcRealStart,
                                    LPWSTR* pwcNextKey);

    CHR GetInstanceByKey(LPCWSTR wszClassName, LPCWSTR wszKey,
                                REFIID riid, void** ppObj);
    CHR WriteClassRelationships(_IWmiObject* pClass, LPCWSTR wszFileName);
    CHR ConstructParentChildFileName(LPCWSTR wszChildFileName, 
                                    LPCWSTR wszParentName,
                                    LPWSTR wszParentChildFileName);
    CHR DeleteDerivedClasses(LPCWSTR wszClassName, CEventCollector &aEvents);
    CHR EraseParentChildRelationship(LPCWSTR wszChildFileName, 
                                        LPCWSTR wszParentName);
    CHR EraseClassRelationships(LPCWSTR wszClassName,
                                _IWmiObject* pClass, LPCWSTR wszFileName);
    CHR GetClassByHash(LPCWSTR wszHash, bool bClone, _IWmiObject** ppClass,
                            __int64* pnTime, bool* pbRead,
							bool *pbSystemClass);
    CHR DeleteClassByHash(LPCWSTR wszHash, CEventCollector &aEvents);
    CHR DeleteClassInternal(LPCWSTR wszClassName, _IWmiObject* pClass,
                                LPCWSTR wszFileName, CEventCollector &aEvents,
								bool bSystemClass);
    CHR GetChildHashes(LPCWSTR wszClassName, CWStringArray& wsChildHashes);
    CHR GetChildDefs(LPCWSTR wszClassName, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    CHR ConstructClassDefFileName(LPCWSTR wszClassName, LPWSTR wszFileName);
    CHR ConstructClassDefFileNameFromHash(LPCWSTR wszHash, 
                                            LPWSTR wszFileName);
    CHR ConstructClassRelationshipsDirFromHash(LPCWSTR wszHash, 
                                        LPWSTR wszDirPath);
    CHR GetChildHashesByHash(LPCWSTR wszHash, CWStringArray& wsChildHashes);
    CHR GetChildDefsByHash(LPCWSTR wszHash, bool bRecursive,
                                    IWbemObjectSink* pSink, bool bClone);
    CHR FireEvent(CEventCollector &aEvents, DWORD dwType, LPCWSTR wszArg1, _IWmiObject* pObj1, 
                                    _IWmiObject* pObj2 = NULL);
    CHR DeleteSelf(CEventCollector &aEvents);
    CHR DeleteInstanceAsScope(_IWmiObject* pInst, CEventCollector &aEvents);
    CHR DeleteInstanceSelf(LPCWSTR wszFilePath, _IWmiObject* pInst,
                                bool bClassDeletion);
    CHR ConstructReferenceDir(LPWSTR wszTargetPath, LPWSTR wszDir);
    CHR ConstructReferenceDirFromKey(LPCWSTR wszClassName,
                                LPCWSTR wszKey, LPWSTR wszReferenceDir);
    CHR ConstructReferenceFileName(LPWSTR wszReference,
                        LPCWSTR wszReferringFile, LPWSTR wszReferenceFile);
    CHR ConstructKeyRootDirFromClass(LPWSTR wszDir, LPCWSTR wszClassName);
    CHR ConstructKeyRootDirFromKeyRoot(LPWSTR wszDir, 
                                                    LPCWSTR wszKeyRootClass);
    CHR ConstructLinkDirFromClass(LPWSTR wszDir, LPCWSTR wszClassName);
    CHR WriteInstanceLinkByHash(LPCWSTR wszClassName,
                                                LPCWSTR wszInstanceHash);
    CHR DeleteInstanceLink(_IWmiObject* pInst, 
                                LPCWSTR wszInstanceDefFilePath);
    CHR GetKeyRoot(LPCWSTR wszClass, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    CHR ConstructInstDefNameFromLinkName(LPWSTR wszInstanceDefName,
                                             LPCWSTR wszInstanceLinkName);
    CHR ExecDeepInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash,
                                IWbemObjectSink* pSink);
    CHR ExecShallowInstanceQuery(QL_LEVEL_1_RPN_EXPRESSION* pQuery, 
                                LPCWSTR wszClassHash, 
                                IWbemObjectSink* pSink);
    CHR GetKeyRootByHash(LPCWSTR wszClassHash, 
                                     TEMPFREE_ME LPWSTR* pwszKeyRootClass);
    CHR ConstructKeyRootDirFromClassHash(LPWSTR wszDir,
                                            LPCWSTR wszClassHash);
    CHR ConstructLinkDirFromClassHash(LPWSTR wszDir, LPCWSTR wszClassHash);
    CHR ConstructClassReferenceFileName(LPCWSTR wszReferredToClass,
                                LPCWSTR wszReferringFile, 
                                LPCWSTR wszReferringProp,
                                LPWSTR wszFieName);
    CHR WriteClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    CHR EraseClassReference(_IWmiObject* pReferringClass,
                            LPCWSTR wszReferringFile,
                            LPCWSTR wszReferringProp);
    //CFileCache* GetFileCache();
	
	CHR CanClassBeUpdatedCompatible(DWORD dwFlags, LPCWSTR wszClassName, 
                _IWmiObject *pOldClass, _IWmiObject *pNewClass);
    CHR DeleteInstanceBackReferences(LPCWSTR wszFilePath);
    CHR ConstructReferenceDirFromFilePath(LPCWSTR wszFilePath, 
                                                LPWSTR wszReferenceDir);

	CHR ClassHasChildren(LPCWSTR wszClassName);
	CHR ClassHasInstances(LPCWSTR wszClassName);
	CHR ClassHasInstancesFromClassHash(LPCWSTR wszClassHash);
    CHR ClassHasInstancesInScopeFromClassHash(
                            LPCWSTR wszInstanceRootDir, LPCWSTR wszClassHash);

	CHR UpdateClassCompatible(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	CHR UpdateClassCompatibleHash(_IWmiObject* pSuperClass, 
                LPCWSTR wszClassHash, _IWmiObject *pClass, 
                _IWmiObject *pOldClass, __int64 nFakeUpdateTime = 0);
	CHR UpdateClassSafeForce(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wcsClassName, _IWmiObject *pOldClass, 
                _IWmiObject *pNewClass, CEventCollector &aEvents);
	CHR UpdateClassAggressively(_IWmiObject* pSuperClass, DWORD dwFlags, 
                LPCWSTR wszClassName, _IWmiObject *pNewClass, 
                _IWmiObject *pOldClass, 
                CEventCollector &aEvents);
	CHR UpdateChildClassAggressively(DWORD dwFlags, LPCWSTR wszClassHash, 
                _IWmiObject *pNewClass, 
                CEventCollector &aEvents);
	};

class CDbIterator : public CUnkBase2<IWmiDbIterator, &IID_IWmiDbIterator,
                                     IWbemObjectSink, &IID_IWbemObjectSink>
{
protected:
    CCritSec m_cs;
    CRefedPointerQueue<IWbemClassObject> m_qObjects;
    long m_lCurrentIndex;
    void* m_pExecFiber;
    CFiberTask* m_pExecReq;
    HRESULT m_hresStatus;
    
    void* m_pMainFiber;
    DWORD m_dwNumRequested;

    HRESULT m_hresCancellationStatus;
    bool m_bExecFiberRunning;
	bool m_bUseLock;

public:
    CDbIterator(CLifeControl* pControl, bool bUseLock);
    ~CDbIterator();

     STDMETHOD(Cancel) (DWORD dwFlags);

     STDMETHOD(NextBatch)(
      DWORD dwNumRequested,
      DWORD dwTimeOutSeconds,
      DWORD dwFlags,
      DWORD dwRequestedHandleType,
      REFIID riid,
      DWORD *pdwNumReturned,
      LPVOID *ppObjects
     );

    void SetExecFiber(void* pFiber, CFiberTask* pReq);
    
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, 
                                    BSTR, IWbemClassObject*);
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\absfile.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <wbemcomn.h>
#include "longstg.h"
#include "absfile.h"

DWORD  CAbstractFile::Write(DWORD dwOffs, LPVOID pMem, DWORD dwBytes, 
                            DWORD *pdwWritten)
{
    long lRes = m_pStage->WriteFile(m_nId, dwOffs, (BYTE*)pMem, dwBytes, 
                                        pdwWritten);
    return lRes;
}

DWORD  CAbstractFile::Read(DWORD dwOffs, LPVOID pMem, DWORD dwBytes,
                            DWORD *pdwRead)
{
    long lRes = m_pStage->ReadFile(m_nId, dwOffs, (BYTE*)pMem, dwBytes, 
                                        pdwRead);
    return lRes;
}

DWORD  CAbstractFile::SetFileLength(DWORD dwLen)
{
    long lRes = m_pStage->SetFileLength(m_nId, dwLen);
    return lRes;
}

DWORD  CAbstractFile::GetFileLength(DWORD* pdwLength)
{
    long lRes = m_pStage->GetFileLength(m_nId, pdwLength);
    return lRes;
}

void CAbstractFile::Touch()
{
    m_pStage->TouchTransaction();
}

long CAbstractFileSource::Create(LPCWSTR wszFileName, long lMaxFileSize,
                            long lAbortTransactionFileSize)
{
    m_Stage.SetMaxFileSize(lMaxFileSize, lAbortTransactionFileSize);
    return m_Stage.Create(wszFileName);
}

long CAbstractFileSource::Start()
{
    return m_Stage.Initialize();
}

long CAbstractFileSource::Stop(DWORD dwShutDownFlags)
{
    return m_Stage.Uninitialize(dwShutDownFlags);
}

DWORD CAbstractFileSource::Register(HANDLE hFile, int nID, 
                                    bool bSupportsOverwrites,
                                    CAbstractFile **pFile)
{
    long lRes = m_Stage.RegisterFile(nID, hFile, bSupportsOverwrites);
    if(lRes != ERROR_SUCCESS)
        return lRes;

    *pFile = new CAbstractFile(&m_Stage, nID);
    if(*pFile == NULL)
        return ERROR_OUTOFMEMORY;
    
    return ERROR_SUCCESS;
}

DWORD CAbstractFileSource::CloseAll()
{
    long lRes = m_Stage.CloseAllFiles();
    if(lRes == ERROR_SUCCESS)
        return TRUE;
    else
        return FALSE;
}
    
DWORD CAbstractFileSource::Begin(DWORD *pdwTransId)
{
    if(pdwTransId)
		*pdwTransId = 0;
    long lRes = m_Stage.BeginTransaction();
    return lRes;
}

DWORD CAbstractFileSource::Commit(DWORD dwTransId)
{
    _ASSERT(dwTransId == 0, L"");
    long lRes = m_Stage.CommitTransaction();
    return lRes;
}

DWORD CAbstractFileSource::Rollback(DWORD dwTransId, bool* pbNonEmpty)
{
    _ASSERT(dwTransId == 0, L"");
    long lRes = m_Stage.AbortTransaction(pbNonEmpty);
    return lRes;
}

void CAbstractFileSource::Dump(FILE* f)
{
    m_Stage.Dump(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\absfile.h ===
//***************************************************************************
//
//  (c) 2000 Microsoft Corp.  All Rights Reserved.
//
//  ABSFILE.H
//
//  Repository file wrappers for transacting
//
//  raymcc  02-Nov-00
//
//***************************************************************************

#ifndef __A51_ABSFILE_H_
#define __A51_ABSFILE_H_

#include "longstg.h"

class CAbstractFile
{
protected:
    CLongFileStagingFile* m_pStage;
    int m_nId;
    
public:
    CAbstractFile(CLongFileStagingFile* pStage, int nId) 
        : m_pStage(pStage), m_nId(nId)
    {}

    DWORD  Write(DWORD dwOffs, LPVOID pMem, DWORD dwBytes, DWORD *pdwWritten);
    DWORD  Read(DWORD dwOffs, LPVOID pMem, DWORD dwBytes, DWORD *pdwRead);
    DWORD  SetFileLength(DWORD dwLen);
    DWORD  GetFileLength(DWORD* pdwLength);
    void   Touch();
};

class CAbstractFileSource
{
private:
    CLongFileStagingFile m_Stage;

public:
    CAbstractFileSource(){}

    long Create(LPCWSTR wszFileName, long lMaxFileSize,
                            long lAbortTransactionFileSize);
    
    long Start();
    long Stop(DWORD dwShutDownFlags);

    DWORD Register(HANDLE hFile, int nID, bool bSupportsOverwrites,
                     CAbstractFile **pFile);		
    DWORD CloseAll();
    DWORD Begin(DWORD *pdwTransId);			// To accomodate possible simultaneous transactions
    DWORD Commit(DWORD dwTransId);
    DWORD Rollback(DWORD dwTransId, bool* pbNonEmpty);

    void Dump(FILE* f);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\roswell\a51tools.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "a51tools.h"

__int64 g_nCurrentTime = 1;

__int64 g_nReadFailures = 0;
__int64 g_nWriteFailures = 0;

//
// FILE_ATTRIBUTE_NOT_CONTENT_INDEXED is not actually supported on CreateFile,
// contrary to the docs.  However, also contrary to the docs, it is inherited
// from the parent directory
//

#define A51_FILE_CREATION_FLAGS 0 //FILE_ATTRIBUTE_NOT_CONTENT_INDEXED

CTempMemoryManager g_Manager;

void* TempAlloc(DWORD dwLen)
{
    return g_Manager.Allocate(dwLen);
}
    
void TempFree(void* p, DWORD dwLen)
{
    g_Manager.Free(p, dwLen);
}

void* TempAlloc(CTempMemoryManager& Manager, DWORD dwLen)
{
    return Manager.Allocate(dwLen);
}
    
void TempFree(CTempMemoryManager& Manager, void* p, DWORD dwLen)
{
    Manager.Free(p, dwLen);
}

HANDLE g_hLastEvent = NULL;
CCritSec g_csEvents;
HANDLE A51GetNewEvent()
{
    {
        CInCritSec ics(&g_csEvents);
        if(g_hLastEvent)
        {
            HANDLE h = g_hLastEvent;
            g_hLastEvent = NULL;
            return h;
        }
    }

    return CreateEvent(NULL, TRUE, FALSE, NULL);
}

void A51ReturnEvent(HANDLE hEvent)
{
    {
        CInCritSec ics(&g_csEvents);
        if(g_hLastEvent == NULL)
        {
            g_hLastEvent = hEvent;
            return;
        }
    }
    
    CloseHandle(hEvent);
}

HRESULT A51TranslateErrorCode(long lRes)
{
	if (SUCCEEDED(lRes))
		return WBEM_S_NO_ERROR;

    switch(lRes)
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        return WBEM_E_NOT_FOUND;
    case ERROR_OUTOFMEMORY:
        return WBEM_E_OUT_OF_MEMORY;
    case ERROR_NOT_ENOUGH_QUOTA:
    case ERROR_DISK_FULL:
        return WBEM_E_OUT_OF_DISK_SPACE;
    default:
        return WBEM_E_FAILED;
    }
}

long __stdcall EnsureDirectory(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    if(!CreateDirectoryW(wszPath, NULL))
    {
		long lRes = GetLastError();
        if(lRes != ERROR_ALREADY_EXISTS)
            return lRes;
        else
            return ERROR_SUCCESS;
    }
    else
        return ERROR_SUCCESS;
}

long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA);
long __stdcall EnsureDirectoryForFile(LPCWSTR wszPath, LPSECURITY_ATTRIBUTES pSA)
{
    //
    // Make a copy, since we will be messing with it
    //

    CFileName wszNewPath;
	if (wszNewPath == NULL)
		return ERROR_OUTOFMEMORY;
    wcscpy(wszNewPath, wszPath);

    return EnsureDirectoryRecursiveForFile(wszNewPath, pSA);
}


long __stdcall EnsureDirectoryRecursiveForFile(LPWSTR wszPath, 
                                                LPSECURITY_ATTRIBUTES pSA)
{
    long lRes;

    //
    // Find the last backslash and remove
    //

    WCHAR* pwcLastSlash = wcsrchr(wszPath, L'\\');
    if(pwcLastSlash == NULL)
        return ERROR_BAD_PATHNAME;

    *pwcLastSlash = 0;

    //
    // Try to create it
    //

    if(!CreateDirectoryW(wszPath, pSA))
    {
        //
        // Call ourselves recursively --- to create our parents
        //

        lRes = EnsureDirectoryRecursiveForFile(wszPath, pSA);
        if(lRes != ERROR_SUCCESS)
        {
            *pwcLastSlash = L'\\';
            return lRes;
        }

        //
        // Try again
        //

        BOOL bRes = CreateDirectoryW(wszPath, pSA);
        *pwcLastSlash = L'\\';
        if(bRes)
            return ERROR_SUCCESS;
        else
            return GetLastError();
    }
    else
    {
        *pwcLastSlash = L'\\';
        return ERROR_SUCCESS;
    }
}
        
inline WCHAR HexDigit(BYTE b)
{
    if(b < 10)
        return L'0' + b;
    else
        return L'A' + b - 10;
}
        
bool A51Hash(LPCWSTR wszName, LPWSTR wszHash)
{
	//
	// Have to upper-case everything
	//

    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
	if (wszBuffer == NULL)
		return false;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    wbem_wcsupr(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = HexDigit(RawHash[i]/16);        
        *(pwc++) = HexDigit(RawHash[i]%16);        
    }
	*pwc = 0;
    return true;
}

long A51WriteFile(LPCWSTR wszFullPath, DWORD dwLen, BYTE* pBuffer)
{
    long lRes;

    A51TRACE(( "Create file %S\n", wszFullPath));

    //
    // Create the right file
    //

    HANDLE hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                    NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
    if(hFile == INVALID_HANDLE_VALUE)
    {
        lRes = GetLastError();
        if(lRes == ERROR_PATH_NOT_FOUND)
        {
            lRes = EnsureDirectoryForFile(wszFullPath, NULL);
            if(lRes != ERROR_SUCCESS)
                return lRes;

            hFile = CreateFileW(wszFullPath, GENERIC_WRITE, 0,
                            NULL, CREATE_ALWAYS, A51_FILE_CREATION_FLAGS, NULL);
    
            if(hFile == INVALID_HANDLE_VALUE)
            {
                lRes = GetLastError();
                _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
                return lRes;
            }
        }
        else
            return lRes;
    }
        
    CCloseMe cm(hFile);

    //
    // Write it and close
    //

    if(!WriteFile(hFile, pBuffer, dwLen, &dwLen, NULL))
    {
        lRes = GetLastError();
        _ASSERT(lRes != ERROR_SUCCESS, L"success error code from fail");
        return lRes;
    }

    return ERROR_SUCCESS;
}

long A51DeleteFile(LPCWSTR wszFullPath)
{
    A51TRACE(("Delete file %S\n", wszFullPath));

    //
    // Delete the right file
    //

    if(!DeleteFileW(wszFullPath))
        return GetLastError();
    return ERROR_SUCCESS;
}

long A51WriteToFileAsync(HANDLE hFile, long lStartingOffset, BYTE* pBuffer,
