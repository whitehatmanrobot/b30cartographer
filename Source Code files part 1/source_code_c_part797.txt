gs,
                    ULONG SkipLines, ULONG OutputLines,
                    PULONG LineCount)
{
    ULONG Lines = 0;
    CHAR Buffer[MAX_DISASM_LEN];
    PCHAR FirstLine;
    HRESULT Status;

    if (Flags & DEBUG_DISASM_MATCHING_SYMBOLS)
    {
        ULONG64 Disp;
        GetSymbol(Flat(*Addr), Buffer, sizeof(Buffer), &Disp);
        if (Disp == 0)
        {
            if (OutputLines > 0)
            {
                if (SkipLines == 0)
                {
                    StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);
                    dprintf("%s:\n", Buffer);
                    OutputLines--;
                }
                else
                {
                    SkipLines--;
                }
            }

            Lines++;
        }
    }

    FirstLine = Buffer;

    if (!g_Machine->
        Disassemble(g_Process, Addr, Buffer,
                    (Flags & DEBUG_DISASM_EFFECTIVE_ADDRESS) != 0))
    {
        // Return S_FALSE if the disassembly failed.
        // Output will still be produced, such as "???".
        // Update the address to the next potential instruction
        // locations so that callers that are satisfied with "???"
        // can just iterate.
        g_Machine->IncrementBySmallestInstruction(Addr);
        Lines++;
        Status = S_FALSE;
        if (SkipLines > 0 || OutputLines == 0)
        {
            *FirstLine = 0;
        }
    }
    else
    {
        PSTR Nl = Buffer;
        PSTR LastLine = Nl;

        // Count lines in output and determine line positions.
        while (*Nl)
        {
            Nl = strchr(Nl, '\n');
            DBG_ASSERT(Nl != NULL);

            Lines++;
            Nl++;
            if (SkipLines > 0)
            {
                FirstLine = Nl;
                SkipLines--;
            }
            if (OutputLines > 0)
            {
                LastLine = Nl;
                OutputLines--;
            }
        }

        *LastLine = 0;
        Status = S_OK;
    }

    if (*FirstLine)
    {
        StartOutLine(DEBUG_OUTPUT_NORMAL, OUT_LINE_NO_TIMESTAMP);
        dprintf("%s", FirstLine);
    }

    if (LineCount != NULL)
    {
        *LineCount = Lines;
    }

    return Status;
}

#define ALL_DISASM_FLAGS \
    (DEBUG_DISASM_EFFECTIVE_ADDRESS | DEBUG_DISASM_MATCHING_SYMBOLS)

STDMETHODIMP
DebugClient::OutputDisassembly(
    THIS_
    IN ULONG OutputControl,
    IN ULONG64 Offset,
    IN ULONG Flags,
    OUT PULONG64 EndOffset
    )
{
    if (Flags & ~ALL_DISASM_FLAGS)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ADDR Addr;

    // Assume this is a code segment address so that disassembly
    // picks up the appropriate type of address.
    g_Machine->FormAddr(SEGREG_CODE, Offset, FORM_SEGREG | FORM_CODE, &Addr);

    Status = DoOutputDisassembly(&Addr, Flags, 0, 0xffffffff, NULL);
    *EndOffset = Flat(Addr);

    PopOutCtl(&OldCtl);
 Exit:
    LEAVE_ENGINE();
    return Status;
}

ULONG
BackUpDisassemblyLines(ULONG Lines, PADDR Addr, ULONG Flags, PADDR PcAddr)
{
    //
    // There's no easy way to predict how many lines of
    // output a particular disassembly will take so
    // just iteratively back up by the minimum amount until
    // the appropriate number of lines is reached.
    //

    ADDR BackAddr = *Addr;

    // Limit things so that failure can be detected.
    // Right now X86's maximum instruction length of 16
    // is big enough for all platforms so use that.
    ADDR LimitAddr = *Addr;
    ULONG BackBytes = X86_MAX_INSTRUCTION_LEN * Lines;
    if (BackBytes > LimitAddr.off)
    {
        LimitAddr.off = 0;
    }
    else
    {
        AddrSub(&LimitAddr, BackBytes);
    }
    
    ADDR TryAddr;
    ULONG TryLines;

    //
    // Reverse disassembly is difficult on x86 due
    // to the variable length instructions.  First
    // just locate the nearest symbol and disassemble
    // from that since this has a better chance of
    // producing a valid disassembly.
    //
    
    CHAR Buffer[MAX_DISASM_LEN];
    ULONG64 Disp;
    ADDR DisAddr, StartAddr;
    
    GetSymbol(Flat(LimitAddr), Buffer, sizeof(Buffer), &Disp);
    ADDRFLAT(&DisAddr, Disp);
    if (!AddrEqu(LimitAddr, DisAddr) &&
        Disp <= 16 * X86_MAX_INSTRUCTION_LEN)  // valid symbol
    {
        BOOL DoOneMore = FALSE;
        
        StartAddr = LimitAddr;
        AddrSub(&StartAddr, Disp);

        TryAddr = StartAddr;
        TryLines = 0;
        while (1)
        {
            ULONG DisLines;
            ULONG DisFlags;

            while (AddrLt(TryAddr, *Addr) && ((TryLines < Lines) || DoOneMore))
            {
                UCHAR MemTest;
                
                // If we can't read memory at this address there's
                // no chance of getting a valid disassembly so
                // just stop the whole process.
                if (fnotFlat(TryAddr) ||
                    g_Target->
                    ReadAllVirtual(g_Process, Flat(TryAddr),
                                   &MemTest, sizeof(MemTest)) != S_OK)
                {
                    TryAddr = *Addr;
                    break;
                }
                
                DisFlags = Flags;
                if (!AddrEqu(TryAddr, *PcAddr))
                {
                    DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
                }
                DoOutputDisassembly(&TryAddr, DisFlags, 0, 0, &DisLines);
                TryLines += DisLines;
                DoOneMore = FALSE;
            }

            if (TryLines >= Lines && AddrEqu(TryAddr, *Addr))
            {
                *Addr = StartAddr;
                return TryLines;
            }
            else if (AddrLt(TryAddr, *Addr)) 
            {
                DisAddr = StartAddr;
                // Increase StartAddr
                DisFlags = Flags;
                if (!AddrEqu(StartAddr, *PcAddr))
                {
                    DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
                }
                DoOutputDisassembly(&StartAddr, DisFlags, 0, 0, &DisLines);
                if ((DisLines == 1) || ((TryLines - DisLines) >= (Lines - 1))) 
                {
                    TryLines -= DisLines;
                }
                else 
                {
                    StartAddr = DisAddr;
                    DoOneMore = TRUE;
                }
            }
            else 
            {
                // couldn't find it
                break;
            }
        }
    }

    //
    // If we couldn't do something with symbols just
    // try a brute-force search backwards.  This
    // has limited utility on variable-length instruction
    // sets but sometimes it works.
    //
    
    while (AddrGt(BackAddr, LimitAddr))
    {
        g_Machine->DecrementBySmallestInstruction(&BackAddr);

        TryAddr = BackAddr;
        TryLines = 0;

        while (AddrLt(TryAddr, *Addr))
        {
            UCHAR MemTest;
                
            // If we can't read memory at this address there's
            // no chance of getting a valid disassembly so
            // just stop the whole process.
            if (fnotFlat(TryAddr) ||
                g_Target->
                ReadAllVirtual(g_Process, Flat(TryAddr),
                               &MemTest, sizeof(MemTest)) != S_OK)
            {
                BackAddr = LimitAddr;
                break;
            }
                
            ULONG DisLines;
            ULONG DisFlags = Flags;
            if (!AddrEqu(TryAddr, *PcAddr))
            {
                DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
            }
            DoOutputDisassembly(&TryAddr, DisFlags, 0, 0, &DisLines);
            TryLines += DisLines;
        }

        if (TryLines >= Lines && AddrEqu(TryAddr, *Addr))
        {
            *Addr = BackAddr;
            return TryLines;
        }
    }

    // Couldn't find a disassembly that worked.
    return 0;
}

STDMETHODIMP
DebugClient::OutputDisassemblyLines(
    THIS_
    IN ULONG OutputControl,
    IN ULONG PreviousLines,
    IN ULONG TotalLines,
    IN ULONG64 Offset,
    IN ULONG Flags,
    OUT OPTIONAL PULONG OffsetLine,
    OUT OPTIONAL PULONG64 StartOffset,
    OUT OPTIONAL PULONG64 EndOffset,
    OUT OPTIONAL /* size_is(TotalLines) */ PULONG64 LineOffsets
    )
{
    if ((Flags & ~ALL_DISASM_FLAGS) ||
        TotalLines < 1 || PreviousLines > TotalLines)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ULONG i;

    if (LineOffsets != NULL)
    {
        for (i = 0; i < TotalLines; i++)
        {
            LineOffsets[i] = DEBUG_INVALID_OFFSET;
        }
    }

    ULONG Line, Lines, SkipLines;
    ADDR Addr, PcAddr;

    // Assume this is a code segment address so that disassembly
    // picks up the appropriate type of address.
    g_Machine->FormAddr(SEGREG_CODE, Offset, FORM_SEGREG | FORM_CODE, &Addr);
    
    g_Machine->GetPC(&PcAddr);

    Line = 0;
    SkipLines = 0;

    if (PreviousLines > 0)
    {
        Lines = BackUpDisassemblyLines(PreviousLines, &Addr, Flags, &PcAddr);
        if (Lines == 0)
        {
            dprintf("No prior disassembly possible\n");
            Line = 1;
            Lines = 1;
            TotalLines--;
        }
        else if (Lines > PreviousLines)
        {
            SkipLines = Lines - PreviousLines;
            Lines = PreviousLines;
        }
    }
    else
    {
        Lines = 0;
    }

    if (OffsetLine != NULL)
    {
        *OffsetLine = Lines;
    }

    if (StartOffset != NULL)
    {
        *StartOffset = Flat(Addr);
    }

    while (TotalLines > 0)
    {
        if (LineOffsets != NULL)
        {
            LineOffsets[Line] = Flat(Addr);
        }

        ULONG DisFlags = Flags;
        if (!AddrEqu(Addr, PcAddr))
        {
            DisFlags &= ~DEBUG_DISASM_EFFECTIVE_ADDRESS;
        }
        DoOutputDisassembly(&Addr, DisFlags, SkipLines, TotalLines, &Lines);
        Lines -= SkipLines;

        if (TotalLines <= Lines)
        {
            break;
        }

        TotalLines -= Lines;
        Line += Lines;
        SkipLines = 0;
    }

    if (EndOffset != NULL)
    {
        *EndOffset = Flat(Addr);
    }

    Status = S_OK;

    PopOutCtl(&OldCtl);
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNearInstruction(
    THIS_
    IN ULONG64 Offset,
    IN LONG Delta,
    OUT PULONG64 NearOffset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Status = S_OK;

    switch(g_Target->m_EffMachineType)
    {
    case IMAGE_FILE_MACHINE_ARM:
        // Each instruction is 32 bits.
        Offset += (LONG64)Delta * 4;
        break;

    case IMAGE_FILE_MACHINE_IA64:
        ULONG Instr;

        // Each 128-bit bundle has three instructions.
        if (Delta < 0)
        {
            while (Delta++ < 0)
            {
                Instr = (ULONG)(Offset & 0xf);
                if (Instr == 0)
                {
                    Offset -= 8;
                }
                else
                {
                    Offset -= 4;
                }
            }
        }
        else
        {
            while (Delta-- > 0)
            {
                Instr = (ULONG)(Offset & 0xf);
                if (Instr == 8)
                {
                    Offset += 8;
                }
                else
                {
                    Offset += 4;
                }
            }
        }
        break;

    case IMAGE_FILE_MACHINE_I386:
    case IMAGE_FILE_MACHINE_AMD64:
        ADDR Addr;
        CHAR Buffer[MAX_DISASM_LEN];

        // Instructions are highly variable.  There isn't any
        // way to really know whether a particular disassembly
        // of a stretch of code is valid or not, so this
        // routine is inherently fragile.
        g_Machine->FormAddr(SEGREG_CODE, Offset,
                            FORM_SEGREG | FORM_CODE, &Addr);
        if (Delta < 0)
        {
            // Back up byte-by-byte and disassemble.  If the
            // post-disassembly offset matches the current offset,
            // a good-enough instruction sequence has been found.
            for (;;)
            {
                ADDR TryAddr;
                LONG TryDelta;

                AddrSub(&Addr, 1);
                TryAddr = Addr;
                TryDelta = 0;
                while (Flat(TryAddr) < Offset)
                {
                    if (!g_Machine->
                        Disassemble(g_Process,&TryAddr, Buffer, FALSE))
                    {
                        break;
                    }

                    TryDelta--;
                }

                if (Flat(TryAddr) == Offset &&
                    TryDelta == Delta)
                {
                    break;
                }

                // Limit things just as a precaution.
                if (Flat(Addr) < Offset + Delta * X86_MAX_INSTRUCTION_LEN)
                {
                    Status = E_FAIL;
                    break;
                }
            }
        }
        else
        {
            while (Delta-- > 0)
            {
                if (!g_Machine->Disassemble(g_Process, &Addr, Buffer, FALSE))
                {
                    Status = E_FAIL;
                    break;
                }
            }
        }
        Offset = Flat(Addr);
        break;

    default:
        Status = E_UNEXPECTED;
        break;
    }

    if (SUCCEEDED(Status))
    {
        *NearOffset = Offset;
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetStackTrace(
    THIS_
    IN ULONG64 FrameOffset,
    IN ULONG64 StackOffset,
    IN ULONG64 InstructionOffset,
    OUT PDEBUG_STACK_FRAME Frames,
    IN ULONG FramesSize,
    OUT OPTIONAL PULONG FramesFilled
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    ULONG FramesRet;
    ULONG64 ThreadData;

    if (g_ExtThread != 0)
    {
        ThreadData = g_ExtThread;
        g_ExtThread = 0;
    }
    else
    {
        ThreadData = 0;
    }

    ULONG PtrDef =
        (!InstructionOffset ? STACK_INSTR_DEFAULT : 0) |
        (!StackOffset ? STACK_STACK_DEFAULT : 0) |
        (!FrameOffset ? STACK_FRAME_DEFAULT : 0);
    
    FramesRet = StackTrace(this,
                           FrameOffset, StackOffset, InstructionOffset,
                           PtrDef, Frames, FramesSize, ThreadData, 0, FALSE);
    if (FramesRet > 0)
    {
        Status = S_OK;
        if (FramesFilled != NULL)
        {
            *FramesFilled = FramesRet;
        }
    }
    else
    {
        Status = E_FAIL;
    }
    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetReturnOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;

        g_Machine->GetRetAddr(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputStackTrace(
    THIS_
    IN ULONG OutputControl,
    IN PDEBUG_STACK_FRAME Frames,
    IN ULONG FramesSize,
    IN ULONG Flags
    )
{
    if (Flags & ~(DEBUG_STACK_ARGUMENTS |
                  DEBUG_STACK_FUNCTION_INFO |
                  DEBUG_STACK_SOURCE_LINE |
                  DEBUG_STACK_FRAME_ADDRESSES |
                  DEBUG_STACK_COLUMN_NAMES |
                  DEBUG_STACK_NONVOLATILE_REGISTERS |
                  DEBUG_STACK_FRAME_NUMBERS |
                  DEBUG_STACK_PARAMETERS | 
                  DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY |
                  DEBUG_STACK_FRAME_MEMORY_USAGE))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    // Currently only IA64 supports nonvolatile register output.
    if (g_Target->m_EffMachineType != IMAGE_FILE_MACHINE_IA64)
    {
        Flags &= ~DEBUG_STACK_NONVOLATILE_REGISTERS;
    }

    PDEBUG_STACK_FRAME LocalFrames;
    LocalFrames = NULL;

    if (Frames == NULL)
    {
        ULONG FramesFilled;
        ULONG64 ThreadData;

        if (g_ExtThread != 0)
        {
            ThreadData = g_ExtThread;
            g_ExtThread = 0;
        }
        else
        {
            ThreadData = 0;
        }

        LocalFrames = new DEBUG_STACK_FRAME[FramesSize];
        if (LocalFrames == NULL)
        {
            ErrOut("Unable to allocate memory for stack trace\n");
            Status = E_OUTOFMEMORY;
            goto PopExit;
        }

        //
        // StackTrace will generate output if any flags are
        // passed in.  The only time we really require that
        // it produce output is when nonvolatile registers
        // are requested as they can only be displayed when
        // the context is available during stack walking.
        // In order to simplify later logic, we only
        // pass flags if we have the nonvolatile register flag.
        //
        
        FramesFilled = StackTrace(this,
                                  0, 0, 0, STACK_ALL_DEFAULT,
                                  LocalFrames, FramesSize, ThreadData,
                                  (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS) ?
                                  Flags : 0, FALSE);
        if (FramesFilled == 0)
        {
            delete [] LocalFrames;
            goto PopExit;
        }

        Frames = LocalFrames;
        FramesSize = FramesFilled;
    }
    else if (Flags & DEBUG_STACK_NONVOLATILE_REGISTERS)
    {
        // Can't dump nonvolatile registers without a full
        // context so this is not an allowable options.
        Status = E_INVALIDARG;
        goto PopExit;
    }

    if (!(Flags & DEBUG_STACK_NONVOLATILE_REGISTERS))
    {
        PrintStackTrace(FramesSize, Frames, Flags);
    }

    Status = S_OK;

    delete [] LocalFrames;
    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }

 PopExit:
    PopOutCtl(&OldCtl);
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDebuggeeType(
    THIS_
    OUT PULONG Class,
    OUT PULONG Qualifier
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        *Class = DEBUG_CLASS_UNINITIALIZED;
        *Qualifier = 0;
        Status = S_OK;
    }
    else
    {
        *Class = g_Target->m_Class;
        *Qualifier = g_Target->m_ClassQualifier;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetActualProcessorType(
    THIS_
    OUT PULONG Type
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Type = g_Target->m_MachineType;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetExecutingProcessorType(
    THIS_
    OUT PULONG Type
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_EventMachine)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Type = g_EventMachine->m_ExecTypes[0];
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberPossibleExecutingProcessorTypes(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        MachineInfo* Machine =
            MachineTypeInfo(g_Target, g_Target->m_MachineType);
        if (Machine == NULL)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            *Number = Machine->m_NumExecTypes;
            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetPossibleExecutingProcessorTypes(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT PULONG Types
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        MachineInfo* Machine =
            MachineTypeInfo(g_Target, g_Target->m_MachineType);
        if (Machine == NULL ||
            Start >= Machine->m_NumExecTypes ||
            Start + Count > Machine->m_NumExecTypes)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            Status = S_OK;
            while (Count-- > 0)
            {
                *Types++ = Machine->m_ExecTypes[Start++];
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberProcessors(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_Target->m_NumProcessors;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSystemVersion(
    THIS_
    OUT PULONG PlatformId,
    OUT PULONG Major,
    OUT PULONG Minor,
    OUT OPTIONAL PSTR ServicePackString,
    IN ULONG ServicePackStringSize,
    OUT OPTIONAL PULONG ServicePackStringUsed,
    OUT PULONG ServicePackNumber,
    OUT OPTIONAL PSTR BuildString,
    IN ULONG BuildStringSize,
    OUT OPTIONAL PULONG BuildStringUsed
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    // This is insufficient to distinguish
    // the various system types supported but we don't
    // want to publish identifiers for every possible
    // system version family.  PlatformId is as good
    // as it gets.

    if (!IS_MACHINE_SET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *PlatformId = g_Target->m_PlatformId;
        *Major = g_Target->m_CheckedBuild;
        *Minor = g_Target->m_BuildNumber;
        Status = FillStringBuffer(g_Target->m_ServicePackString, 0,
                                  ServicePackString, ServicePackStringSize,
                                  ServicePackStringUsed);
        *ServicePackNumber = g_Target->m_ServicePackNumber;
        if (FillStringBuffer(g_Target->m_BuildLabName, 0,
                             BuildString, BuildStringSize,
                             BuildStringUsed) == S_FALSE)
        {
            Status = S_FALSE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetPageSize(
    THIS_
    OUT PULONG Size
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Machine)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Size = g_Machine->m_PageSize;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::IsPointer64Bit(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Machine)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Machine->m_Ptr64 ? S_OK : S_FALSE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadBugCheckData(
    THIS_
    OUT PULONG Code,
    OUT PULONG64 Arg1,
    OUT PULONG64 Arg2,
    OUT PULONG64 Arg3,
    OUT PULONG64 Arg4
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_KERNEL_TARGET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG64 Args[4];

        Status = g_Target->ReadBugCheckData(Code, Args);
        if (Status == S_OK)
        {
            *Arg1 = Args[0];
            *Arg2 = Args[1];
            *Arg3 = Args[2];
            *Arg4 = Args[3];
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberSupportedProcessorTypes(
    THIS_
    OUT PULONG Number
    )
{
    ENTER_ENGINE();

    *Number = MACHIDX_COUNT;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetSupportedProcessorTypes(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT PULONG Types
    )
{
    if (Start >= MACHIDX_COUNT ||
        Start + Count > MACHIDX_COUNT)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Count > 0)
    {
        while (Count-- > 0)
        {
            // First ExecTypes entry is the actual processor
            // type so it's a convenient place to turn an
            // index into a type.
            *Types++ = g_PossibleProcessorTypes[Start++];
        }
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetProcessorTypeNames(
    THIS_
    IN ULONG Type,
    OUT OPTIONAL PSTR FullNameBuffer,
    IN ULONG FullNameBufferSize,
    OUT OPTIONAL PULONG FullNameSize,
    OUT OPTIONAL PSTR AbbrevNameBuffer,
    IN ULONG AbbrevNameBufferSize,
    OUT OPTIONAL PULONG AbbrevNameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    MachineInfo* Machine = MachineTypeInfo(g_Target, Type);
    if (Machine == NULL)
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = FillStringBuffer(Machine->m_FullName, 0,
                                  FullNameBuffer, FullNameBufferSize,
                                  FullNameSize);
        if (FillStringBuffer(Machine->m_AbbrevName, 0,
                             AbbrevNameBuffer, AbbrevNameBufferSize,
                             AbbrevNameSize) == S_FALSE)
        {
            Status = S_FALSE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEffectiveProcessorType(
    THIS_
    OUT PULONG Type
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Type = g_Target->m_EffMachineType;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetEffectiveProcessorType(
    THIS_
    IN ULONG Type
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        MachineIndex Index = MachineTypeIndex(Type);
        if (Index == MACHIDX_COUNT)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            g_Target->SetEffMachine(Type, TRUE);
            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

ULONG
GetExecutionStatus(void)
{
    if ((g_EngStatus & ENG_STATUS_STOP_SESSION) ||
        !AnyActiveProcesses(TRUE))
    {
        return DEBUG_STATUS_NO_DEBUGGEE;
    }
    else if (g_CmdState == 'p')
    {
        return DEBUG_STATUS_STEP_OVER;
    }
    else if (g_CmdState == 't')
    {
        return DEBUG_STATUS_STEP_INTO;
    }
    else if (g_CmdState == 'b')
    {
        return DEBUG_STATUS_STEP_BRANCH;
    }
    else if (g_CmdState == 'g' || g_CmdState == 'e')
    {
        return DEBUG_STATUS_GO;
    }
    else
    {
        return DEBUG_STATUS_BREAK;
    }
}

STDMETHODIMP
DebugClient::GetExecutionStatus(
    THIS_
    OUT PULONG Status
    )
{
    // This method is reentrant.
    *Status = ::GetExecutionStatus();
    return S_OK;
}

HRESULT
SetExecutionStatus(ULONG Status)
{
    // If there's an outstanding request for input don't
    // allow the execution status of the engine to change
    // as it could lead to a wait which cannot
    // be carried out in this situation.  It's better to fail
    // this call and have the caller try again.
    if (g_InputNesting >= 1 ||
        !g_Machine)
    {
        return E_UNEXPECTED;
    }
    
    if (IS_RUNNING(g_CmdState))
    {
        // Already running.
        return S_OK;
    }

    ADDR PcAddr;

    g_Machine->GetPC(&PcAddr);

    // Notifications are sent in the step/go functions.
    if (Status >= DEBUG_STATUS_GO &&
        Status <= DEBUG_STATUS_GO_NOT_HANDLED)
    {
        SetExecGo(Status, &PcAddr, NULL, FALSE, 0, NULL, NULL);
    }
    else
    {
        DBG_ASSERT(Status == DEBUG_STATUS_STEP_OVER ||
                   Status == DEBUG_STATUS_STEP_INTO ||
                   Status == DEBUG_STATUS_STEP_BRANCH);

        if (g_Machine->IsStepStatusSupported(Status))
        {
            char StepType;
            
            switch (Status) 
            {
            case DEBUG_STATUS_STEP_INTO:
                StepType = 't';
                break;
            case DEBUG_STATUS_STEP_OVER:
                StepType = 'p';
                break;
            case DEBUG_STATUS_STEP_BRANCH:
                StepType = 'b';
                break;
            }
            
            SetExecStepTrace(&PcAddr, 1, NULL, FALSE, FALSE, StepType);
        }
        else 
        {
            char* Mode;

            switch (Status)
            {
            case DEBUG_STATUS_STEP_BRANCH:
                Mode = "Taken branch trace";
                break;
            default:
                Mode = "Trace";
                break;
            }

            ErrOut("%s mode not supported\n", Mode);

            return E_INVALIDARG;
        }
    }

    return S_OK;
}

STDMETHODIMP
DebugClient::SetExecutionStatus(
    THIS_
    IN ULONG Status
    )
{
    if ((Status <= DEBUG_STATUS_NO_CHANGE || Status >= DEBUG_STATUS_BREAK) &&
        Status != DEBUG_STATUS_STEP_BRANCH)
    {
        return E_INVALIDARG;
    }

    HRESULT RetStatus;

    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target))
    {
        RetStatus = E_UNEXPECTED;
    }
    else
    {
        RetStatus = ::SetExecutionStatus(Status);
    }

    LEAVE_ENGINE();
    return RetStatus;
}

STDMETHODIMP
DebugClient::GetCodeLevel(
    THIS_
    OUT PULONG Level
    )
{
    ENTER_ENGINE();

    if (g_SrcOptions & SRCOPT_STEP_SOURCE)
    {
        *Level = DEBUG_LEVEL_SOURCE;
    }
    else
    {
        *Level = DEBUG_LEVEL_ASSEMBLY;
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetCodeLevel(
    THIS_
    IN ULONG Level
    )
{
    ENTER_ENGINE();

    HRESULT Status = S_OK;
    ULONG OldSrcOpt = g_SrcOptions;

    switch(Level)
    {
    case DEBUG_LEVEL_ASSEMBLY:
        g_SrcOptions &= ~SRCOPT_STEP_SOURCE;
        break;
    case DEBUG_LEVEL_SOURCE:
        g_SrcOptions |= SRCOPT_STEP_SOURCE;
        break;
    default:
        Status = E_INVALIDARG;
        break;
    }

    if ((OldSrcOpt ^ g_SrcOptions) & SRCOPT_STEP_SOURCE)
    {
        NotifyChangeEngineState(DEBUG_CES_CODE_LEVEL,
                                (g_SrcOptions & SRCOPT_STEP_SOURCE) ?
                                DEBUG_LEVEL_SOURCE : DEBUG_LEVEL_ASSEMBLY,
                                TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEngineOptions(
    THIS_
    OUT PULONG Options
    )
{
    // This method is reentrant.
    *Options = g_EngOptions;
    return S_OK;
}

HRESULT
SetEngOptions(ULONG Options)
{
    if (g_EngOptions != Options)
    {
        // Make sure allow and disallow network paths aren't both on.
        if ((Options & ~DEBUG_ENGOPT_ALL) ||
            ((Options & DEBUG_ENGOPT_NETWORK_PATHS) ==
             DEBUG_ENGOPT_NETWORK_PATHS))
        {
            return E_INVALIDARG;
        }

        // Security options cannot be disabled.
        if ((g_EngOptions & DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS) &&
            !(Options & DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS))
        {
            return E_INVALIDARG;
        }

        g_EngOptions = Options;
        
        ULONG Notify = DEBUG_CES_ENGINE_OPTIONS;
        ULONG64 Arg = Options;
        
        if (SyncFiltersWithOptions())
        {
            Notify |= DEBUG_CES_EVENT_FILTERS;
            Arg = DEBUG_ANY_ID;
        }

        // XXX drewb - Notification without any lock.
        NotifyChangeEngineState(Notify, Arg, FALSE);
    }

    return S_OK;
}

STDMETHODIMP
DebugClient::AddEngineOptions(
    THIS_
    IN ULONG Options
    )
{
    // This method is reentrant.
    return SetEngOptions(g_EngOptions | Options);
}

STDMETHODIMP
DebugClient::RemoveEngineOptions(
    THIS_
    IN ULONG Options
    )
{
    // This method is reentrant.
    return SetEngOptions(g_EngOptions & ~Options);
}

STDMETHODIMP
DebugClient::SetEngineOptions(
    THIS_
    IN ULONG Options
    )
{
    // This method is reentrant.
    return SetEngOptions(Options);
}

STDMETHODIMP
DebugClient::GetSystemErrorControl(
    THIS_
    OUT PULONG OutputLevel,
    OUT PULONG BreakLevel
    )
{
    ENTER_ENGINE();

    *OutputLevel = g_SystemErrorOutput;
    *BreakLevel = g_SystemErrorBreak;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetSystemErrorControl(
    THIS_
    IN ULONG OutputLevel,
    IN ULONG BreakLevel
    )
{
    if (OutputLevel > SLE_WARNING ||
        BreakLevel > SLE_WARNING)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_SystemErrorOutput = OutputLevel;
    g_SystemErrorBreak = BreakLevel;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetTextMacro(
    THIS_
    IN ULONG Slot,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG MacroSize
    )
{
    if (Slot >= REG_USER_COUNT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(GetUserReg(REG_USER_FIRST + Slot), 0,
                              Buffer, BufferSize, MacroSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetTextMacro(
    THIS_
    IN ULONG Slot,
    IN PCSTR Macro
    )
{
    if (Slot >= REG_USER_COUNT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = SetUserReg(REG_USER_FIRST + Slot, Macro) ? S_OK : E_OUTOFMEMORY;

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetRadix(
    THIS_
    OUT PULONG Radix
    )
{
    ENTER_ENGINE();

    *Radix = g_DefaultRadix;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetRadix(
    THIS_
    IN ULONG Radix
    )
{
    if (Radix != 8 && Radix != 10 && Radix != 16)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_DefaultRadix = Radix;
    NotifyChangeEngineState(DEBUG_CES_RADIX, g_DefaultRadix, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::Evaluate(
    THIS_
    IN PCSTR Expression,
    IN ULONG DesiredType,
    OUT PDEBUG_VALUE Value,
    OUT OPTIONAL PULONG RemainderIndex
    )
{
    char Copy[MAX_COMMAND];

    if (Expression == NULL ||
        strlen(Expression) >= sizeof(Copy))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    PSTR SaveCommand;
    PSTR SaveStart;

    // This Evaluate may be coming from an extension invoked
    // from a command so save all command state.
    SaveCommand = g_CurCmd;
    SaveStart = g_CommandStart;
    g_DisableErrorPrint++;

    // Copy const string to buffer to avoid read-only memory
    // AVs as the command is modified during parsing.
    strcpy(Copy, Expression);
    g_CurCmd = Copy;
    g_CommandStart = Copy;
    RemoveDelChar(g_CurCmd);
    ExpandUserRegs(Copy, DIMA(Copy));

    __try
    {
        TypedData Result;
        EvalExpression* Eval = GetCurEvaluator();
        Eval->EvalCurrent(&Result);
        ReleaseEvaluator(Eval);

        if (Result.IsFloat())
        {
            if (Result.ConvertToF64())
            {
                Status = E_FAIL;
                __leave;
            }
            
            Value->F64 = Result.m_F64;
            Value->Type = DEBUG_VALUE_FLOAT64;
        }
        else
        {
            if (Result.ConvertToU64())
            {
                Status = E_FAIL;
                __leave;
            }
            
            Value->I64 = Result.m_U64;
            Value->Type = DEBUG_VALUE_INT64;
        }

        if (RemainderIndex != NULL)
        {
            *RemainderIndex = (ULONG)(g_CurCmd - g_CommandStart);
        }

        if (DesiredType != DEBUG_VALUE_INVALID &&
            DesiredType != Value->Type)
        {
            DEBUG_VALUE Natural = *Value;
            Status = CoerceValue(&Natural, DesiredType, Value);
        }
        else
        {
            Status = S_OK;
        }
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        Status = E_FAIL;
    }

    g_DisableErrorPrint--;
    g_CurCmd = SaveCommand;
    g_CommandStart = SaveStart;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

#define IS_INT(Type) \
    ((Type) >= DEBUG_VALUE_INT8 && (Type) <= DEBUG_VALUE_INT64)
#define IS_FLOAT(Type) \
    ((Type) >= DEBUG_VALUE_FLOAT32 && (Type) <= DEBUG_VALUE_FLOAT128)
#define IS_VECTOR(Type) \
    ((Type) >= DEBUG_VALUE_VECTOR64 && (Type) <= DEBUG_VALUE_VECTOR128)

STDMETHODIMP
DebugClient::CoerceValue(
    THIS_
    IN PDEBUG_VALUE In,
    IN ULONG OutType,
    OUT PDEBUG_VALUE Out
    )
{
    if (In->Type < DEBUG_VALUE_INT8 || In->Type >= DEBUG_VALUE_TYPES ||
        OutType < DEBUG_VALUE_INT8 || OutType >= DEBUG_VALUE_TYPES)
    {
        return E_INVALIDARG;
    }

    if (In->Type == OutType)
    {
        *Out = *In;
        return S_OK;
    }

    ENTER_ENGINE();

    ZeroMemory(Out, sizeof(*Out));
    Out->Type = OutType;

    DEBUG_VALUE Inter;
    char FloatStr[64];

    ZeroMemory(&Inter, sizeof(Inter));

    // Convert the input type to the largest
    // matching type for intermediate operations.
    switch(In->Type)
    {
    case DEBUG_VALUE_INT8:
        Inter.I64 = In->I8;
        Inter.Nat = FALSE;
        break;
    case DEBUG_VALUE_INT16:
        Inter.I64 = In->I16;
        Inter.Nat = FALSE;
        break;
    case DEBUG_VALUE_INT32:
        Inter.I64 = In->I32;
        Inter.Nat = FALSE;
        break;
    case DEBUG_VALUE_INT64:
        Inter.I64 = In->I64;
        Inter.Nat = In->Nat;
        break;
    case DEBUG_VALUE_FLOAT32:
        // XXX drewb - Use direct conversion.
        PrintString(FloatStr, DIMA(FloatStr), "%10g", In->F32);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
        break;
    case DEBUG_VALUE_FLOAT64:
        // XXX drewb - Use direct conversion.
        PrintString(FloatStr, DIMA(FloatStr), "%10lg", In->F64);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
        break;
    case DEBUG_VALUE_FLOAT80:
        memcpy(Inter.RawBytes, In->F80Bytes, sizeof(In->F80Bytes));
        break;
    case DEBUG_VALUE_FLOAT82:
        FLOAT128 f82;
        memcpy(&f82, &(In->F82Bytes), 
               min(sizeof(f82), sizeof(In->F82Bytes)));
        double f; 
        f = Float82ToDouble(&f82);
        PrintString(FloatStr, DIMA(FloatStr), "%10g", f);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
        break;
    case DEBUG_VALUE_FLOAT128:
        // XXX drewb - What's the format?  How should this be supported.
        memcpy(Inter.RawBytes, In->F128Bytes, sizeof(In->F128Bytes));
        break;
    case DEBUG_VALUE_VECTOR64:
        memcpy(Inter.RawBytes, In->RawBytes, 8);
        break;
    case DEBUG_VALUE_VECTOR128:
        memcpy(Inter.RawBytes, In->RawBytes, 16);
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }

    // Convert between float, int and vector.  There's
    // no way to know what kind of data is in a vector
    // so the raw bytes are just used directly.
    if (IS_INT(In->Type) &&
        IS_FLOAT(OutType))
    {
        // XXX drewb - Use direct conversion.
        PrintString(FloatStr, DIMA(FloatStr), "%I64u", Inter.I64);
        _atoldbl((_ULDOUBLE*)Inter.RawBytes, FloatStr);
    }
    else if (IS_FLOAT(In->Type) &&
             IS_INT(OutType))
    {
        double TmpDbl;

        // XXX drewb - Use direct conversion.
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        if (sscanf(FloatStr, "%lg", &TmpDbl) != 1)
        {
            TmpDbl = 0.0;
        }
        Inter.I64 = (ULONG64)TmpDbl;
        Inter.Nat = FALSE;
    }

    // Convert the intermediate value down to the
    // appropriate output size.
    switch(OutType)
    {
    case DEBUG_VALUE_INT8:
        Out->I8 = (UCHAR)Inter.I64;
        break;
    case DEBUG_VALUE_INT16:
        Out->I16 = (USHORT)Inter.I64;
        break;
    case DEBUG_VALUE_INT32:
        Out->I32 = (ULONG)Inter.I64;
        break;
    case DEBUG_VALUE_INT64:
        Out->I64 = Inter.I64;
        Out->Nat = Inter.Nat;
        break;
    case DEBUG_VALUE_FLOAT32:
        // XXX drewb - Use direct conversion.
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        if (sscanf(FloatStr, "%g", &Out->F32) != 1)
        {
            Out->F32 = 0.0f;
        }
        break;
    case DEBUG_VALUE_FLOAT64:
        // XXX drewb - Use direct conversion.
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        if (sscanf(FloatStr, "%lg", &Out->F64) != 1)
        {
            Out->F64 = 0.0;
        }
        break;
    case DEBUG_VALUE_FLOAT80:
        memcpy(Out->F80Bytes, Inter.RawBytes, sizeof(Out->F80Bytes));
        break;
    case DEBUG_VALUE_FLOAT82:
        _uldtoa((_ULDOUBLE*)Inter.RawBytes, sizeof(FloatStr), FloatStr);
        double f;
        if (sscanf(FloatStr, "%lg", &f) != 1)
        {
            f = 0.0;
        }
        FLOAT128 f82;
        DoubleToFloat82(f, &f82);
        memcpy(&(Out->F82Bytes), &f82, 
               min(sizeof(Out->F82Bytes), sizeof(f82)));
        break;
    case DEBUG_VALUE_FLOAT128:
        // XXX drewb - What's the format?  How should this be supported.
        memcpy(Out->F128Bytes, Inter.RawBytes, sizeof(Out->F128Bytes));
        break;
    case DEBUG_VALUE_VECTOR64:
        memcpy(Out->RawBytes, Inter.RawBytes, 8);
        break;
    case DEBUG_VALUE_VECTOR128:
        memcpy(Out->RawBytes, Inter.RawBytes, 16);
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::CoerceValues(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PDEBUG_VALUE In,
    IN /* size_is(Count) */ PULONG OutTypes,
    OUT /* size_is(Count) */ PDEBUG_VALUE Out
    )
{
    ENTER_ENGINE();

    ULONG i;
    HRESULT Status, SingleStatus;

    Status = S_OK;
    for (i = 0; i < Count; i++)
    {
        SingleStatus = CoerceValue(In, *OutTypes, Out);
        if (SingleStatus != S_OK)
        {
            // Accumulate error and mark failed value.
            Status = SingleStatus;
            Out->Type = DEBUG_VALUE_INVALID;
        }

        In++;
        OutTypes++;
        Out++;
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
Execute(DebugClient* Client, PCSTR Command, ULONG Flags)
{
    char Copy[MAX_COMMAND];

    ULONG Len = strlen(Command);
    if (Len >= MAX_COMMAND)
    {
        return E_INVALIDARG;
    }
    
    BOOL AddNewLine = Len == 0 || Command[Len - 1] != '\n';

    if (Flags & DEBUG_EXECUTE_ECHO)
    {
        dprintf("%s", Command);
        if (AddNewLine)
        {
            dprintf("\n");
        }
    }
    else if ((Flags & DEBUG_EXECUTE_NOT_LOGGED) == 0)
    {
        lprintf(Command);
        if (AddNewLine)
        {
            lprintf("\n");
        }
    }

    HRESULT Status;
    PSTR SaveCommand;
    PSTR SaveStart;

    // This Execute may be coming from an extension invoked
    // from a command so save all command state.
    SaveCommand = g_CurCmd;
    SaveStart = g_CommandStart;

    // Copy const string to buffer to avoid read-only memory
    // AVs as the command is modified during parsing.
    strcpy(Copy, Command);
    g_CurCmd = Copy;
    g_CommandStart = Copy;
    RemoveDelChar(g_CurCmd);
    ExpandUserRegs(Copy, DIMA(Copy));
    ReplaceAliases(g_CurCmd, MAX_COMMAND);

    if ((Flags & DEBUG_EXECUTE_NO_REPEAT) == 0 &&
        (g_EngOptions & DEBUG_ENGOPT_NO_EXECUTE_REPEAT) == 0)
    {
        if (Copy[0] == 0)
        {
            strcpy(Copy, g_LastCommand);
        }
        else
        {
            strcpy(g_LastCommand, Copy);
        }
    }

    for (;;)
    {
        Status = ProcessCommandsAndCatch(Client);

        // If we're switching processors (g_CmdState == 's')
        // we have to wait to allow the switch to occur.
        if (g_CmdState != 's' &&
            (Status != S_FALSE ||
             (g_EngStatus & ENG_STATUS_NO_AUTO_WAIT)))
        {
            break;
        }

        if ((g_CmdState != 's' ||
             !IS_CONN_KERNEL_TARGET(g_Target) ||
             ((ConnLiveKernelTargetInfo*)g_Target)->
             m_Transport->m_WaitingThread != 0) &&
            GetCurrentThreadId() != g_SessionThread)
        {
            ErrOut("Non-primary client caused an implicit wait\n");
            Status = E_FAIL;
            break;
        }

        if ((Status = 
             RawWaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)) != S_OK)
        {
            break;
        }
    }

    g_CurCmd = SaveCommand;
    g_CommandStart = SaveStart;

    return Status;
}

#define ALL_EXECUTE_FLAGS       \
    (DEBUG_EXECUTE_DEFAULT |    \
     DEBUG_EXECUTE_ECHO |       \
     DEBUG_EXECUTE_NOT_LOGGED | \
     DEBUG_EXECUTE_NO_REPEAT)

STDMETHODIMP
DebugClient::Execute(
    THIS_
    IN ULONG OutputControl,
    IN PCSTR Command,
    IN ULONG Flags
    )
{
    if ((Flags & ~ALL_EXECUTE_FLAGS) ||
        strlen(Command) >= MAX_COMMAND)
    {
        return E_INVALIDARG;
    }

    // We can't do a blanket IS_MACHINE_ACCESSIBLE check
    // here as Execute's commands have a mix of requirements.
    // Individual commands should check when necessary.

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = ::Execute(this, Command, Flags);
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
ExecuteCommandFile(DebugClient* Client, PCSTR CommandFile, ULONG Flags)
{
    HRESULT Status;
    FILE* File;

    File = fopen(CommandFile, "r");
    if (File == NULL)
    {
        Status = HRESULT_FROM_WIN32(_doserrno);
    }
    else
    {
        char Command[MAX_COMMAND + 1];
        va_list VaUnused;

        // This value is only used as a placeholder so
        // it doesn't really matter what it's initialized to.
        ZeroMemory(&VaUnused, sizeof(VaUnused));

        for (;;)
        {
            ULONG Len;
            
            Command[sizeof(Command) - 2] = 0;
            
            if (fgets(Command, sizeof(Command) - 1, File) == NULL)
            {
                if (feof(File))
                {
                    Status = S_OK;
                }
                else
                {
                    Status = E_FAIL;
                }
                break;
            }

            if (Command[sizeof(Command) - 2] != 0)
            {
                // Input line is too long.
                Status = E_INVALIDARG;
                break;
            }

            //
            // If the line didn't end with a newline force it
            // to have one for consistency.
            //

            Len = strlen(Command);
            if (Len > 0 && Command[Len - 1] != '\n')
            {
                Command[Len] = '\n';
                Command[Len + 1] = 0;
            }
            
            if (Flags & DEBUG_EXECUTE_ECHO)
            {
                OutputPrompt(" ", VaUnused);
                // Command has a new-line built in.
                dprintf("%s", Command);
            }
            else if ((Flags & DEBUG_EXECUTE_NOT_LOGGED) == 0)
            {
                ULONG OutCtl;

                // Restrict output to the log only.
                OutCtl = g_OutputControl;
                g_OutputControl = (OutCtl & ~DEBUG_OUTCTL_SEND_MASK) |
                    DEBUG_OUTCTL_LOG_ONLY;

                OutputPrompt(" ", VaUnused);
                // Command has a new-line built in.
                dprintf("%s", Command);

                g_OutputControl = OutCtl;
            }

            // If a command exception is thrown we don't want to
            // terminate execution of the script, so specifically
            // check for the status code which indicates that
            // an exception occurred and ignore it.
            Status = Execute(Client, Command, DEBUG_EXECUTE_NOT_LOGGED |
                             (Flags & ~DEBUG_EXECUTE_ECHO));
            if (Status != S_OK && Status != HR_PROCESS_EXCEPTION)
            {
                break;
            }
        }

        fclose(File);
    }

    return Status;
}

STDMETHODIMP
DebugClient::ExecuteCommandFile(
    THIS_
    IN ULONG OutputControl,
    IN PCSTR CommandFile,
    IN ULONG Flags
    )
{
    if (Flags & ~ALL_EXECUTE_FLAGS)
    {
        return E_INVALIDARG;
    }

    // We can't do a blanket IS_MACHINE_ACCESSIBLE check
    // here as Execute's commands have a mix of requirements.
    // Individual commands should check when necessary.

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;
    if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        return E_INVALIDARG;
    }
    else
    {
        Status = ::ExecuteCommandFile(this, CommandFile, Flags);
        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberBreakpoints(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_Process->m_NumBreakpoints;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetBreakpointByIndex(
    THIS_
    IN ULONG Index,
    OUT PDEBUG_BREAKPOINT* RetBp
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Breakpoint* Bp = ::GetBreakpointByIndex(this, Index);
        if (Bp != NULL)
        {
            Bp->AddRef();
            *RetBp = Bp;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetBreakpointById(
    THIS_
    IN ULONG Id,
    OUT PDEBUG_BREAKPOINT* RetBp
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Breakpoint* Bp = ::GetBreakpointById(this, Id);
        if (Bp != NULL)
        {
            Bp->AddRef();
            *RetBp = Bp;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetBreakpointParameters(
    THIS_
    IN ULONG Count,
    IN OPTIONAL /* size_is(Count) */ PULONG Ids,
    IN ULONG Start,
    OUT /* size_is(Count) */ PDEBUG_BREAKPOINT_PARAMETERS Params
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG i;
        Breakpoint* Bp;

        Status = S_OK;
        for (i = 0; i < Count; i++)
        {
            if (Ids != NULL)
            {
                Bp = ::GetBreakpointById(this, *Ids++);
            }
            else
            {
                Bp = ::GetBreakpointByIndex(this, Start++);
            }

            if (Bp == NULL)
            {
                ZeroMemory(Params, sizeof(*Params));
                Params->Id = DEBUG_ANY_ID;
                Status = S_FALSE;
            }
            else
            {
                Bp->GetParameters(Params);
            }

            Params++;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddBreakpoint(
    THIS_
    IN ULONG Type,
    IN ULONG DesiredId,
    OUT PDEBUG_BREAKPOINT* Bp
    )
{
    if (
#if DEBUG_BREAKPOINT_CODE > 0
        Type < DEBUG_BREAKPOINT_CODE ||
#endif
        Type > DEBUG_BREAKPOINT_DATA)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target) || !g_Process)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = ::AddBreakpoint(this, g_Target->m_EffMachine,
                                 Type, DesiredId, (Breakpoint**)Bp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveBreakpoint(
    THIS_
    IN PDEBUG_BREAKPOINT Bp
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ::RemoveBreakpoint((Breakpoint*)Bp);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AddExtension(
    THIS_
    IN PCSTR Path,
    IN ULONG Flags,
    OUT PULONG64 Handle
    )
{
    if (Flags & ~(DEBUG_EXTENSION_AT_ENGINE))
    {
        return E_INVALIDARG;
    }
    // Remote extensions aren't supported at the moment.
    if (Flags != DEBUG_EXTENSION_AT_ENGINE)
    {
        return E_NOTIMPL;
    }

    HRESULT Status;

    ENTER_ENGINE();

    char* End;
    EXTDLL* Ext;

    if ((Ext = AddExtensionDll((PSTR)Path, TRUE, NULL, &End)) == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        *Handle = (ULONG64)Ext;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveExtension(
    THIS_
    IN ULONG64 Handle
    )
{
    ENTER_ENGINE();

    UnloadExtensionDll((EXTDLL*)Handle, FALSE);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetExtensionByPath(
    THIS_
    IN PCSTR Path,
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    EXTDLL* Ext;

    Status = E_NOINTERFACE;
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if ((!Ext->Target || Ext->Target == g_Target) &&
            !_strcmpi(Path, Ext->Name))
        {
            Status = S_OK;
            *Handle = (ULONG64)Ext;
            break;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CallExtension(
    THIS_
    IN OPTIONAL ULONG64 Handle,
    IN PCSTR Function,
    IN OPTIONAL PCSTR Arguments
    )
{
    char LocalFunc[MAX_COMMAND];
    ULONG Len;

    // Copy function name to temp buffer because it is
    // modified.
    Len = strlen(Function) + 1;
    if (Len > sizeof(LocalFunc))
    {
        return E_INVALIDARG;
    }
    memcpy(LocalFunc, Function, Len);

    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!CallAnyExtension(this, (EXTDLL*)Handle, LocalFunc, Arguments,
                               Handle != 0, TRUE, &Status))
    {
        Status = E_FAIL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetExtensionFunction(
    THIS_
    IN ULONG64 Handle,
    IN PCSTR FuncName,
    OUT FARPROC* Function
    )
{
    HRESULT Status;
    char ExpName[MAX_PATH + 16];

    if (strlen(FuncName) >= MAX_PATH)
    {
        return E_INVALIDARG;
    }

    // Keep the namespace for extension function exports
    // separate from the namespace for extension commands.
    // Extension commands are exported under the same
    // name as the command, so prefix extension functions
    // to make them obviously different and to avoid
    // name conflicts.
    strcpy(ExpName, "_EFN_");
    strcat(ExpName, FuncName);
    
    ENTER_ENGINE();

    EXTDLL* Ext;
    FARPROC Routine;

    Status = E_NOINTERFACE;
    if (Handle != 0)
    {
        Ext = (EXTDLL*)(ULONG_PTR)Handle;
    }
    else
    {
        Ext = g_ExtDlls;
    }
    while (Ext != NULL)
    {
        if ((!Ext->Target || Ext->Target == g_Target) &&
            LoadExtensionDll(g_Target, Ext))
        {
            Routine = GetProcAddress(Ext->Dll, ExpName);
            if (Routine != NULL)
            {
                Status = S_OK;
                *Function = Routine;
                break;
            }
        }

        // If the search was limited to a single extension stop looking.
        if (Handle != 0)
        {
            break;
        }

        Ext = Ext->Next;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetWindbgExtensionApis32(
    THIS_
    IN OUT PWINDBG_EXTENSION_APIS32 Api
    )
{
    if (Api->nSize != sizeof(*Api))
    {
        return E_INVALIDARG;
    }

    *Api = g_WindbgExtensions32;
    return S_OK;
}

STDMETHODIMP
DebugClient::GetWindbgExtensionApis64(
    THIS_
    IN OUT PWINDBG_EXTENSION_APIS64 Api
    )
{
    if (Api->nSize != sizeof(*Api))
    {
        return E_INVALIDARG;
    }

    *Api = g_WindbgExtensions64;
    return S_OK;
}

STDMETHODIMP
DebugClient::GetNumberEventFilters(
    THIS_
    OUT PULONG SpecificEvents,
    OUT PULONG SpecificExceptions,
    OUT PULONG ArbitraryExceptions
    )
{
    ENTER_ENGINE();

    *SpecificEvents = FILTER_SPECIFIC_LAST - FILTER_SPECIFIC_FIRST + 1;
    *SpecificExceptions = FILTER_EXCEPTION_LAST - FILTER_EXCEPTION_FIRST + 1;
    *ArbitraryExceptions = g_NumOtherExceptions;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetEventFilterText(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TextSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (Index >= FILTER_COUNT)
    {
        Status = E_NOINTERFACE;
    }
    else
    {
        Status = FillStringBuffer(g_EventFilters[Index].Name, 0,
                                  Buffer, BufferSize, TextSize);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetEitherEventFilterCommand(ULONG Index, ULONG Which,
                            PSTR Buffer, ULONG BufferSize, PULONG CommandSize)
{
    EVENT_COMMAND* EventCommand;

    if (Index < FILTER_COUNT)
    {
        EventCommand = &g_EventFilters[Index].Command;
    }
    else if ((Index - FILTER_COUNT) < g_NumOtherExceptions)
    {
        EventCommand = &g_OtherExceptionCommands[Index - FILTER_COUNT];
    }
    else
    {
        return E_NOINTERFACE;
    }

    return FillStringBuffer(EventCommand->Command[Which],
                            EventCommand->CommandSize[Which],
                            Buffer, BufferSize, CommandSize);
}

STDMETHODIMP
DebugClient::GetEventFilterCommand(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG CommandSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = GetEitherEventFilterCommand(Index, 0, Buffer, BufferSize,
                                         CommandSize);

    LEAVE_ENGINE();
    return Status;
}

HRESULT
SetEitherEventFilterCommand(DebugClient* Client, ULONG Index, ULONG Which,
                            PCSTR Command)
{
    EVENT_COMMAND* EventCommand;

    if (Index < FILTER_COUNT)
    {
        EventCommand = &g_EventFilters[Index].Command;
    }
    else if ((Index - FILTER_COUNT) < g_NumOtherExceptions)
    {
        EventCommand = &g_OtherExceptionCommands[Index - FILTER_COUNT];
    }
    else
    {
        return E_NOINTERFACE;
    }

    HRESULT Status;

    Status = ChangeString(&EventCommand->Command[Which],
                          &EventCommand->CommandSize[Which],
                          Command);
    if (Status == S_OK)
    {
        if (Index < FILTER_COUNT)
        {
            g_EventFilters[Index].Flags |= FILTER_CHANGED_COMMAND;
        }
        EventCommand->Client = Client;
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, Index, TRUE);
    }

    return Status;
}

STDMETHODIMP
DebugClient::SetEventFilterCommand(
    THIS_
    IN ULONG Index,
    IN PCSTR Command
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = SetEitherEventFilterCommand(this, Index, 0, Command);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSpecificFilterParameters(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
    )
{
    if (
#if FILTER_SPECIFIC_FIRST > 0
        Start < FILTER_SPECIFIC_FIRST ||
#endif
        Start > FILTER_SPECIFIC_LAST ||
        Start + Count > FILTER_SPECIFIC_LAST + 1)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    EVENT_FILTER* Filter;

    for (ULONG i = 0; i < Count; i++)
    {
        Filter = g_EventFilters + (Start + i);

        Params[i].ExecutionOption = Filter->Params.ExecutionOption;
        Params[i].ContinueOption = Filter->Params.ContinueOption;
        Params[i].TextSize = strlen(Filter->Name) + 1;
        Params[i].CommandSize = Filter->Command.CommandSize[0];
        Params[i].ArgumentSize = Filter->Argument != NULL ?
            strlen(Filter->Argument) + 1 : 0;
    }

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetSpecificFilterParameters(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    IN /* size_is(Count) */ PDEBUG_SPECIFIC_FILTER_PARAMETERS Params
    )
{
    if (
#if FILTER_SPECIFIC_FIRST > 0
        Start < FILTER_SPECIFIC_FIRST ||
#endif
        Start > FILTER_SPECIFIC_LAST ||
        Start + Count > FILTER_SPECIFIC_LAST + 1)
    {
        return E_INVALIDARG;
    }

    HRESULT Status = S_OK;
    ULONG Set = 0;
    ULONG SetIndex = 0;

    ENTER_ENGINE();

    for (ULONG i = 0; i < Count; i++)
    {
        if (
#if DEBUG_FILTER_BREAK > 0
            Params[i].ExecutionOption >= DEBUG_FILTER_BREAK &&
#endif
            Params[i].ExecutionOption <= DEBUG_FILTER_IGNORE &&
#if DEBUG_FILTER_GO_HANDLED > 0
            Params[i].ContinueOption >= DEBUG_FILTER_GO_HANDLED &&
#endif
            Params[i].ContinueOption <= DEBUG_FILTER_GO_NOT_HANDLED)
        {
            g_EventFilters[Start + i].Params.ExecutionOption =
                Params[i].ExecutionOption;
            g_EventFilters[Start + i].Params.ContinueOption =
                Params[i].ContinueOption;
            g_EventFilters[Start + i].Flags |=
                FILTER_CHANGED_EXECUTION | FILTER_CHANGED_CONTINUE;
            Set++;
            SetIndex = i;
        }
        else
        {
            Status = E_INVALIDARG;
        }
    }

    if (SyncOptionsWithFilters())
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS |
                                DEBUG_CES_ENGINE_OPTIONS,
                                DEBUG_ANY_ID, TRUE);
    }
    else if (Set == 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, SetIndex, TRUE);
    }
    else if (Set > 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, DEBUG_ANY_ID, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSpecificFilterArgument(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ArgumentSize
    )
{
    if (
#if FILTER_SPECIFIC_FIRST > 0
        Index < FILTER_SPECIFIC_FIRST ||
#endif
        Index > FILTER_SPECIFIC_LAST ||
        g_EventFilters[Index].Argument == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = FillStringBuffer(g_EventFilters[Index].Argument, 0,
                              Buffer, BufferSize, ArgumentSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSpecificFilterArgument(
    THIS_
    IN ULONG Index,
    IN PCSTR Argument
    )
{
    ULONG Len;

    if (Argument == NULL)
    {
        Len = 1;
    }
    else
    {
        Len = strlen(Argument) + 1;
    }

    if (
#if FILTER_SPECIFIC_FIRST > 0
        Index < FILTER_SPECIFIC_FIRST ||
#endif
        Index > FILTER_SPECIFIC_LAST ||
        g_EventFilters[Index].Argument == NULL ||
        Len > FILTER_MAX_ARGUMENT)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Argument == NULL)
    {
        g_EventFilters[Index].Argument[0] = 0;
    }
    else
    {
        memcpy(g_EventFilters[Index].Argument, Argument, Len);
    }
    if (Index == DEBUG_FILTER_UNLOAD_MODULE)
    {
        g_UnloadDllBase = EvalStringNumAndCatch(Argument);
    }

    NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, Index, TRUE);

    LEAVE_ENGINE();
    return S_OK;
}

void
GetExFilterParams(PCSTR Text,
                  PDEBUG_EXCEPTION_FILTER_PARAMETERS InParams,
                  EVENT_COMMAND* InCommand,
                  PDEBUG_EXCEPTION_FILTER_PARAMETERS OutParams)
{
    OutParams->ExecutionOption = InParams->ExecutionOption;
    OutParams->ContinueOption = InParams->ContinueOption;
    OutParams->TextSize = Text != NULL ? strlen(Text) + 1 : 0;
    OutParams->CommandSize = InCommand->CommandSize[0];
    OutParams->SecondCommandSize = InCommand->CommandSize[1];
    OutParams->ExceptionCode = InParams->ExceptionCode;
}

STDMETHODIMP
DebugClient::GetExceptionFilterParameters(
    THIS_
    IN ULONG Count,
    IN OPTIONAL /* size_is(Count) */ PULONG Codes,
    IN ULONG Start,
    OUT /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
    )
{
    HRESULT Status = S_OK;

    ENTER_ENGINE();

    ULONG i, Index;
    EVENT_FILTER* Filter;

    if (Codes != NULL)
    {
        for (i = 0; i < Count; i++)
        {
            // Is this a specific exception?
            Filter = g_EventFilters + FILTER_EXCEPTION_FIRST;
            for (Index = FILTER_EXCEPTION_FIRST;
                 Index <= FILTER_EXCEPTION_LAST;
                 Index++)
            {
                if (Filter->Params.ExceptionCode == Codes[i])
                {
                    GetExFilterParams(Filter->Name, &Filter->Params,
                                      &Filter->Command, Params + i);
                    break;
                }

                Filter++;
            }

            if (Index > FILTER_EXCEPTION_LAST)
            {
                // Is this an other exception?
                for (Index = 0; Index < g_NumOtherExceptions; Index++)
                {
                    if (g_OtherExceptionList[Index].ExceptionCode == Codes[i])
                    {
                        GetExFilterParams(NULL, g_OtherExceptionList + Index,
                                          g_OtherExceptionCommands + Index,
                                          Params + i);
                        break;
                    }
                }

                if (Index >= g_NumOtherExceptions)
                {
                    memset(Params + i, 0xff, sizeof(*Params));
                    Status = E_NOINTERFACE;
                }
            }
        }
    }
    else
    {
        for (i = 0; i < Count; i++)
        {
            Index = Start + i;

            // Is this a specific exception?
            if (Index >= FILTER_EXCEPTION_FIRST &&
                Index <= FILTER_EXCEPTION_LAST)
            {
                Filter = g_EventFilters + Index;
                GetExFilterParams(Filter->Name, &Filter->Params,
                                  &Filter->Command, Params + i);
            }
            // Is this an other exception?
            else if (Index >= FILTER_COUNT &&
                     Index < FILTER_COUNT + g_NumOtherExceptions)
            {
                GetExFilterParams(NULL, g_OtherExceptionList +
                                  (Index - FILTER_COUNT),
                                  g_OtherExceptionCommands +
                                  (Index - FILTER_COUNT),
                                  Params + i);
            }
            else
            {
                memset(Params + i, 0xff, sizeof(*Params));
                Status = E_INVALIDARG;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
SetExFilterParams(PDEBUG_EXCEPTION_FILTER_PARAMETERS InParams,
                  PDEBUG_EXCEPTION_FILTER_PARAMETERS OutParams)
{
    if (
#if DEBUG_FILTER_BREAK > 0
        InParams->ExecutionOption >= DEBUG_FILTER_BREAK &&
#endif
        InParams->ExecutionOption <= DEBUG_FILTER_IGNORE &&
#if DEBUG_FILTER_GO_HANDLED > 0
        InParams->ContinueOption >= DEBUG_FILTER_GO_HANDLED &&
#endif
        InParams->ContinueOption <= DEBUG_FILTER_GO_NOT_HANDLED)
    {
        OutParams->ExecutionOption = InParams->ExecutionOption;
        OutParams->ContinueOption = InParams->ContinueOption;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT
SetOtherExFilterParams(PDEBUG_EXCEPTION_FILTER_PARAMETERS InParams,
                       ULONG OutIndex, PULONG Set, PULONG SetIndex)
{
    HRESULT Status;

    if (OutIndex < g_NumOtherExceptions)
    {
        if (InParams->ExecutionOption == DEBUG_FILTER_REMOVE)
        {
            RemoveOtherException(OutIndex);
            *Set += 2;
            Status = S_OK;
        }
        else
        {
            Status = SetExFilterParams(InParams,
                                       g_OtherExceptionList + OutIndex);
            if (Status == S_OK)
            {
                (*Set)++;
                *SetIndex = OutIndex + FILTER_COUNT;
            }
        }
    }
    else
    {
        if (g_NumOtherExceptions == OTHER_EXCEPTION_LIST_MAX)
        {
            Status = E_OUTOFMEMORY;
        }
        else
        {
            OutIndex = g_NumOtherExceptions;
            g_OtherExceptionList[OutIndex].ExceptionCode =
                InParams->ExceptionCode;
            Status = SetExFilterParams(InParams,
                                       g_OtherExceptionList + OutIndex);
            if (Status == S_OK)
            {
                ZeroMemory(&g_OtherExceptionCommands[OutIndex],
                           sizeof(g_OtherExceptionCommands[OutIndex]));
                g_NumOtherExceptions++;
                (*Set)++;
                *SetIndex = OutIndex + FILTER_COUNT;
            }
        }
    }

    return Status;
}

STDMETHODIMP
DebugClient::SetExceptionFilterParameters(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PDEBUG_EXCEPTION_FILTER_PARAMETERS Params
    )
{
    HRESULT Status = S_OK;

    ENTER_ENGINE();

    ULONG i, Index;
    EVENT_FILTER* Filter;
    ULONG Set = 0;
    ULONG SetIndex = 0;

    for (i = 0; i < Count; i++)
    {
        // Is this a specific exception?
        Filter = g_EventFilters + FILTER_EXCEPTION_FIRST;
        for (Index = FILTER_EXCEPTION_FIRST;
             Index <= FILTER_EXCEPTION_LAST;
             Index++)
        {
            if (Filter->Params.ExceptionCode == Params[i].ExceptionCode)
            {
                Status = SetExFilterParams(Params + i, &Filter->Params);
                if (Status == S_OK)
                {
                    Filter->Flags |= FILTER_CHANGED_EXECUTION |
                        FILTER_CHANGED_CONTINUE;
                    Set++;
                    SetIndex = Index;
                }
                break;
            }

            Filter++;
        }

        if (Index > FILTER_EXCEPTION_LAST)
        {
            // Is this an other exception?
            for (Index = 0; Index < g_NumOtherExceptions; Index++)
            {
                if (g_OtherExceptionList[Index].ExceptionCode ==
                    Params[i].ExceptionCode)
                {
                    break;
                }
            }

            Status = SetOtherExFilterParams(Params + i, Index,
                                            &Set, &SetIndex);
        }
    }

    if (Set == 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, SetIndex, TRUE);
    }
    else if (Set > 1)
    {
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, DEBUG_ANY_ID, TRUE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetExceptionFilterSecondCommand(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG CommandSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = GetEitherEventFilterCommand(Index, 1, Buffer, BufferSize,
                                         CommandSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetExceptionFilterSecondCommand(
    THIS_
    IN ULONG Index,
    IN PCSTR Command
    )
{
    if (Index <= FILTER_SPECIFIC_LAST)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    Status = SetEitherEventFilterCommand(this, Index, 1, Command);

    LEAVE_ENGINE();
    return Status;
}

HRESULT
WaitForAnyTarget(ULONG Flags, ULONG Timeout, ULONG EventPoss,
                 ULONG ElapsedTime, PULONG EventStatus)
{
    HRESULT Status;
    TargetInfo* Target;

    if (EventPoss == 1)
    {
        // If there's only one source find it and do a simple wait on it.
        ForAllLayersToTarget()
        {
            if (Target->m_EventPossible)
            {
                Status = Target->
                    WaitForEvent(Flags, Timeout,
                                 ElapsedTime - Target->m_WaitTimeBase,
                                 EventStatus);
                Target->m_FirstWait = FALSE;
                return Status;
            }
        }

        return E_UNEXPECTED;
    }
    
    for (;;)
    {
        //
        // Poll all the available sources for an event.
        // A zero timeout is used to get through them as
        // quickly as possible so events are picked up right away.
        //

        // Sanity check the number of possible sources to
        // avoid an infinite loop if something gets confused.
        EventPoss = 0;
        
        ForAllLayersToTarget()
        {
            if (!Target->m_EventPossible)
            {
                continue;
            }

            EventPoss++;
            
            Status = Target->
                WaitForEvent(Flags, 0,
                             ElapsedTime - Target->m_WaitTimeBase,
                             EventStatus);
            Target->m_FirstWait = FALSE;
            if (Status != S_FALSE)
            {
                return Status;
            }

            // If we've exhausted the timeout period return
            // with a no-event status.
            if (Timeout == 0)
            {
                return S_FALSE;
            }
            
            //
            // No source had an event, so sleep for a little while.
            //
            
            ULONG UseTimeout = 500;
            if (Timeout != INFINITE && UseTimeout > Timeout)
            {
                UseTimeout = Timeout;
            }

            SUSPEND_ENGINE();

            Sleep(UseTimeout);
        
            RESUME_ENGINE();

            if (Timeout != INFINITE)
            {
                Timeout -= UseTimeout;
                // Let the loop poll for events one more time
                // before checking for a completed timeout.
            }
        }

        if (!EventPoss)
        {
            // For some reason there are no longer any
            // event sources.
            return E_UNEXPECTED;
        }
    }
}

HRESULT
RawWaitForEvent(ULONG Flags, ULONG Timeout)
{
    HRESULT Status;
    ULONG ContinueStatus;

    Status = PrepareForWait(Flags, &ContinueStatus);
    if ((g_EngStatus & ENG_STATUS_WAITING) == 0)
    {
        // An error occurred or some kind of synthesized
        // event is being returned.
        goto Exit;
    }

    EventOut("> Executing\n");

    BOOL FirstLoop = TRUE;
    ULONG ElapsedTime = 0;
    
    for (;;)
    {
        EventOut(">> Waiting, %d elapsed\n", ElapsedTime);

        TargetInfo* Target;
        ULONG EventPoss = 0;
        ULONG DesiredTimeout;
        ULONG UseTimeout = Timeout;
    
        ForAllLayersToTarget()
        {
            if (FirstLoop)
            {
                Target->m_WaitTimeBase = 0;
            }
            
            if ((Status = Target->
                 WaitInitialize(Flags, Timeout,
                                FirstLoop ? WINIT_FIRST : WINIT_NOT_FIRST,
                                &DesiredTimeout)) != S_OK)
            {
                goto Calls;
            }

            if (Target->m_EventPossible)
            {
                EventPoss++;
                UseTimeout = min(UseTimeout, DesiredTimeout);
            }
        }

        if (!EventPoss)
        {
            DiscardTargets(DEBUG_SESSION_END);
            Status = E_UNEXPECTED;
            goto Calls;
        }

        FirstLoop = FALSE;
        
        g_EngStatus &= ~ENG_STATUS_SPECIAL_EXECUTION;
        
        // Don't process deferred work if this is
        // just a processor switch.
        if (g_CmdState != 's')
        {
            ProcessDeferredWork(&ContinueStatus);
        }

        if (g_EventTarget)
        {
            EventOut(">> Continue with %X\n", ContinueStatus);
            
            if ((Status = g_EventTarget->
                 ReleaseLastEvent(ContinueStatus)) != S_OK)
            {
                goto Calls;
            }

            Target = g_EventTarget;
        }
        
        DiscardLastEvent();
        g_EventTarget = NULL;
        
        g_EngStatus &= ~ENG_STATUS_WAIT_SUCCESSFUL;

        ULONG EventStatus;

        if (g_EngStatus & ENG_STATUS_SPECIAL_EXECUTION)
        {
            // If this is special, directed execution we can only wait on
            // the target that needs special execution.
            Status = Target->
                WaitForEvent(Flags, UseTimeout,
                             ElapsedTime - Target->m_WaitTimeBase,
                             &EventStatus);
            Target->m_FirstWait = FALSE;
        }
        else
        {
            Status = WaitForAnyTarget(Flags, UseTimeout, EventPoss,
                                      ElapsedTime, &EventStatus);
        }

        if (UseTimeout != INFINITE)
        {
            ElapsedTime += UseTimeout;
        }
        
        if (Timeout != INFINITE)
        {
            Timeout -= UseTimeout;
        }
        if (Status == S_FALSE && Timeout > 0)
        {
            // Everything timed out but we were using a
            // timeout smaller than the caller's overall
            // timeout, so loop around and keep waiting.
            continue;
        }
        
        if (Status != S_OK)
        {
            goto Calls;
        }
        
        if (EventStatus != DEBUG_STATUS_NO_DEBUGGEE)
        {
            g_EngStatus |= ENG_STATUS_WAIT_SUCCESSFUL;
        }

        // Successfully retrieved an event so reset the timeout count.
        ElapsedTime = 0;
        ForAllLayersToTarget()
        {
            Target->m_WaitTimeBase = 0;
        }
        
        EventOut(">>> Event status %X\n", EventStatus);
        
        if (EventStatus == DEBUG_STATUS_NO_DEBUGGEE)
        {
            // Machine has rebooted or something else
            // which breaks the connection.  Forget the
            // connection and go back to waiting.
            ContinueStatus = DBG_CONTINUE;
        }
        else if (EventStatus == DEBUG_STATUS_BREAK ||
                 (g_EngStatus & ENG_STATUS_SPECIAL_EXECUTION))
        {
            // If the event handlers requested a break return
            // to the caller.  This path is also taken
            // during special execution to guarantee that
            // the target doesn't start running when the
            // engine is just executing for internal purposes.
            Status = S_OK;
            goto Calls;
        }
        else
        {
            // We're resuming execution so reverse any
            // command preparation that may have occurred
            // while processing the event.
            if ((Status = PrepareForExecution(EventStatus)) != S_OK)
            {
                goto Calls;
            }
        
            ContinueStatus = EventStatusToContinue(EventStatus);
        }
    }

 Calls:
    g_EngStatus &= ~ENG_STATUS_WAITING;

    // Control is passing back to the caller so the engine must
    // be ready for command processing.
    PrepareForCalls(0);

    // If we did switch processors automatically
    // update the page directory for the new processor.
    if (IS_KERNEL_TARGET(g_EventTarget) &&
        (g_EngStatus & ENG_STATUS_SPECIAL_EXECUTION) &&
        g_EventTarget)
    {
        if (g_EventTarget->m_Machine->
            SetDefaultPageDirectories(g_EventThread, PAGE_DIR_ALL) != S_OK)
        {
            WarnOut("WARNING: Unable to reset page directories\n");
        }
    }
    
    g_EngStatus &= ~ENG_STATUS_SPECIAL_EXECUTION;

 Exit:
    EventOut("> Wait returning %X\n", Status);
    return Status;
}

STDMETHODIMP
DebugClient::WaitForEvent(
    THIS_
    IN ULONG Flags,
    IN ULONG Timeout
    )
{
    if (Flags != DEBUG_WAIT_DEFAULT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    // If there's an outstanding request for input don't wait
    // as it's very unlikely that the other thread
    // can handle such an engine change.
    if (g_InputNesting >= 1 ||
        ::GetCurrentThreadId() != g_SessionThread ||
        (g_EngStatus & ENG_STATUS_STOP_SESSION))
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    // If the caller is trying to force the engine to
    // stop waiting return immediately.
    if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
    {
        Status = E_PENDING;
        goto Exit;
    }
    
    // This constitutes interesting activity.
    m_LastActivity = time(NULL);

    if (g_EngStatus & ENG_STATUS_WAITING)
    {
        Status = E_FAIL;
        goto Exit;
    }

    Status = RawWaitForEvent(Flags, Timeout);
    
 Exit:
    g_EngStatus &= ~ENG_STATUS_EXIT_CURRENT_WAIT;
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetLastEventInformation(
    THIS_
    OUT PULONG Type,
    OUT PULONG ProcessId,
    OUT PULONG ThreadId,
    OUT OPTIONAL PVOID ExtraInformation,
    IN ULONG ExtraInformationSize,
    OUT OPTIONAL PULONG ExtraInformationUsed,
    OUT OPTIONAL PSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG DescriptionUsed
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    *Type = g_LastEventType;

    if (g_EventProcess != NULL)
    {
        *ProcessId = g_EventProcess->m_UserId;
        *ThreadId = g_EventThread->m_UserId;
    }
    else
    {
        *ProcessId = DEBUG_ANY_ID;
        *ThreadId = DEBUG_ANY_ID;
    }

    Status = FillDataBuffer(g_LastEventExtraData, g_LastEventExtraDataSize,
                            ExtraInformation, ExtraInformationSize,
                            ExtraInformationUsed);
    if (FillStringBuffer(g_LastEventDesc, 0,
                         Description, DescriptionSize,
                         DescriptionUsed) == S_FALSE)
    {
        Status = S_FALSE;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentTimeDate(
    THIS_
    OUT PULONG TimeDate
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *TimeDate =
            FileTimeToTimeDateStamp(g_Target->GetCurrentTimeDateN());
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentSystemUpTime(
    THIS_
    OUT PULONG UpTime
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *UpTime =
            FileTimeToTime(g_Target->GetCurrentSystemUpTimeN());
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDumpFormatFlags(
    THIS_
    OUT PULONG FormatFlags
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_DUMP_TARGET(g_Target))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *FormatFlags = ((DumpTargetInfo*)g_Target)->m_FormatFlags;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberTextReplacements(
    THIS_
    OUT PULONG NumRepl
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    *NumRepl = g_NumAliases;
    Status = S_OK;
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTextReplacement(
    THIS_
    IN OPTIONAL PCSTR SrcText,
    IN ULONG Index,
    OUT OPTIONAL PSTR SrcBuffer,
    IN ULONG SrcBufferSize,
    OUT OPTIONAL PULONG SrcSize,
    OUT OPTIONAL PSTR DstBuffer,
    IN ULONG DstBufferSize,
    OUT OPTIONAL PULONG DstSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    PALIAS Scan = g_AliasListHead;

    while (Scan != NULL &&
           ((SrcText != NULL && strcmp(SrcText, Scan->Name)) ||
            (SrcText == NULL && Index-- > 0)))
    {
        Scan = Scan->Next;
    }

    if (Scan != NULL)
    {
        Status = FillStringBuffer(Scan->Name, 0,
                                  SrcBuffer, SrcBufferSize, SrcSize);
        if (FillStringBuffer(Scan->Value, 0,
                             DstBuffer, DstBufferSize, DstSize) == S_FALSE)
        {
            Status = S_FALSE;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetTextReplacement(
    THIS_
    IN PCSTR SrcText,
    IN OPTIONAL PCSTR DstText
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (DstText != NULL)
    {
        Status = SetAlias(SrcText, DstText);
    }
    else
    {
        Status = DeleteAlias(SrcText);
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveTextReplacements(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = DeleteAlias("*");
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputTextReplacements(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ListAliases();
    Status = S_OK;
    
    LEAVE_ENGINE();
    return Status;
}

#define ASMOPT_ALL \
    (DEBUG_ASMOPT_VERBOSE | \
     DEBUG_ASMOPT_NO_CODE_BYTES | \
     DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH)

STDMETHODIMP
DebugClient::GetAssemblyOptions(
    THIS_
    OUT PULONG Options
    )
{
    ENTER_ENGINE();

    *Options = g_AsmOptions;
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::AddAssemblyOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ASMOPT_ALL)
    {
        return E_INVALIDARG;
    }
    
    ENTER_ENGINE();

    g_AsmOptions |= Options;
    NotifyChangeEngineState(DEBUG_CES_ASSEMBLY_OPTIONS, g_AsmOptions, TRUE);
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::RemoveAssemblyOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ASMOPT_ALL)
    {
        return E_INVALIDARG;
    }
    
    ENTER_ENGINE();

    g_AsmOptions &= ~Options;
    NotifyChangeEngineState(DEBUG_CES_ASSEMBLY_OPTIONS, g_AsmOptions, TRUE);
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetAssemblyOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ASMOPT_ALL)
    {
        return E_INVALIDARG;
    }
    
    ENTER_ENGINE();

    g_AsmOptions = Options;
    NotifyChangeEngineState(DEBUG_CES_ASSEMBLY_OPTIONS, g_AsmOptions, TRUE);
    
    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::GetExpressionSyntax(
    THIS_
    OUT PULONG Flags
    )
{
    ENTER_ENGINE();

    *Flags = g_EvalSyntax;
    
    LEAVE_ENGINE();
    return S_OK;
}

HRESULT
SetExprSyntax(ULONG Flags)
{
    if (Flags >= EVAL_COUNT)
    {
        return E_INVALIDARG;
    }

    g_EvalSyntax = Flags;

    NotifyChangeEngineState(DEBUG_CES_EXPRESSION_SYNTAX, Flags, TRUE);
    return S_OK;
}

STDMETHODIMP
DebugClient::SetExpressionSyntax(
    THIS_
    IN ULONG Flags
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ::SetExprSyntax(Flags);
    
    LEAVE_ENGINE();
    return Status;
}

HRESULT
SetExprSyntaxByName(PCSTR Name)
{
    HRESULT Status;
    EvalExpression* Eval;

    if ((Status = GetEvaluatorByName(Name, TRUE, &Eval)) != S_OK)
    {
        return Status;
    }
    
    SetExprSyntax(Eval->m_Syntax);
    ReleaseEvaluator(Eval);
    return S_OK;
}

STDMETHODIMP
DebugClient::SetExpressionSyntaxByName(
    THIS_
    IN PCSTR AbbrevName
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    Status = ::SetExprSyntaxByName(AbbrevName);
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberExpressionSyntaxes(
    THIS_
    OUT PULONG Number
    )
{
    *Number = EVAL_COUNT;
    return S_OK;
}

STDMETHODIMP
DebugClient::GetExpressionSyntaxNames(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR FullNameBuffer,
    IN ULONG FullNameBufferSize,
    OUT OPTIONAL PULONG FullNameSize,
    OUT OPTIONAL PSTR AbbrevNameBuffer,
    IN ULONG AbbrevNameBufferSize,
    OUT OPTIONAL PULONG AbbrevNameSize
    )
{
    if (Index >= EVAL_COUNT)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    EvalExpression* Eval = GetEvaluator(Index, TRUE);
    if (!Eval)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        Status = FillStringBuffer(Eval->m_FullName, 0,
                                  FullNameBuffer, FullNameBufferSize,
                                  FullNameSize);
        if (FillStringBuffer(Eval->m_AbbrevName, 0,
                             AbbrevNameBuffer, AbbrevNameBufferSize,
                             AbbrevNameSize) == S_FALSE)
        {
            Status = S_FALSE;
        }

        ReleaseEvaluator(Eval);
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberEvents(
    THIS_
    OUT PULONG Events
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Events = g_Target->m_NumEvents;
        Status = g_Target->m_DynamicEvents ? S_FALSE : S_OK;
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEventIndexDescription(
    THIS_
    IN ULONG Index,
    IN ULONG Which,
    IN OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DescSize
    )
{
    HRESULT Status;

    if (Which != DEBUG_EINDEX_NAME)
    {
        return E_INVALIDARG;
    }
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else if (Index > g_Target->m_NumEvents)
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = g_Target->
            GetEventIndexDescription(Index, Which,
                                     Buffer, BufferSize, DescSize);
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentEventIndex(
    THIS_
    OUT PULONG Index
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Index = g_Target->m_EventIndex;
        Status = S_OK;
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetNextEventIndex(
    THIS_
    IN ULONG Relation,
    IN ULONG Value,
    OUT PULONG NextIndex
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_MACHINE_SET(g_Target) ||
        IS_RUNNING(g_CmdState))
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    switch(Relation)
    {
    case DEBUG_EINDEX_FROM_START:
        // Value is start index.
        if (Value >= g_Target->m_NumEvents)
        {
            Status = E_INVALIDARG;
            goto Exit;
        }
        break;
    case DEBUG_EINDEX_FROM_END:
        // Value is end index.
        if (Value >= g_Target->m_NumEvents)
        {
            Status = E_INVALIDARG;
            goto Exit;
        }
        Value = g_Target->m_NumEvents - Value - 1;
        break;
    case DEBUG_EINDEX_FROM_CURRENT:
        if ((LONG)Value < 0)
        {
            Value = -(LONG)Value;
            if (Value > g_Target->m_EventIndex)
            {
                Status = E_INVALIDARG;
                goto Exit;
            }

            Value = g_Target->m_EventIndex - Value;
        }
        else
        {
            if (Value >= g_Target->m_NumEvents - g_Target->m_EventIndex)
            {
                Status = E_INVALIDARG;
                goto Exit;
            }

            Value = g_Target->m_EventIndex + Value;
        }
        break;
    default:
        Status = E_INVALIDARG;
        goto Exit;
    }

    if (g_Target->m_EventIndex != Value)
    {
        g_Target->m_NextEventIndex = Value;
        g_CmdState = 'e';
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS, DEBUG_STATUS_GO,
                                TRUE);
    }
    *NextIndex = Value;

    Status = S_OK;
    
 Exit:
    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgdata.cpp ===
//----------------------------------------------------------------------------
//
// IDebugDataSpaces implementations.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//----------------------------------------------------------------------------
//
// TargetInfo data space methods.
//
//----------------------------------------------------------------------------

void
TargetInfo::NearestDifferentlyValidOffsets(ULONG64 Offset,
                                           PULONG64 NextOffset,
                                           PULONG64 NextPage)
{
    //
    // In the default case we assume that address validity
    // is controlled on a per-page basis so the next possibly
    // valid page and offset are both the offset of the next
    // page.
    //
    
    ULONG64 Page = NEXT_PAGE(m_Machine, Offset);
    if (NextOffset != NULL)
    {
        *NextOffset = Page;
    }
    if (NextPage != NULL)
    {
        *NextPage = Page;
    }
}

HRESULT
TargetInfo::ReadVirtualUncached(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    return ReadVirtual(Process, Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
TargetInfo::WriteVirtualUncached(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    return WriteVirtual(Process, Offset, Buffer, BufferSize, BytesWritten);
}

// #define DBG_SEARCH

HRESULT
TargetInfo::SearchVirtual(
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    IN ULONG PatternGranularity,
    OUT PULONG64 MatchOffset
    )
{
    HRESULT Status;
    ULONG64 SearchEnd;
    UCHAR Buffer[4096];
    PUCHAR Buf, Pat, BufEnd, PatEnd;
    ULONG ReadLen;
    ULONG64 BufOffset;
    ULONG64 PatOffset;
    ULONG64 StartOffset;

    SearchEnd = Offset + Length;
    Buf = Buffer;
    BufEnd = Buffer;
    Pat = (PUCHAR)Pattern;
    PatEnd = Pat + PatternSize;
    ReadLen = Length < sizeof(Buffer) ? (ULONG)Length : sizeof(Buffer);
    BufOffset = Offset;
    PatOffset = Offset;
    StartOffset = Offset;

#ifdef DBG_SEARCH
    g_NtDllCalls.DbgPrint("Search %d bytes from %I64X to %I64X, gran %X\n",
                          PatternSize, Offset, SearchEnd - 1,
                          Granularity);
#endif
    
    for (;;)
    {
#ifdef DBG_SEARCH_VERBOSE
        g_NtDllCalls.DbgPrint("  %I64X: matched %d\n",
                              Offset + (Buf - Buffer),
                              (ULONG)(Pat - (PUCHAR)Pattern));
#endif
        
        if (Pat == PatEnd)
        {
            // Made it to the end of the pattern so there's
            // a match.
            *MatchOffset = PatOffset;
            Status = S_OK;
            break;
        }

        if (Buf >= BufEnd)
        {
            ULONG Read;

            // Ran out of buffered memory so get some more.
            for (;;)
            {
                if (CheckUserInterrupt())
                {
                    WarnOut("-- Memory search interrupted at %s\n",
                            FormatAddr64(Offset));
                    Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
                    goto Exit;
                }

                if (Offset >= SearchEnd)
                {
                    // Return a result code that's specific and
                    // consistent with the kernel version.
                    Status = HRESULT_FROM_NT(STATUS_NO_MORE_ENTRIES);
                    goto Exit;
                }

                Status = ReadVirtual(Process, Offset, Buffer, ReadLen, &Read);

#ifdef DBG_SEARCH
                g_NtDllCalls.DbgPrint("  Read %X bytes at %I64X, ret %X:%X\n",
                                      ReadLen, Offset,
                                      Status, Read);
#endif
                
                if (Status != S_OK)
                {
                    // Skip to the start of the next page.
                    NearestDifferentlyValidOffsets(Offset, NULL, &Offset);
                    // Restart search due to the address discontinuity.
                    Pat = (PUCHAR)Pattern;
                    PatOffset = Offset;
                }
                else
                {
                    break;
                }
            }

            Buf = Buffer;
            BufEnd = Buffer + Read;
            BufOffset = Offset;
            Offset += Read;
        }

        // If this is the first byte of the pattern it
        // must match on a granularity boundary.
        if (*Buf++ == *Pat &&
            (Pat != (PUCHAR)Pattern ||
             (((PatOffset - StartOffset) % PatternGranularity) == 0)))
        {
            Pat++;
        }
        else
        {
            Buf -= Pat - (PUCHAR)Pattern;
            Pat = (PUCHAR)Pattern;
            PatOffset = BufOffset + (Buf - Buffer);
        }
    }

 Exit:
    return Status;
}

ULONG
HammingDistance(ULONG64 Left, ULONG64 Right, ULONG WordLength)
{
    ULONG64 Value;
    ULONG Index;
    ULONG Distance;

    Value = Left ^ Right;
    Distance = 0;

    for (Index = 0; Index < 8 * WordLength; Index++)
    {
        if ((Value & 1))
        {
            Distance++;
        }

        Value >>= 1;
    }

    return Distance;
}

HRESULT
TargetInfo::PointerSearchPhysical(
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN ULONG64 PointerMin,
    IN ULONG64 PointerMax,
    IN ULONG Flags,
    OUT PULONG64 MatchOffsets,
    IN ULONG MatchOffsetsSize,
    OUT PULONG MatchOffsetsCount
    )
{
    HRESULT Status;
    ULONG ReadSize;

    if (Flags & PTR_SEARCH_PHYS_PTE)
    {
        ReadSize = m_TypeInfo.SizePte;
    }
    else
    {
        if (m_Machine->m_Ptr64)
        {
            ReadSize = 8;
        }
        else
        {
            ReadSize = 4;
            PointerMin &= 0xffffffff;
            PointerMax &= 0xffffffff;
        }
    }
    
    // Make sure things are aligned properly.
    if ((Offset & (ReadSize - 1)) ||
        (Length & (ReadSize - 1)))
    {
        return E_INVALIDARG;
    }

    ULONG Hits;

    Hits = 0;
    Status = S_OK;
    
    while (Length > 0)
    {
        ULONG64 Data;
        BOOL Hit;

        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
        {
            Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
            // Leave the interrupt flag on so that !search
            // interrupts itself.
        }

        Data = 0;
        if ((Status = ReadAllPhysical(Offset, &Data, ReadSize)) != S_OK)
        {
            return Status;
        }

        Hit = FALSE;
        
        if (Flags & PTR_SEARCH_PHYS_PTE)
        {
            ULONG64 Pfn;
            ULONG PteFlags;

            m_Machine->DecodePte(Data, &Pfn, &PteFlags);
            if (Pfn == PointerMin)
            {
                Hit = TRUE;
            }
        }
        else
        {
            if ((Data >= PointerMin && Data <= PointerMax) ||
                HammingDistance(Data, PointerMin, ReadSize) == 1)
            {
                Hit = TRUE;
            }
        }

        if (Hit)
        {
            if (Hits < MatchOffsetsSize)
            {
                MatchOffsets[Hits] = Offset;
            }
            
            Hits++;

            if (!(Flags & PTR_SEARCH_PHYS_ALL_HITS))
            {
                ULONG64 ToNextPage;
                
                //
                // The caller has asked for just the first
                // hit per page, so we can skip to the next page.
                //

                ToNextPage = NEXT_PAGE(m_Machine, Offset);
                if (ToNextPage == 0)
                {
                    // Wrapped around, so we're done.
                    break;
                }
                ToNextPage -= Offset;
                if (ToNextPage > Length)
                {
                    ToNextPage = Length;
                }
                Offset += ToNextPage;
                Length -= ToNextPage;
                continue;
            }
        }
        
        Offset += ReadSize;
        Length -= ReadSize;
    }

    if (MatchOffsetsCount)
    {
        *MatchOffsetsCount = Hits;
    }

    return Status;
}

HRESULT
TargetInfo::ReadPhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesRead
    )
{
    return ReadPhysical(Offset, Buffer, BufferSize, Flags, BytesRead);
}

HRESULT
TargetInfo::WritePhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesWritten
    )
{
    return WritePhysical(Offset, Buffer, BufferSize, Flags, BytesWritten);
}

HRESULT
TargetInfo::ReadHandleData(
    IN ProcessInfo* Process,
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    // Base implementation which silently fails for modes
    // where there is no way to retrieve handle data.
    return E_UNEXPECTED;
}

HRESULT
TargetInfo::FillVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status = S_OK;
    PUCHAR Pat = (PUCHAR)Pattern;
    PUCHAR PatEnd = Pat + PatternSize;

    *Filled = 0;
    while (Size-- > 0)
    {
        ULONG Done;
        
        if (CheckUserInterrupt())
        {
            dprintf("User interrupt during fill - exiting.\n");
            Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
            *Filled = 0;
            break;
        }
        
        if ((Status = WriteVirtual(Process, Start, Pat, 1, &Done)) != S_OK)
        {
            break;
        }
        if (Done != 1)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            break;
        }

        Start++;
        if (++Pat == PatEnd)
        {
            Pat = (PUCHAR)Pattern;
        }
        (*Filled)++;
    }

    // If nothing was filled return an error, otherwise
    // consider it a success.
    return *Filled > 0 ? S_OK : Status;
}

HRESULT
TargetInfo::FillPhysical(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status = S_OK;
    PUCHAR Pat = (PUCHAR)Pattern;
    PUCHAR PatEnd = Pat + PatternSize;

    *Filled = 0;
    while (Size-- > 0)
    {
        ULONG Done;
        
        if (CheckUserInterrupt())
        {
            dprintf("User interrupt during fill - exiting.\n");
            Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
            *Filled = 0;
            break;
        }
        
        if ((Status = WritePhysical(Start, Pat, 1, PHYS_FLAG_DEFAULT,
                                    &Done)) != S_OK)
        {
            break;
        }
        if (Done != 1)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            break;
        }

        Start++;
        if (++Pat == PatEnd)
        {
            Pat = (PUCHAR)Pattern;
        }
        (*Filled)++;
    }

    // If nothing was filled return an error, otherwise
    // consider it a success.
    return *Filled > 0 ? S_OK : Status;
}

HRESULT
TargetInfo::GetProcessorId(ULONG Processor,
                           PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    // Base implementation which silently fails for modes
    // where the ID cannot be retrieved.
    return E_UNEXPECTED;
}

HRESULT
TargetInfo::GetProcessorSpeed(ULONG Processor,
                              PULONG Speed)
{
    // Base implementation which silently fails for modes
    // where the speed cannot be retrieved.
    return E_UNEXPECTED;
}

HRESULT
TargetInfo::GetGenericProcessorFeatures(
    ULONG Processor,
    PULONG64 Features,
    ULONG FeaturesSize,
    PULONG Used
    )
{
    // Base implementation which silently fails for modes
    // where the information cannot be retrieved.
    return E_UNEXPECTED;
}

HRESULT
TargetInfo::GetSpecificProcessorFeatures(
    ULONG Processor,
    PULONG64 Features,
    ULONG FeaturesSize,
    PULONG Used
    )
{
    // Base implementation which silently fails for modes
    // where the information cannot be retrieved.
    return E_UNEXPECTED;
}

HRESULT
TargetInfo::GetTaggedBaseOffset(PULONG64 Offset)
{
    // Base implementation silently fails for
    // targets with no tagged data.
    return E_NOINTERFACE;
}

HRESULT
TargetInfo::ReadTagged(ULONG64 Offset, PVOID Buffer, ULONG BufferSize)
{
    // Base implementation silently fails for
    // targets with no tagged data.
    return E_NOINTERFACE;
}

HRESULT
TargetInfo::ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                         PVOID Buffer, ULONG Size)
{
    // Default implementation for targets which do not
    // support reading the page file.
    return HR_PAGE_NOT_AVAILABLE;
}

HRESULT
TargetInfo::GetUnloadedModuleListHead(ProcessInfo* Process, PULONG64 Head)
{
    // Get the address of the dynamic function table list head which is the
    // the same for all processes. This only has to be done once.

    if (Process->m_RtlUnloadList)
    {
        *Head = Process->m_RtlUnloadList;
        return S_OK;
    }
    
    GetOffsetFromSym(Process, "ntdll!RtlpUnloadEventTrace",
                     &Process->m_RtlUnloadList, NULL);
    if (!Process->m_RtlUnloadList)
    {
        // No error message here as it's a common case when
        // symbols are bad.
        return E_NOINTERFACE;
    }

    *Head = Process->m_RtlUnloadList;
    return S_OK;
}

HRESULT
TargetInfo::GetFunctionTableListHead(ProcessInfo* Process, PULONG64 Head)
{
    // Get the address of the dynamic function table list head which is the
    // the same for all processes. This only has to be done once.

    if (Process->m_DynFuncTableList)
    {
        *Head = Process->m_DynFuncTableList;
        return S_OK;
    }
    
    GetOffsetFromSym(Process, "ntdll!RtlpDynamicFunctionTable",
                     &Process->m_DynFuncTableList, NULL);
    if (!Process->m_DynFuncTableList)
    {
        // No error message here as it's a common case when
        // symbols are bad.
        return E_NOINTERFACE;
    }

    *Head = Process->m_DynFuncTableList;
    return S_OK;
}

// These procedures support dynamic function table entries for user-mode
// run-time code. Dynamic function tables are stored in a linked list
// inside ntdll. The address of the linked list head is returned by
// RtlGetFunctionTableListHead. Since dynamic function tables are
// only supported in user-mode the address of the list head will be
// the same in all processes. Dynamic function tables are very rare,
// so in most cases this the list will be unitialized and this routine
// will return NULL. dbghelp only calls this when it
// is unable to find a function entry in any of the images.

PVOID
TargetInfo::FindDynamicFunctionEntry(ProcessInfo* Process, ULONG64 Address)
{
    ULONG64 ListHeadAddr;
    LIST_ENTRY64 DynamicFunctionTableHead;
    ULONG64 Entry;

    if (GetFunctionTableListHead(Process, &ListHeadAddr) != S_OK)
    {
        return NULL;
    }
    
    // Read the dynamic function table list head

    if (ReadListEntry(Process, m_Machine, ListHeadAddr,
                      &DynamicFunctionTableHead) != S_OK)
    {
        // This failure happens almost all the time in minidumps
        // because the function table list symbol can be resolved
        // but the memory isn't part of the minidump.
        if (!IS_USER_MINI_DUMP(this))
        {
            ErrOut("Unable to read dynamic function table list head\n");
        }
        return NULL;
    }

    Entry = DynamicFunctionTableHead.Flink;

    // The list head is initialized the first time it's used so check
    // for an uninitialized pointers. This is the most common result.

    if (Entry == 0)
    {
        return NULL;
    }

    // Loop through the dynamic function table list reading the headers.
    // If the range of a dynamic function table contains Address then
    // search the function table. Dynamic function table ranges are not
    // mututally exclusive like those in images so an address may be
    // in more than one range. However, there can be only one dynamic function
    // entry that contains the address (if there are any at all).

    while (Entry != ListHeadAddr)
    {
        ULONG64 Table, MinAddress, MaxAddress, BaseAddress, TableData;
        ULONG TableSize;
        WCHAR OutOfProcessDll[MAX_PATH];
        CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable;
        PVOID FunctionTable;
        PVOID FunctionEntry;

        Table = Entry;
        if (m_Machine->
            ReadDynamicFunctionTable(Process, Table, &Entry,
                                     &MinAddress, &MaxAddress,
                                     &BaseAddress,
                                     &TableData, &TableSize,
                                     OutOfProcessDll,
                                     &RawTable) != S_OK)
        {
            ErrOut("Unable to read dynamic function table entry\n");
            continue;
        }

        if (Address >= MinAddress && Address < MaxAddress &&
            (OutOfProcessDll[0] ||
             (TableData && TableSize > 0)))
        {
            if (OutOfProcessDll[0])
            {
                if (ReadOutOfProcessDynamicFunctionTable
                    (Process, OutOfProcessDll, Table, &TableSize,
                     &FunctionTable) != S_OK)
                {
                    ErrOut("Unable to read dynamic function table entries\n");
                    continue;
                }
            }
            else
            {
                FunctionTable = malloc(TableSize);
                if (FunctionTable == NULL)
                {
                    ErrOut("Unable to allocate memory for "
                           "dynamic function table\n");
                    continue;
                }

                // Read the dynamic function table
                if (ReadAllVirtual(Process, TableData, FunctionTable,
                                   TableSize) != S_OK)
                {
                    ErrOut("Unable to read dynamic function table entries\n");
                    free(FunctionTable);
                    continue;
                }
            }

            FunctionEntry = m_Machine->
                FindDynamicFunctionEntry(&RawTable, Address,
                                         FunctionTable, TableSize);
            
            free(FunctionTable);

            if (FunctionEntry)
            {
                return FunctionEntry;
            }
        }
    }

    return NULL;
}

ULONG64
TargetInfo::GetDynamicFunctionTableBase(ProcessInfo* Process,
                                        ULONG64 Address)
{
    LIST_ENTRY64 ListHead;
    ULONG64 Entry;

    // If the process dynamic function table list head hasn't
    // been looked up yet that means that no dynamic function
    // table entry could be in use yet, so there's no need to look.
    if (!Process->m_DynFuncTableList)
    {
        return 0;
    }
    
    if (ReadListEntry(Process, m_Machine,
                      Process->m_DynFuncTableList,
                      &ListHead) != S_OK)
    {
        return 0;
    }

    Entry = ListHead.Flink;

    // The list head is initialized the first time it's used so check
    // for an uninitialized pointers. This is the most common result.

    if (Entry == 0)
    {
        return 0;
    }

    // Loop through the dynamic function table list reading the headers.
    // If the range of a dynamic function table contains Address then
    // return the function table's base.

    while (Entry != Process->m_DynFuncTableList)
    {
        ULONG64 MinAddress, MaxAddress, BaseAddress, TableData;
        ULONG TableSize;
        WCHAR OutOfProcessDll[MAX_PATH];
        CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable;
        
        if (m_Machine->
            ReadDynamicFunctionTable(Process, Entry, &Entry,
                                     &MinAddress, &MaxAddress,
                                     &BaseAddress,
                                     &TableData, &TableSize,
                                     OutOfProcessDll,
                                     &RawTable) == S_OK &&
            Address >= MinAddress &&
            Address < MaxAddress)
        {
            return BaseAddress;
        }
    }

    return 0;
}

HRESULT
TargetInfo::ReadOutOfProcessDynamicFunctionTable(ProcessInfo* Process,
                                                 PWSTR Dll,
                                                 ULONG64 Table,
                                                 PULONG TableSize,
                                                 PVOID* TableData)
{
    // Empty base implementation to avoid error messages
    // that would be produced by an UNEXPECTED_HR implementation.
    return E_UNEXPECTED;
}

PVOID CALLBACK
TargetInfo::DynamicFunctionTableCallback(HANDLE ProcessHandle,
                                         ULONG64 Address,
                                         ULONG64 Context)
{
    ProcessInfo* Process = (ProcessInfo*)Context;
    
    DBG_ASSERT(ProcessHandle == OS_HANDLE(Process->m_SysHandle));

    return Process->m_Target->
        FindDynamicFunctionEntry(Process, Address);
}

HRESULT
TargetInfo::EnumFunctionTables(IN ProcessInfo* Process,
                               IN OUT PULONG64 Start,
                               IN OUT PULONG64 Handle,
                               OUT PULONG64 MinAddress,
                               OUT PULONG64 MaxAddress,
                               OUT PULONG64 BaseAddress,
                               OUT PULONG EntryCount,
                               OUT PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable,
                               OUT PVOID* RawEntries)
{
    HRESULT Status;
    
    if (*Start == 0)
    {
        LIST_ENTRY64 DynamicFunctionTableHead;

        if ((Status = GetFunctionTableListHead(Process, Start)) != S_OK)
        {
            return Status;
        }

        if ((Status = ReadListEntry(Process, m_Machine, *Start,
                                    &DynamicFunctionTableHead)) != S_OK)
        {
            return Status;
        }
        
        *Handle = DynamicFunctionTableHead.Flink;
    }

    if (!*Handle || *Handle == *Start)
    {
        return S_FALSE;
    }

    ULONG64 Table, TableData;
    ULONG TableSize;
    WCHAR OutOfProcessDll[MAX_PATH];

    Table = *Handle;
    if ((Status = m_Machine->
         ReadDynamicFunctionTable(Process, Table, Handle,
                                  MinAddress, MaxAddress,
                                  BaseAddress,
                                  &TableData, &TableSize,
                                  OutOfProcessDll,
                                  RawTable)) != S_OK)
    {
        return Status;
    }

    if (OutOfProcessDll[0])
    {
        if ((Status = ReadOutOfProcessDynamicFunctionTable
             (Process, OutOfProcessDll, Table, &TableSize,
              RawEntries)) != S_OK)
        {
            return Status;
        }
    }
    else
    {
        *RawEntries = malloc(TableSize);
        if (!*RawEntries)
        {
            return E_OUTOFMEMORY;
        }

        // Read the dynamic function table
        if ((Status = ReadAllVirtual(Process, TableData,
                                     *RawEntries, TableSize)) != S_OK)
        {
            free(*RawEntries);
            return Status;
        }
    }

    *EntryCount = TableSize / m_TypeInfo.SizeRuntimeFunction;
    return S_OK;
}

HRESULT
TargetInfo::QueryAddressInformation(ProcessInfo* Process,
                                    ULONG64 Address, ULONG InSpace,
                                    PULONG OutSpace, PULONG OutFlags)
{
    // Default implementation which just returns the
    // least restrictive settings.
    *OutSpace = (Process && IS_KERNEL_TARGET(this)) ?
        DBGKD_QUERY_MEMORY_KERNEL : DBGKD_QUERY_MEMORY_PROCESS;
    *OutFlags =
        DBGKD_QUERY_MEMORY_READ |
        DBGKD_QUERY_MEMORY_WRITE |
        DBGKD_QUERY_MEMORY_EXECUTE;
    return S_OK;
}

HRESULT
TargetInfo::ReadPointer(
    ProcessInfo* Process,
    MachineInfo* Machine,
    ULONG64 Address,
    PULONG64 Pointer64
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    ULONG Pointer32;
    ULONG64 Data;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(ULONG64);
        Status = ReadVirtual(Process, Address, &Data, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(ULONG32);
        Status = ReadVirtual(Process,
                             Address, &Pointer32, SizeToRead, &Result);
        Data = EXTEND64(Pointer32);
    }

    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    *Pointer64 = Data;
    return S_OK;
}

HRESULT
TargetInfo::WritePointer(
    ProcessInfo* Process,
    MachineInfo* Machine,
    ULONG64 Address,
    ULONG64 Pointer64
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToWrite;
    ULONG Pointer32;

    if (Machine->m_Ptr64)
    {
        SizeToWrite = sizeof(ULONG64);
        Status = WriteVirtual(Process,
                              Address, &Pointer64, SizeToWrite, &Result);
    }
    else
    {
        SizeToWrite = sizeof(ULONG32);
        Pointer32 = (ULONG)Pointer64;
        Status = WriteVirtual(Process,
                              Address, &Pointer32, SizeToWrite, &Result);
    }

    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != SizeToWrite)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadListEntry(
    ProcessInfo* Process,
    MachineInfo* Machine,
    ULONG64 Address,
    PLIST_ENTRY64 List64
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    LIST_ENTRY32 List32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(LIST_ENTRY64);
        Status = ReadVirtual(Process, Address, List64, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(LIST_ENTRY32);
        Status = ReadVirtual(Process, Address, &List32, SizeToRead, &Result);
    }

    if (Status != S_OK)
    {
        return Status;
    }
    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    if (!Machine->m_Ptr64)
    {
        List64->Flink = EXTEND64(List32.Flink);
        List64->Blink = EXTEND64(List32.Blink);
    }

    return S_OK;
}

void
ConvertLoaderEntry32To64(
    PKLDR_DATA_TABLE_ENTRY32 b32,
    PKLDR_DATA_TABLE_ENTRY64 b64
    )
{
#define COPYSE2(p64,s32,f) p64->f = (ULONG64)(LONG64)(LONG)s32->f
    COPYSE2(b64,b32,InLoadOrderLinks.Flink);
    COPYSE2(b64,b32,InLoadOrderLinks.Blink);
    COPYSE2(b64,b32,__Undefined1);
    COPYSE2(b64,b32,__Undefined2);
    COPYSE2(b64,b32,__Undefined3);
    COPYSE2(b64,b32,NonPagedDebugInfo);
    COPYSE2(b64,b32,DllBase);
    COPYSE2(b64,b32,EntryPoint);
    b64->SizeOfImage = b32->SizeOfImage;

    b64->FullDllName.Length = b32->FullDllName.Length;
    b64->FullDllName.MaximumLength = b32->FullDllName.MaximumLength;
    COPYSE2(b64,b32,FullDllName.Buffer);

    b64->BaseDllName.Length = b32->BaseDllName.Length;
    b64->BaseDllName.MaximumLength = b32->BaseDllName.MaximumLength;
    COPYSE2(b64,b32,BaseDllName.Buffer);

    b64->Flags     = b32->Flags;
    b64->LoadCount = b32->LoadCount;
    b64->__Undefined5 = b32->__Undefined5;

    COPYSE2(b64,b32,__Undefined6);
    b64->CheckSum = b32->CheckSum;
    b64->TimeDateStamp = b32->TimeDateStamp;
#undef COPYSE2
    return;
}

HRESULT
TargetInfo::ReadLoaderEntry(
    ProcessInfo* Process,
    MachineInfo* Machine,
    ULONG64 Address,
    PKLDR_DATA_TABLE_ENTRY64 Entry
    )
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    KLDR_DATA_TABLE_ENTRY32 Ent32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(KLDR_DATA_TABLE_ENTRY64);
        Status = ReadVirtual(Process, Address, Entry, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(KLDR_DATA_TABLE_ENTRY32);
        Status = ReadVirtual(Process, Address, &Ent32, SizeToRead, &Result);
        ConvertLoaderEntry32To64(&Ent32, Entry);
    }

    if (Status != S_OK)
    {
        return Status;
    }

    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadUnicodeString(ProcessInfo* Process,
                              MachineInfo* Machine,
                              ULONG64 Address, PUNICODE_STRING64 String)
{
    HRESULT Status;
    ULONG Result;
    ULONG SizeToRead;
    UNICODE_STRING32 Str32;

    if (Machine->m_Ptr64)
    {
        SizeToRead = sizeof(UNICODE_STRING64);
        Status = ReadVirtual(Process, Address, String, SizeToRead, &Result);
    }
    else
    {
        SizeToRead = sizeof(UNICODE_STRING32);
        Status = ReadVirtual(Process, Address, &Str32, SizeToRead, &Result);
        String->Length = Str32.Length;
        String->MaximumLength = Str32.MaximumLength;
        String->Buffer = EXTEND64(Str32.Buffer);
    }

    if (Status != S_OK)
    {
        return Status;
    }

    if (Result != SizeToRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

// VS_VERSIONINFO has a variable format but in the case we
// care about it's fixed.
struct PARTIAL_VERSIONINFO
{
    WORD wLength;
    WORD wValueLength;
    WORD wType;
    WCHAR szKey[17];
    VS_FIXEDFILEINFO Value;
};

#define VER2_SIG ((ULONG)'X2EF')

HRESULT
TargetInfo::ReadImageVersionInfo(ProcessInfo* Process,
                                 ULONG64 ImageBase,
                                 PCSTR Item,
                                 PVOID Buffer,
                                 ULONG BufferSize,
                                 PULONG VerInfoSize,
                                 PIMAGE_DATA_DIRECTORY ResDataDir)
{
    if (ResDataDir->VirtualAddress == 0 ||
        ResDataDir->Size < sizeof(IMAGE_RESOURCE_DIRECTORY))
    {
        return E_NOINTERFACE;
    }

    HRESULT Status;
    IMAGE_RESOURCE_DIRECTORY ResDir;
    ULONG64 Offset, DirOffset;

    Offset = ImageBase + ResDataDir->VirtualAddress;
    if ((Status = ReadAllVirtual(Process,
                                 Offset, &ResDir, sizeof(ResDir))) != S_OK)
    {
        return Status;
    }

    //
    // Search for the resource directory entry named by VS_FILE_INFO.
    //
    
    IMAGE_RESOURCE_DIRECTORY_ENTRY DirEnt;
    ULONG i;

    DirOffset = Offset;
    Offset += sizeof(ResDir) +
        ((ULONG64)ResDir.NumberOfNamedEntries * sizeof(DirEnt));
    for (i = 0; i < (ULONG)ResDir.NumberOfIdEntries; i++)
    {
        if ((Status = ReadAllVirtual(Process,
                                     Offset, &DirEnt, sizeof(DirEnt))) != S_OK)
        {
            return Status;
        }

        if (!DirEnt.NameIsString &&
            MAKEINTRESOURCE(DirEnt.Id) == VS_FILE_INFO)
        {
            break;
        }

        Offset += sizeof(DirEnt);
    }

    if (i >= (ULONG)ResDir.NumberOfIdEntries ||
        !DirEnt.DataIsDirectory)
    {
        return E_NOINTERFACE;
    }

    Offset = DirOffset + DirEnt.OffsetToDirectory;
    if ((Status = ReadAllVirtual(Process,
                                 Offset, &ResDir, sizeof(ResDir))) != S_OK)
    {
        return Status;
    }
    
    //
    // Search for the resource directory entry named by VS_VERSION_INFO.
    //

    Offset += sizeof(ResDir) +
        ((ULONG64)ResDir.NumberOfNamedEntries * sizeof(DirEnt));
    for (i = 0; i < (ULONG)ResDir.NumberOfIdEntries; i++)
    {
        if ((Status = ReadAllVirtual(Process,
                                     Offset, &DirEnt, sizeof(DirEnt))) != S_OK)
        {
            return Status;
        }

        if (DirEnt.Name == VS_VERSION_INFO)
        {
            break;
        }

        Offset += sizeof(DirEnt);
    }

    if (i >= (ULONG)ResDir.NumberOfIdEntries ||
        !DirEnt.DataIsDirectory)
    {
        return E_NOINTERFACE;
    }

    Offset = DirOffset + DirEnt.OffsetToDirectory;
    if ((Status = ReadAllVirtual(Process,
                                 Offset, &ResDir, sizeof(ResDir))) != S_OK)
    {
        return Status;
    }
    
    //
    // We now have the VS_VERSION_INFO directory.  Just take
    // the first entry as we don't care about languages.
    //

    Offset += sizeof(ResDir);
    if ((Status = ReadAllVirtual(Process,
                                 Offset, &DirEnt, sizeof(DirEnt))) != S_OK)
    {
        return Status;
    }

    if (DirEnt.DataIsDirectory)
    {
        return E_NOINTERFACE;
    }

    IMAGE_RESOURCE_DATA_ENTRY DataEnt;
    
    Offset = DirOffset + DirEnt.OffsetToData;
    if ((Status = ReadAllVirtual(Process,
                                 Offset, &DataEnt, sizeof(DataEnt))) != S_OK)
    {
        return Status;
    }

    if (DataEnt.Size < sizeof(PARTIAL_VERSIONINFO))
    {
        return E_NOINTERFACE;
    }

    PARTIAL_VERSIONINFO RawInfo;

    Offset = ImageBase + DataEnt.OffsetToData;
    if ((Status = ReadAllVirtual(Process,
                                 Offset, &RawInfo, sizeof(RawInfo))) != S_OK)
    {
        return Status;
    }

    if (RawInfo.wLength < sizeof(RawInfo) ||
        wcscmp(RawInfo.szKey, L"VS_VERSION_INFO") != 0)
    {
        return E_NOINTERFACE;
    }

    //
    // VerQueryValueA needs extra data space for ANSI translations
    // of version strings.  VQVA assumes that this space is available
    // at the end of the data block passed in.  GetFileVersionInformationSize
    // makes this work by returning a size that's big enough
    // for the actual data plus space for ANSI translations.  We
    // need to do the same thing here so that we also provide
    // the necessary translation area.
    //

    ULONG DataSize = (RawInfo.wLength + 3) & ~3;
    PVOID VerData = malloc(DataSize * 2 + sizeof(ULONG));
    if (VerData == NULL)
    {
        return E_OUTOFMEMORY;
    }
        
    if ((Status = ReadAllVirtual(Process,
                                 Offset, VerData, RawInfo.wLength)) == S_OK)
    {
        // Stamp the buffer with the signature that indicates
        // a full-size translation buffer is available after
        // the raw data.
        *(PULONG)((PUCHAR)VerData + DataSize) = VER2_SIG;
        
        Status = QueryVersionDataBuffer(VerData, Item,
                                        Buffer, BufferSize, VerInfoSize);
    }
        
    free(VerData);
    return Status;
}

HRESULT
TargetInfo::ReadImageNtHeaders(ProcessInfo* Process,
                               ULONG64 ImageBase,
                               PIMAGE_NT_HEADERS64 Headers)
{
    HRESULT Status;
    IMAGE_DOS_HEADER DosHdr;
    IMAGE_NT_HEADERS32 Hdr32;

    if ((Status = ReadAllVirtual(Process, ImageBase,
                                 &DosHdr, sizeof(DosHdr))) != S_OK)
    {
        return Status;
    }

    if (DosHdr.e_magic != IMAGE_DOS_SIGNATURE)
    {
        return E_INVALIDARG;
    }

    // Only read HEADERS32 worth of data first in case
    // that's all the memory that's available.
    if ((Status = ReadAllVirtual(Process, ImageBase + DosHdr.e_lfanew,
                                 &Hdr32, sizeof(Hdr32))) != S_OK)
    {
        return Status;
    }

    if (Hdr32.Signature != IMAGE_NT_SIGNATURE)
    {
        return E_INVALIDARG;
    }

    switch(Hdr32.OptionalHeader.Magic)
    {
    case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
        ImageNtHdr32To64(&Hdr32, Headers);
        Status = S_OK;
        break;
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
        // Read the remainder of the header.
        memcpy(Headers, &Hdr32, sizeof(Hdr32));
        Status = ReadAllVirtual(Process,
                                ImageBase + DosHdr.e_lfanew + sizeof(Hdr32),
                                (PUCHAR)Headers + sizeof(Hdr32),
                                sizeof(*Headers) - sizeof(Hdr32));
        break;
    default:
        Status = E_INVALIDARG;
        break;
    }

    return Status;
}

HRESULT
TargetInfo::ReadDirectoryTableBase(PULONG64 DirBase)
{
    HRESULT Status;
    ULONG64 CurProc;

    // Retrieve the current EPROCESS's DirectoryTableBase[0] value.
    Status = GetProcessInfoDataOffset(m_RegContextThread, 0, 0, &CurProc);
    if (Status != S_OK)
    {
        return Status;
    }

    CurProc += m_KdDebuggerData.OffsetEprocessDirectoryTableBase;
    return ReadPointer(m_ProcessHead, m_Machine, CurProc, DirBase);
}

HRESULT
TargetInfo::ReadSharedUserTimeDateN(PULONG64 TimeDate)
{
    return ReadAllVirtual(m_ProcessHead, m_TypeInfo.SharedUserDataOffset +
                          FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime),
                          TimeDate, sizeof(*TimeDate));
}

HRESULT
TargetInfo::ReadSharedUserUpTimeN(PULONG64 UpTime)
{
    return ReadAllVirtual(m_ProcessHead, m_TypeInfo.SharedUserDataOffset +
                          FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime),
                          UpTime, sizeof(*UpTime));
}

HRESULT
TargetInfo::ReadSharedUserProductInfo(PULONG ProductType, PULONG SuiteMask)
{
    HRESULT Status;
    BOOLEAN IsValid;
    
    if ((Status =
         ReadAllVirtual(m_ProcessHead, m_TypeInfo.SharedUserDataOffset +
                        FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid),
                        &IsValid, sizeof(IsValid))) != S_OK)
    {
        return Status;
    }
    if (!IsValid)
    {
        return E_NOTIMPL;
    }
    if ((Status =
         ReadAllVirtual(m_ProcessHead, m_TypeInfo.SharedUserDataOffset +
                        FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType),
                        ProductType, sizeof(*ProductType))) != S_OK)
    {
        return Status;
    }
    return ReadAllVirtual(m_ProcessHead, m_TypeInfo.SharedUserDataOffset +
                          FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask),
                          SuiteMask, sizeof(*SuiteMask));
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
LiveKernelTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    return m_Machine->ReadKernelProcessorId(Processor, Id);
}

HRESULT
LiveKernelTargetInfo::GetProcessorSpeed
    (ULONG Processor, PULONG Speed)
{
    HRESULT Status;
    ULONG64 Prcb;

    if ((Status =
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    if (!m_KdDebuggerData.OffsetPrcbMhz)
    {
        return E_NOTIMPL;
    }

    return
         ReadAllVirtual(m_ProcessHead,
                        Prcb + m_KdDebuggerData.OffsetPrcbMhz, Speed,
                        sizeof(ULONG));
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::ReadVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (Process)
    {
        return Process->m_VirtualCache.
            Read(Offset, Buffer, BufferSize, BytesRead);
    }
    else
    {
        return ReadVirtualUncached(Process,
                                   Offset, Buffer, BufferSize, BytesRead);
    }
}

HRESULT
ConnLiveKernelTargetInfo::WriteVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;

    if (Process)
    {
        Status = Process->m_VirtualCache.
            Write(Offset, Buffer, BufferSize, BytesWritten);
    }
    else
    {
        Status = WriteVirtualUncached(Process, Offset, Buffer, BufferSize,
                                      BytesWritten);
    }
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::SearchVirtual(
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    IN ULONG PatternGranularity,
    OUT PULONG64 MatchOffset
    )
{
    // In NT 4.0, the search API is not supported at the kernel protocol
    // level.  Fall back to the default ReadMemory \ search.
    //

    HRESULT Status;

    if (m_SystemVersion <= NT_SVER_NT4 ||
        PatternGranularity != 1)
    {
        Status = TargetInfo::SearchVirtual(Process,
                                           Offset, Length, (PUCHAR)Pattern,
                                           PatternSize, PatternGranularity,
                                           MatchOffset);
    }
    else
    {
        DBGKD_MANIPULATE_STATE64 m;
        PDBGKD_MANIPULATE_STATE64 Reply;
        PDBGKD_SEARCH_MEMORY a = &m.u.SearchMemory;
        ULONG rc;
        NTSTATUS st;

        KdOut("Search called %s, length %I64x\n",
              FormatAddr64(Offset), Length);

        *MatchOffset = 0;

        a->SearchAddress = Offset;
        a->SearchLength = Length;
        a->PatternLength = PatternSize;

        m.ApiNumber = DbgKdSearchMemoryApi;
        m.ReturnStatus = STATUS_PENDING;

        //
        // Send the message and data to write and then wait for reply
        //

        do
        {
            m_Transport->WritePacket(&m, sizeof(m),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     Pattern, (USHORT)PatternSize);
            rc = m_Transport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        } while (rc != DBGKD_WAIT_PACKET ||
                 Reply->ApiNumber != DbgKdSearchMemoryApi);

        st = Reply->ReturnStatus;

        if (NT_SUCCESS(st))
        {
            if (m_Machine->m_Ptr64)
            {
                *MatchOffset = Reply->u.SearchMemory.FoundAddress;
            }
            else
            {
                *MatchOffset = EXTEND64(Reply->u.SearchMemory.FoundAddress);
            }
        }

        KdOut("DbgKdSearchMemory %08lx\n", st);

        Status = CONV_NT_STATUS(st);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::ReadVirtualUncached(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    BOOL TranslateVirt = Process &&
        Process->m_VirtualCache.m_ForceDecodePTEs;
    ULONG Done;
    ULONG Left;
    HRESULT Status = S_OK;

    if (!m_Machine->m_Ptr64 && EXTEND64((ULONG)Offset) != Offset)
    {
        ErrOut("ReadVirtual: %08x not properly sign extended\n",
               (ULONG)Offset);
    }

 Restart:
    Done = 0;
    Left = BufferSize;
    
    while (Left)
    {
        ULONG64 ReqOffs;
        ULONG Req;

        // Exit if the user is tired of waiting.
        if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
        {
            Done = 0;
            Status = HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT);
            break;
        }

        ReqOffs = Offset + Done;
        Req = Left;
        if (Req > MAX_MANIP_TRANSFER)
        {
            Req = MAX_MANIP_TRANSFER;
        }

        // Split all requests at page boundaries.  This
        // handles different translations per page in the
        // case where the debugger is translating and also
        // avoids failures in partial success cases where
        // the lead page is valid but followers are not.
        if (PAGE_ALIGN(m_Machine, ReqOffs) != 
            PAGE_ALIGN(m_Machine, ReqOffs + Req - 1))
        {
            Req = (ULONG)
                ((ReqOffs | (m_Machine->m_PageSize - 1)) - ReqOffs + 1);
        }
            
        if (TranslateVirt)
        {
            Status = KdReadVirtualTranslated(ReqOffs, (PUCHAR)Buffer + Done,
                                             Req, &Req);
        }
        else
        {
            NTSTATUS NtStatus =
                KdReadVirtual(ReqOffs, (PUCHAR)Buffer + Done, Req, &Req);
            Status = CONV_NT_STATUS(NtStatus);
        }
        
        if (Status != S_OK)
        {
            // If the target machine failed the write it
            // may be because there's a page in transition
            // which it didn't want to access.  Try again
            // with the debugger doing the translations so
            // that it can override certain protections.
            if (Status != HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT) &&
                !TranslateVirt &&
                Process && Process->m_VirtualCache.m_DecodePTEs)
            {
                TranslateVirt = TRUE;
                goto Restart;
            }

            break;
        }
        else
        {
            Left -= Req;
            Done += Req;
        }
    }

    *BytesRead = Done;
    return Done > 0 ? S_OK : Status;
}

HRESULT
ConnLiveKernelTargetInfo::WriteVirtualUncached(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    BOOL TranslateVirt = Process &&
        Process->m_VirtualCache.m_ForceDecodePTEs;
    ULONG Done;
    ULONG Left;
    HRESULT Status = S_OK;

    if (!m_Machine->m_Ptr64 && EXTEND64((ULONG)Offset) != Offset)
    {
        ErrOut("WriteVirtual: %08x not properly sign extended\n",
               (ULONG)Offset);
    }

    // Restrict notifications to a single notify at the end.
    g_EngNotify++;
    
 Restart:
    Done = 0;
    Left = BufferSize;
    
    while (Left)
    {
        ULONG64 ReqOffs;
        ULONG Req;

        ReqOffs = Offset + Done;
        Req = Left;
        if (Req > MAX_MANIP_TRANSFER)
        {
            Req = MAX_MANIP_TRANSFER;
        }

        // Split all requests at page boundaries.  This
        // handles different translations per page in the
        // case where the debugger is translating and also
        // avoids failures in partial success cases where
        // the lead page is valid but followers are not.
        if (PAGE_ALIGN(m_Machine, ReqOffs) !=
            PAGE_ALIGN(m_Machine, ReqOffs + Req - 1))
        {
            Req = (ULONG)
                ((ReqOffs | (m_Machine->m_PageSize - 1)) - ReqOffs + 1);
        }

        if (TranslateVirt)
        {
            Status = KdWriteVirtualTranslated(ReqOffs, (PUCHAR)Buffer + Done,
                                              Req, &Req);
        }
        else
        {
            NTSTATUS NtStatus =
                KdWriteVirtual(ReqOffs, (PUCHAR)Buffer + Done, Req, &Req);
            Status = CONV_NT_STATUS(NtStatus);
        }
        
        if (Status != S_OK)
        {
            // If the target machine failed the write it
            // may be because there's a page in transition
            // which it didn't want to access.  Try again
            // with the debugger doing the translations so
            // that it can override certain protections.
            if (Status != HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT) &&
                !TranslateVirt &&
                Process && Process->m_VirtualCache.m_DecodePTEs)
            {
                TranslateVirt = TRUE;
                goto Restart;
            }

            break;
        }
        else
        {
            Left -= Req;
            Done += Req;
        }
    }

    *BytesWritten = Done;
    Status = Done > 0 ? S_OK : Status;

    g_EngNotify--;
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

NTSTATUS
ConnLiveKernelTargetInfo::KdReadVirtual(
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    ULONG rc;
    
    //
    // Initialize state manipulate message to read virtual memory.
    //

    m.ApiNumber = DbgKdReadVirtualMemoryApi;
    m.u.ReadMemory.TargetBaseAddress = Offset;
    m.u.ReadMemory.TransferCount = BufferSize;

    //
    // Send the read virtual message to the target system and wait for
    // a reply.
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while ((rc != DBGKD_WAIT_PACKET) ||
           (Reply->ApiNumber != DbgKdReadVirtualMemoryApi));

    if (NT_SUCCESS(Reply->ReturnStatus))
    {
        if (Reply->u.ReadMemory.ActualBytesRead == 0)
        {
            Reply->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
        else
        {
            if (Reply->u.ReadMemory.ActualBytesRead > BufferSize)
            {
                ErrOut("KdReadVirtual: Asked for %d, got %d\n",
                       BufferSize, Reply->u.ReadMemory.ActualBytesRead);
                Reply->u.ReadMemory.ActualBytesRead = BufferSize;
            }

            memcpy(Buffer, Reply + 1, Reply->u.ReadMemory.ActualBytesRead);
        }
    }
    
    *BytesRead = Reply->u.ReadMemory.ActualBytesRead;
    KdOut("KdReadVirtual(%s, %x) returns %08lx, %x\n",
          FormatAddr64(Offset), BufferSize,
          Reply->ReturnStatus, *BytesRead);
    return Reply->ReturnStatus;
}

NTSTATUS
ConnLiveKernelTargetInfo::KdWriteVirtual(
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    ULONG rc;
    
    //
    // Initialize state manipulate message to write virtual memory.
    //

    m.ApiNumber = DbgKdWriteVirtualMemoryApi;
    m.u.WriteMemory.TargetBaseAddress = Offset;
    m.u.WriteMemory.TransferCount = BufferSize;

    //
    // Send the write message and data to the target system and wait
    // for a reply.
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 Buffer, (USHORT)BufferSize);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while ((rc != DBGKD_WAIT_PACKET) ||
           (Reply->ApiNumber != DbgKdWriteVirtualMemoryApi));

    KdOut("DbgKdWriteVirtualMemory returns %08lx\n", Reply->ReturnStatus);

    *BytesWritten = Reply->u.WriteMemory.ActualBytesWritten;
    KdOut("KdWriteVirtual(%s, %x) returns %08lx, %x\n",
          FormatAddr64(Offset), BufferSize,
          Reply->ReturnStatus, *BytesWritten);
    return Reply->ReturnStatus;
}

HRESULT
ConnLiveKernelTargetInfo::KdReadVirtualTranslated(
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    //
    // Virtual addresses are not necessarily contiguous
    // after translation to physical addresses so do
    // not allow transfers that cross a page boundary.
    // Higher-level code is responsible for splitting
    // up requests.
    //

    DBG_ASSERT(PAGE_ALIGN(m_Machine, Offset) ==
               PAGE_ALIGN(m_Machine, Offset + BufferSize - 1));
    
    ULONG64 TargetPhysicalAddress;
    ULONG Levels;
    ULONG PfIndex;
    HRESULT Status;
    BOOL ChangedSuspend;

    // Allow the page table physical accesses to be cached.
    ChangedSuspend = m_PhysicalCache.ChangeSuspend(TRUE);
    
    Status = m_Machine->
        GetVirtualTranslationPhysicalOffsets(m_ProcessHead->m_CurrentThread,
                                             Offset, NULL, 0,
                                             &Levels, &PfIndex,
                                             &TargetPhysicalAddress);

    if (ChangedSuspend)
    {
        m_PhysicalCache.ChangeSuspend(FALSE);
    }

    if (Status == S_OK)
    {
        Status = ReadPhysicalUncached(TargetPhysicalAddress,
                                      Buffer, BufferSize,
                                      PHYS_FLAG_DEFAULT,
                                      BytesRead);
    }
    else if (Status == HR_PAGE_IN_PAGE_FILE ||
             Status == HR_PAGE_NOT_AVAILABLE)
    {
        // Translate specific errors into generic memory
        // failure errors.
        Status = HRESULT_FROM_NT(STATUS_UNSUCCESSFUL);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::KdWriteVirtualTranslated(
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    //
    // Virtual addresses are not necessarily contiguous
    // after translation to physical addresses so do
    // not allow transfers that cross a page boundary.
    // Higher-level code is responsible for splitting
    // up requests.
    //

    DBG_ASSERT(PAGE_ALIGN(m_Machine, Offset) ==
               PAGE_ALIGN(m_Machine, Offset + BufferSize - 1));
    
    ULONG64 TargetPhysicalAddress;
    ULONG Levels;
    ULONG PfIndex;
    HRESULT Status;
    BOOL ChangedSuspend;

    // Allow the page table physical accesses to be cached.
    ChangedSuspend = m_PhysicalCache.ChangeSuspend(TRUE);
    
    Status = m_Machine->
        GetVirtualTranslationPhysicalOffsets(m_ProcessHead->m_CurrentThread,
                                             Offset, NULL, 0,
                                             &Levels, &PfIndex,
                                             &TargetPhysicalAddress);
    
    if (ChangedSuspend)
    {
        m_PhysicalCache.ChangeSuspend(FALSE);
    }

    if (Status == S_OK)
    {
        Status = WritePhysicalUncached(TargetPhysicalAddress,
                                       Buffer, BufferSize,
                                       PHYS_FLAG_DEFAULT,
                                       BytesWritten);
    }
    else if (Status == HR_PAGE_IN_PAGE_FILE ||
             Status == HR_PAGE_NOT_AVAILABLE)
    {
        // Translate specific errors into generic memory
        // failure errors.
        Status = HRESULT_FROM_NT(STATUS_UNSUCCESSFUL);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesRead
    )
{
    if (!m_PhysicalCache.m_Suspend)
    {
        if (Flags != PHYS_FLAG_DEFAULT)
        {
            return E_NOTIMPL;
        }
    
        return m_PhysicalCache.
            Read(Offset, Buffer, BufferSize, BytesRead);
    }
    else
    {
        return ReadPhysicalUncached(Offset, Buffer, BufferSize, Flags,
                                    BytesRead);
    }
}

HRESULT
ConnLiveKernelTargetInfo::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesWritten
    )
{
    if (!m_PhysicalCache.m_Suspend)
    {
        if (Flags != PHYS_FLAG_DEFAULT)
        {
            return E_NOTIMPL;
        }
    
        return m_PhysicalCache.
            Write(Offset, Buffer, BufferSize, BytesWritten);
    }
    else
    {
        return WritePhysicalUncached(Offset, Buffer, BufferSize, Flags,
                                     BytesWritten);
    }
}

HRESULT
ConnLiveKernelTargetInfo::PointerSearchPhysical(
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN ULONG64 PointerMin,
    IN ULONG64 PointerMax,
    IN ULONG Flags,
    OUT PULONG64 MatchOffsets,
    IN ULONG MatchOffsetsSize,
    OUT PULONG MatchOffsetsCount
    )
{
    const ULONG SEARCH_SYMBOL_CHECK = 0xABCDDCBA;
    HRESULT Status;

    // The kernel stubs only handle page-based searches,
    // so if the search isn't page aligned fall back on
    // the base implementation.
    // The kernel also will only return a single hit if
    // the search range is greater than a page.
    if ((Offset & ((1 << m_Machine->m_PageShift) - 1)) ||
        (Length & ((1 << m_Machine->m_PageShift) - 1)) ||
        ((Flags & PTR_SEARCH_PHYS_ALL_HITS) &&
         Length != m_Machine->m_PageSize))
    {
        return TargetInfo::PointerSearchPhysical(Offset, Length,
                                                 PointerMin, PointerMax,
                                                 Flags, MatchOffsets,
                                                 MatchOffsetsSize,
                                                 MatchOffsetsCount);
    }
    
    if (!m_KdpSearchInProgress)
    {
        if (!GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchPageHits",
                              &m_KdpSearchPageHits, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchPageHitOffsets",
                              &m_KdpSearchPageHitOffsets, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchPageHitIndex",
                              &m_KdpSearchPageHitIndex, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchInProgress",
                              &m_KdpSearchInProgress, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchStartPageFrame",
                              &m_KdpSearchStartPageFrame, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchEndPageFrame",
                              &m_KdpSearchEndPageFrame, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchAddressRangeStart",
                              &m_KdpSearchAddressRangeStart, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchAddressRangeEnd",
                              &m_KdpSearchAddressRangeEnd, NULL) ||
            !GetOffsetFromSym(m_ProcessHead,
                              "nt!KdpSearchPfnValue",
                              &m_KdpSearchPfnValue, NULL))
        {
            m_KdpSearchInProgress = 0;
            ErrOut("Search error: Unable to resolve symbols for kernel\n");
            return E_INVALIDARG;
        }

        if (!(Flags & PTR_SEARCH_NO_SYMBOL_CHECK))
        {
            ULONG Check;
        
            if (!GetOffsetFromSym(m_ProcessHead,
                                  "nt!KdpSearchCheckPoint",
                                  &m_KdpSearchCheckPoint, NULL) ||
                ReadAllVirtual(m_ProcessHead, m_KdpSearchCheckPoint,
                               &Check, sizeof(Check)) != S_OK ||
                Check != SEARCH_SYMBOL_CHECK)
            {
                m_KdpSearchInProgress = 0;
                ErrOut("Search error: Incorrect symbols for kernel\n");
                return E_INVALIDARG;
            }
        }
    }

    ULONG Ul;
    
    //
    // Perform some sanity checks on the values.
    //

    if (ReadAllVirtual(m_ProcessHead,
                       m_KdpSearchInProgress, &Ul, sizeof(Ul)) != S_OK ||
        Ul != 0)
    {
        ErrOut("Search error: "
               "Inconsistent value for nt!KdpSearchInProgress \n");
        return E_INVALIDARG;
    }

    //
    // Set up the search engine
    //

    if ((Status = WritePointer(m_ProcessHead, m_Machine,
                               m_KdpSearchAddressRangeStart,
                               PointerMin)) != S_OK ||
        (Status = WritePointer(m_ProcessHead, m_Machine,
                               m_KdpSearchAddressRangeEnd,
                               PointerMax)) != S_OK ||
        (Status = WritePointer(m_ProcessHead, m_Machine,
                               m_KdpSearchStartPageFrame,
                               Offset >> m_Machine->
                               m_PageShift)) != S_OK ||
        (Status = WritePointer(m_ProcessHead, m_Machine,
                               m_KdpSearchEndPageFrame,
                               (Offset + Length - 1) >> 
                               m_Machine->m_PageShift)) != S_OK)
    {
        return Status;
    }

    Ul = 0;
    if ((Status = WriteAllVirtual(m_ProcessHead,
                                  m_KdpSearchPageHitIndex,
                                  &Ul, sizeof(Ul))) != S_OK ||
        (Status = WriteAllVirtual(m_ProcessHead,
                                  m_KdpSearchPageHits,
                                  &Ul, sizeof(Ul))) != S_OK ||
        (Status = WriteAllVirtual(m_ProcessHead,
                                  m_KdpSearchPageHitOffsets,
                                  &Ul, sizeof(Ul))) != S_OK)
    {
        return Status;
    }

    Ul = (Flags & PTR_SEARCH_PHYS_PTE) ? 1 : 0;
    if ((Status = WriteAllVirtual(m_ProcessHead,
                                  m_KdpSearchPfnValue,
                                  &Ul, sizeof(Ul))) != S_OK)
    {
        return Status;
    }
    
    Ul = 1;
    if ((Status = WriteAllVirtual(m_ProcessHead,
                                  m_KdpSearchInProgress,
                                  &Ul, sizeof(Ul))) != S_OK)
    {
        goto Exit;
    }

    // The kernel check-low-memory code checks the variables
    // set above and automatically changes its behavior to
    // the given search rather than the standard low-memory check.
    if (FAILED(Status = CheckLowMemory()))
    {
        goto Exit;
    }
    
    ULONG Hits;
    ULONG i;
        
    if ((Status = ReadAllVirtual(m_ProcessHead,
                                 m_KdpSearchPageHitIndex,
                                 &Hits, sizeof(Hits))) != S_OK)
    {
        goto Exit;
    }

    if (MatchOffsetsCount)
    {
        *MatchOffsetsCount = Hits;
    }
        
    if (Hits > MatchOffsetsSize)
    {
        Hits = MatchOffsetsSize;
        Status = S_FALSE;
    }

    for (i = 0; i < Hits; i++)
    {
        ULONG64 Pfn;
        ULONG Offs;
        HRESULT ReadStatus;

        Pfn = 0;
        if ((ReadStatus = ReadAllVirtual
             (m_ProcessHead, m_KdpSearchPageHits +
              i * m_TypeInfo.SizePageFrameNumber,
              &Pfn,
              m_TypeInfo.SizePageFrameNumber)) != S_OK ||
            (ReadStatus = ReadAllVirtual
             (m_ProcessHead,
              m_KdpSearchPageHitOffsets + i * sizeof(ULONG),
              &Offs, sizeof(Offs))) != S_OK)
        {
            Status = ReadStatus;
            goto Exit;
        }

        MatchOffsets[i] = (Pfn << m_Machine->m_PageShift) +
            (Offs & ((1 << m_Machine->m_PageShift) - 1));
    }
    
 Exit:
    Ul = 0;
    // Can't do much on failures.
    WriteAllVirtual(m_ProcessHead,
                    m_KdpSearchPfnValue, &Ul, sizeof(Ul));
    WriteAllVirtual(m_ProcessHead,
                    m_KdpSearchInProgress, &Ul, sizeof(Ul));
    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::ReadPhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesRead
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_MEMORY64 a;
    NTSTATUS st;
    ULONG rc;
    ULONG cb, cb2;
    ULONG OrigBufferSize = BufferSize;

    cb2 = 0;

    if (ARGUMENT_PRESENT(BytesRead))
    {
        *BytesRead = 0;
    }

readmore:

    cb = BufferSize;
    if (cb > MAX_MANIP_TRANSFER)
    {
        cb = MAX_MANIP_TRANSFER;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadPhysicalMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    a = &m.u.ReadMemory;
    a->TargetBaseAddress = Offset + cb2;
    a->TransferCount = cb;
    // The ActualBytes fields have been overloaded to
    // allow passing in flags for the request.  Previous
    // debuggers passed zero so that should always be
    // the default.
    a->ActualBytesRead = Flags;

    //
    // Send the message and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadPhysicalMemoryApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.ReadMemory;
    DBG_ASSERT(a->ActualBytesRead <= cb);

    //
    // Return actual bytes read, and then transfer the bytes
    //

    if (ARGUMENT_PRESENT(BytesRead))
    {
        *BytesRead += a->ActualBytesRead;
    }

    //
    // Since read response data follows message, Reply+1 should point
    // at the data
    //

    if (NT_SUCCESS(st))
    {
        memcpy((PCHAR)((ULONG_PTR)Buffer + cb2), Reply + 1,
               (int)a->ActualBytesRead);

        BufferSize -= a->ActualBytesRead;
        cb2 += a->ActualBytesRead;

        if (BufferSize)
        {
            goto readmore;
        }
    }

    KdOut("KdReadPhysical(%s, %x) returns %08lx, %x\n",
          FormatAddr64(Offset), OrigBufferSize, st, cb2);

    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::WritePhysicalUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesWritten
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_WRITE_MEMORY64 a;
    NTSTATUS st;
    ULONG rc;
    ULONG cb, cb2;
    ULONG OrigBufferSize = BufferSize;

    InvalidateMemoryCaches(TRUE);

    cb2 = 0;

    if (ARGUMENT_PRESENT(BytesWritten))
    {
        *BytesWritten = 0;
    }

writemore:

    cb = BufferSize;
    if (cb > MAX_MANIP_TRANSFER)
    {
        cb = MAX_MANIP_TRANSFER;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWritePhysicalMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    a = &m.u.WriteMemory;
    a->TargetBaseAddress = Offset + cb2;
    a->TransferCount = cb;
    // The ActualBytes fields have been overloaded to
    // allow passing in flags for the request.  Previous
    // debuggers passed zero so that should always be
    // the default.
    a->ActualBytesWritten = Flags;

    //
    // Send the message and data to write and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 (PVOID)((ULONG_PTR)Buffer + cb2),
                                 (USHORT)cb);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWritePhysicalMemoryApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.WriteMemory;
    DBG_ASSERT(a->ActualBytesWritten <= cb);

    //
    // Return actual bytes written
    //

    if (ARGUMENT_PRESENT(BytesWritten))
    {
        *BytesWritten += a->ActualBytesWritten;
    }

    if (NT_SUCCESS(st))
    {
        BufferSize -= a->ActualBytesWritten;
        cb2 += a->ActualBytesWritten;

        if (BufferSize)
        {
            goto writemore;
        }
    }

    KdOut("KdWritePhysical(%s, %x) returns %08lx, %x\n",
          FormatAddr64(Offset), OrigBufferSize, st, cb2);

    if (NT_SUCCESS(st))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_PHYSICAL);
    }

    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_MEMORY64 a = &m.u.ReadMemory;
    NTSTATUS st = STATUS_UNSUCCESSFUL;
    ULONG rc;

    if (BufferSize > MAX_MANIP_TRANSFER)
    {
        return E_INVALIDARG;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadControlSpaceApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (SHORT)Processor;
    a->TargetBaseAddress = Offset;
    a->TransferCount = BufferSize;
    a->ActualBytesRead = 0L;

    //
    // Send the message and then wait for reply
    //
    
    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadControlSpaceApi);
    
    st = Reply->ReturnStatus;

    //
    // Reset message address to reply.
    //

    a = &Reply->u.ReadMemory;
    DBG_ASSERT(a->ActualBytesRead <= BufferSize);

    //
    // Return actual bytes read, and then transfer the bytes
    //

    if (ARGUMENT_PRESENT(BytesRead))
    {
        *BytesRead = a->ActualBytesRead;
    }

    //
    // Since read response data follows message, Reply+1 should point
    // at the data
    //

    memcpy(Buffer, Reply + 1, (int)a->ActualBytesRead);

    KdOut("DbgKdReadControlSpace returns %08lx\n", st);
    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_WRITE_MEMORY64 a = &m.u.WriteMemory;
    NTSTATUS st;
    ULONG rc;

    if (BufferSize > MAX_MANIP_TRANSFER)
    {
        return E_INVALIDARG;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteControlSpaceApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (USHORT)Processor;
    a->TargetBaseAddress = Offset;
    a->TransferCount = BufferSize;
    a->ActualBytesWritten = 0L;

    //
    // Send the message and data to write and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 Buffer, (USHORT)BufferSize);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteControlSpaceApi);

    st = Reply->ReturnStatus;

    a = &Reply->u.WriteMemory;
    DBG_ASSERT(a->ActualBytesWritten <= BufferSize);

    //
    // Return actual bytes written
    //

    *BytesWritten = a->ActualBytesWritten;

    KdOut("DbgWriteControlSpace returns %08lx\n", st);
    
    if (NT_SUCCESS(st))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_CONTROL);
    }
    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS st;
    ULONG rc;
    ULONG DataValue;

    switch(BufferSize)
    {
    case 1:
    case 2:
    case 4:
        break;
    default:
        return E_INVALIDARG;
    }

    if (!(AddressSpace == 0 || AddressSpace == 1))
    {
        return E_INVALIDARG;
    }

    // Convert trivially extended I/O requests down into simple
    // requests as not all platform support extended requests.
    if (InterfaceType == Isa && BusNumber == 0 && AddressSpace == 1)
    {
        PDBGKD_READ_WRITE_IO64 a = &m.u.ReadWriteIo;

        //
        // Format state manipulate message
        //

        m.ApiNumber = DbgKdReadIoSpaceApi;
        m.ReturnStatus = STATUS_PENDING;

        a->DataSize = BufferSize;
        a->IoAddress = Offset;

        //
        // Send the message and then wait for reply
        //

        do
        {
            m_Transport->WritePacket(&m, sizeof(m),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     NULL, 0);
            rc = m_Transport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        } while (rc != DBGKD_WAIT_PACKET ||
                 Reply->ApiNumber != DbgKdReadIoSpaceApi);

        st = Reply->ReturnStatus;
        DataValue = Reply->u.ReadWriteIo.DataValue;

        KdOut("DbgKdReadIoSpace returns %08lx\n", st);
    }
    else
    {
        PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m.u.ReadWriteIoExtended;

        //
        // Format state manipulate message
        //

        m.ApiNumber = DbgKdReadIoSpaceExtendedApi;
        m.ReturnStatus = STATUS_PENDING;

        a->DataSize = BufferSize;
        a->IoAddress = Offset;
        a->InterfaceType = InterfaceType;
        a->BusNumber = BusNumber;
        a->AddressSpace = AddressSpace;

        //
        // Send the message and then wait for reply
        //

        do
        {
            m_Transport->WritePacket(&m, sizeof(m),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     NULL, 0);
            rc = m_Transport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        } while (rc != DBGKD_WAIT_PACKET ||
                 Reply->ApiNumber != DbgKdReadIoSpaceExtendedApi);

        st = Reply->ReturnStatus;
        DataValue = Reply->u.ReadWriteIoExtended.DataValue;

        KdOut("DbgKdReadIoSpaceExtended returns %08lx\n", st);
    }

    if (NT_SUCCESS(st))
    {
        switch(BufferSize)
        {
        case 1:
            *(PUCHAR)Buffer = (UCHAR)DataValue;
            break;
        case 2:
            *(PUSHORT)Buffer = (USHORT)DataValue;
            break;
        case 4:
            *(PULONG)Buffer = DataValue;
            break;
        }

        // I/O access currently can't successfully return anything
        // other than the requested size.
        if (BytesRead != NULL)
        {
            *BytesRead = BufferSize;
        }
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_NT(st);
    }
}

HRESULT
ConnLiveKernelTargetInfo::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS st;
    ULONG rc;
    ULONG DataValue;

    switch(BufferSize)
    {
    case 1:
        DataValue = *(PUCHAR)Buffer;
        break;
    case 2:
        DataValue = *(PUSHORT)Buffer;
        break;
    case 4:
        DataValue = *(PULONG)Buffer;
        break;
    default:
        return E_INVALIDARG;
    }

    if (!(AddressSpace == 0 || AddressSpace == 1))
    {
        return E_INVALIDARG;
    }

    // Convert trivially extended I/O requests down into simple
    // requests as not all platform support extended requests.
    if (InterfaceType == Isa && BusNumber == 0 && AddressSpace == 1)
    {
        PDBGKD_READ_WRITE_IO64 a = &m.u.ReadWriteIo;
        
        //
        // Format state manipulate message
        //

        m.ApiNumber = DbgKdWriteIoSpaceApi;
        m.ReturnStatus = STATUS_PENDING;

        a->DataSize = BufferSize;
        a->IoAddress = Offset;
        a->DataValue = DataValue;

        //
        // Send the message and then wait for reply
        //

        do
        {
            m_Transport->WritePacket(&m, sizeof(m),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     NULL, 0);
            rc = m_Transport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        } while (rc != DBGKD_WAIT_PACKET ||
                 Reply->ApiNumber != DbgKdWriteIoSpaceApi);

        st = Reply->ReturnStatus;

        KdOut("DbgKdWriteIoSpace returns %08lx\n", st);
    }
    else
    {
        PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m.u.ReadWriteIoExtended;

        //
        // Format state manipulate message
        //

        m.ApiNumber = DbgKdWriteIoSpaceExtendedApi;
        m.ReturnStatus = STATUS_PENDING;

        a->DataSize = BufferSize;
        a->IoAddress = Offset;
        a->DataValue = DataValue;
        a->InterfaceType = InterfaceType;
        a->BusNumber = BusNumber;
        a->AddressSpace = AddressSpace;

        //
        // Send the message and then wait for reply
        //

        do
        {
            m_Transport->WritePacket(&m, sizeof(m),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     NULL, 0);
            rc = m_Transport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        } while (rc != DBGKD_WAIT_PACKET ||
                 Reply->ApiNumber != DbgKdWriteIoSpaceExtendedApi);

        st = Reply->ReturnStatus;

        KdOut("DbgKdWriteIoSpaceExtended returns %08lx\n", st);
    }

    if (NT_SUCCESS(st))
    {
        // I/O access currently can't successfully return anything
        // other than the requested size.
        if (BytesWritten != NULL)
        {
            *BytesWritten = BufferSize;
        }
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_IO);
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_NT(st);
    }
}

HRESULT
ConnLiveKernelTargetInfo::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_MSR a = &m.u.ReadWriteMsr;
    LARGE_INTEGER li;
    NTSTATUS st;
    ULONG rc;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdReadMachineSpecificRegister;
    m.ReturnStatus = STATUS_PENDING;

    a->Msr = Msr;

    //
    // Send the message and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdReadMachineSpecificRegister);

    st = Reply->ReturnStatus;
    a = &Reply->u.ReadWriteMsr;

    li.LowPart = a->DataValueLow;
    li.HighPart = a->DataValueHigh;
    *Value = li.QuadPart;

    KdOut("DbgKdReadMsr returns %08lx\n", st);

    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_READ_WRITE_MSR a = &m.u.ReadWriteMsr;
    LARGE_INTEGER li;
    NTSTATUS st;
    ULONG rc;

    li.QuadPart = Value;

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdWriteMachineSpecificRegister;
    m.ReturnStatus = STATUS_PENDING;

    // Quiet PREfix warnings.
    m.Processor = 0;
    m.ProcessorLevel = 0;

    a->Msr = Msr;
    a->DataValueLow = li.LowPart;
    a->DataValueHigh = li.HighPart;

    //
    // Send the message and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdWriteMachineSpecificRegister);

    st = Reply->ReturnStatus;

    KdOut("DbgKdWriteMsr returns %08lx\n", st);

    if (NT_SUCCESS(st))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_MSR);
    }
    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_SET_BUS_DATA a = &m.u.GetSetBusData;
    NTSTATUS st;
    ULONG rc;

    //
    // Check the buffer size.
    //

    if (BufferSize > MAX_MANIP_TRANSFER)
    {
        return E_INVALIDARG;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdGetBusDataApi;
    m.ReturnStatus = STATUS_PENDING;

    a->BusDataType = BusDataType;
    a->BusNumber = BusNumber;
    a->SlotNumber = SlotNumber;
    a->Offset = Offset;
    a->Length = BufferSize;

    //
    // Send the message and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdGetBusDataApi);

    st = Reply->ReturnStatus;

    if (NT_SUCCESS(st))
    {
        a = &Reply->u.GetSetBusData;
        memcpy(Buffer, Reply + 1, a->Length);
        if (BytesRead != NULL)
        {
            *BytesRead = a->Length;
        }
    }

    KdOut("DbgKdGetBusData returns %08lx\n", st);

    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_SET_BUS_DATA a = &m.u.GetSetBusData;
    NTSTATUS st;
    ULONG rc;

    //
    // Check the buffer size.
    //

    if (BufferSize > MAX_MANIP_TRANSFER)
    {
        return E_INVALIDARG;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdSetBusDataApi;
    m.ReturnStatus = STATUS_PENDING;

    a->BusDataType = BusDataType;
    a->BusNumber = BusNumber;
    a->SlotNumber = SlotNumber;
    a->Offset = Offset;
    a->Length = BufferSize;

    //
    // Send the message and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 Buffer, (USHORT)BufferSize);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdSetBusDataApi);

    st = Reply->ReturnStatus;

    if (NT_SUCCESS(st) && BytesWritten != NULL)
    {
        a = &Reply->u.GetSetBusData;
        *BytesWritten = a->Length;
    }

    KdOut("DbgKdSetBusData returns %08lx\n", st);

    if (NT_SUCCESS(st))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_BUS_DATA);
    }
    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::CheckLowMemory(void)
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    ULONG rc;

    //
    // Format state manipulate message
    //

    ZeroMemory(&m, sizeof(m));
    m.ApiNumber = DbgKdCheckLowMemoryApi;
    m.ReturnStatus = STATUS_PENDING;

    //
    // We wait for an answer from the kernel side.
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET);

    if (Reply->ReturnStatus != STATUS_SUCCESS)
    {
        ErrOut("Corrupted page with pfn %x\n", Reply->ReturnStatus);
    }

    KdOut("DbgKdCheckLowMemory 0x00000000\n");

    return S_OK;
}

NTSTATUS
ConnLiveKernelTargetInfo::KdFillMemory(IN ULONG Flags,
                                       IN ULONG64 Start,
                                       IN ULONG Size,
                                       IN PVOID Pattern,
                                       IN ULONG PatternSize,
                                       OUT PULONG Filled)
{
    ULONG NtStatus;
    DBGKD_MANIPULATE_STATE64 Manip;
    PDBGKD_MANIPULATE_STATE64 Reply;
    NTSTATUS Status = STATUS_SUCCESS;

    DBG_ASSERT(m_KdMaxManipulate > DbgKdFillMemoryApi &&
               (Flags & 0xffff0000) == 0 &&
               PatternSize <= MAX_MANIP_TRANSFER);

    // Invalidate any cached memory.
    if (Flags & DBGKD_FILL_MEMORY_VIRTUAL)
    {
        InvalidateMemoryCaches(TRUE);
    }
    else if (Flags & DBGKD_FILL_MEMORY_PHYSICAL)
    {
        m_PhysicalCache.Remove(Start, Size);
    }
    
    //
    // Initialize state manipulate message to fill memory.
    //

    Manip.ApiNumber = DbgKdFillMemoryApi;
    Manip.u.FillMemory.Address = Start;
    Manip.u.FillMemory.Length = Size;
    Manip.u.FillMemory.Flags = (USHORT)Flags;
    Manip.u.FillMemory.PatternLength = (USHORT)PatternSize;
    
    //
    // Send the message and data to the target system and wait
    // for a reply.
    //

    ULONG Recv;

    do
    {
        m_Transport->WritePacket(&Manip, sizeof(Manip),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 Pattern, (USHORT)PatternSize);
        Recv = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    }
    while ((Recv != DBGKD_WAIT_PACKET) ||
           (Reply->ApiNumber != DbgKdFillMemoryApi));

    NtStatus = Reply->ReturnStatus;
    *Filled = Reply->u.FillMemory.Length;

    KdOut("DbgKdFillMemory returns %08lx\n", NtStatus);

    return NtStatus;
}

HRESULT
ConnLiveKernelTargetInfo::FillVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status;
    
    if (m_KdMaxManipulate <= DbgKdFillMemoryApi ||
        PatternSize > MAX_MANIP_TRANSFER)
    {
        Status = TargetInfo::FillVirtual(Process, Start, Size, Pattern,
                                         PatternSize, Filled);
    }
    else
    {
        NTSTATUS NtStatus =
            KdFillMemory(DBGKD_FILL_MEMORY_VIRTUAL, Start, Size,
                         Pattern, PatternSize, Filled);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::FillPhysical(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT PULONG Filled
    )
{
    HRESULT Status;
    
    if (m_KdMaxManipulate <= DbgKdFillMemoryApi ||
        PatternSize > MAX_MANIP_TRANSFER)
    {
        Status = TargetInfo::FillPhysical(Start, Size, Pattern,
                                          PatternSize, Filled);
    }
    else
    {
        NTSTATUS NtStatus =
            KdFillMemory(DBGKD_FILL_MEMORY_PHYSICAL, Start, Size,
                         Pattern, PatternSize, Filled);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::QueryAddressInformation(ProcessInfo* Process,
                                                  ULONG64 Address,
                                                  ULONG InSpace,
                                                  PULONG OutSpace,
                                                  PULONG OutFlags)
{
    HRESULT Status;

    if (m_KdMaxManipulate <= DbgKdQueryMemoryApi)
    {
        Status = TargetInfo::QueryAddressInformation(Process, Address, InSpace,
                                                     OutSpace, OutFlags);
    }
    else
    {
        DBGKD_MANIPULATE_STATE64 Manip;
        PDBGKD_MANIPULATE_STATE64 Reply;
        NTSTATUS NtStatus;

        //
        // Initialize state manipulate message to query memory.
        //

        Manip.ApiNumber = DbgKdQueryMemoryApi;
        Manip.u.QueryMemory.Address = Address;
        Manip.u.QueryMemory.Reserved = 0;
        Manip.u.QueryMemory.AddressSpace = InSpace;
        Manip.u.QueryMemory.Flags = 0;
    
        //
        // Send the message and data to the target system and wait
        // for a reply.
        //

        ULONG Recv;

        do
        {
            m_Transport->WritePacket(&Manip, sizeof(Manip),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     NULL, 0);
            Recv = m_Transport->
                WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
        }
        while ((Recv != DBGKD_WAIT_PACKET) ||
               (Reply->ApiNumber != DbgKdQueryMemoryApi));

        NtStatus = Reply->ReturnStatus;
        *OutSpace = Reply->u.QueryMemory.AddressSpace;
        *OutFlags = Reply->u.QueryMemory.Flags;

        KdOut("DbgKdQueryMemory returns %08lx\n", NtStatus);
        Status = CONV_NT_STATUS(NtStatus);
    }

    return Status;
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::ReadVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    SYSDBG_VIRTUAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesRead = 0;
    Cmd.Address = (PVOID)(ULONG_PTR)Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }

        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadWritePtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgReadVirtual,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesRead > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address = (PVOID)((PUCHAR)Cmd.Address + ChunkDone);
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesRead += ChunkDone;
    }
    
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    SYSDBG_VIRTUAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesWritten = 0;
    Cmd.Address = (PVOID)(ULONG_PTR)Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }

        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadReadPtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgWriteVirtual,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesWritten > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address = (PVOID)((PUCHAR)Cmd.Address + ChunkDone);
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesWritten += ChunkDone;
    }
    
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesRead
    )
{
    SYSDBG_PHYSICAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    if (Flags != PHYS_FLAG_DEFAULT)
    {
        return E_NOTIMPL;
    }
    
    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesRead = 0;
    Cmd.Address.QuadPart = Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }

        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadWritePtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgReadPhysical,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesRead > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address.QuadPart += ChunkDone;
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesRead += ChunkDone;
    }
    
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesWritten
    )
{
    SYSDBG_PHYSICAL Cmd;
    NTSTATUS Status = STATUS_SUCCESS;

    if (Flags != PHYS_FLAG_DEFAULT)
    {
        return E_NOTIMPL;
    }
    
    //
    // The kernel only allows operations up to
    // KDP_MESSAGE_BUFFER_SIZE, so break things up
    // into chunks if necessary.
    //

    *BytesWritten = 0;
    Cmd.Address.QuadPart = Offset;
    Cmd.Buffer = Buffer;
    
    while (BufferSize > 0)
    {
        ULONG ChunkDone;

        if (BufferSize > PACKET_MAX_SIZE)
        {
            Cmd.Request = PACKET_MAX_SIZE;
        }
        else
        {
            Cmd.Request = BufferSize;
        }
        
        // The kernel stubs avoid faults so all memory
        // must be paged in ahead of time.  There's
        // still the possibility that something could
        // get paged out after this but the assumption is
        // that the vulnerability is small and it's much
        // better than implementing dual code paths in
        // the kernel.
        if (IsBadReadPtr(Cmd.Buffer, Cmd.Request))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        ChunkDone = 0;
        Status =
            g_NtDllCalls.NtSystemDebugControl(SysDbgWritePhysical,
                                              &Cmd, sizeof(Cmd),
                                              NULL, 0,
                                              &ChunkDone);
        if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL)
        {
            break;
        }
        if (ChunkDone == 0)
        {
            // If some data was processed consider it a success.
            Status = *BytesWritten > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
            break;
        }

        Cmd.Address.QuadPart += ChunkDone;
        Cmd.Buffer = (PVOID)((PUCHAR)Cmd.Buffer + ChunkDone);
        BufferSize -= ChunkDone;
        *BytesWritten += ChunkDone;
    }
    
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_PHYSICAL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadWritePtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_CONTROL_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.Processor = Processor;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadControlSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadReadPtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_CONTROL_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.Processor = Processor;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteControlSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_CONTROL);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadWritePtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_IO_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.InterfaceType = (INTERFACE_TYPE)InterfaceType;
    Cmd.BusNumber = BusNumber;
    Cmd.AddressSpace = AddressSpace;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadIoSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadReadPtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_IO_SPACE Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.InterfaceType = (INTERFACE_TYPE)InterfaceType;
    Cmd.BusNumber = BusNumber;
    Cmd.AddressSpace = AddressSpace;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteIoSpace,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_IO);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    SYSDBG_MSR Cmd;
    Cmd.Msr = Msr;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadMsr,
                                          &Cmd, sizeof(Cmd),
                                          &Cmd, sizeof(Cmd),
                                          NULL);
    if (NT_SUCCESS(Status))
    {
        *Value = Cmd.Data;
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    SYSDBG_MSR Cmd;
    Cmd.Msr = Msr;
    Cmd.Data = Value;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteMsr,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          NULL);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_MSR);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadWritePtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_BUS_DATA Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.BusDataType = (BUS_DATA_TYPE)BusDataType;
    Cmd.BusNumber = BusNumber;
    Cmd.SlotNumber = SlotNumber;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgReadBusData,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesRead);
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // The kernel stubs avoid faults so all memory
    // must be paged in ahead of time.  There's
    // still the possibility that something could
    // get paged out after this but the assumption is
    // that the vulnerability is small and it's much
    // better than implementing dual code paths in
    // the kernel.
    if (IsBadReadPtr(Buffer, BufferSize))
    {
        return E_INVALIDARG;
    }

    SYSDBG_BUS_DATA Cmd;
    Cmd.Address = Offset;
    Cmd.Buffer = Buffer;
    Cmd.Request = BufferSize;
    Cmd.BusDataType = (BUS_DATA_TYPE)BusDataType;
    Cmd.BusNumber = BusNumber;
    Cmd.SlotNumber = SlotNumber;
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgWriteBusData,
                                          &Cmd, sizeof(Cmd),
                                          NULL, 0,
                                          BytesWritten);
    if (NT_SUCCESS(Status))
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_BUS_DATA);
    }
    return CONV_NT_STATUS(Status);
}

HRESULT
LocalLiveKernelTargetInfo::CheckLowMemory(
    )
{
    NTSTATUS Status =
        g_NtDllCalls.NtSystemDebugControl(SysDbgCheckLowMemory,
                                          NULL, 0,
                                          NULL, 0,
                                          NULL);
    return CONV_NT_STATUS(Status);
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
ExdiLiveKernelTargetInfo::ReadVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status = m_Server->
        ReadVirtualMemory(Offset, BufferSize, 8, (PBYTE)Buffer, BytesRead);
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status = m_Server->
        WriteVirtualMemory(Offset, BufferSize, 8, (PBYTE)Buffer, BytesWritten);
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesRead
    )
{
    if (Flags != PHYS_FLAG_DEFAULT)
    {
        return E_NOTIMPL;
    }
    
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Offset, 0, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesRead = BufferSize;
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN ULONG Flags,
    OUT PULONG BytesWritten
    )
{
    if (Flags != PHYS_FLAG_DEFAULT)
    {
        return E_NOTIMPL;
    }
    
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Offset, 0, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesWritten = BufferSize;
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_PHYSICAL);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // No Ioctl defined for this.
    return E_UNEXPECTED;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // No Ioctl defined for this.
    return E_UNEXPECTED;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status = m_Server->
        ReadPhysicalMemoryOrPeriphIO(Offset, 1, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesRead = BufferSize;
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status = m_Server->
        WritePhysicalMemoryOrPeriphIO(Offset, 1, BufferSize, 8, (PBYTE)Buffer);
    if (Status == S_OK)
    {
        *BytesWritten = BufferSize;
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_IO);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    HRESULT Status;
    
    if (DBGENG_EXDI_IOC_READ_MSR <= m_IoctlMin ||
        DBGENG_EXDI_IOC_READ_MSR >= m_IoctlMax)
    {
        // Read MSR Ioctl not supported.
        return E_NOTIMPL;
    }

    DBGENG_EXDI_IOCTL_MSR_IN IoctlIn;
    DBGENG_EXDI_IOCTL_READ_MSR_OUT IoctlOut;
    ULONG OutUsed;

    IoctlIn.Code = DBGENG_EXDI_IOC_READ_MSR;
    IoctlIn.Index = Msr;
    if ((Status = m_Server->
         Ioctl(sizeof(IoctlIn), (PBYTE)&IoctlIn,
               sizeof(IoctlOut), &OutUsed, (PBYTE)&IoctlOut)) != S_OK)
    {
        return Status;
    }

    *Value = IoctlOut.Value;
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    HRESULT Status;
    
    if (DBGENG_EXDI_IOC_WRITE_MSR <= m_IoctlMin ||
        DBGENG_EXDI_IOC_WRITE_MSR >= m_IoctlMax)
    {
        // Write MSR Ioctl not supported.
        return E_NOTIMPL;
    }

    DBGENG_EXDI_IOCTL_MSR_IN IoctlIn;
    ULONG OutUsed;

    IoctlIn.Code = DBGENG_EXDI_IOC_WRITE_MSR;
    IoctlIn.Index = Msr;
    IoctlIn.Value = Value;
    Status = m_Server->Ioctl(sizeof(IoctlIn), (PBYTE)&IoctlIn,
                             0, &OutUsed, (PBYTE)&IoctlIn);
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_MSR);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // No Ioctl defined for this.
    return E_UNEXPECTED;
}

HRESULT
ExdiLiveKernelTargetInfo::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    // No Ioctl defined for this.
    return E_UNEXPECTED;
}

HRESULT
ExdiLiveKernelTargetInfo::CheckLowMemory(
    )
{
    // XXX drewb - This doesn't have any meaning in
    // the general case.  What about when we know it's
    // NT on the other side of the emulator?
    return E_UNEXPECTED;
}

//----------------------------------------------------------------------------
//
// UserTargetInfo data space methods.
//
//----------------------------------------------------------------------------

HRESULT
LiveUserTargetInfo::ReadVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    if (m_Local)
    {
        return ReadVirtualUncached(Process,
                                   Offset, Buffer, BufferSize, BytesRead);
    }
    else
    {
        return Process->m_VirtualCache.
            Read(Offset, Buffer, BufferSize, BytesRead);
    }
}

HRESULT
LiveUserTargetInfo::WriteVirtual(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    if (m_Local)
    {
        return WriteVirtualUncached(Process,
                                    Offset, Buffer, BufferSize, BytesWritten);
    }
    else
    {
        return Process->m_VirtualCache.
            Write(Offset, Buffer, BufferSize, BytesWritten);
    }
}

HRESULT
LiveUserTargetInfo::ReadVirtualUncached(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    // ReadProcessMemory will fail if any part of the
    // region to read does not have read access.  This
    // routine attempts to read the largest valid prefix
    // so it has to break up reads on page boundaries.

    HRESULT Status = S_OK;
    ULONG TotalBytesRead = 0;
    ULONG Read;
    ULONG ReadSize;

    while (BufferSize > 0)
    {
        // Calculate bytes to read and don't let read cross
        // a page boundary.
        ReadSize = m_Machine->m_PageSize - (ULONG)
            (Offset & (m_Machine->m_PageSize - 1));
        ReadSize = min(BufferSize, ReadSize);

        if ((Status = m_Services->
             ReadVirtual(Process->m_SysHandle, Offset,
                         Buffer, ReadSize, &Read)) != S_OK)
        {
            if (TotalBytesRead != 0)
            {
                // If we've read something consider this a success.
                Status = S_OK;
            }
            break;
        }

        TotalBytesRead += Read;
        Offset += Read;
        Buffer = (PVOID)((PUCHAR)Buffer + Read);
        BufferSize -= (DWORD)Read;
    }

    if (Status == S_OK)
    {
        if (BytesRead != NULL)
        {
            *BytesRead = (DWORD)TotalBytesRead;
        }
    }

    return Status;
}

HRESULT
LiveUserTargetInfo::WriteVirtualUncached(
    THIS_
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    ULONG RealBytesWritten;
    HRESULT Status = m_Services->
        WriteVirtual(Process->m_SysHandle, Offset, Buffer, BufferSize,
                     &RealBytesWritten);
    *BytesWritten = (DWORD) RealBytesWritten;
    if (Status == S_OK)
    {
        NotifyChangeDebuggeeState(DEBUG_CDS_DATA, DEBUG_DATA_SPACE_VIRTUAL);
    }
    return Status;
}

HRESULT
LiveUserTargetInfo::GetUnloadedModuleListHead(ProcessInfo* Process,
                                          PULONG64 Head)
{
    // Get the address of the dynamic function table list head which is the
    // the same for all processes. This only has to be done once.

    if (Process->m_RtlUnloadList)
    {
        *Head = Process->m_RtlUnloadList;
        return S_OK;
    }

    if (m_Services->
        GetUnloadedModuleListHead(Process->m_SysHandle,
                                  &Process->m_RtlUnloadList) == S_OK)
    {
        *Head = Process->m_RtlUnloadList;
        return S_OK;
    }

    return TargetInfo::GetUnloadedModuleListHead(Process, Head);
}

HRESULT
LiveUserTargetInfo::GetFunctionTableListHead(ProcessInfo* Process, PULONG64 Head)
{
    // Get the address of the dynamic function table list head which is the
    // the same for all processes. This only has to be done once.

    if (Process->m_DynFuncTableList)
    {
        *Head = Process->m_DynFuncTableList;
        return S_OK;
    }

    if (m_Services->
        GetFunctionTableListHead(Process->m_SysHandle,
                                 &Process->m_DynFuncTableList) == S_OK)
    {
        *Head = Process->m_DynFuncTableList;
        return S_OK;
    }

    return TargetInfo::GetFunctionTableListHead(Process, Head);
}

HRESULT
LiveUserTargetInfo::ReadOutOfProcessDynamicFunctionTable(ProcessInfo* Process,
                                                         PWSTR Dll,
                                                         ULONG64 Table,
                                                         PULONG RetTableSize,
                                                         PVOID* RetTableData)
{
    HRESULT Status;
    PVOID TableData;
    ULONG TableSize;

    // Allocate an initial buffer of a reasonable size to try
    // and get the data in a single call.
    TableSize = 65536;

    for (;;)
    {
        TableData = malloc(TableSize);
        if (TableData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // We assume that the function table data doesn't
        // change between OOP calls as long as the debuggee isn't
        // executing.  To increase performance we cache loaded
        // DLLs as long as things are halted.
        //

        OUT_OF_PROC_FUNC_TABLE_DLL* OopDll =
            Process->FindOopFuncTableDll(Dll);
        ULONG64 DllHandle;
        
        Status = m_Services->
            GetOutOfProcessFunctionTableW(Process->m_SysHandle,
                                          Dll, OopDll ? OopDll->Handle : 0,
                                          Table, TableData,
                                          TableSize, &TableSize,
                                          &DllHandle);
        if (Status == S_OK)
        {
            // If we haven't cached this DLL yet do so now.
            if (!OopDll)
            {
                // Failure to cache isn't critical, it
                // just means more loads later.
                if (Process->AddOopFuncTableDll(Dll, DllHandle) != S_OK)
                {
                    m_Services->FreeLibrary(DllHandle);
                }
            }
            break;
        }

        free(TableData);
        
        if (Status == S_FALSE)
        {
            // Buffer was too small so loop and try again with
            // the newly retrieved size.
        }
        else
        {
            return Status;
        }
    }

    *RetTableSize = TableSize;
    *RetTableData = TableData;
    return S_OK;
}

HRESULT
LiveUserTargetInfo::QueryMemoryRegion(ProcessInfo* Process,
                                  PULONG64 Handle,
                                  BOOL HandleIsOffset,
                                  PMEMORY_BASIC_INFORMATION64 Info)
{
    MEMORY_BASIC_INFORMATION64 MemInfo;
    HRESULT Status;
    
    for (;;)
    {
        ULONG Used;

        // The handle is always an offset in this mode so
        // there's no need to check.
        if ((Status = m_Services->
             QueryVirtual(Process->m_SysHandle,
                          *Handle, &MemInfo, sizeof(MemInfo), &Used)) != S_OK)
        {
            return Status;
        }
        if (m_Machine->m_Ptr64)
        {
            if (Used != sizeof(MEMORY_BASIC_INFORMATION64))
            {
                return E_FAIL;
            }

            *Info = MemInfo;
        }
        else
        {
            if (Used != sizeof(MEMORY_BASIC_INFORMATION32))
            {
                return E_FAIL;
            }

            MemoryBasicInformation32To64((MEMORY_BASIC_INFORMATION32*)&MemInfo,
                                         Info);
        }
        
        if (HandleIsOffset ||
            !((Info->Protect & PAGE_GUARD) ||
              (Info->Protect & PAGE_NOACCESS) ||
              (Info->State & MEM_FREE) ||
              (Info->State & MEM_RESERVE)))
        {
            break;
        }
        
        *Handle = Info->BaseAddress + Info->RegionSize;
    }

    *Handle = Info->BaseAddress + Info->RegionSize;
    
    return S_OK;
}

HRESULT
LiveUserTargetInfo::ReadHandleData(
    IN ProcessInfo* Process,
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    return m_Services->
        ReadHandleData(Process->m_SysHandle,
                       Handle, DataType, Buffer, BufferSize,
                       DataSize);
}

HRESULT
LiveUserTargetInfo::GetProcessorId(
    ULONG Processor,
    PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id
    )
{
    ULONG Done;
    
    return m_Services->GetProcessorId(Id, sizeof(*Id), &Done);
}

HRESULT
LiveUserTargetInfo::GetProcessorSpeed(
    ULONG Processor,
    PULONG Speed
    )
{
    return E_UNEXPECTED;
}

HRESULT
LiveUserTargetInfo::GetGenericProcessorFeatures(
    ULONG Processor,
    PULONG64 Features,
    ULONG FeaturesSize,
    PULONG Used
    )
{
    return m_Services->
        GetGenericProcessorFeatures(Features, FeaturesSize, Used);
}

HRESULT
LiveUserTargetInfo::GetSpecificProcessorFeatures(
    ULONG Processor,
    PULONG64 Features,
    ULONG FeaturesSize,
    PULONG Used
    )
{
    return m_Services->
        GetSpecificProcessorFeatures(Features, FeaturesSize, Used);
}

//----------------------------------------------------------------------------
//
// IDebugDataSpaces.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DebugClient::ReadVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;

        Status = CurReadVirtual(Offset, Buffer, BufferSize,
                                BytesRead != NULL ? BytesRead : &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteVirtual(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->WriteVirtual(g_Process, Offset, Buffer, BufferSize,
                                        BytesWritten != NULL ? BytesWritten :
                                        &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SearchVirtual(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Length,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    IN ULONG PatternGranularity,
    OUT PULONG64 MatchOffset
    )
{
    if (PatternGranularity == 0 ||
        PatternSize % PatternGranularity)
    {
        return E_INVALIDARG;
    }
    
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->SearchVirtual(g_Process, Offset, Length, Pattern,
                                         PatternSize, PatternGranularity,
                                         MatchOffset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            ReadVirtualUncached(g_Process, Offset, Buffer, BufferSize,
                                BytesRead != NULL ? BytesRead :
                                &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteVirtualUncached(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;

        Status = g_Target->
            WriteVirtualUncached(g_Process, Offset, Buffer, BufferSize,
                                 BytesWritten != NULL ? BytesWritten :
                                 &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadPointersVirtual(
    THIS_
    IN ULONG Count,
    IN ULONG64 Offset,
    OUT /* size_is(Count) */ PULONG64 Ptrs
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = S_OK;
        while (Count-- > 0)
        {
            if ((Status = g_Target->
                 ReadPointer(g_Process, g_Machine, Offset, Ptrs)) != S_OK)
            {
                break;
            }

            Offset += g_Machine->m_Ptr64 ? sizeof(ULONG64) : sizeof(ULONG);
            Ptrs++;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WritePointersVirtual(
    THIS_
    IN ULONG Count,
    IN ULONG64 Offset,
    IN /* size_is(Count) */ PULONG64 Ptrs
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = S_OK;
        while (Count-- > 0)
        {
            if ((Status = g_Target->
                 WritePointer(g_Process, g_Machine, Offset, *Ptrs)) != S_OK)
            {
                break;
            }

            Offset += g_Machine->m_Ptr64 ? sizeof(ULONG64) : sizeof(ULONG);
            Ptrs++;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadPhysical(
    THIS_
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            ReadPhysical(Offset, Buffer, BufferSize,
                         PHYS_FLAG_DEFAULT,
                         BytesRead != NULL ? BytesRead : &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WritePhysical(
    THIS_
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            WritePhysical(Offset, Buffer, BufferSize,
                          PHYS_FLAG_DEFAULT,
                          BytesWritten != NULL ? BytesWritten :
                          &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;

        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        g_Target->FlushRegContext();
    
        Status = g_Target->
            ReadControl(Processor, Offset, Buffer, BufferSize,
                        BytesRead != NULL ? BytesRead : &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteControl(
    THIS_
    IN ULONG Processor,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;

        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        g_Target->FlushRegContext();
    
        Status = g_Target->
            WriteControl(Processor, Offset, Buffer, BufferSize,
                         BytesWritten != NULL ? BytesWritten :
                         &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            ReadIo(InterfaceType, BusNumber, AddressSpace,
                   Offset, Buffer, BufferSize,
                   BytesRead != NULL ? BytesRead : &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteIo(
    THIS_
    IN ULONG InterfaceType,
    IN ULONG BusNumber,
    IN ULONG AddressSpace,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            WriteIo(InterfaceType, BusNumber, AddressSpace,
                    Offset, Buffer, BufferSize,
                    BytesWritten != NULL ? BytesWritten : &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadMsr(
    THIS_
    IN ULONG Msr,
    OUT PULONG64 Value
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->ReadMsr(Msr, Value);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteMsr(
    THIS_
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->WriteMsr(Msr, Value);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesRead
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            ReadBusData(BusDataType, BusNumber, SlotNumber,
                        Offset, Buffer, BufferSize,
                        BytesRead != NULL ? BytesRead : &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::WriteBusData(
    THIS_
    IN ULONG BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BytesWritten
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG BytesTemp;
        
        Status = g_Target->
            WriteBusData(BusDataType, BusNumber, SlotNumber,
                         Offset, Buffer, BufferSize,
                         BytesWritten != NULL ? BytesWritten :
                         &BytesTemp);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CheckLowMemory(
    THIS
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->CheckLowMemory();
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadDebuggerData(
    THIS_
    IN ULONG Index,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    // Wait till the machine is accessible because on dump files the
    // debugger data block requires symbols to be loaded.

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    PVOID Data;
    ULONG Size;
    ULONG64 DataSpace;

    if (Index < sizeof(g_Target->m_KdDebuggerData))
    {
        // Even though internally all of the debugger data is
        // a single buffer that could be read arbitrarily we
        // restrict access to the defined constants to
        // preserve the abstraction that each constant refers
        // to a separate piece of data.

        Data = (PUCHAR)&g_Target->m_KdDebuggerData + Index;
        Size = sizeof(ULONG64);

        if ((Index >= DEBUG_DATA_OffsetKThreadNextProcessor) &&
            (Index <= DEBUG_DATA_SizeEThread))
        {
            Size = sizeof(USHORT);
        }
        else if (Index & (sizeof(ULONG64) - 1))
        {
            Status = E_INVALIDARG;
            goto Exit;
        }
    }
    else
    {
        switch(Index)
        {
        case DEBUG_DATA_PaeEnabled:
            DataSpace = (BOOLEAN)g_Target->m_KdDebuggerData.PaeEnabled;
            Data = &DataSpace;
            Size = sizeof(BOOLEAN);
            break;

        case DEBUG_DATA_SharedUserData:
            DataSpace = g_Target->m_TypeInfo.SharedUserDataOffset;
            Data = &DataSpace;
            Size = sizeof(ULONG64);
            break;

        case DEBUG_DATA_ProductType:
            Data = &g_Target->m_ProductType;
            Size = sizeof(g_Target->m_ProductType);
            break;
            
        case DEBUG_DATA_SuiteMask:
            Data = &g_Target->m_SuiteMask;
            Size = sizeof(g_Target->m_SuiteMask);
            break;
            
        default:
            Status = E_INVALIDARG;
            goto Exit;
        }
    }

    Status = FillDataBuffer(Data, Size, Buffer, BufferSize, DataSize);

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadProcessorSystemData(
    THIS_
    IN ULONG Processor,
    IN ULONG Index,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    HRESULT Status = S_OK;
    PVOID Data;
    ULONG Size;
    ULONG64 DataSpace;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL AllId;

    ENTER_ENGINE();

    switch(Index)
    {
    case DEBUG_DATA_KPCR_OFFSET:
    case DEBUG_DATA_KPRCB_OFFSET:
    case DEBUG_DATA_KTHREAD_OFFSET:
        if (!IS_MACHINE_SET(g_Target))
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            Status = g_Target->
                GetProcessorSystemDataOffset(Processor, Index, &DataSpace);
            Data = &DataSpace;
            Size = sizeof(DataSpace);
        }
        break;

    case DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET:
        if (!IS_MACHINE_SET(g_Target))
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            Status = g_Machine->GetBaseTranslationVirtualOffset(&DataSpace);
            Data = &DataSpace;
            Size = sizeof(DataSpace);
        }
        break;

    case DEBUG_DATA_PROCESSOR_IDENTIFICATION:
        if (!g_Target)
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            ZeroMemory(&AllId, sizeof(AllId));
            Status = g_Target->GetProcessorId(Processor, &AllId);
            Data = &AllId;
            Size = sizeof(AllId);
        }
        break;
    
    case DEBUG_DATA_PROCESSOR_SPEED:
        if (!g_Target)
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            DataSpace = 0;
            Status = g_Target->
                GetProcessorSpeed(Processor, (PULONG) &DataSpace);
            Data = &DataSpace;
            Size = sizeof(ULONG);
        }
        break;

    default:
        Status = E_INVALIDARG;
        break;
    }

    if (Status == S_OK)
    {
        if (DataSize != NULL)
        {
            *DataSize = Size;
        }
            
        if (BufferSize < Size)
        {
            Status = S_FALSE;
            Size = BufferSize;
        }
            
        memcpy(Buffer, Data, Size);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::VirtualToPhysical(
    THIS_
    IN ULONG64 Virtual,
    OUT PULONG64 Physical
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Levels;
        ULONG PfIndex;
        
        Status = g_Machine->
            GetVirtualTranslationPhysicalOffsets(g_Thread, Virtual, NULL, 0,
                                                 &Levels, &PfIndex, Physical);
        // GVTPO returns a special error code if the translation
        // succeeded down to the level of the actual data but
        // the data page itself is in the page file.  This is used
        // for the page file dump support.  To an external caller,
        // though, it's not useful so translate it into the standard
        // page-not-available error.
        if (Status == HR_PAGE_IN_PAGE_FILE)
        {
            Status = HR_PAGE_NOT_AVAILABLE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetVirtualTranslationPhysicalOffsets(
    THIS_
    IN ULONG64 Virtual,
    OUT OPTIONAL /* size_is(OffsetsSize) */ PULONG64 Offsets,
    IN ULONG OffsetsSize,
    OUT OPTIONAL PULONG Levels
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    ULONG _Levels = 0;
    
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG PfIndex;
        ULONG64 LastPhys;
        
        Status = g_Machine->
            GetVirtualTranslationPhysicalOffsets(g_Thread, Virtual, Offsets,
                                                 OffsetsSize, &_Levels,
                                                 &PfIndex, &LastPhys);
        // GVTPO returns a special error code if the translation
        // succeeded down to the level of the actual data but
        // the data page itself is in the page file.  This is used
        // for the page file dump support.  To an external caller,
        // though, it's not useful so translate it into the standard
        // page-not-available error.
        if (Status == HR_PAGE_IN_PAGE_FILE)
        {
            Status = HR_PAGE_NOT_AVAILABLE;
        }

        // If no translations occurred return the given failure.
        // If there was a failure but translations occurred return
        // S_FALSE to indicate the translation was incomplete.
        if (_Levels > 0 && Status != S_OK)
        {
            Status = S_FALSE;
        }
    }

    if (Levels != NULL)
    {
        *Levels = _Levels;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadHandleData(
    THIS_
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Process)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->ReadHandleData(g_Process, Handle, DataType, Buffer,
                                          BufferSize, DataSize);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::FillVirtual(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT OPTIONAL PULONG Filled
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (PatternSize == 0)
    {
        Status = E_INVALIDARG;
    }
    else if (!g_Target || !g_Process)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG _Filled = 0;
        
        Status = g_Target->FillVirtual(g_Process,
                                       Start, Size, Pattern, PatternSize,
                                       &_Filled);
        if (Filled != NULL)
        {
            *Filled = _Filled;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::FillPhysical(
    THIS_
    IN ULONG64 Start,
    IN ULONG Size,
    IN PVOID Pattern,
    IN ULONG PatternSize,
    OUT OPTIONAL PULONG Filled
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (PatternSize == 0)
    {
        Status = E_INVALIDARG;
    }
    else if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG _Filled = 0;
        
        Status = g_Target->
            FillPhysical(Start, Size, Pattern, PatternSize, &_Filled);
        if (Filled != NULL)
        {
            *Filled = _Filled;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::QueryVirtual(
    THIS_
    IN ULONG64 Offset,
    OUT PMEMORY_BASIC_INFORMATION64 Info
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target || !g_Process)
    {
        Status = E_UNEXPECTED;
    }
    else if (!IS_USER_TARGET(g_Target))
    {
        return E_NOTIMPL;
    }
    else
    {
        ULONG64 Handle = Offset;
        
        Status = g_Target->QueryMemoryRegion(g_Process, &Handle, TRUE, Info);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadImageNtHeaders(
    THIS_
    IN ULONG64 ImageBase,
    OUT PIMAGE_NT_HEADERS64 Headers
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target || !g_Process)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->ReadImageNtHeaders(g_Process, ImageBase, Headers);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetFirstBlobHeaderOffset(PULONG64 OffsetRet)
{
    HRESULT Status;
    ULONG64 Offset;
    DUMP_BLOB_FILE_HEADER FileHdr;

    if ((Status = g_Target->
         GetTaggedBaseOffset(&Offset)) != S_OK ||
        (Status = g_Target->
         ReadTagged(Offset, &FileHdr, sizeof(FileHdr))) != S_OK)
    {
        return Status;
    }

    if (FileHdr.Signature1 != DUMP_BLOB_SIGNATURE1 ||
        FileHdr.Signature2 != DUMP_BLOB_SIGNATURE2)
    {
        // No blob data.
        return E_NOINTERFACE;
    }
    if (FileHdr.HeaderSize != sizeof(FileHdr))
    {
        return HR_DATA_CORRUPT;
    }

    *OffsetRet = Offset + FileHdr.HeaderSize;
    return S_OK;
}

HRESULT
ReadBlobHeaderAtOffset(ULONG64 Offset, PDUMP_BLOB_HEADER BlobHdr)
{
    HRESULT Status;
    
    if ((Status = g_Target->
         ReadTagged(Offset, BlobHdr, sizeof(*BlobHdr))) != S_OK)
    {
        return Status;
    }

    if (BlobHdr->HeaderSize != sizeof(*BlobHdr))
    {
        return HR_DATA_CORRUPT;
    }

    return S_OK;
}

STDMETHODIMP
DebugClient::ReadTagged(
    THIS_
    IN LPGUID Tag,
    IN ULONG Offset,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TotalSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    ULONG64 HdrOffs;
    DUMP_BLOB_HEADER BlobHdr;

    if ((Status = GetFirstBlobHeaderOffset(&HdrOffs)) != S_OK)
    {
        goto Exit;
    }

    for (;;)
    {
        if ((Status = ReadBlobHeaderAtOffset(HdrOffs, &BlobHdr)) != S_OK)
        {
            // There's no way to know whether a blob should
            // be present or not so all failures just turn
            // into blob-not-present.
            Status = E_NOINTERFACE;
            goto Exit;
        }

        HdrOffs += BlobHdr.HeaderSize + BlobHdr.PrePad;

        if (DbgIsEqualIID(*Tag, BlobHdr.Tag))
        {
            break;
        }

        HdrOffs += BlobHdr.DataSize + BlobHdr.PostPad;
    }

    if (Offset >= BlobHdr.DataSize)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    if (TotalSize)
    {
        *TotalSize = BlobHdr.DataSize;
    }
    
    if (Buffer)
    {
        if (BufferSize > BlobHdr.DataSize)
        {
            BufferSize = BlobHdr.DataSize;
        }

        Status = g_Target->ReadTagged(HdrOffs + Offset, Buffer, BufferSize);
    }
    else
    {
        Status = S_OK;
    }
    
 Exit:
    LEAVE_ENGINE();
    return Status;
}

struct TaggedEnum
{
    ULONG64 Offset;
};

STDMETHODIMP
DebugClient::StartEnumTagged(
    THIS_
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    TaggedEnum* Enum;

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else if (!(Enum = new TaggedEnum))
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        Status = GetFirstBlobHeaderOffset(&Enum->Offset);
        if (Status == S_OK)
        {
            *Handle = (ULONG64)(ULONG_PTR)Enum;
        }
        else
        {
            delete Enum;
        }
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNextTagged(
    THIS_
    IN ULONG64 Handle,
    OUT LPGUID Tag,
    OUT PULONG Size
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    TaggedEnum* Enum = (TaggedEnum*)(ULONG_PTR)Handle;
    DUMP_BLOB_HEADER BlobHdr;
    
    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else if ((Status = ReadBlobHeaderAtOffset(Enum->Offset,
                                              &BlobHdr)) != S_OK)
    {
        // There's no way to know whether a blob should
        // be present or not so all failures just turn
        // into blob-not-present.
        Status = S_FALSE;
        ZeroMemory(Tag, sizeof(*Tag));
        *Size = 0;
    }
    else
    {
        *Tag = BlobHdr.Tag;
        *Size = BlobHdr.DataSize;
        Enum->Offset += BlobHdr.HeaderSize + BlobHdr.PrePad +
            BlobHdr.DataSize + BlobHdr.PostPad;
    }
    
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndEnumTagged(
    THIS_
    IN ULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        delete (TaggedEnum*)(ULONG_PTR)Handle;
        Status = S_OK;
    }
    
    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgsym.hpp ===
//----------------------------------------------------------------------------
//
// Symbol interface implementations.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __DBGSYM_HPP__
#define __DBGSYM_HPP__

class DebugSymbolGroup;
class SymbolGroupFormat;

//----------------------------------------------------------------------------
//
// SymbolGroupEntry.
//
//----------------------------------------------------------------------------

enum SymbolGroupFormatKind
{
    SGFORMAT_TYPED_DATA,
    SGFORMAT_EXPRESSION,
    SGFORMAT_EXTENSION,
    SGFORMAT_TEXT,
};

// Used for locals when locals are added on change of scope.
#define SYMBOL_IN_SCOPE    0x00000001

// This means another same-named symbol is in inner scope
// blocking this symbol. Although its still a valid member of
// local symbolgroup, but can't be seen by code at IP.
#define SYMBOL_ECLIPSED    0x00000002

class SymbolGroupEntry
{
public:
    SymbolGroupEntry(void);
    ~SymbolGroupEntry(void);
    
    SymbolGroupEntry* m_Parent;
    SymbolGroupEntry* m_Next;
    SymbolGroupFormat* m_Format;

    PSTR m_Expr;
    PSTR m_Cast;
    DEBUG_SYMBOL_PARAMETERS m_Params;
    ULONG m_Flags;
    TypedData m_BaseData;
    SymbolGroupFormatKind m_BaseFormatKind;
};

class SymbolGroupFormat
{
public:
    SymbolGroupFormat(SymbolGroupEntry* Entry,
                      SymbolGroupFormatKind Kind);
    virtual ~SymbolGroupFormat(void);

    virtual ULONG CreateChildren(DebugSymbolGroup* Group) = 0;
    virtual ULONG Refresh(TypedDataAccess AllowAccess) = 0;
    virtual ULONG Write(PCSTR Value) = 0;
    virtual void OutputValue(void) = 0;
    virtual void OutputOffset(void) = 0;
    virtual void OutputType(void) = 0;
    virtual void TestImages(void);

    SymbolGroupEntry* m_Entry;
    SymbolGroupFormatKind m_Kind;

    // If there's an expression error the basic
    // expression could not be evaluated and this
    // entry is just a placeholder for an error message.
    ULONG m_ExprErr;
    // If there's a value error the basic expression
    // was evaluated properly but the value could
    // not be retrieved and is invalid.  If m_ExprErr
    // is set m_ValueErr should be set to match.
    ULONG m_ValueErr;
};

class TypedDataSymbolGroupFormat
    : public SymbolGroupFormat
{
public:
    TypedDataSymbolGroupFormat(SymbolGroupEntry* Entry) :
        SymbolGroupFormat(Entry, SGFORMAT_TYPED_DATA) {}
    TypedDataSymbolGroupFormat(SymbolGroupEntry* Entry,
                               SymbolGroupFormatKind Kind) :
        SymbolGroupFormat(Entry, Kind) {}
    
    virtual ULONG CreateChildren(DebugSymbolGroup* Group);
    ULONG AddChild(SymbolGroupEntry** AddAfter, PSTR Name, TypedData* Data);
    static ULONG CreateChildrenCb(PVOID Context, PSTR Name, TypedData* Child);
    virtual ULONG Refresh(TypedDataAccess AllowAccess);
    virtual ULONG Write(PCSTR Value);
    virtual void OutputValue(void);
    virtual void OutputOffset(void);
    virtual void OutputType(void);
    virtual void TestImages(void);

    SymbolGroupEntry* RefreshChildren(void);
    static ULONG RefreshChildrenCb(PVOID Context, PSTR Name, TypedData* Child);
    void UpdateParams(void);
    
    TypedData m_CastType;
    TypedData m_CastData;
};

class ExprSymbolGroupFormat
    : public TypedDataSymbolGroupFormat
{
public:
    ExprSymbolGroupFormat(SymbolGroupEntry* Entry) :
        TypedDataSymbolGroupFormat(Entry, SGFORMAT_EXPRESSION) {}
    
    virtual ULONG Refresh(TypedDataAccess AllowAccess);
};

class ExtSymbolGroupFormat
    : public SymbolGroupFormat
{
public:
    ExtSymbolGroupFormat(SymbolGroupEntry* Entry, DebugClient* Client);
    virtual ~ExtSymbolGroupFormat(void);

    virtual ULONG CreateChildren(DebugSymbolGroup* Group);
    virtual ULONG Refresh(TypedDataAccess AllowAccess);
    virtual ULONG Write(PCSTR Value);
    virtual void OutputValue(void);
    virtual void OutputOffset(void);
    virtual void OutputType(void);
    
    DebugClient* m_Client;
    PSTR m_Output;
};

class TextSymbolGroupFormat
    : public SymbolGroupFormat
{
public:
    TextSymbolGroupFormat(SymbolGroupEntry* Entry, PSTR Text, BOOL Own);
    virtual ~TextSymbolGroupFormat(void);
    
    virtual ULONG CreateChildren(DebugSymbolGroup* Group);
    virtual ULONG Refresh(TypedDataAccess AllowAccess);
    virtual ULONG Write(PCSTR Value);
    virtual void OutputValue(void);
    virtual void OutputOffset(void);
    virtual void OutputType(void);
    
    PSTR m_Text;
    BOOL m_Own;
};

//----------------------------------------------------------------------------
//
// DebugSymbolGroup.
//
//----------------------------------------------------------------------------

class DebugSymbolGroup : public IDebugSymbolGroup
{
public:
    DebugSymbolGroup(DebugClient *CreatedBy, ULONG ScopeGroup);
    ~DebugSymbolGroup(void);

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugSymbolGroup.

    STDMETHOD(GetNumberSymbols)(
        THIS_
        OUT PULONG Number
        );
    STDMETHOD(AddSymbol)(
        THIS_
        IN PCSTR Name,
        OUT PULONG Index
        );
    STDMETHOD(RemoveSymbolByName)(
        THIS_
        IN PCSTR Name
        );
    STDMETHOD(RemoveSymbolByIndex)(
        THIS_
        IN ULONG Index
        );
    STDMETHOD(GetSymbolName)(
        THIS_
        IN ULONG Index,
        OUT OPTIONAL PSTR Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG NameSize
        );
    STDMETHOD(GetSymbolParameters)(
        THIS_
        IN ULONG Start,
        IN ULONG Count,
        OUT /* size_is(Count) */ PDEBUG_SYMBOL_PARAMETERS Params
        );
    STDMETHOD(ExpandSymbol)(
        THIS_
        IN ULONG Index,
        IN BOOL Expand
        );
    STDMETHOD(OutputSymbols)(
        THIS_
        IN ULONG OutputControl,
        IN ULONG Flags,
        IN ULONG Start,
        IN ULONG Count
        );
    STDMETHOD(WriteSymbol)(
        THIS_
        IN ULONG Index,
        IN PCSTR Value
        );
    STDMETHOD(OutputAsType)(
        THIS_
        IN ULONG Index,
        IN PCSTR Type
        );
    
    SymbolGroupEntry* FindEntryByIndex(ULONG Index);
    SymbolGroupEntry* FindEntryByExpr(SymbolGroupEntry* Parent,
                                      SymbolGroupEntry* After,
                                      PCSTR Expr);
    ULONG FindEntryIndex(SymbolGroupEntry* Entry);

    void DeleteEntry(SymbolGroupEntry* Entry);
    void DeleteChildren(SymbolGroupEntry* Parent);

    void LinkEntry(IN SymbolGroupEntry* Entry,
                   IN OUT PULONG Index);
    HRESULT NewEntry(IN PCSTR Expr,
                     IN OPTIONAL PSYMBOL_INFO SymInfo,
                     OUT SymbolGroupEntry** EntryRet);

    HRESULT SetEntryExpansion(IN SymbolGroupEntry* Entry,
                              IN BOOL Expand);
    
    HRESULT AddCurrentLocals(void);
    ULONG FindLocalInsertionIndex(SymbolGroupEntry* Entry);
    static BOOL CALLBACK AddAllScopedSymbols(PSYMBOL_INFO SymInfo,
                                             ULONG        Size,
                                             PVOID        Context);

    void TestImages(void);
    
    void ShowAll(void);

    DebugClient* m_Client;
    ULONG m_ScopeGroup;

    ULONG m_Refs;
    ULONG m_NumEntries;
    // Entry list is kept sorted by parent/child relationship
    // so all children of a parent follow it directly in the
    // order they were found.
    SymbolGroupEntry* m_Entries;
    BOOL m_LastClassExpanded;
};

#endif // #ifndef __DBGSYM_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgkdtrans.hpp ===
//----------------------------------------------------------------------------
//
// KD hard-line communication support.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __DBGKDTRANS_HPP__
#define __DBGKDTRANS_HPP__

#define MAX_MANIP_TRANSFER (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))

#define PACKET_MAX_MANIP_SIZE \
    (PACKET_MAX_SIZE + sizeof(DBGKD_MANIPULATE_STATE64) - \
     sizeof(DBGKD_MANIPULATE_STATE32) + sizeof(KD_PACKET))

enum
{
    DBGKD_WRITE_PACKET,
    DBGKD_WRITE_RESEND,
};

enum
{
    DBGKD_WAIT_PACKET,
    DBGKD_WAIT_ACK,
    DBGKD_WAIT_RESYNC,
    DBGKD_WAIT_FAILED,
    DBGKD_WAIT_RESEND,
    DBGKD_WAIT_AGAIN,
    DBGKD_WAIT_INTERRUPTED
};

enum
{
    DBGKD_TRANSPORT_COM,
    DBGKD_TRANSPORT_1394,
    DBGKD_TRANSPORT_COUNT
};

#define DBGKD_OUTPUT_READS  0x00000001
#define DBGKD_OUTPUT_WRITES 0x00000002

#define KD_FILE_SIGNATURE 'lFdK'

struct KD_FILE
{
    LIST_ENTRY List;
    HANDLE Handle;
    ULONG Signature;
};

PCSTR g_DbgKdTransportNames[];

class DbgKdTransport : public ParameterStringParser
{
public:
    DbgKdTransport(ConnLiveKernelTargetInfo* Target);
    virtual ~DbgKdTransport(void);
    
    // ParameterStringParser.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);
    
    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    //
    // DbgKdTransport.
    //

    void Restart(void);

    // Base implementation displays general information and
    // packets/bytes read/written.  It should be invoked
    // before derived operations.
    virtual void OutputInfo(void);
    
    // Base implementation creates events for overlapped operations.
    virtual HRESULT Initialize(void);
    
    virtual BOOL Read(IN PVOID Buffer,
                      IN ULONG SizeOfBuffer,
                      IN PULONG BytesRead) = 0;
    virtual BOOL Write(IN PVOID Buffer,
                       IN ULONG SizeOfBuffer,
                       IN PULONG BytesWritten) = 0;

    // Base implementation does nothing.
    virtual void CycleSpeed(void);

    virtual HRESULT ReadTargetPhysicalMemory(IN ULONG64 MemoryOffset,
                                             IN PVOID Buffer,
                                             IN ULONG SizeofBuffer,
                                             IN PULONG BytesRead);

    // This routine keeps on sending reset packet to target until reset packet
    // is acknowledged by a reset packet from target.
    //
    // N.B. This routine is intended to be used by kernel debugger at startup
    //      time (ONLY) to get packet control variables on both target and host
    //      back in synchronization.  Also, reset request will cause kernel to
    //      reset its control variables AND resend us its previous packet (with
    //      the new packet id).
    virtual VOID Synchronize(VOID) = 0;

    virtual ULONG ReadPacketContents(IN USHORT PacketType) = 0;
    virtual ULONG WritePacketContents(IN KD_PACKET* Packet,
                                      IN PVOID PacketData,
                                      IN USHORT PacketDataLength,
                                      IN PVOID MorePacketData OPTIONAL,
                                      IN USHORT MorePacketDataLength OPTIONAL,
                                      IN BOOL NoAck) = 0;

    ULONG HandleDebugIo(PDBGKD_DEBUG_IO Packet);
    ULONG HandleTraceIo(PDBGKD_TRACE_IO Packet);
    ULONG HandleControlRequest(PDBGKD_CONTROL_REQUEST Packet);
    ULONG HandleFileIo(PDBGKD_FILE_IO Packet);
    
    ULONG WaitForPacket(IN USHORT PacketType,
                        OUT PVOID Packet);

    VOID WriteBreakInPacket(VOID);
    VOID WriteControlPacket(IN USHORT PacketType,
                            IN ULONG PacketId OPTIONAL);
    VOID WriteDataPacket(IN PVOID PacketData,
                         IN USHORT PacketDataLength,
                         IN USHORT PacketType,
                         IN PVOID MorePacketData OPTIONAL,
                         IN USHORT MorePacketDataLength OPTIONAL,
                         IN BOOL NoAck);

    inline VOID WritePacket(IN PVOID PacketData,
                            IN USHORT PacketDataLength,
                            IN USHORT PacketType,
                            IN PVOID MorePacketData OPTIONAL,
                            IN USHORT MorePacketDataLength OPTIONAL)
    {
        WriteDataPacket(PacketData, PacketDataLength, PacketType,
                        MorePacketData, MorePacketDataLength, FALSE);
    }
    inline VOID WriteAsyncPacket(IN PVOID PacketData,
                                 IN USHORT PacketDataLength,
                                 IN USHORT PacketType,
                                 IN PVOID MorePacketData OPTIONAL,
                                 IN USHORT MorePacketDataLength OPTIONAL)
    {
        WriteDataPacket(PacketData, PacketDataLength, PacketType,
                        MorePacketData, MorePacketDataLength, TRUE);
    }

    ULONG ComputeChecksum(IN PUCHAR Buffer,
                          IN ULONG Length);

    // This save/restore isn't particularly elegant
    // but we need something like it.  We receive a state change
    // without knowing what kind of machine we're talking to.
    // We have to send/receive a GetVersion packet to get that
    // information, but we need to keep the original packet
    // information around while we do so.
    void SaveReadPacket(void)
    {
        memcpy(s_SavedPacket, s_Packet, sizeof(s_Packet));
        s_SavedPacketHeader = s_PacketHeader;
    }
    void RestoreReadPacket(void)
    {
        memcpy(s_Packet, s_SavedPacket, sizeof(s_Packet));
        s_PacketHeader = s_SavedPacketHeader;
    }

    void HandlePrint(IN ULONG Processor,
                     IN PCSTR String,
                     IN USHORT StringLength,
                     IN ULONG Mask);
    void HandlePromptString(IN PDBGKD_DEBUG_IO IoMessage);
    void HandlePrintTrace(IN ULONG Processor,
                          IN PUCHAR Data,
                          IN USHORT DataLength,
                          IN ULONG Mask);

    void ClearKdFileAssoc(void);
    HRESULT LoadKdFileAssoc(PSTR FileName);
    void InitKdFileAssoc(void);
    void ParseKdFileAssoc(void);
    NTSTATUS CreateKdFile(PWSTR FileName,
                          ULONG DesiredAccess, ULONG FileAttributes,
                          ULONG ShareAccess, ULONG CreateDisposition,
                          ULONG CreateOptions,
                          KD_FILE** FileEntry, PULONG64 Length);
    void CloseKdFile(KD_FILE* File);
    KD_FILE* TranslateKdFileHandle(ULONG64 Handle);

    void Ref(void)
    {
        m_Refs++;
    }
    void Release(void)
    {
        if (--m_Refs == 0)
        {
            delete this;
        }
    }
    
    ULONG m_Refs;
    ConnLiveKernelTargetInfo* m_Target;
    ULONG m_Index;
    HANDLE m_Handle;
    BOOL m_DirectPhysicalMemory;
    ULONG m_InvPacketRetryLimit;
    BOOL m_AckWrites;
    ULONG m_OutputIo;

    //
    // This overlapped structure will be used for all serial read
    // operations. We only need one structure since the code is
    // designed so that no more than one serial read operation is
    // outstanding at any one time.
    //
    OVERLAPPED m_ReadOverlapped;

    //
    // This overlapped structure will be used for all serial write
    // operations. We only need one structure since the code is
    // designed so that no more than one serial write operation is
    // outstanding at any one time.
    //
    OVERLAPPED m_WriteOverlapped;

    ULONG m_PacketsRead;
    ULONG64 m_BytesRead;
    ULONG m_PacketsWritten;
    ULONG64 m_BytesWritten;
    
    // ID for expected incoming packet.
    ULONG m_PacketExpected;
    // ID for Next packet to send.
    ULONG m_NextPacketToSend;

    // Thread ID for thread in WaitStateChange.  Normally
    // multithreaded access to the transport is prevented by
    // the engine lock, but the engine lock is suspended
    // while WaitStateChange is doing its WaitPacketForever.
    // During that time other threads must be forcibly
    // prevented from using the kernel connection.
    ULONG m_WaitingThread;

    BOOL m_AllowInitialBreak;
    BOOL m_Resync;
    BOOL m_BreakIn;
    BOOL m_SyncBreakIn;
    BOOL m_ValidUnaccessedPacket;
    
    LIST_ENTRY m_KdFiles;
    char m_KdFileAssocSource[MAX_PATH];
    LIST_ENTRY m_KdFileAssoc;

    static UCHAR s_BreakinPacket[1];
    static UCHAR s_PacketTrailingByte[1];
    static UCHAR s_PacketLeader[4];

    static UCHAR s_Packet[PACKET_MAX_MANIP_SIZE];
    static KD_PACKET s_PacketHeader;

    static UCHAR s_SavedPacket[PACKET_MAX_MANIP_SIZE];
    static KD_PACKET s_SavedPacketHeader;

private:
    struct KD_FILE_ASSOC* FindKdFileAssoc(PWSTR From);
};

class DbgKdComTransport : public DbgKdTransport
{
public:
    DbgKdComTransport(ConnLiveKernelTargetInfo* Target);
    virtual ~DbgKdComTransport(void);

    // ParameterStringParser.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);
    
    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    // DbgKdTransport.
    virtual HRESULT Initialize(void);

    virtual BOOL Read(IN PVOID Buffer,
                      IN ULONG SizeOfBuffer,
                      IN PULONG BytesRead);
    virtual BOOL Write(IN PVOID Buffer,
                       IN ULONG SizeOfBuffer,
                       IN PULONG BytesWritten);
    virtual void CycleSpeed(void);

    virtual VOID Synchronize(VOID);

    virtual ULONG ReadPacketContents(IN USHORT PacketType);
    virtual ULONG WritePacketContents(IN KD_PACKET* Packet,
                                      IN PVOID PacketData,
                                      IN USHORT PacketDataLength,
                                      IN PVOID MorePacketData OPTIONAL,
                                      IN USHORT MorePacketDataLength OPTIONAL,
                                      IN BOOL NoAck);

    //
    // DbgKdComTransport.
    //
    
    ULONG ReadPacketLeader(IN ULONG PacketType,
                           OUT PULONG PacketLeader);
    void CheckComStatus(void);
    DWORD SelectNewBaudRate(DWORD NewRate);

    char m_PortName[MAX_PARAM_VALUE + 8];
    ULONG m_BaudRate;
    COM_PORT_TYPE m_PortType;
    ULONG m_Timeout;
    ULONG m_CurTimeout;
    ULONG m_MaxSyncResets;
    ULONG m_IpPort;

    // Used to carrier detection.
    DWORD m_ComEvent;

    //
    // This overlapped structure will be used for all event operations.
    // We only need one structure since the code is designed so that no more
    // than one serial event operation is outstanding at any one time.
    //
    OVERLAPPED m_EventOverlapped;
};

enum 
{
    DBGKD_1394_OPERATION_MODE_DEBUG,
    DBGKD_1394_OPERATION_RAW_MEMORY_ACCESS
};

class DbgKd1394Transport : public DbgKdTransport
{
public:
    DbgKd1394Transport(ConnLiveKernelTargetInfo* Target);
    virtual ~DbgKd1394Transport(void);

    // ParameterStringParser.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);
    
    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    // DbgKdTransport.
    virtual HRESULT Initialize(void);

    virtual BOOL Read(IN PVOID Buffer,
                      IN ULONG SizeOfBuffer,
                      IN PULONG BytesRead);
    virtual BOOL Write(IN PVOID Buffer,
                       IN ULONG SizeOfBuffer,
                       IN PULONG BytesWritten);

    virtual HRESULT ReadTargetPhysicalMemory(IN ULONG64 MemoryOffset,
                                             IN PVOID Buffer,
                                             IN ULONG SizeofBuffer,
                                             IN PULONG BytesRead);

    virtual VOID Synchronize(VOID);

    virtual ULONG ReadPacketContents(IN USHORT PacketType);
    virtual ULONG WritePacketContents(IN KD_PACKET* Packet,
                                      IN PVOID PacketData,
                                      IN USHORT PacketDataLength,
                                      IN PVOID MorePacketData OPTIONAL,
                                      IN USHORT MorePacketDataLength OPTIONAL,
                                      IN BOOL NoAck);

    // DbgKd1394Transport.

    BOOL SwitchVirtualDebuggerDriverMode(IN ULONG NewMode);
    void CloseSecond(BOOL MakeFirst);

    ULONG m_Channel;
    char m_Symlink[MAX_PARAM_VALUE];
    ULONG m_OperationMode;
    BOOL m_SymlinkSpecified;
    char m_Symlink2[MAX_PARAM_VALUE];

    HANDLE m_Handle2;
    OVERLAPPED m_ReadOverlapped2;
    
    UCHAR m_TxPacket[PACKET_MAX_MANIP_SIZE];
};

#endif // #ifndef __DBGKDTRANS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgreg.cpp ===
//----------------------------------------------------------------------------
//
// IDebugRegisters implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

STDMETHODIMP
DebugClient::GetNumberRegisters(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!g_Machine)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_Machine->m_NumRegs;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetDescription(
    THIS_
    IN ULONG Register,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PDEBUG_REGISTER_DESCRIPTION Desc
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!g_Machine)
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    
    if (Register >= g_Machine->m_NumRegs)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ULONG Type;
    REGDEF* FullDef;

    FullDef = g_Machine->RegDefFromCount(Register);
    if (!FullDef) 
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Type = g_Machine->GetType(FullDef->Index);

    Status = FillStringBuffer(FullDef->Name, 0,
                              NameBuffer, NameBufferSize, NameSize);
    
    if (Desc != NULL)
    {
        ZeroMemory(Desc, sizeof(*Desc));

        switch(Type)
        {
        case REGVAL_INT16:
            Desc->Type = DEBUG_VALUE_INT16;
            break;
        case REGVAL_SUB32:
            Desc->Flags |= DEBUG_REGISTER_SUB_REGISTER;
            // Fall through.
        case REGVAL_INT32:
            Desc->Type = DEBUG_VALUE_INT32;
            break;
        case REGVAL_SUB64:
            Desc->Flags |= DEBUG_REGISTER_SUB_REGISTER;
            // Fall through.
        case REGVAL_INT64:
        case REGVAL_INT64N:
            Desc->Type = DEBUG_VALUE_INT64;
            break;
        case REGVAL_FLOAT8:
            Desc->Type = DEBUG_VALUE_FLOAT64;
            break;
        case REGVAL_FLOAT10:
            Desc->Type = DEBUG_VALUE_FLOAT80;
            break;
        case REGVAL_FLOAT82:
            Desc->Type = DEBUG_VALUE_FLOAT82;
            break;
        case REGVAL_FLOAT16:
            Desc->Type = DEBUG_VALUE_FLOAT128;
            break;
        case REGVAL_VECTOR64:
            Desc->Type = DEBUG_VALUE_VECTOR64;
            break;
        case REGVAL_VECTOR128:
            Desc->Type = DEBUG_VALUE_VECTOR128;
            break;
        }

        if (Desc->Flags & DEBUG_REGISTER_SUB_REGISTER)
        {
            REGSUBDEF* SubDef = g_Machine->RegSubDefFromIndex(FullDef->Index);
            if (!SubDef) 
            {
                Status = E_UNEXPECTED;
                goto Exit;
            }

            // Find fullreg definition and count.
            ULONG GroupIdx;
            RegisterGroup* Group;
            ULONG FullCount = 0;

            for (GroupIdx = 0;
                 GroupIdx < g_Machine->m_NumGroups;
                 GroupIdx++)
            {
                Group = g_Machine->m_Groups[GroupIdx];
                
                FullDef = Group->Regs;
                while (FullDef->Name != NULL)
                {
                    if (FullDef->Index == SubDef->FullReg)
                    {
                        break;
                    }
                
                    FullDef++;
                }

                FullCount += (ULONG)(FullDef - Group->Regs);
                if (FullDef->Name != NULL)
                {
                    break;
                }
            }
            
            DBG_ASSERT(FullDef->Name != NULL);

            Desc->SubregMaster = FullCount;

            // Count the bits in the mask to derive length.

            ULONG64 Mask;

            Mask = SubDef->Mask;
            Desc->SubregMask = Mask;
        
            while (Mask != 0)
            {
                Desc->SubregLength++;
                Mask &= Mask - 1;
            }

            Desc->SubregShift = SubDef->Shift;
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetIndexByName(
    THIS_
    IN PCSTR Name,
    OUT PULONG Index
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (!g_Machine)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        RegisterGroup* Group;
        ULONG Idx;
        ULONG GroupIdx;

        Status = E_NOINTERFACE;
        Idx = 0;
        for (GroupIdx = 0;
             GroupIdx < g_Machine->m_NumGroups && Status != S_OK;
             GroupIdx++)
        {
            REGDEF* Def;

            Group = g_Machine->m_Groups[GroupIdx];
            
            Def = Group->Regs;
            while (Def->Name != NULL)
            {
                if (!strcmp(Def->Name, Name))
                {
                    Status = S_OK;
                    break;
                }

                Idx++;
                Def++;
            }
        }

        *Index = Idx;
    }

    LEAVE_ENGINE();
    return Status;
}
    
STDMETHODIMP
DebugClient::GetValue(
    THIS_
    IN ULONG Register,
    OUT PDEBUG_VALUE Value
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    
    if (Register >= g_Machine->m_NumRegs)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ZeroMemory(Value, sizeof(*Value));
    
    ULONG Index;
    REGVAL Val;

    REGDEF* RegDef = g_Machine->RegDefFromCount(Register);
    if (!RegDef) 
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    g_DisableErrorPrint++;
    
    Index = RegDef->Index;
    __try
    {
        GetPseudoOrRegVal(TRUE, Index, &Val);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        Status = E_INVALIDARG;
        g_DisableErrorPrint--;
        goto Exit;
    }
    
    g_DisableErrorPrint--;
    
    switch(Val.Type)
    {
    case REGVAL_INT16:
        Value->Type = DEBUG_VALUE_INT16;
        Value->I16 = (USHORT)Val.I32;
        break;
    case REGVAL_SUB32:
    case REGVAL_INT32:
        Value->Type = DEBUG_VALUE_INT32;
        Value->I32 = Val.I32;
        break;
    case REGVAL_SUB64:
    case REGVAL_INT64:
        Val.Nat = FALSE;
        // Fall through.
    case REGVAL_INT64N:
        Value->Type = DEBUG_VALUE_INT64;
        Value->I64 = Val.I64;
        Value->Nat = Val.Nat;
        break;
    case REGVAL_FLOAT8:
        Value->Type = DEBUG_VALUE_FLOAT64;
        Value->F64 = Val.F8;
        break;
    case REGVAL_FLOAT10:
        Value->Type = DEBUG_VALUE_FLOAT80;
        memcpy(Value->F80Bytes, Val.F10, sizeof(Value->F80Bytes));
        break;
    case REGVAL_FLOAT82:
        Value->Type = DEBUG_VALUE_FLOAT82;
        memcpy(Value->F82Bytes, Val.F82, sizeof(Value->F82Bytes));
        break;
    case REGVAL_FLOAT16:
        Value->Type = DEBUG_VALUE_FLOAT128;
        memcpy(Value->F128Bytes, Val.F16, sizeof(Value->F128Bytes));
        break;
    case REGVAL_VECTOR64:
        Value->Type = DEBUG_VALUE_VECTOR64;
        memcpy(Value->RawBytes, Val.Bytes, 8);
        break;
    case REGVAL_VECTOR128:
        Value->Type = DEBUG_VALUE_VECTOR128;
        memcpy(Value->RawBytes, Val.Bytes, 16);
        break;
    }

    Status = S_OK;
    
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetValue(
    THIS_
    IN ULONG Register,
    IN PDEBUG_VALUE Value
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    
    if (Register >= g_Machine->m_NumRegs)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    ULONG Index;
    ULONG Type;
    REGVAL Val;
    DEBUG_VALUE Coerce;

    REGDEF* RegDef = g_Machine->RegDefFromCount(Register);
    if (!RegDef) 
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Index = RegDef->Index;
    Type = g_Machine->GetType(Index);
    Val.Type = Type;

    switch(Type)
    {
    case REGVAL_INT16:
        Status = CoerceValue(Value, DEBUG_VALUE_INT16, &Coerce);
        Val.I32 = Coerce.I16;
        break;
    case REGVAL_SUB32:
    case REGVAL_INT32:
        Status = CoerceValue(Value, DEBUG_VALUE_INT32, &Coerce);
        Val.I32 = Coerce.I32;
        break;
    case REGVAL_INT64:
        Val.Type = REGVAL_INT64N;
        // Fall through.
    case REGVAL_SUB64:
    case REGVAL_INT64N:
        Status = CoerceValue(Value, DEBUG_VALUE_INT64, &Coerce);
        Val.I64 = Coerce.I64;
        Val.Nat = Coerce.Nat ? TRUE : FALSE;
        break;
    case REGVAL_FLOAT8:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT64, &Coerce);
        Val.F8 = Coerce.F64;
        break;
    case REGVAL_FLOAT10:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT80, &Coerce);
        memcpy(Val.F10, Coerce.F80Bytes, sizeof(Coerce.F80Bytes));
        break;
    case REGVAL_FLOAT82:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT82, &Coerce);
        memcpy(Val.F82, Coerce.F82Bytes, sizeof(Coerce.F82Bytes));
        break;
    case REGVAL_FLOAT16:
        Status = CoerceValue(Value, DEBUG_VALUE_FLOAT128, &Coerce);
        memcpy(Val.F16, Coerce.F128Bytes, sizeof(Coerce.F128Bytes));
        break;
    case REGVAL_VECTOR64:
        Status = CoerceValue(Value, DEBUG_VALUE_VECTOR64, &Coerce);
        memcpy(Val.Bytes, Coerce.RawBytes, 8);
        break;
    case REGVAL_VECTOR128:
        Status = CoerceValue(Value, DEBUG_VALUE_VECTOR128, &Coerce);
        memcpy(Val.Bytes, Coerce.RawBytes, 16);
        break;
    }

    if (Status == S_OK)
    {
        g_DisableErrorPrint++;
        
        __try
        {
            SetPseudoOrRegVal(Index, &Val);
        }
        __except(CommandExceptionFilter(GetExceptionInformation()))
        {
            Status = E_INVALIDARG;
        }
        
        g_DisableErrorPrint--;
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetValues(
    THIS_
    IN ULONG Count,
    IN OPTIONAL PULONG Indices,
    IN ULONG Start,
    OUT PDEBUG_VALUE Values
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    HRESULT SingleStatus;
    ULONG i;
    
    Status = S_OK;
    if (Indices != NULL)
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = GetValue(Indices[i], Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }
    else
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = GetValue(Start + i, Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }
    
 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetValues(
    THIS_
    IN ULONG Count,
    IN OPTIONAL PULONG Indices,
    IN ULONG Start,
    IN PDEBUG_VALUE Values
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    HRESULT SingleStatus;
    ULONG i;

    Status = S_OK;
    if (Indices != NULL)
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = SetValue(Indices[i], Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }
    else
    {
        for (i = 0; i < Count; i++)
        {
            SingleStatus = SetValue(Start + i, Values + i);
            if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
            }
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::OutputRegisters(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags
    )
{
    // Ensure that the public flags match the internal flags.
    C_ASSERT(DEBUG_REGISTERS_INT32 == REGALL_INT32 &&
             DEBUG_REGISTERS_INT64 == REGALL_INT64 &&
             DEBUG_REGISTERS_FLOAT == REGALL_FLOAT);

    if (Flags & ~DEBUG_REGISTERS_ALL)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        OutCtlSave OldCtl;
        if (!PushOutCtl(OutputControl, this, &OldCtl))
        {
            Status = E_INVALIDARG;
        }
        else
        {
            if (Flags == DEBUG_REGISTERS_DEFAULT)
            {
                Flags = g_Machine->m_AllMask;
            }
            
            OutCurInfo(OCI_FORCE_REG, Flags, DEBUG_OUTPUT_NORMAL);
            Status = S_OK;
            PopOutCtl(&OldCtl);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetInstructionOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        g_Machine->GetPC(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetStackOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        g_Machine->GetSP(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetFrameOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();
    
    if (!IS_CUR_CONTEXT_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ADDR Addr;
        g_Machine->GetFP(&Addr);
        *Offset = Flat(Addr);
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgsys.cpp ===
//----------------------------------------------------------------------------
//
// IDebugSystemObjects implementations.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//----------------------------------------------------------------------------
//
// Utility functions.
//
//----------------------------------------------------------------------------

void
X86DescriptorToDescriptor64(PX86_LDT_ENTRY X86Desc,
                            PDESCRIPTOR64 Desc64)
{
    Desc64->Base = EXTEND64((ULONG)X86Desc->BaseLow +
                            ((ULONG)X86Desc->HighWord.Bits.BaseMid << 16) +
                            ((ULONG)X86Desc->HighWord.Bytes.BaseHi << 24));
    Desc64->Limit = (ULONG)X86Desc->LimitLow +
        ((ULONG)X86Desc->HighWord.Bits.LimitHi << 16);
    if (X86Desc->HighWord.Bits.Granularity)
    {
        Desc64->Limit = (Desc64->Limit << X86_PAGE_SHIFT) +
            ((1 << X86_PAGE_SHIFT) - 1);
    }
    Desc64->Flags = (ULONG)X86Desc->HighWord.Bytes.Flags1 +
        (((ULONG)X86Desc->HighWord.Bytes.Flags2 >> 4) << 8);
}

HRESULT
ReadX86Descriptor(TargetInfo* Target, ProcessInfo* Process,
                  ULONG Selector, ULONG64 Base, ULONG Limit,
                  PDESCRIPTOR64 Desc)
{
    ULONG Index;

    // Mask off irrelevant bits
    Index = Selector & ~0x7;

    // Check to make sure that the selector is within the table bounds
    if (Index > Limit)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    X86_LDT_ENTRY X86Desc;

    Status = Target->
        ReadAllVirtual(Process, Base + Index, &X86Desc, sizeof(X86Desc));
    if (Status != S_OK)
    {
        return Status;
    }

    X86DescriptorToDescriptor64(&X86Desc, Desc);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// TargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
TargetInfo::GetProcessorSystemDataOffset(
    IN ULONG Processor,
    IN ULONG Index,
    OUT PULONG64 Offset
    )
{
    ThreadInfo* Thread;
    
    if (!IS_KERNEL_TARGET(this))
    {
        return E_UNEXPECTED;
    }

    // XXX drewb - Temporary until different OS support is
    // sorted out.
    if (m_ActualSystemVersion < NT_SVER_START ||
        m_ActualSystemVersion > NT_SVER_END)
    {
        return E_UNEXPECTED;
    }

    Thread = m_ProcessHead->
        FindThreadByHandle(VIRTUAL_THREAD_HANDLE(Processor));
    if (!Thread)
    {
        return E_UNEXPECTED;
    }
    
    HRESULT Status;
    ULONG Read;

    if (m_MachineType == IMAGE_FILE_MACHINE_I386)
    {
        DESCRIPTOR64 Entry;

        //
        // We always need the PCR address so go ahead and get it.
        //
        
        if (!IS_CONTEXT_POSSIBLE(this))
        {
            X86_DESCRIPTOR GdtDesc;
            
            // We can't go through the normal context segreg mapping
            // but all we really need is an entry from the
            // kernel GDT that should always be present and
            // constant while the system is initialized.  We
            // can get the GDT information from the x86 control
            // space so do that.
            if ((Status = ReadControl
                 (Processor,
                  m_TypeInfo.OffsetSpecialRegisters +
                  FIELD_OFFSET(X86_KSPECIAL_REGISTERS, Gdtr),
                  &GdtDesc, sizeof(GdtDesc), &Read)) != S_OK ||
                Read != sizeof(GdtDesc) ||
                (Status = ReadX86Descriptor(this, m_ProcessHead,
                                            m_KdDebuggerData.GdtR0Pcr,
                                            EXTEND64(GdtDesc.Base),
                                            GdtDesc.Limit, &Entry)) != S_OK)
            {
                ErrOut("Unable to read selector for PCR for processor %u\n",
                       Processor);
                return Status != S_OK ?
                    Status : HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }
        }
        else
        {
            if ((Status = GetSelDescriptor(Thread, m_Machine,
                                           m_KdDebuggerData.GdtR0Pcr,
                                           &Entry)) != S_OK)
            {
                ErrOut("Unable to read selector for PCR for processor %u\n",
                       Processor);
                return Status;
            }
        }

        switch(Index)
        {
        case DEBUG_DATA_KPCR_OFFSET:

            Status = ReadPointer(m_ProcessHead, m_Machine,
                                 Entry.Base +
                                 m_KdDebuggerData.OffsetPcrSelfPcr,
                                 Offset);
            if ((Status != S_OK) || Entry.Base != *Offset)
            {
                ErrOut("KPCR is corrupted !");
            }

            *Offset = Entry.Base;
            break;

        case DEBUG_DATA_KPRCB_OFFSET:
        case DEBUG_DATA_KTHREAD_OFFSET:
            Status = ReadPointer(m_ProcessHead, m_Machine,
                                 Entry.Base +
                                 m_KdDebuggerData.OffsetPcrCurrentPrcb,
                                 Offset);
            if (Status != S_OK)
            {
                return Status;
            }

            if (Index == DEBUG_DATA_KPRCB_OFFSET)
            {
                break;
            }

            Status = ReadPointer(m_ProcessHead, m_Machine,
                                 *Offset + 
                                 m_KdDebuggerData.OffsetPrcbCurrentThread,
                                 Offset);
            if (Status != S_OK)
            {
                return Status;
            }
            break;
        }
    }
    else
    {
        ULONG ReadSize = m_Machine->m_Ptr64 ?
            sizeof(ULONG64) : sizeof(ULONG);
        ULONG64 Address;

        switch(m_MachineType)
        {
        case IMAGE_FILE_MACHINE_IA64:
            switch(Index)
            {
            case DEBUG_DATA_KPCR_OFFSET:
                Index = IA64_DEBUG_CONTROL_SPACE_PCR;
                break;
            case DEBUG_DATA_KPRCB_OFFSET:
                Index = IA64_DEBUG_CONTROL_SPACE_PRCB;
                break;
            case DEBUG_DATA_KTHREAD_OFFSET:
                Index = IA64_DEBUG_CONTROL_SPACE_THREAD;
                break;
            }
            break;
            
        case IMAGE_FILE_MACHINE_AMD64:
            switch(Index)
            {
            case DEBUG_DATA_KPCR_OFFSET:
                Index = AMD64_DEBUG_CONTROL_SPACE_PCR;
                break;
            case DEBUG_DATA_KPRCB_OFFSET:
                Index = AMD64_DEBUG_CONTROL_SPACE_PRCB;
                break;
            case DEBUG_DATA_KTHREAD_OFFSET:
                Index = AMD64_DEBUG_CONTROL_SPACE_THREAD;
                break;
            }
            break;
        }

        Status = ReadControl(Processor, Index, &Address, ReadSize, &Read);
        if (Status != S_OK)
        {
            return Status;
        }
        else if (Read != ReadSize)
        {
            return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
        }
        if (!m_Machine->m_Ptr64)
        {
            Address = EXTEND64(Address);
        }

        *Offset = Address;
    }

    return S_OK;
}

HRESULT
TargetInfo::GetTargetSegRegDescriptors(ULONG64 Thread,
                                       ULONG Start, ULONG Count,
                                       PDESCRIPTOR64 Descs)
{
    while (Count-- > 0)
    {
        Descs->Flags = SEGDESC_INVALID;
        Descs++;
    }

    return S_OK;
}

HRESULT
TargetInfo::GetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    HRESULT Status;
    ULONG Done;

    Status = ReadControl(VIRTUAL_THREAD_INDEX(Thread),
                         m_TypeInfo.OffsetSpecialRegisters,
                         Special,
                         m_TypeInfo.SizeKspecialRegisters,
                         &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    return Done == m_TypeInfo.SizeKspecialRegisters ?
        S_OK : E_FAIL;
}

HRESULT
TargetInfo::SetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    HRESULT Status;
    ULONG Done;

    Status = WriteControl(VIRTUAL_THREAD_INDEX(Thread),
                          m_TypeInfo.OffsetSpecialRegisters,
                          Special,
                          m_TypeInfo.SizeKspecialRegisters,
                          &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    return Done == m_TypeInfo.SizeKspecialRegisters ?
        S_OK : E_FAIL;
}

void
TargetInfo::InvalidateTargetContext(void)
{
    // Nothing to do.
}

HRESULT
TargetInfo::GetThreadStartOffset(ThreadInfo* Thread,
                                 PULONG64 StartOffset)
{
    // Base implementation to indicate no information available.
    return E_NOINTERFACE;
}

void
TargetInfo::SuspendThreads(void)
{
    // Base implementation for targets that can't suspend threads.
}

BOOL
TargetInfo::ResumeThreads(void)
{
    ThreadInfo* Thread;
    
    // Base implementation for targets that can't suspend threads.
    //
    // Wipe out all cached thread data offsets in
    // case operations after the resumption invalidates
    // the cached values.
    for (Thread = m_ProcessHead ? m_ProcessHead->m_ThreadHead : NULL;
         Thread != NULL;
         Thread = Thread->m_Next)
    {
        Thread->m_DataOffset = 0;
    }
    
    return TRUE;
}

HRESULT
TargetInfo::GetContext(
    ULONG64 Thread,
    PCROSS_PLATFORM_CONTEXT Context
    )
{
    if (m_Machine == NULL)
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    CROSS_PLATFORM_CONTEXT TargetContextBuffer;
    PCROSS_PLATFORM_CONTEXT TargetContext;

    if (m_Machine->m_SverCanonicalContext <=
        m_SystemVersion)
    {
        TargetContext = Context;
    }
    else
    {
        TargetContext = &TargetContextBuffer;
        m_Machine->
            InitializeContextFlags(TargetContext,
                                   m_SystemVersion);
    }

    Status = GetTargetContext(Thread, TargetContext);

    if (Status == S_OK && TargetContext == &TargetContextBuffer)
    {
        Status = m_Machine->
            ConvertContextFrom(Context, m_SystemVersion,
                               m_TypeInfo.SizeTargetContext,
                               TargetContext);
        // Conversion should always succeed since the size is
        // known to be valid.
        DBG_ASSERT(Status == S_OK);
    }

    return Status;
}

HRESULT
TargetInfo::SetContext(
    ULONG64 Thread,
    PCROSS_PLATFORM_CONTEXT Context
    )
{
    if (m_Machine == NULL)
    {
        return E_UNEXPECTED;
    }

    CROSS_PLATFORM_CONTEXT TargetContextBuffer;
    PCROSS_PLATFORM_CONTEXT TargetContext;

    if (m_Machine->m_SverCanonicalContext <=
        m_SystemVersion)
    {
        TargetContext = Context;
    }
    else
    {
        TargetContext = &TargetContextBuffer;
        HRESULT Status = m_Machine->
            ConvertContextTo(Context, m_SystemVersion,
                             m_TypeInfo.SizeTargetContext,
                             TargetContext);
        // Conversion should always succeed since the size is
        // known to be valid.
        DBG_ASSERT(Status == S_OK);
    }

    return SetTargetContext(Thread, TargetContext);
}

HRESULT
TargetInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                      PCROSS_PLATFORM_CONTEXT Context,
                                      BOOL Verbose)
{
    DBG_ASSERT(ThreadBase && Context != NULL);

    if (!IS_KERNEL_TARGET(this)) 
    {
        return E_UNEXPECTED;
    }

    HRESULT Status;
    UCHAR Type;
    ULONG Proc = 0;
    UCHAR State;
    ULONG64 Stack;

    Status = ReadAllVirtual(m_ProcessHead, ThreadBase, &Type, sizeof(Type));
    if (Status != S_OK)
    {
        ErrOut("Cannot read thread type from thread %s, %s\n",
               FormatMachineAddr64(m_Machine, ThreadBase),
               FormatStatusCode(Status));
        return Status;
    }
        
    if (Type != 6)
    {
        ErrOut("Invalid thread @ %s type - context unchanged.\n",
               FormatMachineAddr64(m_Machine, ThreadBase));
        return E_INVALIDARG;
    }

    //
    // Check to see if the thread is currently running.
    //

    Status = ReadAllVirtual(m_ProcessHead,
                            ThreadBase + m_KdDebuggerData.OffsetKThreadState,
                            &State, sizeof(State));
    if (Status != S_OK)
    {
        ErrOut("Cannot read thread stack from thread %s, %s\n",
               FormatMachineAddr64(m_Machine, ThreadBase),
               FormatStatusCode(Status));
        return Status;
    }

    if (State != 2)
    {
        // thread is not running.

        Status = ReadPointer(m_ProcessHead, m_Machine,
                             ThreadBase +
                             m_KdDebuggerData.OffsetKThreadKernelStack,
                             &Stack);
        if (Status != S_OK)
        {
            ErrOut("Cannot read thread stack from thread %s, %s\n",
                   FormatMachineAddr64(m_Machine, ThreadBase),
                   FormatStatusCode(Status));
            return Status;
        }

        Status = m_Machine->GetContextFromThreadStack
            (ThreadBase, Context, Stack);
    }
    else
    {
        if ((Status =
             ReadAllVirtual(m_ProcessHead,
                            ThreadBase +
                            m_KdDebuggerData.OffsetKThreadNextProcessor,
                            &Proc, 1)) != S_OK)
        {
            ErrOut("Cannot read processor number from thread %s, %s\n",
                   FormatMachineAddr64(m_Machine, ThreadBase),
                   FormatStatusCode(Status));
            return Status;
        }

        // Get the processor context if it's a valid processor.
        if (Proc < m_NumProcessors)
        {
            // This get may be getting the context of the thread
            // currently cached by the register code.  Make sure
            // the cache is flushed.
            FlushRegContext();

            m_Machine->
                InitializeContextFlags(Context, m_SystemVersion);
            if ((Status = GetContext(VIRTUAL_THREAD_HANDLE(Proc),
                                     Context)) != S_OK)
            {
                ErrOut("Unable to get context for thread "
                       "running on processor %d, %s\n",
                       Proc, FormatStatusCode(Status));
                return Status;
            }
        }
        else 
        {
            if (Verbose)
            {
                ErrOut("Thread running on invalid processor %d\n", Proc);
            }
            return E_INVALIDARG;
        }
    }

    if (Status != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Can't retrieve thread context, %s\n", 
                   FormatStatusCode(Status));
        }
    }

    return Status;
}

HRESULT
TargetInfo::StartAttachProcess(ULONG ProcessId,
                               ULONG AttachFlags,
                               PPENDING_PROCESS* Pending)
{
    return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
}

HRESULT
TargetInfo::StartCreateProcess(PWSTR CommandLine,
                               ULONG CreateFlags,
                               PBOOL InheritHandles,
                               PWSTR CurrentDir,
                               PPENDING_PROCESS* Pending)
{
    return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
}

HRESULT
TargetInfo::TerminateProcesses(void)
{
    return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
}

HRESULT
TargetInfo::DetachProcesses(void)
{
    return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
}

HRESULT
TargetInfo::EmulateNtX86SelDescriptor(ThreadInfo* Thread,
                                      MachineInfo* Machine,
                                      ULONG Selector,
                                      PDESCRIPTOR64 Desc)
{
    // Only emulate on platforms that support segments.
    if (Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_I386 &&
        Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_AMD64)
    {
        return E_UNEXPECTED;
    }

    ULONG Type, Gran;

    //
    // For user mode and triage dumps, we can hardcode the selector
    // since we do not have it anywhere.
    // XXX drewb - How many should we fake?  There are quite
    // a few KGDT entries.  Which ones are valid in user mode and
    // which are valid for a triage dump?
    //

    if (Selector == m_KdDebuggerData.GdtR3Teb)
    {
        HRESULT Status;

        // In user mode fs points to the TEB so fake up
        // a selector for it.
        if ((Status = Thread->m_Process->
             GetImplicitThreadDataTeb(Thread, &Desc->Base)) != S_OK)
        {
            return Status;
        }

        if (Machine != m_Machine)
        {
            ULONG Read;

            // We're asking for an emulated machine's TEB.
            // The only case we currently handle is x86-on-IA64
            // for Wow64, where the 32-bit TEB pointer is
            // stored in NT_TIB.ExceptionList.
            // Conveniently, this is the very first entry.
            if ((Status = ReadVirtual(Thread->m_Process,
                                      Desc->Base, &Desc->Base,
                                      sizeof(ULONG), &Read)) != S_OK)
            {
                return Status;
            }
            if (Read != sizeof(ULONG))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }

            Desc->Base = EXTEND64(Desc->Base);
        }

        Desc->Limit = Machine->m_PageSize - 1;
        Type = 0x13;
        Gran = 0;
    }
    else if (Selector == m_KdDebuggerData.GdtR3Data)
    {
        Desc->Base = 0;
        Desc->Limit = Machine->m_Ptr64 ? 0xffffffffffffffffI64 : 0xffffffff;
        Type = 0x13;
        Gran = X86_DESC_GRANULARITY;
    }
    else
    {
        // Assume it's a code segment.
        Desc->Base = 0;
        Desc->Limit = Machine->m_Ptr64 ? 0xffffffffffffffffI64 : 0xffffffff;
        Type = 0x1b;
        Gran = X86_DESC_GRANULARITY |
            (Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 ?
             X86_DESC_LONG_MODE : 0);
    }

    Desc->Flags = Gran | X86_DESC_DEFAULT_BIG | X86_DESC_PRESENT | Type |
        (IS_USER_TARGET(this) ?
         (3 << X86_DESC_PRIVILEGE_SHIFT) : (Selector & 3));

    return S_OK;
}

HRESULT
TargetInfo::EmulateNtAmd64SelDescriptor(ThreadInfo* Thread,
                                        MachineInfo* Machine,
                                        ULONG Selector,
                                        PDESCRIPTOR64 Desc)
{
    if (Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_AMD64)
    {
        return E_UNEXPECTED;
    }

    ULONG Type, Gran;

    //
    // XXX drewb - How many should we fake?  There are quite
    // a few KGDT64 entries.  Which ones are valid in user mode and
    // which are valid for a triage dump?
    //

    if (Selector == m_KdDebuggerData.Gdt64R3CmTeb)
    {
        HRESULT Status;

        // In user mode fs points to the TEB so fake up
        // a selector for it.
        if ((Status = Thread->m_Process->
             GetImplicitThreadDataTeb(Thread, &Desc->Base)) != S_OK)
        {
            return Status;
        }

        if (Machine != m_Machine)
        {
            ULONG Read;

            // We're asking for an emulated machine's TEB.
            // The only case we currently handle is x86-on-IA64
            // for Wow64, where the 32-bit TEB pointer is
            // stored in NT_TIB.ExceptionList.
            // Conveniently, this is the very first entry.
            if ((Status = ReadVirtual(Thread->m_Process,
                                      Desc->Base, &Desc->Base,
                                      sizeof(ULONG), &Read)) != S_OK)
            {
                return Status;
            }
            if (Read != sizeof(ULONG))
            {
                return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
            }

            Desc->Base = EXTEND64(Desc->Base);
        }

        Desc->Limit = Machine->m_PageSize - 1;
        Type = 0x13;
        Gran = 0;
    }
    else if (Selector == m_KdDebuggerData.GdtR3Data)
    {
        Desc->Base = 0;
        Desc->Limit = Machine->m_Ptr64 ? 0xffffffffffffffffI64 : 0xffffffff;
        Type = 0x13;
        Gran = X86_DESC_GRANULARITY;
    }
    else if (Selector == m_KdDebuggerData.Gdt64R3CmCode)
    {
        Desc->Base = 0;
        Desc->Limit = 0xffffffff;
        Type = 0x1b;
        Gran = X86_DESC_GRANULARITY;
    }
    else
    {
        // Assume it's a code segment.
        Desc->Base = 0;
        Desc->Limit = Machine->m_Ptr64 ? 0xffffffffffffffffI64 : 0xffffffff;
        Type = 0x1b;
        Gran = X86_DESC_GRANULARITY |
            (Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 ?
             X86_DESC_LONG_MODE : 0);
    }

    Desc->Flags = Gran | X86_DESC_DEFAULT_BIG | X86_DESC_PRESENT | Type |
        (IS_USER_TARGET(this) ?
         (3 << X86_DESC_PRIVILEGE_SHIFT) : (Selector & 3));

    return S_OK;
}

HRESULT
TargetInfo::EmulateNtSelDescriptor(ThreadInfo* Thread,
                                   MachineInfo* Machine,
                                   ULONG Selector,
                                   PDESCRIPTOR64 Desc)
{
    switch(Machine->m_ExecTypes[0])
    {
    case IMAGE_FILE_MACHINE_I386:
        return EmulateNtX86SelDescriptor(Thread, Machine, Selector, Desc);
    case IMAGE_FILE_MACHINE_AMD64:
        return EmulateNtAmd64SelDescriptor(Thread, Machine, Selector, Desc);
    default:
        return E_UNEXPECTED;
    }
}

HRESULT
TargetInfo::GetImplicitProcessData(ThreadInfo* Thread, PULONG64 Offset)
{
    HRESULT Status;

    if (m_ImplicitProcessData == 0 ||
        (m_ImplicitProcessDataIsDefault &&
         Thread != m_ImplicitProcessDataThread))
    {
        Status = SetImplicitProcessData(Thread, 0, FALSE);
    }
    else
    {
        Status = S_OK;
    }
    
    *Offset = m_ImplicitProcessData;
    return Status;
}

HRESULT
TargetInfo::GetImplicitProcessDataPeb(ThreadInfo* Thread, PULONG64 Peb)
{
    if (IS_USER_TARGET(this))
    {
        // In user mode the process data is the PEB.
        return GetImplicitProcessData(Thread, Peb);
    }
    else if (IS_KERNEL_TARGET(this))
    {
        return ReadImplicitProcessInfoPointer
            (Thread, m_KdDebuggerData.OffsetEprocessPeb, Peb);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

HRESULT
TargetInfo::GetImplicitProcessDataParentCID(ThreadInfo* Thread, PULONG64 Pcid)
{
    if (!IS_KERNEL_TARGET(this))
    {
        // In user mode we don't need the parent process ...
        return E_NOTIMPL;
    }
    else
    {
        return ReadImplicitProcessInfoPointer
            (Thread, m_KdDebuggerData.OffsetEprocessParentCID, Pcid);
    }
}

HRESULT
TargetInfo::SetImplicitProcessData(ThreadInfo* Thread,
                                   ULONG64 Offset, BOOL Verbose)
{
    HRESULT Status;
    BOOL Default = FALSE;

    if (Offset == 0)
    {
        if (!Thread || Thread->m_Process->m_Target != this)
        {
            if (Verbose)
            {
                ErrOut("Unable to get the current thread data\n");
            }
            return E_UNEXPECTED;
        }
        
        if ((Status = GetProcessInfoDataOffset(Thread, 0, 0, &Offset)) != S_OK)
        {
            if (Verbose)
            {
                ErrOut("Unable to get the current process data\n");
            }
            return Status;
        }
        if (Offset == 0)
        {
            if (Verbose)
            {
                ErrOut("Current process data is NULL\n");
            }
            return E_FAIL;
        }

        Default = TRUE;
    }
    
    ULONG64 Old = m_ImplicitProcessData;
    BOOL OldDefault = m_ImplicitProcessDataIsDefault;
    ThreadInfo* OldThread = m_ImplicitProcessDataThread;
        
    m_ImplicitProcessData = Offset;
    m_ImplicitProcessDataIsDefault = Default;
    m_ImplicitProcessDataThread = Thread;
    if (IS_KERNEL_TARGET(this) &&
        !IS_KERNEL_TRIAGE_DUMP(this) &&
        (Status = m_Machine->
         SetDefaultPageDirectories(Thread, PAGE_DIR_ALL)) != S_OK)
    {
        m_ImplicitProcessData = Old;
        m_ImplicitProcessDataIsDefault = OldDefault;
        m_ImplicitProcessDataThread = OldThread;
        if (Verbose)
        {
            ErrOut("Process %s has invalid page directories\n",
                   FormatMachineAddr64(m_Machine, Offset));
        }

        return Status;
    }

    return S_OK;
}

HRESULT
TargetInfo::ReadImplicitProcessInfoPointer(ThreadInfo* Thread,
                                           ULONG Offset, PULONG64 Ptr)
{
    HRESULT Status;
    ULONG64 CurProc;

    // Retrieve the current EPROCESS.
    if ((Status = GetImplicitProcessData(Thread, &CurProc)) != S_OK)
    {
        return Status;
    }

    return ReadPointer(Thread->m_Process, m_Machine, CurProc + Offset, Ptr);
}

HRESULT
TargetInfo::KdGetThreadInfoDataOffset(ThreadInfo* Thread,
                                      ULONG64 ThreadHandle,
                                      PULONG64 Offset)
{
    if (Thread != NULL && Thread->m_DataOffset != 0)
    {
        *Offset = Thread->m_DataOffset;
        return S_OK;
    }

    ULONG Processor;

    if (Thread != NULL)
    {
        ThreadHandle = Thread->m_Handle;
    }
    Processor = VIRTUAL_THREAD_INDEX(ThreadHandle);

    HRESULT Status;

    Status = GetProcessorSystemDataOffset(Processor,
                                          DEBUG_DATA_KTHREAD_OFFSET,
                                          Offset);

    if (Status == S_OK && Thread != NULL)
    {
        Thread->m_DataOffset = *Offset;
    }

    return Status;
}

HRESULT
TargetInfo::KdGetProcessInfoDataOffset(ThreadInfo* Thread,
                                       ULONG Processor,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset)
{
    // Process data offsets are not cached for kernel mode
    // since the only ProcessInfo is for kernel space.

    ULONG64 ProcessAddr;
    HRESULT Status;

    if (ThreadData == 0)
    {
        Status = GetThreadInfoDataOffset(Thread,
                                         VIRTUAL_THREAD_HANDLE(Processor),
                                         &ThreadData);
        if (Status != S_OK)
        {
            return Status;
        }
    }

    ThreadData += m_KdDebuggerData.OffsetKThreadApcProcess;

    Status = ReadPointer(m_ProcessHead,
                         m_Machine, ThreadData, &ProcessAddr);
    if (Status != S_OK)
    {
        ErrOut("Unable to read KTHREAD address %p\n", ThreadData);
    }
    else
    {
        *Offset = ProcessAddr;
    }

    return Status;
}

HRESULT
TargetInfo::KdGetThreadInfoTeb(ThreadInfo* Thread,
                               ULONG ThreadIndex,
                               ULONG64 ThreadData,
                               PULONG64 Offset)
{
    ULONG64 TebAddr;
    HRESULT Status;

    if (ThreadData == 0)
    {
        Status = GetThreadInfoDataOffset(Thread,
                                         VIRTUAL_THREAD_HANDLE(ThreadIndex),
                                         &ThreadData);
        if (Status != S_OK)
        {
            return Status;
        }
    }

    ThreadData += m_KdDebuggerData.OffsetKThreadTeb;

    Status = ReadPointer(m_ProcessHead,
                         m_Machine, ThreadData, &TebAddr);
    if (Status != S_OK)
    {
        ErrOut("Could not read KTHREAD address %p\n", ThreadData);
    }
    else
    {
        *Offset = TebAddr;
    }

    return Status;
}

HRESULT
TargetInfo::KdGetProcessInfoPeb(ThreadInfo* Thread,
                                ULONG Processor,
                                ULONG64 ThreadData,
                                PULONG64 Offset)
{
    HRESULT Status;
    ULONG64 Process, PebAddr;

    Status = GetProcessInfoDataOffset(Thread, Processor,
                                      ThreadData, &Process);
    if (Status != S_OK)
    {
        return Status;
    }

    Process += m_KdDebuggerData.OffsetEprocessPeb;

    Status = ReadPointer(m_ProcessHead,
                         m_Machine, Process, &PebAddr);
    if (Status != S_OK)
    {
        ErrOut("Could not read KPROCESS address %p\n", Process);
    }
    else
    {
        *Offset = PebAddr;
    }

    return Status;
}

void
TargetInfo::FlushSelectorCache(void)
{
    for (ULONG i = 0; i < SELECTOR_CACHE_LENGTH; i++)
    {
        m_SelectorCache[i].Younger = &m_SelectorCache[i + 1];
        m_SelectorCache[i].Older = &m_SelectorCache[i - 1];
        m_SelectorCache[i].Processor = (ULONG)-1;
        m_SelectorCache[i].Selector = 0;
    }
    m_SelectorCache[--i].Younger = NULL;
    m_SelectorCache[0].Older = NULL;
    m_YoungestSel = &m_SelectorCache[i];
    m_OldestSel = &m_SelectorCache[0];
}

BOOL
TargetInfo::FindSelector(ULONG Processor, ULONG Selector,
                         PDESCRIPTOR64 Desc)
{
    int i;

    for (i = 0; i < SELECTOR_CACHE_LENGTH; i++)
    {
        if (m_SelectorCache[i].Selector == Selector &&
            m_SelectorCache[i].Processor == Processor)
        {
            *Desc = m_SelectorCache[i].Desc;
            return TRUE;
        }
    }
    return FALSE;
}

void
TargetInfo::PutSelector(ULONG Processor, ULONG Selector,
                        PDESCRIPTOR64 Desc)
{
    m_OldestSel->Processor = Processor;
    m_OldestSel->Selector = Selector;
    m_OldestSel->Desc = *Desc;
    (m_OldestSel->Younger)->Older = NULL;
    m_OldestSel->Older = m_YoungestSel;
    m_YoungestSel->Younger = m_OldestSel;
    m_YoungestSel = m_OldestSel;
    m_OldestSel = m_OldestSel->Younger;
}

HRESULT
TargetInfo::KdGetSelDescriptor(ThreadInfo* Thread,
                               MachineInfo* Machine,
                               ULONG Selector,
                               PDESCRIPTOR64 Desc)
{
    if (!Thread || !Machine)
    {
        return E_INVALIDARG;
    }
    
    ULONG Processor = VIRTUAL_THREAD_INDEX(Thread->m_Handle);

    if (FindSelector(Processor, Selector, Desc))
    {
        return S_OK;
    }

    ThreadInfo* CtxThread;

    CtxThread = m_RegContextThread;
    ChangeRegContext(Thread);
    
    ULONG TableReg;
    DESCRIPTOR64 Table;
    HRESULT Status;

    // Find out whether this is a GDT or LDT selector
    if (Selector & 0x4)
    {
        TableReg = SEGREG_LDT;
    }
    else
    {
        TableReg = SEGREG_GDT;
    }

    //
    // Fetch the address and limit of the appropriate descriptor table,
    // then look up the selector entry.
    //

    if ((Status = Machine->GetSegRegDescriptor(TableReg, &Table)) != S_OK)
    {
        goto Exit;
    }

    Status = ReadX86Descriptor(this, Thread->m_Process,
                               Selector, Table.Base, (ULONG)Table.Limit, Desc);
    if (Status == S_OK)
    {
        PutSelector(Processor, Selector, Desc);
    }

 Exit:
    ChangeRegContext(CtxThread);
    return Status;
}

//----------------------------------------------------------------------------
//
// LiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
LiveKernelTargetInfo::GetThreadIdByProcessor(
    IN ULONG Processor,
    OUT PULONG Id
    )
{
    *Id = VIRTUAL_THREAD_ID(Processor);
    return S_OK;
}

HRESULT
LiveKernelTargetInfo::GetThreadInfoDataOffset(ThreadInfo* Thread,
                                              ULONG64 ThreadHandle,
                                              PULONG64 Offset)
{
    return KdGetThreadInfoDataOffset(Thread, ThreadHandle, Offset);
}

HRESULT
LiveKernelTargetInfo::GetProcessInfoDataOffset(ThreadInfo* Thread,
                                               ULONG Processor,
                                               ULONG64 ThreadData,
                                               PULONG64 Offset)
{
    return KdGetProcessInfoDataOffset(Thread, Processor, ThreadData, Offset);
}

HRESULT
LiveKernelTargetInfo::GetThreadInfoTeb(ThreadInfo* Thread,
                                       ULONG ThreadIndex,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset)
{
    return KdGetThreadInfoTeb(Thread, ThreadIndex, ThreadData, Offset);
}

HRESULT
LiveKernelTargetInfo::GetProcessInfoPeb(ThreadInfo* Thread,
                                        ULONG Processor,
                                        ULONG64 ThreadData,
                                        PULONG64 Offset)
{
    return KdGetProcessInfoPeb(Thread, Processor, ThreadData, Offset);
}

HRESULT
LiveKernelTargetInfo::GetSelDescriptor(ThreadInfo* Thread,
                                       MachineInfo* Machine,
                                       ULONG Selector,
                                       PDESCRIPTOR64 Desc)
{
    return KdGetSelDescriptor(Thread, Machine, Selector, Desc);
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
ConnLiveKernelTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_GET_CONTEXT a = &m.u.GetContext;
    NTSTATUS st;
    ULONG rc;

    if (m_Machine == NULL)
    {
        return E_UNEXPECTED;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdGetContextApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (USHORT)VIRTUAL_THREAD_INDEX(Thread);

    //
    // Send the message and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 NULL, 0);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdGetContextApi);

    st = Reply->ReturnStatus;

    //
    // Since get context response data follows message, Reply+1 should point
    // at the data
    //

    memcpy(Context, Reply + 1, m_TypeInfo.SizeTargetContext);

    KdOut("DbgKdGetContext returns %08lx\n", st);
    return CONV_NT_STATUS(st);
}

HRESULT
ConnLiveKernelTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    DBGKD_MANIPULATE_STATE64 m;
    PDBGKD_MANIPULATE_STATE64 Reply;
    PDBGKD_SET_CONTEXT a = &m.u.SetContext;
    NTSTATUS st;
    ULONG rc;

    if (m_Machine == NULL)
    {
        return E_UNEXPECTED;
    }

    //
    // Format state manipulate message
    //

    m.ApiNumber = DbgKdSetContextApi;
    m.ReturnStatus = STATUS_PENDING;
    m.Processor = (USHORT)VIRTUAL_THREAD_INDEX(Thread);

    //
    // Send the message and context and then wait for reply
    //

    do
    {
        m_Transport->WritePacket(&m, sizeof(m),
                                 PACKET_TYPE_KD_STATE_MANIPULATE,
                                 Context,
                                 (USHORT)
                                 m_TypeInfo.SizeTargetContext);
        rc = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &Reply);
    } while (rc != DBGKD_WAIT_PACKET ||
             Reply->ApiNumber != DbgKdSetContextApi);

    st = Reply->ReturnStatus;

    KdOut("DbgKdSetContext returns %08lx\n", st);
    return CONV_NT_STATUS(st);
}

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    // There really isn't any way to make
    // this work in a meaningful way unless the system
    // is paused.
    return E_NOTIMPL;
}

HRESULT
LocalLiveKernelTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    // There really isn't any way to make
    // this work in a meaningful way unless the system
    // is paused.
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
ExdiLiveKernelTargetInfo::GetProcessorSystemDataOffset(
    IN ULONG Processor,
    IN ULONG Index,
    OUT PULONG64 Offset
    )
{
    if (m_KdSupport != EXDI_KD_GS_PCR ||
        m_MachineType != IMAGE_FILE_MACHINE_AMD64)
    {
        return LiveKernelTargetInfo::
            GetProcessorSystemDataOffset(Processor, Index, Offset);
    }

    HRESULT Status;
    DESCRIPTOR64 GsDesc;
        
    if ((Status =
         GetTargetSegRegDescriptors(0, SEGREG_GS, 1, &GsDesc)) != S_OK)
    {
        return Status;
    }

    switch(Index)
    {
    case DEBUG_DATA_KPCR_OFFSET:
        *Offset = GsDesc.Base;
        break;

    case DEBUG_DATA_KPRCB_OFFSET:
    case DEBUG_DATA_KTHREAD_OFFSET:
        Status = ReadPointer(m_ProcessHead,
                             m_Machine,
                             GsDesc.Base +
                             m_KdDebuggerData.OffsetPcrCurrentPrcb,
                             Offset);
        if (Status != S_OK)
        {
            return Status;
        }

        if (Index == DEBUG_DATA_KPRCB_OFFSET)
        {
            break;
        }

        Status = ReadPointer(m_ProcessHead,
                             m_Machine,
                             *Offset +
                             m_KdDebuggerData.OffsetPrcbCurrentThread,
                             Offset);
        if (Status != S_OK)
        {
            return Status;
        }
        break;
    }

    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = m_Machine->
             GetExdiContext(m_Context, &m_ContextData, m_ContextType)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = NULL;
    }

    m_Machine->ConvertExdiContextToContext
        (&m_ContextData, m_ContextType, (PCROSS_PLATFORM_CONTEXT)Context);
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = m_Machine->
             GetExdiContext(m_Context, &m_ContextData, m_ContextType)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    m_Machine->ConvertExdiContextFromContext
        ((PCROSS_PLATFORM_CONTEXT)Context, &m_ContextData, m_ContextType);
    return m_Machine->SetExdiContext(m_Context, &m_ContextData,
                                               m_ContextType);
}

HRESULT
ExdiLiveKernelTargetInfo::GetTargetSegRegDescriptors(ULONG64 Thread,
                                                     ULONG Start, ULONG Count,
                                                     PDESCRIPTOR64 Descs)
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = m_Machine->
             GetExdiContext(m_Context, &m_ContextData, m_ContextType)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    m_Machine->
        ConvertExdiContextToSegDescs(&m_ContextData, m_ContextType,
                                     Start, Count, Descs);
    return S_OK;
}

void
ExdiLiveKernelTargetInfo::InvalidateTargetContext(void)
{
    m_ContextValid = FALSE;
}

HRESULT
ExdiLiveKernelTargetInfo::GetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = m_Machine->
             GetExdiContext(m_Context, &m_ContextData, m_ContextType)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    m_Machine->
        ConvertExdiContextToSpecial(&m_ContextData, m_ContextType, Special);
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::SetTargetSpecialRegisters
    (ULONG64 Thread, PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    if (!m_ContextValid)
    {
        HRESULT Status;

        if ((Status = m_Machine->
             GetExdiContext(m_Context, &m_ContextData, m_ContextType)) != S_OK)
        {
            return Status;
        }

        m_ContextValid = TRUE;
    }

    m_Machine->
        ConvertExdiContextFromSpecial(Special, &m_ContextData, m_ContextType);
    return m_Machine->SetExdiContext(m_Context, &m_ContextData,
                                               m_ContextType);
}

//----------------------------------------------------------------------------
//
// LiveUserTargetInfo system object methods.
//
//----------------------------------------------------------------------------

HRESULT
LiveUserTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    return m_Services->
        GetContext(Thread,
                   *(PULONG)((PUCHAR)Context +
                             m_TypeInfo.
                             OffsetTargetContextFlags),
                   m_TypeInfo.OffsetTargetContextFlags,
                   Context,
                   m_TypeInfo.SizeTargetContext, NULL);
}

HRESULT
LiveUserTargetInfo::SetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    return m_Services->
        SetContext(Thread, Context,
                   m_TypeInfo.SizeTargetContext,
                   NULL);
}

HRESULT
LiveUserTargetInfo::GetThreadStartOffset(ThreadInfo* Thread,
                                     PULONG64 StartOffset)
{
    return m_Services->
        GetThreadStartAddress(Thread->m_Handle, StartOffset);
}

#define BUFFER_THREADS 64

void
LiveUserTargetInfo::SuspendThreads(void)
{
    HRESULT Status;
    ProcessInfo* Process;
    ThreadInfo* Thread;
    ULONG64 Threads[BUFFER_THREADS];
    ULONG Counts[BUFFER_THREADS];
    PULONG StoreCounts[BUFFER_THREADS];
    ULONG Buffered;
    ULONG i;

    Buffered = 0;
    Process = m_ProcessHead;
    while (Process != NULL)
    {
        Thread = (Process->m_Flags & ENG_PROC_NO_SUSPEND_RESUME) ?
            NULL : Process->m_ThreadHead;
        while (Thread != NULL)
        {
            if (!Process->m_Exited &&
                !Thread->m_Exited &&
                Thread->m_Handle != 0)
            {
#ifdef DBG_SUSPEND
                dprintf("** suspending thread id: %x handle: %I64x\n",
                        Thread->m_SystemId, Thread->m_Handle);
#endif

                if (Thread->m_InternalFreezeCount > 0)
                {
                    Thread->m_InternalFreezeCount--;
                }
                else if (Thread->m_FreezeCount > 0)
                {
                    dprintf("thread %d can execute\n", Thread->m_UserId);
                    Thread->m_FreezeCount--;
                }
                else
                {
                    if (Buffered == BUFFER_THREADS)
                    {
                        if ((Status = m_Services->
                             SuspendThreads(Buffered, Threads,
                                            Counts)) != S_OK)
                        {
                            WarnOut("SuspendThread failed, %s\n",
                                    FormatStatusCode(Status));
                        }

                        for (i = 0; i < Buffered; i++)
                        {
                            *StoreCounts[i] = Counts[i];
                        }
                        
                        Buffered = 0;
                    }

                    Threads[Buffered] = Thread->m_Handle;
                    StoreCounts[Buffered] = &Thread->m_SuspendCount;
                    Buffered++;
                }
            }
            
            Thread = Thread->m_Next;
        }
        
        Process = Process->m_Next;
    }
    
    if (Buffered > 0)
    {
        if ((Status = m_Services->
             SuspendThreads(Buffered, Threads, Counts)) != S_OK)
        {
            WarnOut("SuspendThread failed, %s\n",
                    FormatStatusCode(Status));
        }
        
        for (i = 0; i < Buffered; i++)
        {
            *StoreCounts[i] = Counts[i];
        }
    }
}

BOOL
LiveUserTargetInfo::ResumeThreads(void)
{
    ProcessInfo* Process;
    ThreadInfo* Thread;
    HRESULT Status;
    BOOL EventActive = FALSE;
    BOOL EventAlive = FALSE;
    ULONG64 Threads[BUFFER_THREADS];
    ULONG Counts[BUFFER_THREADS];
    PULONG StoreCounts[BUFFER_THREADS];
    ULONG Buffered;
    ULONG i;

    Buffered = 0;
    Process = m_ProcessHead;
    while (Process != NULL)
    {
        if (Process->m_Flags & ENG_PROC_NO_SUSPEND_RESUME)
        {
            Thread = NULL;
            // Suppress any possible warning message under
            // the assumption that sessions where the caller
            // is managing suspension do not need warnings.
            EventActive = TRUE;
        }
        else
        {
            Thread = Process->m_ThreadHead;
        }
        while (Thread != NULL)
        {
            if (!Process->m_Exited &&
                !Thread->m_Exited &&
                Thread->m_Handle != 0)
            {
                if (Process == g_EventProcess)
                {
                    EventAlive = TRUE;
                }
                
#ifdef DBG_SUSPEND
                dprintf("** resuming thread id: %x handle: %I64x\n",
                        Thread->m_SystemId, Thread->m_Handle);
#endif

                if ((g_EngStatus & ENG_STATUS_STOP_SESSION) == 0 &&
                    !ThreadWillResume(Thread))
                {
                    if (!IsSelectedExecutionThread(Thread,
                                                   SELTHREAD_INTERNAL_THREAD))
                    {
                        dprintf("thread %d not executing\n", Thread->m_UserId);
                        Thread->m_FreezeCount++;
                    }
                    else
                    {
                        Thread->m_InternalFreezeCount++;
                    }
                }
                else
                {
                    if (Process == g_EventProcess)
                    {
                        EventActive = TRUE;
                    }
                
                    if (Buffered == BUFFER_THREADS)
                    {
                        if ((Status = m_Services->
                             ResumeThreads(Buffered, Threads,
                                           Counts)) != S_OK)
                        {
                            WarnOut("ResumeThread failed, %s\n",
                                    FormatStatusCode(Status));
                        }

                        for (i = 0; i < Buffered; i++)
                        {
                            *StoreCounts[i] = Counts[i];
                        }
                    
                        Buffered = 0;
                    }
                    
                    Threads[Buffered] = Thread->m_Handle;
                    StoreCounts[Buffered] = &Thread->m_SuspendCount;
                    Buffered++;
                }
            }
            
            Thread = Thread->m_Next;
        }

        Process = Process->m_Next;
    }
    
    if (Buffered > 0)
    {
        if ((Status = m_Services->
             ResumeThreads(Buffered, Threads, Counts)) != S_OK)
        {
            WarnOut("ResumeThread failed, %s\n",
                    FormatStatusCode(Status));
        }

        for (i = 0; i < Buffered; i++)
        {
            *StoreCounts[i] = Counts[i];
        }
    }

    if (EventAlive && !EventActive)
    {
        return FALSE;
    }
    
    return TRUE;
}

HRESULT
LiveUserTargetInfo::GetThreadInfoDataOffset(ThreadInfo* Thread,
                                        ULONG64 ThreadHandle,
                                        PULONG64 Offset)
{
    if (Thread && Thread->m_DataOffset)
    {
        *Offset = Thread->m_DataOffset;
        return S_OK;
    }

    if (Thread)
    {
        ThreadHandle = Thread->m_Handle;
    }
    else if (!ThreadHandle)
    {
        return E_UNEXPECTED;
    }

    HRESULT Status = m_Services->
        GetThreadDataOffset(ThreadHandle, Offset);

    if (Status == S_OK)
    {
        if (Thread)
        {
            Thread->m_DataOffset = *Offset;
        }
    }

    return Status;
}

HRESULT
LiveUserTargetInfo::GetProcessInfoDataOffset(ThreadInfo* Thread,
                                         ULONG Processor,
                                         ULONG64 ThreadData,
                                         PULONG64 Offset)
{
    HRESULT Status;

    // Even if an arbitrary thread data pointer is given
    // we still require a thread in order to know what
    // process to read from.
    // Processor isn't any use so fail if no thread is given.
    if (!Thread)
    {
        return E_UNEXPECTED;
    }

    if (ThreadData != 0)
    {
        if (g_DebuggerPlatformId == VER_PLATFORM_WIN32_NT)
        {
            ThreadData += m_Machine->m_Ptr64 ?
                PEB_FROM_TEB64 : PEB_FROM_TEB32;
            Status = ReadPointer(Thread->m_Process, m_Machine,
                                 ThreadData, Offset);
        }
        else
        {
            Status = E_NOTIMPL;
        }
    }
    else
    {
        ProcessInfo* Process = Thread->m_Process;
        if (Process->m_DataOffset != 0)
        {
            *Offset = Process->m_DataOffset;
            Status = S_OK;
        }
        else
        {
            Status = m_Services->
                GetProcessDataOffset(Process->m_SysHandle, Offset);
        }
    }

    if (Status == S_OK)
    {
        if (!ThreadData)
        {
            Thread->m_Process->m_DataOffset = *Offset;
        }
    }

    return Status;
}

HRESULT
LiveUserTargetInfo::GetThreadInfoTeb(ThreadInfo* Thread,
                                 ULONG Processor,
                                 ULONG64 ThreadData,
                                 PULONG64 Offset)
{
    return GetThreadInfoDataOffset(Thread, ThreadData, Offset);
}

HRESULT
LiveUserTargetInfo::GetProcessInfoPeb(ThreadInfo* Thread,
                                  ULONG Processor,
                                  ULONG64 ThreadData,
                                  PULONG64 Offset)
{
    // Thread data is not useful.
    return GetProcessInfoDataOffset(Thread, 0, 0, Offset);
}

HRESULT
LiveUserTargetInfo::GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc)
{
    HRESULT Status;
    ULONG Used;
    X86_LDT_ENTRY X86Desc;

    if ((Status = m_Services->
         DescribeSelector(Thread->m_Handle, Selector,
                          &X86Desc, sizeof(X86Desc),
                          &Used)) != S_OK)
    {
        return Status;
    }
    if (Used != sizeof(X86Desc))
    {
        return E_FAIL;
    }

    X86DescriptorToDescriptor64(&X86Desc, Desc);
    return S_OK;
}

HRESULT
LiveUserTargetInfo::StartAttachProcess(ULONG ProcessId,
                                       ULONG AttachFlags,
                                       PPENDING_PROCESS* Pending)
{
    HRESULT Status;
    PPENDING_PROCESS Pend;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process attach disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    
    if (m_Local &&
        ProcessId == GetCurrentProcessId() &&
        !(AttachFlags & DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND))
    {
        ErrOut("Can't debug the current process\n");
        return E_INVALIDARG;
    }
    
    Pend = new PENDING_PROCESS;
    if (Pend == NULL)
    {
        ErrOut("Unable to allocate memory\n");
        return E_OUTOFMEMORY;
    }

    if ((AttachFlags & DEBUG_ATTACH_NONINVASIVE) == 0)
    {
        if ((Status = m_Services->
             AttachProcess(ProcessId, AttachFlags,
                           &Pend->Handle, &Pend->Options)) != S_OK)
        {
            ErrOut("Cannot debug pid %ld, %s\n    \"%s\"\n",
                   ProcessId, FormatStatusCode(Status), FormatStatus(Status));
            delete Pend;
            return Status;
        }

        Pend->Flags = ENG_PROC_ATTACHED;
        if (AttachFlags & DEBUG_ATTACH_EXISTING)
        {
            Pend->Flags |= ENG_PROC_ATTACH_EXISTING;
        }
        if (AttachFlags & DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK)
        {
            Pend->Flags |= ENG_PROC_NO_INITIAL_BREAK;
        }
        if (AttachFlags & DEBUG_ATTACH_INVASIVE_RESUME_PROCESS)
        {
            Pend->Flags |= ENG_PROC_RESUME_AT_ATTACH;
        }
        
        if (ProcessId == CSRSS_PROCESS_ID)
        {
            if (m_Local)
            {
                g_EngOptions |= DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS |
                    DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION;
                g_EngOptions &= ~DEBUG_ENGOPT_ALLOW_NETWORK_PATHS;
            }

            Pend->Flags |= ENG_PROC_SYSTEM;
        }
    }
    else
    {
        Pend->Handle = 0;
        Pend->Flags = ENG_PROC_EXAMINED;
        if (AttachFlags & DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND)
        {
            Pend->Flags |= ENG_PROC_NO_SUSPEND_RESUME;
        }
        Pend->Options = DEBUG_PROCESS_ONLY_THIS_PROCESS;
    }

    Pend->Id = ProcessId;
    Pend->InitialThreadId = 0;
    Pend->InitialThreadHandle = 0;
    AddPendingProcess(Pend);
    *Pending = Pend;
        
    return S_OK;
}

HRESULT
LiveUserTargetInfo::StartCreateProcess(PWSTR CommandLine,
                                       ULONG CreateFlags,
                                       PBOOL InheritHandles,
                                       PWSTR CurrentDir,
                                       PPENDING_PROCESS* Pending)
{
    HRESULT Status;
    PPENDING_PROCESS Pend;

    if ((CreateFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) == 0)
    {
        return E_INVALIDARG;
    }

    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process creation disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    Pend = new PENDING_PROCESS;
    if (Pend == NULL)
    {
        ErrOut("Unable to allocate memory\n");
        return E_OUTOFMEMORY;
    }
    
    dprintf("CommandLine: %ws\n", CommandLine);

    //
    // Pick up incoming inherit and curdir settings
    // and apply defaults if necessary.
    //

    BOOL FinalInheritHandles;

    if (InheritHandles)
    {
        FinalInheritHandles = *InheritHandles;
    }
    else
    {
        FinalInheritHandles = TRUE;
    }

    if (!CurrentDir)
    {
        CurrentDir = g_StartProcessDir;
    }
    if (CurrentDir)
    {
        dprintf("Starting directory: %ws\n", CurrentDir);
    }
    
    //
    // Create the process.
    //
    
    if ((Status = m_Services->
         CreateProcessW(CommandLine, CreateFlags,
                        FinalInheritHandles, CurrentDir,
                        &Pend->Id, &Pend->InitialThreadId,
                        &Pend->Handle, &Pend->InitialThreadHandle)) != S_OK)
    {
        ErrOut("Cannot execute '%ws', %s\n    \"%s\"\n",
               CommandLine, FormatStatusCode(Status),
               FormatStatusArgs(Status, NULL));
        delete Pend;
    }
    else
    {
        Pend->Flags = ENG_PROC_CREATED;
        Pend->Options = (CreateFlags & DEBUG_ONLY_THIS_PROCESS) ?
            DEBUG_PROCESS_ONLY_THIS_PROCESS : 0;
        AddPendingProcess(Pend);
        *Pending = Pend;
    }
    
    return Status;
}

HRESULT
LiveUserTargetInfo::TerminateProcesses(void)
{
    HRESULT Status;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process termination disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    
    ProcessInfo* Process;
    ULONG AllExamined = ENG_PROC_EXAMINED;

    ForTargetProcesses(this)
    {
        // The all-examined flag will get turned off if any
        // process is not examined.
        AllExamined &= Process->m_Flags;
        
        if ((Status = Process->Terminate()) != S_OK)
        {
            goto Exit;
        }
    }

    if (m_DeferContinueEvent)
    {
        // The event's process may just have been terminated so don't
        // check for failures.
        m_Services->ContinueEvent(DBG_CONTINUE);
        m_DeferContinueEvent = FALSE;
    }

    DEBUG_EVENT64 Event;
    ULONG EventUsed;
    BOOL AnyLeft;
    BOOL AnyExited;

    for (;;)
    {
        while (!AllExamined &&
               m_Services->WaitForEvent(0, &Event, sizeof(Event),
                                        &EventUsed) == S_OK)
        {
            // Check for process exit events so we can
            // mark the process infos as exited.
            if (EventUsed == sizeof(DEBUG_EVENT32))
            {
                DEBUG_EVENT32 Event32 = *(DEBUG_EVENT32*)&Event;
                DebugEvent32To64(&Event32, &Event);
            }
            else if (EventUsed != sizeof(DEBUG_EVENT64))
            {
                ErrOut("Event data corrupt\n");
                Status = E_FAIL;
                goto Exit;
            }

            if (Event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
            {
                Process = FindProcessBySystemId(Event.dwProcessId);
                if (Process != NULL)
                {
                    Process->MarkExited();
                }
            }

            m_Services->ContinueEvent(DBG_CONTINUE);
        }

        AnyLeft = FALSE;
        AnyExited = FALSE;

        ForTargetProcesses(this)
        {
            if (!Process->m_Exited)
            {
                ULONG Code;

                if ((Status = m_Services->
                     GetProcessExitCode(Process->m_SysHandle, &Code)) == S_OK)
                {
                    Process->MarkExited();
                    AnyExited = TRUE;
                }
                else if (FAILED(Status))
                {
                    ErrOut("Unable to wait for process to terminate, %s\n",
                           FormatStatusCode(Status));
                    goto Exit;
                }
                else
                {
                    AnyLeft = TRUE;
                }
            }
        }

        if (!AnyLeft)
        {
            break;
        }

        if (!AnyExited)
        {
            // Give things time to run and exit.
            Sleep(50);
        }
    }

    // We've terminated everything so it's safe to assume
    // we're no longer debugging any system processes.
    // We do this now rather than wait for DeleteProcess
    // so that shutdown can query the value immediately.
    m_AllProcessFlags &= ~ENG_PROC_SYSTEM;

    //
    // Drain off any remaining events.
    //

    if (!AllExamined)
    {
        while (m_Services->
               WaitForEvent(10, &Event, sizeof(Event), NULL) == S_OK)
        {
            m_Services->ContinueEvent(DBG_CONTINUE);
        }
    }

    Status = S_OK;

 Exit:
    return Status;
}

HRESULT
LiveUserTargetInfo::DetachProcesses(void)
{
    HRESULT Status;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Process detach disallowed\n");
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if (m_DeferContinueEvent)
    {
        if ((Status = m_Services->ContinueEvent(DBG_CONTINUE)) != S_OK)
        {
            ErrOut("Unable to continue terminated process, %s\n",
                   FormatStatusCode(Status));
            return Status;
        }
        m_DeferContinueEvent = FALSE;
    }

    ProcessInfo* Process;
    ULONG AllExamined = ENG_PROC_EXAMINED;

    ForTargetProcesses(this)
    {
        // The all-examined flag will get turned off if any
        // process is not examined.
        AllExamined &= Process->m_Flags;
        
        Process->Detach();
    }

    // We've terminated everything so it's safe to assume
    // we're no longer debugging any system processes.
    // We do this now rather than wait for DeleteProcess
    // so that shutdown can query the value immediately.
    m_AllProcessFlags &= ~ENG_PROC_SYSTEM;

    //
    // Drain off any remaining events.
    //

    if (!AllExamined)
    {
        DEBUG_EVENT64 Event;

        while (m_Services->
               WaitForEvent(10, &Event, sizeof(Event), NULL) == S_OK)
        {
            m_Services->ContinueEvent(DBG_CONTINUE);
        }
    }

    return S_OK;
}


void
LiveUserTargetInfo::AddPendingProcess(PPENDING_PROCESS Pending)
{
    Pending->Next = m_ProcessPending;
    m_ProcessPending = Pending;
    m_AllPendingFlags |= Pending->Flags;
}

void
LiveUserTargetInfo::RemovePendingProcess(PPENDING_PROCESS Pending)
{
    PPENDING_PROCESS Prev, Cur;
    ULONG AllFlags = 0;

    Prev = NULL;
    for (Cur = m_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur == Pending)
        {
            break;
        }

        Prev = Cur;
        AllFlags |= Cur->Flags;
    }

    if (Cur == NULL)
    {
        DBG_ASSERT(Cur != NULL);
        return;
    }

    Cur = Cur->Next;
    if (Prev == NULL)
    {
        m_ProcessPending = Cur;
    }
    else
    {
        Prev->Next = Cur;
    }
    DiscardPendingProcess(Pending);

    while (Cur != NULL)
    {
        AllFlags |= Cur->Flags;
        Cur = Cur->Next;
    }
    m_AllPendingFlags = AllFlags;
}

void
LiveUserTargetInfo::DiscardPendingProcess(PPENDING_PROCESS Pending)
{
    if (Pending->InitialThreadHandle)
    {
        m_Services->CloseHandle(Pending->InitialThreadHandle);
    }
    if (Pending->Handle)
    {
        m_Services->CloseHandle(Pending->Handle);
    }
    delete Pending;
}

void
LiveUserTargetInfo::DiscardPendingProcesses(void)
{
    while (m_ProcessPending != NULL)
    {
        PPENDING_PROCESS Next = m_ProcessPending->Next;
        DiscardPendingProcess(m_ProcessPending);
        m_ProcessPending = Next;
    }

    m_AllPendingFlags = 0;
}

PPENDING_PROCESS
LiveUserTargetInfo::FindPendingProcessByFlags(ULONG Flags)
{
    PPENDING_PROCESS Cur;
    
    for (Cur = m_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur->Flags & Flags)
        {
            return Cur;
        }
    }

    return NULL;
}

PPENDING_PROCESS
LiveUserTargetInfo::FindPendingProcessById(ULONG Id)
{
    PPENDING_PROCESS Cur;
    
    for (Cur = m_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur->Id == Id)
        {
            return Cur;
        }
    }

    return NULL;
}

void
LiveUserTargetInfo::VerifyPendingProcesses(void)
{
    PPENDING_PROCESS Cur;

 Restart:
    for (Cur = m_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        ULONG ExitCode;
        
        if (Cur->Handle &&
            m_Services->GetProcessExitCode(Cur->Handle, &ExitCode) == S_OK)
        {
            ErrOut("Process %d exited before attach completed\n", Cur->Id);
            RemovePendingProcess(Cur);
            goto Restart;
        }
    }
}

void
LiveUserTargetInfo::AddExamineToPendingAttach(void)
{
    PPENDING_PROCESS Cur;
    
    for (Cur = m_ProcessPending; Cur != NULL; Cur = Cur->Next)
    {
        if (Cur->Flags & ENG_PROC_ATTACHED)
        {
            Cur->Flags |= ENG_PROC_EXAMINED;
            m_AllPendingFlags |= ENG_PROC_EXAMINED;
        }
    }
}

void
LiveUserTargetInfo::SuspendResumeThreads(ProcessInfo* Process,
                                         BOOL Susp,
                                         ThreadInfo* Match)
{
    ThreadInfo* Thrd;

    for (Thrd = Process->m_ThreadHead; Thrd; Thrd = Thrd->m_Next)
    {
        if (Match != NULL && Match != Thrd)
        {
            continue;
        }
                    
        HRESULT Status;
        ULONG Count;
                        
        if (Susp)
        {
            Status = m_Services->
                SuspendThreads(1, &Thrd->m_Handle, &Count);
        }
        else
        {
            Status = m_Services->
                ResumeThreads(1, &Thrd->m_Handle, &Count);
        }
        if (Status != S_OK)
        {
            ErrOut("Operation failed for thread %d, 0x%X\n",
                   Thrd->m_UserId, Status);
        }
        else
        {
            Thrd->m_SuspendCount = Count;
        }
    }
}

//----------------------------------------------------------------------------
//
// IDebugSystemObjects methods.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DebugClient::GetEventThread(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (g_EventThread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_EventThread->m_UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetEventProcess(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (g_EventProcess == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_EventProcess->m_UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadId(
    THIS_
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Thread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_Thread->m_UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetCurrentThreadId(
    THIS_
    IN ULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (IS_RUNNING(g_CmdState))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ThreadInfo* Thread = FindAnyThreadByUserId(Id);
        if (Thread != NULL)
        {
            SetCurrentThread(Thread, FALSE);
            ResetCurrentScopeLazy();
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessId(
    THIS_
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_Process->m_UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetCurrentProcessId(
    THIS_
    IN ULONG Id
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (IS_RUNNING(g_CmdState))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ProcessInfo* Process = FindAnyProcessByUserId(Id);
        if (Process != NULL)
        {
            if (Process->m_CurrentThread == NULL)
            {
                Process->m_CurrentThread = Process->m_ThreadHead;
            }
            if (Process->m_CurrentThread == NULL)
            {
                Status = E_FAIL;
            }
            else
            {
                SetCurrentThread(Process->m_CurrentThread, FALSE);
                ResetCurrentScopeLazy();
                Status = S_OK;
            }
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberThreads(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_Process->m_NumThreads;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTotalNumberThreads(
    THIS_
    OUT PULONG Total,
    OUT PULONG LargestProcess
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Total = g_Target->m_TotalNumberThreads;
        *LargestProcess = g_Target->m_MaxThreadsInProcess;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdsByIndex(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ThreadInfo* Thread;
        ULONG Index;

        if (Start >= g_Process->m_NumThreads ||
            Start + Count > g_Process->m_NumThreads)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            Index = 0;
            for (Thread = g_Process->m_ThreadHead;
                 Thread != NULL;
                 Thread = Thread->m_Next)
            {
                if (Index >= Start && Index < Start + Count)
                {
                    if (Ids != NULL)
                    {
                        *Ids++ = Thread->m_UserId;
                    }
                    if (SysIds != NULL)
                    {
                        *SysIds++ = Thread->m_SystemId;
                    }
                }

                Index++;
            }

            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByProcessor(
    THIS_
    IN ULONG Processor,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG SysId;

        Status = g_Target->GetThreadIdByProcessor(Processor, &SysId);
        if (Status == S_OK)
        {
            ThreadInfo* Thread =
                g_Process->FindThreadBySystemId(SysId);
            if (Thread != NULL)
            {
                *Id = Thread->m_UserId;
            }
            else
            {
                Status = E_NOINTERFACE;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Thread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->
            GetThreadInfoDataOffset(g_Thread, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByDataOffset(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ThreadInfo* Thread;

        Status = E_NOINTERFACE;
        for (Thread = g_Process->m_ThreadHead;
             Thread != NULL;
             Thread = Thread->m_Next)
        {
            ULONG64 DataOffset;

            Status = g_Target->GetThreadInfoDataOffset(Thread, 0, &DataOffset);
            if (Status != S_OK)
            {
                break;
            }

            if (DataOffset == Offset)
            {
                *Id = Thread->m_UserId;
                Status = S_OK;
                break;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadTeb(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Thread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->GetThreadInfoTeb(g_Thread, 0, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByTeb(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ThreadInfo* Thread;

        Status = E_NOINTERFACE;
        for (Thread = g_Process->m_ThreadHead;
             Thread != NULL;
             Thread = Thread->m_Next)
        {
            ULONG64 Teb;

            Status = g_Target->GetThreadInfoTeb(Thread, 0, 0, &Teb);
            if (Status != S_OK)
            {
                break;
            }

            if (Teb == Offset)
            {
                *Id = Thread->m_UserId;
                Status = S_OK;
                break;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadSystemId(
    THIS_
    OUT PULONG SysId
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (IS_KERNEL_TARGET(g_Target))
    {
        Status = E_NOTIMPL;
    }
    else if (g_Thread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *SysId = g_Thread->m_SystemId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdBySystemId(
    THIS_
    IN ULONG SysId,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();
    
    if (IS_KERNEL_TARGET(g_Target))
    {
        Status = E_NOTIMPL;
    }
    else if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ThreadInfo* Thread = g_Process->FindThreadBySystemId(SysId);
        if (Thread != NULL)
        {
            *Id = Thread->m_UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentThreadHandle(
    THIS_
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Handle = g_Thread->m_Handle;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetThreadIdByHandle(
    THIS_
    IN ULONG64 Handle,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ThreadInfo* Thread = g_Process->FindThreadByHandle(Handle);
        if (Thread != NULL)
        {
            *Id = Thread->m_UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberProcesses(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;
    
    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Number = g_Target->m_NumProcesses;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdsByIndex(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    OUT OPTIONAL /* size_is(Count) */ PULONG SysIds
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
        goto EH_Exit;
    }

    ProcessInfo* Process;
    ULONG Index;

    if (Start >= g_Target->m_NumProcesses ||
        Start + Count > g_Target->m_NumProcesses)
    {
        Status = E_INVALIDARG;
        goto EH_Exit;
    }
    
    Index = 0;
    for (Process = g_Target->m_ProcessHead;
         Process != NULL;
         Process = Process->m_Next)
    {
        if (Index >= Start && Index < Start + Count)
        {
            if (Ids != NULL)
            {
                *Ids++ = Process->m_UserId;
            }
            if (SysIds != NULL)
            {
                *SysIds++ = Process->m_SystemId;
            }
        }

        Index++;
    }

    Status = S_OK;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Thread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->
            GetProcessInfoDataOffset(g_Thread, 0, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdByDataOffset(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else if (IS_KERNEL_TARGET(g_Target))
    {
        Status = E_NOTIMPL;
    }
    else
    {
        ProcessInfo* Process;
        
        Status = E_NOINTERFACE;
        for (Process = g_Target->m_ProcessHead;
             Process != NULL;
             Process = Process->m_Next)
        {
            ULONG64 DataOffset;

            Status = g_Target->
                GetProcessInfoDataOffset(Process->m_ThreadHead,
                                         0, 0, &DataOffset);
            if (Status != S_OK)
            {
                break;
            }

            if (DataOffset == Offset)
            {
                *Id = Process->m_UserId;
                Status = S_OK;
                break;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessPeb(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Thread == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->GetProcessInfoPeb(g_Thread, 0, 0, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdByPeb(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else if (IS_KERNEL_TARGET(g_Target))
    {
        Status = E_NOTIMPL;
    }
    else
    {
        ProcessInfo* Process;

        Status = E_NOINTERFACE;
        for (Process = g_Target->m_ProcessHead;
             Process != NULL;
             Process = Process->m_Next)
        {
            ULONG64 Peb;

            Status = g_Target->GetProcessInfoPeb(Process->m_ThreadHead,
                                                 0, 0, &Peb);
            if (Status != S_OK)
            {
                break;
            }

            if (Peb == Offset)
            {
                *Id = Process->m_UserId;
                Status = S_OK;
                break;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessSystemId(
    THIS_
    OUT PULONG SysId
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (IS_KERNEL_TARGET(g_Target))
    {
        Status = E_NOTIMPL;
    }
    else if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *SysId = g_Process->m_SystemId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdBySystemId(
    THIS_
    IN ULONG SysId,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else if (IS_KERNEL_TARGET(g_Target))
    {
        Status = E_NOTIMPL;
    }
    else
    {
        ProcessInfo* Process = g_Target->FindProcessBySystemId(SysId);
        if (Process != NULL)
        {
            *Id = Process->m_UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessHandle(
    THIS_
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Handle = g_Process->m_SysHandle;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetProcessIdByHandle(
    THIS_
    IN ULONG64 Handle,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ProcessInfo* Process = g_Target->FindProcessByHandle(Handle);
        if (Process != NULL)
        {
            *Id = Process->m_UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessExecutableName(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ExeSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = FillStringBuffer(g_Process->GetExecutableImageName(), 0,
                                  Buffer, BufferSize, ExeSize);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentProcessUpTime(
    THIS_
    OUT PULONG UpTime
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_USER_TARGET(g_Target) || g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG64 LongUpTime;
        
        LongUpTime = g_Target->GetProcessUpTimeN(g_Process);
        if (LongUpTime == 0)
        {
            Status = E_NOINTERFACE;
        }
        else
        {
            *UpTime = FileTimeToTime(LongUpTime);
            Status = S_OK;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetImplicitThreadDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Process->GetImplicitThreadData(g_Thread, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetImplicitThreadDataOffset(
    THIS_
    IN ULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Process->SetImplicitThreadData(g_Thread, Offset, FALSE);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetImplicitProcessDataOffset(
    THIS_
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->GetImplicitProcessData(g_Thread, Offset);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetImplicitProcessDataOffset(
    THIS_
    IN ULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->SetImplicitProcessData(g_Thread, Offset, FALSE);
    }

    LEAVE_ENGINE();
    return Status;
}

void
ResetImplicitData(void)
{
    if (g_Process)
    {
        g_Process->ResetImplicitData();
    }
    if (g_Target)
    {
        g_Target->ResetImplicitData();
    }
}

void
SetImplicitProcessAndCache(ULONG64 Base, BOOL Ptes, BOOL ReloadUser)
{
    BOOL OldPtes = g_Process->m_VirtualCache.m_ForceDecodePTEs;

    if (Ptes && !Base)
    {
        // If the user has requested a reset to the default
        // process with no translations we need to turn
        // off translations immediately so that any
        // existing base doesn't interfere with determining
        // the default process.
        g_Process->m_VirtualCache.SetForceDecodePtes(FALSE, g_Target);
    }
        
    if (g_Target->SetImplicitProcessData(g_Thread, Base, TRUE) == S_OK)
    {
        dprintf("Implicit process is now %s\n",
                FormatAddr64(g_Target->m_ImplicitProcessData));

        if (Ptes)
        {
            if (Base)
            {
                g_Process->m_VirtualCache.SetForceDecodePtes(TRUE, g_Target);
            }
            if (IS_REMOTE_KERNEL_TARGET(g_Target))
            {
                dprintf(".cache %sforcedecodeptes done\n",
                        Base != 0 ? "" : "no");
            }

            if (ReloadUser)
            {
                PCSTR ArgsRet;
                
                g_Target->Reload(g_Thread, "/user", &ArgsRet);
            }
        }
        
        if (Base && !g_Process->m_VirtualCache.m_ForceDecodePTEs &&
            IS_REMOTE_KERNEL_TARGET(g_Target))
        {
            WarnOut("WARNING: .cache forcedecodeptes is not enabled\n");
        }
    }
    else if (Ptes && !Base && OldPtes)
    {
        // Restore settings to the way they were.
        g_Process->m_VirtualCache.SetForceDecodePtes(TRUE, g_Target);
    }
}

HRESULT
SetScopeContextFromThreadData(ULONG64 ThreadBase, BOOL Verbose)
{
    if (!ThreadBase) 
    {
        if (GetCurrentScopeContext())
        {
            ResetCurrentScope();
        }
        return S_OK;
    }

    HRESULT Status;
    DEBUG_STACK_FRAME StkFrame;
    CROSS_PLATFORM_CONTEXT Context;
    
    if ((Status = g_Target->
         GetContextFromThreadStack(ThreadBase, &Context, Verbose)) != S_OK)
    {
        return Status;
    }
    
    g_Machine->GetScopeFrameFromContext(&Context, &StkFrame);
    SetCurrentScope(&StkFrame, &Context, sizeof(Context));
    
    return S_OK;
}

void
DotThread(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 Base = 0;
    BOOL Ptes = FALSE;
    BOOL ReloadUser = FALSE;

    if (!g_Thread)
    {
        error(BADTHREAD);
    }
    
    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*(++g_CurCmd))
        {
        case 'p':
            Ptes = TRUE;
            break;
        case 'r':
            ReloadUser = TRUE;
            break;
        default:
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        Base = GetExpression();
    }

    // Save the current setting in case things fail and
    // it needs to be restored.
    IMPLICIT_THREAD_SAVE Save;
    g_Process->SaveImplicitThread(&Save);
    
    if (g_Process->SetImplicitThreadData(g_Thread, Base, TRUE) == S_OK &&
        (!IS_KERNEL_TARGET(g_Target) ||
         SetScopeContextFromThreadData(Base, TRUE) == S_OK))
    {
        dprintf("Implicit thread is now %s\n",
                FormatAddr64(g_Process->m_ImplicitThreadData));

        if (IS_KERNEL_TARGET(g_Target) &&
            g_Process->m_ImplicitThreadData &&
            Ptes)
        {
            ULONG64 Process;

            if (!Base || g_Target->
                GetProcessInfoDataOffset(NULL, 0,
                                         g_Process->m_ImplicitThreadData,
                                         &Process) == S_OK)
            {
                SetImplicitProcessAndCache(Base ? Process : 0, Ptes,
                                           ReloadUser);
            }
            else
            {
                ErrOut("Unable to get process of implicit thread\n");
            }
        }
    }
    else
    {
        g_Process->RestoreImplicitThread(&Save);
    }
}

HRESULT
KernelPageIn(ULONG64 Process, ULONG64 Data, BOOL Kill)
{
    HRESULT Status;
    ULONG Work;

    ULONG64 ExpDebuggerProcessKill = 0;
    ULONG64 ExpDebuggerProcessAttach = 0;
    ULONG64 ExpDebuggerPageIn = 0;
    ULONG64 ExpDebuggerWork = 0;

    if (!IS_LIVE_KERNEL_TARGET(g_Target))
    {
        ErrOut("This operation only works on live kernel debug sessions\n");
        return E_NOTIMPL;
    }

    GetOffsetFromSym(g_Process,
                     "nt!ExpDebuggerProcessKill", &ExpDebuggerProcessKill,
                     NULL);
    GetOffsetFromSym(g_Process,
                     "nt!ExpDebuggerProcessAttach", &ExpDebuggerProcessAttach,
                     NULL);
    GetOffsetFromSym(g_Process,
                     "nt!ExpDebuggerPageIn", &ExpDebuggerPageIn, NULL);
    GetOffsetFromSym(g_Process,
                     "nt!ExpDebuggerWork", &ExpDebuggerWork, NULL);

    if ((Kill && !ExpDebuggerProcessKill) ||
        !ExpDebuggerProcessAttach ||
        !ExpDebuggerPageIn        ||
        !ExpDebuggerWork)
    {
        ErrOut("Symbols are wrong or this version of the operating system "
               "does not support this command\n");
        return E_NOTIMPL;
    }

    Status = g_Target->ReadAllVirtual(g_Process,
                                      ExpDebuggerWork, &Work, sizeof(Work));
    if (Status != S_OK)
    {
        ErrOut("Could not determine status or debugger worker thread\n");
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }
    else if (Work > 1)
    {
        ErrOut("Debugger worker thread has pending command\n");
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    if (Kill)
    {
        Status = g_Target->WritePointer(g_Process, g_Machine,
                                        ExpDebuggerProcessKill,
                                        Process);
    }
    else
    {
        Status = g_Target->WritePointer(g_Process, g_Machine,
                                        ExpDebuggerProcessAttach,
                                        Process);
        if (Status == S_OK)
        {
            Status = g_Target->WritePointer(g_Process, g_Machine,
                                            ExpDebuggerPageIn, Data);
        }
    }

    if (Status == S_OK)
    {
        Work = 1;
        Status = g_Target->
            WriteAllVirtual(g_Process, ExpDebuggerWork, &Work, sizeof(Work));
    }

    if (Status != S_OK)
    {
        ErrOut("Could not queue operation to debugger worker thread\n");
    }

    return Status;
}

void
DotProcess(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!g_Thread)
    {
        error(BADTHREAD);
    }
    
    ULONG64 Base = 0;
    BOOL Ptes = FALSE;
    BOOL Invasive = FALSE;
    BOOL ReloadUser = FALSE;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*(++g_CurCmd))
        {
        case 'i':
            Invasive = TRUE;
            break;
        case 'p':
            Ptes = TRUE;
            break;
        case 'r':
            ReloadUser = TRUE;
            break;
        default:
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        Base = GetExpression();
    }

    if (Invasive)
    {
        if (S_OK == KernelPageIn(Base, 0, FALSE))
        {
            dprintf("You need to continue execution (press 'g' <enter>) "
                    "for the context\nto be switched. When the debugger "
                    "breaks in again, you will be in\nthe new process "
                    "context.\n");
        }
        return;
    }

    SetImplicitProcessAndCache(Base, Ptes, ReloadUser);
}

void
DotFiber(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 Base = 0;

    if (!g_Process)
    {
        error(BADPROCESS);
    }
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        Base = GetExpression();
    }

    if (Base)
    {
        HRESULT Status;
        DEBUG_STACK_FRAME Frame;
        CROSS_PLATFORM_CONTEXT Context;
    
        if ((Status = g_Machine->GetContextFromFiber(g_Process, Base, &Context,
                                                     TRUE)) != S_OK)
        {
            return;
        }

        g_Machine->GetScopeFrameFromContext(&Context, &Frame);
        SetCurrentScope(&Frame, &Context, sizeof(Context));
        if (StackTrace(Client,
                       Frame.FrameOffset, Frame.StackOffset,
                       Frame.InstructionOffset, STACK_NO_DEFAULT,
                       &Frame, 1, 0, 0, FALSE) != 1)
        {
            ErrOut("Unable to walk fiber stack\n");
            ResetCurrentScope();
        }
    }
    else if (GetCurrentScopeContext())
    {
        dprintf("Resetting default context\n");
        ResetCurrentScope();
    }
}

void
DotKernelKill(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 Process = 0;

    if (PeekChar() && *g_CurCmd != ';')
    {
        Process = GetExpression();
    }

    if (Process)
    {
        KernelPageIn(Process, 0, TRUE);
    }
}

void
DotPageIn(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 Process = 0;
    ULONG64 Data = 0;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*(++g_CurCmd))
        {
        case 'p':
            g_CurCmd++;
            Process = GetExpression();
            break;
        default:
            g_CurCmd++;
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }
    }
    
    if (PeekChar() && *g_CurCmd != ';')
    {
        Data = GetExpression();
    }

    if (!Data)
    {
        ErrOut("Pagein requires an address to be specified\n");
        return;
    }

    if (Data > g_Target->m_SystemRangeStart)
    {
        ErrOut("Pagein operations are only supported for user mode"
               " addresses due to limitations in the memory manager\n");
        return;
    }

    //
    // Modify kernel state to do the pagein
    //

    if (S_OK != KernelPageIn(Process, Data, FALSE))
    {
        ErrOut("PageIn for address %s, process %s failed\n",
               FormatAddr64(Data),
               FormatAddr64(Process));
    }
    else
    {
        dprintf("You need to continue execution (press 'g' <enter>) for "
                 "the pagein to be brought in.  When the debugger breaks in "
                 "again, the page will be present.\n");
    }
}

STDMETHODIMP
DebugClient::GetEventSystem(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (!g_EventTarget)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_EventTarget->m_UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentSystemId(
    THIS_
    OUT PULONG Id
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Id = g_Target->m_UserId;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetCurrentSystemId(
    THIS_
    IN ULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (IS_RUNNING(g_CmdState))
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        TargetInfo* Target = FindTargetByUserId(Id);
        if (Target && Target == g_Target)
        {
            // Requested system is already current.
            Status = S_OK;
        }
        else if (Target)
        {
            ThreadInfo* Thread = NULL;
        
            //
            // Systems can exist without processes and threads
            // so allow such a system to be current even
            // if there is no process or thread.
            //
            if (Target->m_CurrentProcess == NULL)
            {
                Target->m_CurrentProcess = Target->m_ProcessHead;
            }
            if (Target->m_CurrentProcess)
            {
                if (Target->m_CurrentProcess->m_CurrentThread == NULL)
                {
                    Target->m_CurrentProcess->m_CurrentThread =
                        Target->m_CurrentProcess->m_ThreadHead;
                }
                Thread = Target->m_CurrentProcess->m_CurrentThread;
            }
            
            if (Thread)
            {
                Status = Target->SwitchToTarget(g_Target);
                if (Status == S_OK)
                {
                    SetCurrentThread(Thread, FALSE);
                    ResetCurrentScopeLazy();
                }
                else if (Status == S_FALSE)
                {
                    // The switch requires a wait.
                    Status = RawWaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
                }
            }
            else
            {
                SetLayersFromTarget(Target);
                // Notify that there is no current thread.
                NotifyChangeEngineState(DEBUG_CES_CURRENT_THREAD,
                                        DEBUG_ANY_ID, TRUE);
                Status = S_OK;
            }
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberSystems(
    THIS_
    OUT PULONG Number
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    *Number = g_NumberTargets;
    Status = S_OK;

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSystemIdsByIndex(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT /* size_is(Count) */ PULONG Ids
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    TargetInfo* Target;
    ULONG Index;

    if (Start >= g_NumberTargets ||
        Start + Count > g_NumberTargets)
    {
        Status = E_INVALIDARG;
        goto EH_Exit;
    }
    
    Index = 0;
    ForAllLayersToTarget()
    {
        if (Index >= Start && Index < Start + Count)
        {
            if (Ids != NULL)
            {
                *Ids++ = Target->m_UserId;
            }
        }

        Index++;
    }

    Status = S_OK;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTotalNumberThreadsAndProcesses(
    THIS_
    OUT PULONG TotalThreads,
    OUT PULONG TotalProcesses,
    OUT PULONG LargestProcessThreads,
    OUT PULONG LargestSystemThreads,
    OUT PULONG LargestSystemProcesses
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ULONG TotThreads = 0;
    ULONG TotProcs = 0;
    ULONG LargePt = 0;
    ULONG LargeSt = 0;
    ULONG LargeSp = 0;
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        TotThreads += Target->m_TotalNumberThreads;
        TotProcs += Target->m_NumProcesses;
        if (Target->m_MaxThreadsInProcess > LargePt)
        {
            LargePt = Target->m_MaxThreadsInProcess;
        }
        if (Target->m_TotalNumberThreads > LargeSt)
        {
            LargeSt = Target->m_TotalNumberThreads;
        }
        if (Target->m_NumProcesses > LargeSp)
        {
            LargeSp = Target->m_NumProcesses;
        }
    }

    *TotalThreads = TotThreads;
    *TotalProcesses = TotProcs;
    *LargestProcessThreads = LargePt;
    *LargestSystemThreads = LargeSt;
    *LargestSystemProcesses = LargeSp;

    Status = S_OK;

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentSystemServer(
    THIS_
    OUT PULONG64 Server
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Server = (!IS_LIVE_USER_TARGET(g_Target) ||
                   ((LiveUserTargetInfo*)g_Target)->m_Local) ?
            0 : (ULONG64)((LiveUserTargetInfo*)g_Target)->m_Services;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSystemByServer(
    THIS_
    IN ULONG64 Server,
    OUT PULONG Id
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        TargetInfo* Target = FindTargetByServer(Server);
        if (Target)
        {
            *Id = Target->m_UserId;
            Status = S_OK;
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetCurrentSystemServerName(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!g_Target)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        Status = g_Target->
            GetDescription(Buffer, BufferSize, NameSize);
    }

    LEAVE_ENGINE();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dotcmd.cpp ===
//----------------------------------------------------------------------------
//
// Dot command parsing.
//
// Copyright (C) Microsoft Corporation, 1990-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include <time.h>
#include <locale.h>
#include <dbgver.h>

#define CRASH_BUGCHECK_CODE 0xDEADDEAD

void
ParseSeparateCurrentProcess(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;
    ULONG Mode;
    char Desc[128];

    if (g_SymOptions & SYMOPT_SECURE)
    {
        error(NOTSECURE);
    }

    if (!strcmp(Cmd->Name, "abandon"))
    {
        Mode = SEP_ABANDON;
    }
    else if (!strcmp(Cmd->Name, "detach"))
    {
        Mode = SEP_DETACH;
    }
    else if (!strcmp(Cmd->Name, "kill"))
    {
        Mode = SEP_TERMINATE;
    }
    else
    {
        error(SYNTAX);
    }

    if (IS_DUMP_TARGET(g_Target))
    {
        // This will also cause the target to get cleaned
        // up as the system will release the only reference.
        dprintf("Closing dump file\n");
        g_Target->DebuggeeReset(DEBUG_SESSION_END, FALSE);
        delete g_Target;
        SetToAnyLayers(TRUE);
    }
    else if ((Status = SeparateCurrentProcess(Mode, Desc)) == S_OK)
    {
        dprintf("%s\n", Desc);
    }
    else if (Status == E_NOTIMPL)
    {
        dprintf("The system doesn't support %s\n", Cmd->Name);
    }
    else
    {
        dprintf("Unable to %s, %s\n",
                Cmd->Name, FormatStatusCode(Status));
    }
}

ULONG64
ParseConnectProcessServer(void)
{
    HRESULT Status;
    PSTR Srv;
    PUSER_DEBUG_SERVICES Services;
    CHAR Save;

    Srv = StringValue(STRV_SPACE_IS_SEPARATOR |
                      STRV_TRIM_TRAILING_SPACE, &Save);
    Status = DbgRpcConnectServer(Srv, &IID_IUserDebugServices,
                                 (IUnknown**)&Services);
    *g_CurCmd = Save;

    if (Status != S_OK)
    {
        ErrOut("Unable to connect to '%s', %s\n    \"%s\"\n",
               Srv, FormatStatusCode(Status),
               FormatStatus(Status));
        error(NOTFOUND);
    }

    return (ULONG_PTR)Services;
}

void
DotAttach(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;
    ULONG Pid;
    ULONG Flags = DEBUG_ATTACH_DEFAULT;
    ULONG64 Server = 0;

    if (g_SessionThread != GetCurrentThreadId())
    {
        error(BADTHREAD);
    }
    if (g_SymOptions & SYMOPT_SECURE)
    {
        error(NOTSECURE);
    }

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'b':
            Flags |= DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK;
            break;
        case 'e':
            Flags = DEBUG_ATTACH_EXISTING;
            break;
        case 'p':
            if (!strncmp(g_CurCmd, "premote", 7) && isspace(g_CurCmd[7]))
            {
                g_CurCmd += 7;
                Server = ParseConnectProcessServer();
            }
            else
            {
                error(SYNTAX);
            }
            break;
        case 'r':
            Flags |= DEBUG_ATTACH_INVASIVE_RESUME_PROCESS;
            break;
        case 'v':
            Flags = DEBUG_ATTACH_NONINVASIVE;
            if (g_CurCmd[1] == 'r')
            {
                g_CurCmd++;
                Flags |= DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND;
            }
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    Pid = (ULONG)GetExpression();

    PPENDING_PROCESS Pending;
    TargetInfo* Target;
    BOOL CreatedTarget;

    if ((Status = UserInitialize(Client, Server,
                                 &Target, &CreatedTarget)) == S_OK)
    {
        Status = Target->StartAttachProcess(Pid, Flags, &Pending);
        if (Status == S_OK)
        {
            dprintf("Attach will occur on next execution\n");
        }
        else if (CreatedTarget)
        {
            delete Target;
        }
    }
    else
    {
        ErrOut("Unable to initialize target, %s\n",
               FormatStatusCode(Status));
    }

    if (Server)
    {
        ((PUSER_DEBUG_SERVICES)(ULONG_PTR)Server)->Release();
    }
}

void
DotBpCmds(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Flags = 0;
    ProcessInfo* Process = g_Process;
    ULONG Id;

    while (PeekChar() == '-')
    {
        switch(*(++g_CurCmd))
        {
        case '1':
            Flags |= BPCMDS_ONE_LINE;
            break;
        case 'd':
            Flags |= BPCMDS_FORCE_DISABLE;
            break;
        case 'e':
            Flags |= BPCMDS_EXPR_ONLY;
            break;
        case 'm':
            Flags |= BPCMDS_MODULE_HINT;
            break;
        case 'p':
            g_CurCmd++;
            Id = (ULONG)GetTermExpression("Process ID missing from");
            Process = FindAnyProcessByUserId(Id);
            g_CurCmd--;
            break;
        default:
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    if (!Process)
    {
        error(BADPROCESS);
    }

    ListBreakpointsAsCommands(Client, Process, Flags);
}

void
DotBpSync(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() && *g_CurCmd != ';')
    {
        if (GetExpression())
        {
            g_EngOptions |= DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS;
        }
        else
        {
            g_EngOptions &= ~DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS;
        }
    }

    dprintf("Breakpoint synchronization %s\n",
            (g_EngOptions & DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS) ?
            "enabled" : "disabled");
}

void
DotBreakin(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
    {
        ErrOut(".breakin not supported on this platform\n");
        return;
    }

    if (g_Target && g_Target->m_SystemVersion <= NT_SVER_NT4)
    {
        // SysDbgBreakPoint isn't supported, so
        // try to use user32's PrivateKDBreakPoint.
        if (InitDynamicCalls(&g_User32CallsDesc) == S_OK &&
            g_User32Calls.PrivateKDBreakPoint != NULL)
        {
            g_User32Calls.PrivateKDBreakPoint();
        }
        else
        {
            ErrOut(".breakin is not supported on this system\n");
        }
    }
    else
    {
        NTSTATUS NtStatus;

        NtStatus = g_NtDllCalls.NtSystemDebugControl
            (SysDbgBreakPoint, NULL, 0, NULL, 0, NULL);
        if (NtStatus == STATUS_ACCESS_DENIED)
        {
            ErrOut(".breakin requires debug privilege\n");
        }
        else if (NtStatus == STATUS_INVALID_INFO_CLASS)
        {
            ErrOut(".breakin is not supported on this system\n");
        }
        else if (!NT_SUCCESS(NtStatus))
        {
            ErrOut(".breakin failed, 0x%X\n", NtStatus);
        }
    }
}

void
DotBugCheck(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Code;
    ULONG64 Args[4];

    if (g_Target->ReadBugCheckData(&Code, Args) == S_OK)
    {
        dprintf("Bugcheck code %08X\n", Code);
        dprintf("Arguments %s %s %s %s\n",
                FormatAddr64(Args[0]), FormatAddr64(Args[1]),
                FormatAddr64(Args[2]), FormatAddr64(Args[3]));
    }
    else
    {
        dprintf("Unable to read bugcheck data\n");
    }
}

void
DotCache(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (IS_REMOTE_KERNEL_TARGET(g_Target) ||
        (IS_LIVE_USER_TARGET(g_Target) &&
         !((LiveUserTargetInfo*)g_Target)->m_Local))
    {
        if (!g_Process)
        {
            error(BADPROCESS);
        }

        g_Process->m_VirtualCache.ParseCommands();
    }
    else
    {
        error(SESSIONNOTSUP);
    }
}

void
DotChain(PDOT_COMMAND Cmd, DebugClient* Client)
{
    OutputExtensions(Client, FALSE);
}

void
DotChildDbg(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!IS_LIVE_USER_TARGET(g_Target))
    {
        error(SESSIONNOTSUP);
    }
    if (g_Process == NULL)
    {
        error(BADTHREAD);
    }

    HRESULT Status;
    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)g_Target)->m_Services;
    ULONG Opts;

    Opts = g_Process->m_Options;

    if (PeekChar() && *g_CurCmd != ';')
    {
        ULONG64 Val = GetExpression();
        if (Val)
        {
            Opts &= ~DEBUG_PROCESS_ONLY_THIS_PROCESS;
        }
        else
        {
            Opts |= DEBUG_PROCESS_ONLY_THIS_PROCESS;
        }

        if ((Status = Services->SetProcessOptions(g_Process->m_SysHandle,
                                                  Opts)) != S_OK)
        {
            if (Status == E_NOTIMPL)
            {
                ErrOut("The system doesn't support changing the flag\n");
            }
            else
            {
                ErrOut("Unable to set process options, %s\n",
                       FormatStatusCode(Status));
            }
            return;
        }

        g_Process->m_Options = Opts;
    }

    dprintf("Processes created by the current process will%s be debugged\n",
            (Opts & DEBUG_PROCESS_ONLY_THIS_PROCESS) ? " not" : "");
}

void
DotClients(PDOT_COMMAND Cmd, DebugClient* Client)
{
    DebugClient* Cur;

    for (Cur = g_Clients; Cur != NULL; Cur = Cur->m_Next)
    {
        if (Cur->m_Flags & CLIENT_PRIMARY)
        {
            dprintf("%s, last active %s",
                    Cur->m_Identity, ctime(&Cur->m_LastActivity));
        }
    }
}

void
DotCloseHandle(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;
    BOOL All = FALSE;
    ULONG64 Handle;
    ULONG64 Dup;
    ULONG HandleCount;

    if (!g_Process)
    {
        error(BADPROCESS);
    }
    if (!IS_LIVE_USER_TARGET(g_Target))
    {
        error(SESSIONNOTSUP);
    }

    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)g_Target)->m_Services;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'a':
            g_CurCmd++;
            All = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            g_CurCmd++;
            break;
        }
    }

    if (!All)
    {
        Handle = GetExpression();

        if ((Status = Services->
             DuplicateHandle(g_Process->m_SysHandle, Handle,
                             SERVICE_HANDLE(GetCurrentProcess()), 0, FALSE,
                             DUPLICATE_CLOSE_SOURCE |
                             DUPLICATE_SAME_ACCESS, &Dup)) == S_OK)
        {
            dprintf("Closed %x\n", (ULONG)Handle);
        }
        else
        {
            ErrOut("Possibly closed %x, %s\n",
                   (ULONG)Handle, FormatStatusCode(Status));
        }

        return;
    }

    if (Services->
        ReadHandleData(g_Process->m_SysHandle, 0,
                       DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT,
                       &HandleCount, sizeof(HandleCount), NULL) != S_OK)
    {
        ErrOut("Unable to get handle count\n");
        return;
    }

    dprintf("0x%x handles to scan for...\n", HandleCount);

    Handle = 4;
    while (HandleCount)
    {
        if (CheckUserInterrupt())
        {
            WarnOut("-- Interrupted\n");
            break;
        }

        if ((Status = Services->
             DuplicateHandle(g_Process->m_SysHandle, Handle,
                             SERVICE_HANDLE(GetCurrentProcess()), 0, FALSE,
                             DUPLICATE_CLOSE_SOURCE |
                             DUPLICATE_SAME_ACCESS, &Dup)) == S_OK)
        {
            dprintf("  closed %x, 0x%x remaining\n",
                    (ULONG)Handle, --HandleCount);
        }

        Handle += 4;
    }
}

void
DotContext(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!g_Machine)
    {
        error(BADTHREAD);
    }

    if (PeekChar() && *g_CurCmd != ';')
    {
        ULONG64 Base = GetExpression();
        ULONG NextIdx;

        if (g_Machine->SetPageDirectory(g_Thread, PAGE_DIR_USER, Base,
                                        &NextIdx) != S_OK)
        {
            WarnOut("WARNING: Unable to reset page directory base\n");
        }

        // Flush the cache as anything we read from user mode is
        // no longer valid
        g_Process->m_VirtualCache.Empty();

        if (Base && !g_Process->m_VirtualCache.m_ForceDecodePTEs &&
            IS_REMOTE_KERNEL_TARGET(g_Target))
        {
            WarnOut("WARNING: "
                    ".cache forcedecodeptes is not enabled\n");
        }
    }
    else
    {
        dprintf("User-mode page directory base is %I64x\n",
                g_Machine->m_PageDirectories[PAGE_DIR_USER]);
    }
}

void
DotCorStack(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() && *g_CurCmd != ';')
    {
        while (PeekChar() == '-' || *g_CurCmd == '/')
        {
            switch(*++g_CurCmd)
            {
            case 'd':
                g_DebugCorStack = !g_DebugCorStack;
                g_CurCmd++;
                break;
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                g_CurCmd++;
                break;
            }
        }

        g_AllowCorStack = GetExpression() != 0;
    }

    dprintf("COR-assisted stack walking %s\n",
            g_AllowCorStack ? "enabled" : "disabled");
}

void
DotCrash(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar())
    {
        error(SYNTAX);
    }

    g_LastCommand[0] = '\0';
    g_Target->Crash(CRASH_BUGCHECK_CODE);
    // Go back to waiting for a state change to
    // receive the bugcheck exception.
    g_CmdState = 'e';
    NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                            DEBUG_STATUS_GO, TRUE);
}

void
DotCreate(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;
    PPENDING_PROCESS Pending;
    PSTR CmdLine;
    PWSTR CmdLineW;
    CHAR Save;
    ULONG64 Server = 0;

    if (g_SessionThread != GetCurrentThreadId())
    {
        error(BADTHREAD);
    }
    if (g_SymOptions & SYMOPT_SECURE)
    {
        error(NOTSECURE);
    }

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'p':
            if (!strncmp(g_CurCmd, "premote", 7) && isspace(g_CurCmd[7]))
            {
                g_CurCmd += 7;
                Server = ParseConnectProcessServer();
            }
            else
            {
                error(SYNTAX);
            }
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    CmdLine = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
    if (AnsiToWide(CmdLine, &CmdLineW) != S_OK)
    {
        ErrOut("Out of memory\n");
    }
    else
    {
        TargetInfo* Target;
        BOOL CreatedTarget;

        if ((Status = UserInitialize(Client, Server,
                                     &Target, &CreatedTarget)) == S_OK)
        {
            Status = Target->
                StartCreateProcess(CmdLineW, DEBUG_ONLY_THIS_PROCESS,
                                   NULL, NULL, &Pending);
            if (Status == S_OK)
            {
                dprintf("Create will proceed with next execution\n");
            }
            else if (CreatedTarget)
            {
                delete Target;
            }
        }
        else
        {
            ErrOut("Unable to initialize target, %s\n",
                   FormatStatusCode(Status));
        }

        FreeWide(CmdLineW);
    }

    if (Server)
    {
        ((PUSER_DEBUG_SERVICES)(ULONG_PTR)Server)->Release();
    }

    *g_CurCmd = Save;
}

void
DotCreateDir(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PSTR Str;
    char Save;

    if (PeekChar() && *g_CurCmd != ';')
    {
        PWSTR NewStr;

        Str = StringValue(STRV_TRIM_TRAILING_SPACE |
                          STRV_ALLOW_EMPTY_STRING, &Save);
        if (!*Str)
        {
            if (g_StartProcessDir)
            {
                FreeWide(g_StartProcessDir);
            }
            g_StartProcessDir = NULL;
        }
        else if (AnsiToWide(Str, &NewStr) != S_OK)
        {
            ErrOut("Out of memory\n");
        }
        else
        {
            if (g_StartProcessDir)
            {
                FreeWide(g_StartProcessDir);
            }
            g_StartProcessDir = NewStr;
        }
    }

    dprintf("Process creation dir: %ws\n",
            g_StartProcessDir ? g_StartProcessDir : L"<default>");
}

void
DotCxr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Flags = 0;
    ULONG64 ContextBase = 0;

    if (!g_Machine)
    {
        error(BADTHREAD);
    }

    if (PeekChar() && *g_CurCmd != ';')
    {
        ContextBase = GetExpression();
    }

    if (ContextBase)
    {
        SetAndOutputVirtualContext(ContextBase,
                                   REGALL_INT32 | REGALL_INT64 |
                                   (g_Machine->m_ExecTypes[0] ==
                                    IMAGE_FILE_MACHINE_I386 ?
                                    REGALL_EXTRA0 : 0));
    }
    else if (GetCurrentScopeContext())
    {
        dprintf("Resetting default context\n");
        ResetCurrentScope();
    }
}

void
DotDrivers(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PCSTR ArgsRet;

    g_Target->Reload(g_Thread, "-l", &ArgsRet);
}

void
DotDumpCab(PDOT_COMMAND Cmd, DebugClient* Client)
{
    char Save;
    PCSTR CabName;
    ULONG Flags = DEBUG_FORMAT_WRITE_CAB;

    if (!IS_DUMP_TARGET(g_Target))
    {
        error(TARGETNOTSUP);
    }

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'a':
            Flags |= DEBUG_FORMAT_CAB_SECONDARY_FILES;
            g_CurCmd++;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            g_CurCmd++;
            break;
        }
    }

    CabName = StringValue(STRV_TRIM_TRAILING_SPACE |
                          STRV_ESCAPED_CHARACTERS, &Save);
    CreateCabFromDump(NULL, CabName, Flags);
}

void
DotDumpDebug(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ((DumpTargetInfo *)g_Target)->DumpDebug();
}

void
DotDumpOff(PDOT_COMMAND Cmd, DebugClient* Client)
{
    //
    // Show the file offset for a VA.
    //

    ULONG64 Addr = GetExpression();
    ULONG64 Offs;
    ULONG File;
    ULONG Avail;

    Offs = ((DumpTargetInfo*)g_Target)->
        VirtualToOffset(Addr, &File, &Avail);
    dprintf("Virtual %s maps to file %d offset %I64x\n",
            FormatAddr64(Addr), File, Offs);
}

void
DotDumpPOff(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (IS_KERNEL_SUMMARY_DUMP(g_Target) || IS_KERNEL_FULL_DUMP(g_Target))
    {
        //
        // Show the file offset for a physical address.
        //

        ULONG64 Addr = GetExpression();
        ULONG Avail;

        dprintf("Physical %I64x maps to file offset %I64x\n",
                Addr, ((KernelFullSumDumpTargetInfo *)g_Target)->
                PhysicalToOffset(Addr, TRUE, &Avail));
    }
    else
    {
        error(SESSIONNOTSUP);
    }
}

void
DotEcho(PDOT_COMMAND Cmd, DebugClient* Client)
{
    CHAR Save;
    PSTR Str;

    Str = StringValue(STRV_TRIM_TRAILING_SPACE |
                      STRV_ALLOW_EMPTY_STRING, &Save);
    dprintf("%s\n", Str);
    *g_CurCmd = Save;
}

void
DotEchoTimestamps(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_EchoEventTimestamps = !g_EchoEventTimestamps;
    dprintf("Event timestamps are now %s\n",
            g_EchoEventTimestamps ? "enabled" : "disabled");
}

void
DotEcxr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    CROSS_PLATFORM_CONTEXT Context;
    HRESULT Status;

    Status = E_UNEXPECTED;
    if (!g_Target || !g_Machine ||
        (Status = g_Target->GetExceptionContext(&Context)) != S_OK)
    {
        ErrOut("Unable to get exception context, 0x%X\n", Status);
    }
    else
    {
        SetAndOutputContext(&Context, FALSE, REGALL_INT32 | REGALL_INT64 |
                            (g_Machine->
                             m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 ?
                             REGALL_EXTRA0 : 0));
    }
}

void
DotEffMach(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() != ';' && *g_CurCmd)
    {
        PSTR Name = g_CurCmd;

        while (*g_CurCmd && *g_CurCmd != ';' && !isspace(*g_CurCmd))
        {
            g_CurCmd++;
        }
        if (*g_CurCmd)
        {
            *g_CurCmd++ = 0;
        }

        ULONG Machine;

        if (Name[0] == '.' && Name[1] == 0)
        {
            // Reset to target machine.
            Machine = g_Target->m_MachineType;
        }
        else if (Name[0] == '#' && Name[1] == 0)
        {
            // Reset to executing machine.
            Machine = g_EventMachine->m_ExecTypes[0];
        }
        else
        {
            for (Machine = 0; Machine < MACHIDX_COUNT; Machine++)
            {
                if (!_strcmpi(Name,
                              g_Target->m_Machines[Machine]->m_AbbrevName))
                {
                    break;
                }
            }

            if (Machine >= MACHIDX_COUNT)
            {
                ErrOut("Unknown machine '%s'\n", Name);
                return;
            }

            Machine = g_Target->m_Machines[Machine]->m_ExecTypes[0];
        }

        g_Target->SetEffMachine(Machine, TRUE);
        g_Machine = g_Target->m_EffMachine;
    }

    if (g_Machine != NULL)
    {
        dprintf("Effective machine: %s (%s)\n",
                g_Machine->m_FullName, g_Machine->m_AbbrevName);
    }
    else
    {
        dprintf("No effective machine\n");
    }
}

void
DotEnableLongStatus(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_EnableLongStatus = (BOOL)GetExpression();
    if (g_EnableLongStatus)
    {
        g_TypeOptions |= DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY;
    }
    else
    {
        g_TypeOptions &= ~DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY;
    }
    // Callback to update locals and watch window
    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
}

void
DotEnableUnicode(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_EnableUnicode = (BOOL)GetExpression();
    if (g_EnableUnicode)
    {
        g_TypeOptions |= DEBUG_TYPEOPTS_UNICODE_DISPLAY;
    }
    else
    {
        g_TypeOptions &= ~DEBUG_TYPEOPTS_UNICODE_DISPLAY;
    }
    // Callback to update locals and watch window
    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
}


void
DotForceRadixOutput(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_PrintDefaultRadix = (BOOL) GetExpression();
    if (g_PrintDefaultRadix)
    {
        g_TypeOptions |=  DEBUG_TYPEOPTS_FORCERADIX_OUTPUT;
    }
    else
    {
        g_TypeOptions &= ~DEBUG_TYPEOPTS_FORCERADIX_OUTPUT;
    }
    // Callback to update locals and watch window
    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
}

void
DotEndSrv(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (DbgRpcDisableServer((ULONG)GetExpression()) == S_OK)
    {
        dprintf("Server told to exit.  Actual exit may be delayed until\n"
                "the next connection attempt.\n");
    }
    else
    {
        ErrOut("No such server\n");
    }
}

void
DotEndPSrv(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (IS_LIVE_USER_TARGET(g_Target) &&
        !((LiveUserTargetInfo*)g_Target)->m_Local)
    {
        ((LiveUserTargetInfo*)g_Target)->m_Services->Uninitialize(TRUE);
        dprintf("Server told to exit\n");
    }
    else
    {
        error(SESSIONNOTSUP);
    }
}

void
DotEnumTag(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;
    ULONG64 Handle;

    if ((Status = Client->StartEnumTagged(&Handle)) != S_OK)
    {
        ErrOut("Unable to start enumeration, %s\n",
               FormatStatusCode(Status));
        return;
    }

    GUID Tag;
    ULONG Size;
    UCHAR Buffer[16];
    ULONG Total;
    ULONG Left;
    ULONG Offs;

    while (Client->GetNextTagged(Handle, &Tag, &Size) == S_OK)
    {
        if (CheckUserInterrupt())
        {
            dprintf("-- Interrupted\n");
            break;
        }

        dprintf("{%08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X} "
                "- 0x%x bytes\n",
                Tag.Data1, Tag.Data2, Tag.Data3,
                Tag.Data4[0], Tag.Data4[1], Tag.Data4[2],
                Tag.Data4[3], Tag.Data4[4], Tag.Data4[5],
                Tag.Data4[6], Tag.Data4[7], Size);

        Offs = 0;
        Left = Size;

        while (Left > 0)
        {
            ULONG Req;

            if (Left > sizeof(Buffer))
            {
                Req = sizeof(Buffer);
            }
            else
            {
                Req = Left;
            }

            if (Client->ReadTagged(&Tag, Offs, Buffer, Req, &Total) != S_OK)
            {
                ErrOut("  Unable to read data\n");
                break;
            }

            ULONG i;

            dprintf(" ");

            for (i = 0; i < Req; i++)
            {
                dprintf(" %02X", Buffer[i]);
            }
            while (i < sizeof(Buffer))
            {
                dprintf("   ");
                i++;
            }

            dprintf("  ");

            for (i = 0; i < Req; i++)
            {
                dprintf("%c", isprint(Buffer[i]) ? Buffer[i] : '.');
            }

            dprintf("\n");

            Offs += Req;
            Left -= Req;
        }
    }

    Client->EndEnumTagged(Handle);
}

void
DotEvents(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;

    if (PeekChar() && *g_CurCmd != ';')
    {
        ULONG Relation = DEBUG_EINDEX_FROM_CURRENT;
        ULONG Index = 1;

        while (PeekChar() == '-' || *g_CurCmd == '/')
        {
            switch(*++g_CurCmd)
            {
            case '-':
                g_CurCmd++;
                Relation = DEBUG_EINDEX_FROM_CURRENT;
                Index = -(LONG)GetExpression();
                break;
            case '+':
                g_CurCmd++;
                Relation = DEBUG_EINDEX_FROM_CURRENT;
                Index = (ULONG)GetExpression();
                break;
            case 'e':
                g_CurCmd++;
                Relation = DEBUG_EINDEX_FROM_END;
                Index = (ULONG)GetExpression();
                break;
            case 's':
                g_CurCmd++;
                Relation = DEBUG_EINDEX_FROM_START;
                Index = (ULONG)GetExpression();
                break;
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                g_CurCmd++;
                break;
            }
        }

        if ((Status = Client->
             SetNextEventIndex(Relation, Index, &Index)) != S_OK)
        {
            ErrOut("Unable to set next event index, %s\n",
                   FormatStatusCode(Status));
        }
        else
        {
            dprintf("Next event index will be %d\n", Index);
        }
    }
    else
    {
        ULONG Num, Cur;

        if (FAILED(Status = Client->GetNumberEvents(&Num)) ||
            (Status = Client->GetCurrentEventIndex(&Cur)) != S_OK)
        {
            dprintf("Unable to get event information, %s\n",
                    FormatStatusCode(Status));
        }
        else
        {
            for (ULONG i = 0; i < Num; i++)
            {
                char Name[64];

                if (FAILED(Client->
                           GetEventIndexDescription(i, DEBUG_EINDEX_NAME,
                                                    Name, sizeof(Name), NULL)))
                {
                    strcpy(Name, "<Error>");
                }

                dprintf("%c%2d - %s\n",
                        i == Cur ? '.' : ' ', i, Name);
            }
        }
    }
}

void
DotEventStr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!g_EventThread ||
        !g_EventThread->m_EventStrings)
    {
        ErrOut("No event strings\n");
    }
    else
    {
        g_EventThread->OutputEventStrings();
    }
}

void
DotExePath(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar())
    {
        if (ChangePath(&g_ExecutableImageSearchPath,
                       g_CurCmd, Cmd->Name[7] == '+',
                       DEBUG_CSS_PATHS) != S_OK)
        {
            // This command uses the whole string.
            *g_CurCmd = 0;
            return;
        }

        *g_CurCmd = 0;
    }

    if (g_ExecutableImageSearchPath == NULL)
    {
        dprintf("No exectutable image search path\n");
    }
    else
    {
        dprintf("Executable image search path is: %s\n",
                g_ExecutableImageSearchPath);
        CheckPath(g_ExecutableImageSearchPath);
    }
}

void
DotExpr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() && *g_CurCmd != ';')
    {
        ULONG i;
        char Save;
        PCSTR Name;

        while (PeekChar() == '-' || *g_CurCmd == '/')
        {
            switch(*++g_CurCmd)
            {
            case 'q':
                g_CurCmd++;
                dprintf("Available expression evaluators:\n");
                for (i = 0; i < EVAL_COUNT; i++)
                {
                    EvalExpression* Eval = GetEvaluator(i, FALSE);
                    dprintf("%s - %s\n",
                            Eval->m_AbbrevName,
                            Eval->m_FullName);
                    ReleaseEvaluator(Eval);
                }
                dprintf("\n");
                break;
            case 's':
                g_CurCmd++;
                Name = StringValue(STRV_SPACE_IS_SEPARATOR, &Save);
                if (SetExprSyntaxByName(Name) != S_OK)
                {
                    dprintf("No evaluator named '%s'\n", Name);
                }
                *g_CurCmd = Save;
                break;
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                g_CurCmd++;
                break;
            }
        }
    }

    EvalExpression* Eval = GetCurEvaluator();
    dprintf("Current expression evaluator: %s - %s\n",
            Eval->m_AbbrevName, Eval->m_FullName);
    ReleaseEvaluator(Eval);
}

void
DotExr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 ExrAddress = GetExpression();
    ULONG i;
    char Buffer[256];
    ULONG64 Displacement;
    EXCEPTION_RECORD64 Exr64;
    EXCEPTION_RECORD32 Exr32;
    EXCEPTION_RECORD64 *Exr = &Exr64;
    HRESULT Status = S_OK;
    EVENT_FILTER* Filter;

    if (ExrAddress == (ULONG64) -1)
    {
        if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
        {
            Exr64 = g_LastEventInfo.Exception.ExceptionRecord;
        }
        else
        {
            ErrOut("Last event was not an exception\n");
            return;
        }
    }
    else if (g_Target->m_Machine->m_Ptr64)
    {
        Status = CurReadAllVirtual(ExrAddress, &Exr64, sizeof(Exr64));
    }
    else
    {
        Status = CurReadAllVirtual(ExrAddress, &Exr32, sizeof(Exr32));
        ExceptionRecord32To64(&Exr32, &Exr64);
    }
    if (Status != S_OK)
    {
        dprintf64("Cannot read Exception record @ %p\n", ExrAddress);
        return;
    }

    GetSymbol(Exr->ExceptionAddress, &Buffer[0], DIMA(Buffer),
              &Displacement);

    if (*Buffer)
    {
        dprintf64("ExceptionAddress: %p (%s",
                  Exr->ExceptionAddress,
                  Buffer);
        if (Displacement)
        {
            dprintf64("+0x%p)\n", Displacement);
        }
        else
        {
            dprintf64(")\n");
        }
    }
    else
    {
        dprintf64("ExceptionAddress: %p\n", Exr->ExceptionAddress);
    }
    dprintf("   ExceptionCode: %08lx", Exr->ExceptionCode);
    Filter = GetSpecificExceptionFilter(Exr->ExceptionCode);
    if (Filter)
    {
        dprintf(" (%s)\n", Filter->Name);
    }
    else
    {
        dprintf("\n");
    }
    dprintf("  ExceptionFlags: %08lx\n", Exr->ExceptionFlags);

    dprintf("NumberParameters: %d\n", Exr->NumberParameters);
    if (Exr->NumberParameters > EXCEPTION_MAXIMUM_PARAMETERS)
    {
        Exr->NumberParameters = EXCEPTION_MAXIMUM_PARAMETERS;
    }
    for (i = 0; i < Exr->NumberParameters; i++)
    {
        dprintf64("   Parameter[%d]: %p\n", i, Exr->ExceptionInformation[i]);
    }

    //
    // Known Exception processing:
    //

    switch(Exr->ExceptionCode)
    {
    case STATUS_ACCESS_VIOLATION:
        if (Exr->NumberParameters == 2)
        {
            dprintf64("Attempt to %s address %p\n",
                      (Exr->ExceptionInformation[0] ?
                       "write to" : "read from"),
                      Exr->ExceptionInformation[1]);
        }
        break;

    case STATUS_IN_PAGE_ERROR:
        if (Exr->NumberParameters == 3)
        {
            dprintf64("Inpage operation failed at %p, due to I/O error %p\n",
                      Exr->ExceptionInformation[1],
                      Exr->ExceptionInformation[2]);
        }
        break;

    case STATUS_INVALID_HANDLE:
    case STATUS_HANDLE_NOT_CLOSABLE:
        dprintf64("Thread tried to close a handle that was "
                  "invalid or illegal to close\n");
        break;

    case STATUS_POSSIBLE_DEADLOCK:
        if (Exr->NumberParameters == 1)
        {
            RTL_CRITICAL_SECTION64 CritSec64;
            RTL_CRITICAL_SECTION32 CritSec32;

            GetSymbol(Exr->ExceptionInformation[0],
                      Buffer, DIMA(Buffer), &Displacement);
            if (*Buffer)
            {
                dprintf64("Critical section at %p (%s+%p)",
                          Exr->ExceptionInformation[0],
                          Buffer,
                          Displacement);
            }
            else
            {
                dprintf64("Critical section at %p",
                          Exr->ExceptionInformation[0]);
            }

            if (g_Target->m_Machine->m_Ptr64)
            {
                Status = CurReadAllVirtual(Exr->ExceptionInformation[0],
                                           &CritSec64, sizeof(CritSec64));
            }
            else
            {
                Status = CurReadAllVirtual(Exr->ExceptionInformation[0],
                                           &CritSec32, sizeof(CritSec32));
                if (Status == S_OK)
                {
                    CritSec64.OwningThread = CritSec32.OwningThread;
                }
            }
            if (Status == S_OK)
            {
                dprintf64("is owned by thread %p,\n"
                          "causing this thread to raise an exception",
                          CritSec64.OwningThread);
            }

            dprintf("\n");
        }
        break;
    }
}

void
DotFnEnt(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        error(BADTHREAD);
    }

    BOOL SymDirect = FALSE;

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 's':
            SymDirect = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    ULONG64 Addr = GetExpression();
    PVOID FnEnt;

    if (SymDirect)
    {
        FnEnt = SymFunctionTableAccess64(g_Process->m_SymHandle, Addr);
    }
    else
    {
        FnEnt = SwFunctionTableAccess(g_Process->m_SymHandle, Addr);
    }
    if (FnEnt == NULL)
    {
        ErrOut("No function entry for %s\n", FormatAddr64(Addr));
        return;
    }

    dprintf("%s function entry %s for:\n",
            SymDirect ? "Symbol" : "Debugger", FormatAddr64((ULONG_PTR)FnEnt));
    ListNearSymbols(Addr);
    dprintf("\n");
    g_Machine->OutputFunctionEntry(FnEnt);
}

void
DotFormats(PDOT_COMMAND Cmd, DebugClient* Client)
{
    LONG64 Value;
    LONG Val32;
    BOOL Use64;
    // If this command is really .formats then display
    // everything, otherwise just display the basic
    // expression result for ?.
    BOOL Verbose = Cmd != NULL;

    Value = GetExpression();

    // Allow 64-bit expressions to be evaluated even on
    // 32-bit platforms since they can also use 64-bit numbers.
    Use64 = NeedUpper(Value) || !g_Machine || g_Machine->m_Ptr64;
    Val32 = (LONG)Value;

    if (!Verbose)
    {
        if (Use64)
        {
            dprintf("Evaluate expression: %I64d = %08x`%08x\n",
                    Value, (ULONG)(Value >> 32), Val32);
        }
        else
        {
            dprintf("Evaluate expression: %d = %08x\n",
                    Val32, Val32);
        }
    }
    else
    {
        dprintf("Evaluate expression:\n");
        if (Use64)
        {
            dprintf("  Hex:     %08x`%08x\n", (ULONG)(Value >> 32), Val32);
            dprintf("  Decimal: %I64d\n", Value);
        }
        else
        {
            dprintf("  Hex:     %08x\n", Val32);
            dprintf("  Decimal: %d\n", Val32);
        }

        ULONG Shift = Use64 ? 63 : 30;
        dprintf("  Octal:   ");
        for (;;)
        {
            dprintf("%c", ((Value >> Shift) & 7) + '0');
            if (Shift == 0)
            {
                break;
            }
            Shift -= 3;
        }
        dprintf("\n");

        Shift = Use64 ? 63 : 31;
        dprintf("  Binary: ");
        for (;;)
        {
            if ((Shift & 7) == 7)
            {
                dprintf(" ");
            }

            dprintf("%c", ((Value >> Shift) & 1) + '0');
            if (Shift == 0)
            {
                break;
            }
            Shift--;
        }
        dprintf("\n");

        Shift = Use64 ? 56 : 24;
        dprintf("  Chars:   ");
        for (;;)
        {
            Val32 = (LONG)((Value >> Shift) & 0xff);
            if (Val32 >= ' ' && Val32 <= 127)
            {
                dprintf("%c", Val32);
            }
            else
            {
                dprintf(".");
            }
            if (Shift == 0)
            {
                break;
            }
            Shift -= 8;
        }
        Val32 = (LONG)Value;
        dprintf("\n");

        dprintf("  Time:    %s\n", Use64 ? LONG64FileTimeToStr(Value) : TimeToStr(Val32) );

        dprintf("  Float:   low %hg high %hg\n",
                *(float*)&Value, *((float*)&Value + 1));
        dprintf("  Double:  %g\n", *(double*)&Value);
    }
}

void
DotFrame(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PDEBUG_STACK_FRAME StackFrame;
    ULONG Traced = 0, Frame = 0;

    if (PeekChar())
    {
        Frame = (ULONG) GetExpression();
        StackFrame = (PDEBUG_STACK_FRAME)
            malloc(sizeof(DEBUG_STACK_FRAME) * (Frame + 1));
        if (!StackFrame)
        {
            error(NOMEMORY);
        }

        Traced = StackTrace(Client, 0, 0, 0, STACK_ALL_DEFAULT,
                            StackFrame, Frame + 1, 0, 0, FALSE);
        if (Traced <= Frame)
        {
            ErrOut("Cannot find frame 0x%lx, previous scope unchanged\n",
                   Frame);
            return;
        }

        // Do not change the previous context
        SetCurrentScope(&StackFrame[Frame], NULL, 0);
    }

    PrintStackFrame(&GetCurrentScope()->Frame, NULL,
                    DEBUG_STACK_FRAME_ADDRESSES |
                    DEBUG_STACK_FRAME_NUMBERS |
                    DEBUG_STACK_SOURCE_LINE);
}

BOOL
CALLBACK
GetFirstLocalOffset(PSYMBOL_INFO SymInfo,
                    ULONG        Size,
                    PVOID        Context)
{
    PULONG Offset = (PULONG) Context;

    if (SymInfo->Flags & SYMFLAG_REGREL)
    {
        *Offset = (ULONG)SymInfo->Address;
    }
    else
    {
        *Offset = 0;
        return TRUE;
    }

    return FALSE;
}

void
DotFrameEbpFix(PDOT_COMMAND Cmd, DebugClient* Client)
{
    //
    // This adjusts the SAVED_EBP value in stackframe by
    // looking at parameter's offset and actual address. Using
    // these it back-caclulates what ebp value could be right for the frame.
    //

    if (g_Machine->m_ExecTypes[0] != IMAGE_FILE_MACHINE_I386)
    {
        error(SESSIONNOTSUP);
    }

    if (!g_ScopeBuffer.Frame.FuncTableEntry)
    {
        // No need to do this for NON-FPO calls.
        goto Show;
    }
    if (((PFPO_DATA)g_ScopeBuffer.Frame.FuncTableEntry)->cdwParams == 0)
    {
        // We cannot do this for calls without any parameters.
        ErrOut("Parameters required\n");
        return;
    }

    IMAGEHLP_SYMBOL64 ImgSym;
    ULONG Param1Offset;
    ULONG64 Displacement;

    ImgSym.MaxNameLength = 1;

    if (g_ScopeBuffer.Frame.InstructionOffset &&
        SymGetSymFromAddr64(g_Process->m_SymHandle,
                            g_ScopeBuffer.Frame.InstructionOffset,
                            &Displacement,
                            &ImgSym))
    {
        IMAGEHLP_STACK_FRAME StackFrame;

        // SetCurrentScope to this function address, not the return address
        // since we only want to enumerate the parameters
        g_EngNotify++;
        StackFrame.InstructionOffset = ImgSym.Address;
        SymSetContext(g_Process->m_SymHandle,&StackFrame, NULL);

        // Enumerate locals and save the offset for first one
        EnumerateLocals(GetFirstLocalOffset, &Param1Offset);

        if (Param1Offset)
        {
             // Params start after 2 dwords from farame offset
            SAVE_EBP(&g_ScopeBuffer.Frame) =
                ((ULONG) g_ScopeBuffer.Frame.FrameOffset + 2*sizeof(DWORD) -
                 Param1Offset) + 0xEB00000000; // EBP tag
        }

        // Reset the scope back to original
        SymSetContext(g_Process->m_SymHandle,
                      (PIMAGEHLP_STACK_FRAME)&g_ScopeBuffer.Frame, NULL);
        g_EngNotify--;
    }

 Show:
    PrintStackFrame(&GetCurrentScope()->Frame, NULL,
                    DEBUG_STACK_FRAME_ADDRESSES |
                    DEBUG_STACK_FRAME_NUMBERS |
                    DEBUG_STACK_SOURCE_LINE);
}

void
DotImgScan(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 Handle = 0;
    MEMORY_BASIC_INFORMATION64 Info;
    BOOL Verbose = FALSE;
    BOOL AllRegions = TRUE;
    BOOL ReloadIfPossible = FALSE;
    ADDR Start;
    ULONG64 Length;

    //
    // Scan virtual memory looking for image headers.
    //

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'l':
            g_CurCmd++;
            ReloadIfPossible = TRUE;
            break;
        case 'r':
            g_CurCmd++;
            Length = 0x10000;
            GetRange(&Start, &Length, 1, SEGREG_DATA,
                     0x7fffffff);
            AllRegions = FALSE;
            Info.BaseAddress = Flat(Start);
            Info.RegionSize = Length;
            break;
        case 'v':
            g_CurCmd++;
            Verbose = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            g_CurCmd++;
            break;
        }
    }

    while ((AllRegions && g_Target->
            QueryMemoryRegion(g_Process, &Handle, FALSE, &Info) == S_OK) ||
           (!AllRegions && Info.RegionSize))
    {
        ULONG64 Addr;

        if (Verbose)
        {
            dprintf("*** Checking %s - %s\n",
                    FormatAddr64(Info.BaseAddress),
                    FormatAddr64(Info.BaseAddress + Info.RegionSize - 1));
            FlushCallbacks();
        }

        //
        // Check for MZ at the beginning of every page.
        //

        Addr = Info.BaseAddress;
        while (Addr < Info.BaseAddress + Info.RegionSize)
        {
            USHORT ShortSig;
            ULONG Done;

            if (g_Target->
                ReadVirtual(g_Process, Addr, &ShortSig, sizeof(ShortSig),
                            &Done) == S_OK &&
                Done == sizeof(ShortSig) &&
                ShortSig == IMAGE_DOS_SIGNATURE)
            {
                IMAGE_NT_HEADERS64 NtHdr;
                char Name[MAX_IMAGE_PATH];

                if (AllRegions)
                {
                    dprintf("MZ at %s, prot %08X, type %08X",
                            FormatAddr64(Addr), Info.Protect, Info.Type);
                }
                else
                {
                    dprintf("MZ at %s", FormatAddr64(Addr));
                }

                if (g_Target->ReadImageNtHeaders(g_Process, Addr,
                                                 &NtHdr) == S_OK)
                {
                    dprintf(" - size %x\n", NtHdr.OptionalHeader.SizeOfImage);
                    if (GetModnameFromImage(g_Process, Addr, NULL,
                                            Name, DIMA(Name), TRUE))
                    {
                        dprintf("  Name: %s\n", Name);

                        if (ReloadIfPossible)
                        {
                            char ReloadCmd[MAX_IMAGE_PATH];
                            PCSTR ArgsRet;

                            PrintString(ReloadCmd, DIMA(ReloadCmd),
                                        "%s=0x%s,0x%x",
                                        Name, FormatAddr64(Addr),
                                        NtHdr.OptionalHeader.SizeOfImage);
                            if (g_Target->Reload(g_Thread, ReloadCmd,
                                                 &ArgsRet) == S_OK)
                            {
                                dprintf("  Loaded %s module\n", Name);
                            }
                        }
                    }
                }
                else
                {
                    dprintf("\n");
                }

                FlushCallbacks();
            }

            if (CheckUserInterrupt())
            {
                WarnOut("  Aborted\n");
                return;
            }

            Addr += g_Machine->m_PageSize;
        }

        Info.RegionSize = 0;
    }
}

void
DotKdFiles(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ((ConnLiveKernelTargetInfo*)g_Target)->m_Transport->ParseKdFileAssoc();
}

void
DotKdTrans(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ((ConnLiveKernelTargetInfo*)g_Target)->m_Transport->OutputInfo();
}

void
DotKFrames(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_DefaultStackTraceDepth = (ULONG)GetExpression();
    dprintf("Default stack trace depth is 0n%d frames\n",
            g_DefaultStackTraceDepth);
}

PCSTR
EventProcThreadString(void)
{
    if (IS_USER_TARGET(g_EventTarget))
    {
        static char s_Buf[64];

        PrintString(s_Buf, DIMA(s_Buf), "%x.%x: ",
                    g_EventProcessSysId, g_EventThreadSysId);
        return s_Buf;
    }
    else
    {
        return "";
    }
}

void
DotLastEvent(PDOT_COMMAND Cmd, DebugClient* Client)
{
    dprintf("Last event: %s%s\n",
            EventProcThreadString(), g_LastEventDesc);
}

void
DotLocale(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PSTR LocaleStr;
    CHAR Save;

    if (PeekChar() && *g_CurCmd != ';')
    {
        LocaleStr = StringValue(STRV_ESCAPED_CHARACTERS |
                                STRV_TRIM_TRAILING_SPACE,
                                &Save);
    }
    else
    {
        LocaleStr = NULL;
    }

    dprintf("Locale: %s\n", setlocale(LC_ALL, LocaleStr));

    if (LocaleStr != NULL)
    {
        *g_CurCmd = Save;
    }
}

void
DotLogAppend(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ParseLogOpen(TRUE);
}

void
DotLogClose(PDOT_COMMAND Cmd, DebugClient* Client)
{
    CloseLogFile();
}

void
DotLogFile(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (g_LogFile >= 0)
    {
        dprintf("Log '%s' open%s\n",
                g_OpenLogFileName,
                g_OpenLogFileAppended ? " for append" : "");
    }
    else
    {
        dprintf("No log file open\n");
    }
}

void
DotLogOpen(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ParseLogOpen(FALSE);
}

void
DotNetSyms(PDOT_COMMAND Cmd, DebugClient* Client)
{
    char Save;
    PSTR Str;

    Str = StringValue(0, &Save);

    if (_stricmp(Str, "1") == 0 ||
        _stricmp(Str, "true") == 0 ||
        _stricmp(Str, "yes") == 0)
    {
        g_EngOptions |= DEBUG_ENGOPT_ALLOW_NETWORK_PATHS;
        g_EngOptions &= ~DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS;
    }
    else if (_stricmp(Str, "0") == 0 ||
             _stricmp(Str, "false") == 0 ||
             _stricmp(Str, "no") == 0)
    {
        g_EngOptions |= DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS;
        g_EngOptions &= ~DEBUG_ENGOPT_ALLOW_NETWORK_PATHS;
    }

    *g_CurCmd = Save;

    if (g_EngOptions & DEBUG_ENGOPT_ALLOW_NETWORK_PATHS)
    {
        dprintf("netsyms = yes\n");
    }
    else if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
    {
        dprintf("netsyms = no\n");
    }
    else
    {
        dprintf("netsyms = don't care\n");
    }
}

void
DotNoEngErr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    // Internal command to clear out the error suppression
    // flags in case we want to rerun operations and check
    // for errors that may be in suppression mode.
    g_EngErr = 0;
}

void
DotNoShell(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_EngOptions |= DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS;
    dprintf("Shell commands disabled\n");
}

void
DotNoVersion(PDOT_COMMAND Cmd, DebugClient* Client)
{
    dprintf("Extension DLL system version checking is disabled\n");
    g_EnvDbgOptions |= OPTION_NOVERSIONCHECK;
}

void
DotOCommand(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() != ';' && *g_CurCmd)
    {
        ULONG BufLen;

        BufLen = MAX_PATH;

        while (PeekChar() == '-' || *g_CurCmd == '/')
        {
            switch(*++g_CurCmd)
            {
            case 'd':
                BufLen = 0;
                break;
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                break;
            }

            g_CurCmd++;
        }

        if (BufLen)
        {
            ULONG Len;
            CHAR Save;
            PSTR Pat = StringValue(STRV_ESCAPED_CHARACTERS, &Save);
            Len = strlen(Pat);
            if (Len >= BufLen)
            {
                error(OVERFLOW);
            }

            memcpy(g_OutputCommandRedirectPrefix, Pat, Len + 1);
            g_OutputCommandRedirectPrefixLen = Len;

            *g_CurCmd = Save;
        }
        else
        {
            g_OutputCommandRedirectPrefixLen = 0;
        }
    }

    if (g_OutputCommandRedirectPrefixLen)
    {
        dprintf("Treat output prefixed with '%s' as a command\n",
                g_OutputCommandRedirectPrefix);
    }
    else
    {
        dprintf("Output command redirection inactive\n");
    }
}

void
DotOFilter(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() != ';' && *g_CurCmd)
    {
        g_OutFilterResult = TRUE;

        while (PeekChar() == '-' || *g_CurCmd == '/')
        {
            switch(*++g_CurCmd)
            {
            case '!':
                g_OutFilterResult = FALSE;
                break;
            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                break;
            }

            g_CurCmd++;
        }

        CHAR Save;
        PSTR Pat = StringValue(STRV_TRIM_TRAILING_SPACE |
                               STRV_ESCAPED_CHARACTERS |\
                               STRV_ALLOW_EMPTY_STRING, &Save);

        if (strlen(Pat) + 1 > sizeof(g_OutFilterPattern))
        {
            error(OVERFLOW);
        }

        CopyString(g_OutFilterPattern, Pat, DIMA(g_OutFilterPattern));
        *g_CurCmd = Save;
        _strupr(g_OutFilterPattern);
    }

    if (g_OutFilterPattern[0])
    {
        dprintf("Only display debuggee output that %s '%s'\n",
                g_OutFilterResult ? "matches" : "doesn't match",
                g_OutFilterPattern);
    }
    else
    {
        dprintf("No debuggee output filter set\n");
    }
}

void
DotOpenDump(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PSTR FileName;
    PWSTR FileWide;
    char Save;
    TargetInfo* Target;

    if (g_SymOptions & SYMOPT_SECURE)
    {
        error(NOTSECURE);
    }

    FileName = StringValue(STRV_TRIM_TRAILING_SPACE |
                           STRV_ESCAPED_CHARACTERS, &Save);
    if (AnsiToWide(FileName, &FileWide) != S_OK)
    {
        ErrOut("Unable to convert filename\n");
    }
    else
    {
        // Error messages are displayed by DumpInitialize.
        if (DumpInitialize(Client, FileWide, 0, &Target) == S_OK)
        {
            dprintf("Opened '%s'\n", FileName);
        }

        FreeWide(FileWide);
    }
    *g_CurCmd = Save;
}

void
DotOutMask(PDOT_COMMAND Cmd, DebugClient* Client)
{
    // Private internal command for debugging the debugger.
    ULONG Expr = (ULONG)GetExpression();
    if (Cmd->Name[7] == '-')
    {
        Client->m_OutMask &= ~Expr;
    }
    else
    {
        Client->m_OutMask |= Expr;
    }
    dprintf("Client %p mask is %X\n", Client, Client->m_OutMask);
    CollectOutMasks();

    // Also update the log mask as people usually
    // want to see the same things in the log.
    g_LogMask = Client->m_OutMask;
}

void
DotPCache(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_Target->m_PhysicalCache.ParseCommands();
}

void
DotReboot(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar())
    {
        error(SYNTAX);
    }

    // Null out .reboot command.
    g_LastCommand[0] = '\0';
    g_Target->Reboot();
    // The target is no longer accepting commands
    // so reset the command state.
    g_CmdState = 'i';
}

void
DotReCxr(PDOT_COMMAND Cmd, DebugClient* Client)
{
    while (PeekChar() == '-')
    {
        switch(*++g_CurCmd)
        {
        case 'f':
            g_Target->FlushRegContext();
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    if (g_Machine)
    {
        g_Machine->InvalidateContext();
    }
}

void
DotReload(PDOT_COMMAND Cmd, DebugClient* Client)
{
    g_Target->Reload(g_Thread, g_CurCmd, (PCSTR*)&g_CurCmd);
    ClearStoredTypes(0);
}

void
DotSecure(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar() && *g_CurCmd != ';')
    {
        // Ignore argument.
        if (GetExpression())
        {
            if (SetSymOptions(g_SymOptions | SYMOPT_SECURE) != S_OK)
            {
                ErrOut("ERROR: Unable to enter secure mode.\n"
                       "Secure mode requires no sessions and "
                       "no remote clients.\n");
            }
            else
            {
                dprintf("Entered secure mode\n");
            }
        }
    }

    dprintf("Secure mode %sabled\n",
            (g_SymOptions & SYMOPT_SECURE) ? "en" : "dis");
}

void
EnumServers(BOOL ShowComputerName)
{
    ULONG Id;
    char Desc[4 * MAX_PARAM_VALUE];
    PVOID Cookie = NULL;
    BOOL Any = FALSE;
    char CompName[MAX_COMPUTERNAME_LENGTH + 1];

    if (ShowComputerName)
    {
        ULONG CompSize = sizeof(CompName);

        if (!GetComputerName(CompName, &CompSize))
        {
            PrintString(CompName, DIMA(CompName),
                        "<Win32 Error %d>", GetLastError());
        }
    }

    while (Cookie =
           DbgRpcEnumActiveServers(Cookie, &Id, Desc, sizeof(Desc)))
    {
        dprintf("%d - %s", Id, Desc);

        if (ShowComputerName)
        {
            dprintf(",Server=%s", CompName);
        }

        dprintf("\n");

        Any = TRUE;
    }
    if (!Any)
    {
        dprintf("No active servers\n");
    }
}

void
DotServer(PDOT_COMMAND Cmd, DebugClient* Client)
{
    HRESULT Status;

    // Skip whitespace.
    if (PeekChar() == 0)
    {
        ErrOut("Usage: .server tcp:port=<Socket>  OR  "
               ".server npipe:pipe=<PipeName>\n");
    }
    else
    {
        Status = ClientStartServer(g_CurCmd, TRUE);
        if (Status != S_OK)
        {
            ErrOut("Unable to start server, %s\n    \"%s\"\n",
                   FormatStatusCode(Status), FormatStatus(Status));
        }
        else
        {
            dprintf("Server started.  Client can connect with any of:\n");
            EnumServers(TRUE);
        }
        *g_CurCmd = 0;
    }
}

void
DotServers(PDOT_COMMAND Cmd, DebugClient* Client)
{
    EnumServers(FALSE);
}

void
DotShell(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ShellProcess Shell;
    PSTR InFile = NULL;
    PSTR OutFile = NULL;
    PSTR ErrFile = NULL;
    PSTR* File;

    if ((g_EngOptions & DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS) ||
        (g_SymOptions & SYMOPT_SECURE))
    {
        ErrOut(".shell has been disabled\n");
        return;
    }

    if (AnySystemProcesses(TRUE))
    {
        ErrOut(".shell: can't create a process while debugging CSRSS.\n");
        return;
    }

    for (;;)
    {
        if (PeekChar() == '-')
        {
            g_CurCmd++;
            switch(*g_CurCmd)
            {
            case 'e':
                File = &ErrFile;
                goto ParseFile;
            case 'i':
                File = &InFile;
                goto ParseFile;
            case 'o':
                File = &OutFile;
            ParseFile:
                g_CurCmd++;
                if (*g_CurCmd == '-')
                {
                    *File = "nul";
                    g_CurCmd++;
                }
                else
                {
                    char LastSave;

                    *File = StringValue(STRV_SPACE_IS_SEPARATOR |
                                        STRV_ESCAPED_CHARACTERS,
                                        &LastSave);
                    if (LastSave)
                    {
                        g_CurCmd++;
                    }
                    else
                    {
                        *g_CurCmd = LastSave;
                    }
                }
                break;

            case 't':
                Shell.m_DefaultTimeout = (ULONG)GetExpression() * 1000;
                break;

            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                g_CurCmd++;
                break;
            }
        }
        else
        {
            break;
        }
    }

    // If either output file was specified singly give
    // the output file the name and let the error file
    // get set to a duplicate of it.
    if (ErrFile && !OutFile)
    {
        OutFile = ErrFile;
        ErrFile = NULL;
    }

    Shell.Start(g_CurCmd, InFile, OutFile, ErrFile);

    // Command uses the whole string so we're done.
    *g_CurCmd = 0;
}

void
DotSleep(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG WaitStatus;
    ULONG Millis = (ULONG)
        GetExpressionDesc("Number of milliseconds missing from");

    // This command is intended for use with ntsd/cdb -d
    // when being at the prompt locks up the target machine.
    // If you want to use the target machine for something,
    // such as copy symbols, there's no easy way to get it
    // running again without resuming the program.  By
    // sleeping you can return control to the target machine
    // without changing the session state.
    // The sleep is done with a wait on a named event so
    // that it can be interrupted from a different process.
    ResetEvent(g_SleepPidEvent);
    WaitStatus = WaitForSingleObject(g_SleepPidEvent, Millis);
    if (WaitStatus == WAIT_OBJECT_0)
    {
        dprintf("Sleep interrupted\n");
    }
    else if (WaitStatus != WAIT_TIMEOUT)
    {
        ErrOut("Sleep failed, %s\n",
               FormatStatusCode(WIN32_LAST_STATUS()));
    }
}

void
DotSrcPath(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (PeekChar())
    {
        if (ChangePath(&g_SrcPath, g_CurCmd, Cmd->Name[7] == '+',
                       DEBUG_CSS_PATHS) != S_OK)
        {
            // This command uses the whole string.
            *g_CurCmd = 0;
            return;
        }

        *g_CurCmd = 0;
    }

    if (g_SrcPath == NULL)
    {
        dprintf("No source search path\n");
    }
    else
    {
        dprintf("Source search path is: %s\n", g_SrcPath);
        CheckPath(g_SrcPath);
    }
}

void
DotSymPath(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ChangeSymPath(g_CurCmd, Cmd->Name[7] == '+', NULL, 0);
    // Command uses the whole string.
    *g_CurCmd = 0;
}

void
DotSxCmds(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Flags = 0;

    while (PeekChar() == '-')
    {
        switch(*(++g_CurCmd))
        {
        case '1':
            Flags |= SXCMDS_ONE_LINE;
            break;
        default:
            dprintf("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    ListFiltersAsCommands(Client, Flags);
}

void
DotSymFix(PDOT_COMMAND Cmd, DebugClient* Client)
{
    char Path[MAX_PATH * 2];
    PSTR SrvName;
    char LocalStore[MAX_PATH + 1];

    strcpy(Path, "SRV*");

    if (IsInternalPackage())
    {
        // Use the internal symbol server.
        // A local cache is not required.
        SrvName = "\\\\symbols\\symbols";
    }
    else
    {
        // Use the public Microsoft symbol server.
        // This requires a local cache, so default
        // if one isn't given.
        SrvName = "http://msdl.microsoft.com/download/symbols";

        if (!PeekChar() || *g_CurCmd == ';')
        {
            if (!CatString(Path, "*", DIMA(Path)))
            {
                error(OVERFLOW);
            }
            if (SymGetHomeDirectory(hdSym, LocalStore, DIMA(LocalStore)))
            {
                WarnOut("No local cache given, using %s\n", LocalStore);
            }
        }
    }

    if (PeekChar() && *g_CurCmd != ';')
    {
        char Save;
        PSTR Str = StringValue(0, &Save);

        if (!CatString(Path, Str, DIMA(Path)) ||
            !CatString(Path, "*", DIMA(Path)))
        {
            error(OVERFLOW);
        }

        *g_CurCmd = Save;
    }

    if (!CatString(Path, SrvName, DIMA(Path)))
    {
        error(OVERFLOW);
    }

    ChangeSymPath(Path, Cmd->Name[6] == '+', NULL, 0);
}

void
DotSymOpt(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Flags = (ULONG)GetExpression();

    if (Cmd->Name[6] == '+')
    {
        Flags |= g_SymOptions;
    }
    else
    {
        Flags = g_SymOptions & ~Flags;
    }

    if (SetSymOptions(Flags) != S_OK)
    {
        ErrOut("Invalid symbol options\n");
    }
    else
    {
        dprintf("Symbol options are %X\n", Flags);
    }
}

void
DotTList(PDOT_COMMAND Cmd, DebugClient* Client)
{
    BOOL ListCurrent = FALSE;
    BOOL Verbose = FALSE;

    if (!IS_LIVE_USER_TARGET(g_Target))
    {
        error(SESSIONNOTSUP);
    }
    if (g_SymOptions & SYMOPT_SECURE)
    {
        error(NOTSECURE);
    }

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        switch(*++g_CurCmd)
        {
        case 'c':
            if (g_Process == NULL)
            {
                error(BADPROCESS);
            }
            ListCurrent = TRUE;
            break;
        case 'v':
            Verbose = TRUE;
            break;
        default:
            ErrOut("Unknown option '%c'\n", *g_CurCmd);
            break;
        }

        g_CurCmd++;
    }

    PUSER_DEBUG_SERVICES Services =
        ((LiveUserTargetInfo*)g_Target)->m_Services;

#define MAX_IDS 1024
    ULONG Ids[MAX_IDS];
    HRESULT Status;
    ULONG IdCount;
    ULONG i;
    WCHAR DescBuf[2 * MAX_PATH];
    PWSTR Desc;
    ULONG DescLen;

    if (ListCurrent)
    {
        Ids[0] = g_Process->m_SystemId;
        IdCount = 1;
    }
    else
    {
        if ((Status = Services->GetProcessIds(Ids, MAX_IDS, &IdCount)) != S_OK)
        {
            ErrOut("Unable to get process list, %s\n",
                   FormatStatusCode(Status));
            return;
        }

        if (IdCount > MAX_IDS)
        {
            WarnOut("Process list missing %d processes\n",
                    IdCount - MAX_IDS);
            IdCount = MAX_IDS;
        }
    }

    if (Verbose)
    {
        Desc = DescBuf;
        DescLen = sizeof(DescBuf);
    }
    else
    {
        Desc = NULL;
        DescLen = 0;
    }

    for (i = 0; i < IdCount; i++)
    {
        WCHAR ExeName[MAX_PATH];
        int Space;

        if (Ids[i] < 10)
        {
            Space = 3;
        }
        else if (Ids[i] < 100)
        {
            Space = 2;
        }
        else if (Ids[i] < 1000)
        {
            Space = 1;
        }
        else
        {
            Space = 0;
        }
        dprintf("%.*s", Space, "        ");

        if (FAILED(Status = Services->
                   GetProcessDescriptionW(Ids[i], DEBUG_PROC_DESC_DEFAULT,
                                          ExeName, sizeof(ExeName), NULL,
                                          Desc, DescLen, NULL)))
        {
            ErrOut("0n%d Error %s\n", Ids[i], FormatStatusCode(Status));
        }
        else if (Ids[i] >= 0x80000000)
        {
            dprintf("0x%x %ws\n", Ids[i], ExeName);
        }
        else
        {
            dprintf("0n%d %ws\n", Ids[i], ExeName);
        }

        if (Desc && Desc[0])
        {
            dprintf("       %ws\n", Desc);
        }
    }
}

void
DotTime(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!g_Target)
    {
        error(BADSYSTEM);
    }

    g_Target->OutputTime();
}

void
DotTrap(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG64 Addr = 0;

    if (PeekChar() && *g_CurCmd != ';')
    {
        Addr = GetExpression();
    }

    if (Addr)
    {
        CROSS_PLATFORM_CONTEXT Context;

        if (g_Target->m_Machine->GetContextFromTrapFrame(Addr, &Context,
                                                         TRUE) == S_OK)
        {
            g_Target->m_Machine->SetAndOutputTrapFrame(Addr, &Context);
        }
    }
    else if (GetCurrentScopeContext())
    {
        dprintf("Resetting default context\n");
        ResetCurrentScope();
    }
}

void
DotTss(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Sel = 0;
    BOOL Extended = FALSE;

    if (PeekChar() && *g_CurCmd != ';')
    {
        Sel = (ULONG)GetExpression();

        // If user specified a 2nd parameter, doesn't matter
        // what it is, dump the portions of the TSS not covered
        // by the trap frame dump.
        if (PeekChar() && *g_CurCmd != ';')
        {
            Extended = TRUE;
            g_CurCmd += strlen(g_CurCmd);
        }
    }

    if (Sel)
    {
        CROSS_PLATFORM_CONTEXT Context;
        DESCRIPTOR64 SelDesc;

        //
        // Lookup task selector.
        //

        if (g_Target->GetSelDescriptor
            (g_Thread, g_Machine, Sel, &SelDesc) != S_OK)
        {
            ErrOut("Unable to get descriptor for selector %x\n",
                   Sel);
            return;
        }

        if (X86_DESC_TYPE(SelDesc.Flags) != 9  &&
            X86_DESC_TYPE(SelDesc.Flags) != 0xb)
        {
            ErrOut("%x is not a 32-bit TSS selector\n", Sel);
            return;
        }

        if (g_Target->m_Machine->
            GetContextFromTaskSegment(SelDesc.Base, &Context,
                                      TRUE) == S_OK)
        {
            g_Target->m_Machine->
                SetAndOutputTaskSegment(SelDesc.Base, &Context,
                                        Extended);
        }
    }
    else if (GetCurrentScopeContext())
    {
        dprintf("Resetting default context\n");
        ResetCurrentScope();
    }
}

void
DotTTime(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!g_Thread)
    {
        error(BADSYSTEM);
    }

    g_Thread->OutputTimes();
}

void
LoadTxtSym(FILE* File, PSTR FileName, ULONG64 Base, ULONG Size)
{
    char Line[MAX_SYMBOL_LEN];
    ImageInfo* Image;
    BOOL Absolute = FALSE;

    if (!fgets(Line, DIMA(Line), File) ||
        strcmp(Line, "TEXTSYM format | V1.0\n") != 0)
    {
        ErrOut("Not a TEXTSYM 1.0 file\n");
        return;
    }

    Image = new ImageInfo(g_Process, FileName, Base, TRUE);
    if (!Image)
    {
        ErrOut("Unable to create module\n");
        return;
    }

    Image->m_SizeOfImage = Size;
    CreateModuleNameFromPath(FileName, Image->m_ModuleName);
    strcpy(Image->m_OriginalModuleName, Image->m_ModuleName);

    if (!SymLoadModuleEx(g_Process->m_SymHandle, NULL,
                         Image->m_ImagePath,
                         Image->m_ModuleName, Image->m_BaseOfImage,
                         Image->m_SizeOfImage, NULL, SLMFLAG_VIRTUAL))
    {
        ErrOut("Unable to add module\n");
        delete Image;
        return;
    }

    for (;;)
    {
        PSTR Scan;
        ULONG64 Addr;

        if (!fgets(Line, DIMA(Line), File))
        {
            break;
        }

        if (strncmp(Line, "GLOBAL | ", 9) != 0)
        {
            continue;
        }

        // Remove newline.
        Scan = Line + strlen(Line) - 1;
        if (*Scan == '\n')
        {
            *Scan = 0;
        }

        Scan = Line + 9;
        if (!sscanf(Scan, "%I64x", &Addr))
        {
            ErrOut("Unable to read address at %.16s\n", Scan);
            break;
        }
        if (Absolute && (Addr < Base || Addr >= Base + Size))
        {
            ErrOut("Address %I64x out of image bounds\n", Addr);
            continue;
        }

        Scan += 26;

        if (!SymAddSymbol(g_Process->m_SymHandle,
                          Image->m_BaseOfImage,
                          Scan, Addr + Base, 0, 0))
        {
            ErrOut("Unable to add '%s' at %I64x\n", Scan, Addr);
        }
    }
}

void
DotTxtSym(PDOT_COMMAND Cmd, DebugClient* Client)
{
    PSTR FileName;
    char Save;
    ULONG64 Base;
    ULONG Size;
    FILE* File;

    //
    // XXX drewb.
    // At the moment the IA64 firmware symbols come in
    // a couple of trivial text formats.  In order to
    // help them out we added this simple command to
    // create a fake module and populate it from the
    // text files.  This should be removed when
    // no longer necessary.
    //

    FileName = StringValue(STRV_SPACE_IS_SEPARATOR |
                           STRV_ESCAPED_CHARACTERS, &Save);

    File = fopen(FileName, "r");
    if (!File)
    {
        ErrOut("Unable to open '%s', Win32 error %d\n",
               FileName, GetLastError());
        *g_CurCmd = 0;
        return;
    }

    if (Save == '"')
    {
        Save = *++g_CurCmd;
    }
    if (isspace(Save))
    {
        g_CurCmd++;
        Save = PeekChar();
    }

    __try
    {
        if (Save != '=')
        {
            error(SYNTAX);
        }
        g_CurCmd++;

        Base = GetExpression();

        if (PeekChar() != ',')
        {
            error(SYNTAX);
        }
        g_CurCmd++;

        Size = (ULONG)GetExpression();

        LoadTxtSym(File, FileName, Base, Size);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        *g_CurCmd = 0;
    }

    fclose(File);
}

void
DotWake(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Pid = (ULONG)GetExpression();
    if (!SetPidEvent(Pid, OPEN_EXISTING))
    {
        ErrOut("Process %d is not a sleeping debugger\n", Pid);
    }
}

void
DotWriteMem(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (!g_Process)
    {
        error(BADPROCESS);
    }

    PSTR FileName, FileNameEnd;
    char Save;
    HANDLE File;
    ADDR Addr;
    ULONG64 Len;
    char Buf[2048];
    BOOL Err = FALSE;

    FileName = StringValue(STRV_SPACE_IS_SEPARATOR |
                           STRV_ESCAPED_CHARACTERS, &Save);
    FileNameEnd = g_CurCmd;
    *g_CurCmd = Save;

    Len = 0x10000;
    GetRange(&Addr, &Len, 1, SEGREG_DATA, DEFAULT_RANGE_LIMIT);

    *FileNameEnd = 0;

    File = CreateFile(FileName, GENERIC_WRITE, 0, NULL,
                      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (File == INVALID_HANDLE_VALUE)
    {
        ErrOut("Unable to create file\n");
        return;
    }

    dprintf("Writing %s bytes", FormatDisp64(Len));
    FlushCallbacks();

    while (Len > 0)
    {
        ULONG Req, Done;

        Req = sizeof(Buf);
        if (Req > Len)
        {
            Req = (ULONG)Len;
        }

        if (CurReadVirtual(Flat(Addr), Buf, Req, &Done) != S_OK ||
            Done != Req)
        {
            dprintf("\n");
            ErrOut("Unable to read memory at %s, file is incomplete\n",
                   FormatAddr64(Flat(Addr)));
            Err = TRUE;
            break;
        }

        if (!WriteFile(File, Buf, Req, &Done, NULL) ||
            Done != Req)
        {
            dprintf("\n");
            ErrOut("Unable to write data from %s, file is incomplete\n",
                   FormatAddr64(Flat(Addr)));
            Err = TRUE;
            break;
        }

        AddrAdd(&Addr, Done);
        Len -= Done;

        dprintf(".");
        FlushCallbacks();
    }

    CloseHandle(File);
    if (!Err)
    {
        dprintf("\n");
    }
}

#define MODE_USER   0x00000001
#define MODE_KERNEL 0x00000002
#define _MODE_UK    (MODE_USER | MODE_KERNEL)

#define MODE_LIVE   0x00000004
#define MODE_DUMP   0x00000008
#define _MODE_LD    (MODE_LIVE | MODE_DUMP)

#define MODE_LOCAL  0x00000010
#define MODE_REMOTE 0x00000020
#define MODE_REMOTE_CONN 0x00000040
#define _MODE_LR    (MODE_LOCAL | MODE_REMOTE | MODE_REMOTE_CONN)

#define MODE_BANG     0x20000000
#define MODE_INTERNAL 0x40000000
#define MODE_UNINIT   0x80000000

#define ANY (0xffff | MODE_UNINIT)
#define AIT (_MODE_UK | _MODE_LD | _MODE_LR)

#define AUT (MODE_USER | _MODE_LD | _MODE_LR)
#define LLU (MODE_USER | MODE_LIVE | MODE_LOCAL)
#define LUT (MODE_USER | MODE_LIVE | _MODE_LR)

#define AKT (MODE_KERNEL | _MODE_LD | _MODE_LR)
#define LKT (MODE_KERNEL | MODE_LIVE | _MODE_LR)
#define RKT (MODE_KERNEL | MODE_LIVE | MODE_REMOTE | MODE_REMOTE_CONN)
#define CKT (MODE_KERNEL | MODE_LIVE | MODE_REMOTE_CONN)

#define ADT (_MODE_UK | MODE_DUMP | _MODE_LR)

ULONG
CurrentMode(void)
{
    ULONG Mode = 0;

    if (IS_USER_TARGET(g_Target))
    {
        Mode |= MODE_USER;

        if (IS_DUMP_TARGET(g_Target) ||
            ((LiveUserTargetInfo*)g_Target)->m_Local)
        {
            Mode |= MODE_LOCAL;
        }
        else
        {
            Mode |= MODE_REMOTE;
        }
    }
    else if (IS_KERNEL_TARGET(g_Target))
    {
        Mode |= MODE_KERNEL;

        if (IS_CONN_KERNEL_TARGET(g_Target))
        {
            Mode |= MODE_REMOTE_CONN;
        }
        else if (IS_REMOTE_KERNEL_TARGET(g_Target))
        {
            Mode |= MODE_REMOTE;
        }
        else
        {
            Mode |= MODE_LOCAL;
        }
    }
    else
    {
        return MODE_UNINIT;
    }

    if (IS_DUMP_TARGET(g_Target))
    {
        Mode |= MODE_DUMP;
    }
    else
    {
        Mode |= MODE_LIVE;
    }

    return Mode;
}

void DotHelp(PDOT_COMMAND Cmd, DebugClient* Client);

// These must be in alphabetical order.
DOT_COMMAND g_DotCommands[] =
{
    LUT, "abandon", "", "abandon the current process",
         ParseSeparateCurrentProcess,
    ANY | MODE_INTERNAL, "aliascmds", "", "", DotAliasCmds,
    ANY, "asm", "[<options>]", "set disassembly options", DotAsm,
    ANY, "asm-", "[<options>]", "clear disassembly options", DotAsm,
    ANY, "attach", "<proc>", "attach to <proc> at next execution", DotAttach,
    ANY | MODE_INTERNAL, "bpcmds", "", "", DotBpCmds,
    LUT, "bpsync", "[0|1]", "special breakpoint behavior for "
         "multithreaded debuggees", DotBpSync,
    LUT, "breakin", "", "break into KD", DotBreakin,
    AKT, "bugcheck", "", "display the bugcheck code and parameters "
         "for a crashed system", DotBugCheck,
    AIT, "cache", "[<options>]", "virtual memory cache control", DotCache,
    ANY | MODE_BANG, "chain", "", "list current extensions", DotChain,
    LUT, "childdbg", "<0|1>", "turn child process debugging on or off",
         DotChildDbg,
    ANY, "clients", "", "list currently active clients", DotClients,
    LUT, "closehandle", "[<options>] [<handle>]", "close the given handle",
         DotCloseHandle,
    AKT, "context", "[<address>]", "set page directory base", DotContext,
    ANY | MODE_INTERNAL, "corstack", "[0|1]", "toggle COR stack assistance",
         DotCorStack,
    LKT, "crash", "", "cause target to bugcheck", DotCrash,
    ANY, "create", "<command line>", "create a new process", DotCreate,
    ANY, "createdir", "[<path>]", "current directory for process create",
         DotCreateDir,
    AIT, "cxr", "<address>", "dump context record at specified address\n"
         "k* after this gives cxr stack", DotCxr,
    AIT, "detach", "", "detach from the current process/dump",
         ParseSeparateCurrentProcess,
    AIT, "dump", "[<options>] <filename>", "create a dump file on the "
         "host system", DotDump,
    ADT, "dumpcab", "[<options>] <filename>", "create a CAB for an open dump",
         DotDumpCab,
    ADT, "dumpdebug", "", "display detailed information about the dump file",
         DotDumpDebug,
    ADT | MODE_INTERNAL, "dumpoff", "", "", DotDumpOff,
    ADT | MODE_INTERNAL, "dumppoff", "", "", DotDumpPOff,
    AIT | MODE_BANG, "drivers", "", "display the list of loaded modules "
         "(same as .reload -l)", DotDrivers,
    ANY, "echo", "[\"<string>\"|<string>]", "echo string", DotEcho,
    ANY, "echotimestamps", "[0|1]", "toggle timestamp output on events",
         DotEchoTimestamps,
    AIT, "ecxr", "", "dump context record for current exception", DotEcxr,
    AIT, "effmach", "[<machine>]", "change current machine type", DotEffMach,
    ANY, "enable_long_status", "[0|1]", "dump LONG types in default base",
         DotEnableLongStatus,
    ANY, "enable_unicode", "[0|1]", "dump USHORT array/pointers "
         "and unicode strings", DotEnableUnicode,
    ANY, "endsrv", "<id>", "disable the given engine server", DotEndSrv,
    LLU, "endpsrv", "", "cause the current session's "
         "process server to exit", DotEndPSrv,
    AIT, "enumtag", "", "enumerate available tagged data", DotEnumTag,
    ANY, "eventlog", "", "display log of recent events", DotEventLog,
    AIT, "events", "", "display and select available events", DotEvents,
    AIT, "eventstr", "", "display any event strings registered by debuggee",
         DotEventStr,
    ANY | MODE_BANG, "exepath", "[<dir>[;...]]", "set executable search path",
         DotExePath,
    ANY | MODE_BANG, "exepath+", "[<dir>[;...]]",
         "append executable search path", DotExePath,
    ANY, "expr", "", "control expression evaluator", DotExpr,
    AIT, "exr", "<address>", "dump exception record at specified address",
         DotExr,
    AIT, "fiber", "<address>", "sets context of fiber at address\n"
         "resets context if no address specified", DotFiber,
    AIT, "fnent", "<address>", "dump function entry for the "
         "given code address", DotFnEnt,
    AIT, "frame", "[<frame>]", "set current stack frame for locals", DotFrame,
    AIT | MODE_INTERNAL, "frame_ebpfix", "", "", DotFrameEbpFix,
    ANY, "formats", "<expr>", "displays expression result in many formats",
         DotFormats,
    ANY, "force_radix_output", "[0|1]", "dump integer types in default base",
         DotForceRadixOutput,
    ANY, "help", "", "display this help", DotHelp,
    AIT, "imgscan", "<options>", "scan memory for PE images", DotImgScan,
    CKT, "kdfiles", "<file>", "control debuggee remote file loading",
         DotKdFiles,
    CKT, "kdtrans", "", "display current KD transport information", DotKdTrans,
    ANY, "kframes", "<count>", "set default stack trace depth", DotKFrames,
    LUT, "kill", "", "kill the current process",
         ParseSeparateCurrentProcess,
    RKT, "kill", "", "kill a process on the target", DotKernelKill,
    ANY, "lastevent", "", "display the last event that occurred", DotLastEvent,
    ANY | MODE_BANG, "lines", "", "toggle line symbol loading", DotLines,
    ANY | MODE_BANG, "load", "<name>",
         "add this extension DLL to the list of known DLLs", NULL,
    ANY, "locale", "[<locale>]", "set the current locale", DotLocale,
    ANY, "logfile", "", "display log status", DotLogFile,
    ANY, "logopen", "[<file>]", "open new log file", DotLogOpen,
    ANY, "logappend", "[<file>]", "append to log file", DotLogAppend,
    ANY, "logclose", "", "close log file", DotLogClose,
    ANY, "netsyms", "[0|1]", "allow/disallow net symbol paths", DotNetSyms,
    ANY | MODE_INTERNAL, "noengerr", "", "", DotNoEngErr,
    ANY, "noshell", "", "disable shell commands", DotNoShell,
    ANY | MODE_BANG, "noversion", "", "disable extension version checking",
         DotNoVersion,
    ANY, "ofilter", "<pattern>", "filter debuggee output against "
         "the given pattern", DotOFilter,
    LUT, "ocommand", "<prefix>", "treat output with the given prefix "
         "as a command", DotOCommand,
    ANY, "opendump", "<file>", "open a dump file", DotOpenDump,
    ANY, "outmask", "<mask>", "set bits in the current output mask",
         DotOutMask,
    ANY, "outmask-", "<mask>", "clear bits in the current output mask",
         DotOutMask,
    LKT, "pagein", "[<options>] <addr>", "page in user-mode data", DotPageIn,
    RKT, "pcache", "[<options>]", "physical memory cache control", DotPCache,
    AIT, "process", "[<address>]", "sets implicit process\n"
         "resets default if no address specified", DotProcess,
    RKT, "reboot", "", "reboot target", DotReboot,
    AIT | MODE_INTERNAL, "recxr", "", "", DotReCxr,
    AIT | MODE_BANG, "reload", "[<image.ext>[=<address>,<size>]]",
         "reload symbols", DotReload,
    ANY, "remote", "<pipename>", "start remote.exe server", NULL,
    ANY, "secure", "[0|1]", "disallow operations dangerous for the host",
         DotSecure,
    ANY, "server", "<options>", "start engine server", DotServer,
    ANY, "servers", "", "list active remoting servers", DotServers,
    ANY | MODE_BANG, "setdll", "<name>", "debugger will search for extensions "
         "in this DLL first", NULL,
    ANY, "shell", "[<command>]", "execute shell command", DotShell,
    ANY, "sleep", "<milliseconds>", "debugger sleeps for given duration\n"
         "useful for allowing access to a machine that's\n"
         "broken in on an ntsd -d", DotSleep,
    ANY | MODE_BANG, "srcpath", "[<dir>[;...]]", "set source search path",
         DotSrcPath,
    ANY | MODE_BANG, "srcpath+", "[<dir>[;...]]", "append source search path",
         DotSrcPath,
    ANY | MODE_INTERNAL, "sxcmds", "", "", DotSxCmds,
    ANY | MODE_BANG, "symfix", "[<localsym>]", "fix symbol search path",
         DotSymFix,
    ANY | MODE_BANG, "symfix+", "[<localsym>]",
         "append fixed symbol search path", DotSymFix,
    ANY, "symopt+", "<flags>", "set symbol options", DotSymOpt,
    ANY, "symopt-", "<flags>", "clear symbol options", DotSymOpt,
    ANY | MODE_BANG, "sympath", "[<dir>[;...]]", "set symbol search path",
         DotSymPath,
    ANY | MODE_BANG, "sympath+", "[<dir>[;...]]", "append symbol search path",
         DotSymPath,
    AIT, "thread", "[<address>]", "sets context of thread at address\n"
         "resets default context if no address specified", DotThread,
    AIT, "time", "", "displays session time information", DotTime,
    AIT, "ttime", "", "displays thread time information", DotTTime,
    LUT, "tlist", "", "list running processes", DotTList,
    AKT, "trap", "<address>", "dump a trap frame", DotTrap,
    AKT, "tss", "<selector>", "dump a Task State Segment", DotTss,
    ANY | MODE_INTERNAL, "txtsym", "", "", DotTxtSym,
    ANY | MODE_BANG, "unload", "<name>", "remove this extension DLL from the "
         "list of extension DLLs", NULL,
    ANY | MODE_BANG, "unloadall", "", "remove all extension DLLs from the "
         "list of extensions DLLs", NULL,
    ANY, "wake", "", "wake up a .sleep'ing debugger", DotWake,
    AIT, "writemem", "<file> <range>", "write raw memory to a file",
         DotWriteMem,
};

void
DotHelp(PDOT_COMMAND Cmd, DebugClient* Client)
{
    ULONG Mode = CurrentMode();

    dprintf(". commands:\n");
    for (Cmd = g_DotCommands;
         Cmd < g_DotCommands + DIMA(g_DotCommands);
         Cmd++)
    {
        if (!(Cmd->Mode & MODE_INTERNAL) &&
            (Cmd->Mode & Mode) == Mode)
        {
            PSTR Desc;
            int StartBlanks;

            dprintf("   .%s", Cmd->Name);
            StartBlanks = 4 + strlen(Cmd->Name);
            if (*Cmd->Args)
            {
                dprintf(" %s", Cmd->Args);
                StartBlanks += 1 + strlen(Cmd->Args);
            }
            dprintf(" - ");
            StartBlanks += 3;

            Desc = Cmd->Desc;
            while (*Desc)
            {
                PSTR Nl;

                Nl = strchr(Desc, '\n');
                if (Nl)
                {
                    dprintf("%.*s%.*s",
                            (int)(Nl - Desc) + 1, Desc,
                            StartBlanks, g_Blanks);
                    Desc = Nl + 1;
                }
                else
                {
                    dprintf("%s", Desc);
                    break;
                }
            }

            dprintf("\n");
        }
    }

    dprintf("\nUse \".hh <command>\" or open debugger.chm in the debuggers "
             "directory to get\n"
             "detailed documentation on a command.\n");
    dprintf("\n");
}

#define MAX_DOT_COMMAND 32

BOOL
DotCommand(DebugClient* Client, BOOL Bang)
{
    ULONG Index = 0;
    char Cmd[MAX_DOT_COMMAND];
    char Ch;

    // Read in up to the first few alpha characters into
    // Cmd, converting to lower case.

    while (Index < MAX_DOT_COMMAND)
    {
        Ch = (char)tolower(*g_CurCmd);
        if ((Ch >= 'a' && Ch <= 'z') || Ch == '-' || Ch == '+' || Ch == '_')
        {
            Cmd[Index++] = Ch;
            g_CurCmd++;
        }
        else
        {
            break;
        }
    }

    // If all characters read, then too big, else terminate.
    if (Index == MAX_DOT_COMMAND)
    {
        return FALSE;
    }
    Cmd[Index] = '\0';

    DOT_COMMAND* DotCmd;
    ULONG Mode = CurrentMode();

    if (Bang)
    {
        Mode |= MODE_BANG;
    }

    for (DotCmd = g_DotCommands;
         DotCmd < g_DotCommands + DIMA(g_DotCommands);
         DotCmd++)
    {
        if (DotCmd->Func &&
            (DotCmd->Mode & Mode) == Mode &&
            !strcmp(Cmd, DotCmd->Name))
        {
            DotCmd->Func(DotCmd, Client);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dotcmd.h ===
//----------------------------------------------------------------------------
//
// Dot command parsing.
//
// Copyright (C) Microsoft Corporation, 2002.
//
//----------------------------------------------------------------------------

#ifndef __DOTCMD_H__
#define __DOTCMD_H__

typedef struct _DOT_COMMAND
{
    ULONG Mode;
    PSTR Name;
    PSTR Args;
    PSTR Desc;
    void (*Func)(_DOT_COMMAND* Cmd, DebugClient* Client);
} DOT_COMMAND, *PDOT_COMMAND;

void DotFormats(PDOT_COMMAND Cmd, DebugClient* Client);
void DotShell(PDOT_COMMAND Cmd, DebugClient* Client);

BOOL DotCommand(DebugClient* Client, BOOL Bang);

#endif // #ifndef __DOTCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgsym.cpp ===
//----------------------------------------------------------------------------
//
// IDebugSymbols implementation.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_SYMGROUP_ENABLED 0

// Special type status value that maps to E_UNEXPECTED.
#define TYPE_E_UNEXPECTED 0xfefefefe

BOOL
GetAllModuleName(ULONG64 Base,
                 PCHAR Name,
                 ULONG SizeOfName)
{
    ImageInfo* Image = g_Process->FindImageByOffset(Base, TRUE);
    if (Image)
    {
        return CopyString(Name, Image->m_ModuleName, SizeOfName);
    }

    return FALSE;
}

HRESULT
ResultFromTypeStatus(ULONG Status)
{
    switch(Status)
    {
    case NO_ERROR:
        return S_OK;

    case MEMORY_READ_ERROR:
    case EXIT_ON_CONTROLC:
        return E_FAIL;

    case SYMBOL_TYPE_INDEX_NOT_FOUND:
    case SYMBOL_TYPE_INFO_NOT_FOUND:
        return E_NOINTERFACE;

    case FIELDS_DID_NOT_MATCH:
    case NULL_SYM_DUMP_PARAM:
    case NULL_FIELD_NAME:
    case INCORRECT_VERSION_INFO:
        return E_INVALIDARG;

    case CANNOT_ALLOCATE_MEMORY:
    case INSUFFICIENT_SPACE_TO_COPY:
        return E_OUTOFMEMORY;

    case TYPE_E_UNEXPECTED:
        return E_UNEXPECTED;
    }

    return E_FAIL;
}

STDMETHODIMP
DebugClient::GetSymbolOptions(
    THIS_
    OUT PULONG Options
    )
{
    ENTER_ENGINE();

    *Options = g_SymOptions;

    LEAVE_ENGINE();
    return S_OK;
}

#define ALL_SYMBOL_OPTIONS           \
    (SYMOPT_CASE_INSENSITIVE |       \
     SYMOPT_UNDNAME |                \
     SYMOPT_DEFERRED_LOADS |         \
     SYMOPT_NO_CPP |                 \
     SYMOPT_LOAD_LINES |             \
     SYMOPT_OMAP_FIND_NEAREST |      \
     SYMOPT_LOAD_ANYTHING |          \
     SYMOPT_IGNORE_CVREC |           \
     SYMOPT_NO_UNQUALIFIED_LOADS |   \
     SYMOPT_FAIL_CRITICAL_ERRORS |   \
     SYMOPT_EXACT_SYMBOLS |          \
     SYMOPT_ALLOW_ABSOLUTE_SYMBOLS | \
     SYMOPT_IGNORE_NT_SYMPATH |      \
     SYMOPT_INCLUDE_32BIT_MODULES |  \
     SYMOPT_PUBLICS_ONLY |           \
     SYMOPT_NO_PUBLICS |             \
     SYMOPT_AUTO_PUBLICS |           \
     SYMOPT_NO_IMAGE_SEARCH |        \
     SYMOPT_SECURE |                 \
     SYMOPT_NO_PROMPTS |			 \
     SYMOPT_DEBUG)

STDMETHODIMP
DebugClient::AddSymbolOptions(
    THIS_
    IN ULONG Options
    )
{
    HRESULT Status;

    if (Options & ~ALL_SYMBOL_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    Status = SetSymOptions(g_SymOptions | Options);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::RemoveSymbolOptions(
    THIS_
    IN ULONG Options
    )
{
    HRESULT Status;

    if (Options & ~ALL_SYMBOL_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    Status = SetSymOptions(g_SymOptions & ~Options);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSymbolOptions(
    THIS_
    IN ULONG Options
    )
{
    HRESULT Status;

    if (Options & ~ALL_SYMBOL_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    Status = SetSymOptions(Options);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNameByOffset(
    THIS_
    IN ULONG64 Offset,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PULONG64 Displacement
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        char Sym[MAX_SYMBOL_LEN];
        ULONG64 _Disp;

        if (GetSymbol(Offset, Sym, DIMA(Sym), &_Disp))
        {
            Status = FillStringBuffer(Sym, 0, NameBuffer, NameBufferSize,
                                      NameSize);

            if (Displacement)
            {
                *Displacement = _Disp;
            }
        }
        else
        {
            Status = E_FAIL;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetOffsetByName(
    THIS_
    IN PCSTR Symbol,
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    ULONG Count;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (Count = GetOffsetFromSym(g_Process, Symbol, Offset, NULL))
    {
        Status = Count > 1 ? S_FALSE : S_OK;
    }
    else
    {
        Status = E_FAIL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNearNameByOffset(
    THIS_
    IN ULONG64 Offset,
    IN LONG Delta,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize,
    OUT OPTIONAL PULONG64 Displacement
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        char Sym[MAX_SYMBOL_LEN];
        ULONG64 _Disp;

        if (GetNearSymbol(Offset, Sym, sizeof(Sym), &_Disp, Delta))
        {
            Status = FillStringBuffer(Sym, 0, NameBuffer, NameBufferSize,
                                      NameSize);

            if (Displacement)
            {
                *Displacement = _Disp;
            }
        }
        else
        {
            Status = E_NOINTERFACE;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetLineByOffset(
    THIS_
    IN ULONG64 Offset,
    OUT OPTIONAL PULONG Line,
    OUT OPTIONAL PSTR FileBuffer,
    IN ULONG FileBufferSize,
    OUT OPTIONAL PULONG FileSize,
    OUT OPTIONAL PULONG64 Displacement
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        IMAGEHLP_LINE64 DbgLine;
        ULONG Disp;

        if (GetLineFromAddr(g_Process, Offset, &DbgLine, &Disp))
        {
            if (Line != NULL)
            {
                *Line = DbgLine.LineNumber;
            }
            Status = FillStringBuffer(DbgLine.FileName, 0,
                                      FileBuffer, FileBufferSize, FileSize);
            if (Displacement != NULL)
            {
                *Displacement = Disp;
            }
        }
        else
        {
            Status = E_FAIL;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetOffsetByLine(
    THIS_
    IN ULONG Line,
    IN PCSTR File,
    OUT PULONG64 Offset
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        IMAGEHLP_LINE64 DbgLine;
        LONG Disp;

        DbgLine.SizeOfStruct = sizeof(DbgLine);
        if (SymGetLineFromName64(g_Process->m_SymHandle, NULL, (PSTR)File,
                                 Line, &Disp, &DbgLine))
        {
            *Offset = DbgLine.Address;
            Status = S_OK;
        }
        else
        {
            Status = E_FAIL;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetNumberModules(
    THIS_
    OUT PULONG Loaded,
    OUT PULONG Unloaded
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        *Loaded = g_Process->m_NumImages;
        *Unloaded = g_Process->m_NumUnloadedModules;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetUnloadedModuleByIndex(ULONG Index, UnloadedModuleInfo** IterRet,
                         PSTR Name, PDEBUG_MODULE_PARAMETERS Params)
{
    HRESULT Status;
    UnloadedModuleInfo* Iter;

    if ((Iter = g_Target->GetUnloadedModuleInfo()) == NULL)
    {
        return E_FAIL;
    }

    if ((Status = Iter->Initialize(g_Thread)) != S_OK)
    {
        return Status;
    }

    do
    {
        if ((Status = Iter->GetEntry(Name, Params)) != S_OK)
        {
            if (Status == S_FALSE)
            {
                return E_INVALIDARG;
            }

            return Status;
        }
    } while (Index-- > 0);

    if (IterRet != NULL)
    {
        *IterRet = Iter;
    }
    return S_OK;
}

STDMETHODIMP
DebugClient::GetModuleByIndex(
    THIS_
    IN ULONG Index,
    OUT PULONG64 Base
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else if (Index >= g_Process->m_NumImages)
    {
        DEBUG_MODULE_PARAMETERS Params;

        if ((Status = GetUnloadedModuleByIndex
             (Index - g_Process->m_NumImages,
              NULL, NULL, &Params)) == S_OK)
        {
            *Base = Params.Base;
        }
    }
    else
    {
        *Base = g_Process->FindImageByIndex(Index)->m_BaseOfImage;
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleByModuleName(
    THIS_
    IN PCSTR Name,
    IN ULONG StartIndex,
    OUT OPTIONAL PULONG Index,
    OUT OPTIONAL PULONG64 Base
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;

        Status = E_NOINTERFACE;

        ImageInfo* Image = g_Process->m_ImageHead;
        while (Image != NULL)
        {
            if (StartIndex == 0 &&
                !_strcmpi(Name, Image->m_ModuleName))
            {
                if (Index != NULL)
                {
                    *Index = Idx;
                }
                if (Base != NULL)
                {
                    *Base = Image->m_BaseOfImage;
                }
                Status = S_OK;
                break;
            }

            Image = Image->m_Next;
            Idx++;
            if (StartIndex > 0)
            {
                StartIndex--;
            }
        }

        if (Image == NULL)
        {
            UnloadedModuleInfo* Iter;
            char UnlName[MAX_INFO_UNLOADED_NAME];
            DEBUG_MODULE_PARAMETERS Params;

            Status = GetUnloadedModuleByIndex(StartIndex, &Iter, UnlName,
                                              &Params);
            for (;;)
            {
                if (Status == S_FALSE || Status == E_INVALIDARG)
                {
                    Status = E_NOINTERFACE;
                    break;
                }
                else if (Status != S_OK)
                {
                    break;
                }

                if (!_strcmpi(Name, UnlName))
                {
                    if (Index != NULL)
                    {
                        *Index = Idx;
                    }
                    if (Base != NULL)
                    {
                        *Base = Params.Base;
                    }
                    Status = S_OK;
                    break;
                }

                Status = Iter->GetEntry(UnlName, &Params);
                Idx++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleByOffset(
    THIS_
    IN ULONG64 Offset,
    IN ULONG StartIndex,
    OUT OPTIONAL PULONG Index,
    OUT OPTIONAL PULONG64 Base
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;

        Status = E_NOINTERFACE;

        ImageInfo* Image = g_Process->m_ImageHead;
        while (Image != NULL)
        {
            if (StartIndex == 0 &&
                Offset >= Image->m_BaseOfImage &&
                Offset < Image->m_BaseOfImage + Image->m_SizeOfImage)
            {
                if (Index != NULL)
                {
                    *Index = Idx;
                }
                if (Base != NULL)
                {
                    *Base = Image->m_BaseOfImage;
                }
                Status = S_OK;
                break;
            }

            Image = Image->m_Next;
            Idx++;
            if (StartIndex > 0)
            {
                StartIndex--;
            }
        }

        if (Image == NULL)
        {
            UnloadedModuleInfo* Iter;
            DEBUG_MODULE_PARAMETERS Params;

            Status = GetUnloadedModuleByIndex(StartIndex, &Iter, NULL,
                                              &Params);
            for (;;)
            {
                if (Status == S_FALSE || Status == E_INVALIDARG)
                {
                    Status = E_NOINTERFACE;
                    break;
                }
                else if (Status != S_OK)
                {
                    break;
                }

                if (Offset >= Params.Base &&
                    Offset < Params.Base + Params.Size)
                {
                    if (Index != NULL)
                    {
                        *Index = Idx;
                    }
                    if (Base != NULL)
                    {
                        *Base = Params.Base;
                    }
                    Status = S_OK;
                    break;
                }

                Status = Iter->GetEntry(NULL, &Params);
                Idx++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleNames(
    THIS_
    IN ULONG Index,
    IN ULONG64 Base,
    OUT OPTIONAL PSTR ImageNameBuffer,
    IN ULONG ImageNameBufferSize,
    OUT OPTIONAL PULONG ImageNameSize,
    OUT OPTIONAL PSTR ModuleNameBuffer,
    IN ULONG ModuleNameBufferSize,
    OUT OPTIONAL PULONG ModuleNameSize,
    OUT OPTIONAL PSTR LoadedImageNameBuffer,
    IN ULONG LoadedImageNameBufferSize,
    OUT OPTIONAL PULONG LoadedImageNameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;

        Status = E_NOINTERFACE;

        ImageInfo* Image = g_Process->m_ImageHead;
        while (Image != NULL)
        {
            if ((Index != DEBUG_ANY_ID && Idx == Index) ||
                (Index == DEBUG_ANY_ID && Base == Image->m_BaseOfImage))
            {
                IMAGEHLP_MODULE64 ModInfo;

                ModInfo.SizeOfStruct = sizeof(ModInfo);
                if (!SymGetModuleInfo64(g_Process->m_SymHandle,
                                        Image->m_BaseOfImage, &ModInfo))
                {
                    Status = WIN32_LAST_STATUS();
                    break;
                }

                Status = FillStringBuffer(Image->m_ImagePath, 0,
                                          ImageNameBuffer,
                                          ImageNameBufferSize,
                                          ImageNameSize);
                if (FillStringBuffer(Image->m_ModuleName, 0,
                                     ModuleNameBuffer,
                                     ModuleNameBufferSize,
                                     ModuleNameSize) == S_FALSE)
                {
                    Status = S_FALSE;
                }
                if (FillStringBuffer(ModInfo.LoadedImageName, 0,
                                     LoadedImageNameBuffer,
                                     LoadedImageNameBufferSize,
                                     LoadedImageNameSize) == S_FALSE)
                {
                    Status = S_FALSE;
                }
                break;
            }

            Image = Image->m_Next;
            Idx++;
        }

        if (Image == NULL)
        {
            UnloadedModuleInfo* Iter;
            char UnlName[MAX_INFO_UNLOADED_NAME];
            DEBUG_MODULE_PARAMETERS Params;
            ULONG StartIndex = 0;

            if (Index != DEBUG_ANY_ID)
            {
                // If the index was already hit we
                // shouldn't be here.
                DBG_ASSERT(Index >= Idx);
                StartIndex = Index - Idx;
            }

            Status = GetUnloadedModuleByIndex(StartIndex, &Iter, UnlName,
                                              &Params);
            Idx += StartIndex;
            for (;;)
            {
                if (Status == S_FALSE || Status == E_INVALIDARG)
                {
                    Status = E_NOINTERFACE;
                    break;
                }
                else if (Status != S_OK)
                {
                    break;
                }

                if ((Index != DEBUG_ANY_ID && Idx == Index) ||
                    (Index == DEBUG_ANY_ID && Base == Params.Base))
                {
                    Status = FillStringBuffer(UnlName, 0,
                                              ImageNameBuffer,
                                              ImageNameBufferSize,
                                              ImageNameSize);
                    FillStringBuffer(NULL, 0,
                                     ModuleNameBuffer,
                                     ModuleNameBufferSize,
                                     ModuleNameSize);
                    FillStringBuffer(NULL, 0,
                                     LoadedImageNameBuffer,
                                     LoadedImageNameBufferSize,
                                     LoadedImageNameSize);
                    break;
                }

                Status = Iter->GetEntry(UnlName, &Params);
                Idx++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleParameters(
    THIS_
    IN ULONG Count,
    IN OPTIONAL /* size_is(Count) */ PULONG64 Bases,
    IN ULONG Start,
    OUT /* size_is(Count) */ PDEBUG_MODULE_PARAMETERS Params
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    UnloadedModuleInfo* Iter;

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else if (Bases != NULL)
    {
        Status = S_OK;
        while (Count-- > 0)
        {
            ImageInfo* Image = g_Process->m_ImageHead;
            while (Image != NULL)
            {
                if (*Bases == Image->m_BaseOfImage)
                {
                    Image->FillModuleParameters(Params);
                    break;
                }

                Image = Image->m_Next;
            }

            if (Image == NULL)
            {
                Status = E_NOINTERFACE;

                Iter = g_Target->GetUnloadedModuleInfo();
                if (Iter != NULL &&
                    Iter->Initialize(g_Thread) == S_OK)
                {
                    while (Iter->GetEntry(NULL, Params) == S_OK)
                    {
                        if (*Bases == Params->Base)
                        {
                            Status = S_OK;
                            break;
                        }
                    }
                }

                if (Status != S_OK)
                {
                    ZeroMemory(Params, sizeof(*Params));
                    Params->Base = DEBUG_INVALID_OFFSET;
                }
            }

            Bases++;
            Params++;
        }
    }
    else
    {
        ULONG i, End;
        HRESULT SingleStatus;

        Status = S_OK;
        i = Start;
        End = Start + Count;

        if (i < g_Process->m_NumImages)
        {
            ImageInfo* Image = g_Process->FindImageByIndex(i);
            while (i < g_Process->m_NumImages && i < End)
            {
                Image->FillModuleParameters(Params);
                Image = Image->m_Next;
                Params++;
                i++;
            }
        }

        if (i < End)
        {
            DEBUG_MODULE_PARAMETERS Param;

            SingleStatus = GetUnloadedModuleByIndex
                (i - g_Process->m_NumImages,
                 &Iter, NULL, &Param);
            if (SingleStatus != S_OK)
            {
                Iter = NULL;
            }
            while (i < End)
            {
                if (SingleStatus != S_OK)
                {
                    ZeroMemory(Params, sizeof(*Params));
                    Params->Base = DEBUG_INVALID_OFFSET;
                    Status = SingleStatus;
                }
                else
                {
                    *Params = Param;
                }
                Params++;

                if (Iter != NULL)
                {
                    SingleStatus = Iter->GetEntry(NULL, &Param);
                    if (SingleStatus == S_FALSE)
                    {
                        SingleStatus = E_INVALIDARG;
                    }
                }

                i++;
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSymbolModule(
    THIS_
    IN PCSTR Symbol,
    OUT PULONG64 Base
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        PCSTR ModEnd;
        ULONG Len;

        ModEnd = strchr(Symbol, '!');
        if (ModEnd == NULL)
        {
            Status = E_INVALIDARG;
        }
        else if (*(ModEnd+1) != '\0')
        {
            SYM_DUMP_PARAM_EX Param =
            {
                sizeof(Param), (PUCHAR)Symbol, DBG_DUMP_NO_PRINT, 0,
                NULL, NULL, NULL, 0, NULL
            };
            ULONG TypeStatus;
            TYPES_INFO TypeInfo;

            ZeroMemory(&TypeInfo, sizeof(TypeInfo));
            TypeStatus = TypeInfoFound(g_Process->m_SymHandle,
                                       g_Process->m_ImageHead,
                                       &Param, &TypeInfo);
            if (TypeStatus == NO_ERROR)
            {
                *Base = TypeInfo.ModBaseAddress;
            }
            Status = ResultFromTypeStatus(TypeStatus);
        }
        else
        {
            ImageInfo* Image;

            Status = E_NOINTERFACE;
            Len = (ULONG)(ModEnd - Symbol);
            for (Image = g_Process->m_ImageHead;
                 Image != NULL;
                 Image = Image->m_Next)
            {
                if (strlen(Image->m_ModuleName) == Len &&
                    !_memicmp(Symbol, Image->m_ModuleName, Len))
                {
                    *Base = Image->m_BaseOfImage;
                    Status = S_OK;
                    break;
                }
            }
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetTypeName(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        TYPES_INFO TypeInfo;
        ANSI_STRING TypeName;
        char TypeString[MAX_NAME];

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.TypeIndex = TypeId;
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeName.Buffer = TypeString;
        TypeName.Length = sizeof(TypeString);
        TypeName.MaximumLength = sizeof(TypeString);

        Status = ::GetTypeName(NULL, &TypeInfo, &TypeName);
        if (Status == S_OK)
        {
            Status = FillStringBuffer(TypeName.Buffer, TypeName.Length,
                                      NameBuffer, NameBufferSize, NameSize);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetConstantName(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG64 Value,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        TYPES_INFO TypeInfo;
        ANSI_STRING TypeName;
        char TypeString[MAX_NAME];

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.TypeIndex = TypeId;
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.Flag = SYMFLAG_VALUEPRESENT;
        TypeInfo.Value = Value;
        TypeName.Buffer = TypeString;
        TypeName.Length = sizeof(TypeString);
        TypeName.MaximumLength = sizeof(TypeString);

        Status = ::GetTypeName(NULL, &TypeInfo, &TypeName);
        if (Status == S_OK)
        {
            Status = FillStringBuffer(TypeName.Buffer, TypeName.Length,
                                      NameBuffer, NameBufferSize, NameSize);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

typedef struct _COPY_FIELD_NAME_CONTEXT {
    ULONG Called;
    ULONG IndexToMatch;
    PSTR NameBuffer;
    ULONG NameBufferSize;
    PULONG NameSize;
    HRESULT Status;
} COPY_FIELD_NAME_CONTEXT;

ULONG
CopyFieldName(
    PFIELD_INFO_EX pField,
    PVOID          Context
    )
{
    COPY_FIELD_NAME_CONTEXT* pInfo = (COPY_FIELD_NAME_CONTEXT *) Context;

    if (pInfo->Called++ == pInfo->IndexToMatch)
    {
        pInfo->Status = FillStringBuffer((PSTR) pField->fName, strlen((PCHAR) pField->fName)+1,
                                         pInfo->NameBuffer, pInfo->NameBufferSize, pInfo->NameSize);
        return FALSE;
    }
    return TRUE;
}

STDMETHODIMP
DebugClient::GetFieldName(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG FieldIndex,
    OUT OPTIONAL PSTR NameBuffer,
    IN ULONG NameBufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG TypeStatus;
        COPY_FIELD_NAME_CONTEXT FieldInfo =
        {
            0, FieldIndex, NameBuffer, NameBufferSize,
            NameSize, E_INVALIDARG
        };
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, DBG_DUMP_NO_PRINT | DBG_DUMP_CALL_FOR_EACH, 0,
            NULL, &FieldInfo, &CopyFieldName, 0, NULL
        };
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        if (TypeStatus == NO_ERROR)
        {
            Status = FieldInfo.Status;
        } else
        {
            Status = ResultFromTypeStatus(TypeStatus);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

#define ALL_TYPE_OPTIONS (DEBUG_TYPEOPTS_UNICODE_DISPLAY | DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY)

STDMETHODIMP
DebugClient::GetTypeOptions(
    THIS_
    OUT PULONG Options
    )
{
    ENTER_ENGINE();

    *Options = 0;

    *Options |= g_EnableUnicode ? DEBUG_TYPEOPTS_UNICODE_DISPLAY : 0;

    *Options |= g_EnableLongStatus ? DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY : 0;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::SetTypeOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_TYPE_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    g_EnableUnicode = Options & DEBUG_TYPEOPTS_UNICODE_DISPLAY;
    g_EnableLongStatus = Options & DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY;
    g_TypeOptions   = Options;

    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);

    LEAVE_ENGINE();
    return S_OK;

}

STDMETHODIMP
DebugClient::AddTypeOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_TYPE_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Options & DEBUG_TYPEOPTS_UNICODE_DISPLAY)
    {
        g_EnableUnicode = TRUE;
    }
    if (Options & DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY)
    {
        g_EnableLongStatus = TRUE;
    }
    g_TypeOptions |= Options;

    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::RemoveTypeOptions(
    THIS_
    IN ULONG Options
    )
{
    if (Options & ~ALL_TYPE_OPTIONS)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Options & DEBUG_TYPEOPTS_UNICODE_DISPLAY)
    {
        g_EnableUnicode = FALSE;
    }
    if (Options & DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY)
    {
        g_EnableLongStatus = FALSE;
    }

    g_TypeOptions &= ~Options;

    NotifyChangeSymbolState(DEBUG_CSS_TYPE_OPTIONS, 0, NULL);
    LEAVE_ENGINE();
    return S_OK;

}

STDMETHODIMP
DebugClient::GetTypeId(
    THIS_
    IN ULONG64 Module,
    IN PCSTR Name,
    OUT PULONG TypeId
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), (PUCHAR)Name, DBG_DUMP_NO_PRINT, 0,
            NULL, NULL, NULL, 0, NULL
        };
        TYPES_INFO TypeInfo;
        PCHAR QualName;

        TypeStatus = CANNOT_ALLOCATE_MEMORY;
        QualName = (PCHAR) malloc(strlen(Name) + 32);
        if (QualName)
        {
            if (!strchr(Name, '!'))
            {
                if (GetAllModuleName(Module, QualName, 30))
                {
                    strcat(QualName, "!");
                }
            }
            else // Already qualified name
            {
                *QualName = 0;
            }
            strcat(QualName, Name);

            TypeStatus = SYMBOL_TYPE_INFO_NOT_FOUND;
            Param.sName = (PUCHAR) QualName;
            ZeroMemory(&TypeInfo, sizeof(TypeInfo));
            TypeStatus = TypeInfoFound(g_Process->m_SymHandle,
                                       g_Process->m_ImageHead,
                                       &Param, &TypeInfo);
            if (TypeStatus == NO_ERROR)
            {
                *TypeId = TypeInfo.TypeIndex;
            }
        }
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetTypeSize(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT PULONG Size
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL,
            DBG_DUMP_NO_PRINT | DBG_DUMP_GET_SIZE_ONLY, 0,
            NULL, NULL, NULL, 0, NULL
        };
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        *Size = DumpType(&TypeInfo, &Param, &TypeStatus);
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetFieldOffset(
    THIS_
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PCSTR Field,
    OUT PULONG Offset
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        FIELD_INFO_EX FieldInfo =
        {
            (PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL
        };
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, DBG_DUMP_NO_PRINT, 0,
            NULL, NULL, NULL, 1, &FieldInfo
        };
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        if (TypeStatus == NO_ERROR)
        {
            *Offset = (ULONG)FieldInfo.address;
        }
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetSymbolTypeId(
    THIS_
    IN PCSTR Symbol,
    OUT PULONG TypeId,
    OUT OPTIONAL PULONG64 Module
    )
{
    ULONG TypeStatus;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        TypeStatus = TYPE_E_UNEXPECTED;
    }
    else
    {
        TYPES_INFO_ALL TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeStatus = !GetExpressionTypeInfo((PCHAR) Symbol, &TypeInfo);
        if (TypeStatus == NO_ERROR)
        {
            *TypeId = TypeInfo.TypeIndex;

            if (Module != NULL)
            {
                *Module = TypeInfo.Module;
            }
        }
    }

    LEAVE_ENGINE();
    return ResultFromTypeStatus(TypeStatus);
}

STDMETHODIMP
DebugClient::GetOffsetTypeId(
    THIS_
    IN ULONG64 Offset,
    OUT PULONG TypeId,
    OUT OPTIONAL PULONG64 Module
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, DBG_DUMP_NO_PRINT, Offset,
            NULL, NULL, NULL, 0, NULL
        };
        ULONG TypeStatus;
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeStatus = TypeInfoFound(g_Process->m_SymHandle,
                                   g_Process->m_ImageHead,
                                   &Param, &TypeInfo);
        if (TypeStatus == NO_ERROR)
        {
            *TypeId = TypeInfo.TypeIndex;

            if (Module != NULL)
            {
                *Module = TypeInfo.ModBaseAddress;
            }
        }
        Status = ResultFromTypeStatus(TypeStatus);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadTypedDataVirtual(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = ReadVirtual(Offset, Buffer, BufferSize,
                              BytesRead)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::WriteTypedDataVirtual(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = WriteVirtual(Offset, Buffer, BufferSize,
                               BytesWritten)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

#define ALL_OUTPUT_TYPE_FLAGS              \
    (DEBUG_OUTTYPE_NO_INDENT             | \
     DEBUG_OUTTYPE_NO_OFFSET             | \
     DEBUG_OUTTYPE_VERBOSE               | \
     DEBUG_OUTTYPE_COMPACT_OUTPUT        | \
     DEBUG_OUTTYPE_RECURSION_LEVEL(0xf)  | \
     DEBUG_OUTTYPE_ADDRESS_OF_FIELD      | \
     DEBUG_OUTTYPE_ADDRESS_AT_END        | \
     DEBUG_OUTTYPE_BLOCK_RECURSE )


ULONG
OutputTypeFlagsToDumpOptions(ULONG Flags)
{
    ULONG Options = 0;

    if (Flags & DEBUG_OUTTYPE_NO_INDENT)
    {
        Options |= DBG_DUMP_NO_INDENT;
    }
    if (Flags & DEBUG_OUTTYPE_NO_OFFSET)
    {
        Options |= DBG_DUMP_NO_OFFSET;
    }
    if (Flags & DEBUG_OUTTYPE_VERBOSE)
    {
        Options |= DBG_DUMP_VERBOSE;
    }
    if (Flags & DEBUG_OUTTYPE_COMPACT_OUTPUT)
    {
        Options |= DBG_DUMP_COMPACT_OUT;
    }
    if (Flags & DEBUG_OUTTYPE_ADDRESS_AT_END)
    {
        Options |= DBG_DUMP_ADDRESS_AT_END;
    }
    if (Flags & DEBUG_OUTTYPE_ADDRESS_OF_FIELD)
    {
        Options |= DBG_DUMP_ADDRESS_OF_FIELD;
    }
    if (Flags & DEBUG_OUTTYPE_BLOCK_RECURSE)
    {
        Options |= DBG_DUMP_BLOCK_RECURSE;
    }

    Options |= DBG_DUMP_RECUR_LEVEL(((Flags >> 4) & 0xf));

    return Options;
}

STDMETHODIMP
DebugClient::OutputTypedDataVirtual(
    THIS_
    IN ULONG OutputControl,
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG Flags
    )
{
    if (Flags & ~ALL_OUTPUT_TYPE_FLAGS)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, OutputTypeFlagsToDumpOptions(Flags), Offset,
            NULL, NULL, NULL, 0, NULL
        };
        ULONG TypeStatus;
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        Status = ResultFromTypeStatus(TypeStatus);

        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ReadTypedDataPhysical(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = ReadPhysical(Offset, Buffer, BufferSize,
                               BytesRead)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::WriteTypedDataPhysical(
    THIS_
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    HRESULT Status;
    ULONG Size;

    if ((Status = GetTypeSize(Module, TypeId, &Size)) != S_OK)
    {
        return Status;
    }
    if (Size < BufferSize)
    {
        BufferSize = Size;
    }
    if ((Status = WritePhysical(Offset, Buffer, BufferSize,
                                BytesWritten)) != S_OK)
    {
        return Status;
    }
    return Size > BufferSize ? S_FALSE : S_OK;
}

STDMETHODIMP
DebugClient::OutputTypedDataPhysical(
    THIS_
    IN ULONG OutputControl,
    IN ULONG64 Offset,
    IN ULONG64 Module,
    IN ULONG TypeId,
    IN ULONG Flags
    )
{
    if (Flags & ~ALL_OUTPUT_TYPE_FLAGS)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    OutCtlSave OldCtl;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!PushOutCtl(OutputControl, this, &OldCtl))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        SYM_DUMP_PARAM_EX Param =
        {
            sizeof(Param), NULL, OutputTypeFlagsToDumpOptions(Flags) |
            DBG_DUMP_READ_PHYSICAL, Offset, NULL, NULL, NULL, 0, NULL
        };
        ULONG TypeStatus;
        TYPES_INFO TypeInfo;

        ZeroMemory(&TypeInfo, sizeof(TypeInfo));
        TypeInfo.hProcess = g_Process->m_SymHandle;
        TypeInfo.ModBaseAddress = Module;
        TypeInfo.TypeIndex = TypeId;
        DumpType(&TypeInfo, &Param, &TypeStatus);
        Status = ResultFromTypeStatus(TypeStatus);

        PopOutCtl(&OldCtl);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetScope(
    THIS_
    OUT OPTIONAL PULONG64 InstructionOffset,
    OUT OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
    OUT OPTIONAL PVOID ScopeContext,
    IN ULONG ScopeContextSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }

    Status = S_OK;

    // windbg requests the scope IP and only the scope
    // IP at every event.  If the scope is a default lazy
    // scope we can satisfy that request very efficiently.
    if (g_ScopeBuffer.State == ScopeDefaultLazy &&
        InstructionOffset &&
        !ScopeFrame &&
        (!ScopeContext ||
         ScopeContextSize == 0))
    {
        ADDR Addr;

        g_Machine->GetPC(&Addr);
        *InstructionOffset = Flat(Addr);
        goto Exit;
    }

    PDEBUG_SCOPE Scope;

    Scope = GetCurrentScope();

    if (InstructionOffset)
    {
        *InstructionOffset = Scope->Frame.InstructionOffset;
    }

    if (ScopeFrame)
    {
        *ScopeFrame = Scope->Frame;
    }

    if (ScopeContext)
    {
        if (Scope->State == ScopeFromContext)
        {
            memcpy(ScopeContext, &Scope->Context,
                   min(sizeof(Scope->Context), ScopeContextSize));
        }
        else if (g_Machine->GetContextState(MCTX_FULL) == S_OK)
        {
            memcpy(ScopeContext, &g_Machine->m_Context,
                   min(sizeof(g_Machine->m_Context), ScopeContextSize));
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetScope(
    THIS_
    IN ULONG64 InstructionOffset,
    IN OPTIONAL PDEBUG_STACK_FRAME ScopeFrame,
    IN OPTIONAL PVOID ScopeContext,
    IN ULONG ScopeContextSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        DEBUG_STACK_FRAME LocalFrame;

        if (ScopeFrame)
        {
            LocalFrame = *ScopeFrame;
        }
        else
        {
            ZeroMemory(&LocalFrame, sizeof(LocalFrame));
            LocalFrame.InstructionOffset = InstructionOffset;
        }

        Status = SetCurrentScope(&LocalFrame, ScopeContext, ScopeContextSize) ?
            S_FALSE : S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::ResetScope(
    THIS
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ResetCurrentScope();
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetScopeSymbolGroup(
    THIS_
    IN ULONG Flags,
    IN OPTIONAL PDEBUG_SYMBOL_GROUP Update,
    OUT PDEBUG_SYMBOL_GROUP* Symbols
    )
{
    HRESULT Status;

    if (Flags == 0 ||
        (Flags & ~DEBUG_SCOPE_GROUP_ALL))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (Update)
    {
        if (!IS_CUR_MACHINE_ACCESSIBLE())
        {
            Status = E_UNEXPECTED;
        }
        else if (Flags != DEBUG_SCOPE_GROUP_LOCALS &&
                 Flags != DEBUG_SCOPE_GROUP_ARGUMENTS)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            Status = ((DebugSymbolGroup *)Update)->AddCurrentLocals();
            if (Status == S_OK)
            {
                *Symbols = Update;
            }
        }
    }
    else
    {
        *Symbols = new DebugSymbolGroup(this, Flags);
        if (*Symbols != NULL)
        {
            Status = S_OK;
        }
        else
        {
            Status = E_OUTOFMEMORY;
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::CreateSymbolGroup(
    THIS_
    OUT PDEBUG_SYMBOL_GROUP* Group
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    *Group = new DebugSymbolGroup(this, 0);
    if (*Group == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        Status = S_OK;
    }

    LEAVE_ENGINE();
    return Status;
}

struct SymbolMatch
{
    ProcessInfo* Process;
    BOOL SingleMod;
    ImageInfo* Mod;
    PCHAR Storage, StorageEnd;
    PCHAR Cur, End;
    char Pattern[1];
};

STDMETHODIMP
DebugClient::StartSymbolMatch(
    THIS_
    IN PCSTR Pattern,
    OUT PULONG64 Handle
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
        goto EH_Exit;
    }

    ImageInfo* Mod;
    PCSTR Sym;

    // Check for a module qualifier.
    Sym = strchr(Pattern, '!');
    if (Sym != NULL)
    {
        size_t ModLen = Sym - Pattern;

        if (ModLen == 0)
        {
            Status = E_INVALIDARG;
            goto EH_Exit;
        }

        Mod = g_Process->FindImageByName(Pattern, ModLen, INAME_MODULE, FALSE);
        if (Mod == NULL)
        {
            Status = E_NOINTERFACE;
            goto EH_Exit;
        }

        Sym++;
    }
    else
    {
        Sym = Pattern;
        Mod = NULL;
    }

    ULONG SymLen;
    SymLen = strlen(Sym);
    SymbolMatch* Match;
    Match = (SymbolMatch*)malloc(sizeof(SymbolMatch) + SymLen);
    if (Match == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Exit;
    }

    if (Mod == NULL)
    {
        Match->Process = g_Process;
        Match->Mod = Match->Process->m_ImageHead;
        Match->SingleMod = FALSE;
    }
    else
    {
        Match->Process = g_Process;
        Match->Mod = Mod;
        Match->SingleMod = TRUE;
    }

    Match->Storage = NULL;
    Match->StorageEnd = NULL;
    Match->Cur = NULL;
    strcpy(Match->Pattern, Sym);
    _strupr(Match->Pattern);

    *Handle = (ULONG64)Match;
    Status = S_OK;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

#define STORAGE_INC 16384

BOOL CALLBACK
FillMatchStorageCb(PSTR Name, ULONG64 Offset, ULONG Size, PVOID Context)
{
    SymbolMatch* Match = (SymbolMatch*)Context;
    ULONG NameLen = strlen(Name) + 1;
    ULONG RecordLen = NameLen + sizeof(ULONG64);

    if (Match->Cur + RecordLen > Match->StorageEnd)
    {
        PCHAR NewStore;
        size_t NewLen;

        NewLen = (Match->StorageEnd - Match->Storage) + STORAGE_INC;
        NewStore = (PCHAR)realloc(Match->Storage, NewLen);
        if (NewStore == NULL)
        {
            // Terminate the enumeration since there's no more room.
            // This produces a silent failure but it's not
            // important enough to warrant a true failure.
            return FALSE;
        }

        Match->Cur = NewStore + (Match->Cur - Match->Storage);

        Match->Storage = NewStore;
        Match->StorageEnd = NewStore + NewLen;

        DBG_ASSERT(Match->Cur + RecordLen <= Match->StorageEnd);
    }

    strcpy(Match->Cur, Name);
    Match->Cur += NameLen;
    *(ULONG64 UNALIGNED *)Match->Cur = Offset;
    Match->Cur += sizeof(Offset);

    return TRUE;
}

STDMETHODIMP
DebugClient::GetNextSymbolMatch(
    THIS_
    IN ULONG64 Handle,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG MatchSize,
    OUT OPTIONAL PULONG64 Offset
    )
{
    ENTER_ENGINE();

    SymbolMatch* Match = (SymbolMatch*)Handle;
    HRESULT Status = E_NOINTERFACE;

    // Loop until a matching symbol is found.
    for (;;)
    {
        if (Match->Mod == NULL)
        {
            // Nothing more to enumerate.
            // Status is already set.
            break;
        }

        if (Match->Cur == NULL)
        {
            // Enumerate all symbols and stash them away.
            Match->Cur = Match->Storage;

            if (!SymEnumerateSymbols64(Match->Process->m_SymHandle,
                                       Match->Mod->m_BaseOfImage,
                                       FillMatchStorageCb, Match))
            {
                Status = WIN32_LAST_STATUS();
                break;
            }

            Match->End = Match->Cur;
            Match->Cur = Match->Storage;
        }

        while (Match->Cur < Match->End)
        {
            PCHAR Name;
            ULONG64 Addr;

            Name = Match->Cur;
            Match->Cur += strlen(Name) + 1;
            Addr = *(ULONG64 UNALIGNED *)Match->Cur;
            Match->Cur += sizeof(Addr);

            // If this symbol matches remember it for return.
            if (MatchPattern(Name, Match->Pattern))
            {
                char Sym[MAX_MODULE + MAX_SYMBOL_LEN + 1];

                CopyString(Sym, Match->Mod->m_ModuleName, DIMA(Sym));
                CatString(Sym, "!", DIMA(Sym));
                CatString(Sym, Name, DIMA(Sym));

                Status = FillStringBuffer(Sym, 0, Buffer, BufferSize,
                                          MatchSize);

                if (Buffer == NULL)
                {
                    // Do not advance the enumeration as this
                    // is just a size test.
                    Match->Cur = Name;
                }

                if (Offset != NULL)
                {
                    *Offset = Addr;
                }

                break;
            }
        }

        if (SUCCEEDED(Status))
        {
            break;
        }

        if (Match->SingleMod)
        {
            Match->Mod = NULL;
        }
        else
        {
            Match->Mod = Match->Mod->m_Next;
        }
        Match->Cur = NULL;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::EndSymbolMatch(
    THIS_
    IN ULONG64 Handle
    )
{
    ENTER_ENGINE();

    SymbolMatch* Match = (SymbolMatch*)Handle;

    if (Match->Storage != NULL)
    {
        free(Match->Storage);
    }
    free(Match);

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugClient::Reload(
    THIS_
    IN PCSTR Module
    )
{
    ENTER_ENGINE();

    PCSTR ArgsRet;
    HRESULT Status = g_Target->Reload(g_Thread, Module, &ArgsRet);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSymbolPath(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PathSize
    )
{
    ENTER_ENGINE();

    HRESULT Status =
        FillStringBuffer(g_SymbolSearchPath, 0,
                         Buffer, BufferSize, PathSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSymbolPath(
    THIS_
    IN PCSTR Path
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    Status = ChangeSymPath(Path, FALSE, NULL, 0) ?
        S_OK : E_OUTOFMEMORY;
    if (Status == S_OK)
    {
        CheckPath(g_SymbolSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AppendSymbolPath(
    THIS_
    IN PCSTR Addition
    )
{
    ENTER_ENGINE();

    HRESULT Status;

    Status = ChangeSymPath(Addition, TRUE, NULL, 0) ?
        S_OK : E_OUTOFMEMORY;
    if (Status == S_OK)
    {
        CheckPath(g_SymbolSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetImagePath(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PathSize
    )
{
    ENTER_ENGINE();

    HRESULT Status = FillStringBuffer(g_ExecutableImageSearchPath, 0,
                                      Buffer, BufferSize, PathSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetImagePath(
    THIS_
    IN PCSTR Path
    )
{
    ENTER_ENGINE();

    HRESULT Status = ChangePath(&g_ExecutableImageSearchPath, Path, FALSE,
                                DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_ExecutableImageSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AppendImagePath(
    THIS_
    IN PCSTR Addition
    )
{
    ENTER_ENGINE();

    HRESULT Status = ChangePath(&g_ExecutableImageSearchPath, Addition, TRUE,
                                DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_ExecutableImageSearchPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSourcePath(
    THIS_
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG PathSize
    )
{
    ENTER_ENGINE();

    HRESULT Status = FillStringBuffer(g_SrcPath, 0,
                                      Buffer, BufferSize, PathSize);

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetSourcePathElement(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG ElementSize
    )
{
    ENTER_ENGINE();

    HRESULT Status;
    PSTR Elt, EltEnd;

    Elt = FindPathElement(g_SrcPath, Index, &EltEnd);
    if (Elt == NULL)
    {
        Status = E_NOINTERFACE;
        goto EH_Exit;
    }

    CHAR Save;
    Save = *EltEnd;
    *EltEnd = 0;
    Status = FillStringBuffer(Elt, (ULONG)(EltEnd - Elt) + 1,
                              Buffer, BufferSize, ElementSize);
    *EltEnd = Save;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::SetSourcePath(
    THIS_
    IN PCSTR Path
    )
{
    ENTER_ENGINE();

    HRESULT Status = ChangePath(&g_SrcPath, Path, FALSE, DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_SrcPath);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::AppendSourcePath(
    THIS_
    IN PCSTR Addition
    )
{
    ENTER_ENGINE();

    HRESULT Status = ChangePath(&g_SrcPath, Addition, TRUE, DEBUG_CSS_PATHS);
    if (Status == S_OK)
    {
        CheckPath(g_SrcPath);
    }

    LEAVE_ENGINE();
    return Status;
}

HRESULT
GetCanonicalPath(PCSTR Path, PSTR Canon, ULONG CanonSize)
{
    // First make sure it's a full path.
    // XXX drewb - Probably should also convert drive
    // letters to unambiguous names.
    if (!IS_SLASH(Path[0]) &&
        !(((Path[0] >= 'a' && Path[0] <= 'z') ||
           (Path[0] >= 'A' && Path[0] <= 'Z')) &&
          Path[1] == ':') &&
        !IsUrlPathComponent(Path))
    {
        DWORD FullLen;
        PSTR FilePart;

        FullLen = GetFullPathName(Path, CanonSize, Canon, &FilePart);
        if (FullLen == 0 || FullLen >= CanonSize)
        {
            return WIN32_LAST_STATUS();
        }
    }
    else
    {
        CopyString(Canon, Path, CanonSize);
    }

    // Now remove '.' and '..'.  This is a full path with a filename
    // at the end so all occurrences must be bracketed with
    // path slashes.
    PSTR Rd = Canon, Wr = Canon;

    while (*Rd != 0)
    {
        if (IS_SLASH(*Rd))
        {
            if (Rd[1] == '.')
            {
                if (IS_SLASH(Rd[2]))
                {
                    // Found /./, ignore leading /. and continue
                    // with /.
                    Rd += 2;
                    continue;
                }
                else if (Rd[2] == '.' && IS_SLASH(Rd[3]))
                {
                    // Found /../ so back up one path component
                    // and continue with /.
                    do
                    {
                        Wr--;
                    }
                    while (Wr >= Canon && !IS_PATH_DELIM(*Wr));
                    DBG_ASSERT(Wr >= Canon);

                    Rd += 3;
                    continue;
                }
            }
        }

        *Wr++ = *Rd++;
    }
    *Wr = 0;

    return S_OK;
}

STDMETHODIMP
DebugClient::FindSourceFile(
    THIS_
    IN ULONG StartElement,
    IN PCSTR File,
    IN ULONG Flags,
    OUT OPTIONAL PULONG FoundElement,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG FoundSize
    )
{
    if (Flags & ~(DEBUG_FIND_SOURCE_DEFAULT |
                  DEBUG_FIND_SOURCE_FULL_PATH |
                  DEBUG_FIND_SOURCE_BEST_MATCH))
    {
        return E_INVALIDARG;
    }

    HRESULT Status;
    char RwFile[MAX_SOURCE_PATH];
    ULONG FileLen;
    char Found[MAX_SOURCE_PATH];
    PSTR MatchPart;
    ULONG Elt;

    // Make a read-write copy of the file as the searching
    // modifies it.
    FileLen = strlen(File) + 1;
    if (FileLen > sizeof(RwFile))
    {
        return E_INVALIDARG;
    }
    memcpy(RwFile, File, FileLen);

    ENTER_ENGINE();

    if (FindSrcFileOnPath(StartElement, RwFile, Flags, Found, DIMA(Found),
                          &MatchPart, &Elt))
    {
        if (Flags & DEBUG_FIND_SOURCE_FULL_PATH)
        {
            Status = GetCanonicalPath(Found, RwFile, DIMA(RwFile));
            if (Status != S_OK)
            {
                goto EH_Exit;
            }

            strcpy(Found, RwFile);
        }

        if (FoundElement != NULL)
        {
            *FoundElement = Elt;
        }
        Status = FillStringBuffer(Found, 0,
                                  Buffer, BufferSize, FoundSize);
    }
    else
    {
        Status = E_NOINTERFACE;
    }

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

// XXX drewb - This API is private for the moment due
// to uncertainty about what dbghelp's API is going to
// look like in the long term.
extern "C"
ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    IN  HANDLE                  hProcess,
    IN  LPSTR                   ModuleName,
    IN  LPSTR                   FileName,
    OUT PDWORD64                Buffer,
    IN  ULONG                   BufferLines
    );

STDMETHODIMP
DebugClient::GetSourceFileLineOffsets(
    THIS_
    IN PCSTR File,
    OUT OPTIONAL PULONG64 Buffer,
    IN ULONG BufferLines,
    OUT OPTIONAL PULONG FileLines
    )
{
    HRESULT Status;
    ULONG Line;

    if (Buffer != NULL)
    {
        // Initialize map to empty.
        for (Line = 0; Line < BufferLines; Line++)
        {
            Buffer[Line] = DEBUG_INVALID_OFFSET;
        }
    }

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
        goto EH_Exit;
    }

    PSTR FilePart;
    ULONG HighestLine;

    // Request the line information from dbghelp.
    FilePart = (PSTR)File;
    HighestLine =
        SymGetFileLineOffsets64(g_Process->m_SymHandle, NULL, FilePart,
                                Buffer, BufferLines);
    if (HighestLine == 0xffffffff)
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Exit;
    }

    if (HighestLine == 0)
    {
        // Try again with just the filename because the path
        // may be different than what's in the symbol information.
        // XXX drewb - This can cause ambiguity problems.
        FilePart = (PSTR)File + strlen(File) - 1;
        while (FilePart >= File)
        {
            if (IS_PATH_DELIM(*FilePart))
            {
                break;
            }

            FilePart--;
        }
        FilePart++;
        if (FilePart <= File)
        {
            // No path and no information was found for the
            // given file so return not-found.
            Status = E_NOINTERFACE;
            goto EH_Exit;
        }

        HighestLine =
            SymGetFileLineOffsets64(g_Process->m_SymHandle, NULL, FilePart,
                                    Buffer, BufferLines);
        if (HighestLine == 0xffffffff)
        {
            Status = WIN32_LAST_STATUS();
            goto EH_Exit;
        }
        else if (HighestLine == 0)
        {
            Status = E_NOINTERFACE;
            goto EH_Exit;
        }
    }

    if (FileLines != NULL)
    {
        *FileLines = HighestLine;
    }

    // Return S_FALSE if lines were missed because of
    // insufficient buffer space.
    Status = HighestLine > BufferLines ? S_FALSE : S_OK;

 EH_Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleVersionInformation(
    THIS_
    IN ULONG Index,
    IN ULONG64 Base,
    IN PCSTR Item,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG VerInfoSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ImageInfo* Image;

        if (Index == DEBUG_ANY_ID)
        {
            Image = g_Process->FindImageByOffset(Base, FALSE);
        }
        else
        {
            Image = g_Process->FindImageByIndex(Index);
        }
        if (Image == NULL)
        {
            Status = E_NOINTERFACE;
        }
        else
        {
            Status = g_Target->
                GetImageVersionInformation(g_Process, Image->m_ImagePath,
                                           Image->m_BaseOfImage, Item,
                                           Buffer, BufferSize, VerInfoSize);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugClient::GetModuleNameString(
    THIS_
    IN ULONG Which,
    IN ULONG Index,
    IN ULONG64 Base,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    if (Which > DEBUG_MODNAME_MAPPED_IMAGE)
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    if (g_Process == NULL)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        ULONG Idx = 0;

        Status = E_NOINTERFACE;

        ImageInfo* Image = g_Process->m_ImageHead;
        while (Image != NULL)
        {
            if ((Index != DEBUG_ANY_ID && Idx == Index) ||
                (Index == DEBUG_ANY_ID && Base == Image->m_BaseOfImage))
            {
                PSTR Str;
                IMAGEHLP_MODULE64 ModInfo;

                switch(Which)
                {
                case DEBUG_MODNAME_IMAGE:
                    Str = Image->m_ImagePath;
                    break;
                case DEBUG_MODNAME_MODULE:
                    Str = Image->m_ModuleName;
                    break;
                case DEBUG_MODNAME_LOADED_IMAGE:
                    ModInfo.SizeOfStruct = sizeof(ModInfo);
                    if (!SymGetModuleInfo64(g_Process->m_SymHandle,
                                            Image->m_BaseOfImage, &ModInfo))
                    {
                        Status = WIN32_LAST_STATUS();
                        goto Exit;
                    }
                    Str = ModInfo.LoadedImageName;
                    break;
                case DEBUG_MODNAME_SYMBOL_FILE:
                    ModInfo.SizeOfStruct = sizeof(ModInfo);
                    if (!SymGetModuleInfo64(g_Process->m_SymHandle,
                                            Image->m_BaseOfImage, &ModInfo))
                    {
                        Status = WIN32_LAST_STATUS();
                        goto Exit;
                    }
                    Str = ModInfoSymFile(&ModInfo);
                    break;
                case DEBUG_MODNAME_MAPPED_IMAGE:
                    Str = Image->m_MappedImagePath;
                    break;
                }

                Status = FillStringBuffer(Str, 0,
                                          Buffer, BufferSize, NameSize);
                break;
            }

            Image = Image->m_Next;
            Idx++;
        }
    }

 Exit:
    LEAVE_ENGINE();
    return Status;
}

//----------------------------------------------------------------------------
//
// SymbolGroupEntry.
//
//----------------------------------------------------------------------------

SymbolGroupEntry::SymbolGroupEntry(void)
{
    m_Parent = NULL;
    m_Next = NULL;
    m_Format = NULL;
    m_Expr = NULL;
    m_Cast = NULL;
    ZeroMemory(&m_Params, sizeof(m_Params));
    m_Flags = 0;
    ZeroMemory(&m_BaseData, sizeof(m_BaseData));
    m_BaseFormatKind = SGFORMAT_TYPED_DATA;
}

SymbolGroupEntry::~SymbolGroupEntry(void)
{
    free(m_Expr);
    free(m_Cast);
    delete m_Format;
}

//----------------------------------------------------------------------------
//
// SymbolGroupFormat.
//
//----------------------------------------------------------------------------

SymbolGroupFormat::SymbolGroupFormat(SymbolGroupEntry* Entry,
                                     SymbolGroupFormatKind Kind)
{
    m_Entry = Entry;
    m_Kind = Kind;
    // There's no expression to start with so
    // start in an error state.
    m_ExprErr = NOTFOUND;
    m_ValueErr = NOTFOUND;
}

SymbolGroupFormat::~SymbolGroupFormat(void)
{
}

void
SymbolGroupFormat::TestImages(void)
{
    ImageInfo* Image;

    if (m_Entry->m_Params.Module == 0)
    {
        Image = NULL;
    }
    else
    {
        Image = g_Process ?
            g_Process->FindImageByOffset(m_Entry->m_Params.Module, FALSE) :
            NULL;
    }
    if (Image != m_Entry->m_BaseData.m_Image)
    {
        // The module list has changed, avoid
        // referencing a possibly invalid image.
        m_Entry->m_BaseData.ReleaseImage();
    }
}

//---------------------------------------------------------------------------
//
// TypedDataSymbolGroupFormat.
//
//----------------------------------------------------------------------------

struct TdccContext
{
    DebugSymbolGroup* Group;
    TypedDataSymbolGroupFormat* Format;
    SymbolGroupEntry* AddAfter;
    ULONG NumChildren;
};

ULONG
TypedDataSymbolGroupFormat::CreateChildren(DebugSymbolGroup* Group)
{
    if (m_ExprErr)
    {
        return m_ExprErr;
    }

    if (!m_Entry->m_Params.SubElements)
    {
        return NOTFOUND;
    }

    ULONG Err;
    TdccContext Context;

    Context.Group = Group;
    Context.Format = this;
    Context.AddAfter = m_Entry;
    Context.NumChildren = 0;
    // We don't need the actual data for children here,
    // just the children themselves.  This allows nodes
    // to be expanded even when they refer to invalid
    // memory.
    // The children's values will be updated on the next Refresh.
    if (Err = m_CastData.GetChildren(g_Machine->m_Ptr64 ? 8 : 4,
                                     CHLF_DEREF_UDT_POINTERS |
                                     CHLF_DISALLOW_ACCESS,
                                     CreateChildrenCb, &Context))
    {
        return Err;
    }

    // The estimated child count may have been different from
    // the actual child count so update it.
    m_Entry->m_Params.SubElements = Context.NumChildren;

    return NO_ERROR;
}

ULONG
TypedDataSymbolGroupFormat::AddChild(SymbolGroupEntry** AddAfter,
                                     PSTR Name, TypedData* Data)
{
    SymbolGroupEntry* Child = new SymbolGroupEntry;
    TypedDataSymbolGroupFormat* ChildFormat =
        new TypedDataSymbolGroupFormat(Child);
    if (!Child || !ChildFormat)
    {
        delete Child;
        return NOMEMORY;
    }

    Child->m_Format = ChildFormat;

    Child->m_Expr = _strdup(Name);
    if (!Child->m_Expr)
    {
        delete Child;
        return NOMEMORY;
    }

    Child->m_Parent = m_Entry;
    Child->m_Params.Flags =
        (m_Entry->m_Params.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) + 1;
    Child->m_Next = (*AddAfter)->m_Next;
    Child->m_BaseData = *Data;
    Child->m_BaseFormatKind = SGFORMAT_TYPED_DATA;
    ChildFormat->m_ExprErr = NO_ERROR;
    ChildFormat->m_CastData = *Data;
    ChildFormat->UpdateParams();
    (*AddAfter)->m_Next = Child;
    *AddAfter = Child;

    return NO_ERROR;
}

ULONG
TypedDataSymbolGroupFormat::CreateChildrenCb(PVOID _Context,
                                             PSTR Name, TypedData* Child)
{
    ULONG Err;
    TdccContext* Context = (TdccContext*)_Context;

    Err = Context->Format->AddChild(&Context->AddAfter, Name, Child);
    if (!Err)
    {
        Context->Group->m_NumEntries++;
        Context->NumChildren++;
    }

    return Err;
}

ULONG
TypedDataSymbolGroupFormat::Refresh(TypedDataAccess AllowAccess)
{
    ULONG64 OldPtr = m_CastData.m_Ptr;

    if (m_ExprErr)
    {
        return m_ExprErr;
    }

    m_ValueErr = m_CastData.ReadData(AllowAccess);
    if (m_ValueErr)
    {
        return m_ValueErr;
    }

    if (m_CastData.IsPointer() &&
        m_CastData.m_Ptr != OldPtr)
    {
        RefreshChildren();
    }

    return NO_ERROR;
}

ULONG
TypedDataSymbolGroupFormat::Write(PCSTR Value)
{
    if (m_ExprErr)
    {
        return m_ExprErr;
    }

    g_DisableErrorPrint++;
    EvalExpression* RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;

    __try
    {
        TypedData Source;

        EvalExpression* Eval = GetEvaluator(DEBUG_EXPR_CPLUSPLUS, FALSE);
        Eval->Evaluate(Value, NULL, EXPRF_DEFAULT, &Source);
        ReleaseEvaluator(Eval);

        if (!(m_ValueErr = Source.ConvertToSource(&m_CastData)) &&
            !(m_ValueErr = m_CastData.WriteData(&Source, TDACC_REQUIRE)))
        {
            m_CastData.CopyData(&Source);
        }
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        m_ValueErr = GetExceptionCode() - COMMAND_EXCEPTION_BASE;
    }

    g_EvalReleaseChain = RelChain;
    g_DisableErrorPrint--;
    return m_ValueErr;
}

void
TypedDataSymbolGroupFormat::OutputValue(void)
{
    ULONG Tag;

    if (m_ValueErr)
    {
        // windbg puts dummy entries with no expression
        // in symbol groups and expects no output from them,
        // so special case that.
        if (!m_Entry->m_Expr || *m_Entry->m_Expr)
        {
            dprintf("<%s error>", ErrorString(m_ValueErr));
        }
        return;
    }

    m_CastData.OutputSimpleValue();

    // For symbol groups we automatically dereference
    // pointers to UDTs for convenience.  Display the
    // UDT type in the value for UDT pointers as there won't be
    // a normal pointer child to display the type.
    if (m_CastData.IsPointer() &&
        m_CastData.m_Image &&
        SymGetTypeInfo(m_CastData.m_Image->m_Process->m_SymHandle,
                       m_CastData.m_Image->m_BaseOfImage,
                       m_CastData.m_NextType, TI_GET_SYMTAG, &Tag) &&
        Tag == SymTagUDT)
    {
        TypedData Deref = m_CastData;
        if (!Deref.ConvertToDereference(TDACC_NONE,
                                        g_Machine->m_Ptr64 ? 8 : 4))
        {
            dprintf(" ");
            Deref.OutputType();
            dprintf(" *");
        }
    }
}

void
TypedDataSymbolGroupFormat::OutputOffset(void)
{
    if (m_ExprErr)
    {
        // Error message will be shown elsewhere.
        return;
    }

    if (m_CastData.m_DataSource == TDATA_NONE)
    {
        return;
    }

    if (m_CastData.m_DataSource & TDATA_REGISTER)
    {
        dprintf("@%s", RegNameFromIndex(m_CastData.m_SourceRegister));
    }
    else
    {
        ULONG Err;
        ULONG64 Addr;

        if (Err = m_CastData.GetAbsoluteAddress(&Addr))
        {
            // No address.
        }
        else
        {
            dprintf("%s", FormatAddr64(Addr));

            if (m_CastData.m_DataSource & TDATA_BITFIELD)
            {
                dprintf(" %d..%d",
                        m_CastData.m_BitPos,
                        m_CastData.m_BitPos + m_CastData.m_BitSize - 1);
            }
        }
    }
}

void
TypedDataSymbolGroupFormat::OutputType(void)
{
    if (m_ExprErr)
    {
        // Error message will be shown elsewhere.
        return;
    }

    m_CastData.OutputType();
}

struct TdrcContext
{
    SymbolGroupEntry* Parent;
    SymbolGroupEntry* Child;
};

SymbolGroupEntry*
TypedDataSymbolGroupFormat::RefreshChildren(void)
{
    if (!(m_Entry->m_Params.Flags & DEBUG_SYMBOL_EXPANDED))
    {
        return m_Entry->m_Next;
    }

    TdrcContext Context;

    Context.Parent = m_Entry;
    Context.Child = m_Entry->m_Next;

    m_CastData.GetChildren(g_Machine->m_Ptr64 ? 8 : 4,
                           CHLF_DEREF_UDT_POINTERS |
                           CHLF_DISALLOW_ACCESS,
                           RefreshChildrenCb, &Context);
    return Context.Child;
}

ULONG
TypedDataSymbolGroupFormat::RefreshChildrenCb(PVOID _Context,
                                              PSTR Name, TypedData* Child)
{
    TdrcContext* Context = (TdrcContext*)_Context;

    // The assumption is that the child information gathered
    // by this enumeration will be the same as the original
    // child information so every callback should have a
    // matching child entry.  Check just to be sure, though.
    if (Context->Child &&
        Context->Child->m_Parent == Context->Parent)
    {
        if (Context->Child->m_BaseFormatKind == SGFORMAT_TYPED_DATA &&
            !strcmp(Name, Context->Child->m_Expr))
        {
            Context->Child->m_BaseData = *Child;
            if (Context->Child->m_Format->m_Kind == SGFORMAT_TYPED_DATA)
            {
                ((TypedDataSymbolGroupFormat*)Context->Child->m_Format)->
                    m_CastData.CopyDataSource(Child);
            }
        }

        // Pass on the refresh to all children.
        if (Context->Child->m_Format->m_Kind == SGFORMAT_TYPED_DATA)
        {
            Context->Child =
                ((TypedDataSymbolGroupFormat*)Context->Child->m_Format)->
                RefreshChildren();
        }
        else
        {
            Context->Child = Context->Child->m_Next;
        }
    }

    //
    // Look for the next sibling.
    //

    ULONG ParentLevel =
        Context->Parent->m_Params.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK;

    while (Context->Child &&
           (Context->Child->m_Params.Flags &
            DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) > ParentLevel + 1)
    {
        Context->Child = Context->Child->m_Next;
    }

    return NO_ERROR;
}

void
TypedDataSymbolGroupFormat::UpdateParams(void)
{
    ULONG NameUsed;

    if (m_ExprErr)
    {
        m_Entry->m_Params.Module = 0;
        m_Entry->m_Params.TypeId = 0;
        m_Entry->m_Params.SubElements = 0;
        m_Entry->m_Params.Flags &= ~(DEBUG_SYMBOL_IS_ARRAY |
                                     DEBUG_SYMBOL_IS_FLOAT |
                                     DEBUG_SYMBOL_READ_ONLY);
        return;
    }

    m_Entry->m_Params.Module = m_CastData.m_Image ?
        m_CastData.m_Image->m_BaseOfImage : 0;
    m_Entry->m_Params.TypeId = m_CastData.m_Type;
    // If this node was ever expanded the true child count has
    // been determined and set.  Otherwise make a quick guess.
    // If the true child count is zero the estimate will be done
    // repeatedly but should be fast as there are no children.
    if (!m_Entry->m_Params.SubElements &&
        m_CastData.EstimateChildrenCounts(CHLF_DEREF_UDT_POINTERS,
                                          &m_Entry->m_Params.SubElements,
                                          &NameUsed))
    {
        m_Entry->m_Params.SubElements = 0;
    }
    m_Entry->m_Params.Flags &= ~(DEBUG_SYMBOL_IS_ARRAY |
                                 DEBUG_SYMBOL_IS_FLOAT |
                                 DEBUG_SYMBOL_READ_ONLY);
    if (m_CastData.IsArray())
    {
        m_Entry->m_Params.Flags |= DEBUG_SYMBOL_IS_ARRAY;
    }
    else if (m_CastData.IsFloat())
    {
        m_Entry->m_Params.Flags |= DEBUG_SYMBOL_IS_FLOAT;
    }
    if (!m_CastData.IsWritable())
    {
        m_Entry->m_Params.Flags |= DEBUG_SYMBOL_READ_ONLY;
    }
}

void
TypedDataSymbolGroupFormat::TestImages(void)
{
    ImageInfo* Image;

    if (m_Entry->m_Params.Module == 0)
    {
        Image = NULL;
    }
    else
    {
        Image = g_Process ?
            g_Process->FindImageByOffset(m_Entry->m_Params.Module, FALSE) :
            NULL;
    }
    if (Image != m_CastData.m_Image)
    {
        // The module list has changed, avoid
        // referencing a possibly invalid image.
        m_Entry->m_BaseData.ReleaseImage();
        m_CastType.ReleaseImage();
        m_CastData.ReleaseImage();
    }
}

//----------------------------------------------------------------------------
//
// ExprSymbolGroupFormat.
//
//----------------------------------------------------------------------------

ULONG
ExprSymbolGroupFormat::Refresh(TypedDataAccess AllowAccess)
{
    g_DisableErrorPrint++;

    EvalExpression* RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;

    __try
    {
        ULONG64 OldPtr;
        EvalExpression* Eval = GetEvaluator(DEBUG_EXPR_CPLUSPLUS, FALSE);

        if (AllowAccess == TDACC_NONE)
        {
            // Parse-only is automatically reset after evaluation.
            Eval->m_ParseOnly++;
        }

        Eval->Evaluate(m_Entry->m_Expr, NULL, EXPRF_DEFAULT,
                       &m_Entry->m_BaseData);

        ReleaseEvaluator(Eval);

        m_ExprErr = NO_ERROR;
        OldPtr = m_CastData.m_Ptr;
        m_CastData = m_Entry->m_BaseData;

        if (m_Entry->m_Cast)
        {
            m_ExprErr = m_CastData.CastTo(&m_CastType);
        }

        if (!m_ExprErr)
        {
            if (m_CastData.IsPointer() &&
                m_CastData.m_Ptr != OldPtr)
            {
                RefreshChildren();
            }
        }
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        m_ExprErr = GetExceptionCode() - COMMAND_EXCEPTION_BASE;
    }

    g_EvalReleaseChain = RelChain;
    g_DisableErrorPrint--;
    m_ValueErr = m_ExprErr;
    UpdateParams();
    return m_ExprErr;
}

//----------------------------------------------------------------------------
//
// ExtSymbolGroupFormat.
//
//----------------------------------------------------------------------------

CHAR g_ExtensionOutputDataBuffer[MAX_NAME];

class ExtenOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

STDMETHODIMP
ExtenOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
ExtenOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
ExtenOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
ExtenOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if ((strlen(Text) + strlen(g_ExtensionOutputDataBuffer)) <
        sizeof(g_ExtensionOutputDataBuffer))
    {
        strcat(g_ExtensionOutputDataBuffer, Text);
    }
    return S_OK;
}

ExtenOutputCallbacks g_ExtensionOutputCallback;

ExtSymbolGroupFormat::ExtSymbolGroupFormat(SymbolGroupEntry* Entry,
                                           DebugClient* Client)
    : SymbolGroupFormat(Entry, SGFORMAT_EXTENSION)
{
    m_Client = Client;
    m_Output = NULL;
}

ExtSymbolGroupFormat::~ExtSymbolGroupFormat(void)
{
    delete [] m_Output;
}

ULONG
ExtSymbolGroupFormat::CreateChildren(DebugSymbolGroup* Group)
{
    if (m_ExprErr)
    {
        return m_ExprErr;
    }

    if (!m_Output || !m_Entry->m_Params.SubElements)
    {
        return NOTFOUND;
    }

    //
    // Create a simple text child for each line past
    // the first.
    //

    ULONG i;
    PSTR Scan;
    SymbolGroupEntry* AddAfter = m_Entry;

    Scan = m_Output + strlen(m_Output) + 1;
    for (i = 0; i < m_Entry->m_Params.SubElements; i++)
    {
        char Line[32];

        sprintf(Line, "%d", i + 1);

        SymbolGroupEntry* Child = new SymbolGroupEntry;
        TextSymbolGroupFormat* ChildFormat =
            new TextSymbolGroupFormat(Child, Scan, FALSE);
        if (!Child || !ChildFormat)
        {
            delete Child;
            return NOMEMORY;
        }

        Child->m_Format = ChildFormat;

        Child->m_Expr = _strdup(Line);
        if (!Child->m_Expr)
        {
            delete Child;
            return NOMEMORY;
        }

        Child->m_Parent = m_Entry;
        Child->m_Params.Flags = ((m_Entry->m_Params.Flags &
                                  DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) + 1) |
            DEBUG_SYMBOL_READ_ONLY;
        Child->m_Next = AddAfter->m_Next;
        Child->m_BaseFormatKind = SGFORMAT_TEXT;
        ChildFormat->m_ExprErr = NO_ERROR;
        AddAfter->m_Next = Child;
        AddAfter = Child;
        Group->m_NumEntries++;
    }

    return NO_ERROR;
}

ULONG
ExtSymbolGroupFormat::Refresh(TypedDataAccess AllowAccess)
{
    PDEBUG_OUTPUT_CALLBACKS OutCbSave;

    m_Client->FlushCallbacks();
    OutCbSave = m_Client->m_OutputCb;

    OutCtlSave OldCtl;

    PushOutCtl(DEBUG_OUTCTL_THIS_CLIENT |
               DEBUG_OUTCTL_OVERRIDE_MASK | DEBUG_OUTCTL_NOT_LOGGED,
               m_Client, &OldCtl);

    g_ExtensionOutputDataBuffer[0] = 0;
    m_Client->m_OutputCb = &g_ExtensionOutputCallback;

    EvalExpression* RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;

    g_DisableErrorPrint++;

    __try
    {
        char AddrStr[32];
        ULONG64 Addr;
        EvalExpression* Eval = GetEvaluator(DEBUG_EXPR_CPLUSPLUS, FALSE);

        if (AllowAccess == TDACC_NONE)
        {
            // Parse-only is automatically reset after evaluation.
            Eval->m_ParseOnly++;
        }

        Eval->Evaluate(m_Entry->m_Expr, NULL, EXPRF_DEFAULT,
                       &m_Entry->m_BaseData);

        ReleaseEvaluator(Eval);

        if (m_Entry->m_BaseData.GetAbsoluteAddress(&Addr))
        {
            m_ExprErr = MEMORY;
        }
        else
        {
            HRESULT ExtStatus;

            sprintf(AddrStr, "0x%I64x", Addr);
            CallAnyExtension(m_Client, NULL, m_Entry->m_Cast + 1, AddrStr,
                             FALSE, FALSE, &ExtStatus);
            // Ignore the extension status as it's rarely meaningful.
            m_ExprErr = NO_ERROR;
        }
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        m_ExprErr = GetExceptionCode() - COMMAND_EXCEPTION_BASE;
    }

    PopOutCtl(&OldCtl);

    m_Client->FlushCallbacks();
    m_Client->m_OutputCb = OutCbSave;

    g_EvalReleaseChain = RelChain;
    g_DisableErrorPrint--;
    m_ValueErr = m_ExprErr;
    if (m_ExprErr)
    {
        return m_ExprErr;
    }

    if (m_Output)
    {
        delete [] m_Output;
    }
    m_Output = new CHAR[strlen(g_ExtensionOutputDataBuffer) + 1];
    if (!m_Output)
    {
        return NOMEMORY;
    }

    strcpy(m_Output, g_ExtensionOutputDataBuffer);

    //
    // Convert newlines to terminators for convenient output.
    // Number of children == number of newlines - 1.
    //
    // While scanning, also update any children of this
    // node with refreshed pointers.
    //

    PSTR Scan = m_Output;
    SymbolGroupEntry* Child = m_Entry->m_Next;

    m_Entry->m_Params.SubElements = 0;
    while (Scan = strchr(Scan, '\n'))
    {
        m_Entry->m_Params.SubElements++;
        *Scan++ = 0;

        if (Child && Child->m_Parent == m_Entry)
        {
            // It would be cleaner if the child's Refresh()
            // looked up the text value from the parent,
            // but all the per-line lookups would be a lot
            // of wasted effort.
            ((TextSymbolGroupFormat*)Child->m_Format)->m_Text = Scan;
            Child = Child->m_Next;
        }
    }
    if (m_Entry->m_Params.SubElements)
    {
        m_Entry->m_Params.SubElements--;
    }

    //
    // Any excess children are now blank.
    //
    while (Child && Child->m_Parent == m_Entry)
    {
        ((TextSymbolGroupFormat*)Child->m_Format)->m_Text = "";
        Child = Child->m_Next;
    }

    return NO_ERROR;
}

ULONG
ExtSymbolGroupFormat::Write(PCSTR Value)
{
    // No modifications allowed.
    return MEMORY;
}

void
ExtSymbolGroupFormat::OutputValue(void)
{
    if (m_ValueErr)
    {
        dprintf("<%s error>", ErrorString(m_ValueErr));
    }
    else
    {
        dprintf("%s", m_Output);
    }
}

void
ExtSymbolGroupFormat::OutputType(void)
{
    dprintf("%s", m_Entry->m_Cast);
}

void
ExtSymbolGroupFormat::OutputOffset(void)
{
    // No offset.
}

//----------------------------------------------------------------------------
//
// TextSymbolGroupFormat.
//
//----------------------------------------------------------------------------

TextSymbolGroupFormat::TextSymbolGroupFormat(SymbolGroupEntry* Entry,
                                             PSTR Text, BOOL Own)
    : SymbolGroupFormat(Entry, SGFORMAT_TEXT)
{
    m_Text = Text;
    m_Own = Own;

    Entry->m_Flags |= DEBUG_SYMBOL_READ_ONLY;
}

TextSymbolGroupFormat::~TextSymbolGroupFormat(void)
{
    if (m_Own)
    {
        delete [] m_Text;
    }
}

ULONG
TextSymbolGroupFormat::CreateChildren(DebugSymbolGroup* Group)
{
    return NOTFOUND;
}

ULONG
TextSymbolGroupFormat::Refresh(TypedDataAccess AllowAccess)
{
    return NO_ERROR;
}

ULONG
TextSymbolGroupFormat::Write(PCSTR Value)
{
    // No modifications allowed.
    return MEMORY;
}

void
TextSymbolGroupFormat::OutputValue(void)
{
    dprintf("%s", m_Text);
}

void
TextSymbolGroupFormat::OutputType(void)
{
    // No type.
}

void
TextSymbolGroupFormat::OutputOffset(void)
{
    // No offset.
}

//----------------------------------------------------------------------------
//
// IDebugSymbolGroup.
//
//----------------------------------------------------------------------------

DebugSymbolGroup::DebugSymbolGroup(DebugClient* Client, ULONG ScopeGroup)
{
    m_Client = Client;
    m_ScopeGroup = ScopeGroup;

    m_Refs = 1;
    m_NumEntries = 0;
    m_Entries = NULL;
    m_LastClassExpanded = TRUE;
}

DebugSymbolGroup::~DebugSymbolGroup(void)
{
    SymbolGroupEntry* Next;

    while (m_Entries)
    {
        Next = m_Entries->m_Next;
        delete m_Entries;
        m_Entries = Next;
    }
}

STDMETHODIMP
DebugSymbolGroup::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    *Interface = NULL;
    Status = S_OK;

    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, IID_IDebugSymbolGroup))
    {
        AddRef();
        *Interface = (IDebugSymbolGroup *)this;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    return Status;
}

STDMETHODIMP_(ULONG)
DebugSymbolGroup::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
DebugSymbolGroup::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        ENTER_ENGINE();
        delete this;
        LEAVE_ENGINE();
    }
    return Refs;
}

STDMETHODIMP
DebugSymbolGroup::GetNumberSymbols(
    THIS_
    OUT PULONG Number
    )
{
    ENTER_ENGINE();

    *Number = m_NumEntries;

    LEAVE_ENGINE();
    return S_OK;
}

STDMETHODIMP
DebugSymbolGroup::AddSymbol(
    THIS_
    IN PCSTR Name,
    IN OUT PULONG Index
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        SymbolGroupEntry* Entry;

        if ((Status = NewEntry(Name, NULL, &Entry)) == S_OK)
        {
            LinkEntry(Entry, Index);
        }
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::RemoveSymbolByName(
    THIS_
    IN PCSTR Name
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    // Don't delete children.
    SymbolGroupEntry* Entry = FindEntryByExpr(NULL, NULL, Name);
    if (Entry)
    {
        DeleteEntry(Entry);
        Status = S_OK;
    }
    else
    {
        Status = E_INVALIDARG;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::RemoveSymbolByIndex(
    THIS_
    IN ULONG Index
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    // Don't delete children.
    SymbolGroupEntry* Entry = FindEntryByIndex(Index);
    if (Entry && !Entry->m_Parent)
    {
        DeleteEntry(Entry);
        Status = S_OK;
    }
    else
    {
        Status = E_INVALIDARG;
    }

#if DBG_SYMGROUP_ENABLED
    dprintf("Deleted %lx\n", Index);
    ShowAll();
#endif

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::GetSymbolName(
    THIS_
    IN ULONG Index,
    OUT OPTIONAL PSTR Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG NameSize
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    SymbolGroupEntry* Entry = FindEntryByIndex(Index);
    if (Entry)
    {
        Status = FillStringBuffer(Entry->m_Expr, 0,
                                  Buffer, BufferSize, NameSize);
    }
    else
    {
        Status = E_INVALIDARG;
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::GetSymbolParameters(
    THIS_
    IN ULONG Start,
    IN ULONG Count,
    OUT /* size_is(Count) */ PDEBUG_SYMBOL_PARAMETERS Params
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    SymbolGroupEntry* Entry;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    else if (!(Entry = FindEntryByIndex(Start)))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    TestImages();

    Status = S_OK;

#if DBG_SYMGROUP_ENABLED
    dprintf("GetSymbolParameters: will return %lx sym params\n", Count);
    ShowAll();
#endif

    while (Count)
    {
        if (!Entry)
        {
            Status = E_INVALIDARG;
            goto Exit;
        }

        *Params = Entry->m_Params;

        // Update the parent index on demand so that it
        // doesn't have to be tracked through all list updates.
        Params->ParentSymbol = FindEntryIndex(Entry->m_Parent);

        Params++;
        Entry = Entry->m_Next;
        Count--;
    }

#if DBG_SYMGROUP_ENABLED
    dprintf("End GetSymbolParameters\n");
    ShowAll();
#endif

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::ExpandSymbol(
    THIS_
    IN ULONG Index,
    IN BOOL Expand
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    SymbolGroupEntry* Entry;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
    }
    else if (!(Entry = FindEntryByIndex(Index)))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        TestImages();

        Status = SetEntryExpansion(Entry, Expand);
    }

    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::OutputSymbols(
    THIS_
    IN ULONG OutputControl,
    IN ULONG Flags,
    IN ULONG Start,
    IN ULONG Count
    )
{
    HRESULT Status;

    if (Flags & ~(DEBUG_OUTPUT_SYMBOLS_NO_NAMES |
                  DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS |
                  DEBUG_OUTPUT_SYMBOLS_NO_VALUES |
                  DEBUG_OUTPUT_SYMBOLS_NO_TYPES))
    {
        return E_INVALIDARG;
    }

    ENTER_ENGINE();

    SymbolGroupEntry* Entry;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    else if (!(Entry = FindEntryByIndex(Start)))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    TestImages();

#if DBG_SYMGROUP_ENABLED
    dprintf("Output\n");
    ShowAll();
#endif

    OutCtlSave OldCtl;

    if (!PushOutCtl(OutputControl, m_Client, &OldCtl))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    Status = S_OK;

    while (Count)
    {
        if (!Entry)
        {
            Status = E_INVALIDARG;
            break;
        }

        if (!(Entry->m_Flags & SYMBOL_ECLIPSED))
        {
            Entry->m_Format->Refresh(TDACC_REQUIRE);
        }

        if (!(Flags & DEBUG_OUTPUT_SYMBOLS_NO_NAMES))
        {
            dprintf("%s%s", Entry->m_Expr, DEBUG_OUTPUT_NAME_END);
        }

        if (!(Flags & DEBUG_OUTPUT_SYMBOLS_NO_VALUES))
        {
            if (!(Entry->m_Flags & SYMBOL_ECLIPSED))
            {
                Entry->m_Format->OutputValue();
            }
            else
            {
                dprintf("<Eclipsed>");
            }
            dprintf(DEBUG_OUTPUT_VALUE_END);
        }

        if (!(Flags & DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS))
        {
            Entry->m_Format->OutputOffset();
            dprintf(DEBUG_OUTPUT_OFFSET_END);
        }

        if (!(Flags & DEBUG_OUTPUT_SYMBOLS_NO_TYPES))
        {
            Entry->m_Format->OutputType();
            dprintf(DEBUG_OUTPUT_TYPE_END);
        }

        Entry = Entry->m_Next;
        Count--;
    }

    PopOutCtl(&OldCtl);

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::WriteSymbol(
    THIS_
    IN ULONG Index,
    IN PCSTR Value
    )
{
    if (!Value)
    {
        return E_INVALIDARG;
    }

    HRESULT Status;

    ENTER_ENGINE();

    SymbolGroupEntry* Entry;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    else if (!(Entry = FindEntryByIndex(Index)))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    TestImages();

#if DBG_SYMGROUP_ENABLED
    dprintf("WriteSymbol %lx : %s\n", Index, Value);
#endif

    Status = Entry->m_Format->Write(Value) ? E_FAIL : S_OK;

 Exit:
    LEAVE_ENGINE();
    return Status;
}

STDMETHODIMP
DebugSymbolGroup::OutputAsType(
    THIS_
    IN ULONG Index,
    IN PCSTR Type
    )
{
    HRESULT Status;

    ENTER_ENGINE();

    SymbolGroupEntry* Entry;
    PSTR Cast = NULL;
    ULONG CastLen;
    SymbolGroupFormat* NewFormat = NULL;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        Status = E_UNEXPECTED;
        goto Exit;
    }
    else if (!(Entry = FindEntryByIndex(Index)))
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    TestImages();

    if ((Entry->m_BaseFormatKind != SGFORMAT_TYPED_DATA &&
         Entry->m_BaseFormatKind != SGFORMAT_EXPRESSION &&
         Entry->m_BaseFormatKind != SGFORMAT_EXTENSION) ||
        Entry->m_Format->m_ExprErr)
    {
        Status = E_INVALIDARG;
        goto Exit;
    }

    if (Type && *Type)
    {
        // Allocate extra space for cast evaluation expression.
        CastLen = strlen(Type) + 1;
        Cast = (PSTR)malloc(CastLen + 3);
        if (!Cast)
        {
            Status = E_OUTOFMEMORY;
            goto Exit;
        }

        memcpy(Cast, Type, CastLen);
    }

    //
    // Entries may need to be shifted between kinds of
    // symbol group formats according to what the cast is.
    //

    if (Cast && *Cast == '!')
    {
        //
        // Entry needs to use an extension format.
        //

        NewFormat = new ExtSymbolGroupFormat(Entry, m_Client);
        if (!NewFormat)
        {
            Status = E_OUTOFMEMORY;
            goto Exit;
        }

        NewFormat->m_ExprErr = NO_ERROR;
    }
    else
    {
        TypedDataSymbolGroupFormat* TdFormat;

        //
        // Entry is not an extension entry.
        //

        TdFormat = Entry->m_BaseFormatKind == SGFORMAT_EXPRESSION ?
            new ExprSymbolGroupFormat(Entry) :
            new TypedDataSymbolGroupFormat(Entry);
        if (!TdFormat)
        {
            Status = E_OUTOFMEMORY;
            goto Exit;
        }

        NewFormat = TdFormat;
        TdFormat->m_CastData = Entry->m_BaseData;

        if (Cast)
        {
            //
            // Determine cast type.
            //

            memmove(Cast + 1, Cast, CastLen);
            Cast[0] = '(';
            Cast[CastLen] = ')';
            Cast[CastLen + 1] = '0';
            Cast[CastLen + 2] = 0;

            g_DisableErrorPrint++;

            EvalExpression* RelChain = g_EvalReleaseChain;
            g_EvalReleaseChain = NULL;

            __try
            {
                EvalExpression* Eval =
                    GetEvaluator(DEBUG_EXPR_CPLUSPLUS, FALSE);
                Eval->Evaluate(Cast, NULL, EXPRF_DEFAULT,
                               &TdFormat->m_CastType);
                ReleaseEvaluator(Eval);
            }
            __except(CommandExceptionFilter(GetExceptionInformation()))
            {
                g_DisableErrorPrint--;
                Status = E_FAIL;
                goto Exit;
            }

            g_EvalReleaseChain = RelChain;
            g_DisableErrorPrint--;

            memmove(Cast, Cast + 1, CastLen);
            Cast[CastLen - 1] = 0;

            if (TdFormat->m_CastData.CastTo(&TdFormat->m_CastType))
            {
                Status = E_FAIL;
                goto Exit;
            }
        }

        TdFormat->m_ExprErr = NO_ERROR;
        TdFormat->m_ValueErr = TdFormat->m_ExprErr;
        TdFormat->UpdateParams();
    }

    // The cast may have radically altered the subelements
    // for this entry so collapse the entry.
    SetEntryExpansion(Entry, FALSE);

    free(Entry->m_Cast);
    Entry->m_Cast = Cast;
    Cast = NULL;

    delete Entry->m_Format;
    Entry->m_Format = NewFormat;
    NewFormat = NULL;

    Status = S_OK;

Exit:
    free(Cast);
    delete NewFormat;
    LEAVE_ENGINE();
    return Status;
}

//
// Private DebugSymbolGroup methods
//

SymbolGroupEntry*
DebugSymbolGroup::FindEntryByIndex(ULONG Index)
{
    SymbolGroupEntry* Entry;

    for (Entry = m_Entries; Entry; Entry = Entry->m_Next)
    {
        if (Index-- == 0)
        {
            return Entry;
        }
    }

    return NULL;
}

SymbolGroupEntry*
DebugSymbolGroup::FindEntryByExpr(SymbolGroupEntry* Parent,
                                  SymbolGroupEntry* After,
                                  PCSTR Expr)
{
    SymbolGroupEntry* Entry;

    // Entries are sorted by parent/child so children will
    // immediately follow a parent.
    if (!After)
    {
        Entry = Parent ? Parent->m_Next : m_Entries;
    }
    else
    {
        Entry = After->m_Next;
    }
    while (Entry)
    {
        if (Entry->m_Parent == Parent &&
            !strcmp(Expr, Entry->m_Expr))
        {
            return Entry;
        }

        Entry = Entry->m_Next;
    }

    return NULL;
}

ULONG
DebugSymbolGroup::FindEntryIndex(SymbolGroupEntry* Entry)
{
    SymbolGroupEntry* Cur;
    ULONG Index = 0;

    for (Cur = m_Entries; Cur; Cur = Cur->m_Next)
    {
        if (Cur == Entry)
        {
            return Index;
        }

        Index++;
    }

    return DEBUG_ANY_ID;
}

void
DebugSymbolGroup::DeleteEntry(SymbolGroupEntry* Entry)
{
    SymbolGroupEntry* Prev;
    SymbolGroupEntry* Cur;

    //
    // Locate the entry.
    //

    Prev = NULL;
    for (Cur = m_Entries; Cur; Cur = Cur->m_Next)
    {
        if (Cur == Entry)
        {
            break;
        }

        Prev = Cur;
    }

    if (!Cur)
    {
        return;
    }

    DeleteChildren(Entry);

    if (!Prev)
    {
        m_Entries = Entry->m_Next;
    }
    else
    {
        Prev->m_Next = Entry->m_Next;
    }

    delete Entry;

    m_NumEntries--;
}

void
DebugSymbolGroup::DeleteChildren(SymbolGroupEntry* Parent)
{
    //
    // The list of entries is sorted by parent/child
    // relationship so any children follow the parent
    // immediately.
    //

    SymbolGroupEntry* Cur;
    SymbolGroupEntry* Del;
    ULONG Level = Parent->m_Params.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK;

    Cur = Parent->m_Next;
    while (Cur)
    {
        if ((Cur->m_Params.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) <= Level)
        {
            // Any entry of the same or less expansion than the parent
            // cannot be a child so stop.
            break;
        }
        else
        {
            // Found a child entry so delete.
            Del = Cur;
            Cur = Cur->m_Next;
            delete Del;
            m_NumEntries--;
        }
    }

    Parent->m_Next = Cur;
}

void
DebugSymbolGroup::LinkEntry(IN SymbolGroupEntry* Entry,
                            IN OUT PULONG Index)
{
    //
    // Find insertion index point.
    //

    SymbolGroupEntry* Prev;
    SymbolGroupEntry* Cur;
    ULONG CurIdx = 0;

    Prev = NULL;
    for (Cur = m_Entries; Cur; Cur = Cur->m_Next)
    {
        if (CurIdx == *Index)
        {
            break;
        }

        CurIdx++;
        Prev = Cur;
    }

    if (!Prev)
    {
        Entry->m_Next = m_Entries;
        m_Entries = Entry;
    }
    else
    {
        Entry->m_Next = Prev->m_Next;
        Prev->m_Next = Entry;
    }
    m_NumEntries++;
    *Index = CurIdx;

#if DBG_SYMGROUP_ENABLED
    dprintf("Added %s at %lx\n", Entry->m_Expr, *Index);
    ShowAll();
#endif
}

HRESULT
DebugSymbolGroup::NewEntry(IN PCSTR Expr,
                           IN OPTIONAL PSYMBOL_INFO SymInfo,
                           OUT SymbolGroupEntry** EntryRet)
{
    HRESULT Status;

    SymbolGroupEntry* Entry = new SymbolGroupEntry;
    TypedDataSymbolGroupFormat* Format = SymInfo ?
        new TypedDataSymbolGroupFormat(Entry) :
        new ExprSymbolGroupFormat(Entry);
    if (!Entry || !Format)
    {
        delete Entry;
        return E_OUTOFMEMORY;
    }

    Entry->m_Format = Format;

    if (!(Entry->m_Expr = _strdup(Expr)))
    {
        Status = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // We're just creating the entries here so there's
    // no need to attempt to read content yet.  Refresh
    // will be called later.
    //

    if (SymInfo)
    {
        Format->m_ExprErr = Entry->m_BaseData.
            SetToSymbol(g_Process, (PSTR)Expr, SymInfo,
                        TDACC_NONE, g_Machine->m_Ptr64 ? 8 : 4);

        Entry->m_BaseFormatKind = SGFORMAT_TYPED_DATA;
        Format->m_CastData = Entry->m_BaseData;
        Format->UpdateParams();
    }
    else
    {
        // We have to evaluate in order to determine
        // the result type, but evaluate without access
        // to just evaluate the result type without
        // requiring memory access.
        Format->Refresh(TDACC_NONE);

        Entry->m_BaseFormatKind = SGFORMAT_EXPRESSION;
        Format->m_CastData = Entry->m_BaseData;
    }

    *EntryRet = Entry;
    return S_OK;

 Error:
    delete Entry;
    return Status;
}

HRESULT
DebugSymbolGroup::SetEntryExpansion(IN SymbolGroupEntry* Entry,
                                    IN BOOL Expand)
{
    HRESULT Status;

    if (Expand &&
        (Entry->m_Params.Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) ==
        DEBUG_SYMBOL_EXPANSION_LEVEL_MASK)
    {
        return E_INVALIDARG;
    }

#if DBG_SYMGROUP_ENABLED
    dprintf("Expanding %s (%lx to be %s)\n",
            Entry->m_Expr, Entry->m_Params.SubElements,
            Expand ? "created" : "deleted");
    ShowAll();
#endif

    //
    // Special case - check and store if "this" is expanded/collapsed
    //
    if (!strcmp(Entry->m_Expr, "this"))
    {
        m_LastClassExpanded = Expand;
    }

    if (!Expand)
    {
        if (Entry->m_Params.Flags & DEBUG_SYMBOL_EXPANDED)
        {
            DeleteChildren(Entry);
            Entry->m_Params.Flags &= ~DEBUG_SYMBOL_EXPANDED;
        }

        Status = S_OK;
    }
    else
    {
        if (Entry->m_Params.Flags & DEBUG_SYMBOL_EXPANDED)
        {
            Status = S_OK;
        }
        else
        {
            if (!Entry->m_Format->CreateChildren(this))
            {
                Entry->m_Params.Flags |= DEBUG_SYMBOL_EXPANDED;
                Status = S_OK;
            }
            else
            {
                Status = E_FAIL;
            }
        }
    }

#if DBG_SYMGROUP_ENABLED
    dprintf("Expanded %s (%lx %s)\n",
            Entry->m_Expr, Entry->m_Params.SubElements,
            (Entry->m_Params.Flags & DEBUG_SYMBOL_EXPANDED) ?
            "new" : "deleted");
    ShowAll();
#endif
    return Status;
}

HRESULT
DebugSymbolGroup::AddCurrentLocals(void)
{
    // Always return success since this request is
    // processed even if we didn't add anything.

    HRESULT Status = S_OK;

    RequireCurrentScope();

    SymbolGroupEntry* Entry;

    for (Entry = m_Entries; Entry; Entry = Entry->m_Next)
    {
        if (!Entry->m_Parent)
        {
            // Assume everything is visible now.
            Entry->m_Flags &= ~(SYMBOL_ECLIPSED | SYMBOL_IN_SCOPE);
        }
    }

    EnumerateLocals(AddAllScopedSymbols, (PVOID)this);

 Restart:

#if DBG_SYMGROUP_ENABLED
    dprintf("Enum locals loop:\n");
    ShowAll();
#endif

    for (Entry = m_Entries; Entry; Entry = Entry->m_Next)
    {
        if (!Entry->m_Parent)
        {
            if (!(Entry->m_Flags & SYMBOL_IN_SCOPE))
            {
                DeleteEntry(Entry);
                // Restart scan as the list just changed.
                goto Restart;
            }
        }
    }

    SymbolGroupEntry* ThisEntry = NULL;

    for (Entry = m_Entries; Entry; Entry = Entry->m_Next)
    {
        if (!Entry->m_Parent)
        {
            if (Entry->m_Flags & SYMBOL_IN_SCOPE)
            {
                Entry->m_Flags &= ~SYMBOL_IN_SCOPE;

                // Remember if there's a plain "this" reference
                // for later expansion.
                if (!strcmp(Entry->m_Expr, "this"))
                {
                    ThisEntry = Entry;
                }
            }
        }
    }

    if (ThisEntry && m_LastClassExpanded)
    {
        SetEntryExpansion(ThisEntry, TRUE);
    }

    return Status;
}

ULONG
DebugSymbolGroup::FindLocalInsertionIndex(SymbolGroupEntry* Entry)
{
    ULONG Index = 0;
    SymbolGroupEntry* Compare;

    for (Compare = m_Entries; Compare; Compare = Compare->m_Next, Index++)
    {
        if (Compare->m_Parent)
        {
            continue;
        }

        //
        // Sort arguments by address and locals by name.
        //

        if ((Compare->m_Params.Flags & DEBUG_SYMBOL_IS_ARGUMENT) ||
            (Entry->m_Params.Flags & DEBUG_SYMBOL_IS_ARGUMENT))
        {
            if ((Compare->m_Params.Flags & DEBUG_SYMBOL_IS_ARGUMENT) &&
                (Entry->m_Params.Flags & DEBUG_SYMBOL_IS_ARGUMENT))
            {
                // We can only meaningfully sort frame-relative
                // arguments.
                if (Compare->m_BaseFormatKind == SGFORMAT_TYPED_DATA &&
                    Entry->m_BaseFormatKind == SGFORMAT_TYPED_DATA &&
                    (Compare->m_BaseData.m_DataSource &
                     TDATA_FRAME_RELATIVE) &&
                    (Entry->m_BaseData.m_DataSource &
                     TDATA_FRAME_RELATIVE) &&
                    Compare->m_BaseData.m_SourceOffset >
                    Entry->m_BaseData.m_SourceOffset)
                {
                    return Index;
                }
            }
            else if (Entry->m_Params.Flags & DEBUG_SYMBOL_IS_ARGUMENT)
            {
                return Index;
            }
        }
        else
        {
            if (_stricmp(Compare->m_Expr, Entry->m_Expr) > 0)
            {
                return Index;
            }
        }
    }

    // Place at the end.
    return m_NumEntries;
}

BOOL CALLBACK
DebugSymbolGroup::AddAllScopedSymbols(PSYMBOL_INFO SymInfo,
                                      ULONG        Size,
                                      PVOID        Context)
{
    DebugSymbolGroup* Caller = (DebugSymbolGroup*)Context;
    BOOL SymbolEclipsed = FALSE;
    SymbolGroupEntry* Entry;

    //
    // Ingore symbols which do not match Caller's scope
    //
    if (Caller->m_ScopeGroup == DEBUG_SCOPE_GROUP_ARGUMENTS)
    {
        if (!(SymInfo->Flags & SYMFLAG_PARAMETER))
        {

            return TRUE;
        }
    } else if (Caller->m_ScopeGroup != DEBUG_SCOPE_GROUP_LOCALS)
    {
        return TRUE;
    }

    Entry = Caller->FindEntryByExpr(NULL, NULL, SymInfo->Name);
    while (Entry)
    {
        if (Entry->m_Format->m_Kind == SGFORMAT_TYPED_DATA &&
            Entry->m_BaseData.m_Image &&
            Entry->m_BaseData.m_Image->m_BaseOfImage == SymInfo->ModBase &&
            Entry->m_BaseData.m_Type == SymInfo->TypeIndex &&
            Entry->m_BaseData.EquivInfoSource(SymInfo,
                                              Entry->m_BaseData.m_Image))
        {
            // The entry matches the enumerated symbol.
            Entry->m_Flags |= SYMBOL_IN_SCOPE;
            return TRUE;
        }
        else if (!(Entry->m_Flags & SYMBOL_IN_SCOPE))
        {
            // The enumerated symbol hasn't been
            // processed by this routine yet, so it
            // must be some old local var from previous scope.
            Entry->m_Flags |= SYMBOL_ECLIPSED;
        }
        else
        {
            // The enumerated symbol is a newer same-named local,
            // so the current entry is the symbol to be eclipsed.
            SymbolEclipsed = TRUE;
        }

        Entry = Caller->FindEntryByExpr(NULL, Entry, SymInfo->Name);
    }

    if (Caller->NewEntry(SymInfo->Name, SymInfo, &Entry) != S_OK)
    {
        return FALSE;
    }

    Entry->m_Flags |= SYMBOL_IN_SCOPE;
    Entry->m_Flags |= SymbolEclipsed ? SYMBOL_ECLIPSED : 0;
    Entry->m_Params.Flags |=
        (SymInfo->Flags & SYMFLAG_PARAMETER) ? DEBUG_SYMBOL_IS_ARGUMENT :
        ((SymInfo->Flags & SYMFLAG_LOCAL) ? DEBUG_SYMBOL_IS_LOCAL : 0);

    ULONG Index = Caller->FindLocalInsertionIndex(Entry);

    if (SymbolEclipsed && Index)
    {
        // Symbol at 'Index' is the symbol with same name,
        // add this *before* 'Index' since order
        // is important when checking for the inner-scope symbol
        Index--;
    }

    Caller->LinkEntry(Entry, &Index);

#if DBG_SYMGROUP_ENABLED
    dprintf("%lx : Adding local %s %s\n",
            Index, (SymInfo->Flags & SYMFLAG_PARAMETER) ?
            "arg" : "   ", SymInfo->Name);
#endif

    return TRUE;
}

void
DebugSymbolGroup::TestImages(void)
{
    SymbolGroupEntry* Entry = m_Entries;
    while (Entry)
    {
        Entry->m_Format->TestImages();
        Entry = Entry->m_Next;
    }
}

void
DebugSymbolGroup::ShowAll(void)
{
    SymbolGroupEntry* Entry = m_Entries;
    ULONG Index = 0;

    dprintf("Total %d syms\n", m_NumEntries);
    dprintf("Idx Sub  ExFlags      Par Flag Mod      Expr (Cast)\n");
    while (Entry)
    {
        dprintf64("%2lx:%4lx %8lx %8lx %4lx %p %s (%s)\n",
                  Index++,
                  Entry->m_Params.SubElements,
                  Entry->m_Params.Flags,
                  FindEntryIndex(Entry->m_Parent),
                  Entry->m_Flags,
                  Entry->m_Params.Module,
                  Entry->m_Expr,
                  Entry->m_Cast ? Entry->m_Cast : "<none>");
        Entry = Entry->m_Next;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dbgkdtrans.cpp ===
//----------------------------------------------------------------------------
//
// KD hard-line communication support.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <portio.h>

#include <setupapi.h>
#include <newdev.h>

#define THROTTLE_WRITES 0
#define DBG_SYNCH 0

struct KD_FILE_ASSOC
{
    LIST_ENTRY List;
    PWSTR From;
    PSTR To;
};

ULONG g_LastProcessorToPrint = (ULONG) -1;
CHAR g_PrintBuf[PACKET_MAX_SIZE];

PCSTR g_DbgKdTransportNames[] =
{
    "COM", "1394"
};

// This log is for debugging the protocol so leave it
// a simple global for easy examination.
ULONG g_PacketLogIndex;
ULONG64 g_PacketLog[16];

#define PACKET_LOG_SIZE (sizeof(g_PacketLog) / sizeof(g_PacketLog[0]))

UCHAR DbgKdTransport::s_BreakinPacket[1] =
{
    BREAKIN_PACKET_BYTE
};

UCHAR DbgKdTransport::s_PacketTrailingByte[1] =
{
    PACKET_TRAILING_BYTE
};

UCHAR DbgKdTransport::s_PacketLeader[4] =
{
    PACKET_LEADER_BYTE,
    PACKET_LEADER_BYTE,
    PACKET_LEADER_BYTE,
    PACKET_LEADER_BYTE
};

UCHAR DbgKdTransport::s_Packet[PACKET_MAX_MANIP_SIZE];
KD_PACKET DbgKdTransport::s_PacketHeader;

UCHAR DbgKdTransport::s_SavedPacket[PACKET_MAX_MANIP_SIZE];
KD_PACKET DbgKdTransport::s_SavedPacketHeader;

#define COPYSE(p64,p32,f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

__inline
void
DbgkdGetVersion32To64(
    IN PDBGKD_GET_VERSION32 vs32,
    OUT PDBGKD_GET_VERSION64 vs64,
    OUT PKDDEBUGGER_DATA64 dd64
    )
{
    vs64->MajorVersion = vs32->MajorVersion;
    vs64->MinorVersion = vs32->MinorVersion;
    vs64->ProtocolVersion = vs32->ProtocolVersion;
    vs64->Flags = vs32->Flags;
    vs64->MachineType = vs32->MachineType;
    COPYSE(vs64,vs32,PsLoadedModuleList);
    COPYSE(vs64,vs32,DebuggerDataList);
    COPYSE(vs64,vs32,KernBase);

    COPYSE(dd64,vs32,KernBase);
    COPYSE(dd64,vs32,PsLoadedModuleList);
    dd64->ThCallbackStack = vs32->ThCallbackStack;
    dd64->NextCallback = vs32->NextCallback;
    dd64->FramePointer = vs32->FramePointer;
    COPYSE(dd64,vs32,KiCallUserMode);
    COPYSE(dd64,vs32,KeUserCallbackDispatcher);
    COPYSE(dd64,vs32,BreakpointWithStatus);
}

void
OutputIo(PSTR Format, PVOID _Buffer, ULONG Request, ULONG Done)
{
    ULONG i, Chunk;
    PUCHAR Buffer = (PUCHAR)_Buffer;

    dprintf(Format, Done, Request);
    while (Done > 0)
    {
        Chunk = min(Done, 16);
        Done -= Chunk;
        dprintf("   ");
        for (i = 0; i < Chunk; i++)
        {
            dprintf(" %02X", *Buffer++);
        }
        dprintf("\n");
    }
}

//----------------------------------------------------------------------------
//
// DbgKdTransport.
//
//----------------------------------------------------------------------------

DbgKdTransport::DbgKdTransport(ConnLiveKernelTargetInfo* Target)
{
    m_Refs = 1;
    m_Target = Target;
    m_ReadOverlapped.hEvent = NULL;
    m_WriteOverlapped.hEvent = NULL;
    InitializeListHead(&m_KdFiles);

    InitKdFileAssoc();

    Restart();
}

DbgKdTransport::~DbgKdTransport(void)
{
    if (m_ReadOverlapped.hEvent != NULL)
    {
        CloseHandle(m_ReadOverlapped.hEvent);
    }
    if (m_WriteOverlapped.hEvent != NULL)
    {
        CloseHandle(m_WriteOverlapped.hEvent);
    }
    while (!IsListEmpty(&m_KdFiles))
    {
        CloseKdFile(CONTAINING_RECORD(m_KdFiles.Flink, KD_FILE, List));
    }
    ClearKdFileAssoc();
}

ULONG
DbgKdTransport::GetNumberParameters(void)
{
    return 1;
}

void
DbgKdTransport::GetParameter(ULONG Index,
                             PSTR Name, ULONG NameSize,
                             PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_OutputIo)
        {
            CopyString(Name, "OutputIo", NameSize);
            PrintString(Value, ValueSize, "0x%x", m_OutputIo);
        }
        break;
    }
}

void
DbgKdTransport::ResetParameters(void)
{
    m_OutputIo = 0;
}

BOOL
DbgKdTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, "OutputIo"))
    {
        if (!Value || sscanf(Value, "%i", &m_OutputIo) != 1)
        {
            ErrOut("OutputIo requires a numeric value\n");
            return FALSE;
        }
    }
    else
    {
        ErrOut("%s parameters: %s is not a valid parameter\n",
               m_Name, Name);
        return FALSE;
    }

    return TRUE;
}

void
DbgKdTransport::Restart(void)
{
    //
    // Reinitialize per-connection values.
    //

    while (!IsListEmpty(&m_KdFiles))
    {
        CloseKdFile(CONTAINING_RECORD(m_KdFiles.Flink, KD_FILE, List));
    }

    m_PacketsRead = 0;
    m_BytesRead = 0;
    m_PacketsWritten = 0;
    m_BytesWritten = 0;

    m_PacketExpected = INITIAL_PACKET_ID;
    m_NextPacketToSend = INITIAL_PACKET_ID;

    m_WaitingThread = 0;

    m_AllowInitialBreak = TRUE;
    m_Resync = TRUE;
    m_BreakIn = FALSE;
    m_SyncBreakIn = FALSE;
    m_ValidUnaccessedPacket = FALSE;
}

void
DbgKdTransport::OutputInfo(void)
{
    char Params[2 * (MAX_PARAM_NAME + MAX_PARAM_VALUE)];

    GetParameters(Params, sizeof(Params));
    dprintf("Transport %s\n", Params);
    dprintf("Packets read: %u, bytes read %I64u\n",
            m_PacketsRead, m_BytesRead);
    dprintf("Packets written: %u, bytes written %I64u\n",
            m_PacketsWritten, m_BytesWritten);
}

HRESULT
DbgKdTransport::Initialize(void)
{
    HRESULT Status;

    //
    // Create the events used by the overlapped structures for the
    // read and write.
    //

    if ((Status = CreateOverlappedPair(&m_ReadOverlapped,
                                       &m_WriteOverlapped)) != S_OK)
    {
        ErrOut("Unable to create overlapped info, %s\n",
               FormatStatusCode(Status));
    }

    return Status;
}

void
DbgKdTransport::CycleSpeed(void)
{
    WarnOut("KD transport cannot change speeds\n");
}

HRESULT
DbgKdTransport::ReadTargetPhysicalMemory(
    IN ULONG64 MemoryOffset,
    IN PVOID Buffer,
    IN ULONG SizeofBuffer,
    IN PULONG BytesRead
    )
{
    WarnOut("Not valid KD transport operation\n");
    return E_UNEXPECTED;
}

ULONG
DbgKdTransport::HandleDebugIo(PDBGKD_DEBUG_IO Packet)
{
    ULONG ReadStatus = DBGKD_WAIT_AGAIN;

    switch(Packet->ApiNumber)
    {
    case DbgKdPrintStringApi:
        HandlePrint(Packet->Processor,
                    (PSTR)(Packet + 1),
                    (SHORT)Packet->u.PrintString.LengthOfString,
                    DEBUG_OUTPUT_DEBUGGEE);
        break;
    case DbgKdGetStringApi:
        HandlePromptString(Packet);
        break;
    default:
        KdOut("READ: Received INVALID DEBUG_IO packet type %x.\n",
              Packet->ApiNumber);
        ReadStatus = DBGKD_WAIT_RESEND;
        break;
    }

    return ReadStatus;
}

ULONG
DbgKdTransport::HandleTraceIo(PDBGKD_TRACE_IO Packet)
{
    ULONG ReadStatus = DBGKD_WAIT_AGAIN;

    switch(Packet->ApiNumber)
    {
    case DbgKdPrintTraceApi:
        HandlePrintTrace(Packet->Processor,
                         (PUCHAR)(Packet + 1),
                         (USHORT)Packet->u.PrintTrace.LengthOfData,
                         DEBUG_OUTPUT_DEBUGGEE);
        break;
    default:
        KdOut("READ: Received INVALID TRACE_IO packet type %x.\n",
              Packet->ApiNumber);
        ReadStatus = DBGKD_WAIT_RESEND;
        break;
    }

    return ReadStatus;
}

ULONG
DbgKdTransport::HandleControlRequest(PDBGKD_CONTROL_REQUEST Packet)
{
    ULONG ReadStatus = DBGKD_WAIT_AGAIN;

    switch(Packet->ApiNumber)
    {
    case DbgKdRequestHardwareBp:
        Packet->u.RequestBreakpoint.Available = FALSE;
        WritePacket(Packet,
                    sizeof(*Packet),
                    PACKET_TYPE_KD_CONTROL_REQUEST,
                    NULL,
                    0);
        break;
    case DbgKdReleaseHardwareBp:
        Packet->u.ReleaseBreakpoint.Released = TRUE;
        WritePacket(Packet,
                    sizeof(*Packet),
                    PACKET_TYPE_KD_CONTROL_REQUEST,
                    NULL,
                    0);
        break;
    default:
        KdOut("READ: Received INVALID CONTROL_REQUEST packet type %x.\n",
              Packet->ApiNumber);
        ReadStatus = DBGKD_WAIT_RESEND;
        break;
    }

    return ReadStatus;
}

ULONG
DbgKdTransport::HandleFileIo(PDBGKD_FILE_IO Packet)
{
    KD_FILE* File = NULL;
    PVOID ExtraData = NULL;
    USHORT ExtraDataLength = 0;
    LARGE_INTEGER FilePtr;

    // Reenter the engine lock to protect the file list.
    RESUME_ENGINE();

    switch(Packet->ApiNumber)
    {
    case DbgKdCreateFileApi:
        Packet->Status = CreateKdFile((PWSTR)(Packet + 1),
                                      Packet->u.CreateFile.DesiredAccess,
                                      Packet->u.CreateFile.FileAttributes,
                                      Packet->u.CreateFile.ShareAccess,
                                      Packet->u.CreateFile.CreateDisposition,
                                      Packet->u.CreateFile.CreateOptions,
                                      &File,
                                      &Packet->u.CreateFile.Length);
        Packet->u.CreateFile.Handle = (ULONG_PTR)File;
        KdOut("KdFile request for '%ws' returns %08X\n",
              (PWSTR)(Packet + 1), Packet->Status);
        break;
    case DbgKdReadFileApi:
        File = TranslateKdFileHandle(Packet->u.ReadFile.Handle);
        if (File == NULL ||
            Packet->u.ReadFile.Length > PACKET_MAX_SIZE - sizeof(*Packet))
        {
            Packet->Status = STATUS_INVALID_PARAMETER;
            break;
        }
        FilePtr.QuadPart = Packet->u.ReadFile.Offset;
        if (SetFilePointer(File->Handle, FilePtr.LowPart, &FilePtr.HighPart,
                           FILE_BEGIN) == INVALID_SET_FILE_POINTER &&
            GetLastError())
        {
            Packet->Status = STATUS_END_OF_FILE;
            break;
        }
        if (!ReadFile(File->Handle, Packet + 1, Packet->u.ReadFile.Length,
                      &Packet->u.ReadFile.Length, NULL))
        {
            Packet->Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            dprintf(".");
            Packet->Status = STATUS_SUCCESS;
            ExtraData = Packet + 1;
            ExtraDataLength = (USHORT)Packet->u.ReadFile.Length;
        }
        break;
    case DbgKdWriteFileApi:
        File = TranslateKdFileHandle(Packet->u.WriteFile.Handle);
        if (File == NULL ||
            Packet->u.WriteFile.Length > PACKET_MAX_SIZE - sizeof(*Packet))
        {
            Packet->Status = STATUS_INVALID_PARAMETER;
            break;
        }
        FilePtr.QuadPart = Packet->u.WriteFile.Offset;
        if (SetFilePointer(File->Handle, FilePtr.LowPart, &FilePtr.HighPart,
                           FILE_BEGIN) == INVALID_SET_FILE_POINTER &&
            GetLastError())
        {
            Packet->Status = STATUS_END_OF_FILE;
            break;
        }
        if (!WriteFile(File->Handle, Packet + 1, Packet->u.WriteFile.Length,
                      &Packet->u.WriteFile.Length, NULL))
        {
            Packet->Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            dprintf(".");
            Packet->Status = STATUS_SUCCESS;
        }
        break;
    case DbgKdCloseFileApi:
        File = TranslateKdFileHandle(Packet->u.CloseFile.Handle);
        if (File != NULL)
        {
            // Finish line of progress dots.
            dprintf("\n");
            CloseKdFile(File);
            Packet->Status = STATUS_SUCCESS;
        }
        else
        {
            Packet->Status = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
        KdOut("READ: Received INVALID FILE_IO packet type %x.\n",
              Packet->ApiNumber);
        SUSPEND_ENGINE();
        return DBGKD_WAIT_RESEND;
    }

    //
    // Send response data.
    //

    WritePacket(Packet, sizeof(*Packet),
                PACKET_TYPE_KD_FILE_IO,
                ExtraData, ExtraDataLength);

    SUSPEND_ENGINE();
    return DBGKD_WAIT_AGAIN;
}

ULONG
DbgKdTransport::WaitForPacket(
    IN USHORT PacketType,
    OUT PVOID Packet
    )
{
    ULONG InvPacketRetry = 0;

    // Packets can only be read when the kernel transport
    // is not in use.
    if (m_WaitingThread != 0 &&
        m_WaitingThread != GetCurrentThreadId())
    {
        ErrOut("Kernel transport in use, packet read failed\n");
        return DBGKD_WAIT_FAILED;
    }

    if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
    {
        KdOut("READ: Wait for ACK packet with id = %lx\n",
              m_NextPacketToSend);
    }
    else
    {
        KdOut("READ: Wait for type %x packet exp id = %lx\n",
              PacketType, m_PacketExpected);
    }

    g_PacketLog[g_PacketLogIndex++ & (PACKET_LOG_SIZE - 1)] =
        ((ULONG64)PacketType << 32);

    if (PacketType != PACKET_TYPE_KD_ACKNOWLEDGE)
    {
        if (m_ValidUnaccessedPacket)
        {
            KdOut("READ: Grab packet from buffer.\n");
            goto ReadBuffered;
        }
    }

 ReadContents:

    for (;;)
    {
        ULONG ReadStatus = ReadPacketContents(PacketType);

        //
        // If we read an internal packet such as IO or Resend, then
        // handle it and continue waiting.
        //
        if (ReadStatus == DBGKD_WAIT_PACKET)
        {
            m_PacketsRead++;

            switch(s_PacketHeader.PacketType)
            {
            case PACKET_TYPE_KD_DEBUG_IO:
                ReadStatus = HandleDebugIo((PDBGKD_DEBUG_IO)s_Packet);
                break;
            case PACKET_TYPE_KD_TRACE_IO:
                ReadStatus = HandleTraceIo((PDBGKD_TRACE_IO)s_Packet);
                break;
            case PACKET_TYPE_KD_CONTROL_REQUEST:
                ReadStatus =
                    HandleControlRequest((PDBGKD_CONTROL_REQUEST)s_Packet);
                break;
            case PACKET_TYPE_KD_FILE_IO:
                ReadStatus = HandleFileIo((PDBGKD_FILE_IO)s_Packet);
                break;
            }
        }
        else if (ReadStatus == DBGKD_WAIT_ACK)
        {
            m_PacketsRead++;

            // If we're waiting for an ack we're done,
            // otherwise the communication is confused
            // so ask for a resend.
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                return DBGKD_WAIT_ACK;
            }
            else
            {
                KdOut("READ: Received ACK while waiting for type %d\n",
                      PacketType);
                ReadStatus = DBGKD_WAIT_RESEND;
            }
        }

        if (ReadStatus == DBGKD_WAIT_PACKET)
        {
            // If we're waiting for an ack and received
            // a normal packet leave it in the buffer
            // and record the fact that we have one
            // stored.  Consider it an ack and return.
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                m_ValidUnaccessedPacket = TRUE;

                KdOut("READ: Packet Read ahead.\n");
                FlushCallbacks();

                return DBGKD_WAIT_ACK;
            }

            // We're waiting for a data packet and we
            // just got one so process it.
            break;
        }
        else if (ReadStatus == DBGKD_WAIT_RESEND)
        {
            // If the other end didn't wait for an
            // ack then we can't ask for a resend.
            if (!m_AckWrites)
            {
                return DBGKD_WAIT_FAILED;
            }

            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                return DBGKD_WAIT_ACK;
            }

            KdOut("READ: Ask for resend.\n");
        }
        else if (ReadStatus == DBGKD_WAIT_AGAIN)
        {
            // Internal packets count as acknowledgements,
            // so if we processed one while waiting for an
            // ack consider things done.
            if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                return DBGKD_WAIT_ACK;
            }
        }
        else
        {
            return ReadStatus;
        }
    }

 ReadBuffered:

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64)
    {
        if (s_PacketHeader.PacketType == PACKET_TYPE_KD_STATE_CHANGE64)
        {
            m_Target->m_KdApi64 = TRUE;
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_STATE_CHANGE32)
        {
            PacketType = PACKET_TYPE_KD_STATE_CHANGE32;
            m_Target->m_KdApi64 = FALSE;
        }

        KdOut("READ: Packet type = %x, KdApi64 = %x\n",
              s_PacketHeader.PacketType, m_Target->m_KdApi64);
    }

    if (PacketType != s_PacketHeader.PacketType)
    {
        KdOut("READ: Unexpected Packet type %x (Acked). "
              "Expecting Packet type %x\n",
              s_PacketHeader.PacketType, PacketType);

        if (m_InvPacketRetryLimit > 0 &&
            ++InvPacketRetry >= m_InvPacketRetryLimit)
        {
            return DBGKD_WAIT_FAILED;
        }

        goto ReadContents;
    }

    if (!m_Target->m_KdApi64 &&
        PacketType == PACKET_TYPE_KD_STATE_MANIPULATE)
    {
        DBGKD_MANIPULATE_STATE64 Packet64;
        DWORD AdditionalDataSize;

        DbgkdManipulateState32To64((PDBGKD_MANIPULATE_STATE32)&s_Packet,
                                   &Packet64, &AdditionalDataSize);
        if (Packet64.ApiNumber == DbgKdGetVersionApi)
        {
            DbgkdGetVersion32To64(&((PDBGKD_MANIPULATE_STATE32)&s_Packet)->
                                  u.GetVersion32,
                                  &Packet64.u.GetVersion64,
                                  &m_Target->m_KdDebuggerData);
        }
        else if (AdditionalDataSize)
        {
            //
            // Move the trailing data to make room for the larger packet header
            //
            MoveMemory(s_Packet + sizeof(DBGKD_MANIPULATE_STATE64),
                       s_Packet + sizeof(DBGKD_MANIPULATE_STATE32),
                       AdditionalDataSize);
        }
        *(PDBGKD_MANIPULATE_STATE64)s_Packet = Packet64;
    }

    *(PVOID *)Packet = &s_Packet;
    m_ValidUnaccessedPacket = FALSE;
    return DBGKD_WAIT_PACKET;
}

VOID
DbgKdTransport::WriteBreakInPacket(VOID)
{
    DWORD BytesWritten;
    BOOL Succ;

    KdOut("Send Break in ...\n");
    FlushCallbacks();

    for (;;)
    {
        Succ = Write(&s_BreakinPacket[0], sizeof(s_BreakinPacket),
                   &BytesWritten);
        if (Succ && BytesWritten == sizeof(s_BreakinPacket))
        {
            break;
        }

        // Avoid consuming 100% of the CPU when spinning.
        Sleep(10);
    }

    m_BreakIn = FALSE;
    m_PacketsWritten++;
}

VOID
DbgKdTransport::WriteControlPacket(
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This function writes a control packet to target machine.

    N.B. a CONTROL Packet header is sent with the following information:
         PacketLeader - indicates it's a control packet
         PacketType - indicates the type of the control packet
         ByteCount - aways zero to indicate no data following the header
         PacketId - Valid ONLY for PACKET_TYPE_KD_ACKNOWLEDGE to indicate
                    which packet is acknowledged.

Arguments:

    PacketType - Supplies the type of the control packet.

    PacketId - Supplies the PacketId.  Used by Acknowledge packet only.

Return Value:

    None.

--*/
{
    DWORD BytesWritten;
    BOOL Succ;
    KD_PACKET Packet;

    DBG_ASSERT( (m_Target->m_KdMaxPacketType == 0 &&
                 PacketType < PACKET_TYPE_MAX) ||
                (m_Target->m_KdMaxPacketType > 0 &&
                 PacketType < m_Target->m_KdMaxPacketType) );

    Packet.PacketLeader = CONTROL_PACKET_LEADER;
    Packet.ByteCount = 0;
    Packet.PacketType = PacketType;
    if (PacketId)
    {
        Packet.PacketId = PacketId;
    }
    else
    {
        Packet.PacketId = 0;
    }
    Packet.Checksum = 0;

    for (;;)
    {
        // Write the control packet header.  We need this
        // to be sent so retry until the write succeeds.
        Succ = Write(&Packet, sizeof(Packet), &BytesWritten);
        if (Succ && BytesWritten == sizeof(Packet))
        {
            break;
        }

        // Avoid consuming 100% of the CPU when spinning.
        Sleep(10);
    }

    m_PacketsWritten++;
}

VOID
DbgKdTransport::WriteDataPacket(
    IN PVOID PacketData,
    IN USHORT PacketDataLength,
    IN USHORT PacketType,
    IN PVOID MorePacketData OPTIONAL,
    IN USHORT MorePacketDataLength OPTIONAL,
    IN BOOL NoAck
    )
{
    KD_PACKET Packet;
    USHORT TotalBytesToWrite;
    DBGKD_MANIPULATE_STATE32 m32;
    PVOID ConvertedPacketData = NULL;

    DBG_ASSERT( (m_Target->m_KdMaxPacketType == 0 &&
                 PacketType < PACKET_TYPE_MAX) ||
                (m_Target->m_KdMaxPacketType > 0 &&
                 PacketType < m_Target->m_KdMaxPacketType) );

    // Packets can only be written when the kernel transport
    // is not in use.
    if (m_WaitingThread != 0 &&
        m_WaitingThread != GetCurrentThreadId())
    {
        ErrOut("Kernel transport in use, packet write failed\n");
        return;
    }

    KdOut("WRITE: Write type %x packet id= %lx.\n",
          PacketType, m_NextPacketToSend);

    if (!m_Target->m_KdApi64 &&
        PacketType == PACKET_TYPE_KD_STATE_MANIPULATE)
    {
        PacketDataLength = (USHORT)
            DbgkdManipulateState64To32((PDBGKD_MANIPULATE_STATE64)PacketData,
                                       &m32);
        PacketData = (PVOID)&m32;
        if (m32.ApiNumber == DbgKdWriteBreakPointExApi)
        {
            ConvertedPacketData = malloc(MorePacketDataLength / 2);
            if (!ConvertedPacketData)
            {
                ErrOut("Failed to allocate Packet Data\n");
                return;
            }
            ConvertQwordsToDwords((PULONG64)PacketData,
                                  (PULONG)ConvertedPacketData,
                                  MorePacketDataLength / 8);
            MorePacketData = ConvertedPacketData;
            MorePacketDataLength /= 2;
        }
    }

    if ( ARGUMENT_PRESENT(MorePacketData) )
    {
        TotalBytesToWrite = PacketDataLength + MorePacketDataLength;
        Packet.Checksum = ComputeChecksum((PUCHAR)MorePacketData,
                                          MorePacketDataLength);
    }
    else
    {
        TotalBytesToWrite = PacketDataLength;
        Packet.Checksum = 0;
    }
    Packet.Checksum += ComputeChecksum((PUCHAR)PacketData,
                                       PacketDataLength);
    Packet.PacketLeader = PACKET_LEADER;
    Packet.ByteCount = TotalBytesToWrite;
    Packet.PacketType = PacketType;

    g_PacketLog[g_PacketLogIndex++ & (PACKET_LOG_SIZE - 1)] =
        ((ULONG64)0xF << 60) | ((ULONG64)PacketType << 32) | TotalBytesToWrite;

    for (;;)
    {
        Packet.PacketId = m_NextPacketToSend;

        if (WritePacketContents(&Packet, PacketData, PacketDataLength,
                                MorePacketData, MorePacketDataLength,
                                NoAck) == DBGKD_WRITE_PACKET)
        {
            m_PacketsWritten++;
            break;
        }
    }

    if (ConvertedPacketData)
    {
        free(ConvertedPacketData);
    }
}

ULONG
DbgKdTransport::ComputeChecksum(
    IN PUCHAR Buffer,
    IN ULONG Length
    )
{
    ULONG Checksum = 0;

    while (Length > 0)
    {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }

    return Checksum;
}

void
DbgKdTransport::HandlePrint(IN ULONG Processor,
                            IN PCSTR String,
                            IN USHORT StringLength,
                            IN ULONG Mask)
{
    DWORD i;
    DWORD j;
    CHAR c;
    PSTR d;

    DBG_ASSERT(StringLength < PACKET_MAX_SIZE - 2);

    // This routine can be called during a wait when the
    // engine lock isn't held and can also be called when
    // the lock is held.  RESUME handles both of these
    // cases so that the lock is reacquired or reentered.
    RESUME_ENGINE();

    if (m_Target->m_NumProcessors > 1 &&
        Processor != g_LastProcessorToPrint)
    {
        g_LastProcessorToPrint = Processor;
        MaskOut(Mask, "%d:", Processor);
    }

    StartOutLine(Mask, OUT_LINE_NO_PREFIX);

    //
    // Add the original data to the print buffer.
    //

    d = g_PrintBuf;

    for (i = 0; i < StringLength ; i++)
    {
        c = *(String + i);
        if ( c == '\n' )
        {
            g_LastProcessorToPrint = -1;
            *d++ = '\n';
            *d++ = '\r';
        }
        else
        {
            if ( c )
            {
                *d++ = c;
            }
        }
    }

    j = (DWORD)(d - g_PrintBuf);

    //
    // print the string.
    //

    MaskOut(Mask, "%*.*s", j, j, g_PrintBuf);

    SUSPEND_ENGINE();
}

void
DbgKdTransport::HandlePromptString(IN PDBGKD_DEBUG_IO IoMessage)
{
    PSTR IoData;
    DWORD j;

    // This routine can be called during a wait when the
    // engine lock isn't held and can also be called when
    // the lock is held.  RESUME handles both of these
    // cases so that the lock is reacquired or reentered.
    RESUME_ENGINE();

    IoData = (PSTR)(IoMessage + 1);

    HandlePrint(IoMessage->Processor,
                IoData,
                (USHORT)IoMessage->u.GetString.LengthOfPromptString,
                DEBUG_OUTPUT_DEBUGGEE_PROMPT);

    //
    // read the prompt data
    //

    j = GetInput(NULL, IoData,
                 IoMessage->u.GetString.LengthOfStringRead,
                 GETIN_LOG_INPUT_LINE);
    if (j == 0)
    {
        j = IoMessage->u.GetString.LengthOfStringRead;
        memset(IoData, 0, j);
    }

    g_LastProcessorToPrint = -1;
    if ( j < (USHORT)IoMessage->u.GetString.LengthOfStringRead )
    {
        IoMessage->u.GetString.LengthOfStringRead = j;
    }

    SUSPEND_ENGINE();

    //
    // Send data to the debugger-target
    //

    WritePacket(IoMessage, sizeof(*IoMessage),
                PACKET_TYPE_KD_DEBUG_IO, IoData,
                (USHORT)IoMessage->u.GetString.LengthOfStringRead);
}

void
DbgKdTransport::HandlePrintTrace(IN ULONG Processor,
                                 IN PUCHAR Data,
                                 IN USHORT DataLength,
                                 IN ULONG Mask)
{
    // This routine can be called during a wait when the
    // engine lock isn't held and can also be called when
    // the lock is held.  RESUME handles both of these
    // cases so that the lock is reacquired or reentered.
    RESUME_ENGINE();

    DebugClient* Client;

    // Find a client with output callbacks to use for output.
    for (Client = g_Clients; Client != NULL; Client = Client->m_Next)
    {
        if (Client->m_OutputCb != NULL)
        {
            break;
        }
    }
    if (Client == NULL)
    {
        // No clients have output callbacks so nobody
        // cares about output and we can just quit.
        goto Exit;
    }

    // Prefix the entire output block with the processor
    // number as we can't (and don't want to) get involved
    // in the individual messages.
    if (m_Target->m_NumProcessors > 1 &&
        Processor != g_LastProcessorToPrint)
    {
        g_LastProcessorToPrint = Processor;
        MaskOut(Mask, "%d", Processor);
    }

    if (g_WmiFormatTraceData == NULL)
    {
        EXTDLL* WmiExt;

        // Prevent notifications from this low level call.
        g_EngNotify++;

        WmiExt = AddExtensionDll("wmitrace", FALSE, m_Target, NULL);
        if (WmiExt)
        {
            LoadExtensionDll(m_Target, WmiExt);
        }

        g_EngNotify--;
    }

    if (g_WmiFormatTraceData == NULL)
    {
        ErrOut("Missing or incorrect wmitrace.dll - "
               "0x%X byte trace data buffer ignored\n",
               DataLength);
    }
    else
    {
        g_WmiFormatTraceData((PDEBUG_CONTROL)(IDebugControlN*)Client,
                             Mask, DataLength, Data);
    }

 Exit:
    SUSPEND_ENGINE();
}

KD_FILE_ASSOC*
DbgKdTransport::FindKdFileAssoc(PWSTR From)
{
    PLIST_ENTRY Entry;
    KD_FILE_ASSOC* Assoc;

    for (Entry = m_KdFileAssoc.Flink;
         Entry != &m_KdFileAssoc;
         Entry = Entry->Flink)
    {
        Assoc = CONTAINING_RECORD(Entry, KD_FILE_ASSOC, List);

        if (!_wcsicmp(From, Assoc->From))
        {
            return Assoc;
        }
    }

    return NULL;
}

void
DbgKdTransport::ClearKdFileAssoc(void)
{
    while (!IsListEmpty(&m_KdFileAssoc))
    {
        KD_FILE_ASSOC* Assoc;

        Assoc = CONTAINING_RECORD(m_KdFileAssoc.Flink, KD_FILE_ASSOC, List);
        RemoveEntryList(&Assoc->List);
        free(Assoc);
    }

    m_KdFileAssocSource[0] = 0;
}

HRESULT
DbgKdTransport::LoadKdFileAssoc(PSTR FileName)
{
    HRESULT Status;
    FILE* File;
    char Op[32], From[MAX_PATH], To[MAX_PATH];

    File = fopen(FileName, "r");
    if (File == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    ClearKdFileAssoc();

    Status = S_OK;
    for (;;)
    {
        ULONG Len;

        if (fgets(Op, sizeof(Op), File) == NULL)
        {
            break;
        }

        // Remove newline if present.
        Len = strlen(Op);
        if (Len > 0 && Op[Len - 1] == '\n')
        {
            Op[Len - 1] = 0;
        }

        // Skip blank lines between sections and
        // allow comments starting with '#'.
        if (Op[0] == '#' || !Op[0])
        {
            continue;
        }

        if (_stricmp(Op, "map") != 0)
        {
            Status = E_INVALIDARG;
            break;
        }

        if (fgets(From, sizeof(From), File) == NULL ||
            fgets(To, sizeof(To), File) == NULL)
        {
            Status = E_INVALIDARG;
            break;
        }

        // Remove newlines if present.
        Len = strlen(From);
        if (Len > 0 && From[Len - 1] == '\n')
        {
            From[Len - 1] = 0;
        }
        Len = strlen(To);
        if (Len > 0 && To[Len - 1] == '\n')
        {
            To[Len - 1] = 0;
        }

        KD_FILE_ASSOC* Assoc;

        Assoc = (KD_FILE_ASSOC*)malloc(sizeof(KD_FILE_ASSOC) +
                                       (strlen(From) + 1) * sizeof(WCHAR) +
                                       strlen(To) + 1);
        if (Assoc == NULL)
        {
            Status = E_OUTOFMEMORY;
            break;
        }

        Assoc->From = (PWSTR)(Assoc + 1);
        if (MultiByteToWideChar(CP_ACP, 0, From, -1, Assoc->From,
                                sizeof(From) / sizeof(WCHAR)) == 0)
        {
            Status = WIN32_LAST_STATUS();
            break;
        }

        Assoc->To = (PSTR)(Assoc->From + strlen(From) + 1);
        strcpy(Assoc->To, To);

        InsertHeadList(&m_KdFileAssoc, &Assoc->List);
    }

    fclose(File);

    if (Status == S_OK)
    {
        CopyString(m_KdFileAssocSource, FileName, DIMA(m_KdFileAssocSource));
    }

    return Status;
}

void
DbgKdTransport::InitKdFileAssoc(void)
{
    PSTR Env;

    InitializeListHead(&m_KdFileAssoc);
    m_KdFileAssocSource[0] = 0;

    Env = getenv("_NT_KD_FILES");
    if (Env != NULL)
    {
        LoadKdFileAssoc(Env);
    }
}

void
DbgKdTransport::ParseKdFileAssoc(void)
{
    if (PeekChar() == ';' || *g_CurCmd == 0)
    {
        if (m_KdFileAssocSource[0])
        {
            dprintf("KD file assocations loaded from '%s'\n",
                    m_KdFileAssocSource);
        }
        else
        {
            dprintf("No KD file associations set\n");
        }
        return;
    }

    while (PeekChar() == '-' || *g_CurCmd == '/')
    {
        g_CurCmd++;
        switch(*g_CurCmd++)
        {
        case 'c':
            ClearKdFileAssoc();
            dprintf("KD file associations cleared\n");
            return;
        default:
            ErrOut("Unknown option '%c'\n", *(g_CurCmd - 1));
            break;
        }
    }

    PSTR FileName;
    CHAR Save;

    FileName = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
    if (LoadKdFileAssoc(FileName) == S_OK)
    {
        dprintf("KD file assocations loaded from '%s'\n", FileName);
    }
    else
    {
        dprintf("Unable to load KD file associations from '%s'\n", FileName);
    }
    *g_CurCmd = Save;
}

NTSTATUS
DbgKdTransport::CreateKdFile(PWSTR FileName,
                             ULONG DesiredAccess, ULONG FileAttributes,
                             ULONG ShareAccess, ULONG CreateDisposition,
                             ULONG CreateOptions,
                             KD_FILE** FileEntry, PULONG64 Length)
{
    ULONG Access, Create;
    KD_FILE* File;
    KD_FILE_ASSOC* Assoc;

    Assoc = FindKdFileAssoc(FileName);
    if (Assoc == NULL)
    {
        return STATUS_NO_SUCH_FILE;
    }

    File = new KD_FILE;
    if (File == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    Access = 0;
    if (DesiredAccess & FILE_READ_DATA)
    {
        Access |= GENERIC_READ;
    }
    if (DesiredAccess & FILE_WRITE_DATA)
    {
        Access |= GENERIC_WRITE;
    }

    switch(CreateDisposition)
    {
    case FILE_OPEN:
        Create = OPEN_EXISTING;
        break;
    case FILE_CREATE:
        Create = CREATE_NEW;
        break;
    case FILE_OPEN_IF:
        Create = OPEN_ALWAYS;
        break;
    case FILE_OVERWRITE_IF:
        Create = CREATE_ALWAYS;
        break;
    default:
        delete File;
        return STATUS_INVALID_PARAMETER;
    }

    // No interesting CreateOptions at this point.

    File->Handle = CreateFile(Assoc->To, Access, ShareAccess, NULL,
                              Create, FileAttributes, NULL);
    if (File->Handle == NULL || File->Handle == INVALID_HANDLE_VALUE)
    {
        delete File;
        switch(GetLastError())
        {
        case ERROR_FILE_NOT_FOUND:
            return STATUS_NO_SUCH_FILE;
        case ERROR_ACCESS_DENIED:
            return STATUS_ACCESS_DENIED;
        default:
            return STATUS_UNSUCCESSFUL;
        }
    }

    ULONG SizeLow;
    LONG SizeHigh = 0;

    SizeLow = SetFilePointer(File->Handle, 0, &SizeHigh, FILE_END);
    if (SizeLow == INVALID_SET_FILE_POINTER && GetLastError())
    {
        CloseHandle(File->Handle);
        delete File;
        return STATUS_UNSUCCESSFUL;
    }

    *Length = ((ULONG64)SizeHigh << 32) | SizeLow;

    dprintf("KD: Accessing '%s' (%ws)\n  ", Assoc->To, FileName);
    if (*Length > 0)
    {
        dprintf("File size %dK", KBYTES(*Length));
    }
    // Progress dots will be printed for each read/write.

    File->Signature = KD_FILE_SIGNATURE;
    InsertHeadList(&m_KdFiles, &File->List);
    *FileEntry = File;
    return STATUS_SUCCESS;
}

void
DbgKdTransport::CloseKdFile(KD_FILE* File)
{
    RemoveEntryList(&File->List);
    CloseHandle(File->Handle);
    File->Signature = 0;
    delete File;
}

KD_FILE*
DbgKdTransport::TranslateKdFileHandle(ULONG64 Handle)
{
    KD_FILE* File = (KD_FILE*)(ULONG_PTR)Handle;

    if (IsBadWritePtr(File, sizeof(*File)) ||
        File->Signature != KD_FILE_SIGNATURE)
    {
        return NULL;
    }

    return File;
}

//----------------------------------------------------------------------------
//
// DbgKdComTransport.
//
//----------------------------------------------------------------------------

// Environment variable names.
#define COM_PORT_NAME   "_NT_DEBUG_PORT"
#define COM_PORT_BAUD   "_NT_DEBUG_BAUD_RATE"

// Parameter string names.
#define PARAM_COM_BAUD    "Baud"
#define PARAM_COM_IP_PORT "IpPort"
#define PARAM_COM_MODEM   "Modem"
#define PARAM_COM_PIPE    "Pipe"
#define PARAM_COM_PORT    "Port"
#define PARAM_COM_RESETS  "Resets"
#define PARAM_COM_TIMEOUT "Timeout"

DbgKdComTransport::DbgKdComTransport(ConnLiveKernelTargetInfo* Target)
    : DbgKdTransport(Target)
{
    m_Index = DBGKD_TRANSPORT_COM;
    m_Name = g_DbgKdTransportNames[m_Index];
    m_InvPacketRetryLimit = 0;
    m_AckWrites = TRUE;
    m_Handle = NULL;
    m_EventOverlapped.hEvent = NULL;
}

DbgKdComTransport::~DbgKdComTransport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
    }
    if (m_EventOverlapped.hEvent != NULL)
    {
        CloseHandle(m_EventOverlapped.hEvent);
    }
}

ULONG
DbgKdComTransport::GetNumberParameters(void)
{
    return 5 + DbgKdTransport::GetNumberParameters();
}

void
DbgKdComTransport::GetParameter(ULONG Index,
                                PSTR Name, ULONG NameSize,
                                PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        CopyString(Name, PARAM_COM_PORT, NameSize);
        CopyString(Value, m_PortName, ValueSize);
        break;
    case 1:
        CopyString(Name, PARAM_COM_BAUD, NameSize);
        PrintString(Value, ValueSize, "%d", m_BaudRate);
        break;
    case 2:
        switch(m_PortType)
        {
        case COM_PORT_MODEM:
            CopyString(Name, PARAM_COM_MODEM, NameSize);
            break;
        case COM_PORT_PIPE:
            CopyString(Name, PARAM_COM_PIPE, NameSize);
            break;
        case COM_PORT_SOCKET:
            CopyString(Name, PARAM_COM_IP_PORT, NameSize);
            PrintString(Value, ValueSize, "%d", m_IpPort);
            break;
        }
        break;
    case 3:
        CopyString(Name, PARAM_COM_TIMEOUT, NameSize);
        PrintString(Value, ValueSize, "%d", m_Timeout);
        break;
    case 4:
        if (m_MaxSyncResets)
        {
            CopyString(Name, PARAM_COM_RESETS, NameSize);
            PrintString(Value, ValueSize, "%d", m_MaxSyncResets);
        }
        break;
    default:
        DbgKdTransport::GetParameter(Index - 4,
                                     Name, NameSize, Value, ValueSize);
        break;
    }
}

void
DbgKdComTransport::ResetParameters(void)
{
    PSTR Env;

    DbgKdTransport::ResetParameters();

    if ((Env = getenv(COM_PORT_NAME)) == NULL)
    {
        Env = "com1";
    }
    SetComPortName(Env, m_PortName, DIMA(m_PortName));

    if ((Env = getenv(COM_PORT_BAUD)) != NULL)
    {
        m_BaudRate = atol(Env);
    }
    else
    {
        m_BaudRate = 19200;
    }

    m_PortType = COM_PORT_STANDARD;
    m_Timeout = 4000;
    m_CurTimeout = m_Timeout;
    m_MaxSyncResets = 0;
    m_IpPort = 0;
}

BOOL
DbgKdComTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, PARAM_COM_PORT))
    {
        if (!Value)
        {
            ErrOut(PARAM_COM_PORT " requires a value\n");
            return FALSE;
        }

        if (!SetComPortName(Value, m_PortName, DIMA(m_PortName)))
        {
            return FALSE;
        }
    }
    else if (!_strcmpi(Name, PARAM_COM_BAUD))
    {
        if (!Value)
        {
            ErrOut(PARAM_COM_BAUD " requires a numeric value\n");
            return FALSE;
        }

        m_BaudRate = atol(Value);
    }
    else if (!_strcmpi(Name, PARAM_COM_IP_PORT))
    {
        if (!Value)
        {
            ErrOut(PARAM_COM_IP_PORT " requires a numeric value\n");
            return FALSE;
        }

        m_PortType = COM_PORT_SOCKET;
        m_IpPort = atol(Value);
    }
    else if (!_strcmpi(Name, PARAM_COM_MODEM))
    {
        m_PortType = COM_PORT_MODEM;
    }
    else if (!_strcmpi(Name, PARAM_COM_PIPE))
    {
        m_PortType = COM_PORT_PIPE;
        m_MaxSyncResets = 2;
    }
    else if (!_strcmpi(Name, PARAM_COM_RESETS))
    {
        if (!Value)
        {
            ErrOut(PARAM_COM_RESETS " requires a numeric value\n");
            return FALSE;
        }

        m_MaxSyncResets = atol(Value);
    }
    else if (!_strcmpi(Name, PARAM_COM_TIMEOUT))
    {
        if (!Value)
        {
            ErrOut(PARAM_COM_TIMEOUT " requires a numeric value\n");
            return FALSE;
        }

        m_Timeout = atol(Value);
        m_CurTimeout = m_Timeout;
    }
    else
    {
        return DbgKdTransport::SetParameter(Name, Value);
    }

    return TRUE;
}

HRESULT
DbgKdComTransport::Initialize(void)
{
    HRESULT Status;

    if ((Status = DbgKdTransport::Initialize()) != S_OK)
    {
        return Status;
    }

    m_DirectPhysicalMemory = FALSE;

    COM_PORT_PARAMS ComParams;

    ZeroMemory(&ComParams, sizeof(ComParams));
    ComParams.Type = m_PortType;
    ComParams.PortName = m_PortName;
    ComParams.BaudRate = m_BaudRate;
    ComParams.Timeout = m_Timeout;
    ComParams.IpPort = m_IpPort;
    if ((Status = OpenComPort(&ComParams, &m_Handle, &m_BaudRate)) != S_OK)
    {
        ErrOut("Failed to open %s\n", m_PortName);
        return Status;
    }

    dprintf("Opened %s\n", m_PortName);

    m_ComEvent = 0;
    if (m_PortType == COM_PORT_MODEM)
    {
        DWORD Mask;

        //
        //  Debugger is being run over a modem.  Set event to watch
        //  carrier detect.
        //

        GetCommMask (m_Handle, &Mask);
        // set DDCD event
        if (!SetCommMask (m_Handle, Mask | 0xA0))
        {
            ErrOut("Failed to set event for %s.\n", m_PortName);
            return WIN32_LAST_STATUS();
        }

        m_EventOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_EventOverlapped.hEvent)
        {
            ErrOut("Failed to create EventOverlapped\n");
            return WIN32_LAST_STATUS();
        }

        m_EventOverlapped.Offset = 0;
        m_EventOverlapped.OffsetHigh = 0;

        // Fake an event, so modem status will be checked
        m_ComEvent = 1;
    }

    return S_OK;
}

BOOL
DbgKdComTransport::Read(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesRead
    )
{
    if (IS_DUMP_TARGET(m_Target))
    {
        ErrOut( "Attempted to read KD transport while "
                "debugging a crash dump\n" );
        DebugBreak();
    }

    if (m_ComEvent)
    {
        CheckComStatus ();
    }

    //
    // In pipe mode it's possible that only part of the
    // desired data is available, so loop reading pieces
    // of data as long as there are successful reads.
    //

    *BytesRead = 0;
    while (SizeOfBuffer > 0)
    {
        ULONG _BytesRead=0;

        if (ComPortRead(m_Handle, m_PortType, m_CurTimeout,
                        Buffer, SizeOfBuffer, &_BytesRead, &m_ReadOverlapped))
        {
            if (m_OutputIo & DBGKD_OUTPUT_READS)
            {
                OutputIo("COM: Read %d bytes of %d\n",
                         Buffer, SizeOfBuffer, _BytesRead);
            }

            Buffer = (PVOID)((PUCHAR)Buffer + _BytesRead);
            SizeOfBuffer -= _BytesRead;
            *BytesRead += _BytesRead;
            m_BytesRead += _BytesRead;

            // If this isn't a net connection stop reading if
            // we got less than the requested amount of data.
            if (!NET_COM_PORT(m_PortType) &&
                _BytesRead < SizeOfBuffer)
            {
                break;
            }
        }
        else if (*BytesRead == 0)
        {
            // If a read failed with nothing read return an error.
            return FALSE;
        }
        else
        {
            // Read failed, so stop trying to read.
            break;
        }
    }

    return TRUE;
}

BOOL
DbgKdComTransport::Write(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesWritten
    )
{
    if (IS_DUMP_TARGET(m_Target))
    {
        ErrOut( "Attempted to write KD transport "
                "while debugging a crash dump\n" );
        DebugBreak();
    }

    if (m_ComEvent)
    {
        CheckComStatus ();
    }

    //
    // Break up large writes in smaller chunks
    // to try and avoid sending too much data
    // to the target all at once.  Sleep a bit
    // between chunks to let the target retrieve
    // data.
    //

    BOOL Succ = TRUE;
    *BytesWritten = 0;
    while (SizeOfBuffer > 0)
    {
        ULONG Request, Done;

        // By default we want to encourage vendors
        // to create machines with robust serial
        // support so we don't actually limit
        // the write size.
#if THROTTLE_WRITES
        Request = 96;
#else
        Request = 0xffffffff;
#endif
        if (SizeOfBuffer < Request)
        {
            Request = SizeOfBuffer;
        }

        if (!ComPortWrite(m_Handle, m_PortType, Buffer, Request, &Done,
                          &m_WriteOverlapped))
        {
            Succ = FALSE;
            break;
        }

        if (m_OutputIo & DBGKD_OUTPUT_WRITES)
        {
            OutputIo("COM: Wrote %d bytes of %d\n",
                     Buffer, Request, Done);
        }

        *BytesWritten += Done;
        if (Done <= Request)
        {
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Done);
        SizeOfBuffer -= Done;

        Sleep(10);
    }

    m_BytesWritten += *BytesWritten;
    return Succ;
}

void
DbgKdComTransport::CycleSpeed(void)
{
    if (NET_COM_PORT(m_PortType))
    {
        ErrOut("Net COM port baud is ignored\n");
        return;
    }

    if (SetComPortBaud(m_Handle, 0, &m_BaudRate) != S_OK)
    {
        ErrOut("New Baud rate Could not be set on Com %I64x - remains %d.\n",
               (ULONG64)m_Handle, m_BaudRate);
    }
    else
    {
        dprintf("Baud rate set to %d\n", m_BaudRate);
    }
}

VOID
DbgKdComTransport::Synchronize(VOID)
{
    USHORT Index;
    UCHAR DataByte, PreviousDataByte;
    USHORT PacketType = 0;
    ULONG TimeoutCount = 0;
    COMMTIMEOUTS CommTimeouts;
    COMMTIMEOUTS OldTimeouts;
    DWORD BytesRead;
    BOOL Succ;
    BOOL SendReset;
    ULONG DataLoops = 0;
    ULONG ResetsSent = 0;

    //
    // Get the old time out values and hold them.
    // We then set a new total timeout value of
    // a fraction of the base timeout.
    //

#define TIMEOUT_ITERATIONS 6

    m_CurTimeout = m_Timeout / 8;
    if (!NET_COM_PORT(m_PortType))
    {
        GetCommTimeouts(m_Handle, &OldTimeouts);

        CommTimeouts = OldTimeouts;
        CommTimeouts.ReadIntervalTimeout = 0;
        CommTimeouts.ReadTotalTimeoutMultiplier = 0;
        CommTimeouts.ReadTotalTimeoutConstant = m_CurTimeout;

        SetCommTimeouts(m_Handle, &CommTimeouts);
    }

    FlushCallbacks();

    // Emulators that fill pipes from emulated serial ports
    // can end up buffering a huge amount of data.  Drain
    // everything off before we start resyncing.
    if (NET_COM_PORT(m_PortType))
    {
        while (Read(&DataByte, 1, &BytesRead) &&
               BytesRead == 1)
        {
            // Loop
        }
    }

    // Always send a reset the first time around.
    SendReset = TRUE;

    while (TRUE)
    {

Timeout:
        // When sending data to a pipe assume that it's stored
        // rather than being discarded as would happen with an
        // overfull true serial port.  Therefore, limit the
        // total number of reset packets sent as stuffing more
        // in the pipe will just cause a huge number of responses.
        if (SendReset &&
            (!m_MaxSyncResets || ResetsSent < m_MaxSyncResets))
        {
            WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);
            ResetsSent++;
        }

        //
        // Read packet leader
        //

        BOOL First = TRUE;

        Index = 0;
        do
        {
            if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
            {
                KdOut("Synchronize interrupted by exit request\n");
                goto Exit;
            }

            //
            // if we don't get response from kernel in 3 seconds we
            // will resend the reset packet if user does not type ctrl_c.
            // Otherwise, we send breakin character and wait for data again.
            //

            Succ = Read(&DataByte, 1, &BytesRead);
            if ((!Succ) || (BytesRead != 1))
            {
                //
                // Check user input for control_c.  If user types control_c,
                // we will send a breakin packet to the target.  Hopefully,
                // target will send us a StateChange packet and we'll
                // stop waiting.
                //

                if (m_BreakIn || m_SyncBreakIn)
                {
                    m_SyncBreakIn = FALSE;
                    WriteBreakInPacket();
                    TimeoutCount = 0;
                    continue;
                }
                TimeoutCount++;

                //
                // if we have been waiting for 3 seconds, resend RESYNC packet
                //

                if (TimeoutCount < TIMEOUT_ITERATIONS)
                {
                    continue;
                }
                TimeoutCount = 0;

                KdOut("SYNCTARGET: Timeout.\n");
                FlushCallbacks();

                SendReset = TRUE;
                goto Timeout;
            }

#if DBG_SYNCH
            if (Succ && BytesRead == 1 && First)
            {
                dprintf("First byte %X\n", DataByte);
                First = FALSE;
            }
#endif

            if (Succ && BytesRead == 1 &&
                ( DataByte == PACKET_LEADER_BYTE ||
                  DataByte == CONTROL_PACKET_LEADER_BYTE)
                )
            {
                if ( Index == 0 )
                {
                    PreviousDataByte = DataByte;
                    Index++;
                }
                else if ( DataByte == PreviousDataByte )
                {
                    Index++;
                }
                else
                {
                    PreviousDataByte = DataByte;
                    Index = 1;
                }
            }
            else
            {
                Index = 0;

                if (Succ && BytesRead == 1)
                {
                    // The target machine is alive and talking but
                    // the received data is in the middle of
                    // a packet.  Break out of the header byte
                    // loop and consume up to a trailer byte.
                    break;
                }
            }
        }
        while ( Index < 4 );

        if (Index == 4 && DataByte == CONTROL_PACKET_LEADER_BYTE)
        {
            //
            // Read 2 byte Packet type
            //

            Succ = Read((PUCHAR)&PacketType,
                      sizeof(PacketType), &BytesRead);

            if (Succ && BytesRead == sizeof(PacketType) &&
                PacketType == PACKET_TYPE_KD_RESET)
            {
                KdOut("SYNCTARGET: Received KD_RESET ACK packet.\n");

                m_PacketExpected = INITIAL_PACKET_ID;
                m_NextPacketToSend = INITIAL_PACKET_ID;

                KdOut("SYNCTARGET: Target synchronized successfully...\n");
                FlushCallbacks();

                goto Exit;
            }
        }

        //
        // If we receive Data Packet leader, it means target has not
        // receive our reset packet. So we loop back and send it again.
        // N.B. We need to wait until target finishes sending the packet.
        // Otherwise, we may be sending the reset packet while the target
        // is sending the packet. This might cause target loss the reset
        // packet.
        //
        // Sometimes machines just send continuous streams of
        // garbage, which can cause an infinite loop here if
        // the garbage never contains a trailing byte.  Break
        // this loop after a certain amount of garbage is received.
        //

        Index = 0;
        while (DataByte != PACKET_TRAILING_BYTE &&
               Index < 2 * PACKET_MAX_SIZE)
        {
            Succ = Read(&DataByte, 1, &BytesRead);
            if (!Succ || BytesRead != 1)
            {
                DataByte = ~PACKET_TRAILING_BYTE;
                break;
            }

            Index++;
        }

#if DBG_SYNCH
        dprintf("  ate %x bytes\n", Index);
        FlushCallbacks();
#endif

        if (DataByte == PACKET_TRAILING_BYTE)
        {
            // We've consumed up to a trailing byte but
            // there's no guarantee that the byte is not
            // part of the payload of a packet.  However,
            // the target is still talking to us so
            // avoid sending a reset and provoking more
            // packets.  There are cases, though, where
            // the target machine continuously sends data
            // and we end up not sending any more reset
            // packets.  Send a reset packet every once
            // in a while to make sure we don't get stuck here.
            if (++DataLoops == 4)
            {
                DataLoops = 0;
                SendReset = TRUE;
            }
            else
            {
                SendReset = FALSE;
            }
        }
        else
        {
            // Target stopped talking before we got a
            // data byte, so attempt to reset.
            SendReset = TRUE;
        }
    }

 Exit:
    m_CurTimeout = m_Timeout;
    if (!NET_COM_PORT(m_PortType))
    {
        SetCommTimeouts(m_Handle, &OldTimeouts);
    }
}

ULONG
DbgKdComTransport::ReadPacketContents(IN USHORT PacketType)
{
    DWORD BytesRead;
    BOOL Succ;
    UCHAR DataByte;
    ULONG Checksum;
    ULONG SyncBit;
    ULONG WaitStatus;

    //
    // First read a packet leader
    //

WaitForPacketLeader:

    WaitStatus = ReadPacketLeader(PacketType, &s_PacketHeader.PacketLeader);
    if (WaitStatus != DBGKD_WAIT_PACKET)
    {
        return WaitStatus;
    }
    if (m_AllowInitialBreak && (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK))
    {
        KdOut("Attempting to get initial breakpoint.\n");
        WriteBreakInPacket();
    }

    // We've either sent the initial break or we don't want
    // one.  Either way we don't need to send another one.
    m_AllowInitialBreak = FALSE;

    //
    // Read packetLeader ONLY read two Packet Leader bytes.  This do loop
    // filters out the remaining leader byte.
    //

    do
    {
        Succ = Read(&DataByte, 1, &BytesRead);
        if ((Succ) && BytesRead == 1)
        {
            if (DataByte == PACKET_LEADER_BYTE ||
                DataByte == CONTROL_PACKET_LEADER_BYTE)
            {
                continue;
            }
            else
            {
                *(PUCHAR)&s_PacketHeader.PacketType = DataByte;
                break;
            }
        }
        else
        {
            goto WaitForPacketLeader;
        }
    } while (TRUE);

    //
    // Now we have valid packet leader. Read rest of the packet type.
    //

    Succ = Read(((PUCHAR)&s_PacketHeader.PacketType) + 1,
              sizeof(s_PacketHeader.PacketType) - 1, &BytesRead);
    if ((!Succ) || BytesRead != sizeof(s_PacketHeader.PacketType) - 1)
    {
        //
        // If we cannot read the packet type and if the packet leader
        // indicates this is a data packet, we need to ask for resend.
        // Otherwise we simply ignore the incomplete packet.
        //

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header Type error (short read).\n");
        }

        goto WaitForPacketLeader;
    }

    //
    // Check the Packet type.
    //

    if ((m_Target->m_KdMaxPacketType == 0 &&
         s_PacketHeader.PacketType >= PACKET_TYPE_MAX) ||
        (m_Target->m_KdMaxPacketType > 0 &&
         s_PacketHeader.PacketType >= m_Target->m_KdMaxPacketType))
    {
        KdOut("READ: Received INVALID packet type.\n");

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
        }

        goto WaitForPacketLeader;
    }

    KdOut("      PacketType=%x, ", s_PacketHeader.PacketType);

    //
    // Read ByteCount
    //

    Succ = Read(&s_PacketHeader.ByteCount, sizeof(s_PacketHeader.ByteCount),
              &BytesRead);
    if ((!Succ) || BytesRead != sizeof(s_PacketHeader.ByteCount))
    {
        //
        // If we cannot read the packet type and if the packet leader
        // indicates this is a data packet, we need to ask for resend.
        // Otherwise we simply ignore the incomplete packet.
        //

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header ByteCount error (short read).\n");
        }

        goto WaitForPacketLeader;
    }

    //
    // Check ByteCount
    //

    if (s_PacketHeader.ByteCount > PACKET_MAX_SIZE)
    {
        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header ByteCount error (short read).\n");
        }

        goto WaitForPacketLeader;
    }

    KdOut("ByteCount=%x, ", s_PacketHeader.ByteCount);

    //
    // Read Packet Id
    //

    Succ = Read(&s_PacketHeader.PacketId, sizeof(s_PacketHeader.PacketId),
              &BytesRead);
    if ((!Succ) || BytesRead != sizeof(s_PacketHeader.PacketId))
    {
        //
        // If we cannot read the packet Id and if the packet leader
        // indicates this is a data packet, we need to ask for resend.
        // Otherwise we simply ignore the incomplete packet.
        //

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header Id error (short read).\n");
        }

        goto WaitForPacketLeader;
    }

    KdOut("PacketId=%x,\n", s_PacketHeader.PacketId);

    //
    // Don't read checksum here as in some cases
    // it isn't sent with control packets.
    //

    if (s_PacketHeader.PacketLeader == CONTROL_PACKET_LEADER )
    {
        if (s_PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE )
        {
            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (s_PacketHeader.PacketId != m_NextPacketToSend)
            {
                KdOut("READ: Received unmatched packet id = %lx, Type = %x\n",
                      s_PacketHeader.PacketId, s_PacketHeader.PacketType);
                goto WaitForPacketLeader;
            }
            else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
            {
                m_NextPacketToSend ^= 1;

                KdOut("READ: Received correct ACK packet.\n");
                FlushCallbacks();

                return DBGKD_WAIT_ACK;
            }
            else
            {
                goto WaitForPacketLeader;
            }
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESET)
        {
            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            m_NextPacketToSend = INITIAL_PACKET_ID;
            m_PacketExpected = INITIAL_PACKET_ID;
            WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

            KdOut("DbgKdpWaitForPacket(): Recieved KD_RESET packet, "
                  "send KD_RESET ACK packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESEND)
        {
            KdOut("READ: Received RESEND packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else
        {
            //
            // Invalid packet header, ignore it.
            //

            KdOut("READ: Received Control packet with UNKNOWN type\n");
            goto WaitForPacketLeader;
        }
    }
    else
    {
        //
        // The packet header is for data packet (not control packet).
        // Read Checksum.
        //

        Succ = Read(&s_PacketHeader.Checksum, sizeof(s_PacketHeader.Checksum),
                  &BytesRead);
        if ((!Succ) || BytesRead != sizeof(s_PacketHeader.Checksum))
        {
            WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdOut("READ: Data packet header "
                  "checksum error (short read).\n");
            goto WaitForPacketLeader;
        }

        if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE)
        {
            //
            // If we are waiting for ACK packet ONLY
            // and we receive a data packet header, check if the packet id
            // is what we expected.  If yes, assume the acknowledge is lost
            // (but sent) and process the packet.
            //

            if (s_PacketHeader.PacketId == m_PacketExpected)
            {
                m_NextPacketToSend ^= 1;
                KdOut("READ: Received VALID data packet "
                      "while waiting for ACK.\n");
            }
            else
            {
                KdOut("READ: Received Data packet with unmatched ID = %lx\n",
                      s_PacketHeader.PacketId);
                WriteControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                   s_PacketHeader.PacketId);
                goto WaitForPacketLeader;
            }
        }
    }

    //
    // We are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    if ((s_PacketHeader.PacketId & ~SYNC_PACKET_ID) != INITIAL_PACKET_ID &&
        (s_PacketHeader.PacketId & ~SYNC_PACKET_ID) != (INITIAL_PACKET_ID ^ 1))
    {
        KdOut("READ: Received INVALID packet Id.\n");
        return DBGKD_WAIT_RESEND;
    }

    Succ = Read(s_Packet, s_PacketHeader.ByteCount, &BytesRead);
    if ( (!Succ) || BytesRead != s_PacketHeader.ByteCount )
    {
        KdOut("READ: Data packet error (short read).\n");
        return DBGKD_WAIT_RESEND;
    }

    //
    // Make sure the next byte is packet trailing byte
    //

    Succ = Read(&DataByte, sizeof(DataByte), &BytesRead);
    if ( (!Succ) || BytesRead != sizeof(DataByte) ||
         DataByte != PACKET_TRAILING_BYTE )
    {
        KdOut("READ: Packet trailing byte timeout.\n");
        return DBGKD_WAIT_RESEND;
    }

    //
    // Make sure the checksum is valid.
    //

    Checksum = ComputeChecksum(s_Packet, s_PacketHeader.ByteCount);
    if (Checksum != s_PacketHeader.Checksum)
    {
        KdOut("READ: Checksum error.\n");
        return DBGKD_WAIT_RESEND;
    }

    //
    // We have a valid data packet.  If the packetid is bad, we just
    // ack the packet to the sender will step ahead.  If packetid is bad
    // but SYNC_PACKET_ID bit is set, we sync up.  If packetid is good,
    // or SYNC_PACKET_ID is set, we take the packet.
    //

    KdOut("READ: Received Type %x data packet with id = %lx successfully.\n\n",
          s_PacketHeader.PacketType, s_PacketHeader.PacketId);

    SyncBit = s_PacketHeader.PacketId & SYNC_PACKET_ID;
    s_PacketHeader.PacketId = s_PacketHeader.PacketId & ~SYNC_PACKET_ID;

    //
    // Ack the packet.  SYNC_PACKET_ID bit will ALWAYS be OFF.
    //

    WriteControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                       s_PacketHeader.PacketId);

    //
    // Check the incoming packet Id.
    //

    if ((s_PacketHeader.PacketId != m_PacketExpected) &&
        (SyncBit != SYNC_PACKET_ID))
    {
        KdOut("READ: Unexpected Packet Id (Acked).\n");
        goto WaitForPacketLeader;
    }
    else
    {
        if (SyncBit == SYNC_PACKET_ID)
        {
            //
            // We know SyncBit is set, so reset Expected Ids
            //

            KdOut("READ: Got Sync Id, reset PacketId.\n");

            m_PacketExpected = s_PacketHeader.PacketId;
            m_NextPacketToSend = INITIAL_PACKET_ID;
        }

        m_PacketExpected ^= 1;
    }

    return DBGKD_WAIT_PACKET;
}

ULONG
DbgKdComTransport::WritePacketContents(IN KD_PACKET* Packet,
                                       IN PVOID PacketData,
                                       IN USHORT PacketDataLength,
                                       IN PVOID MorePacketData OPTIONAL,
                                       IN USHORT MorePacketDataLength OPTIONAL,
                                       IN BOOL NoAck)
{
    BOOL Succ;
    ULONG BytesWritten;

    // Lock to ensure all parts of the data are
    // sequential in the stream.
    RESUME_ENGINE();

    //
    // Write the packet header
    //

    Succ = Write(Packet, sizeof(*Packet), &BytesWritten);
    if ( (!Succ) || BytesWritten != sizeof(*Packet))
    {
        //
        // An error occured writing the header, so write it again
        //

        KdOut("WRITE: Packet header error.\n");
        SUSPEND_ENGINE();
        return DBGKD_WRITE_RESEND;
    }

    //
    // Write the primary packet data
    //

    Succ = Write(PacketData, PacketDataLength, &BytesWritten);
    if ( (!Succ) || BytesWritten != PacketDataLength )
    {
        //
        // An error occured writing the primary packet data,
        // so write it again
        //

        KdOut("WRITE: Message header error.\n");
        SUSPEND_ENGINE();
        return DBGKD_WRITE_RESEND;
    }

    //
    // If secondary packet data was specified (WriteMemory, SetContext...)
    // then write it as well.
    //

    if ( ARGUMENT_PRESENT(MorePacketData) )
    {
        Succ = Write(MorePacketData, MorePacketDataLength, &BytesWritten);
        if ( (!Succ) || BytesWritten != MorePacketDataLength )
        {
            //
            // An error occured writing the secondary packet data,
            // so write it again
            //

            KdOut("WRITE: Message data error.\n");
            SUSPEND_ENGINE();
            return DBGKD_WRITE_RESEND;
        }
    }

    //
    // Output a packet trailing byte
    //

    do
    {
        Succ = Write(&s_PacketTrailingByte[0],
                   sizeof(s_PacketTrailingByte),
                   &BytesWritten);
    }
    while ((!Succ) || (BytesWritten != sizeof(s_PacketTrailingByte)));

    SUSPEND_ENGINE();

    if (!NoAck)
    {
        ULONG Received;

        //
        // Wait for ACK
        //

        Received = WaitForPacket(PACKET_TYPE_KD_ACKNOWLEDGE, NULL);
        if (Received != DBGKD_WAIT_ACK)
        {
            KdOut("WRITE: Wait for ACK failed. Resend Packet.\n");
            return DBGKD_WRITE_RESEND;
        }
    }

    return DBGKD_WRITE_PACKET;
}

ULONG
DbgKdComTransport::ReadPacketLeader(
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    )
{
    DWORD BytesRead;
    BOOL Succ;
    USHORT Index;
    UCHAR DataByte, PreviousDataByte;

    Index = 0;
    do
    {
        if (m_BreakIn)
        {
            if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64)
            {
                WriteBreakInPacket();
                return DBGKD_WAIT_RESYNC;
            }
        }

        if (m_Resync)
        {
            m_Resync = FALSE;

            KdOut(" Resync packet id ...");

            Synchronize();

            KdOut(" Done.\n");
            FlushCallbacks();

            return DBGKD_WAIT_RESYNC;
        }

        if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
        {
            KdOut("Packet read interrupted by exit request\n");
            return DBGKD_WAIT_INTERRUPTED;
        }

        FlushCallbacks();

        Succ = Read(&DataByte, 1, &BytesRead);
        if (Succ && BytesRead == 1 &&
            ( DataByte == PACKET_LEADER_BYTE ||
              DataByte == CONTROL_PACKET_LEADER_BYTE))
        {
            if ( Index == 0 )
            {
                PreviousDataByte = DataByte;
                Index++;
            }
            else if ( DataByte == PreviousDataByte )
            {
                Index++;
            }
            else
            {
                PreviousDataByte = DataByte;
                Index = 1;
            }
        }
        else
        {
            Index = 0;
            if (BytesRead == 0)
            {
                KdOut("READ: Timeout.\n");
                FlushCallbacks();

                if (m_AllowInitialBreak &&
                    (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK))
                {
                    KdOut("Attempting to get initial breakpoint.\n");
                    WriteBreakInPacket();
                }
                return DBGKD_WAIT_FAILED;
            }
        }
    } while ( Index < 2 );

    if ( DataByte != CONTROL_PACKET_LEADER_BYTE )
    {
        *PacketLeader = PACKET_LEADER;
    }
    else
    {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }
    return DBGKD_WAIT_PACKET;
}

void
DbgKdComTransport::CheckComStatus(void)
/*++

Routine Description:

    Called when the com port status trigger signals a change.
    This function handles the change in status.

    Note: status is only monitored when being used over the modem.

--*/
{
    DWORD   CommStat;
    BOOL    Succ;
    ULONG   BytesRead;
    CHAR    Buf[128];
    DWORD   CommErr;
    COMSTAT FullCommStat;
    ULONG   Len;

    if (!m_ComEvent || NET_COM_PORT(m_PortType))
    {
        //
        // Not triggered, just return
        //

        m_ComEvent = 0;
        return;
    }

    // This should succeed since we were just notified,
    // but check the return value to keep PREfix happy.
    if (!GetCommModemStatus(m_Handle, &CommStat))
    {
        // Leave m_ComEvent set for another try.
        return;
    }

    m_ComEvent = 0;

    if (!(CommStat & 0x80))
    {
        dprintf ("No carrier detect - in terminal mode\n");

        // This routine can be called during a wait when the
        // engine lock isn't held and can also be called when
        // the lock is held.  RESUME handles both of these
        // cases so that the lock is reacquired or reentered.
        RESUME_ENGINE();

        //
        // Loop and read any com input
        //

        while (!(CommStat & 0x80))
        {
            //
            // Get some input to send to the modem.
            //

            Len = GetInput("Term> ", Buf, DIMA(Buf), GETIN_DEFAULT);
            if (Len > 0)
            {
                Write(Buf, Len, &Len);
                Buf[0] = '\n';
                Buf[1] = '\r';
                Write(Buf, 2, &Len);
            }

            GetCommModemStatus(m_Handle, &CommStat);
            Succ = Read(Buf, sizeof(Buf), &BytesRead);
            if (Succ != TRUE || BytesRead == 0)
            {
                continue;
            }

            //
            // print the string.
            //

            dprintf("%s", Buf);
            FlushCallbacks();

            //
            // if logging is on, log the output
            //

            if (g_LogFile != -1)
            {
                _write(g_LogFile, Buf, BytesRead);
            }
        }

        dprintf ("Carrier detect - returning to debugger\n");
        FlushCallbacks();

        ClearCommError(m_Handle,
                       &CommErr,
                       &FullCommStat);

        SUSPEND_ENGINE();
    }
    else
    {
        CommErr = 0;
        ClearCommError(m_Handle,
                       &CommErr,
                       &FullCommStat);

        if (CommErr & CE_FRAME)
        {
            dprintf (" [FRAME ERR] ");
        }

        if (CommErr & CE_OVERRUN)
        {
            dprintf (" [OVERRUN ERR] ");
        }

        if (CommErr & CE_RXPARITY)
        {
            dprintf (" [PARITY ERR] ");
        }
    }

    //
    // Reset trigger
    //

    WaitCommEvent (m_Handle, &m_ComEvent, &m_EventOverlapped);
}

//----------------------------------------------------------------------------
//
// DbgKd1394Transport.
//
//----------------------------------------------------------------------------

#define PARAM_1394_SYMLINK "Symlink"
#define PARAM_1394_CHANNEL "Channel"

#define ENV_1394_SYMLINK "_NT_DEBUG_1394_SYMLINK"
#define ENV_1394_CHANNEL "_NT_DEBUG_1394_CHANNEL"

DbgKd1394Transport::DbgKd1394Transport(ConnLiveKernelTargetInfo* Target)
    : DbgKdTransport(Target)
{
    m_Index = DBGKD_TRANSPORT_1394;
    m_Name = g_DbgKdTransportNames[m_Index];
    m_InvPacketRetryLimit = 3;
    m_AckWrites = FALSE;
    m_Handle = NULL;
    m_Handle2 = NULL;
    ZeroMemory(&m_ReadOverlapped2, sizeof(m_ReadOverlapped2));
}

DbgKd1394Transport::~DbgKd1394Transport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
    }

    if (m_Handle2 != NULL)
    {
        CloseHandle(m_Handle2);
    }

    if (m_ReadOverlapped2.hEvent != NULL)
    {
        CloseHandle(m_ReadOverlapped2.hEvent);
    }
}

ULONG
DbgKd1394Transport::GetNumberParameters(void)
{
    return 2 + DbgKdTransport::GetNumberParameters();
}

void
DbgKd1394Transport::GetParameter(ULONG Index,
                                 PSTR Name, ULONG NameSize,
                                 PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_SymlinkSpecified)
        {
            CopyString(Name, PARAM_1394_SYMLINK, NameSize);
            CopyString(Value, m_Symlink, ValueSize);
        }
        break;
    case 1:
        CopyString(Name, PARAM_1394_CHANNEL, NameSize);
        PrintString(Value, ValueSize, "%d", m_Channel);
        break;
    default:
        DbgKdTransport::GetParameter(Index - 2,
                                     Name, NameSize, Value, ValueSize);
        break;
    }
}

void
DbgKd1394Transport::ResetParameters(void)
{
    PSTR Env;

    DbgKdTransport::ResetParameters();

    if ((Env = getenv(ENV_1394_SYMLINK)) == NULL)
    {
        m_SymlinkSpecified = FALSE;
        strcpy(m_Symlink, "Channel");
        strcpy(m_Symlink2, "Instance");
    }
    else
    {
        m_SymlinkSpecified = TRUE;
        CopyString(m_Symlink, Env, DIMA(m_Symlink));
    }

    if ((Env = getenv(ENV_1394_CHANNEL)) == NULL)
    {
        m_Channel = 0;
    }
    else
    {
        m_Channel = atol(Env);
    }
}

BOOL
DbgKd1394Transport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_strcmpi(Name, PARAM_1394_SYMLINK))
    {
        if (!Value)
        {
            ErrOut(PARAM_1394_SYMLINK " requires a value\n");
            return FALSE;
        }

        if (!CopyString(m_Symlink, Value, DIMA(m_Symlink)))
        {
            return FALSE;
        }
        m_SymlinkSpecified = TRUE;
    }
    else if (!_strcmpi(Name, PARAM_1394_CHANNEL))
    {
        if (!Value)
        {
            ErrOut(PARAM_1394_CHANNEL " requires a numeric value\n");
            return FALSE;
        }

        m_Channel = atol(Value);
    }
    else
    {
        return DbgKdTransport::SetParameter(Name, Value);
    }

    return TRUE;
}

HRESULT
DbgKd1394Transport::Initialize(void)
{
    CHAR InfFile[MAX_PATH];
    char Name[64];
    HRESULT Status;
    HANDLE InfHandle;

    dprintf("Using 1394 for debugging\n");

    if ((Status = DbgKdTransport::Initialize()) != S_OK)
    {
        return Status;
    }

    m_ReadOverlapped2.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_ReadOverlapped2.hEvent == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    //
    // Debugging over 1394 requires drivers to be installed.
    // The the drivers registered so installation can succeed.
    //

    // Get the directory the debugger executable is in.
    // Remove the executable name and add the inf name.
    if (GetEngineDirectory(InfFile, DIMA(InfFile)) &&
        CatString(InfFile, "\\1394\\1394dbg.inf", DIMA(InfFile)))
    {
        InfHandle = CreateFile(InfFile,
                               GENERIC_READ | GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (InfHandle != INVALID_HANDLE_VALUE)
        {
            CloseHandle(InfHandle);

            typedef HDESK (__stdcall *PFN_SETUPCOPYOEMINFPROC)(
                 PCSTR   SourceInfFileName,
                 PCSTR   OEMSourceMediaLocation,
                 DWORD   OEMSourceMediaType,
                 DWORD   CopyStyle,
                 PSTR    DestinationInfFileName,
                 DWORD   DestinationInfFileNameSize,
                 PDWORD  RequiredSize,
                 PSTR   *DestinationInfFileNameComponent);

            HINSTANCE hmod = LoadLibrary("setupapi.dll");

            PFN_SETUPCOPYOEMINFPROC pfnCopyOemInf = (PFN_SETUPCOPYOEMINFPROC)
                GetProcAddress(hmod, "SetupCopyOEMInfA");

            CHAR DestinationInfFile[MAX_PATH];
            ULONG RequiredSize;

            if (!pfnCopyOemInf)
            {
                dprintf("1394 debug drivers can not be installed on this platform\n");
                return E_FAIL;
            }

            if (!(*pfnCopyOemInf)(InfFile,
                                  NULL,
                                  SPOST_PATH,
                                  SP_COPY_DELETESOURCE,
                                  DestinationInfFile,
                                  sizeof(DestinationInfFile),
                                  &RequiredSize,
                                  NULL))
            {
                dprintf("Could not install 1394 device drivers - error %x\n",
                         GetLastError());
                return E_FAIL;
            }

            typedef BOOL (__stdcall *PFN_UPDATEDRIVER)(
                 HWND   HwndParent,
                 LPCSTR HardwareId,
                 LPCSTR FullInfPath,
                 DWORD  InstallFlags,
                 PBOOL  bRebootRequired);

            hmod = LoadLibrary("newdev.dll");

            PFN_UPDATEDRIVER pfnUpdateDriver = (PFN_UPDATEDRIVER)
                GetProcAddress(hmod, "UpdateDriverForPlugAndPlayDevicesA");

            if (pfnUpdateDriver)
            {
                if (!(*pfnUpdateDriver)(NULL,
                                        "V1394\\VIRTUAL_HOST_DEBUGGER",
                                        DestinationInfFile,
                                        INSTALLFLAG_FORCE,
                                        NULL) ||
                    !(*pfnUpdateDriver)(NULL,
                                        "V1394\\HOST_DEBUGGER",
                                        DestinationInfFile,
                                        INSTALLFLAG_FORCE,
                                        NULL))
                {
                    dprintf("Could not update 1394 device drivers - error %x\n",
                             GetLastError());
                }
            }
        }
    }

    m_DirectPhysicalMemory = TRUE;

    Status = Create1394Channel(m_Symlink, m_Channel,
                               Name, DIMA(Name), &m_Handle);
    if (!m_SymlinkSpecified)
    {
        // The user didn't specify a symlink so we'll open
        // both and see which one responds.

        HRESULT Status2;

        Status2 = Create1394Channel(m_Symlink2, m_Channel,
                                    Name, DIMA(Name), &m_Handle2);
        if (Status2 == S_OK)
        {
            Status = S_OK;
        }
    }
    if (Status != S_OK)
    {
        ErrOut("Failed to open 1394 channel %d\n", m_Channel);
        ErrOut("If this is the first time KD was run, this is"
               " why this failed.\nVirtual 1394 "
               "Debugger Driver Installation will now be attempted\n");
        return Status;
    }
    else
    {
        dprintf("Opened %s\n", Name);
    }

    //
    // put the virtual driver in the right operating mode..
    //

    if (!SwitchVirtualDebuggerDriverMode
        (V1394DBG_API_CONFIGURATION_MODE_DEBUG))
    {
        return E_FAIL;
    }

    return S_OK;
}

BOOL
DbgKd1394Transport::Read(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesRead
    )
{
    BOOL Status;
    HANDLE Handles[2];
    ULONG Count = 0;
    HANDLE FirstHandle = NULL;
    OVERLAPPED *FirstOverlapped = NULL;

    if (IS_DUMP_TARGET(m_Target))
    {
        ErrOut("Attempted to read KD transport while "
               "debugging a crash dump\n");
        DebugBreak();
    }

    if (!SwitchVirtualDebuggerDriverMode
        (V1394DBG_API_CONFIGURATION_MODE_DEBUG))
    {
        return FALSE;
    }

    //
    // We may have two handles open as we haven't decided
    // which symlink to use yet.  Read on both and
    // pick whichever one answers first.
    //

    Status = ReadFile(m_Handle,
                      Buffer,
                      SizeOfBuffer,
                      BytesRead,
                      &m_ReadOverlapped);
    if (Status)
    {
        // Success on m_Handle, close m_Handle2.
        CloseSecond(FALSE);
        goto Exit;
    }
    else if (GetLastError() == ERROR_IO_PENDING)
    {
        Handles[Count++] = m_ReadOverlapped.hEvent;
        FirstHandle = m_Handle;
        FirstOverlapped = &m_ReadOverlapped;
    }

    if (m_Handle2)
    {
        Status = ReadFile(m_Handle2,
                          Buffer,
                          SizeOfBuffer,
                          BytesRead,
                          &m_ReadOverlapped2);
        if (Status)
        {
            // Success on m_Handle2, close m_Handle.
            CloseSecond(TRUE);
            goto Exit;
        }
        else if (GetLastError() == ERROR_IO_PENDING)
        {
            if (!Count)
            {
                FirstHandle = m_Handle2;
                FirstOverlapped = &m_ReadOverlapped2;
            }
            Handles[Count++] = m_ReadOverlapped2.hEvent;
        }
    }

    //
    // If both requests failed, Prevent looping on read errors from
    // burning 100% of the CPU.

    if (!Count)
    {
        Sleep(50);
        goto Exit;
    }

    //
    // We now have one or two pending I/Os, so wait to see
    // what completes.
    //

    ULONG Wait;

    Wait = WaitForMultipleObjects(Count, Handles, FALSE, INFINITE);
    switch(Wait)
    {
    case WAIT_OBJECT_0:
        if (Count == 2)
        {
            CancelIo(m_Handle2);
        }

        Status = GetOverlappedResult(FirstHandle,
                                     FirstOverlapped,
                                     BytesRead,
                                     FALSE);

        // Close the handle we are not using
        CloseSecond(FirstHandle == m_Handle2);

        break;
    case WAIT_OBJECT_0 + 1:
        CancelIo(m_Handle);
        Status = GetOverlappedResult(m_Handle2,
                                     &m_ReadOverlapped2,
                                     BytesRead,
                                     FALSE);
        CloseSecond(TRUE);
        break;
    default:
        CancelIo(FirstHandle);
        if (Count == 2)
        {
            CancelIo(m_Handle2);
        }
        Status = FALSE;
        break;
    }

 Exit:
    if (Status)
    {
        if (m_OutputIo & DBGKD_OUTPUT_READS)
        {
            OutputIo("1394: Read %d bytes of %d\n",
                     Buffer, SizeOfBuffer, *BytesRead);
        }

        m_BytesRead += *BytesRead;
    }

    return Status;
}

BOOL
DbgKd1394Transport::Write(
    IN PVOID    Buffer,
    IN ULONG    SizeOfBuffer,
    IN PULONG   BytesWritten
    )
{
    BOOL Status;

    if (IS_DUMP_TARGET(m_Target))
    {
        ErrOut("Attempted to write KD transport "
               "while debugging a crash dump\n");
        DebugBreak();
    }

    if (!SwitchVirtualDebuggerDriverMode
        (V1394DBG_API_CONFIGURATION_MODE_DEBUG))
    {
        return FALSE;
    }

    //
    // We may have two handles open as we haven't decided
    // which symlink to use yet.  Write to both.
    //

    Status = WriteFile(m_Handle,
                       Buffer,
                       SizeOfBuffer,
                       BytesWritten,
                       &m_WriteOverlapped);
    if (!Status)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            Status = GetOverlappedResult(m_Handle,
                                         &m_WriteOverlapped,
                                         BytesWritten,
                                         TRUE);
            if (!Status)
            {
                return Status;
            }
        }
    }

    if (m_Handle2)
    {
        Status = WriteFile(m_Handle2,
                           Buffer,
                           SizeOfBuffer,
                           BytesWritten,
                           &m_WriteOverlapped);
        if (!Status)
        {
            if (GetLastError() == ERROR_IO_PENDING)
            {
                Status = GetOverlappedResult(m_Handle2,
                                             &m_WriteOverlapped,
                                             BytesWritten,
                                             TRUE);
                if (!Status)
                {
                    return Status;
                }
            }
        }
    }

    if (Status)
    {
        if (m_OutputIo & DBGKD_OUTPUT_WRITES)
        {
            OutputIo("1394: Wrote %d bytes of %d\n",
                     Buffer, SizeOfBuffer, *BytesWritten);
        }

        m_BytesWritten += *BytesWritten;
    }

    return Status;
}

HRESULT
DbgKd1394Transport::ReadTargetPhysicalMemory(
    IN ULONG64 MemoryOffset,
    IN PVOID Buffer,
    IN ULONG SizeofBuffer,
    IN PULONG BytesRead
    )
{
    DWORD dwRet, dwBytesRet;
    PV1394DBG_API_REQUEST pApiReq;

    if (IS_DUMP_TARGET(m_Target))
    {
        ErrOut("Attempted to access KD transport while "
               "debugging a crash dump\n");
        DebugBreak();
    }

    if (m_Handle2)
    {
        // We should know what kind of communication is
        // occurring by now.
        ErrOut("Symlink must be established\n");
        return E_UNEXPECTED;
    }

    //
    // first setup the read i/o parameters in the virtual driver
    //

    pApiReq = (PV1394DBG_API_REQUEST)
        LocalAlloc(LPTR, sizeof(V1394DBG_API_REQUEST));
    if (pApiReq == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // if the virtual driver is not set in raw access mode, we need to
    // tell it to change modes..
    //

    if (!SwitchVirtualDebuggerDriverMode
        (V1394DBG_API_CONFIGURATION_MODE_RAW_MEMORY_ACCESS))
    {
        LocalFree(pApiReq);
        return E_UNEXPECTED;
    }

    pApiReq->RequestNumber = V1394DBG_API_SET_IO_PARAMETERS;
    pApiReq->Flags = V1394DBG_API_FLAG_READ_IO;

    pApiReq->u.SetIoParameters.fulFlags = 0;
    pApiReq->u.SetIoParameters.StartingMemoryOffset.QuadPart = MemoryOffset;

    dwRet = DeviceIoControl( m_Handle,
                             IOCTL_V1394DBG_API_REQUEST,
                             pApiReq,
                             sizeof(V1394DBG_API_REQUEST),
                             NULL,
                             0,
                             &dwBytesRet,
                             NULL
                             );
    if (!dwRet)
    {
        dwRet = GetLastError();
        ErrOut("Failed to send SetIoParameters 1394 "
               "Virtual Driver Request, error %x\n",dwRet);

        LocalFree(pApiReq);
        return E_UNEXPECTED;
    }

    LocalFree(pApiReq);

    //
    // now do anormal read. The virtual driver will read SizeofBuffer bytes
    // starting at the remote PCs physical address we specified above
    //

    dwRet = ReadFile(
             m_Handle,
             Buffer,
             SizeofBuffer,
             BytesRead,
             &m_ReadOverlapped
             );
    if (!dwRet)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            dwRet = GetOverlappedResult(m_Handle,
                                        &m_ReadOverlapped,
                                        BytesRead,
                                        TRUE);
        }
    }

    return (dwRet != 0) ? S_OK : E_UNEXPECTED;
}

BOOL
DbgKd1394Transport::SwitchVirtualDebuggerDriverMode(
    IN ULONG    DesiredOperationMode
    )
{
    DWORD   dwRet, dwBytesRet;
    PV1394DBG_API_REQUEST pApiReq;

    //
    // If the virtual driver is not set in raw access mode, we need to
    // tell it to change modes..
    //
    // We may have two handles open as we haven't decided
    // which symlink to use yet.  Write to both.
    //

    if (m_OperationMode != DesiredOperationMode)
    {
        //
        // first setup the read i/o parameters in the virtual driver
        //

        pApiReq = (PV1394DBG_API_REQUEST)
            LocalAlloc(LPTR, sizeof(V1394DBG_API_REQUEST));
        if (pApiReq == NULL)
        {
            return FALSE;
        }

        pApiReq->RequestNumber = V1394DBG_API_SET_CONFIGURATION;
        pApiReq->Flags = 0;

        pApiReq->u.SetConfiguration.OperationMode = DesiredOperationMode;

        dwRet = DeviceIoControl(m_Handle,
                                IOCTL_V1394DBG_API_REQUEST,
                                pApiReq,
                                sizeof(V1394DBG_API_REQUEST),
                                NULL,
                                0,
                                &dwBytesRet,
                                NULL);
        if (!dwRet)
        {
            dwRet = GetLastError();
            ErrOut("Failed to send SetConfiguration 1394 "
                   "Virtual Driver Request, error %x\n", dwRet);
            LocalFree(pApiReq);
            return FALSE;
        }

        if (m_Handle2)
        {
            dwRet = DeviceIoControl(m_Handle2,
                                    IOCTL_V1394DBG_API_REQUEST,
                                    pApiReq,
                                    sizeof(V1394DBG_API_REQUEST),
                                    NULL,
                                    0,
                                    &dwBytesRet,
                                    NULL);
            if (!dwRet)
            {
                dwRet = GetLastError();
                ErrOut("Failed to send SetConfiguration 1394 "
                       "Virtual Driver Request, error %x\n", dwRet);
                LocalFree(pApiReq);
                return FALSE;
            }
        }

        m_OperationMode = DesiredOperationMode;

        LocalFree(pApiReq);
    }

    return TRUE;
}

VOID
DbgKd1394Transport::Synchronize(VOID)
{
    ULONG Index;
    ULONG BytesRead;
    BOOL Succ;

    // XXX drewb - Why is this code disabled?
    return;

    Index = 3;
    while (TRUE)
    {
        if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
        {
            KdOut("Synchronize interrupted by exit request\n");
            return;
        }

        WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

        FlushCallbacks();

        Succ = Read(s_Packet, sizeof(s_Packet), &BytesRead);

        CopyMemory(&s_PacketHeader, &s_Packet[0], sizeof(KD_PACKET));

        if (Succ && (BytesRead >= sizeof(s_PacketHeader)))
        {
            if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESET)
            {
                break;
            }
        }

        if (!Index--)
        {
            break;
        }
    }
}

ULONG
DbgKd1394Transport::ReadPacketContents(IN USHORT PacketType)
{
    DWORD BytesRead;
    BOOL Succ;
    ULONG Checksum;

WaitForPacket1394:

    if (m_AllowInitialBreak && (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK))
    {
        KdOut("Attempting to get initial breakpoint.\n");
        WriteBreakInPacket();
        m_AllowInitialBreak = FALSE;
    }

    if (m_Resync)
    {
        m_Resync = FALSE;

        KdOut(" Resync packet id ...");

        Synchronize();

        KdOut(" Done.\n");
        FlushCallbacks();

        return DBGKD_WAIT_RESYNC;
    }

    if (m_BreakIn)
    {
        WriteBreakInPacket();
        return DBGKD_WAIT_RESYNC;
    }

    if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
    {
        KdOut("Packet read interrupted by exit request\n");
        return DBGKD_WAIT_INTERRUPTED;
    }

    FlushCallbacks();

    //
    // read the whole packet at once.
    // we try to read MAX_PACKET worth of data and then check how much
    // we really read. Also since the packet header (KD_PACKET) is part of what
    // we read, we later have to move the data packet back sizeof(KD_PACKET)
    //

    Succ = Read(s_Packet, sizeof(s_Packet), &BytesRead);
    CopyMemory(&s_PacketHeader, &s_Packet[0], sizeof(KD_PACKET));

    if (!Succ || (BytesRead < sizeof(s_PacketHeader)))
    {
        if (!Succ)
        {
            KdOut("READ: Error %x.\n",GetLastError());
        }
        else
        {
            KdOut("READ: Data ByteCount error (short read) %x, %x.\n",
                  BytesRead, sizeof(s_PacketHeader));
        }

        if (Succ && (BytesRead >= sizeof(s_PacketHeader)) )
        {
            if (s_PacketHeader.PacketLeader == PACKET_LEADER)
            {
                WriteControlPacket(PACKET_TYPE_KD_RESEND, 0L);
                KdOut("READ: Data packet header "
                      "ByteCount error (short read).\n");
            }
        }

        goto WaitForPacket1394;
    }

    //
    // move data portion to start of packet.
    //

    MoveMemory(s_Packet, ((PUCHAR)s_Packet + sizeof(KD_PACKET)),
               BytesRead - sizeof(KD_PACKET));

    //
    // Check the Packet type.
    //

    if ((m_Target->m_KdMaxPacketType == 0 &&
         s_PacketHeader.PacketType >= PACKET_TYPE_MAX) ||
        (m_Target->m_KdMaxPacketType > 0 &&
         s_PacketHeader.PacketType >= m_Target->m_KdMaxPacketType))
    {
        KdOut("READ: Received INVALID packet type.\n");

        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            return DBGKD_WAIT_RESEND;
        }

        return DBGKD_WAIT_FAILED;
    }

    KdOut("      PacketType=%x, ", s_PacketHeader.PacketType);

    //
    // Check ByteCount
    //

    if (s_PacketHeader.ByteCount > PACKET_MAX_SIZE )
    {
        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            KdOut("READ: Data packet header ByteCount error (short read).\n");
            return DBGKD_WAIT_RESEND;
        }

        return DBGKD_WAIT_FAILED;
    }

    KdOut("ByteCount=%x, PacketId=%x,\n",
          s_PacketHeader.ByteCount,
          s_PacketHeader.PacketId);

    if (s_PacketHeader.ByteCount != (BytesRead - sizeof(s_PacketHeader)))
    {
        if (s_PacketHeader.PacketLeader == PACKET_LEADER)
        {
            KdOut("READ: Data packet header ByteCount error (short read).\n");
            return DBGKD_WAIT_RESEND;
        }

        return DBGKD_WAIT_FAILED;
    }

    //
    // Make sure the checksum is valid.
    //

    Checksum = ComputeChecksum(s_Packet, s_PacketHeader.ByteCount);
    if (Checksum != s_PacketHeader.Checksum)
    {
        KdOut("READ: Checksum error.\n");
        return DBGKD_WAIT_RESEND;
    }

    if (s_PacketHeader.PacketLeader == CONTROL_PACKET_LEADER)
    {
        if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESET)
        {
            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            m_NextPacketToSend = INITIAL_PACKET_ID;
            m_PacketExpected = INITIAL_PACKET_ID;
            WriteControlPacket(PACKET_TYPE_KD_RESET, 0L);

            KdOut("DbgKdpWaitForPacket(): "
                  "Recieved KD_RESET packet, send KD_RESET ACK packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else if (s_PacketHeader.PacketType == PACKET_TYPE_KD_RESEND)
        {
            KdOut("READ: Received RESEND packet\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
        else
        {
            //
            // Invalid packet header, ignore it.
            //

            KdOut("READ: Received Control packet with UNKNOWN type\n");
            FlushCallbacks();

            return DBGKD_WAIT_FAILED;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    KdOut("READ: Received Type %x data packet with id = %lx successfully.\n\n",
          s_PacketHeader.PacketType, s_PacketHeader.PacketId);

    return DBGKD_WAIT_PACKET;
}

ULONG
DbgKd1394Transport::WritePacketContents(IN KD_PACKET* Packet,
                                        IN PVOID PacketData,
                                        IN USHORT PacketDataLength,
                                        IN PVOID MorePacketData OPTIONAL,
                                        IN USHORT MorePacketDataLength OPTIONAL,
                                        IN BOOL NoAck)
{
    BOOL Succ;
    ULONG BytesWritten;
    PUCHAR Tx;

    // Lock to ensure only one thread is using
    // the transmit buffer.
    RESUME_ENGINE();

    //
    // On 1394 we double buffer all packet segments into one contigious
    // buffer and write it all at once
    //

    Tx = m_TxPacket;

    memcpy(Tx, Packet, sizeof(*Packet));
    Tx += sizeof(*Packet);

    memcpy(Tx, PacketData, PacketDataLength);
    Tx += PacketDataLength;

    if ( ARGUMENT_PRESENT(MorePacketData) )
    {
        memcpy(Tx, MorePacketData, MorePacketDataLength);
        Tx += MorePacketDataLength;
    }

    //
    // The 1394 Debug protocol does not use trailer bytes
    //

    //
    // Write the whole packet out to the bus
    //

    do
    {
        Succ = Write(&m_TxPacket[0], (ULONG)(Tx - m_TxPacket), &BytesWritten);
    }
    while ((!Succ) || (BytesWritten != (ULONG)(Tx - m_TxPacket)));

    SUSPEND_ENGINE();

    return DBGKD_WRITE_PACKET;
}

void
DbgKd1394Transport::CloseSecond(BOOL MakeFirst)
{
    if (!m_Handle2)
    {
        // No secondary open.
        return;
    }

    if (MakeFirst)
    {
        CloseHandle(m_Handle);
        m_Handle = m_Handle2;
        m_Handle2 = NULL;
        strcpy(m_Symlink, m_Symlink2);
    }
    else
    {
        CloseHandle(m_Handle2);
        m_Handle2 = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dump.hpp ===
//----------------------------------------------------------------------------
//
// Dump file support.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __DUMP_HPP__
#define __DUMP_HPP__

#define HR_DATA_CORRUPT HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT)

#define MI_UNLOADED_DRIVERS 50

#define IS_DUMP_TARGET(Target) \
    ((Target) && (Target)->m_Class != DEBUG_CLASS_UNINITIALIZED && \
     (Target)->m_ClassQualifier >= DEBUG_DUMP_SMALL && \
     (Target)->m_ClassQualifier <= DEBUG_DUMP_FULL)

#define IS_USER_DUMP(Target) \
    (IS_USER_TARGET(Target) && IS_DUMP_TARGET(Target))
#define IS_KERNEL_DUMP(Target) \
    (IS_KERNEL_TARGET(Target) && IS_DUMP_TARGET(Target))

#define IS_KERNEL_SUMMARY_DUMP(Target) \
    (IS_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_KERNEL_DUMP)
#define IS_KERNEL_TRIAGE_DUMP(Target) \
    (IS_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_KERNEL_SMALL_DUMP)
#define IS_KERNEL_FULL_DUMP(Target) \
    (IS_KERNEL_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_KERNEL_FULL_DUMP)
#define IS_USER_FULL_DUMP(Target) \
    (IS_USER_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_USER_WINDOWS_DUMP)
#define IS_USER_MINI_DUMP(Target) \
    (IS_USER_TARGET(Target) && \
     (Target)->m_ClassQualifier == DEBUG_USER_WINDOWS_SMALL_DUMP)

#define IS_DUMP_WITH_MAPPED_IMAGES(Target) \
    (IS_DUMP_TARGET(Target) && ((DumpTargetInfo*)(Target))->m_MappedImages)

enum DTYPE
{
    DTYPE_KERNEL_SUMMARY32,
    DTYPE_KERNEL_SUMMARY64,
    DTYPE_KERNEL_TRIAGE32,
    DTYPE_KERNEL_TRIAGE64,
    // Kernel full dumps must come after summary and triage
    // dumps so that the more specific dumps are identified first.
    DTYPE_KERNEL_FULL32,
    DTYPE_KERNEL_FULL64,
    DTYPE_USER_FULL32,
    DTYPE_USER_FULL64,
    DTYPE_USER_MINI_PARTIAL,
    DTYPE_USER_MINI_FULL,
    DTYPE_COUNT
};

enum
{
    // Actual dump file.
    DUMP_INFO_DUMP,
    // Paging file information.
    DUMP_INFO_PAGE_FILE,

    DUMP_INFO_COUNT
};

// Converts DUMP_INFO value to DEBUG_DUMP_FILE value.
extern ULONG g_DumpApiTypes[];

HRESULT AddDumpInfoFile(PCWSTR FileName, ULONG64 FileHandle,
                        ULONG Index, ULONG InitialView);

class DumpTargetInfo* NewDumpTargetInfo(ULONG DumpType);

HRESULT IdentifyDump(PCWSTR FileName, ULONG64 FileHandle,
                     DumpTargetInfo** TargetRet);

void DotDump(PDOT_COMMAND Cmd, DebugClient* Client);

HRESULT WriteDumpFile(PCWSTR FileName, ULONG64 FileHandle,
                      ULONG Qualifier, ULONG FormatFlags,
                      PCSTR CommentA, PCWSTR CommentW);

HRESULT CreateCabFromDump(PCSTR DumpFile, PCSTR CabFile, ULONG Flags);

//----------------------------------------------------------------------------
//
// ViewMappedFile.
//
// ViewMappedFile layers on top of Win32 file mappings to provide
// the illusion that the entire file is mapped into memory.
// Internally ViewMappedFile caches and shifts Win32 views to
// access the actual data.
//
//----------------------------------------------------------------------------

class ViewMappedFile
{
public:
    ViewMappedFile(void);
    ~ViewMappedFile(void);

    void ResetCache(void);
    void ResetFile(void);
    void EmptyCache(void);
    
    ULONG ReadFileOffset(ULONG64 Offset, PVOID Buffer, ULONG BufferSize);
    ULONG WriteFileOffset(ULONG64 Offset, PVOID Buffer, ULONG BufferSize);
    
    HRESULT Open(PCWSTR FileName, ULONG64 FileHandle, ULONG InitialView);
    void Close(void);
    
    HRESULT RemapInitial(ULONG MapSize);

    void Transfer(ViewMappedFile* To);

    PWSTR   m_FileNameW;
    PSTR    m_FileNameA;
    HANDLE  m_File;
    ULONG64 m_FileSize;
    HANDLE  m_Map;
    PVOID   m_MapBase;
    ULONG   m_MapSize;
    
private:
    struct CacheRecord
    {
        LIST_ENTRY InFileOrderList;
        LIST_ENTRY InLRUOrderList;

        //
        // Base address of mapped region.
        //
        PVOID MappedAddress;

        //
        // File page number of mapped region.  pages are of
        // size == FileCacheData.Granularity.
        //
        // The virtual address of a page is not stored; it is
        // translated into a page number by the read routines
        // and all access is by page number.
        //
        ULONG64 PageNumber;

        //
        // A page may be locked into the cache, either because it is used
        // frequently or because it has been modified.
        //
        BOOL Locked;
    };

    CacheRecord* ReuseOldestCacheRecord(ULONG64 FileByteOffset);
    CacheRecord* FindCacheRecordForFileByteOffset
        (ULONG64 FileByteOffset);
    CacheRecord* CreateNewFileCacheRecord(ULONG64 FileByteOffset);
    PUCHAR FileOffsetToMappedAddress(ULONG64 FileOffset,
                                     BOOL LockCacheRecord,
                                     PULONG Avail);
    
    //
    // If a page is dirty, it will stay in the cache indefinitely.
    // A maximum of MAX_CLEAN_PAGE_RECORD clean pages are kept in
    // the LRU list.
    //
    ULONG m_ActiveCleanPages;

    //
    // This is a list of all mapped pages, dirty and clean.
    // This list is not intended to get very big:  the page finder
    // searches it, so it is not a good data structure for a large
    // list.  It is expected that MAX_CLEAN_PAGE_RECORD will be a
    // small number, and that there aren't going to be very many
    // pages dirtied in a typical debugging session, so this will
    // work well.
    //

    LIST_ENTRY m_InFileOrderList;

    //
    // This is a list of all clean pages.  When the list is full
    // and a new page is mapped, the oldest page will be discarded.
    //

    LIST_ENTRY m_InLRUOrderList;

    // Granularity of cache view sizes.
    ULONG m_CacheGranularity;
};

//----------------------------------------------------------------------------
//
// DumpTargetInfo hierarchy.
//
// Each kind of dump has its own target for methods that are
// specific to the kind of dump.
//
//----------------------------------------------------------------------------

class DumpTargetInfo : public TargetInfo
{
public:
    DumpTargetInfo(ULONG Class, ULONG Qual, BOOL MappedImages);
    virtual ~DumpTargetInfo(void);

    // TargetInfo.
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WriteVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    
    virtual HRESULT SwitchProcessors(ULONG Processor);

    virtual HRESULT WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE First,
                                   PULONG DesiredTimeout);
    virtual HRESULT WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus);

    //
    // DumpTargetInfo.
    //

    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize) = 0;

    virtual void DumpDebug(void) = 0;

    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail) = 0;

    // Base implementation returns E_NOTIMPL.
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);

    virtual HRESULT FirstEvent(void) = 0;

    PVOID IndexByByte(PVOID Pointer, ULONG64 Index)
    {
        return (PVOID)((PUCHAR)Pointer + Index);
    }

    // Validates that the RVA and size fall within the current
    // mapped size.  Primarily useful for minidumps.
    PVOID IndexRva(PVOID Base, RVA Rva, ULONG Size, PCSTR Title);
    
    HRESULT InitSystemInfo(ULONG BuildNumber, ULONG CheckedBuild,
                           ULONG MachineType, ULONG PlatformId,
                           ULONG MajorVersion, ULONG MinorVersion);
    
    HRESULT MapReadVirtual(ProcessInfo* Process,
                           ULONG64 Offset,
                           PVOID Buffer,
                           ULONG BufferSize,
                           PULONG BytesRead);
    void MapNearestDifferentlyValidOffsets(ULONG64 Offset,
                                           PULONG64 NextOffset,
                                           PULONG64 NextPage);

    ViewMappedFile m_InfoFiles[DUMP_INFO_COUNT];
    PVOID m_DumpBase;
    ULONG m_FormatFlags;
    BOOL m_MappedImages;
    // Image memory map can only be used if m_MappedImages is TRUE.
    MappedMemoryMap m_ImageMemMap;
    MappedMemoryMap m_DataMemMap;
    EXCEPTION_RECORD64 m_ExceptionRecord;
    ULONG m_ExceptionFirstChance;
    ULONG m_WriterStatus;
};

class KernelDumpTargetInfo : public DumpTargetInfo
{
public:
    KernelDumpTargetInfo(ULONG Qual, BOOL MappedImages)
        : DumpTargetInfo(DEBUG_CLASS_KERNEL, Qual, MappedImages)
    {
        m_HeaderContext = NULL;
        ZeroMemory(m_KiProcessors, sizeof(m_KiProcessors));
        m_TaggedOffset = 0;
    }

    // TargetInfo.
    
    virtual HRESULT ReadControl(
        IN ULONG Processor,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT GetProcessorId(
        ULONG Processor,
        PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id
        );
    virtual HRESULT GetProcessorSpeed(
        ULONG Processor,
        PULONG Speed
        );
    virtual HRESULT GetTaggedBaseOffset(PULONG64 Offset);
    virtual HRESULT ReadTagged(ULONG64 Offset, PVOID Buffer, ULONG BufferSize);

    virtual HRESULT GetThreadIdByProcessor(
        IN ULONG Processor,
        OUT PULONG Id
        );
    
    virtual HRESULT GetThreadInfoDataOffset(ThreadInfo* Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(ThreadInfo* Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(ThreadInfo* Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(ThreadInfo* Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetCurrentSystemUpTimeN(void);
    virtual HRESULT GetProductInfo(PULONG ProductType, PULONG SuiteMask);

    // DumpTargetInfo.

    virtual HRESULT FirstEvent(void);

    // KernelDumpTargetInfo.

    virtual ULONG GetCurrentProcessor(void) = 0;

    HRESULT InitGlobals32(PMEMORY_DUMP32 Dump);
    HRESULT InitGlobals64(PMEMORY_DUMP64 Dump);
    
    void DumpHeader32(PDUMP_HEADER32 Header);
    void DumpHeader64(PDUMP_HEADER64 Header);

    void InitDumpHeader32(PDUMP_HEADER32 Header,
                          PCSTR CommentA, PCWSTR CommentW,
                          ULONG BugCheckCodeModifier);
    void InitDumpHeader64(PDUMP_HEADER64 Header,
                          PCSTR CommentA, PCWSTR CommentW,
                          ULONG BugCheckCodeModifier);

    HRESULT ReadControlSpaceIa64(ULONG   Processor,
                                 ULONG64 Offset,
                                 PVOID   Buffer,
                                 ULONG   BufferSize,
                                 PULONG  BytesRead);
    HRESULT ReadControlSpaceAmd64(ULONG   Processor,
                                  ULONG64 Offset,
                                  PVOID   Buffer,
                                  ULONG   BufferSize,
                                  PULONG  BytesRead);
    
    PUCHAR m_HeaderContext;

    ULONG64 m_KiProcessors[MAXIMUM_PROCS];

    ULONG64 m_TaggedOffset;
};

class KernelFullSumDumpTargetInfo : public KernelDumpTargetInfo
{
public:
    KernelFullSumDumpTargetInfo(ULONG Qual)
        : KernelDumpTargetInfo(Qual, FALSE)
    {
    }

    // TargetInfo.

    virtual HRESULT ReadPhysical(
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT WritePhysical(
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        IN ULONG Flags,
        OUT OPTIONAL PULONG BytesWritten
        );

    virtual HRESULT ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                                 PVOID Buffer, ULONG Size);
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    // DumpTargetInfo.
    virtual void DumpDebug(void);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
    
    // KernelDumpTargetInfo.
    virtual ULONG GetCurrentProcessor(void);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                     PULONG Avail) = 0;

    HRESULT PageFileOffset(ULONG PfIndex, ULONG64 PfOffset,
                           PULONG64 FileOffset);
};

class KernelSummaryDumpTargetInfo : public KernelFullSumDumpTargetInfo
{
public:
    KernelSummaryDumpTargetInfo(void)
        : KernelFullSumDumpTargetInfo(DEBUG_KERNEL_DUMP)
    {
        m_LocationCache = NULL;
        m_PageBitmapSize = 0;
    }
    
    // KernelSummaryDumpTargetInfo.
    PULONG m_LocationCache;
    ULONG m_PageBitmapSize;
    RTL_BITMAP m_PageBitmap;
    
    void ConstructLocationCache(ULONG BitmapSize,
                                ULONG SizeOfBitMap,
                                IN PULONG Buffer);
    ULONG64 SumPhysicalToOffset(ULONG HeaderSize, ULONG64 Phys,
                                BOOL Verbose, PULONG Avail);
};

class KernelSummary32DumpTargetInfo : public KernelSummaryDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                     PULONG Avail);

    // KernelSummary32DumpTargetInfo.
    PMEMORY_DUMP32 m_Dump;
};

class KernelSummary64DumpTargetInfo : public KernelSummaryDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                     PULONG Avail);

    // KernelSummary64DumpTargetInfo.
    PMEMORY_DUMP64 m_Dump;
};

class KernelTriageDumpTargetInfo : public KernelDumpTargetInfo
{
public:
    KernelTriageDumpTargetInfo(void)
        : KernelDumpTargetInfo(DEBUG_KERNEL_SMALL_DUMP, TRUE)
    {
        m_PrcbOffset = 0;
        m_HasDebuggerData = FALSE;
    }
    
    // TargetInfo.

    virtual void NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                PULONG64 NextOffset,
                                                PULONG64 NextPage);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    virtual HRESULT GetProcessorSystemDataOffset(
        IN ULONG Processor,
        IN ULONG Index,
        OUT PULONG64 Offset
        );
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual HRESULT GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    virtual HRESULT SwitchProcessors(ULONG Processor);
    
    // DumpTargetInfo.
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
    
    // KernelDumpTargetInfo.
    virtual ULONG GetCurrentProcessor(void);
    
    // KernelTriageDumpTargetInfo.
    
    HRESULT MapMemoryRegions(ULONG PrcbOffset,
                             ULONG ThreadOffset,
                             ULONG ProcessOffset,
                             ULONG64 TopOfStack,
                             ULONG SizeOfCallStack,
                             ULONG CallStackOffset,
                             ULONG64 BStoreLimit,
                             ULONG SizeOfBStore,
                             ULONG BStoreOffset,
                             ULONG64 DataPageAddress,
                             ULONG DataPageOffset,
                             ULONG DataPageSize,
                             ULONG64 DebuggerDataAddress,
                             ULONG DebuggerDataOffset,
                             ULONG DebuggerDataSize,
                             ULONG MmDataOffset,
                             ULONG DataBlocksOffset,
                             ULONG DataBlocksCount);

    void DumpDataBlocks(ULONG Offset, ULONG Count);
    
    ULONG m_PrcbOffset;
    BOOL m_HasDebuggerData;
};

class KernelTriage32DumpTargetInfo : public KernelTriageDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);

    // KernelTriage32DumpTargetInfo.
    PMEMORY_DUMP32 m_Dump;
};

class KernelTriage64DumpTargetInfo : public KernelTriageDumpTargetInfo
{
public:
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);

    // KernelTriage64DumpTargetInfo.
    PMEMORY_DUMP64 m_Dump;
};

class KernelFull32DumpTargetInfo : public KernelFullSumDumpTargetInfo
{
public:
    KernelFull32DumpTargetInfo(void)
        : KernelFullSumDumpTargetInfo(DEBUG_KERNEL_FULL_DUMP) {}
    
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                     PULONG Avail);

    // KernelFull32DumpTargetInfo.
    PMEMORY_DUMP32 m_Dump;
};

class KernelFull64DumpTargetInfo : public KernelFullSumDumpTargetInfo
{
public:
    KernelFull64DumpTargetInfo(void)
        : KernelFullSumDumpTargetInfo(DEBUG_KERNEL_FULL_DUMP) {}
    
    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadBugCheckData(PULONG Code, ULONG64 Args[4]);
    
    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);

    // KernelFullSumDumpTargetInfo.
    virtual ULONG64 PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                     PULONG Avail);

    // KernelFull64DumpTargetInfo.
    PMEMORY_DUMP64 m_Dump;
};

class UserDumpTargetInfo : public DumpTargetInfo
{
public:
    UserDumpTargetInfo(ULONG Qual, BOOL MappedImages)
        : DumpTargetInfo(DEBUG_CLASS_USER_WINDOWS, Qual, MappedImages)
    {
        m_HighestMemoryRegion32 = 0;
        m_EventProcessId = 0;
        m_EventProcessSymHandle = NULL;
        m_EventThreadId = 0;
        m_ThreadCount = 0;
    }

    // TargetInfo.

    virtual HRESULT GetThreadInfoDataOffset(ThreadInfo* Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset);
    virtual HRESULT GetProcessInfoDataOffset(ThreadInfo* Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset);
    virtual HRESULT GetThreadInfoTeb(ThreadInfo* Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset);
    virtual HRESULT GetProcessInfoPeb(ThreadInfo* Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset);

    virtual HRESULT GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc);
    
    // DumpTargetInfo.

    virtual HRESULT FirstEvent(void);

    // UserDumpTargetInfo.
    
    ULONG m_HighestMemoryRegion32;
    ULONG m_EventProcessId;
    HANDLE m_EventProcessSymHandle;
    ULONG m_EventThreadId;
    ULONG m_ThreadCount;
    
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb) = 0;
};

class UserFullDumpTargetInfo : public UserDumpTargetInfo
{
public:
    UserFullDumpTargetInfo(void)
        : UserDumpTargetInfo(DEBUG_USER_WINDOWS_DUMP, FALSE) {}

    // DumpTargetInfo.
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);
    
    // UserFullDumpTargetInfo.
    HRESULT GetBuildAndPlatform(ULONG MachineType,
                                PULONG MajorVersion, PULONG MinorVersion,
                                PULONG BuildNumber, PULONG PlatformId);
};

class UserFull32DumpTargetInfo : public UserFullDumpTargetInfo
{
public:
    UserFull32DumpTargetInfo(void)
        : UserFullDumpTargetInfo()
    {
        m_Header = NULL;
        m_Memory = NULL;
        m_IgnoreGuardPages = FALSE;
    }

    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);

    virtual HRESULT QueryMemoryRegion(ProcessInfo* Process,
                                      PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
    
    // UserDumpTargetInfo.
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb);
    
    // UserFull32DumpTargetInfo.
    PUSERMODE_CRASHDUMP_HEADER32 m_Header;
    PMEMORY_BASIC_INFORMATION32 m_Memory;
    BOOL m_IgnoreGuardPages;

    BOOL VerifyModules(void);
};

class UserFull64DumpTargetInfo : public UserFullDumpTargetInfo
{
public:
    UserFull64DumpTargetInfo(void)
        : UserFullDumpTargetInfo()
    {
        m_Header = NULL;
        m_Memory = NULL;
    }

    // TargetInfo.
    virtual HRESULT Initialize(void);
    
    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );
    
    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);

    virtual HRESULT QueryMemoryRegion(ProcessInfo* Process,
                                      PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);

    // UserDumpTargetInfo.
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb);
    
    // UserFull64DumpTargetInfo.
    PUSERMODE_CRASHDUMP_HEADER64 m_Header;
    PMEMORY_BASIC_INFORMATION64 m_Memory;
};

class UserMiniDumpTargetInfo : public UserDumpTargetInfo
{
public:
    UserMiniDumpTargetInfo(BOOL MappedImages)
        : UserDumpTargetInfo(DEBUG_USER_WINDOWS_SMALL_DUMP, MappedImages)
    {
        m_Header = NULL;
        m_SysInfo = NULL;
        ZeroMemory(&m_MiscInfo, sizeof(m_MiscInfo));
        m_ActualThreadCount = 0;
        m_ThreadStructSize = 0;
        m_Threads = NULL;
        m_Memory = NULL;
        m_Memory64 = NULL;
        m_Memory64DataBase = 0;
        m_Modules = NULL;
        m_UnlModules = NULL;
        m_Exception = NULL;
        m_Handles = NULL;
        m_FunctionTables = NULL;
        m_ImageType = 0;
    }

    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual void NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                PULONG64 NextOffset,
                                                PULONG64 NextPage);
    
    virtual HRESULT ReadHandleData(
        IN ProcessInfo* Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    virtual HRESULT GetProcessorId(
        ULONG Processor,
        PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id
        );
    virtual HRESULT GetProcessorSpeed(
        ULONG Processor,
        PULONG Speed
        );
    virtual HRESULT GetGenericProcessorFeatures(
        ULONG Processor,
        PULONG64 Features,
        ULONG FeaturesSize,
        PULONG Used
        );
    virtual HRESULT GetSpecificProcessorFeatures(
        ULONG Processor,
        PULONG64 Features,
        ULONG FeaturesSize,
        PULONG Used
        );

    virtual PVOID FindDynamicFunctionEntry(ProcessInfo* Process,
                                           ULONG64 Address);
    virtual ULONG64 GetDynamicFunctionTableBase(ProcessInfo* Process,
                                                ULONG64 Address);
    virtual HRESULT EnumFunctionTables(IN ProcessInfo* Process,
                                       IN OUT PULONG64 Start,
                                       IN OUT PULONG64 Handle,
                                       OUT PULONG64 MinAddress,
                                       OUT PULONG64 MaxAddress,
                                       OUT PULONG64 BaseAddress,
                                       OUT PULONG EntryCount,
                                       OUT PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable,
                                       OUT PVOID* RawEntries);

    virtual HRESULT GetTargetContext(
        ULONG64 Thread,
        PVOID Context
        );

    virtual ModuleInfo* GetModuleInfo(BOOL UserMode);
    virtual HRESULT GetImageVersionInformation(ProcessInfo* Process,
                                               PCSTR ImagePath,
                                               ULONG64 ImageBase,
                                               PCSTR Item,
                                               PVOID Buffer,
                                               ULONG BufferSize,
                                               PULONG VerInfoSize);
    
    virtual HRESULT GetExceptionContext(PCROSS_PLATFORM_CONTEXT Context);
    virtual ULONG64 GetCurrentTimeDateN(void);
    virtual ULONG64 GetProcessUpTimeN(ProcessInfo* Process);
    virtual HRESULT GetProcessTimes(ProcessInfo* Process,
                                    PULONG64 Create,
                                    PULONG64 Exit,
                                    PULONG64 Kernel,
                                    PULONG64 User);
    virtual HRESULT GetProductInfo(PULONG ProductType, PULONG SuiteMask);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual void DumpDebug(void);
    virtual HRESULT Write(HANDLE hFile, ULONG FormatFlags,
                          PCSTR CommentA, PCWSTR CommentW);

    // UserDumpTargetInfo.
    virtual HRESULT GetThreadInfo(ULONG Index,
                                  PULONG Id, PULONG Suspend, PULONG64 Teb);
    
    // UserMiniDumpTargetInfo.
    PVOID IndexDirectory(ULONG Index, MINIDUMP_DIRECTORY UNALIGNED *Dir,
                         PVOID* Store);
    
    MINIDUMP_THREAD_EX UNALIGNED *IndexThreads(ULONG Index)
    {
        // Only a MINIDUMP_THREAD's worth of data may be valid
        // here if the dump only contains MINIDUMP_THREADs.
        // Check m_ThreadStructSize in any place that it matters.
        return (MINIDUMP_THREAD_EX UNALIGNED *)
            (m_Threads + Index * m_ThreadStructSize);
    }
    
    PMINIDUMP_HEADER                       m_Header;
    MINIDUMP_SYSTEM_INFO UNALIGNED *       m_SysInfo;
    MINIDUMP_MISC_INFO                     m_MiscInfo;
    ULONG                                  m_ActualThreadCount;
    ULONG                                  m_ThreadStructSize;
    PUCHAR                                 m_Threads;
    MINIDUMP_MEMORY_LIST UNALIGNED *       m_Memory;
    MINIDUMP_MEMORY64_LIST UNALIGNED *     m_Memory64;
    RVA64                                  m_Memory64DataBase;
    MINIDUMP_MODULE_LIST UNALIGNED *       m_Modules;
    MINIDUMP_UNLOADED_MODULE_LIST UNALIGNED * m_UnlModules;
    MINIDUMP_EXCEPTION_STREAM UNALIGNED *  m_Exception;
    MINIDUMP_HANDLE_DATA_STREAM UNALIGNED *m_Handles;
    MINIDUMP_FUNCTION_TABLE_STREAM UNALIGNED* m_FunctionTables;
    ULONG                                  m_ImageType;
};

class UserMiniPartialDumpTargetInfo : public UserMiniDumpTargetInfo
{
public:
    UserMiniPartialDumpTargetInfo(void)
        : UserMiniDumpTargetInfo(TRUE) {}

    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT ReadVirtual(
        IN ProcessInfo* Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    
    virtual HRESULT QueryMemoryRegion(ProcessInfo* Process,
                                      PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
};

class UserMiniFullDumpTargetInfo : public UserMiniDumpTargetInfo
{
public:
    UserMiniFullDumpTargetInfo(void)
        : UserMiniDumpTargetInfo(FALSE) {}

    // TargetInfo.
    virtual HRESULT Initialize(void);

    virtual HRESULT GetDescription(PSTR Buffer, ULONG BufferLen,
                                   PULONG DescLen);
    
    virtual HRESULT QueryMemoryRegion(ProcessInfo* Process,
                                      PULONG64 Handle,
                                      BOOL HandleIsOffset,
                                      PMEMORY_BASIC_INFORMATION64 Info);

    virtual UnloadedModuleInfo* GetUnloadedModuleInfo(void);

    // DumpTargetInfo.
    virtual HRESULT IdentifyDump(PULONG64 BaseMapSize);
    virtual ULONG64 VirtualToOffset(ULONG64 Virt,
                                    PULONG File, PULONG Avail);
};

//----------------------------------------------------------------------------
//
// ModuleInfo implementations.
//
//----------------------------------------------------------------------------

class KernelTriage32ModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    KernelTriage32DumpTargetInfo* m_DumpTarget;
    ULONG m_Count;
    ULONG m_Cur;
};

extern KernelTriage32ModuleInfo g_KernelTriage32ModuleIterator;

class KernelTriage64ModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    KernelTriage64DumpTargetInfo* m_DumpTarget;
    ULONG m_Count;
    ULONG m_Cur;
};

extern KernelTriage64ModuleInfo g_KernelTriage64ModuleIterator;

class UserFull32ModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    UserFull32DumpTargetInfo* m_DumpTarget;
    ULONG64 m_Offset;
    ULONG m_Count;
    ULONG m_Cur;
};

extern UserFull32ModuleInfo g_UserFull32ModuleIterator;

class UserFull64ModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    UserFull64DumpTargetInfo* m_DumpTarget;
    ULONG64 m_Offset;
    ULONG m_Count;
    ULONG m_Cur;
};

extern UserFull64ModuleInfo g_UserFull64ModuleIterator;

class UserMiniModuleInfo : public ModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PMODULE_INFO_ENTRY Entry);

private:
    UserMiniDumpTargetInfo* m_DumpTarget;
    ULONG m_Count;
    ULONG m_Cur;
};

extern UserMiniModuleInfo g_UserMiniModuleIterator;

class UserMiniUnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

private:
    UserMiniDumpTargetInfo* m_DumpTarget;
    ULONG m_Index;
};

extern UserMiniUnloadedModuleInfo g_UserMiniUnloadedModuleIterator;

class KernelTriage32UnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

private:
    KernelTriage32DumpTargetInfo* m_DumpTarget;
    PDUMP_UNLOADED_DRIVERS32 m_Cur, m_End;
};

extern KernelTriage32UnloadedModuleInfo g_KernelTriage32UnloadedModuleIterator;

class KernelTriage64UnloadedModuleInfo : public UnloadedModuleInfo
{
public:
    virtual HRESULT Initialize(ThreadInfo* Thread);
    virtual HRESULT GetEntry(PSTR Name, PDEBUG_MODULE_PARAMETERS Params);

private:
    KernelTriage64DumpTargetInfo* m_DumpTarget;
    PDUMP_UNLOADED_DRIVERS64 m_Cur, m_End;
};

extern KernelTriage64UnloadedModuleInfo g_KernelTriage64UnloadedModuleIterator;

//----------------------------------------------------------------------------
//
// Temporary class to generate kernel minidump class
//
//----------------------------------------------------------------------------


class CCrashDumpWrapper32
{
public:
    void WriteDriverList(BYTE *pb, TRIAGE_DUMP32 *ptdh);
    void WriteUnloadedDrivers(BYTE *pb);
    void WriteMmTriageInformation(BYTE *pb);
};

class CCrashDumpWrapper64
{
public:
    void WriteDriverList(BYTE *pb, TRIAGE_DUMP64 *ptdh);
    void WriteUnloadedDrivers(BYTE *pb);
    void WriteMmTriageInformation(BYTE *pb);
};

#endif // #ifndef __DUMP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dump.cpp ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    dump.cpp

Abstract:

    This module implements crashdump loading and analysis code

Comments:

    There are five basic types of dumps:

        User-mode dumps - contains the context and address of the user-mode
            program plus all process memory.

        User-mode minidumps - contains just thread stacks for
            register and stack traces.

        Kernel-mode normal dump - contains the context and address space of
            the entire kernel at the time of crash.

        Kernel-mode summary dump - contains a subset of the kernel-mode
            memory plus optionally the user-mode address space.

        Kernel-mode triage dump - contains a very small dump with registers,
            current process kernel-mode context, current thread kernel-mode
            context and some processor information. This dump is very small
            (typically 64K) but is designed to contain enough information
            to be able to figure out what went wrong when the machine
            crashed.

    This module also implements the following functions:

        Retrieving a normal Kernel-Mode dump from a target machine using 1394
            and storing it locally in a crashdump file format

--*/

#include "ntsdp.hpp"

#define DUMP_INITIAL_VIEW_SIZE (1024 * 1024)
#define DUMP_MAXIMUM_VIEW_SIZE (256 * 1024 * 1024)

typedef ULONG PFN_NUMBER32;

ULONG g_DumpApiTypes[] =
{
    DEBUG_DUMP_FILE_BASE,
    DEBUG_DUMP_FILE_PAGE_FILE_DUMP,
};

//
// Page file dump file information.
//

#define DMPPF_IDENTIFIER "PAGE.DMP"

#define DMPPF_PAGE_NOT_PRESENT 0xffffffff

struct DMPPF_PAGE_FILE_INFO
{
    ULONG Size;
    ULONG MaximumSize;
};

// Left to its own devices the compiler will add a
// ULONG of padding at the end of this structure to
// keep it an even ULONG64 multiple in size.  Force
// it to consider only the declared items.
#pragma pack(4)

struct DMPPF_FILE_HEADER
{
    char Id[8];
    LARGE_INTEGER BootTime;
    ULONG PageData;
    DMPPF_PAGE_FILE_INFO PageFiles[16];
};

#pragma pack()

// Set this value to track down page numbers and contents of a virtual address
// in a dump file.
// Initialized to an address no one will look for.
ULONG64 g_DebugDump_VirtualAddress = 12344321;


#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)


//
// MM Triage information.
//

struct MM_TRIAGE_TRANSLATION
{
    ULONG DebuggerDataOffset;
    ULONG Triage32Offset;
    ULONG Triage64Offset;
    ULONG PtrSize:1;
};

MM_TRIAGE_TRANSLATION g_MmTriageTranslations[] =
{
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmSpecialPoolTag),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MmSpecialPoolTag),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MmSpecialPoolTag),
    FALSE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, MmTriageActionTaken),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MiTriageActionTaken),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MiTriageActionTaken),
    FALSE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, KernelVerifier),
    FIELD_OFFSET(DUMP_MM_STORAGE32, KernelVerifier),
    FIELD_OFFSET(DUMP_MM_STORAGE64, KernelVerifier),
    FALSE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, MmAllocatedNonPagedPool),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MmAllocatedNonPagedPool),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MmAllocatedNonPagedPool),
    TRUE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, MmTotalCommittedPages),
    FIELD_OFFSET(DUMP_MM_STORAGE32, CommittedPages),
    FIELD_OFFSET(DUMP_MM_STORAGE64, CommittedPages),
    TRUE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, MmPeakCommitment),
    FIELD_OFFSET(DUMP_MM_STORAGE32, CommittedPagesPeak),
    FIELD_OFFSET(DUMP_MM_STORAGE64, CommittedPagesPeak),
    TRUE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, MmTotalCommitLimitMaximum),
    FIELD_OFFSET(DUMP_MM_STORAGE32, CommitLimitMaximum),
    FIELD_OFFSET(DUMP_MM_STORAGE64, CommitLimitMaximum),
    TRUE,

#if 0
    // These MM triage fields are in pages while the corresponding
    // debugger data fields are in bytes.  There's no way to
    // directly map one to the other.
    FIELD_OFFSET(KDDEBUGGER_DATA64, MmMaximumNonPagedPoolInBytes),
    FIELD_OFFSET(DUMP_MM_STORAGE32, MmMaximumNonPagedPool),
    FIELD_OFFSET(DUMP_MM_STORAGE64, MmMaximumNonPagedPool),
    TRUE,

    FIELD_OFFSET(KDDEBUGGER_DATA64, MmSizeOfPagedPoolInBytes),
    FIELD_OFFSET(DUMP_MM_STORAGE32, PagedPoolMaximum),
    FIELD_OFFSET(DUMP_MM_STORAGE64, PagedPoolMaximum),
    TRUE,
#endif

    0, 0, 0, 0, 0,
};

//
// AddDumpInformationFile and OpenDumpFile work together
// to establish the full set of files to use for a particular
// dump target.  As the files are given before the target
// exists, they are collected in this global array until
// the target takes them over.
//

ViewMappedFile g_PendingDumpInfoFiles[DUMP_INFO_COUNT];

//----------------------------------------------------------------------------
//
// ViewMappedFile.
//
//----------------------------------------------------------------------------

#define MAX_CLEAN_PAGE_RECORD 4

ViewMappedFile::ViewMappedFile(void)
{
    // No need to specialize this right now so just pick
    // up the global setting.
    m_CacheGranularity = g_SystemAllocGranularity;

    ResetCache();
    ResetFile();
}

ViewMappedFile::~ViewMappedFile(void)
{
    Close();
}

void
ViewMappedFile::ResetCache(void)
{
    m_ActiveCleanPages = 0;
    InitializeListHead(&m_InFileOrderList);
    InitializeListHead(&m_InLRUOrderList);
}

void
ViewMappedFile::ResetFile(void)
{
    m_FileNameW = NULL;
    m_FileNameA = NULL;
    m_File = NULL;
    m_FileSize = 0;
    m_Map = NULL;
    m_MapBase = NULL;
    m_MapSize = 0;
}

void
ViewMappedFile::EmptyCache(void)
{
    PLIST_ENTRY Next;
    CacheRecord* CacheRec;

    Next = m_InFileOrderList.Flink;

    while (Next != &m_InFileOrderList)
    {
        CacheRec = CONTAINING_RECORD(Next, CacheRecord, InFileOrderList);
        Next = Next->Flink;

        UnmapViewOfFile(CacheRec->MappedAddress);

        free(CacheRec);
    }

    ResetCache();
}

ViewMappedFile::CacheRecord*
ViewMappedFile::ReuseOldestCacheRecord(ULONG64 FileByteOffset)
{
    CacheRecord* CacheRec;
    PLIST_ENTRY Next;
    PVOID MappedAddress;
    ULONG64 MapOffset;
    ULONG Size;

    MapOffset = FileByteOffset & ~((ULONG64)m_CacheGranularity - 1);

    if ((m_FileSize - MapOffset) < m_CacheGranularity)
    {
        Size = (ULONG)(m_FileSize - MapOffset);
    }
    else
    {
        Size = m_CacheGranularity;
    }

    MappedAddress = MapViewOfFile(m_Map, FILE_MAP_READ,
                                  (DWORD)(MapOffset >> 32),
                                  (DWORD)MapOffset, Size);
    if (MappedAddress == NULL)
    {
        return NULL;
    }

    Next = m_InLRUOrderList.Flink;

    CacheRec = CONTAINING_RECORD(Next, CacheRecord, InLRUOrderList);

    UnmapViewOfFile(CacheRec->MappedAddress);

    CacheRec->PageNumber = FileByteOffset / m_CacheGranularity;
    CacheRec->MappedAddress = MappedAddress;

    //
    // Move record to end of LRU
    //

    RemoveEntryList(Next);
    InsertTailList(&m_InLRUOrderList, Next);

    //
    // Move record to correct place in ordered list
    //

    RemoveEntryList(&CacheRec->InFileOrderList);
    Next = m_InFileOrderList.Flink;
    while (Next != &m_InFileOrderList)
    {
        CacheRecord* NextCacheRec;
        NextCacheRec = CONTAINING_RECORD(Next, CacheRecord, InFileOrderList);
        if (CacheRec->PageNumber < NextCacheRec->PageNumber)
        {
            break;
        }
        Next = Next->Flink;
    }
    InsertTailList(Next, &CacheRec->InFileOrderList);

    return CacheRec;
}

ViewMappedFile::CacheRecord*
ViewMappedFile::FindCacheRecordForFileByteOffset(ULONG64 FileByteOffset)
{
    CacheRecord* CacheRec;
    PLIST_ENTRY Next;
    ULONG64 PageNumber;

    PageNumber = FileByteOffset / m_CacheGranularity;
    Next = m_InFileOrderList.Flink;
    while (Next != &m_InFileOrderList)
    {
        CacheRec = CONTAINING_RECORD(Next, CacheRecord, InFileOrderList);

        if (CacheRec->PageNumber < PageNumber)
        {
            Next = Next->Flink;
        }
        else if (CacheRec->PageNumber == PageNumber)
        {
            if (!CacheRec->Locked)
            {
                RemoveEntryList(&CacheRec->InLRUOrderList);
                InsertTailList(&m_InLRUOrderList,
                               &CacheRec->InLRUOrderList);
            }

            return CacheRec;
        }
        else
        {
            break;
        }
    }

    //
    // Can't find it in cache.
    //

    return NULL;
}

ViewMappedFile::CacheRecord*
ViewMappedFile::CreateNewFileCacheRecord(ULONG64 FileByteOffset)
{
    CacheRecord* CacheRec;
    CacheRecord* NextCacheRec;
    PLIST_ENTRY Next;
    ULONG64 MapOffset;
    ULONG Size;

    CacheRec = (CacheRecord*)malloc(sizeof(*CacheRec));
    if (CacheRec == NULL)
    {
        return NULL;
    }

    ZeroMemory(CacheRec, sizeof(*CacheRec));

    MapOffset = (FileByteOffset / m_CacheGranularity) *
        m_CacheGranularity;

    if ((m_FileSize - MapOffset) < m_CacheGranularity)
    {
        Size = (ULONG)(m_FileSize - MapOffset);
    }
    else
    {
        Size = m_CacheGranularity;
    }

    CacheRec->MappedAddress = MapViewOfFile(m_Map, FILE_MAP_READ,
                                            (DWORD)(MapOffset >> 32),
                                            (DWORD)MapOffset, Size);
    if (CacheRec->MappedAddress == NULL)
    {
        free(CacheRec);
        return NULL;
    }
    CacheRec->PageNumber = FileByteOffset / m_CacheGranularity;

    //
    // Insert new record in file order list
    //

    Next = m_InFileOrderList.Flink;
    while (Next != &m_InFileOrderList)
    {
        NextCacheRec = CONTAINING_RECORD(Next, CacheRecord, InFileOrderList);
        if (CacheRec->PageNumber < NextCacheRec->PageNumber)
        {
            break;
        }

        Next = Next->Flink;
    }
    InsertTailList(Next, &CacheRec->InFileOrderList);

    //
    // Insert new record at tail of LRU list
    //

    InsertTailList(&m_InLRUOrderList,
                   &CacheRec->InLRUOrderList);

    return CacheRec;
}

PUCHAR
ViewMappedFile::FileOffsetToMappedAddress(ULONG64 FileOffset,
                                          BOOL LockCacheRec,
                                          PULONG Avail)
{
    CacheRecord* CacheRec;
    ULONG64 FileByteOffset;

    if (FileOffset == 0 || FileOffset >= m_FileSize)
    {
        return NULL;
    }

    // The base view covers the beginning of the file.
    if (FileOffset < m_MapSize)
    {
        *Avail = (ULONG)(m_MapSize - FileOffset);
        return (PUCHAR)m_MapBase + FileOffset;
    }

    FileByteOffset = FileOffset;
    CacheRec = FindCacheRecordForFileByteOffset(FileByteOffset);

    if (CacheRec == NULL)
    {
        if (m_ActiveCleanPages < MAX_CLEAN_PAGE_RECORD)
        {
            CacheRec = CreateNewFileCacheRecord(FileByteOffset);
            if (CacheRec)
            {
                m_ActiveCleanPages++;
            }
        }
        else
        {
            //
            // too many pages cached in
            // overwrite existing cache
            //
            CacheRec = ReuseOldestCacheRecord(FileByteOffset);
        }
    }

    if (CacheRec == NULL)
    {
        return NULL;
    }
    else
    {
        if (LockCacheRec && !CacheRec->Locked)
        {
            RemoveEntryList(&CacheRec->InLRUOrderList);
            CacheRec->Locked = TRUE;
            m_ActiveCleanPages--;
        }

        ULONG PageRemainder =
            (ULONG)(FileByteOffset & (m_CacheGranularity - 1));
        *Avail = m_CacheGranularity - PageRemainder;
        return ((PUCHAR)CacheRec->MappedAddress) + PageRemainder;
    }
}

ULONG
ViewMappedFile::ReadFileOffset(ULONG64 Offset, PVOID Buffer, ULONG BufferSize)
{
    ULONG Done = 0;
    ULONG Avail;
    PUCHAR Mapping;

    if (m_File == NULL)
    {
        // Information for this kind of file wasn't provided.
        return 0;
    }

    __try
    {
        while (BufferSize > 0)
        {
            Mapping = FileOffsetToMappedAddress(Offset, FALSE, &Avail);
            if (Mapping == NULL)
            {
                break;
            }

            if (Avail > BufferSize)
            {
                Avail = BufferSize;
            }
            memcpy(Buffer, Mapping, Avail);

            Offset += Avail;
            Buffer = (PUCHAR)Buffer + Avail;
            BufferSize -= Avail;
            Done += Avail;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        Done = 0;
    }

    return Done;
}

ULONG
ViewMappedFile::WriteFileOffset(ULONG64 Offset, PVOID Buffer, ULONG BufferSize)
{
    ULONG Done = 0;
    ULONG Avail;
    PUCHAR Mapping;
    ULONG Protect;

    if (m_File == NULL)
    {
        // Information for this kind of file wasn't provided.
        return 0;
    }

    __try
    {
        while (BufferSize > 0)
        {
            Mapping = FileOffsetToMappedAddress(Offset, TRUE, &Avail);
            if (Mapping == NULL)
            {
                break;
            }

            if (Avail > BufferSize)
            {
                Avail = BufferSize;
            }
            VirtualProtect(Mapping, Avail, PAGE_WRITECOPY, &Protect);
            memcpy(Mapping, Buffer, Avail);

            Offset += Avail;
            Buffer = (PUCHAR)Buffer + Avail;
            BufferSize -= Avail;
            Done += Avail;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        Done = 0;
    }

    return Done;
}

HRESULT
ViewMappedFile::Open(PCWSTR FileName, ULONG64 FileHandle, ULONG InitialView)
{
    HRESULT Status;

    // Pick up default cache size if necessary.
    if (!m_CacheGranularity)
    {
        m_CacheGranularity = g_SystemAllocGranularity;
    }

    if (((m_CacheGranularity - 1) & InitialView) ||
        m_File != NULL)
    {
        return E_INVALIDARG;
    }

    if (!FileName)
    {
        if (!FileHandle)
        {
            return E_INVALIDARG;
        }

        FileName = L"<HandleOnly>";
    }

    m_FileNameW = _wcsdup(FileName);
    if (!m_FileNameW)
    {
        return E_OUTOFMEMORY;
    }
    if ((Status = WideToAnsi(FileName, &m_FileNameA)) != S_OK)
    {
        return Status;
    }

    if (FileHandle)
    {
        m_File = OS_HANDLE(FileHandle);
    }
    else
    {
        // We have to share everything in order to be
        // able to reopen already-open temporary files
        // expanded from CABs as they are marked as
        // delete-on-close.
        m_File = CreateFileW(FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
        if ((!m_File || m_File == INVALID_HANDLE_VALUE) &&
            GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            //
            // ANSI-only platform.  Try the ANSI name.
            //

            m_File = CreateFileA(m_FileNameA,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                                 FILE_SHARE_DELETE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
        }
        if (!m_File || m_File == INVALID_HANDLE_VALUE)
        {
            goto LastStatus;
        }
    }

    //
    // Get file size and map initial view.
    //

    ULONG SizeLow, SizeHigh;

    SizeLow = GetFileSize(m_File, &SizeHigh);
    m_FileSize = ((ULONG64)SizeHigh << 32) | SizeLow;
    m_Map = CreateFileMapping(m_File, NULL, PAGE_READONLY,
                              0, 0, NULL);
    if (m_Map == NULL)
    {
        goto LastStatus;
    }

    if (m_FileSize < InitialView)
    {
        InitialView = (ULONG)m_FileSize;
    }

    m_MapBase = MapViewOfFile(m_Map, FILE_MAP_READ, 0, 0,
                              InitialView);
    if (m_MapBase == NULL)
    {
        goto LastStatus;
    }

    m_MapSize = InitialView;

    return S_OK;

 LastStatus:
    Status = WIN32_LAST_STATUS();
    Close();
    return Status;
}

void
ViewMappedFile::Close(void)
{
    EmptyCache();

    if (m_MapBase != NULL)
    {
        UnmapViewOfFile(m_MapBase);
        m_MapBase = NULL;
    }
    if (m_Map != NULL)
    {
        CloseHandle(m_Map);
        m_Map = NULL;
    }
    free(m_FileNameW);
    m_FileNameW = NULL;
    FreeAnsi(m_FileNameA);
    m_FileNameA = NULL;
    if (m_File != NULL && m_File != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_File);
    }
    m_File = NULL;
    m_FileSize = 0;
    m_MapSize = 0;
}

HRESULT
ViewMappedFile::RemapInitial(ULONG MapSize)
{
    if (MapSize > m_FileSize)
    {
        MapSize = (ULONG)m_FileSize;
    }
    UnmapViewOfFile(m_MapBase);
    m_MapBase = MapViewOfFile(m_Map, FILE_MAP_READ,
                              0, 0, MapSize);
    if (m_MapBase == NULL)
    {
        m_MapSize = 0;
        return WIN32_LAST_STATUS();
    }

    m_MapSize = MapSize;
    return S_OK;
}

void
ViewMappedFile::Transfer(ViewMappedFile* To)
{
    To->m_FileNameW = m_FileNameW;
    To->m_FileNameA = m_FileNameA;
    To->m_File = m_File;
    To->m_FileSize = m_FileSize;
    To->m_Map = m_Map;
    To->m_MapBase = m_MapBase;
    To->m_MapSize = m_MapSize;

    To->m_ActiveCleanPages = m_ActiveCleanPages;
    if (!IsListEmpty(&m_InFileOrderList))
    {
        To->m_InFileOrderList = m_InFileOrderList;
    }
    if (!IsListEmpty(&m_InLRUOrderList))
    {
        To->m_InLRUOrderList = m_InLRUOrderList;
    }

    ResetCache();
    ResetFile();
}

//----------------------------------------------------------------------------
//
// Initialization functions.
//
//----------------------------------------------------------------------------

HRESULT
AddDumpInfoFile(PCWSTR FileName, ULONG64 FileHandle,
                ULONG Index, ULONG InitialView)
{
    HRESULT Status;
    ViewMappedFile* File = &g_PendingDumpInfoFiles[Index];

    if ((Status = File->Open(FileName, FileHandle, InitialView)) != S_OK)
    {
        return Status;
    }

    switch(Index)
    {
    case DUMP_INFO_PAGE_FILE:
        if (memcmp(File->m_MapBase, DMPPF_IDENTIFIER,
                   sizeof(DMPPF_IDENTIFIER) - 1) != 0)
        {
            Status = HR_DATA_CORRUPT;
            File->Close();
        }
        break;
    }

    return Status;
}

DumpTargetInfo*
NewDumpTargetInfo(ULONG DumpType)
{
    switch(DumpType)
    {
    case DTYPE_KERNEL_SUMMARY32:
        return new KernelSummary32DumpTargetInfo;
    case DTYPE_KERNEL_SUMMARY64:
        return new KernelSummary64DumpTargetInfo;
    case DTYPE_KERNEL_TRIAGE32:
        return new KernelTriage32DumpTargetInfo;
    case DTYPE_KERNEL_TRIAGE64:
        return new KernelTriage64DumpTargetInfo;
    case DTYPE_KERNEL_FULL32:
        return new KernelFull32DumpTargetInfo;
    case DTYPE_KERNEL_FULL64:
        return new KernelFull64DumpTargetInfo;
    case DTYPE_USER_FULL32:
        return new UserFull32DumpTargetInfo;
    case DTYPE_USER_FULL64:
        return new UserFull64DumpTargetInfo;
    case DTYPE_USER_MINI_PARTIAL:
        return new UserMiniPartialDumpTargetInfo;
    case DTYPE_USER_MINI_FULL:
        return new UserMiniFullDumpTargetInfo;
    }

    return NULL;
}

HRESULT
IdentifyDump(PCWSTR FileName, ULONG64 FileHandle,
             DumpTargetInfo** TargetRet)
{
    HRESULT Status;

    dprintf("\nLoading Dump File [%ws]\n", FileName);

    if ((Status = AddDumpInfoFile(FileName, FileHandle,
                                  DUMP_INFO_DUMP,
                                  DUMP_INITIAL_VIEW_SIZE)) != S_OK)
    {
        return Status;
    }

    ViewMappedFile* File = &g_PendingDumpInfoFiles[DUMP_INFO_DUMP];
    ULONG i, FileIdx;
    ULONG64 BaseMapSize;
    DumpTargetInfo* Target = NULL;

    for (i = 0; i < DTYPE_COUNT; i++)
    {
        Target = NewDumpTargetInfo(i);
        if (Target == NULL)
        {
            return E_OUTOFMEMORY;
        }

        Target->m_DumpBase = File->m_MapBase;
        BaseMapSize = File->m_MapSize;

        // The target owns the dump info files while it's active.
        for (FileIdx = 0; FileIdx < DUMP_INFO_COUNT; FileIdx++)
        {
            g_PendingDumpInfoFiles[FileIdx].
                Transfer(&Target->m_InfoFiles[FileIdx]);
        }

        Status = Target->IdentifyDump(&BaseMapSize);

        // Remove the info files to handle potential errors and loops.
        for (FileIdx = 0; FileIdx < DUMP_INFO_COUNT; FileIdx++)
        {
            Target->m_InfoFiles[FileIdx].
                Transfer(&g_PendingDumpInfoFiles[FileIdx]);
        }

        if (Status != E_NOINTERFACE)
        {
            break;
        }

        delete Target;
        Target = NULL;
    }

    if (Status == E_NOINTERFACE)
    {
        ErrOut("Could not match Dump File signature - "
               "invalid file format\n");
    }
    else if (Status == S_OK &&
             BaseMapSize > File->m_MapSize)
    {
        if (BaseMapSize > File->m_FileSize ||
            BaseMapSize > DUMP_MAXIMUM_VIEW_SIZE)
        {
            ErrOut("Dump file is too large to map\n");
            Status = E_INVALIDARG;
        }
        else
        {
            // Target requested a larger mapping so
            // try and do so.  Round up to a multiple
            // of the initial view size for cache alignment.
            BaseMapSize =
                (BaseMapSize + DUMP_INITIAL_VIEW_SIZE - 1) &
                ~(DUMP_INITIAL_VIEW_SIZE - 1);
            Status = File->RemapInitial((ULONG)BaseMapSize);
        }
    }

    if (Status == S_OK)
    {
        Target->m_DumpBase = File->m_MapBase;

        // Target now owns the info files permanently.
        for (FileIdx = 0; FileIdx < DUMP_INFO_COUNT; FileIdx++)
        {
            g_PendingDumpInfoFiles[FileIdx].
                Transfer(&Target->m_InfoFiles[FileIdx]);
        }

        *TargetRet = Target;
    }
    else
    {
        delete Target;
        File->Close();
    }

    return Status;
}

//----------------------------------------------------------------------------
//
// DumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
DumpIdentifyStatus(ULONG ExcepCode)
{
    //
    // If we got an access violation it means that the
    // dump content we wanted wasn't present.  Treat
    // this as an identification failure and not a
    // critical failure.
    //
    // Any other code is just passed back as a critical failure.
    //

    if (ExcepCode == STATUS_ACCESS_VIOLATION)
    {
        return E_NOINTERFACE;
    }
    else
    {
        return HRESULT_FROM_NT(ExcepCode);
    }
}

DumpTargetInfo::DumpTargetInfo(ULONG Class, ULONG Qual, BOOL MappedImages)
    : TargetInfo(Class, Qual, FALSE)
{
    m_DumpBase = NULL;
    m_FormatFlags = 0;
    m_MappedImages = MappedImages;
    ZeroMemory(&m_ExceptionRecord, sizeof(m_ExceptionRecord));
    m_ExceptionFirstChance = FALSE;
    m_WriterStatus = DUMP_WRITER_STATUS_UNINITIALIZED;
}

DumpTargetInfo::~DumpTargetInfo(void)
{
    // Force processes and threads to get cleaned up while
    // the memory maps are still available.
    DeleteSystemInfo();
}

HRESULT
DumpTargetInfo::InitSystemInfo(ULONG BuildNumber, ULONG CheckedBuild,
                               ULONG MachineType, ULONG PlatformId,
                               ULONG MajorVersion, ULONG MinorVersion)
{
    HRESULT Status;

    SetSystemVersionAndBuild(BuildNumber, PlatformId);
    m_CheckedBuild = CheckedBuild;
    m_KdApi64 = (m_SystemVersion > NT_SVER_NT4);
    m_PlatformId = PlatformId;

    // We can call InitializeForProcessor right away as it
    // doesn't do anything interesting for dumps.
    if ((Status = InitializeMachines(MachineType)) != S_OK ||
        (Status = InitializeForProcessor()) != S_OK)
    {
        return Status;
    }
    if (m_Machine == NULL)
    {
        ErrOut("Dump has an unknown processor type, 0x%X\n", MachineType);
        return HR_DATA_CORRUPT;
    }

    m_KdVersion.MachineType = (USHORT) MachineType;
    m_KdVersion.MajorVersion = (USHORT) MajorVersion;
    m_KdVersion.MinorVersion = (USHORT) MinorVersion;
    m_KdVersion.Flags = DBGKD_VERS_FLAG_DATA |
        (m_Machine->m_Ptr64 ? DBGKD_VERS_FLAG_PTR64 : 0);

    return S_OK;
}

HRESULT
DumpTargetInfo::ReadVirtual(
    IN ProcessInfo* Process,
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesRead
    )
{
    ULONG Done = 0;
    ULONG FileIndex;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (BufferSize == 0)
    {
        *BytesRead = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        FileOffset = VirtualToOffset(Offset, &FileIndex, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = m_InfoFiles[FileIndex].
            ReadFileOffset(FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesRead = Done;
    // If we didn't read anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
DumpTargetInfo::WriteVirtual(
    IN ProcessInfo* Process,
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesWritten
    )
{
    ULONG Done = 0;
    ULONG FileIndex;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (BufferSize == 0)
    {
        *BytesWritten = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        FileOffset = VirtualToOffset(Offset, &FileIndex, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = m_InfoFiles[FileIndex].
            WriteFileOffset(FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesWritten = Done;
    // If we didn't write anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
DumpTargetInfo::MapReadVirtual(ProcessInfo* Process,
                               ULONG64 Offset,
                               PVOID Buffer,
                               ULONG BufferSize,
                               PULONG BytesRead)
{
    //
    // There are two mapped memory lists kept, one
    // for dump data and one for images mapped from disk.
    // Dump data always takes precedence over mapped image
    // data as on-disk images may not reflect the true state
    // of memory at the time of the dump.  Read from the dump
    // data map whenever possible, only going to the image map
    // when no dump data is available.
    //

    *BytesRead = 0;
    while (BufferSize > 0)
    {
        ULONG64 NextAddr;
        ULONG Req;
        ULONG Read;

        //
        // Check the dump data map.
        //

        if (m_DataMemMap.ReadMemory(Offset, Buffer, BufferSize, &Read))
        {
            Offset += Read;
            Buffer = (PVOID)((PUCHAR)Buffer + Read);
            BufferSize -= Read;
            *BytesRead += Read;

            // If we got everything we're done.
            if (BufferSize == 0)
            {
                break;
            }
        }

        //
        // We still have memory to read so check the image map.
        //

        // Find out where the next data block is so we can limit
        // the image map read.
        Req = BufferSize;
        if (m_DataMemMap.GetNextRegion(Offset, &NextAddr))
        {
            NextAddr -= Offset;
            if (NextAddr < Req)
            {
                Req = (ULONG)NextAddr;
            }
        }

        // Now demand-load any deferred image memory.
        DemandLoadReferencedImageMemory(Process, Offset, Req);

        // Try to read.
        if (m_ImageMemMap.ReadMemory(Offset, Buffer, Req, &Read))
        {
            Offset += Read;
            Buffer = (PVOID)((PUCHAR)Buffer + Read);
            BufferSize -= Read;
            *BytesRead += Read;

            // This read was limited to an area that wouldn't overlap
            // any data memory so if we didn't read the full request
            // we know there isn't data memory available either and
            // we can quit.
            if (Read < Req)
            {
                break;
            }
        }
        else
        {
            // No memory in either map.
            break;
        }
    }

    return *BytesRead > 0 ? S_OK : E_FAIL;
}

void
DumpTargetInfo::MapNearestDifferentlyValidOffsets(ULONG64 Offset,
                                                  PULONG64 NextOffset,
                                                  PULONG64 NextPage)
{
    //
    // In a minidump there can be memory fragments mapped at
    // arbitrary locations so we cannot assume validity
    // changes on page boundaries.
    //

    if (NextOffset != NULL)
    {
        ULONG64 Next;

        *NextOffset = (ULONG64)-1;
        if (m_DataMemMap.GetNextRegion(Offset, &Next))
        {
            *NextOffset = Next;
        }
        if (m_DataMemMap.GetNextRegion(Offset, &Next) &&
            Next < *NextOffset)
        {
            *NextOffset = Next;
        }
        if (*NextOffset == (ULONG64)-1)
        {
            *NextOffset = Offset + 1;
        }
    }
    if (NextPage != NULL)
    {
        *NextPage = (Offset + m_Machine->m_PageSize) &
            ~((ULONG64)m_Machine->m_PageSize - 1);
    }
}

HRESULT
DumpTargetInfo::SwitchProcessors(ULONG Processor)
{
    SetCurrentProcessorThread(this, Processor, FALSE);
    return S_OK;
}

HRESULT
DumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                      PCSTR CommentA, PCWSTR CommentW)
{
    ErrOut("Dump file type does not support writing\n");
    return E_NOTIMPL;
}

PVOID
DumpTargetInfo::IndexRva(PVOID Base, RVA Rva, ULONG Size, PCSTR Title)
{
    if (Rva >= m_InfoFiles[DUMP_INFO_DUMP].m_MapSize)
    {
        ErrOut("ERROR: %s not present in dump (RVA 0x%X)\n",
               Title, Rva);
        FlushCallbacks();
        return NULL;
    }
    else if (Rva + Size > m_InfoFiles[DUMP_INFO_DUMP].m_MapSize)
    {
        ErrOut("ERROR: %s only partially present in dump "
               "(RVA 0x%X, size 0x%X)\n",
               Title, Rva, Size);
        FlushCallbacks();
        return NULL;
    }

    return IndexByByte(Base, Rva);
}

//----------------------------------------------------------------------------
//
// KernelDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
OutputHeaderString(PCSTR Format, PSTR Str)
{
    if (*(PULONG)Str == DUMP_SIGNATURE32 ||
        Str[0] == 0)
    {
        // String not present.
        return;
    }

    dprintf(Format, Str);
}

HRESULT
KernelDumpTargetInfo::ReadControlSpaceIa64(
    ULONG   Processor,
    ULONG64 Offset,
    PVOID   Buffer,
    ULONG   BufferSize,
    PULONG  BytesRead
    )
{
    ULONG64 StartAddr;
    ULONG Read = 0;
    HRESULT Status;

    if (BufferSize < sizeof(ULONG64))
    {
        return E_INVALIDARG;
    }

    switch(Offset)
    {
    case IA64_DEBUG_CONTROL_SPACE_PCR:
        StartAddr = m_KiProcessors[Processor] +
            m_KdDebuggerData.OffsetPrcbPcrPage,
        Status = ReadVirtual(m_ProcessHead,
                             StartAddr, &StartAddr,
                             sizeof(StartAddr), &Read);
        if (Status == S_OK && Read == sizeof(StartAddr))
        {
            *(PULONG64)Buffer =
                (StartAddr << IA64_PAGE_SHIFT) + IA64_PHYSICAL1_START;
        }
        break;

    case IA64_DEBUG_CONTROL_SPACE_PRCB:
        *(PULONG64)Buffer = m_KiProcessors[Processor];
        Read = sizeof(ULONG64);
        Status = S_OK;
        break;

    case IA64_DEBUG_CONTROL_SPACE_KSPECIAL:
        StartAddr = m_KiProcessors[Processor] +
            m_KdDebuggerData.OffsetPrcbProcStateSpecialReg;
        Status = ReadVirtual(m_ProcessHead,
                             StartAddr, Buffer, BufferSize, &Read);
        break;

    case IA64_DEBUG_CONTROL_SPACE_THREAD:
        StartAddr = m_KiProcessors[Processor] +
            m_KdDebuggerData.OffsetPrcbCurrentThread;
        Status = ReadVirtual(m_ProcessHead,
                             StartAddr, Buffer,
                             sizeof(ULONG64), &Read);
        break;
    }

    *BytesRead = Read;
    return Status;
}

HRESULT
KernelDumpTargetInfo::ReadControlSpaceAmd64(
    ULONG   Processor,
    ULONG64 Offset,
    PVOID   Buffer,
    ULONG   BufferSize,
    PULONG  BytesRead
    )
{
    ULONG64 StartAddr;
    ULONG Read = 0;
    HRESULT Status;

    if (BufferSize < sizeof(ULONG64))
    {
        return E_INVALIDARG;
    }

    switch(Offset)
    {
    case AMD64_DEBUG_CONTROL_SPACE_PCR:
        *(PULONG64)Buffer = m_KiProcessors[Processor] -
            m_KdDebuggerData.OffsetPcrContainedPrcb;
        Read = sizeof(ULONG64);
        Status = S_OK;
        break;

    case AMD64_DEBUG_CONTROL_SPACE_PRCB:
        *(PULONG64)Buffer = m_KiProcessors[Processor];
        Read = sizeof(ULONG64);
        Status = S_OK;
        break;

    case AMD64_DEBUG_CONTROL_SPACE_KSPECIAL:
        StartAddr = m_KiProcessors[Processor] +
            m_KdDebuggerData.OffsetPrcbProcStateSpecialReg;
        Status = ReadVirtual(m_ProcessHead,
                             StartAddr, Buffer, BufferSize, &Read);
        break;

    case AMD64_DEBUG_CONTROL_SPACE_THREAD:
        StartAddr = m_KiProcessors[Processor] +
            m_KdDebuggerData.OffsetPrcbCurrentThread;
        Status = ReadVirtual(m_ProcessHead,
                             StartAddr, Buffer,
                             sizeof(ULONG64), &Read);
        break;
    }

    *BytesRead = Read;
    return Status;
}

HRESULT
KernelDumpTargetInfo::ReadControl(
    IN ULONG Processor,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    ULONG64 StartAddr;

    //
    // This function will not currently work if the symbols are not loaded.
    //
    if (!IS_KERNEL_TRIAGE_DUMP(this) &&
        m_KdDebuggerData.KiProcessorBlock == 0)
    {
        ErrOut("ReadControl failed - ntoskrnl symbols must be loaded first\n");

        return E_FAIL;
    }

    if (m_KiProcessors[Processor] == 0)
    {
        // This error message is a little too verbose.
#if 0
        ErrOut("No control space information for processor %d\n", Processor);
#endif
        return E_FAIL;
    }

    switch(m_MachineType)
    {
    case IMAGE_FILE_MACHINE_I386:
        // X86 control space is just a view of the PRCB's
        // processor state.  That starts with the context.
        StartAddr = Offset +
            m_KiProcessors[Processor] +
            m_KdDebuggerData.OffsetPrcbProcStateContext;
        return ReadVirtual(m_ProcessHead,
                           StartAddr, Buffer, BufferSize, BytesRead);

    case IMAGE_FILE_MACHINE_IA64:
        return ReadControlSpaceIa64(Processor, Offset, Buffer,
                                    BufferSize, BytesRead);

    case IMAGE_FILE_MACHINE_AMD64:
        return ReadControlSpaceAmd64(Processor, Offset, Buffer,
                                     BufferSize, BytesRead);
    }

    return E_FAIL;
}

HRESULT
KernelDumpTargetInfo::GetTaggedBaseOffset(PULONG64 Offset)
{
    // The tagged offset can never be zero as that's
    // always the dump header, so if the tagged offset
    // is zero it means there's no tagged data.
    *Offset = m_TaggedOffset;
    return m_TaggedOffset ? S_OK : E_NOINTERFACE;
}

HRESULT
KernelDumpTargetInfo::ReadTagged(ULONG64 Offset, PVOID Buffer,
                                 ULONG BufferSize)
{
    ULONG Attempt = m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(Offset, Buffer, BufferSize);
    return Attempt == BufferSize ?
        S_OK : HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY);
}

HRESULT
KernelDumpTargetInfo::GetThreadIdByProcessor(
    IN ULONG Processor,
    OUT PULONG Id
    )
{
    *Id = VIRTUAL_THREAD_ID(Processor);
    return S_OK;
}

HRESULT
KernelDumpTargetInfo::GetThreadInfoDataOffset(ThreadInfo* Thread,
                                              ULONG64 ThreadHandle,
                                              PULONG64 Offset)
{
    return KdGetThreadInfoDataOffset(Thread, ThreadHandle, Offset);
}

HRESULT
KernelDumpTargetInfo::GetProcessInfoDataOffset(ThreadInfo* Thread,
                                               ULONG Processor,
                                               ULONG64 ThreadData,
                                               PULONG64 Offset)
{
    return KdGetProcessInfoDataOffset(Thread, Processor, ThreadData, Offset);
}

HRESULT
KernelDumpTargetInfo::GetThreadInfoTeb(ThreadInfo* Thread,
                                       ULONG ThreadIndex,
                                       ULONG64 ThreadData,
                                       PULONG64 Offset)
{
    return KdGetThreadInfoTeb(Thread, ThreadIndex, ThreadData, Offset);
}

HRESULT
KernelDumpTargetInfo::GetProcessInfoPeb(ThreadInfo* Thread,
                                        ULONG Processor,
                                        ULONG64 ThreadData,
                                        PULONG64 Offset)
{
    return KdGetProcessInfoPeb(Thread, Processor, ThreadData, Offset);
}

ULONG64
KernelDumpTargetInfo::GetCurrentTimeDateN(void)
{
    if (m_SystemVersion < NT_SVER_W2K)
    {
        ULONG64 TimeDate;

        // Header time not available.  Try and read
        // the time saved in the shared user data segment.
        if (ReadSharedUserTimeDateN(&TimeDate) == S_OK)
        {
            return TimeDate;
        }
        else
        {
            return 0;
        }
    }

    return m_Machine->m_Ptr64 ?
        ((PDUMP_HEADER64)m_DumpBase)->SystemTime.QuadPart :
        ((PDUMP_HEADER32)m_DumpBase)->SystemTime.QuadPart;
}

ULONG64
KernelDumpTargetInfo::GetCurrentSystemUpTimeN(void)
{
    ULONG64 Page = DUMP_SIGNATURE32;
    ULONG64 Page64 = Page | (Page << 32);
    ULONG64 SystemUpTime = m_Machine->m_Ptr64 ?
        ((PDUMP_HEADER64)m_DumpBase)->SystemUpTime.QuadPart :
        ((PDUMP_HEADER32)m_DumpBase)->SystemUpTime.QuadPart;

    if (SystemUpTime && (SystemUpTime != Page64))
    {
        return SystemUpTime;
    }

    // Header time not available.  Try and read
    // the time saved in the shared user data segment.

    if (ReadSharedUserUpTimeN(&SystemUpTime) == S_OK)
    {
        return SystemUpTime;
    }
    else
    {
        return 0;
    }
}

HRESULT
KernelDumpTargetInfo::GetProductInfo(PULONG ProductType, PULONG SuiteMask)
{
    PULONG HdrType, HdrMask;

    // Try and get the information from the header.  If that's
    // not available try and read it from the shared user data.
    if (m_Machine->m_Ptr64)
    {
        HdrType = &((PDUMP_HEADER64)m_DumpBase)->ProductType;
        HdrMask = &((PDUMP_HEADER64)m_DumpBase)->SuiteMask;
    }
    else
    {
        HdrType = &((PDUMP_HEADER32)m_DumpBase)->ProductType;
        HdrMask = &((PDUMP_HEADER32)m_DumpBase)->SuiteMask;
    }
    if (*HdrType == DUMP_SIGNATURE32)
    {
        // Not available in header.
        return ReadSharedUserProductInfo(ProductType, SuiteMask);
    }
    else
    {
        *ProductType = *HdrType;
        *SuiteMask = *HdrMask;
    }
    return S_OK;
}

HRESULT
KernelDumpTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    return m_Machine->ReadKernelProcessorId(Processor, Id);
}

HRESULT
KernelDumpTargetInfo::GetProcessorSpeed
    (ULONG Processor, PULONG Speed)
{
    HRESULT Status;
    ULONG64 Prcb;

    if ((Status =
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    return
         ReadAllVirtual(m_ProcessHead,
                        Prcb + m_KdDebuggerData.OffsetPrcbMhz, Speed,
                        sizeof(ULONG));
}

HRESULT
KernelDumpTargetInfo::InitGlobals32(PMEMORY_DUMP32 Dump)
{
    if (Dump->Header.DirectoryTableBase == 0)
    {
        ErrOut("Invalid directory table base value 0x%x\n",
               Dump->Header.DirectoryTableBase);
        return HR_DATA_CORRUPT;
    }

    if (Dump->Header.MinorVersion > 1381 &&
        Dump->Header.PaeEnabled == TRUE )
    {
        m_KdDebuggerData.PaeEnabled = TRUE;
    }
    else
    {
        m_KdDebuggerData.PaeEnabled = FALSE;
    }

    m_KdDebuggerData.PsLoadedModuleList =
        EXTEND64(Dump->Header.PsLoadedModuleList);
    m_KdVersion.PsLoadedModuleList =
        m_KdDebuggerData.PsLoadedModuleList;
    m_NumProcessors = Dump->Header.NumberProcessors;
    ExceptionRecord32To64(&Dump->Header.Exception, &m_ExceptionRecord);
    m_ExceptionFirstChance = FALSE;
    m_HeaderContext = Dump->Header.ContextRecord;

    // New field in XP, Win2k SP1 and above
    if ((Dump->Header.KdDebuggerDataBlock) &&
        (Dump->Header.KdDebuggerDataBlock != DUMP_SIGNATURE32))
    {
        m_KdDebuggerDataOffset =
            EXTEND64(Dump->Header.KdDebuggerDataBlock);
    }

    m_WriterStatus = Dump->Header.WriterStatus;
    
    OutputHeaderString("Comment: '%s'\n", Dump->Header.Comment);

    HRESULT Status =
        InitSystemInfo(Dump->Header.MinorVersion,
                       Dump->Header.MajorVersion & 0xFF,
                       Dump->Header.MachineImageType,
                       VER_PLATFORM_WIN32_NT,
                       Dump->Header.MajorVersion,
                       Dump->Header.MinorVersion);
    if (Status != S_OK)
    {
        return Status;
    }

    if (IS_KERNEL_TRIAGE_DUMP(this))
    {
        return S_OK;
    }

    ULONG NextIdx;

    // We're expecting that the header value will be non-zero
    // so that we don't need a thread to indicate the current processor.
    // If it turns out to be zero the implicit read will fail
    // due to the NULL.
    return m_Machine->
        SetPageDirectory(NULL, PAGE_DIR_KERNEL,
                         Dump->Header.DirectoryTableBase,
                         &NextIdx);
}

HRESULT
KernelDumpTargetInfo::InitGlobals64(PMEMORY_DUMP64 Dump)
{
    if (Dump->Header.DirectoryTableBase == 0)
    {
        ErrOut("Invalid directory table base value 0x%I64x\n",
               Dump->Header.DirectoryTableBase);
        return HR_DATA_CORRUPT;
    }

    m_KdDebuggerData.PaeEnabled = FALSE;
    m_KdDebuggerData.PsLoadedModuleList =
        Dump->Header.PsLoadedModuleList;
    m_KdVersion.PsLoadedModuleList =
        m_KdDebuggerData.PsLoadedModuleList;
    m_NumProcessors = Dump->Header.NumberProcessors;
    m_ExceptionRecord = Dump->Header.Exception;
    m_ExceptionFirstChance = FALSE;
    m_HeaderContext = Dump->Header.ContextRecord;

    // New field in XP, Win2k SP1 and above
    if ((Dump->Header.KdDebuggerDataBlock) &&
        (Dump->Header.KdDebuggerDataBlock != DUMP_SIGNATURE32))
    {
        m_KdDebuggerDataOffset =
            Dump->Header.KdDebuggerDataBlock;
    }

    m_WriterStatus = Dump->Header.WriterStatus;
    
    OutputHeaderString("Comment: '%s'\n", Dump->Header.Comment);

    HRESULT Status =
        InitSystemInfo(Dump->Header.MinorVersion,
                       Dump->Header.MajorVersion & 0xFF,
                       Dump->Header.MachineImageType,
                       VER_PLATFORM_WIN32_NT,
                       Dump->Header.MajorVersion,
                       Dump->Header.MinorVersion);
    if (Status != S_OK)
    {
        return Status;
    }

    if (IS_KERNEL_TRIAGE_DUMP(this))
    {
        return S_OK;
    }

    ULONG NextIdx;

    // We're expecting that the header value will be non-zero
    // so that we don't need a thread to indicate the current processor.
    // If it turns out to be zero the implicit read will fail
    // due to the NULL.
    return m_Machine->
        SetPageDirectory(NULL, PAGE_DIR_KERNEL,
                         Dump->Header.DirectoryTableBase,
                         &NextIdx);
}

void
KernelDumpTargetInfo::DumpHeader32(PDUMP_HEADER32 Header)
{
    dprintf("\nDUMP_HEADER32:\n");
    dprintf("MajorVersion        %08lx\n", Header->MajorVersion);
    dprintf("MinorVersion        %08lx\n", Header->MinorVersion);
    dprintf("DirectoryTableBase  %08lx\n", Header->DirectoryTableBase);
    dprintf("PfnDataBase         %08lx\n", Header->PfnDataBase);
    dprintf("PsLoadedModuleList  %08lx\n", Header->PsLoadedModuleList);
    dprintf("PsActiveProcessHead %08lx\n", Header->PsActiveProcessHead);
    dprintf("MachineImageType    %08lx\n", Header->MachineImageType);
    dprintf("NumberProcessors    %08lx\n", Header->NumberProcessors);
    dprintf("BugCheckCode        %08lx\n", Header->BugCheckCode);
    dprintf("BugCheckParameter1  %08lx\n", Header->BugCheckParameter1);
    dprintf("BugCheckParameter2  %08lx\n", Header->BugCheckParameter2);
    dprintf("BugCheckParameter3  %08lx\n", Header->BugCheckParameter3);
    dprintf("BugCheckParameter4  %08lx\n", Header->BugCheckParameter4);
    OutputHeaderString("VersionUser         '%s'\n", Header->VersionUser);
    dprintf("PaeEnabled          %08lx\n", Header->PaeEnabled);
    dprintf("KdDebuggerDataBlock %08lx\n", Header->KdDebuggerDataBlock);
    OutputHeaderString("Comment             '%s'\n", Header->Comment);
    if (Header->SecondaryDataState != DUMP_SIGNATURE32)
    {
        dprintf("SecondaryDataState  %08lx\n", Header->SecondaryDataState);
    }
    if (Header->ProductType != DUMP_SIGNATURE32)
    {
        dprintf("ProductType         %08lx\n", Header->ProductType);
        dprintf("SuiteMask           %08lx\n", Header->SuiteMask);
    }
    if (Header->WriterStatus != DUMP_SIGNATURE32)
    {
        dprintf("WriterStatus        %08lx\n", Header->WriterStatus);
    }
}

void
KernelDumpTargetInfo::DumpHeader64(PDUMP_HEADER64 Header)
{
    dprintf("\nDUMP_HEADER64:\n");
    dprintf("MajorVersion        %08lx\n", Header->MajorVersion);
    dprintf("MinorVersion        %08lx\n", Header->MinorVersion);
    dprintf("DirectoryTableBase  %s\n",
            FormatAddr64(Header->DirectoryTableBase));
    dprintf("PfnDataBase         %s\n",
            FormatAddr64(Header->PfnDataBase));
    dprintf("PsLoadedModuleList  %s\n",
            FormatAddr64(Header->PsLoadedModuleList));
    dprintf("PsActiveProcessHead %s\n",
            FormatAddr64(Header->PsActiveProcessHead));
    dprintf("MachineImageType    %08lx\n", Header->MachineImageType);
    dprintf("NumberProcessors    %08lx\n", Header->NumberProcessors);
    dprintf("BugCheckCode        %08lx\n", Header->BugCheckCode);
    dprintf("BugCheckParameter1  %s\n",
            FormatAddr64(Header->BugCheckParameter1));
    dprintf("BugCheckParameter2  %s\n",
            FormatAddr64(Header->BugCheckParameter2));
    dprintf("BugCheckParameter3  %s\n",
            FormatAddr64(Header->BugCheckParameter3));
    dprintf("BugCheckParameter4  %s\n",
            FormatAddr64(Header->BugCheckParameter4));
    OutputHeaderString("VersionUser         '%s'\n", Header->VersionUser);
    dprintf("KdDebuggerDataBlock %s\n",
            FormatAddr64(Header->KdDebuggerDataBlock));
    OutputHeaderString("Comment             '%s'\n", Header->Comment);
    if (Header->SecondaryDataState != DUMP_SIGNATURE32)
    {
        dprintf("SecondaryDataState  %08lx\n", Header->SecondaryDataState);
    }
    if (Header->ProductType != DUMP_SIGNATURE32)
    {
        dprintf("ProductType         %08lx\n", Header->ProductType);
        dprintf("SuiteMask           %08lx\n", Header->SuiteMask);
    }
    if (Header->WriterStatus != DUMP_SIGNATURE32)
    {
        dprintf("WriterStatus        %08lx\n", Header->WriterStatus);
    }
}

//----------------------------------------------------------------------------
//
// KernelFullSumDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
KernelFullSumDumpTargetInfo::PageFileOffset(ULONG PfIndex, ULONG64 PfOffset,
                                            PULONG64 FileOffset)
{
    ViewMappedFile* File = &m_InfoFiles[DUMP_INFO_PAGE_FILE];
    if (File->m_File == NULL)
    {
        return HR_PAGE_NOT_AVAILABLE;
    }
    if (PfIndex > MAX_PAGING_FILE_MASK)
    {
        return HR_DATA_CORRUPT;
    }

    //
    // We can safely assume the header information is present
    // in the base mapping.
    //

    DMPPF_FILE_HEADER* Hdr = (DMPPF_FILE_HEADER*)File->m_MapBase;
    DMPPF_PAGE_FILE_INFO* FileInfo = &Hdr->PageFiles[PfIndex];
    ULONG64 PfPage = PfOffset >> m_Machine->m_PageShift;

    if (PfPage >= FileInfo->MaximumSize)
    {
        return HR_PAGE_NOT_AVAILABLE;
    }

    ULONG i;
    ULONG PageDirOffs = sizeof(*Hdr) + (ULONG)PfPage * sizeof(ULONG);

    for (i = 0; i < PfIndex; i++)
    {
        PageDirOffs += Hdr->PageFiles[i].MaximumSize * sizeof(ULONG);
    }

    ULONG PageDirEnt;

    if (m_InfoFiles[DUMP_INFO_PAGE_FILE].
        ReadFileOffset(PageDirOffs, &PageDirEnt, sizeof(PageDirEnt)) !=
        sizeof(PageDirEnt))
    {
        return HR_DATA_CORRUPT;
    }

    if (PageDirEnt == DMPPF_PAGE_NOT_PRESENT)
    {
        return HR_PAGE_NOT_AVAILABLE;
    }

    *FileOffset = Hdr->PageData +
        (PageDirEnt << m_Machine->m_PageShift) +
        (PfOffset & (m_Machine->m_PageSize - 1));
    return S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::ReadPhysical(
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    ULONG Flags,
    PULONG BytesRead
    )
{
    ULONG Done = 0;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (Flags != PHYS_FLAG_DEFAULT)
    {
        return E_NOTIMPL;
    }

    if (BufferSize == 0)
    {
        *BytesRead = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        // Don't produce error messages on a direct
        // physical access as the behavior of all data access
        // functions is to just return an error when
        // data is not present.
        FileOffset = PhysicalToOffset(Offset, FALSE, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = m_InfoFiles[DUMP_INFO_DUMP].
            ReadFileOffset(FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesRead = Done;
    // If we didn't read anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::WritePhysical(
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    ULONG Flags,
    PULONG BytesWritten
    )
{
    ULONG Done = 0;
    ULONG Avail;
    ULONG Attempt;
    ULONG64 FileOffset;

    if (Flags != PHYS_FLAG_DEFAULT)
    {
        return E_NOTIMPL;
    }

    if (BufferSize == 0)
    {
        *BytesWritten = 0;
        return S_OK;
    }

    while (BufferSize > 0)
    {
        // Don't produce error messages on a direct
        // physical access as the behavior of all data access
        // functions is to just return an error when
        // data is not present.
        FileOffset = PhysicalToOffset(Offset, FALSE, &Avail);
        if (FileOffset == 0)
        {
            break;
        }

        if (Avail > BufferSize)
        {
            Avail = BufferSize;
        }

        Attempt = m_InfoFiles[DUMP_INFO_DUMP].
            WriteFileOffset(FileOffset, Buffer, Avail);
        Done += Attempt;

        if (Attempt < Avail)
        {
            break;
        }

        Offset += Avail;
        Buffer = (PUCHAR)Buffer + Avail;
        BufferSize -= Avail;
    }

    *BytesWritten = Done;
    // If we didn't write anything return an error.
    return Done == 0 ? E_FAIL : S_OK;
}

HRESULT
KernelFullSumDumpTargetInfo::ReadPageFile(ULONG PfIndex, ULONG64 PfOffset,
                                          PVOID Buffer, ULONG Size)
{
    HRESULT Status;
    ULONG64 FileOffset;

    if ((Status = PageFileOffset(PfIndex, PfOffset, &FileOffset)) != S_OK)
    {
        return Status;
    }

    // It's assumed that all page file reads are for the
    // entire amount requested, as there are no situations
    // where it's useful to only read part of a page from the
    // page file.
    if (m_InfoFiles[DUMP_INFO_PAGE_FILE].
        ReadFileOffset(FileOffset, Buffer, Size) < Size)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    else
    {
        return S_OK;
    }
}

HRESULT
KernelFullSumDumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    ULONG Read;
    HRESULT Status;

    Status = ReadVirtual(m_ProcessHead,
                         m_KiProcessors[VIRTUAL_THREAD_INDEX(Thread)] +
                         m_KdDebuggerData.OffsetPrcbProcStateContext,
                         Context, m_TypeInfo.SizeTargetContext,
                         &Read);
    if (Status != S_OK)
    {
        return Status;
    }

    return Read == m_TypeInfo.SizeTargetContext ? S_OK : E_FAIL;
}

HRESULT
KernelFullSumDumpTargetInfo::GetSelDescriptor(ThreadInfo* Thread,
                                              MachineInfo* Machine,
                                              ULONG Selector,
                                              PDESCRIPTOR64 Desc)
{
    return KdGetSelDescriptor(Thread, Machine, Selector, Desc);
}

void
KernelFullSumDumpTargetInfo::DumpDebug(void)
{
    ULONG i;

    dprintf("\nKiProcessorBlock at %s\n",
            FormatAddr64(m_KdDebuggerData.KiProcessorBlock));
    dprintf("  %d KiProcessorBlock entries:\n ",
            m_NumProcessors);
    for (i = 0; i < m_NumProcessors; i++)
    {
        dprintf(" %s", FormatAddr64(m_KiProcessors[i]));
    }
    dprintf("\n");

    ViewMappedFile* PageDump = &m_InfoFiles[DUMP_INFO_PAGE_FILE];
    if (PageDump->m_File != NULL)
    {
        // XXX drewb - Display more information when format is understood.
        dprintf("\nAdditional page file in use\n");
    }
}

ULONG64
KernelFullSumDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                             PULONG File, PULONG Avail)
{
    HRESULT Status;
    ULONG Levels;
    ULONG PfIndex;
    ULONG64 Phys;

    *File = DUMP_INFO_DUMP;

    if ((Status = m_Machine->
         GetVirtualTranslationPhysicalOffsets(m_ProcessHead->
                                              m_CurrentThread,
                                              Virt, NULL, 0, &Levels,
                                              &PfIndex, &Phys)) != S_OK)
    {
        // If the virtual address was paged out we got back
        // a page file reference for the address.  The user
        // may have provided a page file in addition to the
        // normal dump file so translate the reference into
        // a secondary dump information file request.
        if (Status == HR_PAGE_IN_PAGE_FILE)
        {
            if (PageFileOffset(PfIndex, Phys, &Phys) != S_OK)
            {
                return 0;
            }

            *File = DUMP_INFO_PAGE_FILE;
            // Page files always have complete pages so the amount
            // available is always the remainder of the page.
            ULONG PageIndex =
                (ULONG)Virt & (m_Machine->m_PageSize - 1);
            *Avail = m_Machine->m_PageSize - PageIndex;
            return Phys;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        // A summary dump will not contain any pages that
        // are mapped by user-mode addresses.  The virtual
        // translation tables may still have valid mappings,
        // though, so VToO will succeed.  We want to suppress
        // page-not-available messages in this case since
        // the dump is known not to contain user pages.
        return PhysicalToOffset(Phys, Virt >= m_SystemRangeStart, Avail);
    }
}

ULONG
KernelFullSumDumpTargetInfo::GetCurrentProcessor(void)
{
    ULONG i;

    for (i = 0; i < m_NumProcessors; i++)
    {
        CROSS_PLATFORM_CONTEXT Context;

        if (GetContext(VIRTUAL_THREAD_HANDLE(i), &Context) == S_OK)
        {
            switch(m_MachineType)
            {
            case IMAGE_FILE_MACHINE_I386:
                if (Context.X86Nt5Context.Esp ==
                    ((PX86_NT5_CONTEXT)m_HeaderContext)->Esp)
                {
                    return i;
                }
                break;

            case IMAGE_FILE_MACHINE_IA64:
                if (Context.IA64Context.IntSp ==
                    ((PIA64_CONTEXT)m_HeaderContext)->IntSp)
                {
                    return i;
                }
                break;

            case IMAGE_FILE_MACHINE_AMD64:
                if (Context.Amd64Context.Rsp ==
                    ((PAMD64_CONTEXT)m_HeaderContext)->Rsp)
                {
                    return i;
                }
                break;
            }
        }
    }

    // Give up and just pick the default processor.
    return 0;
}

//----------------------------------------------------------------------------
//
// KernelSummaryDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
KernelSummaryDumpTargetInfo::ConstructLocationCache(ULONG BitmapSize,
                                                    ULONG SizeOfBitMap,
                                                    PULONG Buffer)
{
    PULONG Cache;
    ULONG Index;
    ULONG Offset;

    m_PageBitmapSize = BitmapSize;
    m_PageBitmap.SizeOfBitMap = SizeOfBitMap;
    m_PageBitmap.Buffer = Buffer;

    //
    // Create a direct mapped cache.
    //

    Cache = new ULONG[BitmapSize];
    if (!Cache)
    {
        // Not a failure; there just won't be a cache.
        return;
    }

    //
    // For each bit set in the bitmask fill the appropriate cache
    // line location with the correct offset
    //

    Offset = 0;
    for (Index = 0; Index < BitmapSize; Index++)
    {
        //
        // If this page is in the summary dump fill in the offset
        //

        if ( RtlCheckBit (&m_PageBitmap, Index) )
        {
            Cache[ Index ] = Offset++;
        }
    }

    //
    // Assign back to the global storing the cache data.
    //

    m_LocationCache = Cache;
}

ULONG64
KernelSummaryDumpTargetInfo::SumPhysicalToOffset(ULONG HeaderSize,
                                                 ULONG64 Phys,
                                                 BOOL Verbose,
                                                 PULONG Avail)
{
    ULONG Offset, j;
    ULONG64 Page = Phys >> m_Machine->m_PageShift;

    //
    // Make sure this page is included in the dump
    //

    if (Page >= m_PageBitmapSize)
    {
        ErrOut("Page %x too large to be in the dump file.\n", Page);
        return 0;
    }

    BOOL Present = TRUE;

    __try
    {
        if (!RtlCheckBit(&m_PageBitmap, Page))
        {
            if (Verbose)
            {
                ErrOut("Page %x not present in the dump file. "
                       "Type \".hh dbgerr004\" for details\n",
                       Page);
            }
            Present = FALSE;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        return 0;
    }

    if (!Present)
    {
        return 0;
    }

    //
    // If the cache exists then find the location the easy way
    //

    if (m_LocationCache != NULL)
    {
        Offset = m_LocationCache[Page];
    }
    else
    {
        //
        // CAVEAT This code will never execute unless there is a failure
        //        creating the summary dump (cache) mapping information
        //
        //
        // The page is in the summary dump locate it's offset
        // Note: this is painful. The offset is a count of
        // all the bits set up to this page
        //

        Offset = 0;

        __try
        {
            for (j = 0; j < m_PageBitmapSize; j++)
            {
                if (RtlCheckBit(&m_PageBitmap, j))
                {
                    //
                    // If the offset is equal to the page were done.
                    //

                    if (j == Page)
                    {
                        break;
                    }

                    Offset++;
                }
            }
        }
        __except(MappingExceptionFilter(GetExceptionInformation()))
        {
            j = m_PageBitmapSize;
        }

        //
        // Sanity check that we didn't drop out of the loop.
        //

        if (j >= m_PageBitmapSize)
        {
            return 0;
        }
    }

    //
    // The actual address is calculated as follows
    // Header size - Size of header plus summary dump header
    //

    ULONG PageIndex =
        (ULONG)Phys & (m_Machine->m_PageSize - 1);
    *Avail = m_Machine->m_PageSize - PageIndex;
    return HeaderSize + (Offset * m_Machine->m_PageSize) +
        PageIndex;
}

HRESULT
KernelSummary32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP32)m_DumpBase;

    dprintf("Kernel Summary Dump File: "
            "Only kernel address space is available\n\n");

    ConstructLocationCache(m_Dump->Summary.BitmapSize,
                           m_Dump->Summary.Bitmap.SizeOfBitMap,
                           m_Dump->Summary.Bitmap.Buffer);

    HRESULT Status = InitGlobals32(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    // Tagged data will follow all of the normal dump data.
    m_TaggedOffset =
        m_Dump->Summary.HeaderSize +
        m_Dump->Summary.Pages * m_Machine->m_PageSize;

    if (m_InfoFiles[DUMP_INFO_DUMP].m_FileSize < m_TaggedOffset)
    {
        WarnOut("************************************************************\n");
        WarnOut("WARNING: Dump file has been truncated.  "
                "Data may be missing.\n");
        WarnOut("************************************************************\n\n");
    }

    m_InfoFiles[DUMP_INFO_DUMP].m_FileSize =
        m_Dump->Header.RequiredDumpSpace.QuadPart;

    return KernelFullSumDumpTargetInfo::Initialize();
}

HRESULT
KernelSummary32DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                              PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "32-bit Kernel summary dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
KernelSummary32DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = EXTEND64(m_Dump->Header.BugCheckParameter1);
    Args[1] = EXTEND64(m_Dump->Header.BugCheckParameter2);
    Args[2] = EXTEND64(m_Dump->Header.BugCheckParameter3);
    Args[3] = EXTEND64(m_Dump->Header.BugCheckParameter4);
    return S_OK;
}

HRESULT
KernelSummary32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP32 Dump = (PMEMORY_DUMP32)m_DumpBase;

    __try
    {
        if (Dump->Header.Signature != DUMP_SIGNATURE32 ||
            Dump->Header.ValidDump != DUMP_VALID_DUMP32 ||
            Dump->Header.DumpType != DUMP_TYPE_SUMMARY)
        {
            __leave;
        }

        if (Dump->Summary.Signature != DUMP_SUMMARY_SIGNATURE)
        {
            // The header says it's a summary dump but
            // it doesn't have a valid signature, so assume
            // it's not a valid dump.
            Status = HR_DATA_CORRUPT;
        }
        else
        {
            PPHYSICAL_MEMORY_RUN32 LastRun;
            ULONG HighestPage;

            // We rely on all of the header information being
            // directly mapped.  Unfortunately the header information
            // can be off due to some size computation bugs, so
            // attempt to get the right size regardless.
            *BaseMapSize = Dump->Summary.HeaderSize;
            LastRun = Dump->Header.PhysicalMemoryBlock.Run +
                (Dump->Header.PhysicalMemoryBlock.NumberOfRuns - 1);
            HighestPage = LastRun->BasePage + LastRun->PageCount;
            if (HighestPage > Dump->Header.PhysicalMemoryBlock.NumberOfPages)
            {
                (*BaseMapSize) +=
                    (HighestPage -
                     Dump->Header.PhysicalMemoryBlock.NumberOfPages + 7) / 8;
            }

            Status = S_OK;
            m_Dump = Dump;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ULONG64
KernelSummary32DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                                PULONG Avail)
{
    return SumPhysicalToOffset(m_Dump->Summary.HeaderSize, Phys, Verbose,
                               Avail);
}

void
KernelSummary32DumpTargetInfo::DumpDebug(void)
{
    PSUMMARY_DUMP32 Sum = &m_Dump->Summary;

    dprintf("----- 32 bit Kernel Summary Dump Analysis\n");

    DumpHeader32(&m_Dump->Header);

    dprintf("\nSUMMARY_DUMP32:\n");
    dprintf("DumpOptions         %08lx\n", Sum->DumpOptions);
    dprintf("HeaderSize          %08lx\n", Sum->HeaderSize);
    dprintf("BitmapSize          %08lx\n", Sum->BitmapSize);
    dprintf("Pages               %08lx\n", Sum->Pages);
    dprintf("Bitmap.SizeOfBitMap %08lx\n", Sum->Bitmap.SizeOfBitMap);

    KernelFullSumDumpTargetInfo::DumpDebug();
}

HRESULT
KernelSummary64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP64)m_DumpBase;

    dprintf("Kernel Summary Dump File: "
            "Only kernel address space is available\n\n");

    ConstructLocationCache(m_Dump->Summary.BitmapSize,
                           m_Dump->Summary.Bitmap.SizeOfBitMap,
                           m_Dump->Summary.Bitmap.Buffer);

    HRESULT Status = InitGlobals64(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    // Tagged data will follow all of the normal dump data.
    m_TaggedOffset =
        m_Dump->Summary.HeaderSize +
        m_Dump->Summary.Pages * m_Machine->m_PageSize;

    if (m_InfoFiles[DUMP_INFO_DUMP].m_FileSize < m_TaggedOffset)
    {
        WarnOut("************************************************************\n");
        WarnOut("WARNING: Dump file has been truncated.  "
                "Data may be missing.\n");
        WarnOut("************************************************************\n\n");
    }

    m_InfoFiles[DUMP_INFO_DUMP].m_FileSize =
        m_Dump->Header.RequiredDumpSpace.QuadPart;

    return KernelFullSumDumpTargetInfo::Initialize();
}

HRESULT
KernelSummary64DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                              PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "64-bit Kernel summary dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
KernelSummary64DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = m_Dump->Header.BugCheckParameter1;
    Args[1] = m_Dump->Header.BugCheckParameter2;
    Args[2] = m_Dump->Header.BugCheckParameter3;
    Args[3] = m_Dump->Header.BugCheckParameter4;
    return S_OK;
}

HRESULT
KernelSummary64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP64 Dump = (PMEMORY_DUMP64)m_DumpBase;

    __try
    {
        if (Dump->Header.Signature != DUMP_SIGNATURE64 ||
            Dump->Header.ValidDump != DUMP_VALID_DUMP64 ||
            Dump->Header.DumpType != DUMP_TYPE_SUMMARY)
        {
            __leave;
        }

        if (Dump->Summary.Signature != DUMP_SUMMARY_SIGNATURE)
        {
            // The header says it's a summary dump but
            // it doesn't have a valid signature, so assume
            // it's not a valid dump.
            Status = HR_DATA_CORRUPT;
        }
        else
        {
            PPHYSICAL_MEMORY_RUN64 LastRun;
            ULONG64 HighestPage;

            // We rely on all of the header information being
            // directly mapped.  Unfortunately the header information
            // can be off due to some size computation bugs, so
            // attempt to get the right size regardless.
            *BaseMapSize = Dump->Summary.HeaderSize;
            LastRun = Dump->Header.PhysicalMemoryBlock.Run +
                (Dump->Header.PhysicalMemoryBlock.NumberOfRuns - 1);
            HighestPage = LastRun->BasePage + LastRun->PageCount;
            if (HighestPage > Dump->Header.PhysicalMemoryBlock.NumberOfPages)
            {
                (*BaseMapSize) +=
                    (HighestPage -
                     Dump->Header.PhysicalMemoryBlock.NumberOfPages + 7) / 8;
            }

            Status = S_OK;
            m_Dump = Dump;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ULONG64
KernelSummary64DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                                PULONG Avail)
{
    return SumPhysicalToOffset(m_Dump->Summary.HeaderSize, Phys, Verbose,
                               Avail);
}

void
KernelSummary64DumpTargetInfo::DumpDebug(void)
{
    PSUMMARY_DUMP64 Sum = &m_Dump->Summary;

    dprintf("----- 64 bit Kernel Summary Dump Analysis\n");

    DumpHeader64(&m_Dump->Header);

    dprintf("\nSUMMARY_DUMP64:\n");
    dprintf("DumpOptions         %08lx\n", Sum->DumpOptions);
    dprintf("HeaderSize          %08lx\n", Sum->HeaderSize);
    dprintf("BitmapSize          %08lx\n", Sum->BitmapSize);
    dprintf("Pages               %08lx\n", Sum->Pages);
    dprintf("Bitmap.SizeOfBitMap %08lx\n", Sum->Bitmap.SizeOfBitMap);

    KernelFullSumDumpTargetInfo::DumpDebug();
}

//----------------------------------------------------------------------------
//
// KernelTriageDumpTargetInfo.
//
//----------------------------------------------------------------------------

void
KernelTriageDumpTargetInfo::NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                           PULONG64 NextOffset,
                                                           PULONG64 NextPage)
{
    return MapNearestDifferentlyValidOffsets(Offset, NextOffset, NextPage);
}

HRESULT
KernelTriageDumpTargetInfo::ReadVirtual(
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    return MapReadVirtual(Process, Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
KernelTriageDumpTargetInfo::GetProcessorSystemDataOffset(
    IN ULONG Processor,
    IN ULONG Index,
    OUT PULONG64 Offset
    )
{
    if (Processor != GetCurrentProcessor())
    {
        return E_INVALIDARG;
    }

    ULONG64 Prcb = m_KiProcessors[Processor];
    HRESULT Status;

    switch(Index)
    {
    case DEBUG_DATA_KPCR_OFFSET:
        // We don't have a full PCR, just a PRCB.
        return E_FAIL;

    case DEBUG_DATA_KPRCB_OFFSET:
        *Offset = Prcb;
        break;

    case DEBUG_DATA_KTHREAD_OFFSET:
        if ((Status = ReadPointer
             (m_ProcessHead, m_Machine,
              Prcb + m_KdDebuggerData.OffsetPrcbCurrentThread,
              Offset)) != S_OK)
        {
            return Status;
        }
        break;
    }

    return S_OK;
}

HRESULT
KernelTriageDumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    // We only have the current context in a triage dump.
    if (VIRTUAL_THREAD_INDEX(Thread) != GetCurrentProcessor())
    {
        return E_INVALIDARG;
    }

    // The KPRCB could be used to retrieve context information as in
    // KernelFullSumDumpTargetInfo::GetTargetContext but
    // for consistency the header context is used since it's
    // the officially advertised place.
    memcpy(Context, m_HeaderContext,
           m_TypeInfo.SizeTargetContext);

    return S_OK;
}

HRESULT
KernelTriageDumpTargetInfo::GetSelDescriptor(ThreadInfo* Thread,
                                             MachineInfo* Machine,
                                             ULONG Selector,
                                             PDESCRIPTOR64 Desc)
{
    return EmulateNtSelDescriptor(Thread, Machine, Selector, Desc);
}

HRESULT
KernelTriageDumpTargetInfo::SwitchProcessors(ULONG Processor)
{
    ErrOut("Can't switch processors on a kernel triage dump\n");
    return E_UNEXPECTED;
}

ULONG64
KernelTriageDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                            PULONG File, PULONG Avail)
{
    ULONG64 Base;
    ULONG Size;
    PVOID Mapping, Param;

    *File = DUMP_INFO_DUMP;

    // ReadVirtual is overridden to read the memory map directly
    // so this function will only be called from the generic
    // WriteVirtual.  We can only write regions mapped out of
    // the dump so only return data memory regions.
    if (m_DataMemMap.GetRegionInfo(Virt, &Base, &Size, &Mapping, &Param))
    {
        ULONG Delta = (ULONG)(Virt - Base);
        *Avail = Size - Delta;
        return ((PUCHAR)Mapping - (PUCHAR)m_DumpBase) + Delta;
    }

    return 0;
}

ULONG
KernelTriageDumpTargetInfo::GetCurrentProcessor(void)
{
    // Extract the processor number from the
    // PRCB in the dump.
    PUCHAR PrcbNumber = (PUCHAR)
        IndexRva(m_DumpBase, m_PrcbOffset +
                 m_KdDebuggerData.OffsetPrcbNumber, sizeof(UCHAR),
                 "PRCB.Number");
    return PrcbNumber ? *PrcbNumber : 0;
}

HRESULT
KernelTriageDumpTargetInfo::MapMemoryRegions(ULONG PrcbOffset,
                                             ULONG ThreadOffset,
                                             ULONG ProcessOffset,
                                             ULONG64 TopOfStack,
                                             ULONG SizeOfCallStack,
                                             ULONG CallStackOffset,
                                             ULONG64 BStoreLimit,
                                             ULONG SizeOfBStore,
                                             ULONG BStoreOffset,
                                             ULONG64 DataPageAddress,
                                             ULONG DataPageOffset,
                                             ULONG DataPageSize,
                                             ULONG64 DebuggerDataAddress,
                                             ULONG DebuggerDataOffset,
                                             ULONG DebuggerDataSize,
                                             ULONG MmDataOffset,
                                             ULONG DataBlocksOffset,
                                             ULONG DataBlocksCount)

{
    HRESULT Status;

    // Map any debugger data.
    // We have to do this first to get the size of the various NT
    // data structures will will map after this.

    if (DebuggerDataAddress)
    {
        if ((Status = m_DataMemMap.
             AddRegion(DebuggerDataAddress,
                       DebuggerDataSize,
                       IndexRva(m_DumpBase,
                                DebuggerDataOffset,
                                DebuggerDataSize,
                                "Debugger data block"),
                       NULL, TRUE)) != S_OK)
        {
            return Status;
        }

        m_HasDebuggerData = TRUE;

        if (MmDataOffset)
        {
            MM_TRIAGE_TRANSLATION* Trans = g_MmTriageTranslations;

            // Map memory fragments for MM Triage information
            // that equates to entries in the debugger data.
            while (Trans->DebuggerDataOffset > 0)
            {
                ULONG64 UNALIGNED* DbgDataPtr;
                ULONG64 DbgData;
                ULONG MmData;
                ULONG Size;

                DbgDataPtr = (ULONG64 UNALIGNED*)
                    IndexRva(m_DumpBase, DebuggerDataOffset +
                             Trans->DebuggerDataOffset,
                             sizeof(ULONG64), "Debugger data block");
                if (!DbgDataPtr)
                {
                    return HR_DATA_CORRUPT;
                }

                DbgData = *DbgDataPtr;
                Size = sizeof(ULONG);
                if (m_Machine->m_Ptr64)
                {
                    MmData = MmDataOffset + Trans->Triage64Offset;
                    if (Trans->PtrSize)
                    {
                        Size = sizeof(ULONG64);
                    }
                }
                else
                {
                    MmData = MmDataOffset + Trans->Triage32Offset;
                    DbgData = EXTEND64(DbgData);
                }

                if ((Status = m_DataMemMap.
                     AddRegion(DbgData, Size,
                               IndexRva(m_DumpBase, MmData, Size,
                                        "MMTRIAGE data"),
                               NULL, TRUE)) != S_OK)
                {
                    return Status;
                }

                Trans++;
            }
        }
    }

    //
    // Load KdDebuggerDataBlock data right now so
    // that the type constants in it are available immediately.
    //

    ReadKdDataBlock(m_ProcessHead);

    // Technically a triage dump doesn't have to contain a KPRCB
    // but we really want it to have one.  Nobody generates them
    // without a KPRCB so this is really just a sanity check.
    if (PrcbOffset == 0)
    {
        ErrOut("Dump does not contain KPRCB\n");
        return E_FAIL;
    }

    // Set this first so GetCurrentProcessor works.
    m_PrcbOffset = PrcbOffset;

    ULONG Processor = GetCurrentProcessor();
    if (Processor >= MAXIMUM_PROCS)
    {
        ErrOut("Dump does not contain valid processor number\n");
        return E_FAIL;
    }

    // The dump contains one PRCB for the current processor.
    // Map the PRCB at the processor-zero location because
    // that location should not ever have some other mapping
    // for the dump.
    m_KiProcessors[Processor] = m_TypeInfo.TriagePrcbOffset;
    if ((Status = m_DataMemMap.
         AddRegion(m_KiProcessors[Processor],
                   m_KdDebuggerData.SizePrcb,
                   IndexRva(m_DumpBase, PrcbOffset,
                            m_KdDebuggerData.SizePrcb, "PRCB"),
                   NULL, FALSE)) != S_OK)
    {
        return Status;
    }

    //
    // Add ETHREAD and EPROCESS memory regions if available.
    //

    if (ThreadOffset != 0)
    {
        PVOID CurThread =
            IndexRva(m_DumpBase, PrcbOffset +
                     m_KdDebuggerData.OffsetPrcbCurrentThread,
                     m_Machine->m_Ptr64 ? 8 : 4,
                     "PRCB.CurrentThread");
        ULONG64 ThreadAddr, ProcAddr;
        PVOID DataPtr;

        if (!CurThread)
        {
            return HR_DATA_CORRUPT;
        }
        if (m_Machine->m_Ptr64)
        {
            ThreadAddr = *(PULONG64)CurThread;
            DataPtr = IndexRva(m_DumpBase, ThreadOffset +
                               m_KdDebuggerData.OffsetKThreadApcProcess,
                               sizeof(ULONG64), "PRCB.ApcState.Process");
            if (!DataPtr)
            {
                return HR_DATA_CORRUPT;
            }
            ProcAddr = *(PULONG64)DataPtr;
        }
        else
        {
            ThreadAddr = EXTEND64(*(PULONG)CurThread);
            DataPtr = IndexRva(m_DumpBase, ThreadOffset +
                               m_KdDebuggerData.OffsetKThreadApcProcess,
                               sizeof(ULONG), "PRCB.ApcState.Process");
            if (!DataPtr)
            {
                return HR_DATA_CORRUPT;
            }
            ProcAddr = EXTEND64(*(PULONG)DataPtr);
        }

        if ((Status = m_DataMemMap.
             AddRegion(ThreadAddr,
                       m_KdDebuggerData.SizeEThread,
                       IndexRva(m_DumpBase, ThreadOffset,
                                m_KdDebuggerData.SizeEThread,
                                "ETHREAD"),
                       NULL, TRUE)) != S_OK)
        {
            return Status;
        }

        if (ProcessOffset != 0)
        {
            if ((Status = m_DataMemMap.
                 AddRegion(ProcAddr,
                           m_KdDebuggerData.SizeEProcess,
                           IndexRva(m_DumpBase, ProcessOffset,
                                    m_KdDebuggerData.SizeEProcess,
                                    "EPROCESS"),
                           NULL, TRUE)) != S_OK)
            {
                return Status;
            }
        }
        else
        {
            WarnOut("Mini Kernel Dump does not have "
                    "process information\n");
        }
    }
    else
    {
        WarnOut("Mini Kernel Dump does not have thread information\n");
    }

    // Add the backing store region.
    if (m_MachineType == IMAGE_FILE_MACHINE_IA64)
    {
        if (BStoreOffset != 0)
        {
            if ((Status = m_DataMemMap.
                 AddRegion(BStoreLimit - SizeOfBStore, SizeOfBStore,
                           IndexRva(m_DumpBase, BStoreOffset, SizeOfBStore,
                                    "Backing store"),
                           NULL, TRUE)) != S_OK)
            {
                return Status;
            }
        }
        else
        {
            WarnOut("Mini Kernel Dump does not have "
                    "backing store information\n");
        }
    }

    // Add data page if available
    if (DataPageAddress)
    {
        if ((Status = m_DataMemMap.
             AddRegion(DataPageAddress, DataPageSize,
                       IndexRva(m_DumpBase, DataPageOffset, DataPageSize,
                                "Data page"),
                       NULL, TRUE)) != S_OK)
        {
            return Status;
        }
    }

    // Map arbitrary data blocks.
    if (DataBlocksCount > 0)
    {
        PTRIAGE_DATA_BLOCK Block;

        Block = (PTRIAGE_DATA_BLOCK)
            IndexRva(m_DumpBase, DataBlocksOffset, sizeof(Block),
                     "Data block descriptor");
        if (!Block)
        {
            return HR_DATA_CORRUPT;
        }
        while (DataBlocksCount-- > 0)
        {
            if ((Status = m_DataMemMap.
                 AddRegion(Block->Address, Block->Size,
                           IndexRva(m_DumpBase, Block->Offset, Block->Size,
                                    "Data block"),
                           NULL, TRUE)) != S_OK)
            {
                return Status;
            }

            Block++;
        }
    }

    // Add the stack to the valid memory region.
    return m_DataMemMap.
        AddRegion(TopOfStack, SizeOfCallStack,
                  IndexRva(m_DumpBase, CallStackOffset,
                           SizeOfCallStack, "Call stack"),
                  NULL, TRUE);
}

void
KernelTriageDumpTargetInfo::DumpDataBlocks(ULONG Offset, ULONG Count)
{
    PTRIAGE_DATA_BLOCK Block;
    ULONG MaxOffset;

    if (Count == 0)
    {
        return;
    }

    Block = (PTRIAGE_DATA_BLOCK)
        IndexRva(m_DumpBase, Offset, sizeof(Block),
                 "Data block descriptor");
    if (!Block)
    {
        return;
    }

    MaxOffset = 0;
    while (Count-- > 0)
    {
        dprintf("  %s - %s at offset %08x\n",
                FormatAddr64(Block->Address),
                FormatAddr64(Block->Address + Block->Size - 1),
                Block->Offset);

        if (Block->Offset + Block->Size > MaxOffset)
        {
            MaxOffset = Block->Offset + Block->Size;
        }

        Block++;
    }

    dprintf("  Max offset %x, %x from end of file\n",
            MaxOffset, (ULONG)(m_InfoFiles[DUMP_INFO_DUMP].m_FileSize -
                               MaxOffset));
}

HRESULT
KernelTriage32DumpTargetInfo::Initialize(void)
{
    HRESULT Status;

    if ((Status = KernelDumpTargetInfo::Initialize()) != S_OK)
    {
        return Status;
    }

    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP32)m_DumpBase;

    dprintf("Mini Kernel Dump File: "
            "Only registers and stack trace are available\n\n");

    PTRIAGE_DUMP32 Triage = &m_Dump->Triage;

    Status = InitGlobals32(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    //
    // Optional memory page
    //

    ULONG64 DataPageAddress = 0;
    ULONG   DataPageOffset = 0;
    ULONG   DataPageSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        DataPageAddress = Triage->DataPageAddress;
        DataPageOffset  = Triage->DataPageOffset;
        DataPageSize    = Triage->DataPageSize;
    }

    //
    // Optional KDDEBUGGER_DATA64.
    //

    ULONG64 DebuggerDataAddress = 0;
    ULONG   DebuggerDataOffset = 0;
    ULONG   DebuggerDataSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        // DebuggerDataBlock field must be valid if the dump is
        // new enough to have a data block in it.
        DebuggerDataAddress = EXTEND64(m_Dump->Header.KdDebuggerDataBlock);
        DebuggerDataOffset  = Triage->DebuggerDataOffset;
        DebuggerDataSize    = Triage->DebuggerDataSize;
    }

    //
    // Optional data blocks.
    //

    ULONG DataBlocksOffset = 0;
    ULONG DataBlocksCount = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        DataBlocksOffset = Triage->DataBlocksOffset;
        DataBlocksCount  = Triage->DataBlocksCount;
    }

    //
    // We store the service pack version in the header because we
    // don't store the actual memory
    //

    SetNtCsdVersion(m_BuildNumber, m_Dump->Triage.ServicePackBuild);

    // Tagged data will follow all of the normal dump data.
    m_TaggedOffset = m_Dump->Triage.SizeOfDump;

    return MapMemoryRegions(Triage->PrcbOffset, Triage->ThreadOffset,
                            Triage->ProcessOffset,
                            EXTEND64(Triage->TopOfStack),
                            Triage->SizeOfCallStack, Triage->CallStackOffset,
                            0, 0, 0,
                            DataPageAddress, DataPageOffset, DataPageSize,
                            DebuggerDataAddress, DebuggerDataOffset,
                            DebuggerDataSize, Triage->MmOffset,
                            DataBlocksOffset, DataBlocksCount);
}

HRESULT
KernelTriage32DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                             PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "32-bit Kernel triage dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
KernelTriage32DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = EXTEND64(m_Dump->Header.BugCheckParameter1);
    Args[1] = EXTEND64(m_Dump->Header.BugCheckParameter2);
    Args[2] = EXTEND64(m_Dump->Header.BugCheckParameter3);
    Args[3] = EXTEND64(m_Dump->Header.BugCheckParameter4);
    return S_OK;
}

HRESULT
KernelTriage32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP32 Dump = (PMEMORY_DUMP32)m_DumpBase;

    __try
    {
        if (Dump->Header.Signature != DUMP_SIGNATURE32 ||
            Dump->Header.ValidDump != DUMP_VALID_DUMP32 ||
            Dump->Header.DumpType != DUMP_TYPE_TRIAGE)
        {
            __leave;
        }

        if (*(PULONG)IndexByByte(Dump, Dump->Triage.SizeOfDump -
                                 sizeof(ULONG)) != TRIAGE_DUMP_VALID)
        {
            // The header says it's a triage dump but
            // it doesn't have a valid signature, so assume
            // it's not a valid dump.
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        // Make sure that the dump has the minimal information that
        // we want.
        if (Dump->Triage.ContextOffset == 0 ||
            Dump->Triage.ExceptionOffset == 0 ||
            Dump->Triage.PrcbOffset == 0 ||
            Dump->Triage.CallStackOffset == 0)
        {
            ErrOut("Mini Kernel Dump does not contain enough "
                   "information to be debugged\n");
            Status = E_FAIL;
            __leave;
        }

        // We rely on being able to directly access the entire
        // content of the dump through the default view so
        // ensure that it's possible.
        *BaseMapSize = m_InfoFiles[DUMP_INFO_DUMP].m_FileSize;

        m_Dump = Dump;
        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ModuleInfo*
KernelTriage32DumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    return UserMode ? NULL : &g_KernelTriage32ModuleIterator;
}

UnloadedModuleInfo*
KernelTriage32DumpTargetInfo::GetUnloadedModuleInfo(void)
{
    return &g_KernelTriage32UnloadedModuleIterator;
}

void
KernelTriage32DumpTargetInfo::DumpDebug(void)
{
    PTRIAGE_DUMP32 Triage = &m_Dump->Triage;

    dprintf("----- 32 bit Kernel Mini Dump Analysis\n");

    DumpHeader32(&m_Dump->Header);
    dprintf("MiniDumpFields      %08lx \n", m_Dump->Header.MiniDumpFields);

    dprintf("\nTRIAGE_DUMP32:\n");
    dprintf("ServicePackBuild      %08lx \n", Triage->ServicePackBuild      );
    dprintf("SizeOfDump            %08lx \n", Triage->SizeOfDump            );
    dprintf("ValidOffset           %08lx \n", Triage->ValidOffset           );
    dprintf("ContextOffset         %08lx \n", Triage->ContextOffset         );
    dprintf("ExceptionOffset       %08lx \n", Triage->ExceptionOffset       );
    dprintf("MmOffset              %08lx \n", Triage->MmOffset              );
    dprintf("UnloadedDriversOffset %08lx \n", Triage->UnloadedDriversOffset );
    dprintf("PrcbOffset            %08lx \n", Triage->PrcbOffset            );
    dprintf("ProcessOffset         %08lx \n", Triage->ProcessOffset         );
    dprintf("ThreadOffset          %08lx \n", Triage->ThreadOffset          );
    dprintf("CallStackOffset       %08lx \n", Triage->CallStackOffset       );
    dprintf("SizeOfCallStack       %08lx \n", Triage->SizeOfCallStack       );
    dprintf("DriverListOffset      %08lx \n", Triage->DriverListOffset      );
    dprintf("DriverCount           %08lx \n", Triage->DriverCount           );
    dprintf("StringPoolOffset      %08lx \n", Triage->StringPoolOffset      );
    dprintf("StringPoolSize        %08lx \n", Triage->StringPoolSize        );
    dprintf("BrokenDriverOffset    %08lx \n", Triage->BrokenDriverOffset    );
    dprintf("TriageOptions         %08lx %s\n",
            Triage->TriageOptions,
            (Triage->TriageOptions != 0xffffffff &&
             (Triage->TriageOptions & TRIAGE_OPTION_OVERFLOWED)) ?
            "OVERFLOWED" : "");
    dprintf("TopOfStack            %08lx \n", Triage->TopOfStack            );

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        dprintf("DataPageAddress       %08lx \n", Triage->DataPageAddress   );
        dprintf("DataPageOffset        %08lx \n", Triage->DataPageOffset    );
        dprintf("DataPageSize          %08lx \n", Triage->DataPageSize      );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        dprintf("DebuggerDataOffset    %08lx \n", Triage->DebuggerDataOffset);
        dprintf("DebuggerDataSize      %08lx \n", Triage->DebuggerDataSize  );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        dprintf("DataBlocksOffset      %08lx \n", Triage->DataBlocksOffset  );
        dprintf("DataBlocksCount       %08lx \n", Triage->DataBlocksCount   );
        DumpDataBlocks(Triage->DataBlocksOffset,
                       Triage->DataBlocksCount);
    }
}

HRESULT
KernelTriage64DumpTargetInfo::Initialize(void)
{
    HRESULT Status;

    if ((Status = KernelDumpTargetInfo::Initialize()) != S_OK)
    {
        return Status;
    }

    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP64)m_DumpBase;

    dprintf("Mini Kernel Dump File: "
            "Only registers and stack trace are available\n\n");

    PTRIAGE_DUMP64 Triage = &m_Dump->Triage;

    Status = InitGlobals64(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    //
    // Optional memory page
    //

    ULONG64 DataPageAddress = 0;
    ULONG   DataPageOffset = 0;
    ULONG   DataPageSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        DataPageAddress = Triage->DataPageAddress;
        DataPageOffset  = Triage->DataPageOffset;
        DataPageSize    = Triage->DataPageSize;
    }

    //
    // Optional KDDEBUGGER_DATA64.
    //

    ULONG64 DebuggerDataAddress = 0;
    ULONG   DebuggerDataOffset = 0;
    ULONG   DebuggerDataSize = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        // DebuggerDataBlock field must be valid if the dump is
        // new enough to have a data block in it.
        DebuggerDataAddress = m_Dump->Header.KdDebuggerDataBlock;
        DebuggerDataOffset  = Triage->DebuggerDataOffset;
        DebuggerDataSize    = Triage->DebuggerDataSize;
    }

    //
    // Optional data blocks.
    //

    ULONG DataBlocksOffset = 0;
    ULONG DataBlocksCount = 0;

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        DataBlocksOffset = Triage->DataBlocksOffset;
        DataBlocksCount  = Triage->DataBlocksCount;
    }

    //
    // We store the service pack version in the header because we
    // don't store the actual memory
    //

    SetNtCsdVersion(m_BuildNumber, m_Dump->Triage.ServicePackBuild);

    // Tagged data will follow all of the normal dump data.
    m_TaggedOffset = m_Dump->Triage.SizeOfDump;

    return MapMemoryRegions(Triage->PrcbOffset, Triage->ThreadOffset,
                            Triage->ProcessOffset, Triage->TopOfStack,
                            Triage->SizeOfCallStack, Triage->CallStackOffset,
                            Triage->ArchitectureSpecific.Ia64.LimitOfBStore,
                            Triage->ArchitectureSpecific.Ia64.SizeOfBStore,
                            Triage->ArchitectureSpecific.Ia64.BStoreOffset,
                            DataPageAddress, DataPageOffset, DataPageSize,
                            DebuggerDataAddress, DebuggerDataOffset,
                            DebuggerDataSize, Triage->MmOffset,
                            DataBlocksOffset, DataBlocksCount);
}

HRESULT
KernelTriage64DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                             PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "64-bit Kernel triage dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
KernelTriage64DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = m_Dump->Header.BugCheckParameter1;
    Args[1] = m_Dump->Header.BugCheckParameter2;
    Args[2] = m_Dump->Header.BugCheckParameter3;
    Args[3] = m_Dump->Header.BugCheckParameter4;
    return S_OK;
}

HRESULT
KernelTriage64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP64 Dump = (PMEMORY_DUMP64)m_DumpBase;

    __try
    {
        if (Dump->Header.Signature != DUMP_SIGNATURE64 ||
            Dump->Header.ValidDump != DUMP_VALID_DUMP64 ||
            Dump->Header.DumpType != DUMP_TYPE_TRIAGE)
        {
            __leave;
        }

        if (*(PULONG)IndexByByte(Dump, Dump->Triage.SizeOfDump -
                                 sizeof(ULONG)) != TRIAGE_DUMP_VALID)
        {
            // The header says it's a triage dump but
            // it doesn't have a valid signature, so assume
            // it's not a valid dump.
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        // Make sure that the dump has the minimal information that
        // we want.
        if (Dump->Triage.ContextOffset == 0 ||
            Dump->Triage.ExceptionOffset == 0 ||
            Dump->Triage.PrcbOffset == 0 ||
            Dump->Triage.CallStackOffset == 0)
        {
            ErrOut("Mini Kernel Dump does not contain enough "
                   "information to be debugged\n");
            Status = E_FAIL;
            __leave;
        }

        // We rely on being able to directly access the entire
        // content of the dump through the default view so
        // ensure that it's possible.
        *BaseMapSize = m_InfoFiles[DUMP_INFO_DUMP].m_FileSize;

        m_Dump = Dump;
        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ModuleInfo*
KernelTriage64DumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    return UserMode ? NULL : &g_KernelTriage64ModuleIterator;
}

UnloadedModuleInfo*
KernelTriage64DumpTargetInfo::GetUnloadedModuleInfo(void)
{
    return &g_KernelTriage64UnloadedModuleIterator;
}

void
KernelTriage64DumpTargetInfo::DumpDebug(void)
{
    PTRIAGE_DUMP64 Triage = &m_Dump->Triage;

    dprintf("----- 64 bit Kernel Mini Dump Analysis\n");

    DumpHeader64(&m_Dump->Header);
    dprintf("MiniDumpFields      %08lx \n", m_Dump->Header.MiniDumpFields);

    dprintf("\nTRIAGE_DUMP64:\n");
    dprintf("ServicePackBuild      %08lx \n", Triage->ServicePackBuild      );
    dprintf("SizeOfDump            %08lx \n", Triage->SizeOfDump            );
    dprintf("ValidOffset           %08lx \n", Triage->ValidOffset           );
    dprintf("ContextOffset         %08lx \n", Triage->ContextOffset         );
    dprintf("ExceptionOffset       %08lx \n", Triage->ExceptionOffset       );
    dprintf("MmOffset              %08lx \n", Triage->MmOffset              );
    dprintf("UnloadedDriversOffset %08lx \n", Triage->UnloadedDriversOffset );
    dprintf("PrcbOffset            %08lx \n", Triage->PrcbOffset            );
    dprintf("ProcessOffset         %08lx \n", Triage->ProcessOffset         );
    dprintf("ThreadOffset          %08lx \n", Triage->ThreadOffset          );
    dprintf("CallStackOffset       %08lx \n", Triage->CallStackOffset       );
    dprintf("SizeOfCallStack       %08lx \n", Triage->SizeOfCallStack       );
    dprintf("DriverListOffset      %08lx \n", Triage->DriverListOffset      );
    dprintf("DriverCount           %08lx \n", Triage->DriverCount           );
    dprintf("StringPoolOffset      %08lx \n", Triage->StringPoolOffset      );
    dprintf("StringPoolSize        %08lx \n", Triage->StringPoolSize        );
    dprintf("BrokenDriverOffset    %08lx \n", Triage->BrokenDriverOffset    );
    dprintf("TriageOptions         %08lx %s\n",
            Triage->TriageOptions,
            (Triage->TriageOptions != 0xffffffff &&
             (Triage->TriageOptions & TRIAGE_OPTION_OVERFLOWED)) ?
            "OVERFLOWED" : "");
    dprintf("TopOfStack            %s \n",
            FormatAddr64(Triage->TopOfStack));
    dprintf("BStoreOffset          %08lx \n",
            Triage->ArchitectureSpecific.Ia64.BStoreOffset );
    dprintf("SizeOfBStore          %08lx \n",
            Triage->ArchitectureSpecific.Ia64.SizeOfBStore );
    dprintf("LimitOfBStore         %s \n",
            FormatAddr64(Triage->ArchitectureSpecific.Ia64.LimitOfBStore));

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATAPAGE))
    {
        dprintf("DataPageAddress       %s \n",
                FormatAddr64(Triage->DataPageAddress));
        dprintf("DataPageOffset        %08lx \n", Triage->DataPageOffset    );
        dprintf("DataPageSize          %08lx \n", Triage->DataPageSize      );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DEBUGGER_DATA))
    {
        dprintf("DebuggerDataOffset    %08lx \n", Triage->DebuggerDataOffset);
        dprintf("DebuggerDataSize      %08lx \n", Triage->DebuggerDataSize  );
    }

    if (((m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_BASIC_INFO) ==
            TRIAGE_DUMP_BASIC_INFO) &&
        (m_Dump->Header.MiniDumpFields & TRIAGE_DUMP_DATA_BLOCKS))
    {
        dprintf("DataBlocksOffset      %08lx \n", Triage->DataBlocksOffset  );
        dprintf("DataBlocksCount       %08lx \n", Triage->DataBlocksCount   );
        DumpDataBlocks(Triage->DataBlocksOffset,
                       Triage->DataBlocksCount);
    }
}

//----------------------------------------------------------------------------
//
// KernelFullDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
KernelFull32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP32)m_DumpBase;

    dprintf("Kernel Dump File: Full address space is available\n\n");

    HRESULT Status = InitGlobals32(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    // Tagged data will follow all of the normal dump data.
    m_TaggedOffset =
        sizeof(m_Dump->Header) +
        m_Dump->Header.PhysicalMemoryBlock.NumberOfPages *
        m_Machine->m_PageSize;

    if (m_InfoFiles[DUMP_INFO_DUMP].m_FileSize < m_TaggedOffset)
    {
        WarnOut("************************************************************\n");
        WarnOut("WARNING: Dump file has been truncated.  "
                "Data may be missing.\n");
        WarnOut("************************************************************\n\n");
    }

    return KernelFullSumDumpTargetInfo::Initialize();
}

HRESULT
KernelFull32DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                           PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "32-bit Full kernel dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
KernelFull32DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = EXTEND64(m_Dump->Header.BugCheckParameter1);
    Args[1] = EXTEND64(m_Dump->Header.BugCheckParameter2);
    Args[2] = EXTEND64(m_Dump->Header.BugCheckParameter3);
    Args[3] = EXTEND64(m_Dump->Header.BugCheckParameter4);
    return S_OK;
}

HRESULT
KernelFull32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP32 Dump = (PMEMORY_DUMP32)m_DumpBase;

    __try
    {
        if (Dump->Header.Signature != DUMP_SIGNATURE32 ||
            Dump->Header.ValidDump != DUMP_VALID_DUMP32)
        {
            __leave;
        }

        if (Dump->Header.DumpType != DUMP_SIGNATURE32 &&
            Dump->Header.DumpType != DUMP_TYPE_FULL)
        {
            // We've seen some cases where the end of a dump
            // header is messed up, leaving the dump type wrong.
            // If this is an older build let such corruption
            // go by with a warning.
            if (Dump->Header.MinorVersion < 2195)
            {
                WarnOut("***************************************************************\n");
                WarnOut("WARNING: Full dump header type is invalid, "
                        "dump may be corrupt.\n");
                WarnOut("***************************************************************\n");
            }
            else
            {
                __leave;
            }
        }

        // Summary and triage dumps must be checked before this
        // so there's nothing left to check.
        m_Dump = Dump;
        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ULONG64
KernelFull32DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                             PULONG Avail)
{
    ULONG PageIndex =
        (ULONG)Phys & (m_Machine->m_PageSize - 1);

    *Avail = m_Machine->m_PageSize - PageIndex;

    ULONG64 Offset = 0;

    __try
    {
        PPHYSICAL_MEMORY_DESCRIPTOR32 PhysDesc =
            &m_Dump->Header.PhysicalMemoryBlock;
        ULONG64 Page = Phys >> m_Machine->m_PageShift;

        ULONG j = 0;

        while (j < PhysDesc->NumberOfRuns)
        {
            if ((Page >= PhysDesc->Run[j].BasePage) &&
                (Page < (PhysDesc->Run[j].BasePage +
                         PhysDesc->Run[j].PageCount)))
            {
                Offset += Page - PhysDesc->Run[j].BasePage;
                Offset = Offset * m_Machine->m_PageSize +
                    sizeof(m_Dump->Header) + PageIndex;
                break;
            }

            Offset += PhysDesc->Run[j].PageCount;
            j += 1;
        }

        if (j >= PhysDesc->NumberOfRuns)
        {
            KdOut("Physical Memory Address %s is "
                  "greater than MaxPhysicalAddress\n",
                  FormatDisp64(Phys));
            Offset = 0;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        Offset = 0;
    }

    return Offset;
}

void
KernelFull32DumpTargetInfo::DumpDebug(void)
{
    PPHYSICAL_MEMORY_DESCRIPTOR32 PhysDesc =
        &m_Dump->Header.PhysicalMemoryBlock;
    ULONG PageSize = m_Machine->m_PageSize;

    dprintf("----- 32 bit Kernel Full Dump Analysis\n");

    DumpHeader32(&m_Dump->Header);

    dprintf("\nPhysical Memory Description:\n");
    dprintf("Number of runs: %d\n", PhysDesc->NumberOfRuns);

    dprintf("          FileOffset  Start Address  Length\n");

    ULONG j = 0;
    ULONG Offset = 1;

    while (j < PhysDesc->NumberOfRuns)
    {
        dprintf("           %08lx     %08lx     %08lx\n",
                 Offset * PageSize,
                 PhysDesc->Run[j].BasePage * PageSize,
                 PhysDesc->Run[j].PageCount * PageSize);

        Offset += PhysDesc->Run[j].PageCount;
        j += 1;
    }

    j--;
    dprintf("Last Page: %08lx     %08lx\n",
             (Offset - 1) * PageSize,
             (PhysDesc->Run[j].BasePage + PhysDesc->Run[j].PageCount - 1) *
                 PageSize);

    KernelFullSumDumpTargetInfo::DumpDebug();
}

HRESULT
KernelFull64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Dump = (PMEMORY_DUMP64)m_DumpBase;

    dprintf("Kernel Dump File: Full address space is available\n\n");

    HRESULT Status = InitGlobals64(m_Dump);
    if (Status != S_OK)
    {
        return Status;
    }

    // Tagged data will follow all of the normal dump data.
    m_TaggedOffset =
        sizeof(m_Dump->Header) +
        m_Dump->Header.PhysicalMemoryBlock.NumberOfPages *
        m_Machine->m_PageSize;

    if (m_InfoFiles[DUMP_INFO_DUMP].m_FileSize < m_TaggedOffset)
    {
        WarnOut("************************************************************\n");
        WarnOut("WARNING: Dump file has been truncated.  "
                "Data may be missing.\n");
        WarnOut("************************************************************\n\n");
    }

    return KernelFullSumDumpTargetInfo::Initialize();
}

HRESULT
KernelFull64DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                           PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "64-bit Full kernel dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
KernelFull64DumpTargetInfo::ReadBugCheckData(PULONG Code, ULONG64 Args[4])
{
    *Code = m_Dump->Header.BugCheckCode;
    Args[0] = m_Dump->Header.BugCheckParameter1;
    Args[1] = m_Dump->Header.BugCheckParameter2;
    Args[2] = m_Dump->Header.BugCheckParameter3;
    Args[3] = m_Dump->Header.BugCheckParameter4;
    return S_OK;
}

HRESULT
KernelFull64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PMEMORY_DUMP64 Dump = (PMEMORY_DUMP64)m_DumpBase;

    __try
    {
        if (Dump->Header.Signature != DUMP_SIGNATURE64 ||
            Dump->Header.ValidDump != DUMP_VALID_DUMP64 ||
            (Dump->Header.DumpType != DUMP_SIGNATURE32 &&
             Dump->Header.DumpType != DUMP_TYPE_FULL))
        {
            __leave;
        }

        // Summary and triage dumps must be checked before this
        // so there's nothing left to check.
        m_Dump = Dump;
        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ULONG64
KernelFull64DumpTargetInfo::PhysicalToOffset(ULONG64 Phys, BOOL Verbose,
                                             PULONG Avail)
{
    ULONG PageIndex =
        (ULONG)Phys & (m_Machine->m_PageSize - 1);

    *Avail = m_Machine->m_PageSize - PageIndex;

    ULONG64 Offset = 0;

    __try
    {
        PPHYSICAL_MEMORY_DESCRIPTOR64 PhysDesc =
            &m_Dump->Header.PhysicalMemoryBlock;
        ULONG64 Page = Phys >> m_Machine->m_PageShift;

        ULONG j = 0;

        while (j < PhysDesc->NumberOfRuns)
        {
            if ((Page >= PhysDesc->Run[j].BasePage) &&
                (Page < (PhysDesc->Run[j].BasePage +
                         PhysDesc->Run[j].PageCount)))
            {
                Offset += Page - PhysDesc->Run[j].BasePage;
                Offset = Offset * m_Machine->m_PageSize +
                    sizeof(m_Dump->Header) + PageIndex;
                break;
            }

            Offset += PhysDesc->Run[j].PageCount;
            j += 1;
        }

        if (j >= PhysDesc->NumberOfRuns)
        {
            KdOut("Physical Memory Address %s is "
                  "greater than MaxPhysicalAddress\n",
                  FormatDisp64(Phys));
            Offset = 0;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        Offset = 0;
    }

    return Offset;
}

void
KernelFull64DumpTargetInfo::DumpDebug(void)
{
    PPHYSICAL_MEMORY_DESCRIPTOR64 PhysDesc =
        &m_Dump->Header.PhysicalMemoryBlock;
    ULONG PageSize = m_Machine->m_PageSize;

    dprintf("----- 64 bit Kernel Full Dump Analysis\n");

    DumpHeader64(&m_Dump->Header);

    dprintf("\nPhysical Memory Description:\n");
    dprintf("Number of runs: %d\n", PhysDesc->NumberOfRuns);

    dprintf("          FileOffset           Start Address           Length\n");

    ULONG j = 0;
    ULONG64 Offset = 1;

    while (j < PhysDesc->NumberOfRuns)
    {
        dprintf("           %s     %s     %s\n",
                FormatAddr64(Offset * PageSize),
                FormatAddr64(PhysDesc->Run[j].BasePage * PageSize),
                FormatAddr64(PhysDesc->Run[j].PageCount * PageSize));

        Offset += PhysDesc->Run[j].PageCount;
        j += 1;
    }

    j--;
    dprintf("Last Page: %s     %s\n",
            FormatAddr64((Offset - 1) * PageSize),
            FormatAddr64((PhysDesc->Run[j].BasePage +
                          PhysDesc->Run[j].PageCount - 1) *
                         PageSize));

    KernelFullSumDumpTargetInfo::DumpDebug();
}

//----------------------------------------------------------------------------
//
// UserDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserDumpTargetInfo::GetThreadInfoDataOffset(ThreadInfo* Thread,
                                            ULONG64 ThreadHandle,
                                            PULONG64 Offset)
{
    if (Thread != NULL && Thread->m_DataOffset != 0)
    {
        *Offset = Thread->m_DataOffset;
        return S_OK;
    }

    BOOL ContextThread = FALSE;

    if (Thread != NULL)
    {
        ThreadHandle = Thread->m_Handle;
        ContextThread = Thread == m_RegContextThread;
    }
    else if (ThreadHandle == 0)
    {
        return E_UNEXPECTED;
    }
    else
    {
        // Arbitrary thread handle provided.
        ContextThread = FALSE;
    }

    HRESULT Status;
    ULONG64 TebAddr;
    ULONG Id, Suspend;

    if ((Status = GetThreadInfo(VIRTUAL_THREAD_INDEX(ThreadHandle),
                                &Id, &Suspend, &TebAddr)) != S_OK)
    {
        ErrOut("User dump thread %u not available\n",
               VIRTUAL_THREAD_INDEX(ThreadHandle));
        return Status;
    }

    if (TebAddr == 0)
    {
        //
        // NT4 dumps have a bug - they do not fill in the TEB value.
        // luckily, for pretty much all user mode processes, the
        // TEBs start two pages down from the highest user address.
        // For example, on x86 we try 0x7FFDE000 (on 3GB systems 0xBFFDE000).
        //

        if (!m_Machine->m_Ptr64 &&
            m_HighestMemoryRegion32 > 0x80000000)
        {
            TebAddr = 0xbffe0000;
        }
        else
        {
            TebAddr = 0x7ffe0000;
        }
        TebAddr -= 2 * m_Machine->m_PageSize;

        //
        // Try and validate that this is really a TEB.
        // If it isn't search lower memory addresses for
        // a while, but don't get hung up here.
        //

        ULONG64 TebCheck = TebAddr;
        ULONG Attempts = 8;
        BOOL IsATeb = FALSE;

        while (Attempts > 0)
        {
            ULONG64 TebSelf;

            // Check if this looks like a TEB.  TEBs have a
            // self pointer in the TIB that's useful for this.
            if (ReadPointer(m_ProcessHead,
                            m_Machine,
                            TebCheck +
                            6 * (m_Machine->m_Ptr64 ? 8 : 4),
                            &TebSelf) == S_OK &&
                TebSelf == TebCheck)
            {
                // It looks like it's a TEB.  Remember this address
                // so that if all searching fails we'll at least
                // return some TEB.
                TebAddr = TebCheck;
                IsATeb = TRUE;

                // If the given thread is the current register context
                // thread we can check and see if the current SP falls
                // within the stack limits in the TEB.
                if (ContextThread)
                {
                    ULONG64 StackBase, StackLimit;
                    ADDR Sp;

                    m_Machine->GetSP(&Sp);
                    if (m_Machine->m_Ptr64)
                    {
                        StackBase = STACK_BASE_FROM_TEB64;
                        StackLimit = StackBase + 8;
                    }
                    else
                    {
                        StackBase = STACK_BASE_FROM_TEB32;
                        StackLimit = StackBase + 4;
                    }
                    if (ReadPointer(m_ProcessHead,
                                    m_Machine,
                                    TebCheck + StackBase,
                                    &StackBase) == S_OK &&
                        ReadPointer(m_ProcessHead,
                                    m_Machine,
                                    TebCheck + StackLimit,
                                    &StackLimit) == S_OK &&
                        Flat(Sp) >= StackLimit &&
                        Flat(Sp) <= StackBase)
                    {
                        // SP is within stack limits, everything
                        // looks good.
                        break;
                    }
                }
                else
                {
                    // Can't validate SP so just go with it.
                    break;
                }

                // As long as we're looking through real TEBs
                // we'll continue searching.  Otherwise we
                // wouldn't be able to locate TEBs in dumps that
                // have a lot of threads.
                Attempts++;
            }

            // The memory either wasn't a TEB or was the
            // wrong TEB.  Drop down a page and try again.
            TebCheck -= m_Machine->m_PageSize;
            Attempts--;
        }

        WarnOut("WARNING: Teb %u pointer is NULL - "
                "defaulting to %s\n", VIRTUAL_THREAD_INDEX(ThreadHandle),
                FormatAddr64(TebAddr));
        if (!IsATeb)
        {
            WarnOut("WARNING: %s does not appear to be a TEB\n",
                    FormatAddr64(TebAddr));
        }
        else if (Attempts == 0)
        {
            WarnOut("WARNING: %s does not appear to be the right TEB\n",
                    FormatAddr64(TebAddr));
        }
    }

    *Offset = TebAddr;
    if (Thread != NULL)
    {
        Thread->m_DataOffset = TebAddr;
    }
    return S_OK;
}

HRESULT
UserDumpTargetInfo::GetProcessInfoDataOffset(ThreadInfo* Thread,
                                             ULONG Processor,
                                             ULONG64 ThreadData,
                                             PULONG64 Offset)
{
    if (Thread != NULL && Thread->m_Process->m_DataOffset != 0)
    {
        *Offset = Thread->m_Process->m_DataOffset;
        return S_OK;
    }

    HRESULT Status;

    if (Thread != NULL || ThreadData == 0)
    {
        if ((Status = GetThreadInfoDataOffset(Thread, 0,
                                              &ThreadData)) != S_OK)
        {
            return Status;
        }
    }

    ThreadData += m_Machine->m_Ptr64 ?
        PEB_FROM_TEB64 : PEB_FROM_TEB32;
    if ((Status = ReadPointer(m_ProcessHead,
                              m_Machine, ThreadData,
                              Offset)) != S_OK)
    {
        return Status;
    }

    if (Thread != NULL)
    {
        Thread->m_Process->m_DataOffset = *Offset;
    }

    return S_OK;
}

HRESULT
UserDumpTargetInfo::GetThreadInfoTeb(ThreadInfo* Thread,
                                     ULONG Processor,
                                     ULONG64 ThreadData,
                                     PULONG64 Offset)
{
    return GetThreadInfoDataOffset(Thread, ThreadData, Offset);
}

HRESULT
UserDumpTargetInfo::GetProcessInfoPeb(ThreadInfo* Thread,
                                      ULONG Processor,
                                      ULONG64 ThreadData,
                                      PULONG64 Offset)
{
    // Thread data is not useful.
    return GetProcessInfoDataOffset(Thread, 0, 0, Offset);
}

HRESULT
UserDumpTargetInfo::GetSelDescriptor(ThreadInfo* Thread,
                                     MachineInfo* Machine,
                                     ULONG Selector,
                                     PDESCRIPTOR64 Desc)
{
    return EmulateNtSelDescriptor(Thread, Machine, Selector, Desc);
}

//----------------------------------------------------------------------------
//
// UserFullDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserFullDumpTargetInfo::GetBuildAndPlatform(ULONG MachineType,
                                            PULONG MajorVersion,
                                            PULONG MinorVersion,
                                            PULONG BuildNumber,
                                            PULONG PlatformId)
{
    //
    // Allow a knowledgeable user to override the
    // dump version in order to work around problems
    // with userdump.exe always generating version 5
    // dumps regardless of the actual OS version.
    //

    PSTR Override = getenv("DBGENG_FULL_DUMP_VERSION");
    if (Override)
    {
        switch(sscanf(Override, "%d.%d:%d:%d",
                      MajorVersion, MinorVersion,
                      BuildNumber, PlatformId))
        {
        case 2:
        case 3:
            // Only major/minor given, so let the build
            // and platform be guessed from them.
            break;
        case 4:
            // Everything was given, we're done.
            return S_OK;
        default:
            // Invalid format, this will produce an error below.
            *MajorVersion = 0;
            *MinorVersion = 0;
            break;
        }
    }

    //
    // The only way to distinguish user dump
    // platforms is guessing from the Major/MinorVersion
    // and the extra QFE/Hotfix data.
    //

    // If this is for a processor that only CE supports
    // we can immediately select CE.
    if (MachineType == IMAGE_FILE_MACHINE_ARM)
    {
        *BuildNumber = 1;
        *PlatformId = VER_PLATFORM_WIN32_CE;
        goto CheckBuildNumber;
    }

    switch(*MajorVersion)
    {
    case 4:
        switch(*MinorVersion & 0xffff)
        {
        case 0:
            // This could be Win95 or NT4.  We mostly
            // deal with NT dumps so just assume NT.
            *BuildNumber = 1381;
            *PlatformId = VER_PLATFORM_WIN32_NT;
            break;
        case 3:
            // Win95 OSR releases were 4.03.  Treat them
            // as Win95 for now.
            *BuildNumber = 950;
            *PlatformId = VER_PLATFORM_WIN32_WINDOWS;
            break;
        case 10:
            // This could be Win98 or Win98SE.  Go with Win98.
            *BuildNumber = 1998;
            *PlatformId = VER_PLATFORM_WIN32_WINDOWS;
            break;
        case 90:
            // Win98 ME.
            *BuildNumber = 3000;
            *PlatformId = VER_PLATFORM_WIN32_WINDOWS;
            break;
        }
        break;

    case 5:
        *PlatformId = VER_PLATFORM_WIN32_NT;
        switch(*MinorVersion & 0xffff)
        {
        case 0:
            *BuildNumber = 2195;
            break;
        case 1:
            // Just has to be greater than 2195 to
            // distinguish it from Win2K RTM.
            *BuildNumber = 2196;
            break;
        }
        break;

    case 6:
        // Has to be some form of NT.  Longhorn is the only
        // one we recognize.
        *PlatformId = VER_PLATFORM_WIN32_NT;
        // XXX drewb - Longhorn hasn't split their build numbers
        // off yet so they're the same as .NET.  Just pick
        // a junk build.
        *BuildNumber = 9999;
        break;

    case 0:
        // AV: Busted BETA of the debugger generates a broken dump file
        // Guess it's 2195.
        WarnOut("Dump file was generated with NULL version - "
                "guessing Windows 2000, ");
        *PlatformId = VER_PLATFORM_WIN32_NT;
        *BuildNumber = 2195;
        break;

    default:
        // Other platforms are not supported.
        ErrOut("Dump file was generated by an unsupported system, ");
        ErrOut("version %x.%x\n", *MajorVersion, *MinorVersion & 0xffff);
        return E_INVALIDARG;
    }

 CheckBuildNumber:
    // Newer full user dumps have the actual build number in
    // the high word, so use it if it's present.
    if (*MinorVersion >> 16)
    {
        *BuildNumber = *MinorVersion >> 16;
    }

    return S_OK;
}

HRESULT
UserFull32DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Header = (PUSERMODE_CRASHDUMP_HEADER32)m_DumpBase;

    dprintf("User Dump File: Only application data is available\n\n");

    ULONG MajorVersion, MinorVersion;
    ULONG BuildNumber;
    ULONG PlatformId;
    HRESULT Status;

    MajorVersion = m_Header->MajorVersion;
    MinorVersion = m_Header->MinorVersion;

    if ((Status = GetBuildAndPlatform(m_Header->MachineImageType,
                                      &MajorVersion, &MinorVersion,
                                      &BuildNumber, &PlatformId)) != S_OK)
    {
        return Status;
    }

    if ((Status = InitSystemInfo(BuildNumber, 0,
                                 m_Header->MachineImageType, PlatformId,
                                 MajorVersion,
                                 MinorVersion & 0xffff)) != S_OK)
    {
        return Status;
    }

    // Dump does not contain this information.
    m_NumProcessors = 1;

    DEBUG_EVENT32 Event;

    if (m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Header->DebugEventOffset, &Event,
                       sizeof(Event)) != sizeof(Event))
    {
        ErrOut("Unable to read debug event at offset %x\n",
               m_Header->DebugEventOffset);
        return E_FAIL;
    }

    m_EventProcessId = Event.dwProcessId;
    m_EventProcessSymHandle =
        GloballyUniqueProcessHandle(this, Event.dwProcessId);
    m_EventThreadId = Event.dwThreadId;

    if (Event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        ExceptionRecord32To64(&Event.u.Exception.ExceptionRecord,
                              &m_ExceptionRecord);
        m_ExceptionFirstChance = Event.u.Exception.dwFirstChance;
    }
    else
    {
        // Fake an exception.
        ZeroMemory(&m_ExceptionRecord, sizeof(m_ExceptionRecord));
        m_ExceptionRecord.ExceptionCode = STATUS_BREAKPOINT;
        m_ExceptionFirstChance = FALSE;
    }

    m_ThreadCount = m_Header->ThreadCount;

    m_Memory = (PMEMORY_BASIC_INFORMATION32)
        IndexByByte(m_Header, m_Header->MemoryRegionOffset);

    //
    // Determine the highest memory region address.
    // This helps differentiate 2GB systems from 3GB systems.
    //

    ULONG i;
    PMEMORY_BASIC_INFORMATION32 Mem;
    ULONG TotalMemory;

    Mem = m_Memory;
    m_HighestMemoryRegion32 = 0;
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        if (Mem->BaseAddress > m_HighestMemoryRegion32)
        {
            m_HighestMemoryRegion32 = Mem->BaseAddress;
        }

        Mem++;
    }

    VerbOut("  Memory regions: %d\n",
            m_Header->MemoryRegionCount);
    TotalMemory = 0;
    Mem = m_Memory;
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        VerbOut("  %5d: %08X - %08X off %08X, prot %08X, type %08X\n",
                i, Mem->BaseAddress,
                Mem->BaseAddress + Mem->RegionSize - 1,
                TotalMemory + m_Header->DataOffset,
                Mem->Protect, Mem->Type);

        if ((Mem->Protect & PAGE_GUARD) ||
            (Mem->Protect & PAGE_NOACCESS) ||
            (Mem->State & MEM_FREE) ||
            (Mem->State & MEM_RESERVE))
        {
            VerbOut("       Region has data-less pages\n");
        }

        TotalMemory += Mem->RegionSize;
        Mem++;
    }

    VerbOut("  Total memory region size %X, file %08X - %08X\n",
            TotalMemory, m_Header->DataOffset,
            m_Header->DataOffset + TotalMemory - 1);

    //
    // Determine whether guard pages are present in
    // the dump content or not.
    //
    // First try with IgnoreGuardPages == TRUE.
    //

    m_IgnoreGuardPages = TRUE;

    if (!VerifyModules())
    {
        //
        // That didn't work, try IgnoreGuardPages == FALSE.
        //

        m_IgnoreGuardPages = FALSE;

        if (!VerifyModules())
        {
            ErrOut("Module list is corrupt\n");
            return HR_DATA_CORRUPT;
        }
    }

    return UserDumpTargetInfo::Initialize();
}

HRESULT
UserFull32DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                         PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "32-bit Full user dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
UserFull32DumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (VIRTUAL_THREAD_INDEX(Thread) >= m_Header->ThreadCount)
    {
        return E_INVALIDARG;
    }

    if (m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Header->ThreadOffset +
                       VIRTUAL_THREAD_INDEX(Thread) *
                       m_TypeInfo.SizeTargetContext,
                       Context,
                       m_TypeInfo.SizeTargetContext) ==
        m_TypeInfo.SizeTargetContext)
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

ModuleInfo*
UserFull32DumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    DBG_ASSERT(UserMode);
    // If this dump came from an NT system we'll just
    // use the system's loaded module list.  Otherwise
    // we'll use the dump's module list.
    return m_PlatformId == VER_PLATFORM_WIN32_NT ?
        (ModuleInfo*)&g_NtTargetUserModuleIterator :
        (ModuleInfo*)&g_UserFull32ModuleIterator;
}

HRESULT
UserFull32DumpTargetInfo::QueryMemoryRegion(ProcessInfo* Process,
                                            PULONG64 Handle,
                                            BOOL HandleIsOffset,
                                            PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;

    if (HandleIsOffset)
    {
        ULONG BestIndex;
        ULONG BestDiff;

        //
        // Emulate VirtualQueryEx and return the closest higher
        // region if a containing region isn't found.
        //

        BestIndex = 0xffffffff;
        BestDiff = 0xffffffff;
        for (Index = 0; Index < m_Header->MemoryRegionCount; Index++)
        {
            if ((ULONG)*Handle >= m_Memory[Index].BaseAddress)
            {
                if ((ULONG)*Handle < m_Memory[Index].BaseAddress +
                    m_Memory[Index].RegionSize)
                {
                    // Found a containing region, we're done.
                    BestIndex = Index;
                    break;
                }

                // Not containing and lower in memory, ignore.
            }
            else
            {
                // Check and see if this is a closer
                // region than what we've seen already.
                ULONG Diff = m_Memory[Index].BaseAddress -
                    (ULONG)*Handle;
                if (Diff <= BestDiff)
                {
                    BestIndex = Index;
                    BestDiff = Diff;
                }
            }
        }

        if (BestIndex >= m_Header->MemoryRegionCount)
        {
            return E_NOINTERFACE;
        }

        Index = BestIndex;
    }
    else
    {
        Index = (ULONG)*Handle;

        for (;;)
        {
            if (Index >= m_Header->MemoryRegionCount)
            {
                return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
            }

            if (!(m_Memory[Index].Protect & PAGE_GUARD))
            {
                break;
            }

            Index++;
        }
    }

    MemoryBasicInformation32To64(&m_Memory[Index], Info);
    *Handle = ++Index;

    return S_OK;
}

HRESULT
UserFull32DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PUSERMODE_CRASHDUMP_HEADER32 Header =
        (PUSERMODE_CRASHDUMP_HEADER32)m_DumpBase;

    __try
    {
        if (Header->Signature != USERMODE_CRASHDUMP_SIGNATURE ||
            Header->ValidDump != USERMODE_CRASHDUMP_VALID_DUMP32)
        {
            __leave;
        }

        //
        // Check for the presence of some basic things.
        //

        if (Header->ThreadCount == 0 ||
            Header->ModuleCount == 0 ||
            Header->MemoryRegionCount == 0)
        {
            ErrOut("Thread, module or memory region count is zero.\n"
                   "The dump file is probably corrupt.\n");
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        if (Header->ThreadOffset == 0 ||
            Header->ModuleOffset == 0 ||
            Header->DataOffset == 0 ||
            Header->MemoryRegionOffset == 0 ||
            Header->DebugEventOffset == 0 ||
            Header->ThreadStateOffset == 0)
        {
            ErrOut("A dump header data offset is zero.\n"
                   "The dump file is probably corrupt.\n");
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        // We don't want to have to call ReadFileOffset
        // every time we check memory ranges so just require
        // that the memory descriptors fit in the base view.
        *BaseMapSize = Header->MemoryRegionOffset +
            Header->MemoryRegionCount * sizeof(*m_Memory);

        m_Header = Header;
        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

void
UserFull32DumpTargetInfo::DumpDebug(void)
{
    dprintf("----- 32 bit User Full Dump Analysis\n\n");

    dprintf("MajorVersion:       %d\n", m_Header->MajorVersion);
    dprintf("MinorVersion:       %d (Build %d)\n",
            m_Header->MinorVersion & 0xffff,
            m_Header->MinorVersion >> 16);
    dprintf("MachineImageType:   %08lx\n", m_Header->MachineImageType);
    dprintf("ThreadCount:        %08lx\n", m_Header->ThreadCount);
    dprintf("ThreadOffset:       %08lx\n", m_Header->ThreadOffset);
    dprintf("ThreadStateOffset:  %08lx\n", m_Header->ThreadStateOffset);
    dprintf("ModuleCount:        %08lx\n", m_Header->ModuleCount);
    dprintf("ModuleOffset:       %08lx\n", m_Header->ModuleOffset);
    dprintf("DebugEventOffset:   %08lx\n", m_Header->DebugEventOffset);
    dprintf("VersionInfoOffset:  %08lx\n", m_Header->VersionInfoOffset);
    dprintf("\nVirtual Memory Description:\n");
    dprintf("MemoryRegionOffset: %08lx\n", m_Header->MemoryRegionOffset);
    dprintf("Number of regions:  %d\n", m_Header->MemoryRegionCount);

    dprintf("          FileOffset   Start Address   Length\n");

    ULONG j = 0;
    ULONG64 Offset = m_Header->DataOffset;
    BOOL Skip;

    while (j < m_Header->MemoryRegionCount)
    {
        Skip = FALSE;

        dprintf("      %12I64lx      %08lx       %08lx",
                 Offset,
                 m_Memory[j].BaseAddress,
                 m_Memory[j].RegionSize);

        if (m_Memory[j].Protect & PAGE_GUARD)
        {
            dprintf("   Guard Page");

            if (m_IgnoreGuardPages)
            {
                dprintf(" - Ignored");
                Skip = TRUE;
            }
        }

        if (!Skip)
        {
            Offset += m_Memory[j].RegionSize;
        }

        dprintf("\n");

        j += 1;
    }

    dprintf("Total memory:     %12I64x\n", Offset - m_Header->DataOffset);
}

ULONG64
UserFull32DumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                          PULONG File, PULONG Avail)
{
    ULONG i;
    ULONG Offset = 0;
    ULONG64 RetOffset = 0;

    *File = DUMP_INFO_DUMP;

    // Ignore the upper 32 bits to avoid getting
    // confused by sign extensions in pointer handling
    Virt &= 0xffffffff;

    __try
    {
        for (i = 0; i < m_Header->MemoryRegionCount; i++)
        {
            if (m_IgnoreGuardPages)
            {
                //
                // Guard pages get reported, but they are not written
                // out to the file
                //

                if (m_Memory[i].Protect & PAGE_GUARD)
                {
                    continue;
                }
            }

            if (Virt >= m_Memory[i].BaseAddress &&
                Virt < m_Memory[i].BaseAddress + m_Memory[i].RegionSize)
            {
                ULONG Frag = (ULONG)Virt - m_Memory[i].BaseAddress;
                *Avail = m_Memory[i].RegionSize - Frag;

                if (Virt == (g_DebugDump_VirtualAddress & 0xffffffff))
                {
                    g_NtDllCalls.DbgPrint("%X at offset %X\n",
                                          (ULONG)Virt,
                                          m_Header->DataOffset +
                                          Offset + Frag);
                }

                RetOffset = m_Header->DataOffset + Offset + Frag;
                break;
            }

            Offset += m_Memory[i].RegionSize;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        RetOffset = 0;
    }

    return RetOffset;
}

HRESULT
UserFull32DumpTargetInfo::GetThreadInfo(ULONG Index,
                                        PULONG Id, PULONG Suspend,
                                        PULONG64 Teb)
{
    if (Index >= m_ThreadCount)
    {
        return E_INVALIDARG;
    }

    CRASH_THREAD32 Thread;
    if (m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Header->ThreadStateOffset +
                       Index * sizeof(Thread),
                       &Thread, sizeof(Thread)) != sizeof(Thread))
    {
        return E_FAIL;
    }

    *Id = Thread.ThreadId;
    *Suspend = Thread.SuspendCount;
    *Teb = EXTEND64(Thread.Teb);

    return S_OK;
}

#define DBG_VERIFY_MOD 0

BOOL
UserFull32DumpTargetInfo::VerifyModules(void)
{
    CRASH_MODULE32   CrashModule;
    ULONG            i;
    IMAGE_DOS_HEADER DosHeader;
    ULONG            Read;
    BOOL             Succ = TRUE;
    ULONG            Offset;
    PSTR             Env;

    Env = getenv("DBGENG_VERIFY_MODULES");
    if (Env != NULL)
    {
        return atoi(Env) == m_IgnoreGuardPages;
    }

    Offset = m_Header->ModuleOffset;

#if DBG_VERIFY_MOD
    g_NtDllCalls.DbgPrint("Verify %d modules at offset %X\n",
                          m_Header->ModuleCount, Offset);
#endif

    for (i = 0; i < m_Header->ModuleCount; i++)
    {
        if (m_InfoFiles[DUMP_INFO_DUMP].
            ReadFileOffset(Offset, &CrashModule, sizeof(CrashModule)) !=
            sizeof(CrashModule))
        {
            return FALSE;
        }

#if DBG_VERIFY_MOD
        g_NtDllCalls.DbgPrint("Mod %d of %d offs %X, base %s, ",
                              i, m_Header->ModuleCount, Offset,
                              FormatAddr64(CrashModule.BaseOfImage));
        if (ReadVirtual(m_ProcessHead, CrashModule.BaseOfImage, &DosHeader,
                        sizeof(DosHeader), &Read) != S_OK ||
            Read != sizeof(DosHeader))
        {
            g_NtDllCalls.DbgPrint("unable to read header\n");
        }
        else
        {
            g_NtDllCalls.DbgPrint("magic %04X\n", DosHeader.e_magic);
        }
#endif

        //
        // It is not strictly a requirement that every image
        // begin with an MZ header, though all of our tools
        // today produce images like this.  Check for it
        // as a sanity check since it's so common nowadays.
        //

        if (ReadVirtual(NULL, CrashModule.BaseOfImage, &DosHeader,
                        sizeof(DosHeader), &Read) != S_OK ||
            Read != sizeof(DosHeader) ||
            DosHeader.e_magic != IMAGE_DOS_SIGNATURE)
        {
            Succ = FALSE;
            break;
        }

        Offset += sizeof(CrashModule) + CrashModule.ImageNameLength;
    }

#if DBG_VERIFY_MOD
    g_NtDllCalls.DbgPrint("VerifyModules returning %d, %d of %d mods\n",
                          Succ, i, m_Header->ModuleCount);
#endif

    return Succ;
}

HRESULT
UserFull64DumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Header = (PUSERMODE_CRASHDUMP_HEADER64)m_DumpBase;

    dprintf("User Dump File: Only application data is available\n\n");

    ULONG MajorVersion, MinorVersion;
    ULONG BuildNumber;
    ULONG PlatformId;
    HRESULT Status;

    MajorVersion = m_Header->MajorVersion;
    MinorVersion = m_Header->MinorVersion;

    if ((Status = GetBuildAndPlatform(m_Header->MachineImageType,
                                      &MajorVersion, &MinorVersion,
                                      &BuildNumber, &PlatformId)) != S_OK)
    {
        return Status;
    }

    if ((Status = InitSystemInfo(BuildNumber, 0,
                                 m_Header->MachineImageType, PlatformId,
                                 MajorVersion,
                                 MinorVersion & 0xffff)) != S_OK)
    {
        return Status;
    }

    // Dump does not contain this information.
    m_NumProcessors = 1;

    DEBUG_EVENT64 Event;

    if (m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Header->DebugEventOffset, &Event,
                       sizeof(Event)) != sizeof(Event))
    {
        ErrOut("Unable to read debug event at offset %I64x\n",
               m_Header->DebugEventOffset);
        return E_FAIL;
    }

    m_EventProcessId = Event.dwProcessId;
    m_EventProcessSymHandle =
        GloballyUniqueProcessHandle(this, Event.dwProcessId);
    m_EventThreadId = Event.dwThreadId;

    if (Event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        m_ExceptionRecord = Event.u.Exception.ExceptionRecord;
        m_ExceptionFirstChance = Event.u.Exception.dwFirstChance;
    }
    else
    {
        // Fake an exception.
        ZeroMemory(&m_ExceptionRecord, sizeof(m_ExceptionRecord));
        m_ExceptionRecord.ExceptionCode = STATUS_BREAKPOINT;
        m_ExceptionFirstChance = FALSE;
    }

    m_ThreadCount = m_Header->ThreadCount;

    m_Memory = (PMEMORY_BASIC_INFORMATION64)
        IndexByByte(m_Header, m_Header->MemoryRegionOffset);

    ULONG64 TotalMemory;
    ULONG i;

    VerbOut("  Memory regions: %d\n",
            m_Header->MemoryRegionCount);
    TotalMemory = 0;

    PMEMORY_BASIC_INFORMATION64 Mem = m_Memory;
    for (i = 0; i < m_Header->MemoryRegionCount; i++)
    {
        VerbOut("  %5d: %s - %s, prot %08X, type %08X\n",
                i, FormatAddr64(Mem->BaseAddress),
                FormatAddr64(Mem->BaseAddress + Mem->RegionSize - 1),
                Mem->Protect, Mem->Type);

        if ((Mem->Protect & PAGE_GUARD) ||
            (Mem->Protect & PAGE_NOACCESS) ||
            (Mem->State & MEM_FREE) ||
            (Mem->State & MEM_RESERVE))
        {
            VerbOut("       Region has data-less pages\n");
        }

        TotalMemory += Mem->RegionSize;
        Mem++;
    }

    VerbOut("  Total memory region size %s\n",
            FormatAddr64(TotalMemory));

    return UserDumpTargetInfo::Initialize();
}

HRESULT
UserFull64DumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                         PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "64-bit Full user dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
UserFull64DumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (VIRTUAL_THREAD_INDEX(Thread) >= m_Header->ThreadCount)
    {
        return E_INVALIDARG;
    }

    if (m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Header->ThreadOffset +
                       VIRTUAL_THREAD_INDEX(Thread) *
                       m_TypeInfo.SizeTargetContext,
                       Context,
                       m_TypeInfo.SizeTargetContext) ==
        m_TypeInfo.SizeTargetContext)
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

ModuleInfo*
UserFull64DumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    DBG_ASSERT(UserMode);
    // If this dump came from an NT system we'll just
    // use the system's loaded module list.  Otherwise
    // we'll use the dump's module list.
    return m_PlatformId == VER_PLATFORM_WIN32_NT ?
        (ModuleInfo*)&g_NtTargetUserModuleIterator :
        (ModuleInfo*)&g_UserFull64ModuleIterator;
}

HRESULT
UserFull64DumpTargetInfo::QueryMemoryRegion(ProcessInfo* Process,
                                            PULONG64 Handle,
                                            BOOL HandleIsOffset,
                                            PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;

    if (HandleIsOffset)
    {
        ULONG BestIndex;
        ULONG64 BestDiff;

        //
        // Emulate VirtualQueryEx and return the closest higher
        // region if a containing region isn't found.
        //

        BestIndex = 0xffffffff;
        BestDiff = (ULONG64)-1;
        for (Index = 0; Index < m_Header->MemoryRegionCount; Index++)
        {
            if (*Handle >= m_Memory[Index].BaseAddress)
            {
                if (*Handle < m_Memory[Index].BaseAddress +
                    m_Memory[Index].RegionSize)
                {
                    // Found a containing region, we're done.
                    BestIndex = Index;
                    break;
                }

                // Not containing and lower in memory, ignore.
            }
            else
            {
                // Check and see if this is a closer
                // region than what we've seen already.
                ULONG64 Diff = m_Memory[Index].BaseAddress - *Handle;
                if (Diff <= BestDiff)
                {
                    BestIndex = Index;
                    BestDiff = Diff;
                }
            }
        }

        if (BestIndex >= m_Header->MemoryRegionCount)
        {
            return E_NOINTERFACE;
        }

        Index = BestIndex;
    }
    else
    {
        Index = (ULONG)*Handle;
        if (Index >= m_Header->MemoryRegionCount)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
        }

        // 64-bit user dump support came into being after
        // guard pages were suppressed so they never contain them.
    }

    *Info = m_Memory[Index];
    *Handle = ++Index;

    return S_OK;
}

HRESULT
UserFull64DumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;
    PUSERMODE_CRASHDUMP_HEADER64 Header =
        (PUSERMODE_CRASHDUMP_HEADER64)m_DumpBase;

    __try
    {
        if (Header->Signature != USERMODE_CRASHDUMP_SIGNATURE ||
            Header->ValidDump != USERMODE_CRASHDUMP_VALID_DUMP64)
        {
            __leave;
        }

        //
        // Check for the presence of some basic things.
        //

        if (Header->ThreadCount == 0 ||
            Header->ModuleCount == 0 ||
            Header->MemoryRegionCount == 0)
        {
            ErrOut("Thread, module or memory region count is zero.\n"
                   "The dump file is probably corrupt.\n");
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        if (Header->ThreadOffset == 0 ||
            Header->ModuleOffset == 0 ||
            Header->DataOffset == 0 ||
            Header->MemoryRegionOffset == 0 ||
            Header->DebugEventOffset == 0 ||
            Header->ThreadStateOffset == 0)
        {
            ErrOut("A dump header data offset is zero.\n"
                   "The dump file is probably corrupt.\n");
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        // We don't want to have to call ReadFileOffset
        // every time we check memory ranges so just require
        // that the memory descriptors fit in the base view.
        *BaseMapSize = Header->MemoryRegionOffset +
            Header->MemoryRegionCount * sizeof(*m_Memory);

        m_Header = Header;
        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

void
UserFull64DumpTargetInfo::DumpDebug(void)
{
    dprintf("----- 64 bit User Full Dump Analysis\n\n");

    dprintf("MajorVersion:       %d\n", m_Header->MajorVersion);
    dprintf("MinorVersion:       %d (Build %d)\n",
            m_Header->MinorVersion & 0xffff,
            m_Header->MinorVersion >> 16);
    dprintf("MachineImageType:   %08lx\n", m_Header->MachineImageType);
    dprintf("ThreadCount:        %08lx\n", m_Header->ThreadCount);
    dprintf("ThreadOffset:       %12I64lx\n", m_Header->ThreadOffset);
    dprintf("ThreadStateOffset:  %12I64lx\n", m_Header->ThreadStateOffset);
    dprintf("ModuleCount:        %08lx\n", m_Header->ModuleCount);
    dprintf("ModuleOffset:       %12I64lx\n", m_Header->ModuleOffset);
    dprintf("DebugEventOffset:   %12I64lx\n", m_Header->DebugEventOffset);
    dprintf("VersionInfoOffset:  %12I64lx\n", m_Header->VersionInfoOffset);
    dprintf("\nVirtual Memory Description:\n");
    dprintf("MemoryRegionOffset: %12I64lx\n", m_Header->MemoryRegionOffset);
    dprintf("Number of regions:  %d\n", m_Header->MemoryRegionCount);

    dprintf("    FileOffset            Start Address"
            "             Length\n");

    ULONG j = 0;
    ULONG64 Offset = m_Header->DataOffset;

    while (j < m_Header->MemoryRegionCount)
    {
        dprintf("      %12I64lx      %s       %12I64x",
                Offset,
                FormatAddr64(m_Memory[j].BaseAddress),
                m_Memory[j].RegionSize);

        Offset += m_Memory[j].RegionSize;

        dprintf("\n");

        j += 1;
    }

    dprintf("Total memory:     %12I64x\n", Offset - m_Header->DataOffset);
}

ULONG64
UserFull64DumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                          PULONG File, PULONG Avail)
{
    ULONG i;
    ULONG64 Offset = 0;
    ULONG64 RetOffset = 0;

    *File = DUMP_INFO_DUMP;

    __try
    {
        for (i = 0; i < m_Header->MemoryRegionCount; i++)
        {
            //
            // Guard pages get reported, but they are not written
            // out to the file
            //

            if (m_Memory[i].Protect & PAGE_GUARD)
            {
                continue;
            }

            if (Virt >= m_Memory[i].BaseAddress &&
                Virt < m_Memory[i].BaseAddress + m_Memory[i].RegionSize)
            {
                ULONG64 Frag = Virt - m_Memory[i].BaseAddress;
                ULONG64 Avail64 = m_Memory[i].RegionSize - Frag;
                // It's extremely unlikely that there'll be a single
                // region greater than 4GB, but check anyway.  No
                // reads should ever require more than 4GB so just
                // indicate that 4GB is available.
                if (Avail64 > 0xffffffff)
                {
                    *Avail = 0xffffffff;
                }
                else
                {
                    *Avail = (ULONG)Avail64;
                }
                RetOffset = m_Header->DataOffset + Offset + Frag;
                break;
            }

            Offset += m_Memory[i].RegionSize;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        RetOffset = 0;
    }

    return RetOffset;
}

HRESULT
UserFull64DumpTargetInfo::GetThreadInfo(ULONG Index,
                                        PULONG Id, PULONG Suspend,
                                        PULONG64 Teb)
{
    if (Index >= m_ThreadCount)
    {
        return E_INVALIDARG;
    }

    CRASH_THREAD64 Thread;
    if (m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Header->ThreadStateOffset +
                       Index * sizeof(Thread),
                       &Thread, sizeof(Thread)) != sizeof(Thread))
    {
        return E_FAIL;
    }

    *Id = Thread.ThreadId;
    *Suspend = Thread.SuspendCount;
    *Teb = Thread.Teb;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// UserMiniDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserMiniDumpTargetInfo::Initialize(void)
{
    // Pick up any potentially modified base mapping pointer.
    m_Header = (PMINIDUMP_HEADER)m_DumpBase;
    // Clear pointers that have already been set so
    // that they get picked up again.
    m_SysInfo = NULL;

    if (m_Header->Flags & MiniDumpWithFullMemory)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_FULL_MEMORY;
    }
    if (m_Header->Flags & MiniDumpWithHandleData)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
    }
    if (m_Header->Flags & MiniDumpWithUnloadedModules)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES;
    }
    if (m_Header->Flags & MiniDumpWithIndirectlyReferencedMemory)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY;
    }
    if (m_Header->Flags & MiniDumpWithDataSegs)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS;
    }
    if (m_Header->Flags & MiniDumpFilterMemory)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY;
    }
    if (m_Header->Flags & MiniDumpFilterModulePaths)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_FILTER_PATHS;
    }
    if (m_Header->Flags & MiniDumpWithProcessThreadData)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA;
    }
    if (m_Header->Flags & MiniDumpWithPrivateReadWriteMemory)
    {
        m_FormatFlags |= DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY;
    }

    MINIDUMP_DIRECTORY UNALIGNED *Dir;
    MINIDUMP_MISC_INFO UNALIGNED *MiscPtr = NULL;
    ULONG i;
    ULONG Size;

    Dir = (MINIDUMP_DIRECTORY UNALIGNED *)
        IndexRva(m_Header, m_Header->StreamDirectoryRva,
                 m_Header->NumberOfStreams * sizeof(*Dir),
                 "Directory");
    if (Dir == NULL)
    {
        return HR_DATA_CORRUPT;
    }

    for (i = 0; i < m_Header->NumberOfStreams; i++)
    {
        switch(Dir->StreamType)
        {
        case ThreadListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Threads) == NULL)
            {
                break;
            }

            m_ActualThreadCount =
                ((MINIDUMP_THREAD_LIST UNALIGNED *)m_Threads)->NumberOfThreads;
            m_ThreadStructSize = sizeof(MINIDUMP_THREAD);
            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_THREAD_LIST) +
                sizeof(MINIDUMP_THREAD) * m_ActualThreadCount)
            {
                m_Threads = NULL;
                m_ActualThreadCount = 0;
            }
            else
            {
                // Move past count to actual thread data.
                m_Threads += sizeof(MINIDUMP_THREAD_LIST);
            }
            break;

        case ThreadExListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Threads) == NULL)
            {
                break;
            }

            m_ActualThreadCount =
                ((MINIDUMP_THREAD_EX_LIST UNALIGNED *)m_Threads)->
                NumberOfThreads;
            m_ThreadStructSize = sizeof(MINIDUMP_THREAD_EX);
            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_THREAD_EX_LIST) +
                sizeof(MINIDUMP_THREAD_EX) * m_ActualThreadCount)
            {
                m_Threads = NULL;
                m_ActualThreadCount = 0;
            }
            else
            {
                // Move past count to actual thread data.
                m_Threads += sizeof(MINIDUMP_THREAD_EX_LIST);
            }
            break;

        case ModuleListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Modules) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_MODULE_LIST) +
                sizeof(MINIDUMP_MODULE) * m_Modules->NumberOfModules)
            {
                m_Modules = NULL;
            }
            break;

        case UnloadedModuleListStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_UnlModules) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                m_UnlModules->SizeOfHeader +
                m_UnlModules->SizeOfEntry * m_UnlModules->NumberOfEntries)
            {
                m_UnlModules = NULL;
            }
            break;

        case MemoryListStream:
            if (m_Header->Flags & MiniDumpWithFullMemory)
            {
                ErrOut("Full memory minidumps can't have MemoryListStreams\n");
                return HR_DATA_CORRUPT;
            }

            if (IndexDirectory(i, Dir, (PVOID*)&m_Memory) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_MEMORY_LIST) +
                sizeof(MINIDUMP_MEMORY_DESCRIPTOR) *
                m_Memory->NumberOfMemoryRanges)
            {
                m_Memory = NULL;
            }
            break;

        case Memory64ListStream:
            if (!(m_Header->Flags & MiniDumpWithFullMemory))
            {
                ErrOut("Partial memory minidumps can't have "
                       "Memory64ListStreams\n");
                return HR_DATA_CORRUPT;
            }

            if (IndexDirectory(i, Dir, (PVOID*)&m_Memory64) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_MEMORY64_LIST) +
                sizeof(MINIDUMP_MEMORY_DESCRIPTOR64) *
                m_Memory64->NumberOfMemoryRanges)
            {
                m_Memory64 = NULL;
            }
            break;

        case ExceptionStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Exception) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                sizeof(MINIDUMP_EXCEPTION_STREAM))
            {
                m_Exception = NULL;
            }
            break;

        case SystemInfoStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_SysInfo) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize != sizeof(MINIDUMP_SYSTEM_INFO))
            {
                m_SysInfo = NULL;
            }
            break;

        case CommentStreamA:
            PSTR CommentA;

            CommentA = NULL;
            if (IndexDirectory(i, Dir, (PVOID*)&CommentA) == NULL)
            {
                break;
            }

            dprintf("Comment: '%s'\n", CommentA);
            break;

        case CommentStreamW:
            PWSTR CommentW;

            CommentW = NULL;
            if (IndexDirectory(i, Dir, (PVOID*)&CommentW) == NULL)
            {
                break;
            }

            dprintf("Comment: '%ls'\n", CommentW);
            break;

        case HandleDataStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_Handles) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize !=
                m_Handles->SizeOfHeader +
                m_Handles->SizeOfDescriptor *
                m_Handles->NumberOfDescriptors)
            {
                m_Handles = NULL;
            }
            break;

        case FunctionTableStream:
            if (IndexDirectory(i, Dir, (PVOID*)&m_FunctionTables) == NULL)
            {
                break;
            }

            // Don't bother walking every table to verify the size,
            // just do a simple minimum size check.
            if (Dir->Location.DataSize <
                m_FunctionTables->SizeOfHeader +
                m_FunctionTables->SizeOfDescriptor *
                m_FunctionTables->NumberOfDescriptors)
            {
                m_FunctionTables = NULL;
            }
            break;

        case MiscInfoStream:
            if (IndexDirectory(i, Dir, (PVOID*)&MiscPtr) == NULL)
            {
                break;
            }

            if (Dir->Location.DataSize < 2 * sizeof(ULONG32))
            {
                break;
            }

            // The dump keeps its own version of the struct
            // as a data member to avoid having to check pointers
            // and structure size.  Later references just check
            // flags, copy in what this dump has available.
            Size = sizeof(m_MiscInfo);
            if (Size > Dir->Location.DataSize)
            {
                Size = Dir->Location.DataSize;
            }
            CopyMemory(&m_MiscInfo, MiscPtr, Size);
            break;

        case UnusedStream:
            // Nothing to do.
            break;

        default:
            WarnOut("WARNING: Minidump contains unknown stream type 0x%x\n",
                    Dir->StreamType);
            break;
        }

        Dir++;
    }

    // This was already checked in Identify but check
    // again just in case something went wrong.
    if (m_SysInfo == NULL)
    {
        ErrOut("Unable to locate system info\n");
        return HR_DATA_CORRUPT;
    }

    HRESULT Status;

    if ((Status = InitSystemInfo(m_SysInfo->BuildNumber, 0,
                                 m_ImageType, m_SysInfo->PlatformId,
                                 m_SysInfo->MajorVersion,
                                 m_SysInfo->MinorVersion)) != S_OK)
    {
        return Status;
    }

    if (m_SysInfo->NumberOfProcessors)
    {
        m_NumProcessors = m_SysInfo->NumberOfProcessors;
    }
    else
    {
        // Dump does not contain this information.
        m_NumProcessors = 1;
    }

    if (m_SysInfo->CSDVersionRva != 0)
    {
        MINIDUMP_STRING UNALIGNED *CsdString = (MINIDUMP_STRING UNALIGNED *)
            IndexRva(m_Header,
                     m_SysInfo->CSDVersionRva, sizeof(*CsdString),
                     "CSD string");
        if (CsdString != NULL && CsdString->Length > 0)
        {
            WCHAR UNALIGNED *WideStr = CsdString->Buffer;
            ULONG WideLen = wcslen((PWSTR)WideStr);

            if (m_ActualSystemVersion > W9X_SVER_START &&
                m_ActualSystemVersion < W9X_SVER_END)
            {
                WCHAR UNALIGNED *Str;

                //
                // Win9x CSD strings are usually just a single
                // letter surrounded by whitespace, so clean them
                // up a little bit.
                //

                while (iswspace(*WideStr))
                {
                    WideStr++;
                }
                Str = WideStr;
                WideLen = 0;
                while (*Str && !iswspace(*Str))
                {
                    WideLen++;
                    Str++;
                }
            }

            sprintf(m_ServicePackString,
                    "%.*S", WideLen, WideStr);
        }
    }

    if (m_MiscInfo.Flags1 & MINIDUMP_MISC1_PROCESS_ID)
    {
        m_EventProcessId = m_MiscInfo.ProcessId;
    }
    else
    {
        // Some minidumps don't store the process ID.  Add the system ID
        // to the fake process ID base to keep each system's
        // fake processes separate from each other.
        m_EventProcessId = VIRTUAL_PROCESS_ID_BASE + m_UserId;
    }
    m_EventProcessSymHandle = VIRTUAL_PROCESS_HANDLE(m_EventProcessId);

    if (m_Exception != NULL)
    {
        m_EventThreadId = m_Exception->ThreadId;

        C_ASSERT(sizeof(m_Exception->ExceptionRecord) ==
                 sizeof(EXCEPTION_RECORD64));
        m_ExceptionRecord = *(EXCEPTION_RECORD64 UNALIGNED *)
            &m_Exception->ExceptionRecord;
    }
    else
    {
        m_EventThreadId = VIRTUAL_THREAD_ID(0);

        // Fake an exception.
        ZeroMemory(&m_ExceptionRecord, sizeof(m_ExceptionRecord));
        m_ExceptionRecord.ExceptionCode = STATUS_BREAKPOINT;
    }
    m_ExceptionFirstChance = FALSE;

    if (m_Threads != NULL)
    {
        m_ThreadCount = m_ActualThreadCount;

        if (m_Exception == NULL)
        {
            m_EventThreadId = IndexThreads(0)->ThreadId;
        }
    }
    else
    {
        m_ThreadCount = 1;
    }

    return UserDumpTargetInfo::Initialize();
}

void
UserMiniDumpTargetInfo::NearestDifferentlyValidOffsets(ULONG64 Offset,
                                                       PULONG64 NextOffset,
                                                       PULONG64 NextPage)
{
    return MapNearestDifferentlyValidOffsets(Offset, NextOffset, NextPage);
}

HRESULT
UserMiniDumpTargetInfo::ReadHandleData(
    IN ProcessInfo* Process,
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    if (m_Handles == NULL)
    {
        return E_FAIL;
    }

    MINIDUMP_HANDLE_DESCRIPTOR UNALIGNED *Desc;

    if (DataType != DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT)
    {
        PUCHAR RawDesc = (PUCHAR)m_Handles + m_Handles->SizeOfHeader;
        ULONG i;

        for (i = 0; i < m_Handles->NumberOfDescriptors; i++)
        {
            Desc = (MINIDUMP_HANDLE_DESCRIPTOR UNALIGNED *)RawDesc;
            if (Desc->Handle == Handle)
            {
                break;
            }

            RawDesc += m_Handles->SizeOfDescriptor;
        }

        if (i >= m_Handles->NumberOfDescriptors)
        {
            return E_NOINTERFACE;
        }
    }

    ULONG Used;
    RVA StrRva;
    BOOL WideStr = FALSE;

    switch(DataType)
    {
    case DEBUG_HANDLE_DATA_TYPE_BASIC:
        Used = sizeof(DEBUG_HANDLE_DATA_BASIC);
        if (Buffer == NULL)
        {
            break;
        }

        if (BufferSize < Used)
        {
            return E_INVALIDARG;
        }

        PDEBUG_HANDLE_DATA_BASIC Basic;

        Basic = (PDEBUG_HANDLE_DATA_BASIC)Buffer;
        Basic->TypeNameSize = Desc->TypeNameRva == 0 ? 0 :
            ((MINIDUMP_STRING UNALIGNED *)
             IndexByByte(m_Header, Desc->TypeNameRva))->
            Length / sizeof(WCHAR) + 1;
        Basic->ObjectNameSize = Desc->ObjectNameRva == 0 ? 0 :
            ((MINIDUMP_STRING UNALIGNED *)
             IndexByByte(m_Header, Desc->ObjectNameRva))->
            Length / sizeof(WCHAR) + 1;
        Basic->Attributes = Desc->Attributes;
        Basic->GrantedAccess = Desc->GrantedAccess;
        Basic->HandleCount = Desc->HandleCount;
        Basic->PointerCount = Desc->PointerCount;
        break;

    case DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE:
        WideStr = TRUE;
    case DEBUG_HANDLE_DATA_TYPE_TYPE_NAME:
        StrRva = Desc->TypeNameRva;
        break;

    case DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE:
        WideStr = TRUE;
    case DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME:
        StrRva = Desc->ObjectNameRva;
        break;

    case DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT:
        Used = sizeof(ULONG);
        if (Buffer == NULL)
        {
            break;
        }
        if (BufferSize < Used)
        {
            return E_INVALIDARG;
        }
        *(PULONG)Buffer = m_Handles->NumberOfDescriptors;
        break;
    }

    if (DataType == DEBUG_HANDLE_DATA_TYPE_TYPE_NAME ||
        DataType == DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE ||
        DataType == DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME ||
        DataType == DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE)
    {
        if (StrRva == 0)
        {
            Used = WideStr ? sizeof(WCHAR) : sizeof(CHAR);
            if (Buffer)
            {
                if (BufferSize < Used)
                {
                    return E_INVALIDARG;
                }

                if (WideStr)
                {
                    *(PWCHAR)Buffer = 0;
                }
                else
                {
                    *(PCHAR)Buffer = 0;
                }
            }
        }
        else
        {
            MINIDUMP_STRING UNALIGNED *Str = (MINIDUMP_STRING UNALIGNED *)
                IndexRva(m_Header, StrRva, sizeof(*Str), "Handle name string");
            if (Str == NULL)
            {
                return HR_DATA_CORRUPT;
            }

            if (WideStr)
            {
                Used = Str->Length + sizeof(WCHAR);
            }
            else
            {
                Used = Str->Length / sizeof(WCHAR) + 1;
            }

            if (Buffer)
            {
                if (WideStr)
                {
                    if (BufferSize < sizeof(WCHAR))
                    {
                        return E_INVALIDARG;
                    }
                    BufferSize /= sizeof(WCHAR);

                    // The string data may not be aligned, so
                    // check and handle both the aligned
                    // and unaligned cases.
                    if (!((ULONG_PTR)Str->Buffer & (sizeof(WCHAR) - 1)))
                    {
                        CopyStringW((PWSTR)Buffer, (PWSTR)Str->Buffer,
                                    BufferSize);
                    }
                    else
                    {
                        PUCHAR RawStr = (PUCHAR)Str->Buffer;
                        while (--BufferSize > 0 &&
                               (RawStr[0] || RawStr[1]))
                        {
                            *(PWCHAR)Buffer =
                                ((USHORT)RawStr[1] << 8) | RawStr[0];
                            Buffer = (PVOID)((PWCHAR)Buffer + 1);
                        }
                        *(PWCHAR)Buffer = 0;
                    }
                }
                else
                {
                    if (!WideCharToMultiByte(CP_ACP, 0,
                                             (LPCWSTR)Str->Buffer, -1,
                                             (LPSTR)Buffer, BufferSize,
                                             NULL, NULL))
                    {
                        return WIN32_LAST_STATUS();
                    }
                }
            }
        }
    }

    if (DataSize != NULL)
    {
        *DataSize = Used;
    }

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::GetProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    PSTR Unavail = "<unavailable>";

    // Allow any processor index as minidumps now
    // remember the number of processors so requests
    // may come in for processor indices other than zero.

    if (m_SysInfo == NULL)
    {
        return E_UNEXPECTED;
    }

    switch(m_SysInfo->ProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        Id->X86.Family = m_SysInfo->ProcessorLevel;
        Id->X86.Model = (m_SysInfo->ProcessorRevision >> 8) & 0xf;
        Id->X86.Stepping = m_SysInfo->ProcessorRevision & 0xf;

        if (m_SysInfo->Cpu.X86CpuInfo.VendorId[0])
        {
            memcpy(Id->X86.VendorString,
                   m_SysInfo->Cpu.X86CpuInfo.VendorId,
                   sizeof(m_SysInfo->Cpu.X86CpuInfo.VendorId));
        }
        else
        {
            DBG_ASSERT(strlen(Unavail) < DIMA(Id->X86.VendorString));
            strcpy(&(Id->X86.VendorString[0]), Unavail);
        }
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        Id->Ia64.Model = m_SysInfo->ProcessorLevel;
        Id->Ia64.Revision = m_SysInfo->ProcessorRevision;
        DBG_ASSERT(strlen(Unavail) < DIMA(Id->Ia64.VendorString));
        strcpy(&(Id->Ia64.VendorString[0]), Unavail);
        break;

    case PROCESSOR_ARCHITECTURE_AMD64:
        Id->Amd64.Family = m_SysInfo->ProcessorLevel;
        Id->Amd64.Model = (m_SysInfo->ProcessorRevision >> 8) & 0xf;
        Id->Amd64.Stepping = m_SysInfo->ProcessorRevision & 0xf;
        DBG_ASSERT(strlen(Unavail) < DIMA(Id->Amd64.VendorString));
        strcpy(&(Id->Amd64.VendorString[0]), Unavail);
        break;
    }

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::GetProcessorSpeed
    (ULONG Processor, PULONG Speed)
{
    return E_UNEXPECTED;
}

HRESULT
UserMiniDumpTargetInfo::GetGenericProcessorFeatures(
    ULONG Processor,
    PULONG64 Features,
    ULONG FeaturesSize,
    PULONG Used
    )
{
    // Allow any processor index as minidumps now
    // remember the number of processors so requests
    // may come in for processor indices other than zero.

    if (m_SysInfo == NULL)
    {
        return E_UNEXPECTED;
    }

    if (m_MachineType == IMAGE_FILE_MACHINE_I386)
    {
        // x86 stores only specific features.
        return E_NOINTERFACE;
    }

    *Used = DIMA(m_SysInfo->Cpu.OtherCpuInfo.ProcessorFeatures);
    if (FeaturesSize > *Used)
    {
        FeaturesSize = *Used;
    }
    memcpy(Features, m_SysInfo->Cpu.OtherCpuInfo.ProcessorFeatures,
           FeaturesSize * sizeof(*Features));

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::GetSpecificProcessorFeatures(
    ULONG Processor,
    PULONG64 Features,
    ULONG FeaturesSize,
    PULONG Used
    )
{
    // Allow any processor index as minidumps now
    // remember the number of processors so requests
    // may come in for processor indices other than zero.

    if (m_SysInfo == NULL)
    {
        return E_UNEXPECTED;
    }

    if (m_MachineType != IMAGE_FILE_MACHINE_I386)
    {
        // Only x86 stores specific features.
        return E_NOINTERFACE;
    }

    *Used = 2;
    if (FeaturesSize > 0)
    {
        *Features++ = m_SysInfo->Cpu.X86CpuInfo.VersionInformation;
        FeaturesSize--;
    }
    if (FeaturesSize > 0)
    {
        *Features++ = m_SysInfo->Cpu.X86CpuInfo.FeatureInformation;
        FeaturesSize--;
    }

    if (m_SysInfo->Cpu.X86CpuInfo.VendorId[0] == AMD_VENDOR_ID_EBX &&
        m_SysInfo->Cpu.X86CpuInfo.VendorId[1] == AMD_VENDOR_ID_EDX &&
        m_SysInfo->Cpu.X86CpuInfo.VendorId[2] == AMD_VENDOR_ID_EBX)
    {
        if (FeaturesSize > 0)
        {
            (*Used)++;
            *Features++ = m_SysInfo->Cpu.X86CpuInfo.AMDExtendedCpuFeatures;
            FeaturesSize--;
        }
    }

    return S_OK;
}

PVOID
UserMiniDumpTargetInfo::FindDynamicFunctionEntry(ProcessInfo* Process,
                                                 ULONG64 Address)
{
    if (m_FunctionTables == NULL)
    {
        return NULL;
    }

    PUCHAR StreamData =
        (PUCHAR)m_FunctionTables + m_FunctionTables->SizeOfHeader +
        m_FunctionTables->SizeOfAlignPad;
    ULONG TableIdx;

    for (TableIdx = 0;
         TableIdx < m_FunctionTables->NumberOfDescriptors;
         TableIdx++)
    {
        // Stream structure contents are guaranteed to be
        // properly aligned.
        PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR Desc =
            (PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR)StreamData;
        StreamData += m_FunctionTables->SizeOfDescriptor;

        PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable =
            (PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE)StreamData;
        StreamData += m_FunctionTables->SizeOfNativeDescriptor;

        PVOID TableData = (PVOID)StreamData;
        StreamData += Desc->EntryCount *
            m_FunctionTables->SizeOfFunctionEntry +
            Desc->SizeOfAlignPad;

        if (Address >= Desc->MinimumAddress && Address < Desc->MaximumAddress)
        {
            PVOID Entry = m_Machine->FindDynamicFunctionEntry
                (RawTable, Address, TableData,
                 Desc->EntryCount * m_FunctionTables->SizeOfFunctionEntry);
            if (Entry)
            {
                return Entry;
            }
        }
    }

    return NULL;
}

ULONG64
UserMiniDumpTargetInfo::GetDynamicFunctionTableBase(ProcessInfo* Process,
                                                    ULONG64 Address)
{
    if (m_FunctionTables == NULL)
    {
        return 0;
    }

    PUCHAR StreamData =
        (PUCHAR)m_FunctionTables + m_FunctionTables->SizeOfHeader +
        m_FunctionTables->SizeOfAlignPad;
    ULONG TableIdx;

    for (TableIdx = 0;
         TableIdx < m_FunctionTables->NumberOfDescriptors;
         TableIdx++)
    {
        // Stream structure contents are guaranteed to be
        // properly aligned.
        PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR Desc =
            (PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR)StreamData;
        StreamData +=
            m_FunctionTables->SizeOfDescriptor +
            m_FunctionTables->SizeOfNativeDescriptor +
            Desc->EntryCount * m_FunctionTables->SizeOfFunctionEntry +
            Desc->SizeOfAlignPad;

        if (Address >= Desc->MinimumAddress && Address < Desc->MaximumAddress)
        {
            return Desc->BaseAddress;
        }
    }

    return 0;
}

HRESULT
UserMiniDumpTargetInfo::EnumFunctionTables(IN ProcessInfo* Process,
                                           IN OUT PULONG64 Start,
                                           IN OUT PULONG64 Handle,
                                           OUT PULONG64 MinAddress,
                                           OUT PULONG64 MaxAddress,
                                           OUT PULONG64 BaseAddress,
                                           OUT PULONG EntryCount,
                                           OUT PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE RawTable,
                                           OUT PVOID* RawEntries)
{
    PUCHAR StreamData;

    if (!m_FunctionTables)
    {
        return S_FALSE;
    }

    if (*Start == 0)
    {
        StreamData = (PUCHAR)m_FunctionTables +
            m_FunctionTables->SizeOfHeader +
            m_FunctionTables->SizeOfAlignPad;
        *Start = (LONG_PTR)StreamData;
        *Handle = 0;
    }
    else
    {
        StreamData = (PUCHAR)(ULONG_PTR)*Start;
    }

    if (*Handle >= m_FunctionTables->NumberOfDescriptors)
    {
        return S_FALSE;
    }

    // Stream structure contents are guaranteed to be
    // properly aligned.
    PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR Desc =
        (PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR)StreamData;
    *MinAddress = Desc->MinimumAddress;
    *MaxAddress = Desc->MaximumAddress;
    *BaseAddress = Desc->BaseAddress;
    *EntryCount = Desc->EntryCount;
    StreamData += m_FunctionTables->SizeOfDescriptor;

    memcpy(RawTable, StreamData, m_FunctionTables->SizeOfNativeDescriptor);
    StreamData += m_FunctionTables->SizeOfNativeDescriptor;

    *RawEntries = malloc(Desc->EntryCount *
                         m_FunctionTables->SizeOfFunctionEntry);
    if (!*RawEntries)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*RawEntries, StreamData, Desc->EntryCount *
           m_FunctionTables->SizeOfFunctionEntry);

    StreamData += Desc->EntryCount *
        m_FunctionTables->SizeOfFunctionEntry +
        Desc->SizeOfAlignPad;
    *Start = (LONG_PTR)StreamData;
    (*Handle)++;

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::GetTargetContext(
    ULONG64 Thread,
    PVOID Context
    )
{
    if (m_Threads == NULL ||
        VIRTUAL_THREAD_INDEX(Thread) >= m_ActualThreadCount)
    {
        return E_INVALIDARG;
    }

    PVOID ContextData =
        IndexRva(m_Header,
                 IndexThreads(VIRTUAL_THREAD_INDEX(Thread))->ThreadContext.Rva,
                 m_TypeInfo.SizeTargetContext,
                 "Thread context data");
    if (ContextData == NULL)
    {
        return HR_DATA_CORRUPT;
    }

    memcpy(Context, ContextData, m_TypeInfo.SizeTargetContext);

    return S_OK;
}

HRESULT
UserMiniDumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status = E_NOINTERFACE;

    // m_Header must be set as other methods rely on it.
    m_Header = (PMINIDUMP_HEADER)m_DumpBase;

    __try
    {
        if (m_Header->Signature != MINIDUMP_SIGNATURE ||
            (m_Header->Version & 0xffff) != MINIDUMP_VERSION)
        {
            __leave;
        }

        MINIDUMP_DIRECTORY UNALIGNED *Dir;
        ULONG i;

        Dir = (MINIDUMP_DIRECTORY UNALIGNED *)
            IndexRva(m_Header, m_Header->StreamDirectoryRva,
                     m_Header->NumberOfStreams * sizeof(*Dir),
                     "Directory");
        if (Dir == NULL)
        {
            Status = HR_DATA_CORRUPT;
            __leave;
        }

        for (i = 0; i < m_Header->NumberOfStreams; i++)
        {
            switch(Dir->StreamType)
            {
            case SystemInfoStream:
                if (IndexDirectory(i, Dir, (PVOID*)&m_SysInfo) == NULL)
                {
                    break;
                }
                if (Dir->Location.DataSize != sizeof(MINIDUMP_SYSTEM_INFO))
                {
                    m_SysInfo = NULL;
                }
                break;
            case Memory64ListStream:
                MINIDUMP_MEMORY64_LIST Mem64;

                // The memory for the full memory list may not
                // fit within the initial mapping used at identify
                // time so do not directly index.  Instead, use
                // the adaptive read to get the data so we can
                // determine the data base.
                if (m_InfoFiles[DUMP_INFO_DUMP].
                    ReadFileOffset(Dir->Location.Rva,
                                   &Mem64, sizeof(Mem64)) == sizeof(Mem64) &&
                    Dir->Location.DataSize ==
                    sizeof(MINIDUMP_MEMORY64_LIST) +
                    sizeof(MINIDUMP_MEMORY_DESCRIPTOR64) *
                    Mem64.NumberOfMemoryRanges)
                {
                    m_Memory64DataBase = Mem64.BaseRva;
                }

                // Clear any cache entries that may have been
                // added by the above read so that only the
                // identify mapping is active.
                m_InfoFiles[DUMP_INFO_DUMP].EmptyCache();
                break;
            }

            Dir++;
        }

        if (m_SysInfo == NULL)
        {
            ErrOut("Minidump does not have system info\n");
            Status = E_FAIL;
            __leave;
        }

        m_ImageType = ProcArchToImageMachine(m_SysInfo->ProcessorArchitecture);
        if (m_ImageType == IMAGE_FILE_MACHINE_UNKNOWN)
        {
            ErrOut("Minidump has unrecognized processor architecture 0x%x\n",
                   m_SysInfo->ProcessorArchitecture);
            Status = E_FAIL;
            __leave;
        }

        // We rely on being able to directly access the entire
        // content of the dump through the default view so
        // ensure that it's possible.
        *BaseMapSize = m_InfoFiles[DUMP_INFO_DUMP].m_FileSize;

        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    if (Status != S_OK)
    {
        m_Header = NULL;
    }

    return Status;
}

ModuleInfo*
UserMiniDumpTargetInfo::GetModuleInfo(BOOL UserMode)
{
    DBG_ASSERT(UserMode);
    return &g_UserMiniModuleIterator;
}

HRESULT
UserMiniDumpTargetInfo::GetImageVersionInformation(ProcessInfo* Process,
                                                   PCSTR ImagePath,
                                                   ULONG64 ImageBase,
                                                   PCSTR Item,
                                                   PVOID Buffer,
                                                   ULONG BufferSize,
                                                   PULONG VerInfoSize)
{
    //
    // Find the image in the dump module list.
    //

    if (m_Modules == NULL)
    {
        return E_NOINTERFACE;
    }

    ULONG i;
    MINIDUMP_MODULE UNALIGNED *Mod = m_Modules->Modules;
    for (i = 0; i < m_Modules->NumberOfModules; i++)
    {
        if (ImageBase == Mod->BaseOfImage)
        {
            break;
        }

        Mod++;
    }

    if (i == m_Modules->NumberOfModules)
    {
        return E_NOINTERFACE;
    }

    PVOID Data = NULL;
    ULONG DataSize = 0;

    if (Item[0] == '\\' && Item[1] == 0)
    {
        Data = &Mod->VersionInfo;
        DataSize = sizeof(Mod->VersionInfo);
    }
    else
    {
        return E_INVALIDARG;
    }

    return FillDataBuffer(Data, DataSize, Buffer, BufferSize, VerInfoSize);
}

HRESULT
UserMiniDumpTargetInfo::GetExceptionContext(PCROSS_PLATFORM_CONTEXT Context)
{
    if (m_Exception != NULL)
    {
        PVOID ContextData;

        if (m_Exception->ThreadContext.DataSize <
            m_TypeInfo.SizeTargetContext ||
            (ContextData = IndexRva(m_Header,
                                    m_Exception->ThreadContext.Rva,
                                    m_TypeInfo.SizeTargetContext,
                                    "Exception context")) == NULL)
        {
            return E_FAIL;
        }

        memcpy(Context, ContextData,
               m_TypeInfo.SizeTargetContext);
        return S_OK;
    }
    else
    {
        ErrOut("Minidump doesn't have an exception context\n");
        return E_FAIL;
    }
}

ULONG64
UserMiniDumpTargetInfo::GetCurrentTimeDateN(void)
{
    return TimeDateStampToFileTime(m_Header->TimeDateStamp);
}

ULONG64
UserMiniDumpTargetInfo::GetProcessUpTimeN(ProcessInfo* Process)
{
    if (m_MiscInfo.Flags1 & MINIDUMP_MISC1_PROCESS_TIMES)
    {
        return TimeToFileTime(m_Header->TimeDateStamp -
                              m_MiscInfo.ProcessCreateTime);
    }
    else
    {
        return 0;
    }
}

HRESULT
UserMiniDumpTargetInfo::GetProcessTimes(ProcessInfo* Process,
                                        PULONG64 Create,
                                        PULONG64 Exit,
                                        PULONG64 Kernel,
                                        PULONG64 User)
{
    if (m_MiscInfo.Flags1 & MINIDUMP_MISC1_PROCESS_TIMES)
    {
        *Create = TimeDateStampToFileTime(m_MiscInfo.ProcessCreateTime);
        *Exit = 0;
        *Kernel = TimeToFileTime(m_MiscInfo.ProcessKernelTime);
        *User = TimeToFileTime(m_MiscInfo.ProcessUserTime);
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

HRESULT
UserMiniDumpTargetInfo::GetProductInfo(PULONG ProductType, PULONG SuiteMask)
{
    if (m_SysInfo->ProductType != INVALID_PRODUCT_TYPE)
    {
        *ProductType = m_SysInfo->ProductType;
        *SuiteMask = m_SysInfo->SuiteMask;
        return S_OK;
    }
    else
    {
        return TargetInfo::GetProductInfo(ProductType, SuiteMask);
    }
}

HRESULT
UserMiniDumpTargetInfo::GetThreadInfo(ULONG Index,
                                      PULONG Id, PULONG Suspend, PULONG64 Teb)
{
    if (m_Threads == NULL || Index >= m_ActualThreadCount)
    {
        return E_INVALIDARG;
    }

    MINIDUMP_THREAD_EX UNALIGNED *Thread = IndexThreads(Index);
    *Id = Thread->ThreadId;
    *Suspend = Thread->SuspendCount;
    *Teb = Thread->Teb;

    return S_OK;
}

PSTR g_MiniStreamNames[] =
{
    "UnusedStream", "ReservedStream0", "ReservedStream1", "ThreadListStream",
    "ModuleListStream", "MemoryListStream", "ExceptionStream",
    "SystemInfoStream", "ThreadExListStream", "Memory64ListStream",
    "CommentStreamA", "CommentStreamW", "HandleDataStream",
    "FunctionTableStream", "UnloadedModuleListStream", "MiscInfoStream",
};

PSTR
MiniStreamTypeName(ULONG32 Type)
{
    if (Type < sizeof(g_MiniStreamNames) / sizeof(g_MiniStreamNames[0]))
    {
        return g_MiniStreamNames[Type];
    }
    else
    {
        return "???";
    }
}

PVOID
UserMiniDumpTargetInfo::IndexDirectory(ULONG Index,
                                       MINIDUMP_DIRECTORY UNALIGNED *Dir,
                                       PVOID* Store)
{
    if (*Store != NULL)
    {
        WarnOut("WARNING: Ignoring extra %s stream, dir entry %d\n",
                MiniStreamTypeName(Dir->StreamType), Index);
        return NULL;
    }

    char Msg[128];

    sprintf(Msg, "Dir entry %d, %s stream",
            Index, MiniStreamTypeName(Dir->StreamType));

    PVOID Ptr = IndexRva(m_Header,
                         Dir->Location.Rva, Dir->Location.DataSize, Msg);
    if (Ptr != NULL)
    {
        *Store = Ptr;
    }
    return Ptr;
}

void
UserMiniDumpTargetInfo::DumpDebug(void)
{
    ULONG i;

    dprintf("----- User Mini Dump Analysis\n");

    dprintf("\nMINIDUMP_HEADER:\n");
    dprintf("Version         %X (%X)\n",
            m_Header->Version & 0xffff, m_Header->Version >> 16);
    dprintf("NumberOfStreams %d\n", m_Header->NumberOfStreams);
    if (m_Header->CheckSum)
    {
        dprintf("Failure flags:  %X\n", m_Header->CheckSum);
    }
    dprintf("Flags           %X\n", m_Header->Flags);

    MINIDUMP_DIRECTORY UNALIGNED *Dir;

    dprintf("\nStreams:\n");
    Dir = (MINIDUMP_DIRECTORY UNALIGNED *)
        IndexRva(m_Header, m_Header->StreamDirectoryRva,
                 m_Header->NumberOfStreams * sizeof(*Dir),
                 "Directory");
    if (Dir == NULL)
    {
        return;
    }

    PVOID Data;

    for (i = 0; i < m_Header->NumberOfStreams; i++)
    {
        dprintf("Stream %d: type %s (%d), size %08X, RVA %08X\n",
                i, MiniStreamTypeName(Dir->StreamType), Dir->StreamType,
                Dir->Location.DataSize, Dir->Location.Rva);

        Data = NULL;
        if (IndexDirectory(i, Dir, &Data) == NULL)
        {
            continue;
        }

        ULONG j;
        RVA Rva;
        WCHAR StrBuf[MAX_PATH];

        Rva = Dir->Location.Rva;

        switch(Dir->StreamType)
        {
        case ModuleListStream:
        {
            MINIDUMP_MODULE_LIST UNALIGNED *ModList;
            MINIDUMP_MODULE UNALIGNED *Mod;

            ModList = (MINIDUMP_MODULE_LIST UNALIGNED *)Data;
            Mod = ModList->Modules;
            dprintf("  %d modules\n", ModList->NumberOfModules);
            Rva += FIELD_OFFSET(MINIDUMP_MODULE_LIST, Modules);
            for (j = 0; j < ModList->NumberOfModules; j++)
            {
                PVOID Str = IndexRva(m_Header, Mod->ModuleNameRva,
                                     sizeof(MINIDUMP_STRING),
                                     "Module entry name");

                // The Unicode string text may not be aligned,
                // so copy it to an alignment-friendly buffer.
                if (Str)
                {
                    memcpy(StrBuf, ((MINIDUMP_STRING UNALIGNED *)Str)->Buffer,
                           sizeof(StrBuf));
                    StrBuf[DIMA(StrBuf) - 1] = 0;
                }
                else
                {
                    wcscpy(StrBuf, L"** Invalid **");
                }
                
                dprintf("  RVA %08X, %s - %s: '%S'\n",
                        Rva,
                        FormatAddr64(Mod->BaseOfImage),
                        FormatAddr64(Mod->BaseOfImage + Mod->SizeOfImage),
                        StrBuf);
                Mod++;
                Rva += sizeof(*Mod);
            }
            break;
        }

        case UnloadedModuleListStream:
        {
            MINIDUMP_UNLOADED_MODULE_LIST UNALIGNED *UnlModList;

            UnlModList = (MINIDUMP_UNLOADED_MODULE_LIST UNALIGNED *)Data;
            dprintf("  %d unloaded modules\n", UnlModList->NumberOfEntries);
            Rva += UnlModList->SizeOfHeader;
            for (j = 0; j < UnlModList->NumberOfEntries; j++)
            {
                MINIDUMP_UNLOADED_MODULE UNALIGNED *UnlMod =
                    (MINIDUMP_UNLOADED_MODULE UNALIGNED *)
                    IndexRva(m_Header, Rva, sizeof(MINIDUMP_UNLOADED_MODULE),
                             "Unloaded module entry");
                if (!UnlMod)
                {
                    break;
                }
                PVOID Str = IndexRva(m_Header, UnlMod->ModuleNameRva,
                                     sizeof(MINIDUMP_STRING),
                                     "Unloaded module entry name");

                // The Unicode string text may not be aligned,
                // so copy it to an alignment-friendly buffer.
                if (Str)
                {
                    memcpy(StrBuf, ((MINIDUMP_STRING UNALIGNED *)Str)->Buffer,
                           sizeof(StrBuf));
                    StrBuf[DIMA(StrBuf) - 1] = 0;
                }
                else
                {
                    wcscpy(StrBuf, L"** Invalid **");
                }
                
                dprintf("  RVA %08X, %s - %s: '%S'\n",
                        Rva,
                        FormatAddr64(UnlMod->BaseOfImage),
                        FormatAddr64(UnlMod->BaseOfImage +
                                     UnlMod->SizeOfImage),
                        StrBuf);
                Rva += UnlModList->SizeOfEntry;
            }
            break;
        }

        case MemoryListStream:
            {
            MINIDUMP_MEMORY_LIST UNALIGNED *MemList;
            ULONG64 Total = 0;

            MemList = (MINIDUMP_MEMORY_LIST UNALIGNED *)Data;
            dprintf("  %d memory ranges\n", MemList->NumberOfMemoryRanges);
            dprintf("  range#    Address      %sSize\n",
                    m_Machine->m_Ptr64 ? "       " : "");
            for (j = 0; j < MemList->NumberOfMemoryRanges; j++)
            {
                dprintf("    %4d    %s   %s\n",
                        j,
                        FormatAddr64(MemList->MemoryRanges[j].StartOfMemoryRange),
                        FormatAddr64(MemList->MemoryRanges[j].Memory.DataSize));
                Total += MemList->MemoryRanges[j].Memory.DataSize;
            }
            dprintf("  Total memory: %I64x\n", Total);
            break;
            }

        case Memory64ListStream:
            {
            MINIDUMP_MEMORY64_LIST UNALIGNED *MemList;
            ULONG64 Total = 0;

            MemList = (MINIDUMP_MEMORY64_LIST UNALIGNED *)Data;
            dprintf("  %d memory ranges\n", MemList->NumberOfMemoryRanges);
            dprintf("  RVA 0x%X BaseRva\n", (ULONG)(MemList->BaseRva));
            dprintf("  range#   Address      %sSize\n",
                    m_Machine->m_Ptr64 ? "       " : "");
            for (j = 0; j < MemList->NumberOfMemoryRanges; j++)
            {
                dprintf("    %4d  %s %s\n",
                        j,
                        FormatAddr64(MemList->MemoryRanges[j].StartOfMemoryRange),
                        FormatAddr64(MemList->MemoryRanges[j].DataSize));
                Total += MemList->MemoryRanges[j].DataSize;
            }
            dprintf("  Total memory: %I64x\n", Total);
            break;
            }

        case CommentStreamA:
            dprintf("  '%s'\n", Data);
            break;

        case CommentStreamW:
            dprintf("  '%ls'\n", Data);
            break;
        }

        Dir++;
    }
}

//----------------------------------------------------------------------------
//
// UserMiniPartialDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserMiniPartialDumpTargetInfo::Initialize(void)
{
    HRESULT Status;

    dprintf("User Mini Dump File: Only registers, stack and portions of "
            "memory are available\n\n");

    if ((Status = UserMiniDumpTargetInfo::Initialize()) != S_OK)
    {
        return Status;
    }

    if (m_Memory != NULL)
    {
        //
        // Map every piece of memory in the dump.  This makes
        // ReadVirtual very simple and there shouldn't be that
        // many ranges so it doesn't require that many map regions.
        //

        MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *Mem;
        ULONG i;
        ULONG64 TotalMemory;

        Mem = m_Memory->MemoryRanges;
        for (i = 0; i < m_Memory->NumberOfMemoryRanges; i++)
        {
            PVOID Data = IndexRva(m_Header,
                                  Mem->Memory.Rva, Mem->Memory.DataSize,
                                  "Memory range data");
            if (Data == NULL)
            {
                return HR_DATA_CORRUPT;
            }
            if ((Status = m_DataMemMap.
                 AddRegion(Mem->StartOfMemoryRange,
                           Mem->Memory.DataSize, Data,
                           NULL, FALSE)) != S_OK)
            {
                return Status;
            }

            Mem++;
        }

        VerbOut("  Memory regions: %d\n",
                m_Memory->NumberOfMemoryRanges);
        Mem = m_Memory->MemoryRanges;
        TotalMemory = 0;
        for (i = 0; i < m_Memory->NumberOfMemoryRanges; i++)
        {
            VerbOut("  %5d: %s - %s\n",
                    i, FormatAddr64(Mem->StartOfMemoryRange),
                    FormatAddr64(Mem->StartOfMemoryRange +
                                 Mem->Memory.DataSize - 1));
            TotalMemory += Mem->Memory.DataSize;
            Mem++;
        }
        VerbOut("  Total memory region size %s\n",
                FormatAddr64(TotalMemory));
    }

    return S_OK;
}

HRESULT
UserMiniPartialDumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                              PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "User mini dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
UserMiniPartialDumpTargetInfo::ReadVirtual(
    IN ProcessInfo* Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    return MapReadVirtual(Process, Offset, Buffer, BufferSize, BytesRead);
}

HRESULT
UserMiniPartialDumpTargetInfo::QueryMemoryRegion
    (ProcessInfo* Process,
     PULONG64 Handle,
     BOOL HandleIsOffset,
     PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;
    MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *Mem;

    if (HandleIsOffset)
    {
        if (m_Memory == NULL)
        {
            return E_NOINTERFACE;
        }

        MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *BestMem;
        ULONG64 BestDiff;

        //
        // Emulate VirtualQueryEx and return the closest higher
        // region if a containing region isn't found.
        //

        BestMem = NULL;
        BestDiff = (ULONG64)-1;
        Mem = m_Memory->MemoryRanges;
        for (Index = 0; Index < m_Memory->NumberOfMemoryRanges; Index++)
        {
            if (*Handle >= Mem->StartOfMemoryRange)
            {
                if (*Handle < Mem->StartOfMemoryRange + Mem->Memory.DataSize)
                {
                    // Found a containing region, we're done.
                    BestMem = Mem;
                    break;
                }

                // Not containing and lower in memory, ignore.
            }
            else
            {
                // Check and see if this is a closer
                // region than what we've seen already.
                ULONG64 Diff = Mem->StartOfMemoryRange - *Handle;
                if (Diff <= BestDiff)
                {
                    BestMem = Mem;
                    BestDiff = Diff;
                }
            }

            Mem++;
        }

        if (!BestMem)
        {
            return E_NOINTERFACE;
        }

        Mem = BestMem;
    }
    else
    {
        Index = (ULONG)*Handle;
        if (m_Memory == NULL || Index >= m_Memory->NumberOfMemoryRanges)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
        }

        Mem = m_Memory->MemoryRanges + Index;
    }

    Info->BaseAddress = Mem->StartOfMemoryRange;
    Info->AllocationBase = Mem->StartOfMemoryRange;
    Info->AllocationProtect = PAGE_READWRITE;
    Info->__alignment1 = 0;
    Info->RegionSize = Mem->Memory.DataSize;
    Info->State = MEM_COMMIT;
    Info->Protect = PAGE_READWRITE;
    Info->Type = MEM_PRIVATE;
    Info->__alignment2 = 0;
    *Handle = ++Index;

    return S_OK;
}

UnloadedModuleInfo*
UserMiniPartialDumpTargetInfo::GetUnloadedModuleInfo(void)
{
    return &g_UserMiniUnloadedModuleIterator;
}

HRESULT
UserMiniPartialDumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status;

    if ((Status = UserMiniDumpTargetInfo::IdentifyDump(BaseMapSize)) != S_OK)
    {
        return Status;
    }

    __try
    {
        if (m_Header->Flags & MiniDumpWithFullMemory)
        {
            m_Header = NULL;
            m_SysInfo = NULL;
            Status = E_NOINTERFACE;
        }
        else
        {
            Status = S_OK;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ULONG64
UserMiniPartialDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                               PULONG File, PULONG Avail)
{
    *File = DUMP_INFO_DUMP;

    if (m_Memory == NULL)
    {
        return 0;
    }

    MINIDUMP_MEMORY_DESCRIPTOR UNALIGNED *Mem = m_Memory->MemoryRanges;
    ULONG i;
    ULONG64 RetOffset = 0;

    __try
    {
        for (i = 0; i < m_Memory->NumberOfMemoryRanges; i++)
        {
            if (Virt >= Mem->StartOfMemoryRange &&
                Virt < Mem->StartOfMemoryRange + Mem->Memory.DataSize)
            {
                ULONG Frag = (ULONG)(Virt - Mem->StartOfMemoryRange);
                *Avail = Mem->Memory.DataSize - Frag;
                RetOffset = Mem->Memory.Rva + Frag;
                break;
            }

            Mem++;
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        RetOffset = 0;
    }

    return RetOffset;
}

//----------------------------------------------------------------------------
//
// UserMiniFullDumpTargetInfo.
//
//----------------------------------------------------------------------------

HRESULT
UserMiniFullDumpTargetInfo::Initialize(void)
{
    HRESULT Status;

    dprintf("User Mini Dump File with Full Memory: Only application "
            "data is available\n\n");

    if ((Status = UserMiniDumpTargetInfo::Initialize()) != S_OK)
    {
        return Status;
    }

    if (m_Memory64 != NULL)
    {
        ULONG64 TotalMemory;
        ULONG i;
        MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *Mem;

        VerbOut("  Memory regions: %d\n",
                m_Memory64->NumberOfMemoryRanges);
        Mem = m_Memory64->MemoryRanges;
        TotalMemory = 0;
        for (i = 0; i < m_Memory64->NumberOfMemoryRanges; i++)
        {
            VerbOut("  %5d: %s - %s\n",
                    i, FormatAddr64(Mem->StartOfMemoryRange),
                    FormatAddr64(Mem->StartOfMemoryRange +
                                 Mem->DataSize - 1));
            TotalMemory += Mem->DataSize;
            Mem++;
        }
        VerbOut("  Total memory region size %s\n",
                FormatAddr64(TotalMemory));

        if (TotalMemory + m_Memory64->BaseRva >
            m_InfoFiles[DUMP_INFO_DUMP].m_FileSize)
        {
            WarnOut("****************************************"
                    "********************\n");
            WarnOut("WARNING: Dump file has been truncated.  "
                    "Data may be missing.\n");
            WarnOut("****************************************"
                    "********************\n\n");
        }
    }

    return S_OK;
}

HRESULT
UserMiniFullDumpTargetInfo::GetDescription(PSTR Buffer, ULONG BufferLen,
                                           PULONG DescLen)
{
    HRESULT Status;

    Status = AppendToStringBuffer(S_OK, "Full memory user mini dump: ", TRUE,
                                  &Buffer, &BufferLen, DescLen);
    return AppendToStringBuffer(Status,
                                m_InfoFiles[DUMP_INFO_DUMP].m_FileNameA,
                                FALSE, &Buffer, &BufferLen, DescLen);
}

HRESULT
UserMiniFullDumpTargetInfo::QueryMemoryRegion
    (ProcessInfo* Process,
     PULONG64 Handle,
     BOOL HandleIsOffset,
     PMEMORY_BASIC_INFORMATION64 Info)
{
    ULONG Index;
    MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *Mem;

    if (HandleIsOffset)
    {
        if (m_Memory64 == NULL)
        {
            return E_NOINTERFACE;
        }

        MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *BestMem;
        ULONG64 BestDiff;

        //
        // Emulate VirtualQueryEx and return the closest higher
        // region if a containing region isn't found.
        //

        BestMem = NULL;
        BestDiff = (ULONG64)-1;
        Mem = m_Memory64->MemoryRanges;

        if (m_Machine->m_Ptr64)
        {
            for (Index = 0; Index < m_Memory64->NumberOfMemoryRanges; Index++)
            {
                if (*Handle >= Mem->StartOfMemoryRange)
                {
                    if (*Handle < Mem->StartOfMemoryRange + Mem->DataSize)
                    {
                        // Found a containing region, we're done.
                        BestMem = Mem;
                        break;
                    }

                    // Not containing and lower in memory, ignore.
                }
                else
                {
                    // Check and see if this is a closer
                    // region than what we've seen already.
                    ULONG64 Diff = Mem->StartOfMemoryRange - *Handle;
                    if (Diff <= BestDiff)
                    {
                        BestMem = Mem;
                        BestDiff = Diff;
                    }
                }

                Mem++;
            }
        }
        else
        {
            ULONG64 Check;

            //
            // Ignore any sign extension on a 32-bit dump.
            //

            Check = (ULONG)*Handle;
            for (Index = 0; Index < m_Memory64->NumberOfMemoryRanges; Index++)
            {
                if (Check >= (ULONG)Mem->StartOfMemoryRange)
                {
                    if (Check < (ULONG)
                        (Mem->StartOfMemoryRange + Mem->DataSize))
                    {
                        // Found a containing region, we're done.
                        BestMem = Mem;
                        break;
                    }

                    // Not containing and lower in memory, ignore.
                }
                else
                {
                    // Check and see if this is a closer
                    // region than what we've seen already.
                    ULONG64 Diff = (ULONG)Mem->StartOfMemoryRange - Check;
                    if (Diff <= BestDiff)
                    {
                        BestMem = Mem;
                        BestDiff = Diff;
                    }
                }

                Mem++;
            }
        }

        if (!BestMem)
        {
            return E_NOINTERFACE;
        }

        Mem = BestMem;
    }
    else
    {
        Index = (ULONG)*Handle;
        if (m_Memory64 == NULL || Index >= m_Memory64->NumberOfMemoryRanges)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
        }

        Mem = m_Memory64->MemoryRanges + Index;
    }

    Info->BaseAddress = Mem->StartOfMemoryRange;
    Info->AllocationBase = Mem->StartOfMemoryRange;
    Info->AllocationProtect = PAGE_READWRITE;
    Info->__alignment1 = 0;
    Info->RegionSize = Mem->DataSize;
    Info->State = MEM_COMMIT;
    Info->Protect = PAGE_READWRITE;
    Info->Type = MEM_PRIVATE;
    Info->__alignment2 = 0;
    *Handle = ++Index;

    return S_OK;
}

UnloadedModuleInfo*
UserMiniFullDumpTargetInfo::GetUnloadedModuleInfo(void)
{
    // As this is a full-memory dump we may have unloaded module
    // information in the memory itself.  If we don't have
    // an official unloaded module stream, try to get it from memory.
    if (m_UnlModules)
    {
        return &g_UserMiniUnloadedModuleIterator;
    }
    else if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        return &g_NtUserUnloadedModuleIterator;
    }
    else
    {
        return NULL;
    }
}

HRESULT
UserMiniFullDumpTargetInfo::IdentifyDump(PULONG64 BaseMapSize)
{
    HRESULT Status;

    if ((Status = UserMiniDumpTargetInfo::IdentifyDump(BaseMapSize)) != S_OK)
    {
        return Status;
    }

    __try
    {
        if (!(m_Header->Flags & MiniDumpWithFullMemory))
        {
            m_Header = NULL;
            m_SysInfo = NULL;
            Status = E_NOINTERFACE;
            __leave;
        }
        if (m_Memory64DataBase == 0)
        {
            ErrOut("Full-memory minidump must have a Memory64ListStream\n");
            Status = E_FAIL;
            __leave;
        }

        // In the case of a full memory minidump we don't
        // want to map the entire dump as it can be very large.
        // Fortunately, we are guaranteed that all of the raw
        // memory data in a full memory minidump will be at the
        // end of the dump, so we can just map the dump up
        // to the memory content and stop.
        *BaseMapSize = m_Memory64DataBase;

        Status = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = DumpIdentifyStatus(GetExceptionCode());
    }

    return Status;
}

ULONG64
UserMiniFullDumpTargetInfo::VirtualToOffset(ULONG64 Virt,
                                            PULONG File, PULONG Avail)
{
    *File = DUMP_INFO_DUMP;

    if (m_Memory64 == NULL)
    {
        return 0;
    }

    MINIDUMP_MEMORY_DESCRIPTOR64 UNALIGNED *Mem = m_Memory64->MemoryRanges;
    ULONG i;
    ULONG64 Offset = m_Memory64->BaseRva;
    ULONG64 RetOffset = 0;

    __try
    {
        if (m_Machine->m_Ptr64)
        {
            for (i = 0; i < m_Memory64->NumberOfMemoryRanges; i++)
            {
                if (Virt >= Mem->StartOfMemoryRange &&
                    Virt < Mem->StartOfMemoryRange + Mem->DataSize)
                {
                    ULONG64 Frag = Virt - Mem->StartOfMemoryRange;
                    ULONG64 Avail64 = Mem->DataSize - Frag;
                    if (Avail64 > 0xffffffff)
                    {
                        *Avail = 0xffffffff;
                    }
                    else
                    {
                        *Avail = (ULONG)Avail64;
                    }
                    RetOffset = Offset + Frag;
                    break;
                }

                Offset += Mem->DataSize;
                Mem++;
            }
        }
        else
        {
            //
            // Ignore any sign extension on a 32-bit dump.
            //

            Virt = (ULONG)Virt;
            for (i = 0; i < m_Memory64->NumberOfMemoryRanges; i++)
            {
                if (Virt >= (ULONG)Mem->StartOfMemoryRange &&
                    Virt < (ULONG)(Mem->StartOfMemoryRange + Mem->DataSize))
                {
                    ULONG64 Frag = Virt - (ULONG)Mem->StartOfMemoryRange;
                    ULONG64 Avail64 = Mem->DataSize - Frag;
                    if (Avail64 > 0xffffffff)
                    {
                        *Avail = 0xffffffff;
                    }
                    else
                    {
                        *Avail = (ULONG)Avail64;
                    }
                    RetOffset = Offset + Frag;
                    break;
                }

                Offset += Mem->DataSize;
                Mem++;
            }
        }
    }
    __except(MappingExceptionFilter(GetExceptionInformation()))
    {
        RetOffset = 0;
    }

    return RetOffset;
}

//----------------------------------------------------------------------------
//
// ModuleInfo implementations.
//
//----------------------------------------------------------------------------

HRESULT
KernelTriage32ModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (KernelTriage32DumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Dump->Triage.DriverListOffset != 0)
    {
        m_Count = m_DumpTarget->m_Dump->Triage.DriverCount;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage32ModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Count)
    {
        return S_FALSE;
    }

    PDUMP_DRIVER_ENTRY32 DriverEntry;
    PDUMP_STRING DriverName;

    DBG_ASSERT(m_DumpTarget->m_Dump->Triage.DriverListOffset != 0);

    DriverEntry = (PDUMP_DRIVER_ENTRY32)
        m_DumpTarget->IndexRva(m_DumpTarget->m_Dump, (RVA)
                               (m_DumpTarget->m_Dump->Triage.DriverListOffset +
                                m_Cur * sizeof(*DriverEntry)),
                               sizeof(*DriverEntry), "Driver entry");
    if (DriverEntry == NULL)
    {
        return HR_DATA_CORRUPT;
    }
    DriverName = (PDUMP_STRING)
        m_DumpTarget->IndexRva(m_DumpTarget->m_Dump,
                               DriverEntry->DriverNameOffset,
                               sizeof(*DriverName), "Driver entry name");
    if (DriverName == NULL)
    {
        Entry->NamePtr = NULL;
        Entry->NameLength = 0;
    }
    else
    {
        Entry->NamePtr = (PSTR)DriverName->Buffer;
        Entry->UnicodeNamePtr = 1;
        Entry->NameLength = DriverName->Length * sizeof(WCHAR);
    }
    Entry->Base = EXTEND64(DriverEntry->LdrEntry.DllBase);
    Entry->Size = DriverEntry->LdrEntry.SizeOfImage;
    Entry->ImageInfoValid = TRUE;
    Entry->CheckSum = DriverEntry->LdrEntry.CheckSum;
    Entry->TimeDateStamp = DriverEntry->LdrEntry.TimeDateStamp;

    m_Cur++;
    return S_OK;
}

KernelTriage32ModuleInfo g_KernelTriage32ModuleIterator;

HRESULT
KernelTriage64ModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (KernelTriage64DumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Dump->Triage.DriverListOffset != 0)
    {
        m_Count = m_DumpTarget->m_Dump->Triage.DriverCount;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage64ModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Count)
    {
        return S_FALSE;
    }

    PDUMP_DRIVER_ENTRY64 DriverEntry;
    PDUMP_STRING DriverName;

    DBG_ASSERT(m_DumpTarget->m_Dump->Triage.DriverListOffset != 0);

    DriverEntry = (PDUMP_DRIVER_ENTRY64)
        m_DumpTarget->IndexRva(m_DumpTarget->m_Dump, (RVA)
                               (m_DumpTarget->m_Dump->Triage.DriverListOffset +
                                m_Cur * sizeof(*DriverEntry)),
                               sizeof(*DriverEntry), "Driver entry");
    if (DriverEntry == NULL)
    {
        return HR_DATA_CORRUPT;
    }
    DriverName = (PDUMP_STRING)
        m_DumpTarget->IndexRva(m_DumpTarget->m_Dump,
                               DriverEntry->DriverNameOffset,
                               sizeof(*DriverName), "Driver entry name");
    if (DriverName == NULL)
    {
        Entry->NamePtr = NULL;
        Entry->NameLength = 0;
    }
    else
    {
        Entry->NamePtr = (PSTR)DriverName->Buffer;
        Entry->UnicodeNamePtr = 1;
        Entry->NameLength = DriverName->Length * sizeof(WCHAR);
    }

    Entry->Base = DriverEntry->LdrEntry.DllBase;
    Entry->Size = DriverEntry->LdrEntry.SizeOfImage;
    Entry->ImageInfoValid = TRUE;
    Entry->CheckSum = DriverEntry->LdrEntry.CheckSum;
    Entry->TimeDateStamp = DriverEntry->LdrEntry.TimeDateStamp;

    m_Cur++;
    return S_OK;
}

KernelTriage64ModuleInfo g_KernelTriage64ModuleIterator;

HRESULT
UserFull32ModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (UserFull32DumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Header->ModuleOffset &&
        m_DumpTarget->m_Header->ModuleCount)
    {
        m_Offset = m_DumpTarget->m_Header->ModuleOffset;
        m_Count = m_DumpTarget->m_Header->ModuleCount;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        m_Offset = 0;
        m_Count = 0;
        m_Cur = 0;
        dprintf("User Mode Full Dump does not have a module list\n");
        return S_FALSE;
    }
}

HRESULT
UserFull32ModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Count)
    {
        return S_FALSE;
    }

    CRASH_MODULE32 CrashModule;

    if (m_DumpTarget->m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Offset, &CrashModule, sizeof(CrashModule)) !=
        sizeof(CrashModule))
    {
        return HR_DATA_CORRUPT;
    }

    if (CrashModule.ImageNameLength >= MAX_IMAGE_PATH ||
        m_DumpTarget->m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Offset + FIELD_OFFSET(CRASH_MODULE32, ImageName),
                       Entry->Buffer, CrashModule.ImageNameLength) !=
        CrashModule.ImageNameLength)
    {
        Entry->NamePtr = NULL;
        Entry->NameLength = 0;
    }
    else
    {
        Entry->NamePtr = (PSTR)Entry->Buffer;
        Entry->NameLength = CrashModule.ImageNameLength - 1;
    }

    Entry->Base = EXTEND64(CrashModule.BaseOfImage);
    Entry->Size = CrashModule.SizeOfImage;

    m_Cur++;
    m_Offset += sizeof(CrashModule) + CrashModule.ImageNameLength;
    return S_OK;
}

UserFull32ModuleInfo g_UserFull32ModuleIterator;

HRESULT
UserFull64ModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (UserFull64DumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Header->ModuleOffset &&
        m_DumpTarget->m_Header->ModuleCount)
    {
        m_Offset = m_DumpTarget->m_Header->ModuleOffset;
        m_Count = m_DumpTarget->m_Header->ModuleCount;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        m_Offset = 0;
        m_Count = 0;
        m_Cur = 0;
        dprintf("User Mode Full Dump does not have a module list\n");
        return S_FALSE;
    }
}

HRESULT
UserFull64ModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Count)
    {
        return S_FALSE;
    }

    CRASH_MODULE64 CrashModule;

    if (m_DumpTarget->m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Offset, &CrashModule, sizeof(CrashModule)) !=
        sizeof(CrashModule))
    {
        return HR_DATA_CORRUPT;
    }

    if (CrashModule.ImageNameLength >= MAX_IMAGE_PATH ||
        m_DumpTarget->m_InfoFiles[DUMP_INFO_DUMP].
        ReadFileOffset(m_Offset + FIELD_OFFSET(CRASH_MODULE64, ImageName),
                       Entry->Buffer, CrashModule.ImageNameLength) !=
        CrashModule.ImageNameLength)
    {
        Entry->NamePtr = NULL;
        Entry->NameLength = 0;
    }
    else
    {
        Entry->NamePtr = (PSTR)Entry->Buffer;
        Entry->NameLength = CrashModule.ImageNameLength - 1;
    }

    Entry->Base = CrashModule.BaseOfImage;
    Entry->Size = CrashModule.SizeOfImage;

    m_Cur++;
    m_Offset += sizeof(CrashModule) + CrashModule.ImageNameLength;
    return S_OK;
}

UserFull64ModuleInfo g_UserFull64ModuleIterator;

HRESULT
UserMiniModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (UserMiniDumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Modules != NULL)
    {
        m_Count = m_DumpTarget->m_Modules->NumberOfModules;
        m_Cur = 0;
        return S_OK;
    }
    else
    {
        m_Count = 0;
        m_Cur = 0;
        dprintf("User Mode Mini Dump does not have a module list\n");
        return S_FALSE;
    }
}

HRESULT
UserMiniModuleInfo::GetEntry(PMODULE_INFO_ENTRY Entry)
{
    if (m_Cur == m_Count)
    {
        return S_FALSE;
    }

    MINIDUMP_MODULE UNALIGNED *Mod;
    MINIDUMP_STRING UNALIGNED *ModName;

    DBG_ASSERT(m_DumpTarget->m_Modules != NULL);

    Mod = m_DumpTarget->m_Modules->Modules + m_Cur;
    ModName = (MINIDUMP_STRING UNALIGNED *)
        m_DumpTarget->IndexRva(m_DumpTarget->m_Header,
                               Mod->ModuleNameRva, sizeof(*ModName),
                               "Module entry name");
    if (ModName == NULL)
    {
        Entry->NamePtr = NULL;
        Entry->NameLength = 0;
    }
    else
    {
        memcpy(Entry->Buffer, (VOID * UNALIGNED) ModName->Buffer, sizeof(Entry->Buffer));
        Entry->Buffer[sizeof(Entry->Buffer)/sizeof(WCHAR)-1] = 0;
        Entry->NamePtr = (PSTR)Entry->Buffer;
        Entry->UnicodeNamePtr = 1;
        Entry->NameLength = ModName->Length;
    }

    // Some dumps do not have properly sign-extended addresses,
    // so force the extension on 32-bit platforms.
    if (!m_Machine->m_Ptr64)
    {
        Entry->Base = EXTEND64(Mod->BaseOfImage);
    }
    else
    {
        Entry->Base = Mod->BaseOfImage;
    }
    Entry->Size = Mod->SizeOfImage;
    Entry->ImageInfoValid = TRUE;
    Entry->CheckSum = Mod->CheckSum;
    Entry->TimeDateStamp = Mod->TimeDateStamp;

    m_Cur++;
    return S_OK;
}

UserMiniModuleInfo g_UserMiniModuleIterator;

HRESULT
UserMiniUnloadedModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (UserMiniDumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_UnlModules)
    {
        m_Index = 0;
        return S_OK;
    }
    else
    {
        // Don't display a message as this is a common case.
        return S_FALSE;
    }
}

HRESULT
UserMiniUnloadedModuleInfo::GetEntry(PSTR Name,
                                     PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Index >= m_DumpTarget->m_UnlModules->NumberOfEntries)
    {
        return S_FALSE;
    }

    MINIDUMP_UNLOADED_MODULE UNALIGNED * Mod =
        (MINIDUMP_UNLOADED_MODULE UNALIGNED *)
        m_DumpTarget->
        IndexRva(m_DumpTarget->m_Header,
                 (RVA)((PUCHAR)m_DumpTarget->m_UnlModules -
                       (PUCHAR)m_DumpTarget->m_Header) +
                 m_DumpTarget->m_UnlModules->SizeOfHeader +
                 m_DumpTarget->m_UnlModules->SizeOfEntry * m_Index,
                 sizeof(*Mod), "Unloaded module entry");
    if (Mod == NULL)
    {
        return HR_DATA_CORRUPT;
    }

    ZeroMemory(Params, sizeof(*Params));
    Params->Base = Mod->BaseOfImage;
    Params->Size = Mod->SizeOfImage;
    Params->TimeDateStamp = Mod->TimeDateStamp;
    Params->Checksum = Mod->CheckSum;
    Params->Flags = DEBUG_MODULE_UNLOADED;

    if (Name != NULL)
    {
        MINIDUMP_STRING UNALIGNED * ModName = (MINIDUMP_STRING UNALIGNED *)
            m_DumpTarget->IndexRva(m_DumpTarget->m_Header,
                                   Mod->ModuleNameRva, sizeof(*ModName),
                                   "Unloaded module entry name");
        if (ModName == NULL)
        {
            UnknownImageName(Mod->BaseOfImage, Name, MAX_INFO_UNLOADED_NAME);
        }
        else
        {
            ConvertAndValidateImagePathW((PWSTR)ModName->Buffer,
                                         wcslen((PWSTR)ModName->Buffer),
                                         Mod->BaseOfImage,
                                         Name,
                                         MAX_INFO_UNLOADED_NAME);
        }
    }

    m_Index++;
    return S_OK;
}

UserMiniUnloadedModuleInfo g_UserMiniUnloadedModuleIterator;

HRESULT
KernelTriage32UnloadedModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (KernelTriage32DumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Dump->Triage.UnloadedDriversOffset != 0)
    {
        PVOID Data = m_DumpTarget->IndexRva
            (m_DumpTarget->m_Dump,
             m_DumpTarget->m_Dump->Triage.UnloadedDriversOffset,
             sizeof(ULONG), "Unloaded driver list");
        if (!Data)
        {
            return HR_DATA_CORRUPT;
        }
        m_Cur = (PDUMP_UNLOADED_DRIVERS32)((PULONG)Data + 1);
        m_End = m_Cur + *(PULONG)Data;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain unloaded driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage32UnloadedModuleInfo::GetEntry(PSTR Name,
                                           PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Cur == m_End)
    {
        return S_FALSE;
    }

    ZeroMemory(Params, sizeof(*Params));
    Params->Base = EXTEND64(m_Cur->StartAddress);
    Params->Size = m_Cur->EndAddress - m_Cur->StartAddress;
    Params->Flags = DEBUG_MODULE_UNLOADED;

    if (Name != NULL)
    {
        USHORT NameLen = m_Cur->Name.Length;
        if (NameLen > MAX_UNLOADED_NAME_LENGTH)
        {
            NameLen = MAX_UNLOADED_NAME_LENGTH;
        }
        ConvertAndValidateImagePathW(m_Cur->DriverName,
                                     NameLen / sizeof(WCHAR),
                                     Params->Base,
                                     Name,
                                     MAX_INFO_UNLOADED_NAME);
    }

    m_Cur++;
    return S_OK;
}

KernelTriage32UnloadedModuleInfo g_KernelTriage32UnloadedModuleIterator;

HRESULT
KernelTriage64UnloadedModuleInfo::Initialize(ThreadInfo* Thread)
{
    InitSource(Thread);

    m_DumpTarget = (KernelTriage64DumpTargetInfo*)m_Target;

    if (m_DumpTarget->m_Dump->Triage.UnloadedDriversOffset != 0)
    {
        PVOID Data = m_DumpTarget->IndexRva
            (m_DumpTarget->m_Dump,
             m_DumpTarget->m_Dump->Triage.UnloadedDriversOffset,
             sizeof(ULONG), "Unloaded driver list");
        if (!Data)
        {
            return HR_DATA_CORRUPT;
        }
        m_Cur = (PDUMP_UNLOADED_DRIVERS64)((PULONG64)Data + 1);
        m_End = m_Cur + *(PULONG)Data;
        return S_OK;
    }
    else
    {
        dprintf("Mini Kernel Dump does not contain unloaded driver list\n");
        return S_FALSE;
    }
}

HRESULT
KernelTriage64UnloadedModuleInfo::GetEntry(PSTR Name,
                                           PDEBUG_MODULE_PARAMETERS Params)
{
    if (m_Cur == m_End)
    {
        return S_FALSE;
    }

    ZeroMemory(Params, sizeof(*Params));
    Params->Base = m_Cur->StartAddress;
    Params->Size = (ULONG)(m_Cur->EndAddress - m_Cur->StartAddress);
    Params->Flags = DEBUG_MODULE_UNLOADED;

    if (Name != NULL)
    {
        USHORT NameLen = m_Cur->Name.Length;
        if (NameLen > MAX_UNLOADED_NAME_LENGTH)
        {
            NameLen = MAX_UNLOADED_NAME_LENGTH;
        }
        ConvertAndValidateImagePathW(m_Cur->DriverName,
                                     NameLen / sizeof(WCHAR),
                                     Params->Base,
                                     Name,
                                     MAX_INFO_UNLOADED_NAME);
    }

    m_Cur++;
    return S_OK;
}

KernelTriage64UnloadedModuleInfo g_KernelTriage64UnloadedModuleIterator;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\event.cpp ===
//----------------------------------------------------------------------------
//
// Event waiting and processing.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

// Special exception code used by the system when generating dumps
// from apps which seem to be hung.
#define STATUS_APPLICATION_HANG 0xcfffffff

// An event can be signalled on certain events for
// synchronizing other programs with the debugger.
HANDLE g_EventToSignal;

// When both creating a debuggee process and attaching
// the debuggee is left suspended until the attach
// succeeds.  At that point the created process's thread
// is resumed.
ULONG64 g_ThreadToResume;
PUSER_DEBUG_SERVICES g_ThreadToResumeServices;

ULONG g_ExecutionStatusRequest = DEBUG_STATUS_NO_CHANGE;
// Currently in seconds.
ULONG g_PendingBreakInTimeoutLimit = 30;

char g_OutputCommandRedirectPrefix[MAX_PATH];
ULONG g_OutputCommandRedirectPrefixLen;

// Set when events occur.  Can't always be retrieved from
// g_Event{Process|Thread}->SystemId since the events may be creation events
// where the info structures haven't been created yet.
ULONG g_EventThreadSysId;
ULONG g_EventProcessSysId;

ULONG g_LastEventType;
char g_LastEventDesc[MAX_IMAGE_PATH + 64];
PVOID g_LastEventExtraData;
ULONG g_LastEventExtraDataSize;
LAST_EVENT_INFO g_LastEventInfo;

// Set when lookups are done during event handling.
TargetInfo* g_EventTarget;
ProcessInfo* g_EventProcess;
ThreadInfo* g_EventThread;
MachineInfo* g_EventMachine;
// This is zero for events without a PC.
ULONG64 g_TargetEventPc;

// PC for current suspended event.
ADDR g_EventPc;
// Stored PC from the last resumed event.
ADDR g_PrevEventPc;
// An interesting related PC for the current event, such
// as the source of a branch when branch tracing.
ADDR g_PrevRelatedPc;

PDEBUG_EXCEPTION_FILTER_PARAMETERS g_EventExceptionFilter;
ULONG g_ExceptionFirstChance;

ULONG g_SystemErrorOutput = SLE_ERROR;
ULONG g_SystemErrorBreak = SLE_ERROR;

ULONG g_SuspendedExecutionStatus;
CHAR g_SuspendedCmdState;
PDBGKD_ANY_CONTROL_REPORT g_ControlReport;
PCHAR g_StateChangeData;
CHAR g_StateChangeBuffer[2 * PACKET_MAX_SIZE];
DBGKD_ANY_WAIT_STATE_CHANGE g_StateChange;
DBGKD_ANY_CONTROL_SET g_ControlSet;

char g_CreateProcessBreakName[FILTER_MAX_ARGUMENT];
char g_ExitProcessBreakName[FILTER_MAX_ARGUMENT];
char g_LoadDllBreakName[FILTER_MAX_ARGUMENT];
char g_UnloadDllBaseName[FILTER_MAX_ARGUMENT];
ULONG64 g_UnloadDllBase;
char g_OutEventFilterPattern[FILTER_MAX_ARGUMENT];

DEBUG_EXCEPTION_FILTER_PARAMETERS
g_OtherExceptionList[OTHER_EXCEPTION_LIST_MAX];
EVENT_COMMAND g_OtherExceptionCommands[OTHER_EXCEPTION_LIST_MAX];
ULONG g_NumOtherExceptions;

char g_EventLog[1024];
PSTR g_EventLogEnd = g_EventLog;

EVENT_FILTER g_EventFilters[] =
{
    //
    // Debug events.
    //

    "Create thread", "ct", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Exit thread", "et", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Create process", "cpr", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_CreateProcessBreakName, 0,
    "Exit process", "epr", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_ExitProcessBreakName, 0,
    "Load module", "ld", NULL, NULL, 0, DEBUG_FILTER_OUTPUT,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_LoadDllBreakName, 0,
    "Unload module", "ud", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_UnloadDllBaseName, 0,
    "System error", "ser", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Initial breakpoint", "ibp", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Initial module load", "iml", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Debuggee output", "out", NULL, NULL, 0, DEBUG_FILTER_OUTPUT,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, g_OutEventFilterPattern, 0,

    // Default exception filter.
    "Unknown exception", NULL, NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, 0,
        NULL, NULL, NULL, 0, 0, NULL, 0,

    //
    // Specific exceptions.
    //

    "Access violation", "av", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_ACCESS_VIOLATION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Application hang", "aph", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_APPLICATION_HANG,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Break instruction exception", "bpe", "bpec", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_BREAKPOINT,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "C++ EH exception", "eh", NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_CPP_EH_EXCEPTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Control-Break exception", "cce", "cc", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, DBG_CONTROL_BREAK,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Control-C exception", "cce", "cc", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, DBG_CONTROL_C,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Data misaligned", "dm", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_DATATYPE_MISALIGNMENT,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Debugger command exception", "dbce", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, DBG_COMMAND_EXCEPTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Guard page violation", "gp", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_GUARD_PAGE_VIOLATION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Illegal instruction", "ii", NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_ILLEGAL_INSTRUCTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "In-page I/O error", "ip", NULL, " %I64x", 2, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_IN_PAGE_ERROR,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Integer divide-by-zero", "dz", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INTEGER_DIVIDE_BY_ZERO,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Integer overflow", "iov", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INTEGER_OVERFLOW,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Invalid handle", "ch", "hc", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INVALID_HANDLE,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Invalid lock sequence", "lsq", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INVALID_LOCK_SEQUENCE,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Invalid system call", "isc", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_INVALID_SYSTEM_SERVICE,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Port disconnected", "3c", NULL, NULL, 0, DEBUG_FILTER_SECOND_CHANCE_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_PORT_DISCONNECTED,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Single step exception", "sse", "ssec", NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_SINGLE_STEP,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Stack buffer overflow", "sbo", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_STACK_BUFFER_OVERRUN,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Stack overflow", "sov", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_STACK_OVERFLOW,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Visual C++ exception", "vcpp", NULL, NULL, 0, DEBUG_FILTER_IGNORE,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_VCPP_EXCEPTION,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "Wake debugger", "wkd", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_NOT_HANDLED, 0, 0, 0, STATUS_WAKE_SYSTEM_DEBUGGER,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "WOW64 breakpoint", "wob", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_WX86_BREAKPOINT,
        NULL, NULL, NULL, 0, 0, NULL, 0,
    "WOW64 single step exception", "wos", NULL, NULL, 0, DEBUG_FILTER_BREAK,
        DEBUG_FILTER_GO_HANDLED, 0, 0, 0, STATUS_WX86_SINGLE_STEP,
        NULL, NULL, NULL, 0, 0, NULL, 0,
};

void
ClearEventLog(void)
{
    g_EventLogEnd = g_EventLog;
    *g_EventLogEnd = 0;
}

void
DotEventLog(PDOT_COMMAND Cmd, DebugClient* Client)
{
    if (g_EventLogEnd > g_EventLog)
    {
        dprintf("%s", g_EventLog);
    }
    else
    {
        dprintf("Event log is empty\n");
    }

    dprintf("Last event: %s\n", g_LastEventDesc);
}

void
LogEventDesc(PSTR Desc, ULONG ProcId, ULONG ThreadId)
{
    // Extra space for newline and terminator.
    int Len = strlen(Desc) + 2;
    if (IS_USER_TARGET(g_EventTarget))
    {
        // Space for process and thread IDs.
        Len += 16;
    }
    if (Len > sizeof(g_EventLog))
    {
        Len = sizeof(g_EventLog);
    }

    int Avail = (int)(sizeof(g_EventLog) - (g_EventLogEnd - g_EventLog));
    if (g_EventLogEnd > g_EventLog && Len > Avail)
    {
        PSTR Save = g_EventLog;
        int Need = Len - Avail;

        while (Need > 0)
        {
            PSTR Scan = strchr(Save, '\n');
            if (Scan == NULL)
            {
                break;
            }

            Scan++;
            Need -= (int)(Scan - Save);
            Save = Scan;
        }

        if (Need > 0)
        {
            // Couldn't make enough space so throw
            // everything away.
            g_EventLogEnd = g_EventLog;
            *g_EventLogEnd = 0;
        }
        else
        {
            Need = strlen(Save);
            memmove(g_EventLog, Save, Need + 1);
            g_EventLogEnd = g_EventLog + Need;
        }
    }

    Avail = (int)(sizeof(g_EventLog) - (g_EventLogEnd - g_EventLog));

    if (IS_USER_TARGET(g_EventTarget))
    {
        sprintf(g_EventLogEnd, "%04x.%04x: ", ProcId, ThreadId);
        Avail -= strlen(g_EventLogEnd);
        g_EventLogEnd += strlen(g_EventLogEnd);
    }

    CopyString(g_EventLogEnd, Desc, Avail - 2);
    g_EventLogEnd += strlen(g_EventLogEnd);
    *g_EventLogEnd++ = '\n';
    *g_EventLogEnd = 0;
}

void
DiscardLastEventInfo(void)
{
    if (g_EventThread)
    {
        g_EventThread->ClearEventStrings();
    }

    if (g_LastEventDesc[0])
    {
        LogEventDesc(g_LastEventDesc, g_EventProcessSysId, g_EventThreadSysId);
    }

    g_LastEventType = 0;
    g_LastEventDesc[0] = 0;
    g_LastEventExtraData = NULL;
    g_LastEventExtraDataSize = 0;
}

void
DiscardLastEvent(void)
{
    // Do this before clearing the other information so
    // it's available for the log.
    DiscardLastEventInfo();
    g_EventProcessSysId = 0;
    g_EventThreadSysId = 0;
    g_TargetEventPc = 0;

    // Clear any cached memory read during the last event.
    InvalidateAllMemoryCaches();
}

BOOL
AnyEventsPossible(void)
{
    TargetInfo* Target;

    ForAllLayersToTarget()
    {
        ULONG DesiredTimeout;

        if (Target->
            WaitInitialize(DEBUG_WAIT_DEFAULT, INFINITE,
                           WINIT_TEST, &DesiredTimeout) == S_OK &&
            Target->m_EventPossible)
        {
            break;
        }
    }

    return Target != NULL;
}

void
NotifyDebuggeeActivation(void)
{
    StackSaveLayers Save;

    //
    // Now that all initialization is done, send initial
    // notification that a debuggee exists.  Make sure
    // that the basic target, system and machine globals
    // are set up so that queries can be made during
    // the callbacks.
    //

    SetLayersFromTarget(g_EventTarget);

    g_EventTarget->AddSpecificExtensions();

    NotifySessionStatus(DEBUG_SESSION_ACTIVE);
    NotifyChangeDebuggeeState(DEBUG_CDS_ALL, 0);
    NotifyExtensions(DEBUG_NOTIFY_SESSION_ACTIVE, 0);
}

ULONG
EventStatusToContinue(ULONG EventStatus)
{
    switch(EventStatus)
    {
    case DEBUG_STATUS_GO_NOT_HANDLED:
        return DBG_EXCEPTION_NOT_HANDLED;
    case DEBUG_STATUS_GO_HANDLED:
        return DBG_EXCEPTION_HANDLED;
    case DEBUG_STATUS_NO_CHANGE:
    case DEBUG_STATUS_IGNORE_EVENT:
    case DEBUG_STATUS_GO:
    case DEBUG_STATUS_STEP_OVER:
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_BRANCH:
        return DBG_CONTINUE;
    default:
        DBG_ASSERT(FALSE);
        return DBG_CONTINUE;
    }
}

HRESULT
PrepareForWait(ULONG Flags, PULONG ContinueStatus)
{
    HRESULT Status;

    Status = PrepareForExecution(g_ExecutionStatusRequest);
    if (Status != S_OK)
    {
        // If S_FALSE, we're at a hard breakpoint so the only thing that
        // happens is that the PC is adjusted and the "wait"
        // can succeed immediately.
        // Otherwise we failed execution preparation.  Either way
        // we need to try and prepare for calls.
        PrepareForCalls(0);

        return FAILED(Status) ? Status : S_OK;
    }

    *ContinueStatus = EventStatusToContinue(g_ExecutionStatusRequest);
    g_EngStatus |= ENG_STATUS_WAITING;

    return S_OK;
}

DWORD
GetContinueStatus(ULONG FirstChance, ULONG Continue)
{
    if (!FirstChance || Continue == DEBUG_FILTER_GO_HANDLED)
    {
        return DBG_EXCEPTION_HANDLED;
    }
    else
    {
        return DBG_EXCEPTION_NOT_HANDLED;
    }
}

void
ProcessDeferredWork(PULONG ContinueStatus)
{
    if (g_EngDefer & ENG_DEFER_SET_EVENT)
    {
        // This event signalling is used by the system
        // to synchronize with the debugger when starting
        // the debugger via AeDebug.  The -e parameter
        // to ntsd sets this value.
        // It could potentially be used in other situations.
        if (g_EventToSignal != NULL)
        {
            SetEvent(g_EventToSignal);
            g_EventToSignal = NULL;
        }

        g_EngDefer &= ~ENG_DEFER_SET_EVENT;
    }

    if (g_EngDefer & ENG_DEFER_RESUME_THREAD)
    {
        DBG_ASSERT(g_ThreadToResumeServices);

        g_ThreadToResumeServices->
            ResumeThreads(1, &g_ThreadToResume, NULL);
        g_ThreadToResume = 0;
        g_ThreadToResumeServices = NULL;
        g_EngDefer &= ~ENG_DEFER_RESUME_THREAD;
    }

    if (g_EngDefer & ENG_DEFER_EXCEPTION_HANDLING)
    {
        if (*ContinueStatus == DBG_CONTINUE)
        {
            if (g_EventExceptionFilter != NULL)
            {
                // A user-visible exception occurred so check on how it
                // should be handled.
                *ContinueStatus =
                    GetContinueStatus(g_ExceptionFirstChance,
                                      g_EventExceptionFilter->ContinueOption);

            }
            else
            {
                // An internal exception occurred, such as a single-step.
                // Force the continue status.
                *ContinueStatus = g_ExceptionFirstChance;
            }
        }

        g_EngDefer &= ~ENG_DEFER_EXCEPTION_HANDLING;
    }

    // If output was deferred but the wait was exited anyway
    // a stale defer flag will be left.  Make sure it's cleared.
    g_EngDefer &= ~ENG_DEFER_OUTPUT_CURRENT_INFO;

    // Clear at-initial flags.  If the incoming event
    // turns out to be one of them it'll turn on the flag.
    g_EngStatus &= ~(ENG_STATUS_AT_INITIAL_BREAK |
                     ENG_STATUS_AT_INITIAL_MODULE_LOAD);
}

BOOL
SuspendExecution(void)
{
    if (g_EngStatus & ENG_STATUS_SUSPENDED)
    {
        // Nothing to do.
        return FALSE;
    }

    g_LastSelector = -1;          // Prevent stale selector values

    SuspendAllThreads();

    // Don't notify on any state changes as
    // PrepareForCalls will do a blanket notify later.
    g_EngNotify++;

    // If we have an event thread select it.
    if (g_EventThread != NULL)
    {
        DBG_ASSERT(g_EventTarget->m_RegContextThread == NULL);
        g_EventTarget->ChangeRegContext(g_EventThread);
    }

    // First set the effective machine to the true
    // processor type so that real processor information
    // can be examined to determine any possible
    // alternate execution states.
    // No need to notify here as another SetEffMachine
    // is coming up.
    g_EventTarget->SetEffMachine(g_EventTarget->m_MachineType, FALSE);
    if (g_EngStatus & ENG_STATUS_STATE_CHANGED)
    {
        g_EventTarget->m_EffMachine->
            InitializeContext(g_TargetEventPc, g_ControlReport);
        g_EngStatus &= ~ENG_STATUS_STATE_CHANGED;
    }

    // If this is a live user target that's being examined
    // instead of truly debugged we do not want to set the
    // trace mode as we can't track events.  If we did
    // set the trace mode here it could cause context writeback
    // which could generate an exception that nobody expects.
    if (g_EventProcess &&
        !IS_DUMP_TARGET(g_EventTarget) &&
        (!IS_LIVE_USER_TARGET(g_EventTarget) ||
         !(g_EventProcess->m_Flags & ENG_PROC_EXAMINED)))
    {
        g_EventTarget->m_EffMachine->QuietSetTraceMode(TRACE_NONE);
    }

    // Now determine the executing code type and
    // make that the effective machine.
    if (IS_CONTEXT_POSSIBLE(g_EventTarget))
    {
        g_EventMachine = MachineTypeInfo(g_EventTarget,
                                         g_EventTarget->m_EffMachine->
                                         ExecutingMachine());
    }
    else
    {
        // Local kernel debugging doesn't deal with contexts
        // as everything would be in the context of the debugger.
        // It's safe to just assume the executing machine
        // is the target machine, plus this avoids unwanted
        // context access.
        g_EventMachine = g_EventTarget->m_Machine;
    }
    g_EventTarget->SetEffMachine(g_EventMachine->m_ExecTypes[0], TRUE);
    g_Machine = g_EventMachine;

    // Trace flag should always be clear at this point.
    g_EngDefer &= ~ENG_DEFER_HARDWARE_TRACING;

    g_EngNotify--;

    g_EngStatus |= ENG_STATUS_SUSPENDED;
    g_SuspendedExecutionStatus = GetExecutionStatus();
    g_SuspendedCmdState = g_CmdState;

    g_ContextChanged = FALSE;

    return TRUE;
}

HRESULT
ResumeExecution(void)
{
    TargetInfo* Target;

    if ((g_EngStatus & ENG_STATUS_SUSPENDED) == 0)
    {
        // Nothing to do.
        return S_OK;
    }

    if (g_EventTarget &&
        g_EventTarget->m_EffMachine->GetTraceMode() != TRACE_NONE)
    {
        g_EngDefer |= ENG_DEFER_HARDWARE_TRACING;
    }

    if (!SPECIAL_EXECUTION(g_CmdState) &&
        IS_REMOTE_KERNEL_TARGET(g_EventTarget))
    {
        g_EventTarget->m_Machine->KdUpdateControlSet(&g_ControlSet);
        g_EngDefer |= ENG_DEFER_UPDATE_CONTROL_SET;
    }

    ForAllLayersToTarget()
    {
        Target->PrepareForExecution();
    }

    if (!ResumeAllThreads())
    {
        if (g_EventTarget)
        {
            g_EventTarget->ChangeRegContext(g_EventThread);
        }
        return E_FAIL;
    }

    g_EngStatus &= ~ENG_STATUS_SUSPENDED;
    return S_OK;
}

void
PrepareForCalls(ULONG64 ExtraStatusFlags)
{
    BOOL HardBrkpt = FALSE;
    ADDR PcAddr;
    BOOL Changed = FALSE;

    // If there's no event then execution didn't really
    // occur so there's no need to suspend.  This will happen
    // when a debuggee exits or during errors on execution
    // preparation.
    if (g_EventThreadSysId != 0)
    {
        if (SuspendExecution())
        {
            Changed = TRUE;
        }
    }
    else
    {
        g_CmdState = 'c';

        // Force notification in this case to ensure
        // that clients know the engine is not running.
        Changed = TRUE;
    }

    if (RemoveBreakpoints() == S_OK)
    {
        Changed = TRUE;
    }

    if (!IS_EVENT_CONTEXT_ACCESSIBLE())
    {
        ADDRFLAT(&PcAddr, 0);
        ClearAddr(&g_EventPc);
    }
    else
    {
        g_EventMachine->GetPC(&PcAddr);
        g_EventPc = PcAddr;
    }

    if (g_CmdState != 'c')
    {
        g_CmdState = 'c';
        Changed = TRUE;

        g_DumpDefault = g_UnasmDefault = g_AssemDefault = PcAddr;

        if (IS_EVENT_CONTEXT_ACCESSIBLE() &&
            IS_KERNEL_TARGET(g_EventTarget))
        {
            HardBrkpt = g_EventMachine->
                IsBreakpointInstruction(g_EventProcess, &PcAddr);
        }
    }

    g_EngStatus |= ENG_STATUS_PREPARED_FOR_CALLS;

    if (Changed)
    {
        if (IS_EVENT_CONTEXT_ACCESSIBLE())
        {
            ResetCurrentScopeLazy();
        }

        // This can produce many notifications.  Callers should
        // suppress notification when they can to avoid multiple
        // notifications during a single operation.
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                DEBUG_STATUS_BREAK | ExtraStatusFlags, TRUE);
        NotifyChangeEngineState(DEBUG_CES_CURRENT_THREAD,
                                g_Thread ? g_Thread->m_UserId : DEBUG_ANY_ID,
                                TRUE);
        NotifyChangeDebuggeeState(DEBUG_CDS_ALL, 0);
        NotifyExtensions(DEBUG_NOTIFY_SESSION_ACCESSIBLE, 0);
    }
    else if (ExtraStatusFlags == 0)
    {
        // We're exiting a wait so force the current execution
        // status to be sent to let everybody know that a
        // wait is finishing.
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                DEBUG_STATUS_BREAK, TRUE);
    }

    // IA64 reports a plabel in the structure, so we need to compare
    // against the real function address.
    if (HardBrkpt)
    {
        ULONG64 Address = Flat(PcAddr);
        ULONG64 StatusRoutine =
            g_EventTarget->m_KdDebuggerData.BreakpointWithStatus;

        if (g_EventMachine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_IA64)
        {
            g_EventTarget->ReadPointer(g_EventProcess, g_EventMachine,
                                       StatusRoutine, &StatusRoutine);
            StatusRoutine &= ~0xf;
            Address &= ~0xf;
        }

        if (Address && Address == StatusRoutine)
        {
            HandleBPWithStatus();
        }
    }
    else
    {
        // Some kernel dumps don't show up as hard breakpoints
        // Call !analyze if we have kernel dump target
        if (IS_EVENT_CONTEXT_ACCESSIBLE() &&
            g_EventTarget->m_Class == DEBUG_CLASS_KERNEL &&
            (g_EventTarget->m_ClassQualifier == DEBUG_DUMP_SMALL ||
             g_EventTarget->m_ClassQualifier == DEBUG_DUMP_DEFAULT ||
             g_EventTarget->m_ClassQualifier == DEBUG_DUMP_FULL))
        {
            CallBugCheckExtension(NULL);
        }
    }
}

HRESULT
PrepareForExecution(ULONG NewStatus)
{
    ADDR PcAddr;
    BOOL AtHardBrkpt = FALSE;
    ThreadInfo* StepThread = NULL;

    ClearAddr(&g_PrevRelatedPc);

 StepAgain:
    // Remember the event PC for later.
    g_PrevEventPc = g_EventPc;

    // Display current information on intermediate steps where
    // the debugger UI isn't even invoked.
    if ((g_EngDefer & ENG_DEFER_OUTPUT_CURRENT_INFO) &&
        (g_EngStatus & ENG_STATUS_STOP_SESSION) == 0)
    {
        OutCurInfo(OCI_SYMBOL | OCI_DISASM | OCI_ALLOW_EA |
                   OCI_ALLOW_REG | OCI_ALLOW_SOURCE | OCI_IGNORE_STATE,
                   g_Machine->m_AllMask, DEBUG_OUTPUT_PROMPT_REGISTERS);
        g_EngDefer &= ~ENG_DEFER_OUTPUT_CURRENT_INFO;
    }

    // Don't notify on any state changes as
    // PrepareForCalls will do a blanket notify later.
    g_EngNotify++;

    if (g_EventTarget && (g_EngStatus & ENG_STATUS_SUSPENDED))
    {
        if (!SPECIAL_EXECUTION(g_CmdState))
        {
            if (NewStatus != DEBUG_STATUS_IGNORE_EVENT)
            {
                SetExecutionStatus(NewStatus);
                DBG_ASSERT((g_EngStatus & ENG_STATUS_STOP_SESSION) ||
                           IS_RUNNING(g_CmdState));
            }
            else
            {
                NewStatus = g_SuspendedExecutionStatus;
                g_CmdState = g_SuspendedCmdState;
            }
        }

        if (!(g_EngStatus & ENG_STATUS_STOP_SESSION) &&
            !SPECIAL_EXECUTION(g_CmdState) &&
            (g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
            g_StepTraceBp->m_MatchThread)
        {
            StepThread = g_StepTraceBp->m_MatchThread;

            // Check and see if we need to fake a step/trace
            // event when artificially moving beyond a hard-coded
            // break instruction.
            if (!StepThread->m_Process->m_Exited)
            {
                StackSaveLayers SaveLayers;
                MachineInfo* Machine =
                    MachineTypeInfo(StepThread->m_Process->m_Target,
                                    g_Machine->m_ExecTypes[0]);

                SetLayersFromThread(StepThread);
                StepThread->m_Process->m_Target->ChangeRegContext(StepThread);
                Machine->GetPC(&PcAddr);
                AtHardBrkpt = Machine->
                    IsBreakpointInstruction(g_Process, &PcAddr);
                if (AtHardBrkpt)
                {
                    g_WatchBeginCurFunc = 1;

                    Machine->AdjustPCPastBreakpointInstruction
                        (&PcAddr, DEBUG_BREAKPOINT_CODE);
                    if (Flat(*g_StepTraceBp->GetAddr()) != OFFSET_TRACE)
                    {
                        ULONG NextMachine;

                        Machine->GetNextOffset(g_Process,
                                               g_StepTraceCmdState == 'p',
                                               g_StepTraceBp->GetAddr(),
                                               &NextMachine);
                        g_StepTraceBp->SetProcType(NextMachine);
                    }
                    GetCurrentMemoryOffsets(&g_StepTraceInRangeStart,
                                            &g_StepTraceInRangeEnd);

                    if (StepTracePass(&PcAddr))
                    {
                        // If the step was passed over go back
                        // and update things based on the adjusted PC.
                        g_EngNotify--;
                        g_EventPc = PcAddr;
                        goto StepAgain;
                    }
                }
            }
        }

        // If the last event was a hard-coded breakpoint exception
        // we need to move the event thread beyond the break instruction.
        // Note that if we continued stepping on that thread it was
        // handled above, so we only do this if it's a different
        // thread or we're not stepping.
        // If the continuation status is not-handled then
        // we need to let the int3 get hit again.  If we're
        // exiting, though, we don't want to do this.
        if (g_EventThread != NULL &&
            !g_EventThread->m_Process->m_Exited &&
            g_EventTarget->m_DynamicEvents &&
            !SPECIAL_EXECUTION(g_CmdState) &&
            g_EventThread != StepThread &&
            (NewStatus != DEBUG_STATUS_GO_NOT_HANDLED ||
             (g_EngStatus & ENG_STATUS_STOP_SESSION)))
        {
            StackSaveLayers SaveLayers;

            SetLayersFromThread(g_EventThread);
            g_EventTarget->ChangeRegContext(g_EventThread);

            g_EventMachine->GetPC(&PcAddr);
            if (g_EventMachine->
                IsBreakpointInstruction(g_EventProcess, &PcAddr))
            {
                g_EventMachine->AdjustPCPastBreakpointInstruction
                    (&PcAddr, DEBUG_BREAKPOINT_CODE);
            }

            if (StepThread != NULL)
            {
                StepThread->m_Process->m_Target->
                    ChangeRegContext(StepThread);
            }
        }
    }

    HRESULT Status;

    if ((g_EngStatus & ENG_STATUS_STOP_SESSION) ||
        SPECIAL_EXECUTION(g_CmdState))
    {
        // If we're stopping don't insert breakpoints in
        // case we're detaching from the process.  In
        // that case we want threads to run normally.
        Status = S_OK;
    }
    else
    {
        Status = InsertBreakpoints();
    }

    // Resume notification now that modifications are done.
    g_EngNotify--;

    if (Status != S_OK)
    {
        return Status;
    }

    if ((Status = ResumeExecution()) != S_OK)
    {
        return Status;
    }

    g_EngStatus &= ~ENG_STATUS_PREPARED_FOR_CALLS;

    if (!SPECIAL_EXECUTION(g_CmdState))
    {
        // Now that we've resumed execution notify about the change.
        NotifyChangeEngineState(DEBUG_CES_EXECUTION_STATUS,
                                NewStatus, TRUE);
        NotifyExtensions(DEBUG_NOTIFY_SESSION_INACCESSIBLE, 0);
    }

    if (AtHardBrkpt && StepThread != NULL)
    {
        // We're stepping over a hard breakpoint.  This is
        // done entirely by the debugger so no debug event
        // is associated with it.  Instead we simply update
        // the PC and return from the Wait without actually waiting.

        // Step/trace events have empty event info.
        DiscardLastEventInfo();
        g_EventThreadSysId = StepThread->m_SystemId;
        g_EventProcessSysId = StepThread->m_Process->m_SystemId;
        FindEventProcessThread();

        // Clear left-overs from the true event so they're
        // not used during initialization.
        g_TargetEventPc = 0;
        g_ControlReport = NULL;

        SuspendExecution();
        if (IS_EVENT_CONTEXT_ACCESSIBLE())
        {
            g_EventMachine->GetPC(&g_EventPc);
        }
        else
        {
            ClearAddr(&g_EventPc);
        }

        return S_FALSE;
    }

    // Once we resume execution the processes and threads
    // can change so we must flush our notion of what's current.
    g_Process = NULL;
    g_Thread = NULL;
    g_EventProcess = NULL;
    g_EventThread = NULL;
    g_EventMachine = NULL;

    if (g_EngDefer & ENG_DEFER_DELETE_EXITED)
    {
        // Reap any threads and processes that have terminated since
        // we last executed.
        DeleteAllExitedInfos();
        g_EngDefer &= ~ENG_DEFER_DELETE_EXITED;
    }

    return S_OK;
}

HRESULT
PrepareForSeparation(void)
{
    HRESULT Status;
    ULONG OldStop = g_EngStatus & ENG_STATUS_STOP_SESSION;

    //
    // The debugger is going to separate from the
    // debuggee, such as during a detach operation.
    // Get the debuggee running again so that it
    // will go on without the debugger.
    //

    g_EngStatus |= ENG_STATUS_STOP_SESSION;

    Status = PrepareForExecution(DEBUG_STATUS_GO_HANDLED);

    g_EngStatus = (g_EngStatus & ~ENG_STATUS_STOP_SESSION) | OldStop;
    return Status;
}

void
FindEventProcessThread(void)
{
    //
    // If these lookups fail other processes and
    // threads cannot be substituted for the correct
    // ones as that may cause modifications to the
    // wrong data structures.  For example, if a
    // thread exit comes in it cannot be processed
    // with any other process or thread as that would
    // delete the wrong thread.
    //

    g_EventProcess = g_EventTarget->FindProcessBySystemId(g_EventProcessSysId);
    if (g_EventProcess == NULL)
    {
        ErrOut("ERROR: Unable to find system process %X\n",
               g_EventProcessSysId);
        ErrOut("ERROR: The process being debugged has either exited "
               "or cannot be accessed\n");
        ErrOut("ERROR: Many commands will not work properly\n");
    }
    else
    {
        g_EventThread = g_EventProcess->
            FindThreadBySystemId(g_EventThreadSysId);
        if (g_EventThread == NULL)
        {
            ErrOut("ERROR: Unable to find system thread %X\n",
                   g_EventThreadSysId);
            ErrOut("ERROR: The thread being debugged has either exited "
                   "or cannot be accessed\n");
            ErrOut("ERROR: Many commands will not work properly\n");
        }
    }

    DBG_ASSERT((g_EventThread == NULL ||
                g_EventThread->m_Process == g_EventProcess) &&
               (g_EventProcess == NULL ||
                g_EventProcess->m_Target == g_EventTarget));

    g_Thread = g_EventThread;
    g_Process = g_EventProcess;
    if (g_Process)
    {
        g_Process->m_CurrentThread = g_Thread;
    }
    g_Target = g_EventTarget;
    if (g_Target)
    {
        g_Target->m_CurrentProcess = g_Process;
    }
}

static int VoteWeight[] =
{
    0, // DEBUG_STATUS_NO_CHANGE
    2, // DEBUG_STATUS_GO
    3, // DEBUG_STATUS_GO_HANDLED
    4, // DEBUG_STATUS_GO_NOT_HANDLED
    6, // DEBUG_STATUS_STEP_OVER
    7, // DEBUG_STATUS_STEP_INTO
    8, // DEBUG_STATUS_BREAK
    9, // DEBUG_STATUS_NO_DEBUGGEE
    5, // DEBUG_STATUS_STEP_BRANCH
    1, // DEBUG_STATUS_IGNORE_EVENT
};

ULONG
MergeVotes(ULONG Cur, ULONG Vote)
{
    // If the vote is actually an error code display a message.
    if (FAILED(Vote))
    {
        ErrOut("Callback failed with %X\n", Vote);
        return Cur;
    }

    // Ignore invalid votes.
    if (
        (
#if DEBUG_STATUS_NO_CHANGE > 0
         Vote < DEBUG_STATUS_NO_CHANGE ||
#endif
         Vote > DEBUG_STATUS_BREAK) &&
        (Vote < DEBUG_STATUS_STEP_BRANCH ||
         Vote > DEBUG_STATUS_IGNORE_EVENT))
    {
        ErrOut("Callback returned invalid vote %X\n", Vote);
        return Cur;
    }

    // Votes are biased towards executing as little
    // as possible.
    //   Break overrides all other votes.
    //   Step into overrides step over.
    //   Step over overrides step branch.
    //   Step branch overrides go.
    //   Go not-handled overrides go handled.
    //   Go handled overrides plain go.
    //   Plain go overrides ignore event.
    //   Anything overrides no change.
    if (VoteWeight[Vote] > VoteWeight[Cur])
    {
        Cur = Vote;
    }

    return Cur;
}

ULONG
ProcessBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                 ULONG FirstChance)
{
    ADDR BpAddr;
    ULONG BreakType;
    ULONG EventStatus;

    SuspendExecution();
    // Default breakpoint address to the current PC as that's
    // where the majority are at.
    g_EventMachine->GetPC(&BpAddr);

    // Check whether the exception is a breakpoint.
    BreakType = g_EventMachine->
        IsBreakpointOrStepException(Record, FirstChance,
                                    &BpAddr, &g_PrevRelatedPc);
    if (BreakType & EXBS_BREAKPOINT_ANY)
    {
        // It's a breakpoint of some kind.
        EventOut("*** breakpoint exception\n");
        EventStatus = CheckBreakpointOrStepTrace(&BpAddr, BreakType);
    }
    else
    {
        // It's a true single step or taken branch exception.
        // We still need to check breakpoints as we may have stepped
        // to an instruction which has a breakpoint.
        EventOut("*** single step or taken branch exception\n");
        EventStatus = CheckBreakpointOrStepTrace(&BpAddr, EXBS_BREAKPOINT_ANY);
    }

    if (EventStatus == DEBUG_STATUS_NO_CHANGE)
    {
        // The break/step exception wasn't recognized
        // as a debugger-specific event so handle it as
        // a regular exception.  The default states for
        // break/step exceptions are to break in so
        // this will do the right thing, plus it allows
        // people to ignore or notify for them if they want.
        EventStatus = NotifyExceptionEvent(Record, FirstChance, FALSE);
    }
    else
    {
        // Force the exception to be handled.
        g_EngDefer |= ENG_DEFER_EXCEPTION_HANDLING;
        g_EventExceptionFilter = NULL;
        g_ExceptionFirstChance = DBG_EXCEPTION_HANDLED;
    }

    return EventStatus;
}

ULONG
CheckBreakpointOrStepTrace(PADDR BpAddr, ULONG BreakType)
{
    ULONG EventStatus;
    Breakpoint* Bp;
    ULONG BreakHitType;
    BOOL BpHit;

    BpHit = FALSE;
    Bp = NULL;
    EventStatus = DEBUG_STATUS_NO_CHANGE;

    // Multiple breakpoints can be hit at the same address.
    // Process all possible hits.  Do not do notifications
    // while walking the list as the callbacks may modify
    // the list.  Instead just mark the breakpoint as
    // needing notification in the next pass.
    for (;;)
    {
        Bp = CheckBreakpointHit(g_EventProcess, Bp, BpAddr, BreakType, -1,
                                g_CmdState != 'g' ?
                                DEBUG_BREAKPOINT_GO_ONLY : 0,
                                &BreakHitType, TRUE);
        if (Bp == NULL)
        {
            break;
        }

        if (BreakHitType == BREAKPOINT_HIT)
        {
            Bp->m_Flags |= BREAKPOINT_NOTIFY;
        }
        else
        {
            // This breakpoint was hit but the hit was ignored.
            // Vote to continue execution.
            EventStatus = MergeVotes(EventStatus, DEBUG_STATUS_IGNORE_EVENT);
        }

        BpHit = TRUE;
        Bp = Bp->m_Next;
        if (Bp == NULL)
        {
            break;
        }
    }

    if (!BpHit)
    {
        // If no breakpoints were recognized check for an internal
        // breakpoint.
        EventStatus = CheckStepTrace(BpAddr, EventStatus);

        //
        // If the breakpoint wasn't for a step/trace
        // it's a hard breakpoint and should be
        // handled as a normal exception.
        //

        if (!g_EventProcess->m_InitialBreakDone)
        {
            g_EngStatus |= ENG_STATUS_AT_INITIAL_BREAK;
        }

        // We've seen the initial break for this process.
        g_EventProcess->m_InitialBreakDone = TRUE;
        // If we were waiting for a break-in exception we've got it.
        g_EngStatus &= ~ENG_STATUS_PENDING_BREAK_IN;

        if (EventStatus == DEBUG_STATUS_NO_CHANGE)
        {
            if (!g_EventProcess->m_InitialBreak)
            {
                // Refresh breakpoints even though we're not
                // stopping.  This gives saved breakpoints
                // a chance to become active.
                RemoveBreakpoints();

                EventStatus = DEBUG_STATUS_GO;
                g_EventProcess->m_InitialBreak = TRUE;
            }
            else if (IS_USER_TARGET(g_EventTarget) &&
                     (!g_EventProcess->m_InitialBreakWx86) &&
                     (g_EventTarget->m_MachineType !=
                      g_EventTarget->m_EffMachineType) &&
                     (g_EventTarget->
                      m_EffMachineType == IMAGE_FILE_MACHINE_I386))
            {
                // Allow skipping of both the target machine
                // initial break and emulated machine initial breaks.
                RemoveBreakpoints();
                EventStatus = DEBUG_STATUS_GO;
                g_EventProcess->m_InitialBreakWx86 = TRUE;
            }
        }
    }
    else
    {
        // A breakpoint was recognized.  We need to
        // refresh the breakpoint status since we'll
        // probably need to defer the reinsertion of
        // the breakpoint we're sitting on.
        RemoveBreakpoints();

        // Now do event callbacks for any breakpoints that need it.
        EventStatus = NotifyHitBreakpoints(EventStatus);
    }

    if (g_ThreadToResume != 0)
    {
        g_EngDefer |= ENG_DEFER_RESUME_THREAD;
    }

    return EventStatus;
}

ULONG
CheckStepTrace(PADDR PcAddr, ULONG DefaultStatus)
{
    BOOL WatchStepOver = FALSE;
    ULONG uOciFlags;
    ULONG NextMachine;

    if ((g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
        Flat(*g_StepTraceBp->GetAddr()) != OFFSET_TRACE)
    {
        NotFlat(*g_StepTraceBp->GetAddr());
        ComputeFlatAddress(g_StepTraceBp->GetAddr(), NULL);
    }

    // We do not check ENG_THREAD_TRACE_SET here because
    // this event detection is only for proper user-initiated
    // step/trace events.  Such an event must occur immediately
    // after the t/p/b, otherwise we cannot be sure that
    // it's actually a debugger event and not an app-generated
    // single-step exception.
    // In user mode we restrict the step/trace state
    // to a single thread to try and be as precise
    // as possible.  This isn't done in kernel mode
    // since kernel mode "threads" are currently
    // just placeholders for processors.  It is
    // possible for a context switch to occur at any
    // time while stepping, meaning a true system
    // thread could move from one processor to another.
    // The processor state, including the single-step
    // flag, will be moved with the thread so single
    // step exceptions will come from the new processor
    // rather than this one, meaning we would ignore
    // it if we used "thread" restrictions.  Instead,
    // just assume any single-step exception while in
    // p/t mode is a debugger step.
    if ((g_StepTraceBp->m_Flags & DEBUG_BREAKPOINT_ENABLED) &&
        g_StepTraceBp->m_Process == g_EventProcess &&
        ((IS_KERNEL_TARGET(g_EventTarget) && IS_STEP_TRACE(g_CmdState)) ||
         g_StepTraceBp->m_MatchThread == g_EventThread) &&
        (Flat(*g_StepTraceBp->GetAddr()) == OFFSET_TRACE ||
         AddrEqu(*g_StepTraceBp->GetAddr(), *PcAddr)))
    {
        ADDR CurrentSP;

        //  step/trace event occurred

        // Update breakpoint status since we may need to step
        // again and step/trace is updated when breakpoints
        // are inserted.
        RemoveBreakpoints();

        uOciFlags = OCI_DISASM | OCI_ALLOW_REG | OCI_ALLOW_SOURCE |
            OCI_ALLOW_EA;

        if (g_EngStatus & (ENG_STATUS_PENDING_BREAK_IN |
                           ENG_STATUS_USER_INTERRUPT))
        {
            g_WatchFunctions.End(PcAddr);
            return DEBUG_STATUS_BREAK;
        }

        if (IS_KERNEL_TARGET(g_EventTarget) && g_WatchInitialSP)
        {
            g_EventMachine->GetSP(&CurrentSP);

            if ((Flat(CurrentSP) + 0x1500 < g_WatchInitialSP) ||
                (g_WatchInitialSP + 0x1500 < Flat(CurrentSP)))
            {
                return DEBUG_STATUS_IGNORE_EVENT;
            }
        }

        if (g_StepTraceInRangeStart != -1 &&
            Flat(*PcAddr) >= g_StepTraceInRangeStart &&
            Flat(*PcAddr) < g_StepTraceInRangeEnd)
        {
            //  test if step/trace range active
            //      if so, compute the next offset and pass through

            g_EventMachine->GetNextOffset(g_EventProcess,
                                          g_StepTraceCmdState == 'p',
                                          g_StepTraceBp->GetAddr(),
                                          &NextMachine);
            g_StepTraceBp->SetProcType(NextMachine);
            if (g_WatchWhole)
            {
                g_WatchBeginCurFunc = Flat(*g_StepTraceBp->GetAddr());
                g_WatchEndCurFunc = 0;
            }

            return DEBUG_STATUS_IGNORE_EVENT;
        }

        //  active step/trace event - note event if count is zero

        if (!StepTracePass(PcAddr) ||
            (g_WatchFunctions.IsStarted() && AddrEqu(g_WatchTarget, *PcAddr) &&
             (!IS_KERNEL_TARGET(g_EventTarget) ||
              Flat(CurrentSP) >= g_WatchInitialSP)))
        {
            g_WatchFunctions.End(PcAddr);
            return DEBUG_STATUS_BREAK;
        }

        if (g_WatchFunctions.IsStarted())
        {
            if (g_WatchTrace)
            {
                g_EventTarget->
                    ProcessWatchTraceEvent((PDBGKD_TRACE_DATA)
                                           g_StateChangeData,
                                           PcAddr,
                                           &WatchStepOver);
            }
            goto skipit;
        }

        if (g_SrcOptions & SRCOPT_STEP_SOURCE)
        {
            goto skipit;
        }

        //  more remaining events to occur, but output
        //      the instruction (optionally with registers)
        //      compute the step/trace address for next event

        OutCurInfo(uOciFlags, g_EventMachine->m_AllMask,
                   DEBUG_OUTPUT_PROMPT_REGISTERS);

skipit:
        g_EventMachine->
            GetNextOffset(g_EventProcess,
                          g_StepTraceCmdState == 'p' || WatchStepOver,
                          g_StepTraceBp->GetAddr(),
                          &NextMachine);
        g_StepTraceBp->SetProcType(NextMachine);
        GetCurrentMemoryOffsets(&g_StepTraceInRangeStart,
                                &g_StepTraceInRangeEnd);

        return DEBUG_STATUS_IGNORE_EVENT;
    }

    // Carry out deferred breakpoint work if necessary.
    // We need to check the thread deferred-bp flag here as
    // other events may occur before the thread with deferred
    // work gets to execute again, in which case the setting
    // of g_DeferDefined may have changed.
    if ((g_EventThread != NULL &&
         (g_EventThread->m_Flags & ENG_THREAD_DEFER_BP_TRACE)) ||
        (g_DeferDefined &&
         g_DeferBp->m_Process == g_EventProcess &&
         (Flat(*g_DeferBp->GetAddr()) == OFFSET_TRACE ||
          AddrEqu(*g_DeferBp->GetAddr(), *PcAddr))))
    {
        if ((g_EngOptions & DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS) &&
            IS_USER_TARGET(g_EventTarget) &&
            IsSelectedExecutionThread(g_EventThread,
                                      SELTHREAD_INTERNAL_THREAD))
        {
            // The engine internally restricted execution to
            // this particular thread in order to manage
            // breakpoints in multithreaded conditions.
            // The deferred work will be finished before
            // we resume so we can drop the lock.
            SelectExecutionThread(NULL, SELTHREAD_ANY);
        }

        // Deferred breakpoints are refreshed on breakpoint
        // insertion so make sure that insertion happens
        // when things restart.
        RemoveBreakpoints();
        return DEBUG_STATUS_IGNORE_EVENT;
    }

    // If the event was unrecognized return the default status.
    return DefaultStatus;
}

void
AnalyzeDeadlock(PEXCEPTION_RECORD64 Record, ULONG FirstChance)
{
    CHAR Symbol[MAX_SYMBOL_LEN];
    DWORD64 Displacement;
    ThreadInfo* ThreadOwner = NULL;
    DWORD Tid = 0;
    RTL_CRITICAL_SECTION CritSec;

    // poking around inside NT's user-mode RTL_CRITICAL_SECTION and
    // RTL_RESOURCE structures.

    //
    // Get the symbolic name of the routine which
    // raised the exception to see if it matches
    // one of the expected ones in ntdll.
    //

    GetSymbol((ULONG64)Record->ExceptionAddress,
              Symbol, DIMA(Symbol), &Displacement);

    if (!_stricmp("ntdll!RtlpWaitForCriticalSection", Symbol))
    {
        //
        // If the first parameter is a pointer to the critsect as it
        // should be, switch to the owning thread before bringing
        // up the prompt.  This way it's obvious where the problem
        // is.
        //

        if (Record->ExceptionInformation[0])
        {
            if (g_EventTarget->
                ReadAllVirtual(g_EventProcess, Record->ExceptionInformation[0],
                               &CritSec, sizeof(CritSec)) == S_OK)
            {
                if (NULL == CritSec.DebugInfo)
                {
                    dprintf("Critsec %s was deleted or "
                            "was never initialized.\n",
                            FormatAddr64(Record->ExceptionInformation[0]));
                }
                else if (CritSec.LockCount < -1)
                {
                    dprintf("Critsec %s was left when not owned, corrupted.\n",
                            FormatAddr64(Record->ExceptionInformation[0]));
                }
                else
                {
                    Tid = (DWORD)((ULONG_PTR)CritSec.OwningThread);
                    ThreadOwner = g_Process->FindThreadBySystemId(Tid);
                }
            }
        }

        if (ThreadOwner)
        {
            dprintf("Critsec %s owned by thread %d (.%x) "
                    "caused thread %d (.%x)\n"
                    "      to timeout entering it.  "
                    "Breaking in on owner thread, ask\n"
                    "      yourself why it has held this "
                    "critsec long enough to deadlock.\n"
                    "      Use `~%ds` to switch back to timeout thread.\n",
                    FormatAddr64(Record->ExceptionInformation[0]),
                    ThreadOwner->m_UserId,
                    ThreadOwner->m_SystemId,
                    g_Thread->m_UserId,
                    g_Thread->m_SystemId,
                    g_Thread->m_UserId);

            g_EventThread = ThreadOwner;

            SetPromptThread(ThreadOwner, 0);
        }
        else if (Tid)
        {
            dprintf("Critsec %s ABANDONED owner thread ID is .%x, "
                    "no such thread.\n",
                    FormatAddr64(Record->ExceptionInformation[0]),
                    Tid);
        }

        if (!FirstChance)
        {
            dprintf("!!! second chance !!!\n");
        }

        //
        // do a !critsec for them
        //

        if (Record->ExceptionInformation[0])
        {
            char CritsecAddr[64];
            HRESULT Status;

            sprintf(CritsecAddr, "%s",
                    FormatAddr64(Record->ExceptionInformation[0]));
            dprintf("!critsec %s\n", CritsecAddr);
            CallAnyExtension(NULL, NULL, "critsec", CritsecAddr,
                             FALSE, FALSE, &Status);
        }
    }
    else if (!_stricmp("ntdll!RtlAcquireResourceShared", Symbol) ||
             !_stricmp("ntdll!RtlAcquireResourceExclusive", Symbol) ||
             !_stricmp("ntdll!RtlConvertSharedToExclusive", Symbol))
    {
        dprintf("deadlock in %s ", 1 + strstr(Symbol, "!"));

        GetSymbol(Record->ExceptionInformation[0],
                  Symbol, sizeof(Symbol), &Displacement);

        dprintf("Resource %s", Symbol);
        if (Displacement)
        {
            dprintf("+%s", FormatDisp64(Displacement));
        }
        dprintf(" (%s)\n",
                FormatAddr64(Record->ExceptionInformation[0]));
        if (!FirstChance)
        {
            dprintf("!!! second chance !!!\n");
        }

        // Someone who uses RTL_RESOURCEs might write a !resource
        // for ntsdexts.dll like !critsec.
    }
    else
    {
        dprintf("Possible Deadlock in %s ", Symbol);

        GetSymbol(Record->ExceptionInformation[0],
                  Symbol, sizeof(Symbol), &Displacement);

        dprintf("Lock %s", Symbol);
        if (Displacement)
        {
            dprintf("+%s", FormatDisp64(Displacement));
        }
        dprintf(" (%s)\n",
                FormatAddr64(Record->ExceptionInformation[0]));
        if (!FirstChance)
        {
            dprintf("!!! second chance !!!\n");
        }
    }
}

void
OutputDeadlock(PEXCEPTION_RECORD64 Record, ULONG FirstChance)
{
    CHAR Symbol[MAX_SYMBOL_LEN];
    DWORD64 Displacement;

    GetSymbol(Record->ExceptionInformation[0],
              Symbol, sizeof(Symbol), &Displacement);

    dprintf("Possible Deadlock Lock %s+%s at %s\n",
            Symbol,
            FormatDisp64(Displacement),
            FormatAddr64(Record->ExceptionInformation[0]));
    if (!FirstChance)
    {
        dprintf("!!! second chance !!!\n");
    }
}

void
GetEventName(ULONG64 ImageFile, ULONG64 ImageBase,
             ULONG64 NamePtr, WORD Unicode,
             PSTR NameBuffer, ULONG BufferSize)
{
    char TempName[MAX_IMAGE_PATH];

    if (!g_EventProcess)
    {
        return;
    }

    if (NamePtr != 0)
    {
        if (g_EventTarget->ReadPointer(g_EventProcess,
                                       g_EventTarget->m_Machine,
                                       NamePtr, &NamePtr) != S_OK)
        {
            NamePtr = 0;
        }
    }

    if (NamePtr != 0)
    {
        ULONG Done;

        if (g_EventTarget->ReadVirtual(g_EventProcess,
                                       NamePtr, TempName, sizeof(TempName),
                                       &Done) != S_OK ||
            Done < (Unicode ? 2 * sizeof(WCHAR) : 2))
        {
            NamePtr = 0;
        }
        else
        {
            TempName[sizeof(TempName) - 1] = 0;
            TempName[sizeof(TempName) - 2] = 0;
        }
    }

    if (NamePtr != 0)
    {
        //
        // We have a name.
        //
        if (Unicode)
        {
            if (!WideCharToMultiByte(
                    CP_ACP,
                    WC_COMPOSITECHECK,
                    (LPWSTR)TempName,
                    -1,
                    NameBuffer,
                    BufferSize,
                    NULL,
                    NULL
                    ))
            {
                //
                // Unicode -> ANSI conversion failed.
                //
                NameBuffer[0] = 0;
            }
        }
        else
        {
            CopyString(NameBuffer, TempName, BufferSize);
        }
    }
    else
    {
        //
        // We don't have a name, so look in the image.
        // A file handle will only be provided here in the
        // local case so it's safe to case to HANDLE.
        //
        if (!GetModnameFromImage(g_EventProcess,
                                 ImageBase, OS_HANDLE(ImageFile),
                                 NameBuffer, BufferSize, TRUE))
        {
            NameBuffer[0] = 0;
        }
    }

    if (!NameBuffer[0])
    {
        if (!GetModNameFromLoaderList(g_EventThread,
                                      g_EventTarget->m_Machine, 0,
                                      ImageBase, NameBuffer, BufferSize,
                                      TRUE))
        {
            PrintString(NameBuffer, BufferSize,
                        "image%p", (PVOID)(ULONG_PTR)ImageBase);
        }
    }
    else
    {
        // If the name given doesn't have a full path try
        // and locate a full path in the loader list.
        if ((((NameBuffer[0] < 'a' || NameBuffer[0] > 'z') &&
              (NameBuffer[0] < 'A' || NameBuffer[0] > 'Z')) ||
             NameBuffer[1] != ':') &&
            (NameBuffer[0] != '\\' || NameBuffer[1] != '\\'))
        {
            GetModNameFromLoaderList(g_EventThread,
                                     g_EventTarget->m_Machine, 0,
                                     ImageBase, NameBuffer, BufferSize,
                                     TRUE);
        }
    }
}

//----------------------------------------------------------------------------
//
// ConnLiveKernelTargetInfo wait methods.
//
//----------------------------------------------------------------------------

NTSTATUS
ConnLiveKernelTargetInfo::KdContinue(ULONG ContinueStatus,
                                     PDBGKD_ANY_CONTROL_SET ControlSet)
{
    DBGKD_MANIPULATE_STATE64 m;

    DBG_ASSERT(ContinueStatus == DBG_EXCEPTION_HANDLED ||
               ContinueStatus == DBG_EXCEPTION_NOT_HANDLED ||
               ContinueStatus == DBG_CONTINUE);

    if (ControlSet)
    {
        EventOut(">>> DbgKdContinue2\n");

        m.ApiNumber = DbgKdContinueApi2;
        m.u.Continue2.ContinueStatus = ContinueStatus;
        m.u.Continue2.AnyControlSet = *ControlSet;
    }
    else
    {
        EventOut(">>> DbgKdContinue\n");

        m.ApiNumber = DbgKdContinueApi;
        m.u.Continue.ContinueStatus = ContinueStatus;
    }

    m.ReturnStatus = ContinueStatus;
    m_Transport->WritePacket(&m, sizeof(m),
                             PACKET_TYPE_KD_STATE_MANIPULATE,
                             NULL, 0);

    return STATUS_SUCCESS;
}

HRESULT
ConnLiveKernelTargetInfo::WaitInitialize(ULONG Flags,
                                         ULONG Timeout,
                                         WAIT_INIT_TYPE Type,
                                         PULONG DesiredTimeout)
{
    // Timeouts can't easily be supported at the moment and
    // aren't really necessary.
    if (Timeout != INFINITE)
    {
        return E_NOTIMPL;
    }

    *DesiredTimeout = Timeout;
    m_EventPossible = m_CurrentPartition;
    return S_OK;
}

HRESULT
ConnLiveKernelTargetInfo::ReleaseLastEvent(ULONG ContinueStatus)
{
    HRESULT Status = S_OK;
    NTSTATUS NtStatus;

    if (!g_EventProcessSysId)
    {
        // No event to release.
        return S_OK;
    }

    m_CurrentPartition = FALSE;

    if (SPECIAL_EXECUTION(g_CmdState))
    {
        if (m_SwitchTarget)
        {
            DBGKD_MANIPULATE_STATE64 m;

            EventOut(">>> Switch to system %d\n", m_SwitchTarget->m_UserId);

            if (m_KdMaxManipulate <= DbgKdSwitchPartition)
            {
                ErrOut("System doesn't support partition switching\n");
                return E_NOTIMPL;
            }

            m.ApiNumber = (USHORT)DbgKdSwitchPartition;
            m.Processor = 0;
            m.ProcessorLevel = 0;
            m.u.SwitchPartition.Partition = m_SwitchTarget->m_SystemId;

            m_Transport->WritePacket(&m, sizeof(m),
                                     PACKET_TYPE_KD_STATE_MANIPULATE,
                                     NULL, 0);

            KdOut("DbgKdSwitchPartition returns 0x00000000\n");

            m_SwitchTarget = NULL;
            g_EngStatus |= ENG_STATUS_SPECIAL_EXECUTION;
        }
        else
        {
            // This can either be a real processor switch or
            // a rewait for state change.  Check the switch
            // processor to be sure.
            if (m_SwitchProcessor)
            {
                DBGKD_MANIPULATE_STATE64 m;

                EventOut(">>> Switch to processor %d\n",
                         m_SwitchProcessor - 1);

                m.ApiNumber = (USHORT)DbgKdSwitchProcessor;
                m.Processor = (USHORT)(m_SwitchProcessor - 1);

                // Quiet PREfix warnings.
                m.ProcessorLevel = 0;

                m_Transport->WritePacket(&m, sizeof(m),
                                         PACKET_TYPE_KD_STATE_MANIPULATE,
                                         NULL, 0);

                KdOut("DbgKdSwitchActiveProcessor returns 0x00000000\n");

                m_SwitchProcessor = 0;
                g_EngStatus |= ENG_STATUS_SPECIAL_EXECUTION;
            }
        }
    }
    else
    {
        NtStatus = KdContinue(ContinueStatus,
                              (g_EngDefer & ENG_DEFER_UPDATE_CONTROL_SET) ?
                              &g_ControlSet : NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            ErrOut("KdContinue failed, 0x%08x\n", NtStatus);
            Status = HRESULT_FROM_NT(NtStatus);
        }
        else
        {
            g_EngDefer &= ~ENG_DEFER_UPDATE_CONTROL_SET;
        }
    }

    return Status;
}

HRESULT
ConnLiveKernelTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout,
                                       ULONG ElapsedTime, PULONG EventStatus)
{
    NTSTATUS NtStatus;

    if (!IS_MACHINE_SET(this))
    {
        dprintf("Waiting to reconnect...\n");

        if ((g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) &&
            IS_CONN_KERNEL_TARGET(this))
        {
            // Ask for a breakin to be sent once the
            // code gets into resync.
            m_Transport->m_SyncBreakIn = TRUE;
        }
    }

    // When waiting for confirmation of a processor switch don't
    // yield the engine lock in order to prevent other clients
    // from trying to do things with the target while it's
    // switching.
    NtStatus = WaitStateChange(&g_StateChange, g_StateChangeBuffer,
                               sizeof(g_StateChangeBuffer) - 2,
                               (g_EngStatus &
                                ENG_STATUS_SPECIAL_EXECUTION) == 0);
    if (NtStatus == STATUS_PENDING)
    {
        // A caller interrupted the current wait so exit
        // without an error message.
        return E_PENDING;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        ErrOut("DbgKdWaitStateChange failed: %08lx\n", NtStatus);
        return HRESULT_FROM_NT(NtStatus);
    }

    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    g_StateChangeData = g_StateChangeBuffer;

    *EventStatus = ((ConnLiveKernelTargetInfo*)g_EventTarget)->
        ProcessStateChange(&g_StateChange, g_StateChangeData);

    return S_OK;
}

NTSTATUS
ConnLiveKernelTargetInfo::WaitStateChange
    (OUT PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
     OUT PVOID Buffer,
     IN ULONG BufferLength,
     IN BOOL SuspendEngine)
{
    PVOID LocalStateChange;
    NTSTATUS Status;
    PUCHAR Data;
    ULONG SizeofStateChange;
    ULONG WaitStatus;

    //
    // Waiting for a state change message. Copy the message to the callers
    // buffer.
    //

    DBG_ASSERT(m_Transport->m_WaitingThread == 0);
    m_Transport->m_WaitingThread = GetCurrentThreadId();

    if (SuspendEngine)
    {
        SUSPEND_ENGINE();
    }

    do
    {
        WaitStatus = m_Transport->
            WaitForPacket(PACKET_TYPE_KD_STATE_CHANGE64, &LocalStateChange);
    } while (WaitStatus != DBGKD_WAIT_PACKET &&
             WaitStatus != DBGKD_WAIT_INTERRUPTED);

    if (SuspendEngine)
    {
        RESUME_ENGINE();
    }
    m_Transport->m_WaitingThread = 0;

    if (WaitStatus == DBGKD_WAIT_INTERRUPTED)
    {
        return STATUS_PENDING;
    }

    Status = STATUS_SUCCESS;

    // If this is the very first wait we don't know what system
    // we've connected to.  Update the version information
    // right away.
    if (!IS_MACHINE_SET(this))
    {
        m_Transport->SaveReadPacket();

        // Failures will be detected by checking the machine
        // state later so don't worry about the return value.
        InitFromKdVersion();

        m_Transport->RestoreReadPacket();

        if (!IS_MACHINE_SET(this))
        {
            //
            // We were unable to determine what kind of machine
            // has connected so we cannot properly communicate with it.
            //

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Trusted Windows systems have two OS's running, one
        // regular NT and the other a trusted NT-like OS.
        // If this is a Trusted Windows system set up systems
        // for both the regular and trusted OSs.
        //

        if ((m_KdVersion.Flags & DBGKD_VERS_FLAG_PARTITIONS) &&
            !FindTargetBySystemId(DBGKD_PARTITION_ALTERNATE))
        {
            ConnLiveKernelTargetInfo* AltTarg = new ConnLiveKernelTargetInfo;
            if (!AltTarg)
            {
                return STATUS_NO_MEMORY;
            }
            // Avoid the ConnLiveKernelTargetInfo Initialize as
            // we don't want a new transport created.
            if (AltTarg->LiveKernelTargetInfo::Initialize() != S_OK)
            {
                delete AltTarg;
                return STATUS_UNSUCCESSFUL;
            }

            m_Transport->Ref();
            AltTarg->m_Transport = m_Transport;

            m_Transport->SaveReadPacket();
            AltTarg->InitFromKdVersion();
            m_Transport->RestoreReadPacket();
            if (!IS_MACHINE_SET(AltTarg))
            {
                delete AltTarg;
                return STATUS_UNSUCCESSFUL;
            }

            if (DBGKD_MAJOR_TYPE(m_KdVersion.MajorVersion) == DBGKD_MAJOR_TNT)
            {
                // This is the trusted partition.
                m_SystemId = DBGKD_PARTITION_ALTERNATE;
                AltTarg->m_SystemId = DBGKD_PARTITION_DEFAULT;
            }
            else
            {
                // This is the regular partition.
                m_SystemId = DBGKD_PARTITION_DEFAULT;
                AltTarg->m_SystemId = DBGKD_PARTITION_ALTERNATE;
            }
        }
    }

    if (m_KdApi64)
    {
        if (m_KdVersion.ProtocolVersion < DBGKD_64BIT_PROTOCOL_VERSION2)
        {
            PDBGKD_WAIT_STATE_CHANGE64 Ws64 =
                (PDBGKD_WAIT_STATE_CHANGE64)LocalStateChange;
            ULONG Offset, Align, Pad;

            //
            // The 64-bit structures contain 64-bit quantities and
            // therefore the compiler rounds the total size up to
            // an even multiple of 64 bits (or even more, the IA64
            // structures are 16-byte aligned).  Internal structures
            // are also aligned, so make sure that we account for any
            // padding.  Knowledge of which structures need which
            // padding pretty much has to be hard-coded in.
            //

            C_ASSERT((sizeof(DBGKD_WAIT_STATE_CHANGE64) & 15) == 0);

            SizeofStateChange =
                sizeof(DBGKD_WAIT_STATE_CHANGE64) +
                m_TypeInfo.SizeControlReport +
                m_TypeInfo.SizeTargetContext;

            // We shouldn't need to align the base of the control report
            // so copy the base data and control report.
            Offset = sizeof(DBGKD_WAIT_STATE_CHANGE64) +
                m_TypeInfo.SizeControlReport;
            memcpy(StateChange, Ws64, Offset);

            //
            // Add alignment padding before the context.
            //

            switch(m_MachineType)
            {
            case IMAGE_FILE_MACHINE_IA64:
                Align = 15;
                break;
            default:
                Align = 7;
                break;
            }

            Pad = ((Offset + Align) & ~Align) - Offset;
            Offset += Pad;
            SizeofStateChange += Pad;

            //
            // Add alignment padding after the context.
            //

            Offset += m_TypeInfo.SizeTargetContext;
            Pad = ((Offset + Align) & ~Align) - Offset;
            SizeofStateChange += Pad;
        }
        else
        {
            PDBGKD_ANY_WAIT_STATE_CHANGE WsAny =
                (PDBGKD_ANY_WAIT_STATE_CHANGE)LocalStateChange;
            SizeofStateChange = sizeof(*WsAny);
            *StateChange = *WsAny;
        }
    }
    else
    {
        SizeofStateChange =
            sizeof(DBGKD_WAIT_STATE_CHANGE32) +
            m_TypeInfo.SizeControlReport +
            m_TypeInfo.SizeTargetContext;
        WaitStateChange32ToAny((PDBGKD_WAIT_STATE_CHANGE32)LocalStateChange,
                               m_TypeInfo.SizeControlReport,
                               StateChange);
    }

    if (StateChange->NewState & DbgKdAlternateStateChange)
    {
        // This state change came from the alternate partition.
        g_EventTarget = FindTargetBySystemId(DBGKD_PARTITION_ALTERNATE);

        StateChange->NewState &= ~DbgKdAlternateStateChange;
    }
    else
    {
        // Default partition state change.
        g_EventTarget = FindTargetBySystemId(DBGKD_PARTITION_DEFAULT);
    }

    if (!g_EventTarget)
    {
        return STATUS_UNSUCCESSFUL;
    }

    ((ConnLiveKernelTargetInfo*)g_EventTarget)->m_CurrentPartition = TRUE;

    switch(StateChange->NewState)
    {
    case DbgKdExceptionStateChange:
    case DbgKdCommandStringStateChange:
        if (BufferLength <
            (m_Transport->s_PacketHeader.ByteCount - SizeofStateChange))
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            Data = (UCHAR *)LocalStateChange + SizeofStateChange;
            memcpy(Buffer, Data,
                   m_Transport->s_PacketHeader.ByteCount -
                   SizeofStateChange);
        }
        break;
    case DbgKdLoadSymbolsStateChange:
        if ( BufferLength < StateChange->u.LoadSymbols.PathNameLength )
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            Data = ((UCHAR *) LocalStateChange) +
                m_Transport->s_PacketHeader.ByteCount -
                (int)StateChange->u.LoadSymbols.PathNameLength;
            memcpy(Buffer, Data,
                   (int)StateChange->u.LoadSymbols.PathNameLength);
        }
        break;
    default:
        ErrOut("Unknown state change type %X\n", StateChange->NewState);
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;
}

#define EXCEPTION_CODE StateChange->u.Exception.ExceptionRecord.ExceptionCode
#define FIRST_CHANCE   StateChange->u.Exception.FirstChance

ULONG
ConnLiveKernelTargetInfo::ProcessStateChange(PDBGKD_ANY_WAIT_STATE_CHANGE StateChange,
                                             PCHAR StateChangeData)
{
    ULONG EventStatus;

    EventOut(">>> State change event %X, proc %d of %d\n",
             StateChange->NewState, StateChange->Processor,
             StateChange->NumberProcessors);

    if (!m_NumProcessors)
    {
        dprintf("Kernel Debugger connection established.%s\n",
                (g_EngOptions & DEBUG_ENGOPT_INITIAL_BREAK) ?
                "  (Initial Breakpoint requested)" : "");

        // Initial connection after a fresh boot may only report
        // a single processor as the others haven't started yet.
        m_NumProcessors = StateChange->NumberProcessors;

        CreateVirtualProcess(m_NumProcessors);

        g_EventProcessSysId = m_ProcessHead->m_SystemId;
        g_EventThreadSysId = VIRTUAL_THREAD_ID(StateChange->Processor);
        FindEventProcessThread();

        QueryKernelInfo(g_EventThread, TRUE);

        // Now that we have the data block
        // we can retrieve processor information.
        InitializeForProcessor();

        RemoveAllTargetBreakpoints();

        OutputVersion();

        NotifyDebuggeeActivation();
    }
    else
    {
        // Initial connection after a fresh boot may only report
        // a single processor as the others haven't started yet.
        // Pick up any additional processors.
        if (StateChange->NumberProcessors > m_NumProcessors)
        {
            m_ProcessHead->
                CreateVirtualThreads(m_NumProcessors,
                                     StateChange->NumberProcessors -
                                     m_NumProcessors);
            m_NumProcessors = StateChange->NumberProcessors;
        }

        g_EventProcessSysId = m_ProcessHead->m_SystemId;
        g_EventThreadSysId = VIRTUAL_THREAD_ID(StateChange->Processor);
        FindEventProcessThread();
    }

    g_TargetEventPc = StateChange->ProgramCounter;
    g_ControlReport = &StateChange->AnyControlReport;
    if (g_EventThread)
    {
        g_EventThread->m_DataOffset = StateChange->Thread;
    }

    //
    // If the reported instruction stream contained breakpoints
    // the kernel automatically removed them.  We need to
    // ensure that breakpoints get reinserted properly if
    // that's the case.
    //

    ULONG Count;

    switch(m_MachineType)
    {
    case IMAGE_FILE_MACHINE_IA64:
        Count = g_ControlReport->IA64ControlReport.InstructionCount;
        break;
    case IMAGE_FILE_MACHINE_I386:
        Count = g_ControlReport->X86ControlReport.InstructionCount;
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        Count = g_ControlReport->Amd64ControlReport.InstructionCount;
        break;
    }

    if (CheckBreakpointInsertedInRange(g_EventProcess,
                                       g_TargetEventPc,
                                       g_TargetEventPc + Count - 1))
    {
        SuspendExecution();
        RemoveBreakpoints();
    }

    if (StateChange->NewState == DbgKdExceptionStateChange)
    {
        //
        // Read the system range start address from the target system.
        //

        if (m_SystemRangeStart == 0)
        {
            QueryKernelInfo(g_EventThread, FALSE);
        }

        EventOut("Exception %X at %p\n", EXCEPTION_CODE, g_TargetEventPc);

        if (EXCEPTION_CODE == STATUS_BREAKPOINT ||
            EXCEPTION_CODE == STATUS_SINGLE_STEP ||
            EXCEPTION_CODE == STATUS_WX86_BREAKPOINT ||
            EXCEPTION_CODE == STATUS_WX86_SINGLE_STEP)
        {
            EventStatus = ProcessBreakpointOrStepException
                (&StateChange->u.Exception.ExceptionRecord,
                 StateChange->u.Exception.FirstChance);
        }
        else if (EXCEPTION_CODE == STATUS_WAKE_SYSTEM_DEBUGGER)
        {
            // The target has requested that the debugger
            // become active so just break in.
            EventStatus = DEBUG_STATUS_BREAK;
        }
        else
        {
            //
            // The interlocked SList code has a by-design faulting
            // case, so ignore AVs at that particular symbol.
            //

            if (EXCEPTION_CODE == STATUS_ACCESS_VIOLATION &&
                StateChange->u.Exception.FirstChance)
            {
                CHAR ExSym[MAX_SYMBOL_LEN];
                ULONG64 ExDisp;

                GetSymbol(StateChange->
                          u.Exception.ExceptionRecord.ExceptionAddress,
                          ExSym, sizeof(ExSym), &ExDisp);
                if (ExDisp == 0 &&
                    !_stricmp(ExSym, "nt!ExpInterlockedPopEntrySListFault"))
                {
                    return DEBUG_STATUS_GO_NOT_HANDLED;
                }
            }

            EventStatus =
                NotifyExceptionEvent(&StateChange->u.Exception.ExceptionRecord,
                                     StateChange->u.Exception.FirstChance,
                                     FALSE);
        }
    }
    else if (StateChange->NewState == DbgKdLoadSymbolsStateChange)
    {
        if (StateChange->u.LoadSymbols.UnloadSymbols)
        {
            if (StateChange->u.LoadSymbols.PathNameLength == 0 &&
                StateChange->u.LoadSymbols.ProcessId == 0)
            {
                if (StateChange->u.LoadSymbols.BaseOfDll == (ULONG64)KD_REBOOT ||
                    StateChange->u.LoadSymbols.BaseOfDll == (ULONG64)KD_HIBERNATE)
                {
                    KdContinue(DBG_CONTINUE, NULL);
                    DebuggeeReset(StateChange->u.LoadSymbols.BaseOfDll ==
                                  KD_REBOOT ?
                                  DEBUG_SESSION_REBOOT :
                                  DEBUG_SESSION_HIBERNATE,
                                  TRUE);
                    EventStatus = DEBUG_STATUS_NO_DEBUGGEE;
                }
                else
                {
                    ErrOut("Invalid module unload state change\n");
                    EventStatus = DEBUG_STATUS_IGNORE_EVENT;
                }
            }
            else
            {
                EventStatus = NotifyUnloadModuleEvent
                    (StateChangeData, StateChange->u.LoadSymbols.BaseOfDll);
            }
        }
        else
        {
            ImageInfo* Image;
            CHAR FileName[_MAX_FNAME];
            CHAR Ext[_MAX_EXT];
            CHAR ImageName[_MAX_FNAME + _MAX_EXT];
            CHAR ModNameBuf[_MAX_FNAME + _MAX_EXT + 1];
            PSTR ModName = ModNameBuf;

            ModName[0] = '\0';
            _splitpath( StateChangeData, NULL, NULL, FileName, Ext );
            sprintf( ImageName, "%s%s", FileName, Ext );
            if (_stricmp(Ext, ".sys") == 0)
            {
                Image = g_EventProcess ? g_EventProcess->m_ImageHead : NULL;
                while (Image)
                {
                    if (_stricmp(ImageName, Image->m_ImagePath) == 0)
                    {
                        PSTR Dot;

                        ModName[0] = 'c';
                        strcpy( &ModName[1], ImageName );
                        Dot = strchr( ModName, '.' );
                        if (Dot)
                        {
                            *Dot = '\0';
                        }

                        ModName[8] = '\0';
                        break;
                    }

                    Image = Image->m_Next;
                }
            }
            else if (StateChange->u.LoadSymbols.BaseOfDll ==
                     m_KdDebuggerData.KernBase)
            {
                //
                // Recognize the kernel module.
                //
                ModName = KERNEL_MODULE_NAME;
            }

            EventStatus = NotifyLoadModuleEvent(
                0, StateChange->u.LoadSymbols.BaseOfDll,
                StateChange->u.LoadSymbols.SizeOfImage,
                ModName[0] ? ModName : NULL, ImageName,
                StateChange->u.LoadSymbols.CheckSum, 0,
                StateChange->u.LoadSymbols.BaseOfDll < m_SystemRangeStart);

            //
            // Attempt to preload the machine type of the image
            // as we expect the headers to be available at this
            // point, whereas they may be paged out later.
            //

            Image = g_EventProcess ? g_EventProcess->
                FindImageByOffset(StateChange->u.LoadSymbols.BaseOfDll,
                                  FALSE) : NULL;
            if (Image)
            {
                Image->GetMachineType();
            }
        }
    }
    else if (StateChange->NewState == DbgKdCommandStringStateChange)
    {
        PSTR Command;

        //
        // The state change data has two strings one after
        // the other.  The first is a name string identifying
        // the originator of the command.  The second is
        // the command itself.
        //

        Command = StateChangeData + strlen(StateChangeData) + 1;
        _snprintf(g_LastEventDesc, sizeof(g_LastEventDesc) - 1,
                  "%.48s command: '%.192s'",
                  StateChangeData, Command);
        EventStatus = ExecuteEventCommand(DEBUG_STATUS_NO_CHANGE, NULL,
                                          Command);

        // Break in if the command didn't explicitly continue.
        if (EventStatus == DEBUG_STATUS_NO_CHANGE)
        {
            EventStatus = DEBUG_STATUS_BREAK;
        }
    }
    else
    {
        //
        // Invalid NewState in state change record.
        //
        ErrOut("\nUNEXPECTED STATE CHANGE %08lx\n\n",
               StateChange->NewState);

        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
    }

    return EventStatus;
}

#undef EXCEPTION_CODE
#undef FIRST_CHANCE

//----------------------------------------------------------------------------
//
// LocalLiveKernelTargetInfo wait methods.
//
//----------------------------------------------------------------------------

HRESULT
LocalLiveKernelTargetInfo::WaitInitialize(ULONG Flags,
                                          ULONG Timeout,
                                          WAIT_INIT_TYPE Type,
                                          PULONG DesiredTimeout)
{
    *DesiredTimeout = Timeout;
    m_EventPossible = m_FirstWait;
    return S_OK;
}

HRESULT
LocalLiveKernelTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout,
                                        ULONG ElapsedTime, PULONG EventStatus)
{
    HRESULT Status;
    SYSTEM_INFO SysInfo;

    if (!m_FirstWait)
    {
        // A wait has already been done.  Local kernels
        // can only generate a single event so further
        // waiting is not possible.
        return S_FALSE;
    }

    g_EventTarget = this;

    GetSystemInfo(&SysInfo);
    m_NumProcessors = SysInfo.dwNumberOfProcessors;

    // Set this right here since we know kernel debugging only works on
    // recent systems using the 64 bit protocol.
    m_KdApi64 = TRUE;

    if ((Status = InitFromKdVersion()) != S_OK)
    {
        delete g_EventTarget;
        g_EventTarget = NULL;
        return Status;
    }

    // This is the first wait.  Simulate any
    // necessary events such as process and thread
    // creations and image loads.

    CreateVirtualProcess(m_NumProcessors);

    g_EventProcessSysId = m_ProcessHead->m_SystemId;
    // Current processor always starts at zero.
    g_EventThreadSysId = VIRTUAL_THREAD_ID(0);
    FindEventProcessThread();

    QueryKernelInfo(g_EventThread, TRUE);

    // Now that we have the data block
    // we can retrieve processor information.
    InitializeForProcessor();

    // Clear the global state change just in case somebody's
    // directly accessing it somewhere.
    ZeroMemory(&g_StateChange, sizeof(g_StateChange));
    g_StateChangeData = g_StateChangeBuffer;
    g_StateChangeBuffer[0] = 0;

    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    // Do not provide a control report; this will force
    // such information to come from context retrieval.
    g_ControlReport = NULL;

    // There isn't a current PC, let it be discovered.
    g_TargetEventPc = 0;

    // Warn if the kernel debugging code isn't available
    // as that often causes problems.
    if (g_NtDllCalls.NtQuerySystemInformation)
    {
        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo;
        
        if (!NT_SUCCESS(g_NtDllCalls.NtQuerySystemInformation
                        (SystemKernelDebuggerInformation,
                         &KdInfo, sizeof(KdInfo), NULL)) ||
            !KdInfo.KernelDebuggerEnabled)
        {
            WarnOut("*****************************************"
                    "**************************************\n");
            WarnOut("WARNING: Local kernel debugging requires "
                    "booting with /debug to work optimally.\n");
            WarnOut("*****************************************"
                    "**************************************\n");
        }
    }
    
    OutputVersion();

    NotifyDebuggeeActivation();

    *EventStatus = DEBUG_STATUS_BREAK;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// ExdiLiveKernelTargetInfo wait methods.
//
//----------------------------------------------------------------------------

HRESULT
ExdiLiveKernelTargetInfo::WaitInitialize(ULONG Flags,
                                         ULONG Timeout,
                                         WAIT_INIT_TYPE Type,
                                         PULONG DesiredTimeout)
{
    *DesiredTimeout = Timeout;
    m_EventPossible = TRUE;
    return S_OK;
}

HRESULT
ExdiLiveKernelTargetInfo::ReleaseLastEvent(ULONG ContinueStatus)
{
    HRESULT Status;

    if (!g_EventProcessSysId)
    {
        // No event to release.
        return S_OK;
    }

    //
    // eXDI deals with hardware exceptions, not software
    // exceptions, so there's no concept of handled/not-handled
    // and first/second-chance.
    //

    if (g_EngDefer & ENG_DEFER_HARDWARE_TRACING)
    {
        // Processor trace flag was set.  eXDI can change
        // the trace flag itself, though, so use the
        // official eXDI stepping methods rather than
        // rely on the trace flag.  This will result
        // in a single instruction execution, after
        // which the trace flag will be clear so
        // go ahead and clear the defer flag.
        Status = m_Server->DoSingleStep();
        if (Status == S_OK)
        {
            g_EngDefer &= ~ENG_DEFER_HARDWARE_TRACING;
        }
    }
    else
    {
        Status = m_Server->Run();
    }
    if (Status != S_OK)
    {
        ErrOut("IeXdiServer::Run failed, 0x%X\n", Status);
    }
    return Status;
}

HRESULT
ExdiLiveKernelTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout,
                                       ULONG ElapsedTime, PULONG EventStatus)
{
    HRESULT Status;
    DWORD Cookie;

    if ((Status = m_Server->
         StartNotifyingRunChg(&m_RunChange, &Cookie)) != S_OK)
    {
        ErrOut("IeXdiServer::StartNotifyingRunChg failed, 0x%X\n", Status);
        return Status;
    }

    RUN_STATUS_TYPE RunStatus;

    if ((Status = m_Server->
         GetRunStatus(&RunStatus, &m_RunChange.m_HaltReason,
                      &m_RunChange.m_ExecAddress,
                      &m_RunChange.m_ExceptionCode)) != S_OK)
    {
        m_Server->StopNotifyingRunChg(Cookie);
        ErrOut("IeXdiServer::GetRunStatus failed, 0x%X\n", Status);
        return Status;
    }

    DWORD WaitStatus;

    if (RunStatus == rsRunning)
    {
        SUSPEND_ENGINE();

        // We need to run a message pump so COM
        // can deliver calls properly.
        for (;;)
        {
            if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
            {
                WaitStatus = WAIT_FAILED;
                SetLastError(ERROR_IO_PENDING);
                break;
            }

            WaitStatus = MsgWaitForMultipleObjects(1, &m_RunChange.m_Event,
                                                   FALSE, Timeout,
                                                   QS_ALLEVENTS);
            if (WaitStatus == WAIT_OBJECT_0 + 1)
            {
                MSG Msg;

                if (GetMessage(&Msg, NULL, 0, 0))
                {
                    TranslateMessage(&Msg);
                    DispatchMessage(&Msg);
                }
            }
            else
            {
                // We either successfully waited, timed-out or failed.
                // Break out to handle it.
                break;
            }
        }

        RESUME_ENGINE();
    }
    else
    {
        WaitStatus = WAIT_OBJECT_0;
    }

    m_Server->StopNotifyingRunChg(Cookie);
    // Make sure we're not leaving the event set.
    ResetEvent(m_RunChange.m_Event);

    if (WaitStatus == WAIT_TIMEOUT)
    {
        return S_FALSE;
    }
    else if (WaitStatus != WAIT_OBJECT_0)
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("WaitForSingleObject failed, 0x%X\n", Status);
        return Status;
    }

    EventOut(">>> RunChange halt reason %d\n",
             m_RunChange.m_HaltReason);

    if (!IS_MACHINE_SET(this))
    {
        dprintf("Kernel Debugger connection established\n");

        g_EventTarget = this;

        //
        // Try to figure out the processor configuration
        // via the defined Ioctl.
        //

        // Default to one.
        m_NumProcessors = 1;

        if (DBGENG_EXDI_IOC_IDENTIFY_PROCESSORS > m_IoctlMin &&
            DBGENG_EXDI_IOC_IDENTIFY_PROCESSORS < m_IoctlMax)
        {
            DBGENG_EXDI_IOCTL_BASE_IN IoctlIn;
            DBGENG_EXDI_IOCTL_IDENTIFY_PROCESSORS_OUT IoctlOut;
            ULONG OutUsed;

            IoctlIn.Code = DBGENG_EXDI_IOC_IDENTIFY_PROCESSORS;
            if (m_Server->
                Ioctl(sizeof(IoctlIn), (PBYTE)&IoctlIn,
                      sizeof(IoctlOut), &OutUsed, (PBYTE)&IoctlOut) == S_OK)
            {
                m_NumProcessors = IoctlOut.NumberProcessors;
            }
        }

        // eXDI kernels are always treated as Win2K so
        // it's assumed it uses the 64-bit API.
        if (m_KdSupport == EXDI_KD_NONE)
        {
            m_KdApi64 = TRUE;
            m_SystemVersion = NT_SVER_W2K;
        }

        if ((Status = InitFromKdVersion()) != S_OK)
        {
            DeleteSystemInfo();
            ResetSystemInfo();
            g_EventTarget = NULL;
            return Status;
        }

        CreateVirtualProcess(m_NumProcessors);

        g_EventProcessSysId = m_ProcessHead->m_SystemId;
        g_EventThreadSysId = VIRTUAL_THREAD_ID(GetCurrentProcessor());
        FindEventProcessThread();

        //
        // Load kernel symbols.
        //

        if (m_ActualSystemVersion > NT_SVER_START &&
            m_ActualSystemVersion < NT_SVER_END)
        {
            QueryKernelInfo(g_EventThread, TRUE);
        }
        else
        {
            // Initialize some debugger data fields from known
            // information as there isn't a real data block.
            m_KdDebuggerData.MmPageSize =
                m_Machine->m_PageSize;

            if (m_MachineType == IMAGE_FILE_MACHINE_AMD64)
            {
                // AMD64 always operates in PAE mode.
                m_KdDebuggerData.PaeEnabled = TRUE;
            }
        }

        // Now that we have the data block
        // we can retrieve processor information.
        InitializeForProcessor();

        OutputVersion();

        NotifyDebuggeeActivation();
    }
    else
    {
        g_EventTarget = this;
        g_EventProcessSysId = m_ProcessHead->m_SystemId;
        g_EventThreadSysId = VIRTUAL_THREAD_ID(GetCurrentProcessor());
        FindEventProcessThread();
    }

    g_TargetEventPc = m_RunChange.m_ExecAddress;
    g_ControlReport = NULL;
    g_StateChangeData = NULL;

    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    *EventStatus = ProcessRunChange(m_RunChange.m_HaltReason,
                                   m_RunChange.m_ExceptionCode);

    return S_OK;
}

ULONG
ExdiLiveKernelTargetInfo::ProcessRunChange(ULONG HaltReason,
                                           ULONG ExceptionCode)
{
    ULONG EventStatus;
    EXCEPTION_RECORD64 Record;
    DBGENG_EXDI_IOCTL_BASE_IN IoctlBaseIn;
    ULONG OutUsed;

    // Assume no breakpoint information.
    m_BpHit.Type = DBGENG_EXDI_IOCTL_BREAKPOINT_NONE;

    switch(HaltReason)
    {
    case hrUser:
    case hrUnknown:
        // User requested break in.
        // Unknown breakin also seems to be the status at power-up.
        EventStatus = DEBUG_STATUS_BREAK;
        break;

    case hrException:
        // Fake an exception record.
        ZeroMemory(&Record, sizeof(Record));
        // The exceptions reported are hardware exceptions so
        // there's no easy mapping to NT exception codes.
        // Just report them as access violations.
        Record.ExceptionCode = STATUS_ACCESS_VIOLATION;
        Record.ExceptionAddress = g_TargetEventPc;
        // Hardware exceptions are always severe so always
        // report them as second-chance.
        EventStatus = NotifyExceptionEvent(&Record, FALSE, FALSE);
        break;

    case hrBp:
        //
        // Try and get which breakpoint it was.
        //

        if (DBGENG_EXDI_IOC_GET_BREAKPOINT_HIT > m_IoctlMin &&
            DBGENG_EXDI_IOC_GET_BREAKPOINT_HIT < m_IoctlMax)
        {
            DBGENG_EXDI_IOCTL_GET_BREAKPOINT_HIT_OUT IoctlOut;

            IoctlBaseIn.Code = DBGENG_EXDI_IOC_GET_BREAKPOINT_HIT;
            if (m_Server->
                Ioctl(sizeof(IoctlBaseIn), (PBYTE)&IoctlBaseIn,
                      sizeof(IoctlOut), &OutUsed, (PBYTE)&IoctlOut) != S_OK)
            {
                m_BpHit.Type = DBGENG_EXDI_IOCTL_BREAKPOINT_NONE;
            }
        }

        // Fake a breakpoint exception record.
        ZeroMemory(&Record, sizeof(Record));
        Record.ExceptionCode = STATUS_BREAKPOINT;
        Record.ExceptionAddress = g_TargetEventPc;
        EventStatus = ProcessBreakpointOrStepException(&Record, TRUE);
        break;

    case hrStep:
        // Fake a single-step exception record.
        ZeroMemory(&Record, sizeof(Record));
        Record.ExceptionCode = STATUS_SINGLE_STEP;
        Record.ExceptionAddress = g_TargetEventPc;
        EventStatus = ProcessBreakpointOrStepException(&Record, TRUE);
        break;

    default:
        ErrOut("Unknown HALT_REASON %d\n", HaltReason);
        EventStatus = DEBUG_STATUS_BREAK;
        break;
    }

    return EventStatus;
}

//----------------------------------------------------------------------------
//
// UserTargetInfo wait methods.
//
//----------------------------------------------------------------------------

void
SynthesizeWakeEvent(LPDEBUG_EVENT64 Event,
                    ULONG ProcessId, ULONG ThreadId)
{
    // Fake up an event.
    ZeroMemory(Event, sizeof(*Event));
    Event->dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
    Event->dwProcessId = ProcessId;
    Event->dwThreadId = ThreadId;
    Event->u.Exception.ExceptionRecord.ExceptionCode =
        STATUS_WAKE_SYSTEM_DEBUGGER;
    Event->u.Exception.dwFirstChance = TRUE;
}

#define THREADS_ALLOC 256

HRESULT
CreateNonInvasiveProcessAndThreads(PUSER_DEBUG_SERVICES Services,
                                   ULONG ProcessId, ULONG Flags, ULONG Options,
                                   PULONG InitialThreadId)
{
    ULONG64 Process;
    PUSER_THREAD_INFO Threads, ThreadBuffer;
    ULONG ThreadsAlloc = 0;
    ULONG ThreadCount;
    HRESULT Status;
    ULONG i;
    ULONG ProcInfoFlags = (Flags & ENG_PROC_NO_SUSPEND_RESUME) ?
        DBGSVC_PROC_INFO_NO_SUSPEND : 0;

    //
    // Retrieve process and thread information.  This
    // requires a thread buffer of unknown size and
    // so involves a bit of trial and error.
    //

    for (;;)
    {
        ThreadsAlloc += THREADS_ALLOC;
        ThreadBuffer = new USER_THREAD_INFO[ThreadsAlloc];
        if (ThreadBuffer == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if ((Status = Services->GetProcessInfo(ProcessId, ProcInfoFlags,
                                               &Process, ThreadBuffer,
                                               ThreadsAlloc,
                                               &ThreadCount)) != S_OK &&
            Status != S_FALSE)
        {
            delete [] ThreadBuffer;
            return Status;
        }

        if (ThreadCount <= ThreadsAlloc)
        {
            break;
        }

        // The threads retrieved were suspended so resume them
        // and close handles.
        for (i = 0; i < ThreadsAlloc; i++)
        {
            if (!(Flags & ENG_PROC_NO_SUSPEND_RESUME))
            {
                Services->ResumeThreads(1, &ThreadBuffer[i].Handle, NULL);
            }
            Services->CloseHandle(ThreadBuffer[i].Handle);
        }
        delete [] ThreadBuffer;

        // Set the allocation request size to what the
        // reported count of threads was.  The count may
        // change between now and the next call so let
        // the normal allocation extension get added in
        // also to provide extra space for new threads.
        ThreadsAlloc = ThreadCount;
    }

    //
    // Create the process and thread structures from
    // the retrieved data.
    //

    Threads = ThreadBuffer;

    g_EngNotify++;

    // Create the fake kernel process and initial thread.
    g_EventProcessSysId = ProcessId;
    g_EventThreadSysId = Threads->Id;
    *InitialThreadId = Threads->Id;
    NotifyCreateProcessEvent(0, GloballyUniqueProcessHandle(g_EventTarget,
                                                            Process),
                             Process, 0, 0, NULL, NULL, 0, 0,
                             Threads->Handle, 0, 0,
                             Flags | ENG_PROC_THREAD_CLOSE_HANDLE,
                             Options, ENG_PROC_THREAD_CLOSE_HANDLE,
                             FALSE, 0, FALSE);

    // Create any remaining threads.
    while (--ThreadCount > 0)
    {
        Threads++;
        g_EventThreadSysId = Threads->Id;
        NotifyCreateThreadEvent(Threads->Handle, 0, 0,
                                ENG_PROC_THREAD_CLOSE_HANDLE);
    }

    g_EngNotify--;

    delete [] ThreadBuffer;

    // Don't leave event variables set as these
    // weren't true events.
    g_EventProcessSysId = 0;
    g_EventThreadSysId = 0;
    g_EventProcess = NULL;
    g_EventThread = NULL;

    return S_OK;
}

HRESULT
ExamineActiveProcess(PUSER_DEBUG_SERVICES Services,
                     ULONG ProcessId, ULONG Flags, ULONG Options,
                     LPDEBUG_EVENT64 Event)
{
    HRESULT Status;
    ULONG InitialThreadId;

    if ((Status = CreateNonInvasiveProcessAndThreads
         (Services, ProcessId, Flags, Options, &InitialThreadId)) != S_OK)
    {
        ErrOut("Unable to examine process id %d, %s\n",
               ProcessId, FormatStatusCode(Status));
        return Status;
    }

    if (Flags & ENG_PROC_EXAMINED)
    {
        WarnOut("WARNING: Process %d is not attached as a debuggee\n",
                ProcessId);
        WarnOut("         The process can be examined but debug "
                "events will not be received\n");
    }

    SynthesizeWakeEvent(Event, ProcessId, InitialThreadId);

    return S_OK;
}

// When waiting for an attach we check process status relatively
// frequently.  The overall timeout limit is also hard-coded
// as we expect some sort of debug event to always be delivered
// quickly.
#define ATTACH_PENDING_TIMEOUT 100
#define ATTACH_PENDING_TIMEOUT_LIMIT 60000

// When not waiting for an attach the wait only waits one second,
// then checks to see if things have changed in a way that
// affects the wait.  All timeouts are given in multiples of
// this interval.
#define DEFAULT_WAIT_TIMEOUT 1000

// A message is printed after this timeout interval to
// let the user know a break-in is pending.
#define PENDING_BREAK_IN_MESSAGE_TIMEOUT_LIMIT 3000

HRESULT
LiveUserTargetInfo::WaitInitialize(ULONG Flags,
                                   ULONG Timeout,
                                   WAIT_INIT_TYPE Type,
                                   PULONG DesiredTimeout)
{
    ULONG AllPend = m_AllPendingFlags;

    if (AllPend & ENG_PROC_ANY_ATTACH)
    {
        if (Type == WINIT_FIRST)
        {
            dprintf("*** wait with pending attach\n");
        }

        // While waiting for an attach we need to periodically
        // check and see if the process has exited so we
        // need to force a reasonably small timeout.
        *DesiredTimeout = ATTACH_PENDING_TIMEOUT;

        // Check and see if any of our pending processes
        // has died unexpectedly.
        VerifyPendingProcesses();
    }
    else
    {
        // We might be waiting on a break-in.  Keep timeouts moderate
        // to deal with apps hung with a lock that prevents
        // the break from happening.  The timeout is
        // still long enough so that no substantial amount
        // of CPU time is consumed.
        *DesiredTimeout = DEFAULT_WAIT_TIMEOUT;
    }

    m_DataBpAddrValid = FALSE;

    if (Type != WINIT_NOT_FIRST)
    {
        m_BreakInMessage = FALSE;
    }

    m_EventPossible = m_ProcessHead || m_ProcessPending;
    return S_OK;
}

HRESULT
LiveUserTargetInfo::ReleaseLastEvent(ULONG ContinueStatus)
{
    HRESULT Status;

    if (!g_EventTarget || !m_DeferContinueEvent)
    {
        return S_OK;
    }

    for (;;)
    {
        if ((Status = m_Services->
             ContinueEvent(ContinueStatus)) == S_OK)
        {
            break;
        }

        //
        // If we got an out of memory error, wait again
        //

        if (Status != E_OUTOFMEMORY)
        {
            ErrOut("IUserDebugServices::ContinueEvent failed "
                   "with status 0x%X\n", Status);
            return Status;
        }
    }

    m_DeferContinueEvent = FALSE;
    return S_OK;
}

HRESULT
LiveUserTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout,
                                 ULONG ElapsedTime, PULONG EventStatus)
{
    DEBUG_EVENT64 Event;
    HRESULT Status;
    ULONG EventUsed;
    BOOL ContinueDefer;
    BOOL BreakInTimeout;
    PPENDING_PROCESS Pending;
    ULONG PendingFlags = 0;
    ULONG PendingOptions = DEBUG_PROCESS_ONLY_THIS_PROCESS;
    ULONG ResumeProcId = 0;
    ULONG AllPend;
    BOOL InitSystem = FALSE;

    //
    // Check for partially initialized systems
    // and query for all the system information that is needed.
    // This needs to be done before the actual wait
    // or examine so that the information is available
    // for constructing processes and threads.
    //

    if (!m_MachinesInitialized)
    {
        if ((Status = InitFromServices()) != S_OK)
        {
            return Status;
        }

        InitSystem = TRUE;
    }

    AllPend = m_AllPendingFlags;

    //
    // There are two cases we want to handle timeouts for:
    // 1. Timeout for a basic attach.
    // 2. Timeout for a pending breakin.
    // If neither of these things can happen we don't
    // need to track delay time.  Once one of those two
    // things can happen we need to track delay time from
    // the first time they became possible.
    //

    if ((AllPend & ENG_PROC_ANY_ATTACH) ||
        (g_EngStatus & ENG_STATUS_PENDING_BREAK_IN))
    {
        if (m_WaitTimeBase == 0)
        {
            // Add one to avoid the case of ElapsedTime == 0
            // causing a reinit the next time around.
            m_WaitTimeBase = ElapsedTime + 1;
            ElapsedTime = 0;
        }
        else
        {
            // Adjust for + 1 in time base above.
            ElapsedTime++;
        }

        EventOut(">>> User elapsed time %d\n", ElapsedTime);
    }

    if ((AllPend & ENG_PROC_ANY_ATTACH) &&
        ElapsedTime >= ATTACH_PENDING_TIMEOUT_LIMIT)
    {
        // Assume that the process has some kind
        // of lock that's preventing the attach
        // from succeeding and just do a soft attach.
        AddExamineToPendingAttach();
    }

    // Refresh result of pending flags as they may have
    // changed above due to AddAllExamineToPendingAttach.
    if (m_AllPendingFlags & ENG_PROC_ANY_EXAMINE)
    {
        // If we're attaching noninvasively or reattaching
        // and still haven't done the work go ahead and do it now.
        Pending = FindPendingProcessByFlags(ENG_PROC_ANY_EXAMINE);
        if (Pending == NULL)
        {
            DBG_ASSERT(FALSE);
            return E_UNEXPECTED;
        }

        g_EventTarget = this;

        if ((Status = ExamineActiveProcess
             (m_Services, Pending->Id, Pending->Flags,
              Pending->Options, &Event)) != S_OK)
        {
            g_EventTarget = NULL;
            g_EventTarget = NULL;
            return Status;
        }

        // If we just started examining a process we
        // suspended all the threads during enumeration.
        // We need to resume them after the normal
        // SuspendExecution suspend to get the suspend
        // count back to normal.
        ResumeProcId = Pending->Id;

        PendingFlags = Pending->Flags;
        PendingOptions = Pending->Options;
        RemovePendingProcess(Pending);
        EventUsed = sizeof(Event);
        // This event is not a real continuable event.
        ContinueDefer = FALSE;
        BreakInTimeout = FALSE;
        goto WaitDone;
    }

    if (g_EngStatus & ENG_STATUS_PENDING_BREAK_IN)
    {
        if (!m_BreakInMessage &&
            ElapsedTime >= PENDING_BREAK_IN_MESSAGE_TIMEOUT_LIMIT)
        {
            dprintf("Break-in sent, waiting %d seconds...\n",
                    g_PendingBreakInTimeoutLimit);
            m_BreakInMessage = TRUE;
        }

        if (ElapsedTime >= g_PendingBreakInTimeoutLimit * 1000)
        {
            // Assume that the process has some kind
            // of lock that's preventing the break-in
            // exception from coming through and
            // just suspend to let the user look at things.
            if (!m_ProcessHead ||
                !m_ProcessHead->m_ThreadHead)
            {
                WarnOut("WARNING: Break-in timed out without "
                        "an available thread.  Rewaiting.\n");
                m_WaitTimeBase = 0;
            }
            else
            {
                WarnOut("WARNING: Break-in timed out, suspending.\n");
                WarnOut("         This is usually caused by "
                        "another thread holding the loader lock\n");
                SynthesizeWakeEvent(&Event,
                                    m_ProcessHead->m_SystemId,
                                    m_ProcessHead->m_ThreadHead->
                                    m_SystemId);
                EventUsed = sizeof(Event);
                ContinueDefer = FALSE;
                BreakInTimeout = TRUE;
                g_EngStatus &= ~ENG_STATUS_PENDING_BREAK_IN;
                Status = S_OK;
                g_EventTarget = this;
                goto WaitDone;
            }
        }
    }

    if (g_EngStatus & ENG_STATUS_EXIT_CURRENT_WAIT)
    {
        return E_PENDING;
    }
    else
    {
        SUSPEND_ENGINE();

        for (;;)
        {
            Status = m_Services->
                WaitForEvent(Timeout, &Event, sizeof(Event), &EventUsed);
            if (Status == E_OUTOFMEMORY)
            {
                // Allow memory pressure to ease and rewait.
                Sleep(50);
            }
            else
            {
                break;
            }
        }

        RESUME_ENGINE();

        if (Status == S_FALSE)
        {
            return Status;
        }
        else if (Status != S_OK)
        {
            ErrOut("IUserDebugServices::WaitForEvent failed "
                   "with status 0x%X\n", Status);
            return Status;
        }

        g_EventTarget = this;
    }

    ContinueDefer = TRUE;
    BreakInTimeout = FALSE;

 WaitDone:

    if (EventUsed == sizeof(DEBUG_EVENT32))
    {
        DEBUG_EVENT32 Event32 = *(DEBUG_EVENT32*)&Event;
        DebugEvent32To64(&Event32, &Event);
    }
    else if (EventUsed != sizeof(DEBUG_EVENT64))
    {
        ErrOut("Event data corrupt\n");
        return E_FAIL;
    }

    g_Target = g_EventTarget;

    m_DeferContinueEvent = ContinueDefer;
    m_BreakInTimeout = BreakInTimeout;

    EventOut(">>> Debug event %u for %X.%X\n",
             Event.dwDebugEventCode, Event.dwProcessId,
             Event.dwThreadId);

    g_EventProcessSysId = Event.dwProcessId;
    g_EventThreadSysId = Event.dwThreadId;

    // Look up the process and thread infos in the cases
    // where they already exist.
    if (Event.dwDebugEventCode != CREATE_PROCESS_DEBUG_EVENT &&
        Event.dwDebugEventCode != CREATE_THREAD_DEBUG_EVENT)
    {
        FindEventProcessThread();
    }

    if (Event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
    {
        // If we're being notified of a new process take
        // out the pending record for the process.
        Pending = FindPendingProcessById(g_EventProcessSysId);
        if (Pending == NULL &&
            (m_AllPendingFlags & ENG_PROC_SYSTEM))
        {
            // Assume that this is the system process
            // as we attached under a fake process ID so
            // we can't check for a true match.
            Pending = FindPendingProcessById(CSRSS_PROCESS_ID);
        }

        if (Pending != NULL)
        {
            PendingFlags = Pending->Flags;
            PendingOptions = Pending->Options;

            if (Pending->Flags & ENG_PROC_ATTACHED)
            {
                VerbOut("*** attach succeeded\n");

                // If we're completing a full attach
                // we are now a fully active debugger.
                PendingFlags &= ~ENG_PROC_EXAMINED;

                // Expect a break-in if a break thread
                // was injected.
                if (!(PendingFlags & ENG_PROC_NO_INITIAL_BREAK))
                {
                    g_EngStatus |= ENG_STATUS_PENDING_BREAK_IN;
                }

                // If the process should be resumed
                // mark that and it will happen just
                // before leaving this routine.
                if (PendingFlags & ENG_PROC_RESUME_AT_ATTACH)
                {
                    ResumeProcId = Pending->Id;
                }
            }

            RemovePendingProcess(Pending);
        }
    }

    if (PendingFlags & ENG_PROC_ANY_EXAMINE)
    {
        PCSTR ArgsRet;

        // We're examining the process rather than
        // debugging it, so no module load events
        // are going to come through.  Reload from
        // the system module list.  This needs
        // to work even if there isn't a path.
        Reload(g_EventThread, "-s -P", &ArgsRet);
    }

    if (InitSystem)
    {
        NotifyDebuggeeActivation();
    }

    if ((Event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT ||
         Event.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT) &&
        (m_ServiceFlags & DBGSVC_CLOSE_PROC_THREAD_HANDLES))
    {
        PendingFlags |= ENG_PROC_THREAD_CLOSE_HANDLE;
    }

    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    *EventStatus = ProcessDebugEvent(&Event, PendingFlags, PendingOptions);

    // If we have an extra suspend count resume it out now
    // that any normal suspends have been done and it's safe
    // to remove the excess suspend.
    if (ResumeProcId)
    {
        ProcessInfo* ExamProc =
            FindProcessBySystemId(ResumeProcId);

        // If we did a no-suspend examine we don't have the
        // extra count, so suspend first and then resume to
        // get accurate suspend counts for the threads.
        // Be careful not to do this in the self-attach case
        // as the suspend will hang things.
        if (PendingFlags & ENG_PROC_NO_SUSPEND_RESUME)
        {
            if (ResumeProcId != GetCurrentProcessId())
            {
                SuspendResumeThreads(ExamProc, TRUE, NULL);
                SuspendResumeThreads(ExamProc, FALSE, NULL);
            }
        }
        else
        {
            SuspendResumeThreads(ExamProc, FALSE, NULL);
        }
    }

    return S_OK;
}

ULONG
LiveUserTargetInfo::ProcessDebugEvent(DEBUG_EVENT64* Event,
                                      ULONG PendingFlags,
                                      ULONG PendingOptions)
{
    ULONG EventStatus;
    CHAR NameBuffer[MAX_IMAGE_PATH];
    ULONG ModuleSize, CheckSum, TimeDateStamp;
    char ModuleName[MAX_MODULE];

    switch(Event->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
        LoadWow64ExtsIfNeeded(Event->u.CreateProcessInfo.hProcess);

        EventStatus = NotifyCreateProcessEvent(
            (ULONG64)Event->u.CreateProcessInfo.hFile,
            GloballyUniqueProcessHandle(g_EventTarget,
                                        (ULONG64)
                                        Event->u.CreateProcessInfo.hProcess),
            (ULONG64)Event->u.CreateProcessInfo.hProcess,
            (ULONG64)Event->u.CreateProcessInfo.lpBaseOfImage,
            0, NULL, NULL, 0, 0,
            (ULONG64)Event->u.CreateProcessInfo.hThread,
            (ULONG64)Event->u.CreateProcessInfo.lpThreadLocalBase,
            (ULONG64)Event->u.CreateProcessInfo.lpStartAddress,
            PendingFlags, PendingOptions,
            (PendingFlags & ENG_PROC_THREAD_CLOSE_HANDLE) ?
            ENG_PROC_THREAD_CLOSE_HANDLE : 0,
            TRUE,
            Event->u.CreateProcessInfo.lpImageName,
            Event->u.CreateProcessInfo.fUnicode);
        break;

    case EXIT_PROCESS_DEBUG_EVENT:
        if (g_EventProcess == NULL)
        {
            // Assume that this unmatched exit process event is a leftover
            // from a previous restart and just ignore it.
            WarnOut("Ignoring unknown process exit for %X\n",
                    g_EventProcessSysId);
            EventStatus = DEBUG_STATUS_IGNORE_EVENT;
        }
        else
        {
            EventStatus =
                NotifyExitProcessEvent(Event->u.ExitProcess.dwExitCode);
        }
        break;

    case CREATE_THREAD_DEBUG_EVENT:
        EventStatus = NotifyCreateThreadEvent(
            (ULONG64)Event->u.CreateThread.hThread,
            (ULONG64)Event->u.CreateThread.lpThreadLocalBase,
            (ULONG64)Event->u.CreateThread.lpStartAddress,
            PendingFlags);
        break;

    case EXIT_THREAD_DEBUG_EVENT:
        EventStatus = NotifyExitThreadEvent(Event->u.ExitThread.dwExitCode);
        break;

    case LOAD_DLL_DEBUG_EVENT:
        strcpy(NameBuffer, "no_process");
        GetEventName(Event->u.LoadDll.hFile,
                     Event->u.LoadDll.lpBaseOfDll,
                     Event->u.LoadDll.lpImageName,
                     Event->u.LoadDll.fUnicode,
                     NameBuffer, sizeof(NameBuffer));

        GetHeaderInfo(g_EventProcess,
                      (ULONG64)Event->u.LoadDll.lpBaseOfDll,
                      &CheckSum, &TimeDateStamp, &ModuleSize);
        CreateModuleNameFromPath(NameBuffer, ModuleName);

        EventStatus = NotifyLoadModuleEvent(
            (ULONG64)Event->u.LoadDll.hFile,
            (ULONG64)Event->u.LoadDll.lpBaseOfDll,
            ModuleSize, ModuleName, NameBuffer, CheckSum, TimeDateStamp,
            TRUE);
        break;

    case UNLOAD_DLL_DEBUG_EVENT:
        EventStatus = NotifyUnloadModuleEvent(
            NULL, (ULONG64)Event->u.UnloadDll.lpBaseOfDll);
        break;

    case OUTPUT_DEBUG_STRING_EVENT:
        EventStatus = OutputEventDebugString(&Event->u.DebugString);
        break;

    case RIP_EVENT:
        EventStatus = NotifySystemErrorEvent(Event->u.RipInfo.dwError,
                                             Event->u.RipInfo.dwType);
        break;

    case EXCEPTION_DEBUG_EVENT:
        EventStatus = ProcessEventException(Event);
        break;

    default:
        WarnOut("Unknown event number 0x%08lx\n",
                Event->dwDebugEventCode);
        EventStatus = DEBUG_STATUS_BREAK;
        break;
    }

    return EventStatus;
}

#define ISTS() (!!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)))
#define FIRST_CHANCE     Event->u.Exception.dwFirstChance

ULONG
LiveUserTargetInfo::ProcessEventException(DEBUG_EVENT64* Event)
{
    ULONG ExceptionCode;
    ULONG EventStatus;
    BOOL OutputDone = FALSE;
    ImageInfo* Image;

    ExceptionCode = Event->u.Exception.ExceptionRecord.ExceptionCode;
    g_TargetEventPc = (ULONG64)
        Event->u.Exception.ExceptionRecord.ExceptionAddress;

    EventOut("Exception %X at %p\n", ExceptionCode, g_TargetEventPc);

    //
    // If we are debugging a crashed process, force the
    // desktop we are on to the front so the user will know
    // what happened.
    //
    if (g_EventToSignal != NULL &&
        !ISTS() &&
        !AnySystemProcesses(FALSE))
    {
        if (InitDynamicCalls(&g_User32CallsDesc) == S_OK &&
            g_User32Calls.SwitchDesktop != NULL          &&
            g_User32Calls.GetThreadDesktop != NULL       &&
            g_User32Calls.CloseDesktop != NULL)
        {
            HDESK hDesk;

            hDesk = g_User32Calls.GetThreadDesktop(::GetCurrentThreadId());
            g_User32Calls.SwitchDesktop(hDesk);
            g_User32Calls.CloseDesktop(hDesk);
        }
    }

    if (g_EventThread && ExceptionCode == STATUS_VDM_EVENT)
    {
        ULONG ulRet = VDMEvent(Event);

        switch(ulRet)
        {
        case VDMEVENT_NOT_HANDLED:
            EventStatus = DEBUG_STATUS_GO_NOT_HANDLED;
            break;
        case VDMEVENT_HANDLED:
            EventStatus = DEBUG_STATUS_GO_HANDLED;
            break;
        default:
            // Give vdm code the option of mutating this into
            // a standard exception (like STATUS_BREAKPOINT)
            ExceptionCode = ulRet;
            break;
        }
    }

    switch(ExceptionCode)
    {
    case STATUS_BREAKPOINT:
    case STATUS_SINGLE_STEP:
    case STATUS_WX86_BREAKPOINT:
    case STATUS_WX86_SINGLE_STEP:
        if (!g_EventThread)
        {
            goto NotifyException;
        }
        EventStatus = ProcessBreakpointOrStepException
            (&Event->u.Exception.ExceptionRecord, FIRST_CHANCE);
        break;

    case STATUS_VDM_EVENT:
        if (!g_EventThread)
        {
            goto NotifyException;
        }
        // do nothing, it's already handled
        EventStatus = DEBUG_STATUS_IGNORE_EVENT;
        break;

    case STATUS_ACCESS_VIOLATION:
        if (FIRST_CHANCE &&
            g_EventProcess &&
            (Image = g_EventProcess->
             FindImageByOffset(Event->u.Exception.
                               ExceptionRecord.ExceptionAddress, FALSE)) &&
            !_stricmp(Image->m_ModuleName, "ntdll"))
        {
            CHAR ExSym[MAX_SYMBOL_LEN];
            LPSTR Scan;
            ULONG64 ExDisp;

            //
            // Ignore AVs that are expected in system code.
            //

            GetSymbol(Event->u.Exception.ExceptionRecord.ExceptionAddress,
                      ExSym, sizeof(ExSym), &ExDisp);

            Scan = ExSym;
            if (!_strnicmp(Scan, "ntdll!", 6))
            {
                Scan += 6;
                if (*Scan == '_')
                {
                    Scan += 1;
                }

                // This option allows new 3.51 binaries to run under
                // this debugger on old 3.1, 3.5 systems and avoid stopping
                // at access violations inside LDR that will be handled
                // by the LDR anyway.
                if ((g_EngOptions & DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS) &&
                    (!_stricmp(Scan, "LdrpSnapThunk") ||
                     !_stricmp(Scan, "LdrpWalkImportDescriptor")))
                {
                    EventStatus = DEBUG_STATUS_GO_NOT_HANDLED;
                    break;
                }

                // The interlocked SList code has a by-design faulting
                // case, so ignore AVs at that particular symbol.
                if ((ExDisp == 0 &&
                     !_stricmp(Scan, "ExpInterlockedPopEntrySListFault")) ||
                    (m_ActualSystemVersion == NT_SVER_W2K &&
                     !_stricmp(Scan, "RtlpInterlockedPopEntrySList")))
                {
                    EventStatus = DEBUG_STATUS_GO_NOT_HANDLED;
                    break;
                }
            }
        }
        goto NotifyException;

    case STATUS_POSSIBLE_DEADLOCK:
        if (m_PlatformId == VER_PLATFORM_WIN32_NT)
        {
            DBG_ASSERT(IS_USER_TARGET(g_EventTarget));
            AnalyzeDeadlock(&Event->u.Exception.ExceptionRecord,
                            FIRST_CHANCE);
        }
        else
        {
            OutputDeadlock(&Event->u.Exception.ExceptionRecord,
                           FIRST_CHANCE);
        }

        OutputDone = TRUE;
        goto NotifyException;

    default:
        {
        NotifyException:
            EventStatus =
                NotifyExceptionEvent(&Event->u.Exception.ExceptionRecord,
                                     Event->u.Exception.dwFirstChance,
                                     OutputDone);
        }
        break;
    }

    //
    // Do this for all exceptions, just in case some other
    // thread caused an exception before we get around to
    // handling the breakpoint event.
    //
    g_EngDefer |= ENG_DEFER_SET_EVENT;

    return EventStatus;
}

#undef FIRST_CHANCE

#define INPUT_API_SIG 0xdefaced

typedef struct _hdi
{
    DWORD   dwSignature;
    BYTE    cLength;
    BYTE    cStatus;
} HDI;

ULONG
LiveUserTargetInfo::OutputEventDebugString(OUTPUT_DEBUG_STRING_INFO64* Info)
{
    LPSTR Str, Str2;
    ULONG dwNumberOfBytesRead;
    HDI hdi;
    ULONG EventStatus = DEBUG_STATUS_IGNORE_EVENT;

    if (Info->nDebugStringLength == 0)
    {
        return EventStatus;
    }

    Str = (PSTR)calloc(1, Info->nDebugStringLength);
    if (Str == NULL)
    {
        ErrOut("Unable to allocate debug output buffer\n");
        return EventStatus;
    }

    if (ReadVirtual(g_EventProcess,
                    Info->lpDebugStringData, Str,
                    Info->nDebugStringLength,
                    &dwNumberOfBytesRead) == S_OK &&
        (dwNumberOfBytesRead == (SIZE_T)Info->nDebugStringLength))
    {
        //
        // Special processing for hacky debug input string
        //

        if (ReadVirtual(g_EventProcess,
                        Info->lpDebugStringData +
                        Info->nDebugStringLength,
                        &hdi, sizeof(hdi),
                        &dwNumberOfBytesRead) == S_OK &&
            dwNumberOfBytesRead == sizeof(hdi) &&
            hdi.dwSignature == INPUT_API_SIG)
        {
            StartOutLine(DEBUG_OUTPUT_DEBUGGEE_PROMPT, OUT_LINE_NO_PREFIX);
            MaskOut(DEBUG_OUTPUT_DEBUGGEE_PROMPT, "%s", Str);

            Str2 = (PSTR)calloc(1, hdi.cLength + 1);
            if (Str2)
            {
                GetInput(NULL, Str2, hdi.cLength, GETIN_DEFAULT);
                WriteVirtual(g_EventProcess,
                             Info->lpDebugStringData + 6,
                             Str2, (DWORD)hdi.cLength, NULL);
                free(Str2);
            }
            else
            {
                ErrOut("Unable to allocate prompt buffer\n");
            }
        }
        else if (g_OutputCommandRedirectPrefixLen &&
                 !_strnicmp(g_OutputCommandRedirectPrefix, Str,
                            g_OutputCommandRedirectPrefixLen))
        {
            PSTR Command = Str + g_OutputCommandRedirectPrefixLen;
            _snprintf(g_LastEventDesc, sizeof(g_LastEventDesc) - 1,
                      "%.48s command: '%.192s'",
                      g_OutputCommandRedirectPrefix, Command);
            EventStatus = ExecuteEventCommand(DEBUG_STATUS_NO_CHANGE, NULL,
                                              Command);

            // Break in if the command didn't explicitly continue.
            if (EventStatus == DEBUG_STATUS_NO_CHANGE)
            {
                EventStatus = DEBUG_STATUS_BREAK;
            }
        }
        else
        {
            StartOutLine(DEBUG_OUTPUT_DEBUGGEE, OUT_LINE_NO_PREFIX);
            MaskOut(DEBUG_OUTPUT_DEBUGGEE, "%s", Str);

            EVENT_FILTER* Filter =
                &g_EventFilters[DEBUG_FILTER_DEBUGGEE_OUTPUT];
            if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                BreakOnThisOutString(Str))
            {
                EventStatus = DEBUG_STATUS_BREAK;
            }
        }
    }
    else
    {
        ErrOut("Unable to read debug output string, %d\n",
               GetLastError());
    }

    free(Str);
    return EventStatus;
}

//----------------------------------------------------------------------------
//
// DumpTargetInfo wait methods.
//
//----------------------------------------------------------------------------

HRESULT
KernelDumpTargetInfo::FirstEvent(void)
{
    HRESULT Status;
    ULONG i;

    CreateVirtualProcess(m_NumProcessors);

    QueryKernelInfo(m_ProcessHead->m_ThreadHead, TRUE);
    OutputVersion();

    if (!IS_KERNEL_TRIAGE_DUMP(this))
    {
        if (m_KdDebuggerData.KiProcessorBlock)
        {
            ULONG PtrSize = m_Machine->m_Ptr64 ?
                sizeof(ULONG64) : sizeof(ULONG);

            for (i = 0; i < m_NumProcessors; i++)
            {
                Status =
                    ReadPointer(g_EventProcess, m_Machine,
                                m_KdDebuggerData.KiProcessorBlock +
                                i * PtrSize, &m_KiProcessors[i]);
                if (Status != S_OK || !m_KiProcessors[i])
                {
                    ErrOut("KiProcessorBlock[%d] could not be read\n", i);
                    return Status != S_OK ? Status : E_FAIL;
                }
            }
        }
    }

    // Clear the global state change just in case somebody's
    // directly accessing it somewhere.
    ZeroMemory(&g_StateChange, sizeof(g_StateChange));
    g_StateChangeData = g_StateChangeBuffer;
    g_StateChangeBuffer[0] = 0;

    return S_OK;
}

HRESULT
UserDumpTargetInfo::FirstEvent(void)
{
    ULONG i;
    ULONG Suspend;
    ULONG64 Teb;

    if (GetProductInfo(&m_ProductType, &m_SuiteMask) != S_OK)
    {
        m_ProductType = INVALID_PRODUCT_TYPE;
        m_SuiteMask = 0;
    }

    OutputVersion();

    // Create the process.
    g_EventProcessSysId = m_EventProcessId;
    if (GetThreadInfo(0, &g_EventThreadSysId,
                      &Suspend, &Teb) != S_OK)
    {
        // Dump doesn't contain thread information so
        // fake it.
        g_EventThreadSysId = VIRTUAL_THREAD_ID(0);
        Suspend = 0;
        Teb = 0;
    }

    EventOut("User dump process %x.%x with %u threads\n",
             g_EventProcessSysId, g_EventThreadSysId,
             m_ThreadCount);

    NotifyCreateProcessEvent(0,
                             m_EventProcessSymHandle,
                             (ULONG64)
                             VIRTUAL_PROCESS_HANDLE(g_EventProcessSysId),
                             0, 0, NULL, NULL, 0, 0,
                             (ULONG64)VIRTUAL_THREAD_HANDLE(0),
                             Teb, 0, 0, DEBUG_PROCESS_ONLY_THIS_PROCESS,
                             0, FALSE, 0, FALSE);
    // Update thread suspend count from dump info.
    g_EventThread->m_SuspendCount = Suspend;

    // Create any remaining threads.
    for (i = 1; i < m_ThreadCount; i++)
    {
        GetThreadInfo(i, &g_EventThreadSysId, &Suspend, &Teb);

        EventOut("User dump thread %d: %x\n", i, g_EventThreadSysId);

        NotifyCreateThreadEvent((ULONG64)VIRTUAL_THREAD_HANDLE(i),
                                Teb, 0, 0);
        // Update thread suspend count from dump info.
        g_EventThread->m_SuspendCount = Suspend;
    }

    return S_OK;
}

HRESULT
DumpTargetInfo::WaitInitialize(ULONG Flags,
                               ULONG Timeout,
                               WAIT_INIT_TYPE Type,
                               PULONG DesiredTimeout)
{
    *DesiredTimeout = Timeout;
    m_EventPossible = m_FirstWait;
    return S_OK;
}

HRESULT
DumpTargetInfo::WaitForEvent(ULONG Flags, ULONG Timeout,
                             ULONG ElapsedTime, PULONG EventStatus)
{
    HRESULT Status;
    BOOL HaveContext = FALSE;

    if (m_NumEvents == 1 && !m_FirstWait)
    {
        // A wait has already been done.  Most crash dumps
        // can only generate a single event so further
        // waiting is not possible.
        return S_FALSE;
    }

    g_EventTarget = this;

    if (m_FirstWait)
    {
        //
        // This is the first wait.  Simulate any
        // necessary events such as process and thread
        // creations and image loads.
        //

        // Don't give real callbacks for processes/threads as
        // they're just faked in the dump case.
        g_EngNotify++;

        if ((Status = FirstEvent()) != S_OK)
        {
            g_EngNotify--;
            return Status;
        }
    }

    if (IS_KERNEL_TARGET(this))
    {
        ULONG CurProc = ((KernelDumpTargetInfo*)this)->GetCurrentProcessor();
        if (CurProc == (ULONG)-1)
        {
            WarnOut("Could not determine the current processor, "
                    "using zero\n");
            CurProc = 0;
        }

        // Always set up an event so that the debugger
        // initializes to the point of having a process
        // and thread so commands can be used.
        g_EventProcessSysId =
            g_EventTarget->m_ProcessHead->m_SystemId;
        g_EventThreadSysId = VIRTUAL_THREAD_ID(CurProc);

        HaveContext = IS_KERNEL_TRIAGE_DUMP(this) ||
            g_EventTarget->m_KdDebuggerData.KiProcessorBlock;

        if (HaveContext &&
            (g_EventTarget->m_MachineType == IMAGE_FILE_MACHINE_I386 ||
             g_EventTarget->m_MachineType == IMAGE_FILE_MACHINE_IA64) &&
            !IS_KERNEL_TRIAGE_DUMP(g_EventTarget))
        {
            //
            // Reset the page directory correctly since NT 4 stores
            // the wrong CR3 value in the context.
            //
            // IA64 dumps start out with just the kernel page
            // directory set so update everything.
            //

            FindEventProcessThread();
            g_EventTarget->ChangeRegContext(g_EventThread);
            if (g_EventTarget->m_Machine->
                SetDefaultPageDirectories(g_EventThread, PAGE_DIR_ALL) != S_OK)
            {
                WarnOut("WARNING: Unable to reset page directories\n");
            }
            g_EventTarget->ChangeRegContext(NULL);
            // Flush the cache just in case as vmem mappings changed.
            g_EventProcess->m_VirtualCache.Empty();
        }
    }
    else
    {
        UserDumpTargetInfo* UserDump = (UserDumpTargetInfo*)g_EventTarget;
        g_EventProcessSysId = UserDump->m_EventProcessId;
        g_EventThreadSysId = UserDump->m_EventThreadId;

        HaveContext = TRUE;

        EventOut("User dump event on %x.%x\n",
                 g_EventProcessSysId, g_EventThreadSysId);
    }

    // Do not provide a control report; this will force
    // such information to come from context retrieval.
    g_ControlReport = NULL;

    g_TargetEventPc = (ULONG64)m_ExceptionRecord.ExceptionAddress;

    g_EngStatus |= ENG_STATUS_STATE_CHANGED;

    FindEventProcessThread();
    if (HaveContext)
    {
        g_EventTarget->ChangeRegContext(g_EventThread);
    }

    //
    // Go ahead and reload all the symbols.
    // This is especially important for minidumps because without
    // symbols and the executable image, we can't unassemble the
    // current instruction.
    //
    // If we don't have any context information we need to try
    // and load symbols with whatever we've got, so skip any
    // path checks.  Also, if we're on XP or newer there's enough
    // information in the dump to get things running even without
    // symbols, so don't fail on paths checks then either.
    //

    BOOL CheckPaths = TRUE;

    if (!HaveContext ||
        IS_USER_DUMP(this) ||
        (g_EventTarget->m_ActualSystemVersion >= NT_SVER_XP &&
         g_EventTarget->m_ActualSystemVersion < NT_SVER_END))
    {
        CheckPaths = FALSE;
    }

    PCSTR ArgsRet;

    Status = g_EventTarget->Reload(g_EventThread, CheckPaths ? "" : "-P",
                                   &ArgsRet);

    g_EventTarget->ChangeRegContext(NULL);

    // The engine is now initialized so a real event
    // can be generated.
    g_EngNotify--;

    if (HaveContext && Status != S_OK)
    {
        return Status;
    }

    if (m_FirstWait)
    {
        if (IS_USER_TARGET(this))
        {
            SetKernel32BuildString(m_ProcessHead);
            if (IS_USER_FULL_DUMP(this))
            {
                m_ProcessHead->VerifyKernel32Version();
            }
        }

        NotifyDebuggeeActivation();
    }

    NotifyExceptionEvent(&m_ExceptionRecord, m_ExceptionFirstChance,
                         m_ExceptionRecord.ExceptionCode ==
                         STATUS_BREAKPOINT ||
                         m_ExceptionRecord.ExceptionCode ==
                         STATUS_WX86_BREAKPOINT);

    *EventStatus = DEBUG_STATUS_BREAK;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Event filters.
//
//----------------------------------------------------------------------------

void
ParseImageTail(PSTR Buffer, ULONG BufferSize)
{
    int i;
    char ch;

    Buffer[0] = '\0';

    i = 0;
    while (ch = (char)tolower(*g_CurCmd))
    {
        if (ch == ' ' || ch == '\t' || ch == ';')
        {
            break;
        }

        // Only capture the path tail.
        if (IS_SLASH(ch) || ch == ':')
        {
            i = 0;
        }
        else
        {
            Buffer[i++] = ch;
            if (i == BufferSize - 1)
            {
                // don't overrun the buffer
                break;
            }
        }

        g_CurCmd++;
    }

    Buffer[i] = '\0';
}

void
ParseUnloadDllBreakAddr(void)
/*++

Routine Description:

    Called after 'sxe ud' has been parsed.  This routine detects an
    optional DLL base address after the 'sxe ud', which tells the debugger
    to run until that specific DLL is unloaded, not just the next DLL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR ch;

    g_UnloadDllBase = 0;
    g_UnloadDllBaseName[0] = 0;

    while (ch = (UCHAR)tolower(*g_CurCmd))
    {
        if (ch == ' ')
        {
            break;
        }

        // Skip leading ':'
        if (ch != ':')
        {
            //  Get the base address
            g_UnloadDllBase = GetExpression();
            sprintf(g_UnloadDllBaseName, "0x%s",
                    FormatAddr64(g_UnloadDllBase));
            break;
        }
        g_CurCmd++;
    }
}

void
ParseOutFilterPattern(void)
{
    int i;
    char ch;

    i = 0;
    while (ch = (char)tolower(*g_CurCmd))
    {
        if (ch == ' ')
        {
            break;
        }

        if (ch == ':')
        {
            i = 0;
        }
        else
        {
            g_OutEventFilterPattern[i++] = (char)toupper(ch);
            if (i == sizeof(g_OutEventFilterPattern) - 1)
            {
                // Don't overrun the buffer.
                break;
            }
        }

        g_CurCmd++;
    }

    g_OutEventFilterPattern[i] = 0;
}

BOOL
BreakOnThisImageTail(PCSTR ImagePath, PCSTR FilterArg)
{
    //
    // No filter specified so break on all events.
    //
    if (!FilterArg || !FilterArg[0])
    {
        return TRUE;
    }

    //
    // Some kind of error looking up the image path.  Break anyhow.
    //
    if (!ImagePath || !ImagePath[0])
    {
        return TRUE;
    }

    PCSTR Tail = PathTail(ImagePath);

    //
    // Specified name may not have an extension.  Break
    // on the first event whose name matches regardless of its extension if
    // the break name did not have one.
    //
    if (_strnicmp(Tail, FilterArg, strlen(FilterArg)) == 0)
    {
        return TRUE;
    }
    else if (MatchPattern((PSTR)Tail, (PSTR)FilterArg))
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
BreakOnThisDllUnload(
    ULONG64 DllBase
    )
{
    // 'sxe ud' with no base address specified.  Break on all DLL unloads
    if (g_UnloadDllBase == 0)
    {
        return TRUE;
    }

    // 'sxe ud' with base address specified.  Break if this
    // DLL's base address matches the one specified
    return g_UnloadDllBase == DllBase;
}

BOOL
BreakOnThisOutString(PCSTR OutString)
{
    if (!g_OutEventFilterPattern[0])
    {
        // No pattern means always break.
        return TRUE;
    }

    return MatchPattern((PSTR)OutString, g_OutEventFilterPattern);
}

EVENT_FILTER*
GetSpecificExceptionFilter(ULONG Code)
{
    ULONG i;
    EVENT_FILTER* Filter;

    Filter = g_EventFilters + FILTER_EXCEPTION_FIRST;
    for (i = FILTER_EXCEPTION_FIRST; i <= FILTER_EXCEPTION_LAST; i++)
    {
        if (i != FILTER_DEFAULT_EXCEPTION &&
            Filter->Params.ExceptionCode == Code)
        {
            return Filter;
        }

        Filter++;
    }

    return NULL;
}

ULONG
GetOtherExceptionParameters(ULONG Code, BOOL DefaultOnNotFound,
                            PDEBUG_EXCEPTION_FILTER_PARAMETERS* Params,
                            EVENT_COMMAND** Command)
{
    ULONG Index;

    for (Index = 0; Index < g_NumOtherExceptions; Index++)
    {
        if (Code == g_OtherExceptionList[Index].ExceptionCode)
        {
            *Params = g_OtherExceptionList + Index;
            *Command = g_OtherExceptionCommands + Index;
            return NO_ERROR;
        }
    }

    if (DefaultOnNotFound)
    {
        *Params = &g_EventFilters[FILTER_DEFAULT_EXCEPTION].Params;
        *Command = &g_EventFilters[FILTER_DEFAULT_EXCEPTION].Command;
        return NO_ERROR;
    }
    else if (g_NumOtherExceptions == OTHER_EXCEPTION_LIST_MAX)
    {
        return LISTSIZE;
    }
    else
    {
        Index = g_NumOtherExceptions++;
        g_OtherExceptionList[Index] =
            g_EventFilters[FILTER_DEFAULT_EXCEPTION].Params;
        g_OtherExceptionList[Index].ExceptionCode = Code;
        ZeroMemory(&g_OtherExceptionCommands[Index],
                   sizeof(g_OtherExceptionCommands[Index]));
        *Params = g_OtherExceptionList + Index;
        *Command = g_OtherExceptionCommands + Index;
        return NO_ERROR;
    }
}

ULONG
SetOtherExceptionParameters(PDEBUG_EXCEPTION_FILTER_PARAMETERS Params,
                            EVENT_COMMAND* Command)
{
    ULONG Index;

    if (g_EventFilters[FILTER_DEFAULT_EXCEPTION].
        Params.ExecutionOption == Params->ExecutionOption &&
        g_EventFilters[FILTER_DEFAULT_EXCEPTION].
        Params.ContinueOption == Params->ContinueOption &&
        !memcmp(&g_EventFilters[FILTER_DEFAULT_EXCEPTION].Command,
                Command, sizeof(*Command)))
    {
        // Exception state same as global state clears entry
        // in list if there.

        for (Index = 0; Index < g_NumOtherExceptions; Index++)
        {
            if (Params->ExceptionCode ==
                g_OtherExceptionList[Index].ExceptionCode)
            {
                RemoveOtherException(Index);
                NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS,
                                        DEBUG_ANY_ID, TRUE);
                break;
            }
        }
    }
    else
    {
        // Exception state different from global state is added
        // to list if not already there.

        for (Index = 0; Index < g_NumOtherExceptions; Index++)
        {
            if (Params->ExceptionCode ==
                g_OtherExceptionList[Index].ExceptionCode)
            {
                break;
            }
        }
        if (Index == g_NumOtherExceptions)
        {
            if (g_NumOtherExceptions == OTHER_EXCEPTION_LIST_MAX)
            {
                return LISTSIZE;
            }

            Index = g_NumOtherExceptions++;
        }

        g_OtherExceptionList[Index] = *Params;
        g_OtherExceptionCommands[Index] = *Command;
        NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, Index, TRUE);
    }

    return 0;
}

void
RemoveOtherException(ULONG Index)
{
    g_NumOtherExceptions--;
    memmove(g_OtherExceptionList + Index,
            g_OtherExceptionList + Index + 1,
            (g_NumOtherExceptions - Index) *
            sizeof(g_OtherExceptionList[0]));
    delete [] g_OtherExceptionCommands[Index].Command[0];
    delete [] g_OtherExceptionCommands[Index].Command[1];
    memmove(g_OtherExceptionCommands + Index,
            g_OtherExceptionCommands + Index + 1,
            (g_NumOtherExceptions - Index) *
            sizeof(g_OtherExceptionCommands[0]));
}

ULONG
SetEventFilterExecution(EVENT_FILTER* Filter, ULONG Execution)
{
    ULONG Index = (ULONG)(Filter - g_EventFilters);

    // Non-exception events don't have second chances so
    // demote second-chance break to output.  This matches
    // the intuitive expectation that sxd will disable
    // the break.
    if (
#if DEBUG_FILTER_CREATE_THREAD > 0
        Index >= DEBUG_FILTER_CREATE_THREAD &&
#endif
        Index <= DEBUG_FILTER_SYSTEM_ERROR &&
        Execution == DEBUG_FILTER_SECOND_CHANCE_BREAK)
    {
        Execution = DEBUG_FILTER_OUTPUT;
    }

    Filter->Params.ExecutionOption = Execution;
    Filter->Flags |= FILTER_CHANGED_EXECUTION;

    // Collect any additional arguments.
    switch(Index)
    {
    case DEBUG_FILTER_CREATE_PROCESS:
    case DEBUG_FILTER_EXIT_PROCESS:
    case DEBUG_FILTER_LOAD_MODULE:
        ParseImageTail(Filter->Argument, FILTER_MAX_ARGUMENT);
        break;

    case DEBUG_FILTER_UNLOAD_MODULE:
        ParseUnloadDllBreakAddr();
        break;

    case DEBUG_FILTER_DEBUGGEE_OUTPUT:
        ParseOutFilterPattern();
        break;
    }

    return 0;
}

ULONG
SetEventFilterContinue(EVENT_FILTER* Filter, ULONG Continue)
{
    Filter->Params.ContinueOption = Continue;
    Filter->Flags |= FILTER_CHANGED_CONTINUE;
    return 0;
}

ULONG
SetEventFilterCommand(DebugClient* Client, EVENT_FILTER* Filter,
                      EVENT_COMMAND* EventCommand, PSTR* Command)
{
    if (Command[0] != NULL)
    {
        if (strlen(Command[0]) >= MAX_COMMAND)
        {
            return STRINGSIZE;
        }

        if (ChangeString(&EventCommand->Command[0],
                         &EventCommand->CommandSize[0],
                         Command[0][0] ? Command[0] : NULL) != S_OK)
        {
            return MEMORY;
        }
    }
    if (Command[1] != NULL)
    {
        if (strlen(Command[1]) >= MAX_COMMAND)
        {
            return STRINGSIZE;
        }

        if (Filter != NULL &&
#if FILTER_SPECIFIC_FIRST > 0
            (ULONG)(Filter - g_EventFilters) >= FILTER_SPECIFIC_FIRST &&
#endif
            (ULONG)(Filter - g_EventFilters) <= FILTER_SPECIFIC_LAST)
        {
            WarnOut("Second-chance command for specific event ignored\n");
        }
        else if (ChangeString(&EventCommand->Command[1],
                              &EventCommand->CommandSize[1],
                              Command[1][0] ? Command[1] : NULL) != S_OK)
        {
            return MEMORY;
        }
    }

    if (Command[0] != NULL || Command[1] != NULL)
    {
        if (Filter != NULL)
        {
            Filter->Flags |= FILTER_CHANGED_COMMAND;
        }
        EventCommand->Client = Client;
    }
    else
    {
        EventCommand->Client = NULL;
    }

    return 0;
}

#define EXEC_TO_CONT(Option) \
    ((Option) == DEBUG_FILTER_BREAK ? \
     DEBUG_FILTER_GO_HANDLED : DEBUG_FILTER_GO_NOT_HANDLED)

ULONG
SetEventFilterEither(DebugClient* Client, EVENT_FILTER* Filter,
                     ULONG Option, BOOL ContinueOption,
                     PSTR* Command)
{
    ULONG Status;

    if (Option != DEBUG_FILTER_REMOVE)
    {
        if (ContinueOption)
        {
            Status = SetEventFilterContinue(Filter, EXEC_TO_CONT(Option));
        }
        else
        {
            Status = SetEventFilterExecution(Filter, Option);
        }
        if (Status != 0)
        {
            return Status;
        }
    }

    return SetEventFilterCommand(Client, Filter, &Filter->Command, Command);
}

ULONG
SetEventFilterByName(DebugClient* Client,
                     ULONG Option, BOOL ForceContinue, PSTR* Command)
{
    PSTR Start = g_CurCmd;
    char Name[8];
    int i;
    char Ch;

    // Collect name.
    i = 0;
    while (i < sizeof(Name) - 1)
    {
        Ch = *g_CurCmd++;
        if (!__iscsym(Ch))
        {
            g_CurCmd--;
            break;
        }

        Name[i++] = (CHAR)tolower(Ch);
    }
    Name[i] = 0;

    // Skip any whitespace after the name.
    while (isspace(*g_CurCmd))
    {
        g_CurCmd++;
    }

    EVENT_FILTER* Filter;
    BOOL Match = FALSE;
    ULONG MatchIndex = DEBUG_ANY_ID;
    ULONG Status = 0;

    // Multiple filters can be altered if they share names.
    Filter = g_EventFilters;
    for (i = 0; i < FILTER_COUNT; i++)
    {
        if (Filter->ExecutionAbbrev != NULL &&
            !strcmp(Name, Filter->ExecutionAbbrev))
        {
            Status = SetEventFilterEither(Client,
                                          Filter, Option, ForceContinue,
                                          Command);
            if (Status != 0)
            {
                goto Exit;
            }

            if (!Match)
            {
                MatchIndex = i;
                Match = TRUE;
            }
            else if (MatchIndex != (ULONG)i)
            {
                // Multiple matches.
                MatchIndex = DEBUG_ANY_ID;
            }
        }

        if (Filter->ContinueAbbrev != NULL &&
            !strcmp(Name, Filter->ContinueAbbrev))
        {
            // Translate execution-style option to continue-style option.
            Status = SetEventFilterEither(Client,
                                          Filter, Option, TRUE, Command);
            if (Status != 0)
            {
                goto Exit;
            }

            if (!Match)
            {
                MatchIndex = i;
                Match = TRUE;
            }
            else if (MatchIndex != (ULONG)i)
            {
                // Multiple matches.
                MatchIndex = DEBUG_ANY_ID;
            }
        }

        Filter++;
    }

    if (!Match)
    {
        ULONG64 ExceptionCode;

        // Name is unrecognized.  Assume it's an exception code.
        g_CurCmd = Start;
        ExceptionCode = GetExpression();
        if (NeedUpper(ExceptionCode))
        {
            return OVERFLOW;
        }

        DEBUG_EXCEPTION_FILTER_PARAMETERS Params, *CurParams;
        EVENT_COMMAND EventCommand, *CurEventCommand;

        if (Status = GetOtherExceptionParameters((ULONG)ExceptionCode, FALSE,
                                                 &CurParams, &CurEventCommand))
        {
            return Status;
        }

        Params = *CurParams;
        if (Option != DEBUG_FILTER_REMOVE)
        {
            if (ForceContinue)
            {
                Params.ContinueOption = EXEC_TO_CONT(Option);
            }
            else
            {
                Params.ExecutionOption = Option;
            }
        }
        Params.ExceptionCode = (ULONG)ExceptionCode;

        EventCommand = *CurEventCommand;
        Status = SetEventFilterCommand(Client, NULL, &EventCommand, Command);
        if (Status != 0)
        {
            return Status;
        }

        return SetOtherExceptionParameters(&Params, &EventCommand);
    }

 Exit:
    if (Match)
    {
        if (SyncOptionsWithFilters())
        {
            NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS |
                                    DEBUG_CES_ENGINE_OPTIONS,
                                    DEBUG_ANY_ID, TRUE);
        }
        else
        {
            NotifyChangeEngineState(DEBUG_CES_EVENT_FILTERS, MatchIndex, TRUE);
        }
    }
    return Status;
}

char* g_EfExecutionNames[] =
{
    "break", "second-chance break", "output", "ignore",
};

char* g_EfContinueNames[] =
{
    "handled", "not handled",
};

void
ListEventFilters(void)
{
    EVENT_FILTER* Filter;
    ULONG i;
    BOOL SetOption = TRUE;

    Filter = g_EventFilters;
    for (i = 0; i < FILTER_COUNT; i++)
    {
        if (Filter->ExecutionAbbrev != NULL)
        {
            dprintf("%4s - %s - %s",
                    Filter->ExecutionAbbrev, Filter->Name,
                    g_EfExecutionNames[Filter->Params.ExecutionOption]);
            if (i >= FILTER_EXCEPTION_FIRST &&
                Filter->ContinueAbbrev == NULL)
            {
                dprintf(" - %s\n",
                        g_EfContinueNames[Filter->Params.ContinueOption]);
            }
            else
            {
                dprintf("\n");
            }

            if (Filter->Command.Command[0] != NULL)
            {
                dprintf("       Command: \"%s\"\n",
                        Filter->Command.Command[0]);
            }
            if (Filter->Command.Command[1] != NULL)
            {
                dprintf("       Second command: \"%s\"\n",
                        Filter->Command.Command[1]);
            }
        }

        if (Filter->ContinueAbbrev != NULL)
        {
            dprintf("%4s - %s continue - %s\n",
                    Filter->ContinueAbbrev, Filter->Name,
                    g_EfContinueNames[Filter->Params.ContinueOption]);
        }

        switch(i)
        {
        case DEBUG_FILTER_CREATE_PROCESS:
        case DEBUG_FILTER_EXIT_PROCESS:
        case DEBUG_FILTER_LOAD_MODULE:
        case DEBUG_FILTER_UNLOAD_MODULE:
            if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                Filter->Argument[0])
            {
                dprintf("       (only break for %s)\n", Filter->Argument);
            }
            break;
        case DEBUG_FILTER_DEBUGGEE_OUTPUT:
            if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                g_OutEventFilterPattern[0])
            {
                dprintf("       (only break for %s matches)\n",
                        g_OutEventFilterPattern);
            }
            break;
        }

        Filter++;
    }

    Filter = &g_EventFilters[FILTER_DEFAULT_EXCEPTION];
    dprintf("\n   * - Other exception - %s - %s\n",
            g_EfExecutionNames[Filter->Params.ExecutionOption],
            g_EfContinueNames[Filter->Params.ContinueOption]);
    if (Filter->Command.Command[0] != NULL)
    {
        dprintf("       Command: \"%s\"\n",
                Filter->Command.Command[0]);
    }
    if (Filter->Command.Command[1] != NULL)
    {
        dprintf("       Second command: \"%s\"\n",
                Filter->Command.Command[1]);
    }

    if (g_NumOtherExceptions > 0)
    {
        dprintf("       Exception option for:\n");
        for (i = 0; i < g_NumOtherExceptions; i++)
        {
            dprintf("           %08lx - %s - %s\n",
                    g_OtherExceptionList[i].ExceptionCode,
                    g_EfExecutionNames[g_OtherExceptionList[i].
                                      ExecutionOption],
                    g_EfContinueNames[g_OtherExceptionList[i].
                                      ContinueOption]);
            if (g_OtherExceptionCommands[i].Command[0] != NULL)
            {
                dprintf("               Command: \"%s\"\n",
                        g_OtherExceptionCommands[i].Command[0]);
            }
            if (g_OtherExceptionCommands[i].Command[1] != NULL)
            {
                dprintf("               Second command: \"%s\"\n",
                        g_OtherExceptionCommands[i].Command[1]);
            }
        }
    }
}

void
ParseSetEventFilter(DebugClient* Client)
{
    UCHAR Ch;

    // Verify that exception constants are properly updated.
    DBG_ASSERT(!strcmp(g_EventFilters[FILTER_EXCEPTION_FIRST - 1].Name,
                       "Debuggee output"));
    C_ASSERT(DIMA(g_EventFilters) == FILTER_COUNT);

    Ch = PeekChar();
    if (Ch == '\0')
    {
        ListEventFilters();
    }
    else
    {
        ULONG Option;

        Ch = (UCHAR)tolower(Ch);
        g_CurCmd++;

        switch(Ch)
        {
        case 'd':
            Option = DEBUG_FILTER_SECOND_CHANCE_BREAK;
            break;
        case 'e':
            Option = DEBUG_FILTER_BREAK;
            break;
        case 'i':
            Option = DEBUG_FILTER_IGNORE;
            break;
        case 'n':
            Option = DEBUG_FILTER_OUTPUT;
            break;
        case '-':
            // Special value to indicate "don't change the option".
            // Used for just changing commands.
            Option = DEBUG_FILTER_REMOVE;
            break;
        default:
            error(SYNTAX);
            break;
        }

        BOOL ForceContinue;
        PSTR Command[2];
        ULONG Which;

        ForceContinue = FALSE;
        Command[0] = NULL;
        Command[1] = NULL;

        for (;;)
        {
            while (isspace(PeekChar()))
            {
                g_CurCmd++;
            }

            if (*g_CurCmd == '-' || *g_CurCmd == '/')
            {
                switch(tolower(*(++g_CurCmd)))
                {
                case 'c':
                    if (*(++g_CurCmd) == '2')
                    {
                        Which = 1;
                        g_CurCmd++;
                    }
                    else
                    {
                        Which = 0;
                    }
                    if (PeekChar() != '"')
                    {
                        error(SYNTAX);
                    }
                    if (Command[Which] != NULL)
                    {
                        error(SYNTAX);
                    }
                    Command[Which] = ++g_CurCmd;
                    while (*g_CurCmd && *g_CurCmd != '"')
                    {
                        g_CurCmd++;
                    }
                    if (*g_CurCmd != '"')
                    {
                        error(SYNTAX);
                    }
                    *g_CurCmd = 0;
                    break;

                case 'h':
                    ForceContinue = TRUE;
                    break;

                default:
                    error(SYNTAX);
                }

                g_CurCmd++;
            }
            else
            {
                break;
            }
        }

        ULONG Status;

        if (*g_CurCmd == '*')
        {
            g_CurCmd++;

            Status = SetEventFilterEither
                (Client, &g_EventFilters[FILTER_DEFAULT_EXCEPTION],
                 Option, ForceContinue, Command);
            if (Status == 0)
            {
                while (g_NumOtherExceptions)
                {
                    RemoveOtherException(0);
                }
            }
        }
        else
        {
            Status = SetEventFilterByName(Client,
                                          Option, ForceContinue, Command);
        }

        if (Status != 0)
        {
            error(Status);
        }
    }
}

char
ExecutionChar(ULONG Execution)
{
    switch(Execution)
    {
    case DEBUG_FILTER_BREAK:
        return 'e';
    case DEBUG_FILTER_SECOND_CHANCE_BREAK:
        return 'd';
    case DEBUG_FILTER_OUTPUT:
        return 'n';
    case DEBUG_FILTER_IGNORE:
        return 'i';
    }

    return 0;
}

char
ContinueChar(ULONG Continue)
{
    switch(Continue)
    {
    case DEBUG_FILTER_GO_HANDLED:
        return 'e';
    case DEBUG_FILTER_GO_NOT_HANDLED:
        return 'd';
    }

    return 0;
}

void
ListFiltersAsCommands(DebugClient* Client, ULONG Flags)
{
    ULONG i;

    EVENT_FILTER* Filter = g_EventFilters;
    for (i = 0; i < FILTER_COUNT; i++)
    {
        if (Filter->Flags & FILTER_CHANGED_EXECUTION)
        {
            PCSTR Abbrev = Filter->ExecutionAbbrev != NULL ?
                Filter->ExecutionAbbrev : "*";
            dprintf("sx%c %s",
                    ExecutionChar(Filter->Params.ExecutionOption), Abbrev);

            switch(i)
            {
            case DEBUG_FILTER_CREATE_PROCESS:
            case DEBUG_FILTER_EXIT_PROCESS:
            case DEBUG_FILTER_LOAD_MODULE:
            case DEBUG_FILTER_UNLOAD_MODULE:
            case DEBUG_FILTER_DEBUGGEE_OUTPUT:
                if (IS_EFEXECUTION_BREAK(Filter->Params.ExecutionOption) &&
                    Filter->Argument[0])
                {
                    dprintf(":%s", Filter->Argument);
                }
                break;
            }

            dprintf(" ;%c", (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if (Filter->Flags & FILTER_CHANGED_CONTINUE)
        {
            PCSTR Abbrev = Filter->ContinueAbbrev;
            if (Abbrev == NULL)
            {
                Abbrev = Filter->ExecutionAbbrev != NULL ?
                    Filter->ExecutionAbbrev : "*";
            }

            dprintf("sx%c -h %s ;%c",
                    ContinueChar(Filter->Params.ContinueOption), Abbrev,
                    (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        if (Filter->Flags & FILTER_CHANGED_COMMAND)
        {
            PCSTR Abbrev = Filter->ExecutionAbbrev != NULL ?
                Filter->ExecutionAbbrev : "*";

            dprintf("sx-");
            if (Filter->Command.Command[0] != NULL)
            {
                dprintf(" -c \"%s\"", Filter->Command.Command[0]);
            }
            if (Filter->Command.Command[1] != NULL)
            {
                dprintf(" -c2 \"%s\"", Filter->Command.Command[1]);
            }
            dprintf(" %s ;%c", Abbrev,
                    (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        Filter++;
    }

    PDEBUG_EXCEPTION_FILTER_PARAMETERS Other = g_OtherExceptionList;
    EVENT_COMMAND* EventCommand = g_OtherExceptionCommands;
    for (i = 0; i < g_NumOtherExceptions; i++)
    {
        dprintf("sx%c 0x%x ;%c",
                ExecutionChar(Other->ExecutionOption), Other->ExceptionCode,
                (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        dprintf("sx%c -h 0x%x ;%c",
                ContinueChar(Other->ContinueOption), Other->ExceptionCode,
                (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');

        if (EventCommand->Command[0] != NULL ||
            EventCommand->Command[1] != NULL)
        {
            dprintf("sx-");
            if (EventCommand->Command[0] != NULL)
            {
                dprintf(" -c \"%s\"", EventCommand->Command[0]);
            }
            if (EventCommand->Command[1] != NULL)
            {
                dprintf(" -c2 \"%s\"", EventCommand->Command[1]);
            }
            dprintf(" 0x%x ;%c", Other->ExceptionCode,
                    (Flags & SXCMDS_ONE_LINE) ? ' ' : '\n');
        }

        Other++;
        EventCommand++;
    }

    if (Flags & SXCMDS_ONE_LINE)
    {
        dprintf("\n");
    }
}

struct SHARED_FILTER_AND_OPTION
{
    ULONG FilterIndex;
    ULONG OptionBit;
};

SHARED_FILTER_AND_OPTION g_SharedFilterOptions[] =
{
    DEBUG_FILTER_INITIAL_BREAKPOINT,  DEBUG_ENGOPT_INITIAL_BREAK,
    DEBUG_FILTER_INITIAL_MODULE_LOAD, DEBUG_ENGOPT_INITIAL_MODULE_BREAK,
    DEBUG_FILTER_EXIT_PROCESS,        DEBUG_ENGOPT_FINAL_BREAK,
};

BOOL
SyncFiltersWithOptions(void)
{
    ULONG ExOption;
    BOOL Changed = FALSE;
    ULONG i;

    for (i = 0; i < DIMA(g_SharedFilterOptions); i++)
    {
        ExOption = (g_EngOptions & g_SharedFilterOptions[i].OptionBit) ?
            DEBUG_FILTER_BREAK : DEBUG_FILTER_IGNORE;
        if (g_EventFilters[g_SharedFilterOptions[i].FilterIndex].
            Params.ExecutionOption != ExOption)
        {
            g_EventFilters[g_SharedFilterOptions[i].FilterIndex].
                Params.ExecutionOption = ExOption;
            Changed = TRUE;
        }
    }

    return Changed;
}

BOOL
SyncOptionsWithFilters(void)
{
    ULONG Bit;
    BOOL Changed = FALSE;
    ULONG i;

    for (i = 0; i < DIMA(g_SharedFilterOptions); i++)
    {
        Bit = IS_EFEXECUTION_BREAK
            (g_EventFilters[g_SharedFilterOptions[i].FilterIndex].
             Params.ExecutionOption) ?
            g_SharedFilterOptions[i].OptionBit : 0;
        if ((g_EngOptions & g_SharedFilterOptions[i].OptionBit) ^ Bit)
        {
            g_EngOptions =
                (g_EngOptions & ~g_SharedFilterOptions[i].OptionBit) | Bit;
            Changed = TRUE;
        }
    }

    return Changed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\dumpwrite.cpp ===
//----------------------------------------------------------------------------
//
// Dump file writing.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include <uminiprov.hpp>
#include <dbgver.h>
#include <bugcodes.h>

#define GENERIC_FORMATS \
    (DEBUG_FORMAT_WRITE_CAB | \
     DEBUG_FORMAT_CAB_SECONDARY_FILES | \
     DEBUG_FORMAT_NO_OVERWRITE)
#define UMINI_FORMATS \
    (DEBUG_FORMAT_USER_SMALL_FULL_MEMORY | \
     DEBUG_FORMAT_USER_SMALL_HANDLE_DATA | \
     DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES | \
     DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY | \
     DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS | \
     DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY | \
     DEBUG_FORMAT_USER_SMALL_FILTER_PATHS | \
     DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA | \
     DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY)

// Internal format flag for testing of microdumps.  This
// will not be made into a public flag and must not conflict
// with them.
#define FORMAT_USER_MICRO 0x01000000

//----------------------------------------------------------------------------
//
// UserFullDumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

#define USER_DUMP_MEMORY_BUFFER 65536

struct CREATE_USER_DUMP_STATE
{
    ThreadInfo* Thread;
    ImageInfo* Image;
    ULONG64 MemHandle;
    HANDLE DumpFileHandle;
    MEMORY_BASIC_INFORMATION64 MemInfo;
    MEMORY_BASIC_INFORMATION32 MemInfo32;
    ULONG64 MemBufDone;
    ULONG64 TotalMemQueried;
    ULONG64 TotalMemData;
    CROSS_PLATFORM_CONTEXT TargetContext;
    DEBUG_EVENT Event;
    CRASH_THREAD CrashThread;
    ULONG64 MemBuf[USER_DUMP_MEMORY_BUFFER / sizeof(ULONG64)];
};

BOOL WINAPI
CreateUserDumpCallback(
    ULONG       DataType,
    PVOID*      Data,
    PULONG      DataLength,
    PVOID       UserData
    )
{
    CREATE_USER_DUMP_STATE* State = (CREATE_USER_DUMP_STATE*)UserData;
    ThreadInfo* Thread;

    switch(DataType)
    {
    case DMP_DUMP_FILE_HANDLE:
        *Data = State->DumpFileHandle;
        *DataLength = sizeof(HANDLE);
        break;

    case DMP_DEBUG_EVENT:
        ADDR PcAddr;

        //
        // Fake up an exception event for the current thread.
        //

        ZeroMemory(&State->Event, sizeof(State->Event));

        g_Machine->GetPC(&PcAddr);

        State->Event.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
        State->Event.dwProcessId = g_Process->m_SystemId;
        State->Event.dwThreadId = g_Thread->m_SystemId;
        if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
        {
            // Use the exception record from the last exception.
            ExceptionRecord64To(&g_LastEventInfo.Exception.ExceptionRecord,
                                &State->Event.u.Exception.ExceptionRecord);
            State->Event.u.Exception.dwFirstChance =
                g_LastEventInfo.Exception.FirstChance;
        }
        else
        {
            // Fake a breakpoint exception.
            State->Event.u.Exception.ExceptionRecord.ExceptionCode =
                STATUS_BREAKPOINT;
            State->Event.u.Exception.ExceptionRecord.ExceptionAddress =
                (PVOID)(ULONG_PTR)Flat(PcAddr);
            State->Event.u.Exception.dwFirstChance = TRUE;
        }

        *Data = &State->Event;
        *DataLength = sizeof(State->Event);
        break;

    case DMP_THREAD_STATE:
        ULONG64 Teb64;

        if (State->Thread == NULL)
        {
            Thread = g_Process->m_ThreadHead;
        }
        else
        {
            Thread = State->Thread->m_Next;
        }
        State->Thread = Thread;
        if (Thread == NULL)
        {
            return FALSE;
        }

        ZeroMemory(&State->CrashThread, sizeof(State->CrashThread));

        State->CrashThread.ThreadId = Thread->m_SystemId;
        State->CrashThread.SuspendCount = Thread->m_SuspendCount;
        if (IS_LIVE_USER_TARGET(g_Target))
        {
            if (g_Target->m_ClassQualifier ==
                DEBUG_USER_WINDOWS_PROCESS_SERVER)
            {
                // The priority information isn't important
                // enough to warrant remoting.
                State->CrashThread.PriorityClass = NORMAL_PRIORITY_CLASS;
                State->CrashThread.Priority = THREAD_PRIORITY_NORMAL;
            }
            else
            {
                State->CrashThread.PriorityClass =
                    GetPriorityClass(OS_HANDLE(g_Process->m_SysHandle));
                State->CrashThread.Priority =
                    GetThreadPriority(OS_HANDLE(Thread->m_Handle));
            }
        }
        else
        {
            State->CrashThread.PriorityClass = NORMAL_PRIORITY_CLASS;
            State->CrashThread.Priority = THREAD_PRIORITY_NORMAL;
        }
        if (g_Target->GetThreadInfoDataOffset(Thread, NULL, &Teb64) != S_OK)
        {
            Teb64 = 0;
        }
        State->CrashThread.Teb = (DWORD_PTR)Teb64;

        *Data = &State->CrashThread;
        *DataLength = sizeof(State->CrashThread);
        break;

    case DMP_MEMORY_BASIC_INFORMATION:
        if (g_Target->QueryMemoryRegion(g_Process,
                                        &State->MemHandle, FALSE,
                                        &State->MemInfo) != S_OK)
        {
            State->MemHandle = 0;
            State->MemInfo.RegionSize = 0;
            return FALSE;
        }

        State->TotalMemQueried += State->MemInfo.RegionSize;

#ifdef _WIN64
        *Data = &State->MemInfo;
        *DataLength = sizeof(State->MemInfo);
#else
        State->MemInfo32.BaseAddress = (ULONG)State->MemInfo.BaseAddress;
        State->MemInfo32.AllocationBase = (ULONG)State->MemInfo.AllocationBase;
        State->MemInfo32.AllocationProtect = State->MemInfo.AllocationProtect;
        State->MemInfo32.RegionSize = (ULONG)State->MemInfo.RegionSize;
        State->MemInfo32.State = State->MemInfo.State;
        State->MemInfo32.Protect = State->MemInfo.Protect;
        State->MemInfo32.Type = State->MemInfo.Type;
        *Data = &State->MemInfo32;
        *DataLength = sizeof(State->MemInfo32);
#endif
        break;

    case DMP_THREAD_CONTEXT:
        if (State->Thread == NULL)
        {
            Thread = g_Process->m_ThreadHead;
        }
        else
        {
            Thread = State->Thread->m_Next;
        }
        State->Thread = Thread;
        if (Thread == NULL)
        {
            g_Target->ChangeRegContext(g_Thread);
            return FALSE;
        }

        g_Target->ChangeRegContext(Thread);
        if (g_Machine->GetContextState(MCTX_CONTEXT) != S_OK ||
            g_Machine->ConvertContextTo(&g_Machine->m_Context,
                                        g_Target->m_SystemVersion,
                                        g_Target->m_TypeInfo.SizeTargetContext,
                                        &State->TargetContext) != S_OK)
        {
            ErrOut("Unable to retrieve context for thread %d. "
                   "Dump may be corrupt.", Thread->m_UserId);
            return FALSE;
        }

        *Data = &State->TargetContext;
        *DataLength = g_Target->m_TypeInfo.SizeTargetContext;
        break;

    case DMP_MODULE:
        ImageInfo* Image;
        PCRASH_MODULE Module;

        if (State->Image == NULL)
        {
            Image = g_Process->m_ImageHead;
        }
        else
        {
            Image = State->Image->m_Next;
        }
        State->Image = Image;
        if (Image == NULL)
        {
            return FALSE;
        }

        Module = (PCRASH_MODULE)State->MemBuf;
        Module->BaseOfImage = (DWORD_PTR)Image->m_BaseOfImage;
        Module->SizeOfImage = Image->m_SizeOfImage;
        Module->ImageNameLength = strlen(Image->m_ImagePath) + 1;
        CopyString(Module->ImageName, Image->m_ImagePath,
                   USER_DUMP_MEMORY_BUFFER - sizeof(*Module));

        *Data = Module;
        *DataLength = sizeof(*Module) + Module->ImageNameLength;
        break;

    case DMP_MEMORY_DATA:
        ULONG64 Left;

        Left = State->MemInfo.RegionSize - State->MemBufDone;
        if (Left == 0)
        {
            State->MemBufDone = 0;
            if (g_Target->QueryMemoryRegion(g_Process,
                                            &State->MemHandle, FALSE,
                                            &State->MemInfo) != S_OK)
            {
                State->MemHandle = 0;
                State->MemInfo.RegionSize = 0;

                // Sanity check that we wrote out as much data
                // as we stored in the MEMORY_BASIC phase.
                if (State->TotalMemQueried != State->TotalMemData)
                {
                    ErrOut("Queried %s bytes of memory but wrote %s "
                           "bytes of memory data.\nDump may be corrupt.\n",
                           FormatDisp64(State->TotalMemQueried),
                           FormatDisp64(State->TotalMemData));
                }

                return FALSE;
            }

            Left = State->MemInfo.RegionSize;
            State->TotalMemData += State->MemInfo.RegionSize;
        }

        if (Left > USER_DUMP_MEMORY_BUFFER)
        {
            Left = USER_DUMP_MEMORY_BUFFER;
        }
        if (CurReadAllVirtual(State->MemInfo.BaseAddress +
                              State->MemBufDone, State->MemBuf,
                              (ULONG)Left) != S_OK)
        {
            ErrOut("ReadVirtual at %s failed. Dump may be corrupt.\n",
                   FormatAddr64(State->MemInfo.BaseAddress +
                                State->MemBufDone));
            return FALSE;
        }

        State->MemBufDone += Left;

        *Data = State->MemBuf;
        *DataLength = (ULONG)Left;
        break;
    }

    return TRUE;
}

HRESULT
UserFullDumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                              PCSTR CommentA, PCWSTR CommentW)
{
    dprintf("user full dump\n");
    FlushCallbacks();

    if (!IS_LIVE_USER_TARGET(g_Target))
    {
        ErrOut("User full dumps can only be written in "
               "live user-mode sessions\n");
        return E_UNEXPECTED;
    }
    if (CommentA != NULL || CommentW != NULL)
    {
        ErrOut("User full dumps do not support comments\n");
        return E_INVALIDARG;
    }

    CREATE_USER_DUMP_STATE* State;

    State = (CREATE_USER_DUMP_STATE*)calloc(1, sizeof(*State));
    if (State == NULL)
    {
        ErrOut("Unable to allocate memory for dump state\n");
        return E_OUTOFMEMORY;
    }

    State->DumpFileHandle = hFile;

    HRESULT Status;

    if (!DbgHelpCreateUserDump(NULL, CreateUserDumpCallback, State))
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Dump creation failed, %s\n    \"%s\"\n",
               FormatStatusCode(Status), FormatStatus(Status));
    }
    else
    {
        Status = S_OK;
    }

    free(State);
    return Status;
}

//----------------------------------------------------------------------------
//
// UserMiniDumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

class DbgSystemProvider : public MiniDumpSystemProvider
{
public:
    DbgSystemProvider(void);
    ~DbgSystemProvider(void);

    virtual void Release(void);
    virtual HRESULT GetCurrentTimeDate(OUT PULONG TimeDate);
    virtual HRESULT GetCpuType(OUT PULONG Type,
                               OUT PBOOL BackingStore);
    virtual HRESULT GetCpuInfo(OUT PUSHORT Architecture,
                               OUT PUSHORT Level,
                               OUT PUSHORT Revision,
                               OUT PUCHAR NumberOfProcessors,
                               OUT PCPU_INFORMATION Info);
    virtual void GetContextSizes(OUT PULONG Size,
                                 OUT PULONG RegScanStart,
                                 OUT PULONG RegScanCount);
    virtual void GetPointerSize(OUT PULONG Size);
    virtual void GetPageSize(OUT PULONG Size);
    virtual void GetFunctionTableSizes(OUT PULONG TableSize,
                                       OUT PULONG EntrySize);
    virtual void GetInstructionWindowSize(OUT PULONG Size);
    virtual HRESULT GetOsInfo(OUT PULONG PlatformId,
                              OUT PULONG Major,
                              OUT PULONG Minor,
                              OUT PULONG BuildNumber,
                              OUT PUSHORT ProductType,
                              OUT PUSHORT SuiteMask);
    virtual HRESULT GetOsCsdString(OUT PWSTR Buffer,
                                   IN ULONG BufferChars);
    virtual HRESULT OpenMapping(IN PCWSTR FilePath,
                                OUT PULONG Size,
                                OUT PWSTR LongPath,
                                IN ULONG LongPathChars,
                                OUT PVOID* Mapping);
    virtual void    CloseMapping(PVOID Mapping);
    virtual HRESULT GetImageHeaderInfo(IN HANDLE Process,
                                       IN PCWSTR FilePath,
                                       IN ULONG64 ImageBase,
                                       OUT PULONG Size,
                                       OUT PULONG CheckSum,
                                       OUT PULONG TimeDateStamp);
    virtual HRESULT GetImageVersionInfo(IN HANDLE Process,
                                        IN PCWSTR FilePath,
                                        IN ULONG64 ImageBase,
                                        OUT VS_FIXEDFILEINFO* Info);
    virtual HRESULT GetImageDebugRecord(IN HANDLE Process,
                                        IN PCWSTR FilePath,
                                        IN ULONG64 ImageBase,
                                        IN ULONG RecordType,
                                        OUT OPTIONAL PVOID Data,
                                        IN OUT PULONG DataLen);
    virtual HRESULT EnumImageDataSections(IN HANDLE Process,
                                          IN PCWSTR FilePath,
                                          IN ULONG64 ImageBase,
                                          IN MiniDumpProviderCallbacks*
                                          Callback);
    virtual HRESULT OpenThread(IN ULONG DesiredAccess,
                               IN BOOL InheritHandle,
                               IN ULONG ThreadId,
                               OUT PHANDLE Handle);
    virtual void    CloseThread(IN HANDLE Handle);
    virtual ULONG   GetCurrentThreadId(void);
    virtual ULONG   SuspendThread(IN HANDLE Thread);
    virtual ULONG   ResumeThread(IN HANDLE Thread);
    virtual HRESULT GetThreadContext(IN HANDLE Thread,
                                     OUT PVOID Context,
                                     IN ULONG ContextSize,
                                     OUT PULONG64 CurrentPc,
                                     OUT PULONG64 CurrentStack,
                                     OUT PULONG64 CurrentStore);
    virtual HRESULT GetTeb(IN HANDLE Thread,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
    virtual HRESULT GetThreadInfo(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  OUT PULONG64 Teb,
                                  OUT PULONG SizeOfTeb,
                                  OUT PULONG64 StackBase,
                                  OUT PULONG64 StackLimit,
                                  OUT PULONG64 StoreBase,
                                  OUT PULONG64 StoreLimit);
    virtual HRESULT GetPeb(IN HANDLE Process,
                           OUT PULONG64 Offset,
                           OUT PULONG Size);
    virtual HRESULT GetProcessTimes(IN HANDLE Process,
                                    OUT LPFILETIME Create,
                                    OUT LPFILETIME User,
                                    OUT LPFILETIME Kernel);
    virtual HRESULT ReadVirtual(IN HANDLE Process,
                                IN ULONG64 Offset,
                                OUT PVOID Buffer,
                                IN ULONG Request,
                                OUT PULONG Done);
    virtual HRESULT ReadAllVirtual(IN HANDLE Process,
                                   IN ULONG64 Offset,
                                   OUT PVOID Buffer,
                                   IN ULONG Request);
    virtual HRESULT QueryVirtual(IN HANDLE Process,
                                 IN ULONG64 Offset,
                                 OUT PULONG64 Base,
                                 OUT PULONG64 Size,
                                 OUT PULONG Protect,
                                 OUT PULONG State,
                                 OUT PULONG Type);
    virtual HRESULT StartProcessEnum(IN HANDLE Process,
                                     IN ULONG ProcessId);
    virtual HRESULT EnumThreads(OUT PULONG ThreadId);
    virtual HRESULT EnumModules(OUT PULONG64 Base,
                                OUT PWSTR Path,
                                IN ULONG PathChars);
    virtual HRESULT EnumFunctionTables(OUT PULONG64 MinAddress,
                                       OUT PULONG64 MaxAddress,
                                       OUT PULONG64 BaseAddress,
                                       OUT PULONG EntryCount,
                                       OUT PVOID RawTable,
                                       IN ULONG RawTableSize,
                                       OUT PVOID* RawEntryHandle);
    virtual HRESULT EnumFunctionTableEntries(IN PVOID RawTable,
                                             IN ULONG RawTableSize,
                                             IN PVOID RawEntryHandle,
                                             OUT PVOID RawEntries,
                                             IN ULONG RawEntriesSize);
    virtual HRESULT EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                 IN PVOID RawEntries,
                                                 IN ULONG Index,
                                                 OUT PULONG64 Start,
                                                 OUT PULONG Size);
    virtual HRESULT EnumUnloadedModules(OUT PWSTR Path,
                                        IN ULONG PathChars,
                                        OUT PULONG64 BaseOfModule,
                                        OUT PULONG SizeOfModule,
                                        OUT PULONG CheckSum,
                                        OUT PULONG TimeDateStamp);
    virtual void    FinishProcessEnum(void);
    virtual HRESULT StartHandleEnum(IN HANDLE Process,
                                    IN ULONG ProcessId,
                                    OUT PULONG Count);
    virtual HRESULT EnumHandles(OUT PULONG64 Handle,
                                OUT PULONG Attributes,
                                OUT PULONG GrantedAccess,
                                OUT PULONG HandleCount,
                                OUT PULONG PointerCount,
                                OUT PWSTR TypeName,
                                IN ULONG TypeNameChars,
                                OUT PWSTR ObjectName,
                                IN ULONG ObjectNameChars);
    virtual void    FinishHandleEnum(void);

    virtual HRESULT EnumPebMemory(IN HANDLE Process,
                                  IN ULONG64 PebOffset,
                                  IN ULONG PebSize,
                                  IN MiniDumpProviderCallbacks* Callback);
    virtual HRESULT EnumTebMemory(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  IN ULONG64 TebOffset,
                                  IN ULONG TebSize,
                                  IN MiniDumpProviderCallbacks* Callback);

    virtual HRESULT GetCorDataAccess(IN PWSTR AccessDllName,
                                     IN struct ICorDataAccessServices*
                                     Services,
                                     OUT struct ICorDataAccess**
                                     Access);
    virtual void    ReleaseCorDataAccess(IN struct ICorDataAccess*
                                         Access);

protected:
    ThreadInfo* m_Thread;
    ImageInfo* m_Image;
    UnloadedModuleInfo* m_UnlEnum;
    ULONG m_Handle;
    ULONG64 m_FuncTableStart;
    ULONG64 m_FuncTableHandle;
};

DbgSystemProvider::DbgSystemProvider(void)
{
}

DbgSystemProvider::~DbgSystemProvider(void)
{
}

void
DbgSystemProvider::Release(void)
{
    delete this;
}

HRESULT
DbgSystemProvider::GetCurrentTimeDate(OUT PULONG TimeDate)
{
    *TimeDate = FileTimeToTimeDateStamp(g_Target->GetCurrentTimeDateN());
    return S_OK;
}

HRESULT
DbgSystemProvider::GetCpuType(OUT PULONG Type,
                              OUT PBOOL BackingStore)
{
    *Type = g_Target->m_MachineType;
    *BackingStore = *Type == IMAGE_FILE_MACHINE_IA64;
    return S_OK;
}

HRESULT
DbgSystemProvider::GetCpuInfo(OUT PUSHORT Architecture,
                              OUT PUSHORT Level,
                              OUT PUSHORT Revision,
                              OUT PUCHAR NumberOfProcessors,
                              OUT PCPU_INFORMATION Info)
{
    DEBUG_PROCESSOR_IDENTIFICATION_ALL ProcId;
    ULONG64 ProcFeatures[4];
    ULONG NumVals;

    *Architecture = (USHORT)ImageMachineToProcArch(g_Target->m_MachineType);
    *NumberOfProcessors = (UCHAR)g_Target->m_NumProcessors;

    //
    // We've set the basic processor type so that the dump
    // can be interpreted correctly.  Any other failures should
    // not be considered fatal.
    //

    *Level = 0;
    *Revision = 0;
    ZeroMemory(Info, sizeof(*Info));

    if (g_Target->GetProcessorId(0, &ProcId) != S_OK)
    {
        return S_OK;
    }

    switch(g_Target->m_MachineType)
    {
    case IMAGE_FILE_MACHINE_I386:
        *Level = (USHORT)ProcId.X86.Family;
        *Revision = ((USHORT)ProcId.X86.Model << 8) |
            (USHORT)ProcId.X86.Stepping;

        memcpy(Info->X86CpuInfo.VendorId, ProcId.X86.VendorString,
               sizeof(Info->X86CpuInfo.VendorId));
        if (SUCCEEDED(g_Target->
                      GetSpecificProcessorFeatures(0,
                                                   ProcFeatures,
                                                   DIMA(ProcFeatures),
                                                   &NumVals)) &&
            NumVals >= 2)
        {
            Info->X86CpuInfo.VersionInformation =
                (ULONG32)ProcFeatures[0];
            Info->X86CpuInfo.FeatureInformation =
                (ULONG32)ProcFeatures[1];

            if (NumVals >= 3)
            {
                Info->X86CpuInfo.AMDExtendedCpuFeatures =
                    (ULONG32)ProcFeatures[2];
            }
        }
        break;

    case IMAGE_FILE_MACHINE_IA64:
        *Level = (USHORT)ProcId.Ia64.Model;
        *Revision = (USHORT)ProcId.Ia64.Revision;
        break;

    case IMAGE_FILE_MACHINE_AMD64:
        *Level = (USHORT)ProcId.Amd64.Family;
        *Revision = ((USHORT)ProcId.Amd64.Model << 8) |
            (USHORT)ProcId.Amd64.Stepping;
        break;
    }

    if (g_Target->m_MachineType != IMAGE_FILE_MACHINE_I386 &&
        SUCCEEDED(g_Target->
                  GetGenericProcessorFeatures(0,
                                              ProcFeatures,
                                              DIMA(ProcFeatures),
                                              &NumVals)))
    {
        C_ASSERT(sizeof(Info->OtherCpuInfo.ProcessorFeatures) <=
                 sizeof(ProcFeatures));

        if (NumVals < DIMA(ProcFeatures))
        {
            ZeroMemory(ProcFeatures + NumVals,
                       (DIMA(ProcFeatures) - NumVals) *
                       sizeof(ProcFeatures[0]));
        }

        memcpy(Info->OtherCpuInfo.ProcessorFeatures, ProcFeatures,
               sizeof(Info->OtherCpuInfo.ProcessorFeatures));
    }

    return S_OK;
}

void
DbgSystemProvider::GetContextSizes(OUT PULONG Size,
                                   OUT PULONG RegScanOffset,
                                   OUT PULONG RegScanCount)
{
    *Size = g_Target->m_TypeInfo.SizeTargetContext;
    // Default reg scan.
    *RegScanOffset = -1;
    *RegScanCount = -1;
}

void
DbgSystemProvider::GetPointerSize(OUT PULONG Size)
{
    *Size = g_Machine->m_Ptr64 ? 8 : 4;
}

void
DbgSystemProvider::GetPageSize(OUT PULONG Size)
{
    *Size = g_Machine->m_PageSize;
}

void
DbgSystemProvider::GetFunctionTableSizes(OUT PULONG TableSize,
                                         OUT PULONG EntrySize)
{
    *TableSize = g_Target->m_TypeInfo.SizeDynamicFunctionTable;
    *EntrySize = g_Target->m_TypeInfo.SizeRuntimeFunction;
}

void
DbgSystemProvider::GetInstructionWindowSize(OUT PULONG Size)
{
    // Default window.
    *Size = -1;
}

HRESULT
DbgSystemProvider::GetOsInfo(OUT PULONG PlatformId,
                             OUT PULONG Major,
                             OUT PULONG Minor,
                             OUT PULONG BuildNumber,
                             OUT PUSHORT ProductType,
                             OUT PUSHORT SuiteMask)
{
    *PlatformId = g_Target->m_PlatformId;
    *Major = g_Target->m_KdVersion.MajorVersion;
    *Minor = g_Target->m_KdVersion.MinorVersion;
    *BuildNumber = g_Target->m_BuildNumber;
    *ProductType = (USHORT)g_Target->m_ProductType;
    *SuiteMask = (USHORT)g_Target->m_SuiteMask;
    return S_OK;
}

HRESULT
DbgSystemProvider::GetOsCsdString(OUT PWSTR Buffer,
                                  IN ULONG BufferChars)
{
    if (!MultiByteToWideChar(CP_ACP, 0,
                             g_Target->m_ServicePackString, -1,
                             Buffer, BufferChars))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

HRESULT
DbgSystemProvider::OpenMapping(IN PCWSTR FilePath,
                               OUT PULONG Size,
                               OUT PWSTR LongPath,
                               IN ULONG LongPathChars,
                               OUT PVOID* ViewRet)
{
    // We could potentially support this via image file
    // location but the minidump code is deliberately
    // written to not rely to mappings.
    return E_NOTIMPL;
}

void
DbgSystemProvider::CloseMapping(PVOID Mapping)
{
    // No mapping support.
    DBG_ASSERT(!Mapping);
}

HRESULT
DbgSystemProvider::GetImageHeaderInfo(IN HANDLE Process,
                                      IN PCWSTR FilePath,
                                      IN ULONG64 ImageBase,
                                      OUT PULONG Size,
                                      OUT PULONG CheckSum,
                                      OUT PULONG TimeDateStamp)
{
    ImageInfo* Image = ((ProcessInfo*)Process)->
        FindImageByOffset(ImageBase, FALSE);
    if (!Image)
    {
        return E_NOINTERFACE;
    }

    *Size = Image->m_SizeOfImage;
    *CheckSum = Image->m_CheckSum;
    *TimeDateStamp = Image->m_TimeDateStamp;

    return S_OK;
}

HRESULT
DbgSystemProvider::GetImageVersionInfo(IN HANDLE Process,
                                       IN PCWSTR FilePath,
                                       IN ULONG64 ImageBase,
                                       OUT VS_FIXEDFILEINFO* Info)
{
    HRESULT Status;
    PSTR Ansi;

    if ((Status = WideToAnsi(FilePath, &Ansi)) != S_OK)
    {
        return Status;
    }

    Status = g_Target->
        GetImageVersionInformation((ProcessInfo*)Process,
                                   Ansi, ImageBase, "\\",
                                   Info, sizeof(*Info), NULL);

    FreeAnsi(Ansi);
    return Status;
}

HRESULT
DbgSystemProvider::GetImageDebugRecord(IN HANDLE Process,
                                       IN PCWSTR FilePath,
                                       IN ULONG64 ImageBase,
                                       IN ULONG RecordType,
                                       IN OUT OPTIONAL PVOID Data,
                                       OUT PULONG DataLen)
{
    // We can rely on the default processing.
    return E_NOINTERFACE;
}

HRESULT
DbgSystemProvider::EnumImageDataSections(IN HANDLE Process,
                                         IN PCWSTR FilePath,
                                         IN ULONG64 ImageBase,
                                         IN MiniDumpProviderCallbacks*
                                         Callback)
{
    // We can rely on the default processing.
    return E_NOINTERFACE;
}

HRESULT
DbgSystemProvider::OpenThread(IN ULONG DesiredAccess,
                              IN BOOL InheritHandle,
                              IN ULONG ThreadId,
                              OUT PHANDLE Handle)
{
    // Just use the thread pointer as the "handle".
    *Handle = g_Process->FindThreadBySystemId(ThreadId);
    return *Handle ? S_OK : E_NOINTERFACE;
}

void
DbgSystemProvider::CloseThread(IN HANDLE Handle)
{
    // "Handle" is just a pointer so nothing to do.
}

ULONG
DbgSystemProvider::GetCurrentThreadId(void)
{
    // The minidump code uses the current thread ID
    // to avoid suspending the thread running the dump
    // code.  That's not a problem for the debugger,
    // so return an ID that will never match.
    // SuspendThread will always be called so all
    // suspend counts will be set properly.
    return 0;
}

ULONG
DbgSystemProvider::SuspendThread(IN HANDLE Thread)
{
    return ((ThreadInfo*)Thread)->m_SuspendCount;
}

ULONG
DbgSystemProvider::ResumeThread(IN HANDLE Thread)
{
    return ((ThreadInfo*)Thread)->m_SuspendCount;
}

HRESULT
DbgSystemProvider::GetThreadContext(IN HANDLE Thread,
                                    OUT PVOID Context,
                                    IN ULONG ContextSize,
                                    OUT PULONG64 CurrentPc,
                                    OUT PULONG64 CurrentStack,
                                    OUT PULONG64 CurrentStore)
{
    HRESULT Status;
    ADDR Addr;

    g_Target->ChangeRegContext((ThreadInfo*)Thread);
    if ((Status = g_Machine->
         GetContextState(MCTX_CONTEXT)) != S_OK ||
        (Status = g_Machine->
         ConvertContextTo(&g_Machine->m_Context,
                          g_Target->m_SystemVersion,
                          g_Target->m_TypeInfo.SizeTargetContext,
                          Context)) != S_OK)
    {
        return Status;
    }

    g_Machine->GetPC(&Addr);
    *CurrentPc = Flat(Addr);
    g_Machine->GetSP(&Addr);
    *CurrentStack = Flat(Addr);
    if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_IA64)
    {
        *CurrentStore = g_Machine->m_Context.IA64Context.RsBSP;
    }
    else
    {
        *CurrentStore = 0;
    }

    return S_OK;
}

HRESULT
DbgSystemProvider::GetTeb(IN HANDLE Thread,
                          OUT PULONG64 Offset,
                          OUT PULONG Size)
{
    // Always save a whole page for the TEB.
    *Size = g_Machine->m_PageSize;
    return g_Target->
        GetThreadInfoTeb((ThreadInfo*)Thread, 0, 0, Offset);
}

HRESULT
DbgSystemProvider::GetThreadInfo(IN HANDLE Process,
                                 IN HANDLE Thread,
                                 OUT PULONG64 Teb,
                                 OUT PULONG SizeOfTeb,
                                 OUT PULONG64 StackBase,
                                 OUT PULONG64 StackLimit,
                                 OUT PULONG64 StoreBase,
                                 OUT PULONG64 StoreLimit)
{
    HRESULT Status;
    MEMORY_BASIC_INFORMATION64 MemInfo;
    ULONG64 MemHandle;

    if ((Status = g_Target->
         GetThreadInfoTeb((ThreadInfo*)Thread, 0, 0, Teb)) != S_OK)
    {
        return Status;
    }

    //
    // Try and save a whole page for the TEB.  If that's
    // not possible, save as much as is there.
    //

    MemHandle = *Teb;
    if ((Status = g_Target->
         QueryMemoryRegion((ProcessInfo*)Process, &MemHandle,
                           TRUE, &MemInfo)) != S_OK)
    {
        return Status;
    }

    *SizeOfTeb = g_Machine->m_PageSize;
    if (*Teb + *SizeOfTeb > MemInfo.BaseAddress + MemInfo.RegionSize)
    {
        *SizeOfTeb = (ULONG)
            ((MemInfo.BaseAddress + MemInfo.RegionSize) - *Teb);
    }

    //
    // Read the TIB for stack and store limit information.
    //

    ULONG PtrSize = g_Machine->m_Ptr64 ? 8 : 4;

    if ((Status = g_Target->
         ReadPointer((ProcessInfo*)Process, g_Machine, *Teb + PtrSize,
                     StackBase)) != S_OK ||
        (Status = g_Target->
         ReadPointer((ProcessInfo*)Process, g_Machine, *Teb + 2 * PtrSize,
                     StackLimit)) != S_OK)
    {
        return Status;
    }

    *StoreBase = 0;
    *StoreLimit = 0;

    switch(g_Target->m_PlatformId)
    {
    case VER_PLATFORM_WIN32_WINDOWS:
        // Can't have a backing store.
        break;

    case VER_PLATFORM_WIN32_NT:
        if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_IA64)
        {
#if 1
            // XXX drewb - The TEB bstore values don't seem to point to
            // the actual base of the backing store.  Just
            // assume it's contiguous with the stack.
            *StoreBase = *StackBase;
#else
            if ((Status = g_Target->
                 ReadPointer((ProcessInfo*)Process, g_Machine,
                             *Teb + IA64_TEB_BSTORE_BASE,
                             StoreBase)) != S_OK)
            {
                return Status;
            }
#endif
            if ((Status = g_Target->
                 ReadPointer((ProcessInfo*)Process, g_Machine,
                             *Teb + IA64_TEB_BSTORE_BASE + PtrSize,
                             StoreLimit)) != S_OK)
            {
                return Status;
            }
        }
        break;

    default:
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
DbgSystemProvider::GetPeb(IN HANDLE Process,
                          OUT PULONG64 Offset,
                          OUT PULONG Size)
{
    HRESULT Status;
    MEMORY_BASIC_INFORMATION64 MemInfo;
    ULONG64 MemHandle;

    // The passed in process isn't very useful but we know
    // that we're dumping the current state so always
    // retrieve the PEB for the current thread.
    if ((Status = g_Target->
         GetProcessInfoPeb(g_Thread, 0, 0, Offset)) != S_OK)
    {
        return Status;
    }

    //
    // Try and save a whole page for the PEB.  If that's
    // not possible, save as much as is there.
    //

    MemHandle = *Offset;
    if ((Status = g_Target->
         QueryMemoryRegion((ProcessInfo*)Process, &MemHandle,
                           TRUE, &MemInfo)) != S_OK)
    {
        return Status;
    }

    *Size = g_Machine->m_PageSize;
    if (*Offset + *Size > MemInfo.BaseAddress + MemInfo.RegionSize)
    {
        *Size = (ULONG)
            ((MemInfo.BaseAddress + MemInfo.RegionSize) - *Offset);
    }

    return S_OK;
}

HRESULT
DbgSystemProvider::GetProcessTimes(IN HANDLE Process,
                                   OUT LPFILETIME Create,
                                   OUT LPFILETIME User,
                                   OUT LPFILETIME Kernel)
{
    HRESULT Status;
    ULONG64 Create64, Exit64, User64, Kernel64;

    if ((Status = g_Target->GetProcessTimes((ProcessInfo*)Process,
                                            &Create64, &Exit64,
                                            &Kernel64, &User64)) != S_OK)
    {
        return Status;
    }

    Create->dwHighDateTime = (ULONG)(Create64 >> 32);
    Create->dwLowDateTime = (ULONG)Create64;
    User->dwHighDateTime = (ULONG)(User64 >> 32);
    User->dwLowDateTime = (ULONG)User64;
    Kernel->dwHighDateTime = (ULONG)(Kernel64 >> 32);
    Kernel->dwLowDateTime = (ULONG)Kernel64;

    return S_OK;
}

HRESULT
DbgSystemProvider::ReadVirtual(IN HANDLE Process,
                               IN ULONG64 Offset,
                               OUT PVOID Buffer,
                               IN ULONG Request,
                               OUT PULONG Done)
{
    return g_Target->ReadVirtual((ProcessInfo*)Process, Offset,
                                 Buffer, Request, Done);
}

HRESULT
DbgSystemProvider::ReadAllVirtual(IN HANDLE Process,
                                  IN ULONG64 Offset,
                                  OUT PVOID Buffer,
                                  IN ULONG Request)
{
    return g_Target->ReadAllVirtual((ProcessInfo*)Process, Offset,
                                    Buffer, Request);
}

HRESULT
DbgSystemProvider::QueryVirtual(IN HANDLE Process,
                                IN ULONG64 Offset,
                                OUT PULONG64 Base,
                                OUT PULONG64 Size,
                                OUT PULONG Protect,
                                OUT PULONG State,
                                OUT PULONG Type)
{
    HRESULT Status;
    MEMORY_BASIC_INFORMATION64 Info;

    if ((Status = g_Target->
         QueryMemoryRegion((ProcessInfo*)Process, &Offset, TRUE,
                           &Info)) != S_OK)
    {
        return Status;
    }

    *Base = Info.BaseAddress;
    *Size = Info.RegionSize;
    *Protect = Info.Protect;
    *State = Info.State;
    *Type = Info.Type;

    return S_OK;
}

HRESULT
DbgSystemProvider::StartProcessEnum(IN HANDLE Process,
                                    IN ULONG ProcessId)
{
    m_Thread = ((ProcessInfo*)Process)->m_ThreadHead;
    m_Image = ((ProcessInfo*)Process)->m_ImageHead;

    // Unloaded modules aren't critical, so just
    // ignore them if the enumerator fails.
    m_UnlEnum = ((ProcessInfo*)Process)->m_Target->
        GetUnloadedModuleInfo();
    if (m_UnlEnum && m_UnlEnum->Initialize(g_Thread) != S_OK)
    {
        m_UnlEnum = NULL;
    }

    m_FuncTableStart = 0;
    m_FuncTableHandle = 0;

    return S_OK;
}

HRESULT
DbgSystemProvider::EnumThreads(OUT PULONG ThreadId)
{
    if (!m_Thread)
    {
        return S_FALSE;
    }

    *ThreadId = m_Thread->m_SystemId;
    m_Thread = m_Thread->m_Next;
    return S_OK;
}

HRESULT
DbgSystemProvider::EnumModules(OUT PULONG64 Base,
                               OUT PWSTR Path,
                               IN ULONG PathChars)
{
    if (!m_Image)
    {
        return S_FALSE;
    }

    *Base = m_Image->m_BaseOfImage;

    if (!MultiByteToWideChar(CP_ACP, 0,
                             m_Image->m_ImagePath, -1,
                             Path, PathChars))
    {
        return WIN32_LAST_STATUS();
    }

    m_Image = m_Image->m_Next;
    return S_OK;
}

HRESULT
DbgSystemProvider::EnumFunctionTables(OUT PULONG64 MinAddress,
                                      OUT PULONG64 MaxAddress,
                                      OUT PULONG64 BaseAddress,
                                      OUT PULONG EntryCount,
                                      OUT PVOID RawTable,
                                      IN ULONG RawTableSize,
                                      OUT PVOID* RawEntryHandle)
{
    HRESULT Status;
    CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE CpTable;

    if ((Status = g_Target->
         EnumFunctionTables(g_Process,
                            &m_FuncTableStart,
                            &m_FuncTableHandle,
                            MinAddress,
                            MaxAddress,
                            BaseAddress,
                            EntryCount,
                            &CpTable,
                            RawEntryHandle)) != S_OK)
    {
        return Status;
    }

    memcpy(RawTable, &CpTable, RawTableSize);
    return S_OK;
}

HRESULT
DbgSystemProvider::EnumFunctionTableEntries(IN PVOID RawTable,
                                            IN ULONG RawTableSize,
                                            IN PVOID RawEntryHandle,
                                            OUT PVOID RawEntries,
                                            IN ULONG RawEntriesSize)
{
    memcpy(RawEntries, RawEntryHandle, RawEntriesSize);
    free(RawEntryHandle);
    return S_OK;
}

HRESULT
DbgSystemProvider::EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                IN PVOID RawEntries,
                                                IN ULONG Index,
                                                OUT PULONG64 Start,
                                                OUT PULONG Size)
{
    return g_Machine->GetUnwindInfoBounds(g_Process,
                                          TableBase,
                                          RawEntries,
                                          Index,
                                          Start,
                                          Size);
}

HRESULT
DbgSystemProvider::EnumUnloadedModules(OUT PWSTR Path,
                                       IN ULONG PathChars,
                                       OUT PULONG64 BaseOfModule,
                                       OUT PULONG SizeOfModule,
                                       OUT PULONG CheckSum,
                                       OUT PULONG TimeDateStamp)
{
    char UnlName[MAX_INFO_UNLOADED_NAME];
    DEBUG_MODULE_PARAMETERS Params;

    if (!m_UnlEnum ||
        m_UnlEnum->GetEntry(UnlName, &Params) != S_OK)
    {
        return S_FALSE;
    }

    if (!MultiByteToWideChar(CP_ACP, 0,
                             UnlName, -1,
                             Path, PathChars))
    {
        return WIN32_LAST_STATUS();
    }

    *BaseOfModule = Params.Base;
    *SizeOfModule = Params.Size;
    *CheckSum = Params.Checksum;
    *TimeDateStamp = Params.TimeDateStamp;

    return S_OK;
}

void
DbgSystemProvider::FinishProcessEnum(void)
{
    // Nothing to do.
}

HRESULT
DbgSystemProvider::StartHandleEnum(IN HANDLE Process,
                                   IN ULONG ProcessId,
                                   OUT PULONG Count)
{
    m_Handle = 4;

    // If the target doesn't have handle data don't make
    // it a fatal error, just don't enumerate anything.
    if (g_Target->
        ReadHandleData((ProcessInfo*)Process, 0,
                       DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT,
                       Count, sizeof(*Count), NULL) != S_OK)
    {
        *Count = 0;
    }

    return S_OK;
}

HRESULT
DbgSystemProvider::EnumHandles(OUT PULONG64 Handle,
                               OUT PULONG Attributes,
                               OUT PULONG GrantedAccess,
                               OUT PULONG HandleCount,
                               OUT PULONG PointerCount,
                               OUT PWSTR TypeName,
                               IN ULONG TypeNameChars,
                               OUT PWSTR ObjectName,
                               IN ULONG ObjectNameChars)
{
    DEBUG_HANDLE_DATA_BASIC BasicInfo;

    for (;;)
    {
        if (m_Handle >= (1 << 24))
        {
            return S_FALSE;
        }

        // If we can't get the basic info and type there isn't much
        // point in writing anything out so skip the handle.
        if (g_Target->
            ReadHandleData(g_Process, m_Handle,
                           DEBUG_HANDLE_DATA_TYPE_BASIC,
                           &BasicInfo, sizeof(BasicInfo), NULL) == S_OK &&
            SUCCEEDED(g_Target->
                      ReadHandleData(g_Process, m_Handle,
                                     DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE,
                                     TypeName,
                                     TypeNameChars * sizeof(*TypeName),
                                     NULL)))
        {
            break;
        }

        m_Handle += 4;
    }

    // Try and get the object name.
    if (FAILED(g_Target->
               ReadHandleData(g_Process, m_Handle,
                              DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE,
                              ObjectName,
                              ObjectNameChars * sizeof(*ObjectName),
                              NULL)))
    {
        *ObjectName = 0;
    }

    *Handle = m_Handle;
    *Attributes = BasicInfo.Attributes;
    *GrantedAccess = BasicInfo.GrantedAccess;
    *HandleCount = BasicInfo.HandleCount;
    *PointerCount = BasicInfo.PointerCount;

    m_Handle += 4;
    return S_OK;
}

void
DbgSystemProvider::FinishHandleEnum(void)
{
    // Nothing to do.
}

HRESULT
DbgSystemProvider::EnumPebMemory(IN HANDLE Process,
                                 IN ULONG64 PebOffset,
                                 IN ULONG PebSize,
                                 IN MiniDumpProviderCallbacks* Callback)
{
    if (g_Target->m_SystemVersion <= NT_SVER_START ||
        g_Target->m_SystemVersion >= NT_SVER_END)
    {
        // Basic Win32 doesn't have a defined PEB.
        return S_OK;
    }

    // XXX drewb - This requires a whole set of constants
    // to abstract data structure locations.  Leave it
    // for when we really need it.
    return S_OK;
}

HRESULT
DbgSystemProvider::EnumTebMemory(IN HANDLE Process,
                                 IN HANDLE Thread,
                                 IN ULONG64 TebOffset,
                                 IN ULONG TebSize,
                                 IN MiniDumpProviderCallbacks* Callback)
{
    if (g_Target->m_SystemVersion <= NT_SVER_START ||
        g_Target->m_SystemVersion >= NT_SVER_END)
    {
        // Basic Win32 doesn't have a defined TEB beyond
        // the TIB.  The TIB can reference fiber data but
        // that's NT-specific.
        return S_OK;
    }

    // XXX drewb - This requires a whole set of constants
    // to abstract data structure locations.  Leave it
    // for when we really need it.
    return S_OK;
}

HRESULT
DbgSystemProvider::GetCorDataAccess(IN PWSTR AccessDllName,
                                    IN struct ICorDataAccessServices*
                                    Services,
                                    OUT struct ICorDataAccess**
                                    Access)
{
    HRESULT Status;

    // We're providing all of the system services to
    // the minidump code so we know that its state
    // matches what's available directly from the debugger's
    // state.  Just ignore the given DLL name and
    // service interface in favor of the one the
    // debugger already has.
    if ((Status = g_Process->LoadCorDebugDll()) != S_OK)
    {
        return Status;
    }

    *Access = g_Process->m_CorAccess;
    return S_OK;
}

void
DbgSystemProvider::ReleaseCorDataAccess(IN struct ICorDataAccess*
                                        Access)
{
    // No work necessary.
}

PMINIDUMP_EXCEPTION_INFORMATION64
CreateMiniExceptionInformation(PMINIDUMP_EXCEPTION_INFORMATION64 ExInfo,
                               PEXCEPTION_RECORD ExRecord,
                               PCROSS_PLATFORM_CONTEXT Context)
{
    // If the last event was an exception put together
    // exception information in minidump format.
    if (g_LastEventType != DEBUG_EVENT_EXCEPTION ||
        g_Process != g_EventProcess)
    {
        return NULL;
    }

    // Get the full context for the event thread.
    g_Target->ChangeRegContext(g_EventThread);
    if (g_Machine->GetContextState(MCTX_CONTEXT) != S_OK)
    {
        return NULL;
    }
    *Context = g_Machine->m_Context;

    ExInfo->ThreadId = g_EventThreadSysId;
    ExInfo->ClientPointers = FALSE;
    ExInfo->ExceptionRecord = (LONG_PTR)ExRecord;
    ExceptionRecord64To(&g_LastEventInfo.Exception.ExceptionRecord, ExRecord);
    ExInfo->ContextRecord = (LONG_PTR)Context;

    return ExInfo;
}

BOOL WINAPI
MicroDumpCallback(
    IN PVOID CallbackParam,
    IN CONST PMINIDUMP_CALLBACK_INPUT CallbackInput,
    IN OUT PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    )
{
    switch(CallbackInput->CallbackType)
    {
    case IncludeModuleCallback:
        // Mask off all flags other than the basic write flag.
        CallbackOutput->ModuleWriteFlags &= ModuleWriteModule;
        break;
    case ModuleCallback:
        // Eliminate all unreferenced modules.
        if (!(CallbackOutput->ModuleWriteFlags & ModuleReferencedByMemory))
        {
            CallbackOutput->ModuleWriteFlags = 0;
        }
        break;
    case IncludeThreadCallback:
        if (CallbackInput->IncludeThread.ThreadId != g_EventThreadSysId)
        {
            return FALSE;
        }

        // Reduce write to the minimum of information
        // necessary for a stack walk.
        CallbackOutput->ThreadWriteFlags &= ~ThreadWriteInstructionWindow;
        break;
    }

    return TRUE;
}

HRESULT
UserMiniDumpTargetInfo::Write(HANDLE hFile, ULONG FormatFlags,
                              PCSTR CommentA, PCWSTR CommentW)
{
    if (!IS_USER_TARGET(g_Target))
    {
        ErrOut("User minidumps can only be written in user-mode sessions\n");
        return E_UNEXPECTED;
    }

    dprintf("mini user dump\n");
    FlushCallbacks();

    HRESULT Status;
    MINIDUMP_EXCEPTION_INFORMATION64 ExInfoBuf, *ExInfo;
    EXCEPTION_RECORD ExRecord;
    CROSS_PLATFORM_CONTEXT Context;
    ULONG MiniType;
    MINIDUMP_USER_STREAM UserStreams[2];
    MINIDUMP_USER_STREAM_INFORMATION UserStreamInfo;
    MINIDUMP_CALLBACK_INFORMATION CallbackBuffer;
    PMINIDUMP_CALLBACK_INFORMATION Callback;

    MiniType = MiniDumpNormal;
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_FULL_MEMORY)
    {
        MiniType |= MiniDumpWithFullMemory;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_HANDLE_DATA)
    {
        MiniType |= MiniDumpWithHandleData;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES)
    {
        MiniType |= MiniDumpWithUnloadedModules;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY)
    {
        MiniType |= MiniDumpWithIndirectlyReferencedMemory;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS)
    {
        MiniType |= MiniDumpWithDataSegs;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY)
    {
        MiniType |= MiniDumpFilterMemory;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_FILTER_PATHS)
    {
        MiniType |= MiniDumpFilterModulePaths;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA)
    {
        MiniType |= MiniDumpWithProcessThreadData;
    }
    if (FormatFlags & DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY)
    {
        MiniType |= MiniDumpWithPrivateReadWriteMemory;
    }

    UserStreamInfo.UserStreamCount = 0;
    UserStreamInfo.UserStreamArray = UserStreams;
    if (CommentA != NULL)
    {
        UserStreams[UserStreamInfo.UserStreamCount].Type =
            CommentStreamA;
        UserStreams[UserStreamInfo.UserStreamCount].BufferSize =
            strlen(CommentA) + 1;
        UserStreams[UserStreamInfo.UserStreamCount].Buffer =
            (PVOID)CommentA;
        UserStreamInfo.UserStreamCount++;
    }
    if (CommentW != NULL)
    {
        UserStreams[UserStreamInfo.UserStreamCount].Type =
            CommentStreamW;
        UserStreams[UserStreamInfo.UserStreamCount].BufferSize =
            (wcslen(CommentW) + 1) * sizeof(WCHAR);
        UserStreams[UserStreamInfo.UserStreamCount].Buffer =
            (PVOID)CommentW;
        UserStreamInfo.UserStreamCount++;
    }

    ExInfo = CreateMiniExceptionInformation(&ExInfoBuf, &ExRecord, &Context);

    if (FormatFlags & FORMAT_USER_MICRO)
    {
        // This case isn't expected to be used by users,
        // it's for testing of the microdump support.
        Callback = &CallbackBuffer;
        Callback->CallbackRoutine = MicroDumpCallback;
        Callback->CallbackParam = NULL;
        ExInfo = NULL;
        MiniType |= MiniDumpScanMemory;
    }
    else
    {
        Callback = NULL;
    }

    HANDLE ProcHandle;
    MiniDumpSystemProvider* SysProv = NULL;
    MiniDumpOutputProvider* OutProv = NULL;
    MiniDumpAllocationProvider* AllocProv = NULL;

    if ((Status =
         MiniDumpCreateFileOutputProvider(hFile, &OutProv)) != S_OK ||
        (Status =
         MiniDumpCreateLiveAllocationProvider(&AllocProv)) != S_OK)
    {
        goto Exit;
    }

    //
    // If we're live we can let the official minidump
    // code do all the work.  If not, hook up a provider
    // that uses debugger information.  This provider
    // could always be used but the default live-system
    // provider offers slightly more information so
    // check and use that if possible.
    //

    if (IS_LIVE_USER_TARGET(g_Target) &&
        ((LiveUserTargetInfo*)g_Target)->m_Local)
    {
        if ((Status =
             MiniDumpCreateLiveSystemProvider(&SysProv)) != S_OK)
        {
            goto Exit;
        }

        ProcHandle = OS_HANDLE(g_Process->m_SysHandle);
    }
    else
    {
        DbgSystemProvider* DbgSysProv = new DbgSystemProvider;
        if (!DbgSysProv)
        {
            Status = E_OUTOFMEMORY;
            goto Exit;
        }

        SysProv = DbgSysProv;
        ProcHandle = (HANDLE)g_Process;
    }

    Status = MiniDumpProvideDump(ProcHandle, g_Process->m_SystemId,
                                 SysProv, OutProv, AllocProv,
                                 MiniType, ExInfo,
                                 &UserStreamInfo, Callback);

 Exit:

    if (Status != S_OK)
    {
        ErrOut("Dump creation failed, %s\n    \"%s\"\n",
               FormatStatusCode(Status), FormatStatus(Status));
    }

    if (SysProv)
    {
        SysProv->Release();
    }
    if (OutProv)
    {
        OutProv->Release();
    }
    if (AllocProv)
    {
        AllocProv->Release();
    }

    // Reset the current register context in case
    // it was changed at some point.
    g_Target->ChangeRegContext(g_Thread);

    return Status;
}

//-------------------------------------------------------------------
//  initialize the dump headers
//

#define MINIDUMP_BUGCHECK 0x10000000

void
KernelDumpTargetInfo::InitDumpHeader32(
    PDUMP_HEADER32 pdh,
    PCSTR CommentA,
    PCWSTR CommentW,
    ULONG BugCheckCodeModifier
    )
{
    ULONG64 Data[4];
    PULONG  FillPtr = (PULONG)pdh;

    while (FillPtr < (PULONG)(pdh + 1))
    {
        *FillPtr++ = DUMP_SIGNATURE32;
    }

    pdh->Signature           = DUMP_SIGNATURE32;
    pdh->ValidDump           = DUMP_VALID_DUMP32;
    pdh->MajorVersion        = g_Target->m_KdVersion.MajorVersion;
    pdh->MinorVersion        = g_Target->m_KdVersion.MinorVersion;

    g_Target->ReadDirectoryTableBase(Data);
    pdh->DirectoryTableBase  = (ULONG)Data[0];

    pdh->PfnDataBase         =
        (ULONG)g_Target->m_KdDebuggerData.MmPfnDatabase;
    pdh->PsLoadedModuleList  =
        (ULONG)g_Target->m_KdDebuggerData.PsLoadedModuleList;
    pdh->PsActiveProcessHead =
        (ULONG)g_Target->m_KdDebuggerData.PsActiveProcessHead;
    pdh->MachineImageType    = g_Target->m_KdVersion.MachineType;
    pdh->NumberProcessors    = g_Target->m_NumProcessors;

    g_Target->ReadBugCheckData(&(pdh->BugCheckCode), Data);
    pdh->BugCheckCode       |= BugCheckCodeModifier;
    pdh->BugCheckParameter1  = (ULONG)Data[0];
    pdh->BugCheckParameter2  = (ULONG)Data[1];
    pdh->BugCheckParameter3  = (ULONG)Data[2];
    pdh->BugCheckParameter4  = (ULONG)Data[3];

    //pdh->VersionUser         = 0;
    pdh->PaeEnabled          = g_Target->m_KdDebuggerData.PaeEnabled;
    pdh->KdDebuggerDataBlock = (ULONG)g_Target->m_KdDebuggerDataOffset;

    // pdh->PhysicalMemoryBlock =;

    g_Machine->GetContextState(MCTX_CONTEXT);
    g_Machine->ConvertContextTo(&g_Machine->m_Context,
                                g_Target->m_SystemVersion,
                                sizeof(pdh->ContextRecord),
                                pdh->ContextRecord);

    if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
    {
        // Use the exception record from the last event.
        ExceptionRecord64To32(&g_LastEventInfo.Exception.ExceptionRecord,
                              &pdh->Exception);
    }
    else
    {
        ADDR PcAddr;

        // Fake a breakpoint exception.
        ZeroMemory(&pdh->Exception, sizeof(pdh->Exception));
        pdh->Exception.ExceptionCode = STATUS_BREAKPOINT;
        g_Machine->GetPC(&PcAddr);
        pdh->Exception.ExceptionAddress = (ULONG)Flat(PcAddr);
    }

    pdh->RequiredDumpSpace.QuadPart = TRIAGE_DUMP_SIZE32;

    pdh->SystemTime.QuadPart = g_Target->GetCurrentTimeDateN();
    pdh->SystemUpTime.QuadPart = g_Target->GetCurrentSystemUpTimeN();

    if (g_Target->m_ProductType != INVALID_PRODUCT_TYPE)
    {
        pdh->ProductType = g_Target->m_ProductType;
        pdh->SuiteMask = g_Target->m_SuiteMask;
    }

    PSTR ConvComment = NULL;

    if (!CommentA && CommentW)
    {
        if (WideToAnsi(CommentW, &ConvComment) != S_OK)
        {
            ConvComment = NULL;
        }
        else
        {
            CommentA = ConvComment;
        }
    }
    if (CommentA != NULL && CommentA[0])
    {
        CopyString(pdh->Comment, CommentA, DIMA(pdh->Comment));
    }
    FreeAnsi(ConvComment);
}

void
KernelDumpTargetInfo::InitDumpHeader64(
    PDUMP_HEADER64 pdh,
    PCSTR CommentA,
    PCWSTR CommentW,
    ULONG BugCheckCodeModifier
    )
{
    ULONG64 Data[4];
    PULONG  FillPtr = (PULONG)pdh;

    while (FillPtr < (PULONG)(pdh + 1))
    {
        *FillPtr++ = DUMP_SIGNATURE32;
    }

    pdh->Signature           = DUMP_SIGNATURE64;
    pdh->ValidDump           = DUMP_VALID_DUMP64;
    pdh->MajorVersion        = g_Target->m_KdVersion.MajorVersion;
    pdh->MinorVersion        = g_Target->m_KdVersion.MinorVersion;

    // IA64 has several page directories.  The defined
    // behavior is to put the kernel page directory
    // in the dump header as that's the one that can
    // be most useful when first initializing the dump.
    if (g_Target->m_EffMachineType == IMAGE_FILE_MACHINE_IA64)
    {
        ULONG Next;

        if (g_Machine->
            SetPageDirectory(g_Thread, PAGE_DIR_KERNEL, 0, &Next) != S_OK)
        {
            ErrOut("Unable to update the kernel dirbase\n");
            Data[0] = 0;
        }
        else
        {
            Data[0] = g_Machine->m_PageDirectories[PAGE_DIR_KERNEL];
        }
    }
    else
    {
        g_Target->ReadDirectoryTableBase(Data);
    }
    pdh->DirectoryTableBase  = Data[0];

    pdh->PfnDataBase         =
        g_Target->m_KdDebuggerData.MmPfnDatabase;
    pdh->PsLoadedModuleList  =
        g_Target->m_KdDebuggerData.PsLoadedModuleList;
    pdh->PsActiveProcessHead =
        g_Target->m_KdDebuggerData.PsActiveProcessHead;
    pdh->MachineImageType    = g_Target->m_KdVersion.MachineType;
    pdh->NumberProcessors    = g_Target->m_NumProcessors;

    g_Target->ReadBugCheckData(&(pdh->BugCheckCode), Data);
    pdh->BugCheckCode       |= BugCheckCodeModifier;
    pdh->BugCheckParameter1  = Data[0];
    pdh->BugCheckParameter2  = Data[1];
    pdh->BugCheckParameter3  = Data[2];
    pdh->BugCheckParameter4  = Data[3];

    //pdh->VersionUser         = 0;

    pdh->KdDebuggerDataBlock = g_Target->m_KdDebuggerDataOffset;

    // pdh->PhysicalMemoryBlock =;

    g_Machine->GetContextState(MCTX_CONTEXT);
    g_Machine->ConvertContextTo(&g_Machine->m_Context,
                                g_Target->m_SystemVersion,
                                sizeof(pdh->ContextRecord),
                                pdh->ContextRecord);

    if (g_LastEventType == DEBUG_EVENT_EXCEPTION)
    {
        // Use the exception record from the last event.
        pdh->Exception = g_LastEventInfo.Exception.ExceptionRecord;
    }
    else
    {
        ADDR PcAddr;

        // Fake a breakpoint exception.
        ZeroMemory(&pdh->Exception, sizeof(pdh->Exception));
        pdh->Exception.ExceptionCode = STATUS_BREAKPOINT;
        g_Machine->GetPC(&PcAddr);
        pdh->Exception.ExceptionAddress = Flat(PcAddr);
    }

    pdh->RequiredDumpSpace.QuadPart = TRIAGE_DUMP_SIZE64;

    pdh->SystemTime.QuadPart = g_Target->GetCurrentTimeDateN();
    pdh->SystemUpTime.QuadPart = g_Target->GetCurrentSystemUpTimeN();

    if (g_Target->m_ProductType != INVALID_PRODUCT_TYPE)
    {
        pdh->ProductType = g_Target->m_ProductType;
        pdh->SuiteMask = g_Target->m_SuiteMask;
    }

    PSTR ConvComment = NULL;

    if (!CommentA && CommentW)
    {
        if (WideToAnsi(CommentW, &ConvComment) != S_OK)
        {
            ConvComment = NULL;
        }
        else
        {
            CommentA = ConvComment;
        }
    }
    if (CommentA != NULL && CommentA[0])
    {
        CopyString(pdh->Comment, CommentA, DIMA(pdh->Comment));
    }
    FreeAnsi(ConvComment);
}

//----------------------------------------------------------------------------
//
// KernelFull64DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

HRESULT
KernelFull64DumpTargetInfo::Write(HANDLE File, ULONG FormatFlags,
                                  PCSTR CommentA, PCWSTR CommentW)
{
    PDUMP_HEADER64 DumpHeader64;
    HRESULT Status;
    ULONG64 Offset;
    PPHYSICAL_MEMORY_DESCRIPTOR64 PhysMem = NULL;
    DWORD i, j;
    PUCHAR PageBuffer = NULL;
    DWORD BytesRead;
    DWORD BytesWritten;
    DWORD Percent;
    ULONG64 CurrentPagesWritten;
    DbgKdTransport* KdTrans;

    DumpHeader64 = (PDUMP_HEADER64) LocalAlloc(LPTR, sizeof(DUMP_HEADER64));
    if (DumpHeader64 == NULL)
    {
        ErrOut("Failed to allocate dump header buffer\n");
        return E_OUTOFMEMORY;
    }

    if (!IS_REMOTE_KERNEL_TARGET(g_Target) && !IS_KERNEL_FULL_DUMP(g_Target))
    {
        ErrOut("\nKernel full dumps can only be written when all of physical "
               "memory is accessible - aborting now\n");
        return E_INVALIDARG;
    }

    if (IS_CONN_KERNEL_TARGET(g_Target))
    {
        KdTrans = ((ConnLiveKernelTargetInfo*)g_Target)->m_Transport;
    }
    else
    {
        KdTrans = NULL;
    }

    dprintf("Full kernel dump\n");
    FlushCallbacks();

    KernelDumpTargetInfo::InitDumpHeader64(DumpHeader64,
                                           CommentA, CommentW, 0);
    DumpHeader64->DumpType = DUMP_TYPE_FULL;
    DumpHeader64->WriterStatus = DUMP_DBGENG_SUCCESS;

    //
    // now copy the memory descriptor list to our header..
    // first get the pointer va
    //

    Status = g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                                   g_Target->m_KdDebuggerData.
                                   MmPhysicalMemoryBlock,
                                   &Offset);
    if (Status != S_OK || (Offset == 0))
    {
        ErrOut("Unable to read MmPhysicalMemoryBlock\n");
        Status = Status != S_OK ? Status : E_INVALIDARG;
    }
    else
    {
        //
        // first read the memory descriptor size...
        //

        PhysMem = &DumpHeader64->PhysicalMemoryBlock;
        Status = g_Target->
            ReadVirtual(g_Process, Offset,
                        PhysMem, DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64,
                        &BytesRead);
        if (Status != S_OK ||
            BytesRead < sizeof(*PhysMem) +
            (sizeof(PhysMem->Run[0]) * (PhysMem->NumberOfRuns - 1)))
        {
            ErrOut("Unable to read MmPhysicalMemoryBlock\n");
            Status = Status != S_OK ? Status : E_INVALIDARG;
        }
        else
        {
            //
            // calculate total dump file size
            //

            DumpHeader64->RequiredDumpSpace.QuadPart =
                    DumpHeader64->PhysicalMemoryBlock.NumberOfPages *
                    g_Machine->m_PageSize;

            //
            // write dump header to crash dump file
            //

            if (!WriteFile(File,
                           DumpHeader64,
                           sizeof(DUMP_HEADER64),
                           &BytesWritten,
                           NULL))
            {
                Status = WIN32_LAST_STATUS();
                ErrOut("Failed writing to crashdump file - %s\n    \"%s\"\n",
                        FormatStatusCode(Status),
                        FormatStatusArgs(Status, NULL));
            }
        }
    }

    if (Status == S_OK)
    {
        PageBuffer = (PUCHAR) LocalAlloc(LPTR, g_Machine->m_PageSize);
        if (PageBuffer == NULL)
        {
            ErrOut("Failed to allocate double buffer\n");
        }
        else
        {
            //
            // now write the physical memory out to disk.
            // we use the dump header to retrieve the physical memory base and
            // run count then ask the transport to gecth these pages form the
            // target.  On 1394, the virtual debugger driver will do physical
            // address reads on the remote host since there is a onoe-to-one
            // relationships between physical 1394 and physical mem addresses.
            //

            CurrentPagesWritten = 0;
            Percent = 0;

            for (i = 0; i < PhysMem->NumberOfRuns; i++)
            {
                Offset = 0;
                Offset = PhysMem->Run[i].BasePage*g_Machine->m_PageSize;

                if (CheckUserInterrupt())
                {
                    ErrOut("Creation of crashdump file interrupted\n");
                    Status = E_ABORT;
                    break;
                }

                for (j = 0; j< PhysMem->Run[i].PageCount; j++)
                {
                    //
                    // printout the percent done every 5% increments
                    //

                    if ((CurrentPagesWritten*100) / PhysMem->NumberOfPages ==
                        Percent)
                    {
                        dprintf("Percent written %d \n", Percent);
                        FlushCallbacks();
                        if (KdTrans &&
                            KdTrans->m_DirectPhysicalMemory)
                        {
                            Percent += 5;
                        }
                        else
                        {
                            Percent += 1;
                        }
                    }

                    if (KdTrans &&
                        KdTrans->m_DirectPhysicalMemory)
                    {
                        Status = KdTrans->
                            ReadTargetPhysicalMemory(Offset,
                                                     PageBuffer,
                                                     g_Machine->m_PageSize,
                                                     &BytesWritten);
                    }
                    else
                    {
                        Status = g_Target->ReadPhysical(Offset,
                                                        PageBuffer,
                                                        g_Machine->m_PageSize,
                                                        PHYS_FLAG_DEFAULT,
                                                        &BytesWritten);
                    }

                    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                    {
                        break;
                    }
                    else if (Status != S_OK)
                    {
                        ErrOut("Failed Reading page for crashdump file\n");
                        break;
                    }
                    else
                    {
                        //
                        // now write the page to the local crashdump file
                        //

                        if (!WriteFile(File,
                                       PageBuffer,
                                       g_Machine->m_PageSize,
                                       &BytesWritten,
                                       NULL))
                        {
                            Status = WIN32_LAST_STATUS();
                            ErrOut("Failed writing header to crashdump file - %s\n    \"%s\"\n",
                                    FormatStatusCode(Status),
                                    FormatStatusArgs(Status, NULL));
                            break;
                        }

                        Offset += g_Machine->m_PageSize;
                        CurrentPagesWritten++;
                    }
                }
            }

            if (Status == S_OK)
            {
                dprintf("CrashDump write complete\n");
            }
            LocalFree(PageBuffer);
        }
    }

    LocalFree(DumpHeader64);

    return Status;
}

//----------------------------------------------------------------------------
//
// KernelFull32DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

HRESULT
KernelFull32DumpTargetInfo::Write(HANDLE File, ULONG FormatFlags,
                                  PCSTR CommentA, PCWSTR CommentW)
{
    PDUMP_HEADER32 DumpHeader32 = NULL;
    HRESULT Status;
    ULONG64 Offset;
    PPHYSICAL_MEMORY_DESCRIPTOR32 PhysMem = NULL;
    DWORD i, j;
    PUCHAR PageBuffer = NULL;
    DWORD BytesRead;
    DWORD BytesWritten;
    DWORD Percent;
    ULONG CurrentPagesWritten;
    DbgKdTransport* KdTrans;

    DumpHeader32 = (PDUMP_HEADER32) LocalAlloc(LPTR, sizeof(DUMP_HEADER32));
    if (DumpHeader32 == NULL)
    {
        ErrOut("Failed to allocate dump header buffer\n");
        return E_OUTOFMEMORY;
    }

    if (!IS_REMOTE_KERNEL_TARGET(g_Target) && !IS_KERNEL_FULL_DUMP(g_Target))
    {
        ErrOut("\nKernel full dumps can only be written when all of physical "
               "memory is accessible - aborting now\n");
        return E_INVALIDARG;
    }

    if (IS_CONN_KERNEL_TARGET(g_Target))
    {
        KdTrans = ((ConnLiveKernelTargetInfo*)g_Target)->m_Transport;
    }
    else
    {
        KdTrans = NULL;
    }

    dprintf("Full kernel dump\n");
    FlushCallbacks();

    //
    // Build the header
    //

    KernelDumpTargetInfo::InitDumpHeader32(DumpHeader32,
                                           CommentA, CommentW, 0);
    DumpHeader32->DumpType = DUMP_TYPE_FULL;
    DumpHeader32->WriterStatus = DUMP_DBGENG_SUCCESS;

    //
    // now copy the memory descriptor list to our header..
    // first get the pointer va
    //

    Status = g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                                   g_Target->m_KdDebuggerData.
                                   MmPhysicalMemoryBlock,
                                   &Offset);
    if (Status != S_OK || (Offset == 0))
    {
        ErrOut("Unable to read MmPhysicalMemoryBlock\n");
        Status = Status != S_OK ? Status : E_INVALIDARG;
    }
    else
    {
        //
        // first read the memory descriptor size...
        //

        PhysMem = &DumpHeader32->PhysicalMemoryBlock;
        Status = g_Target->
            ReadVirtual(g_Process, Offset,
                        PhysMem, DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32,
                        &BytesRead);
        if (Status != S_OK ||
            BytesRead < sizeof(*PhysMem) +
            (sizeof(PhysMem->Run[0]) * (PhysMem->NumberOfRuns - 1)))
        {
            ErrOut("Unable to read MmPhysicalMemoryBlock\n");
            Status = Status != S_OK ? Status : E_INVALIDARG;
        }
        else
        {
            //
            // calculate total dump file size
            //

            DumpHeader32->RequiredDumpSpace.QuadPart =
                    DumpHeader32->PhysicalMemoryBlock.NumberOfPages *
                    g_Machine->m_PageSize;

            //
            // write dump header to crash dump file
            //

            if (!WriteFile(File,
                           DumpHeader32,
                           sizeof(DUMP_HEADER32),
                           &BytesWritten,
                           NULL))
            {
                Status = WIN32_LAST_STATUS();
                ErrOut("Failed writing to crashdump file - %s\n    \"%s\"\n",
                        FormatStatusCode(Status),
                        FormatStatusArgs(Status, NULL));
            }
        }
    }

    if (Status == S_OK)
    {
        PageBuffer = (PUCHAR) LocalAlloc(LPTR, g_Machine->m_PageSize);
        if (PageBuffer == NULL)
        {
            ErrOut("Failed to allocate double buffer\n");
        }
        else
        {
            //
            // now write the physical memory out to disk.
            // we use the dump header to retrieve the physical memory base and
            // run count then ask the transport to gecth these pages form the
            // target.  On 1394, the virtual debugger driver will do physical
            // address reads on the remote host since there is a onoe-to-one
            // relationships between physical 1394 and physical mem addresses.
            //

            CurrentPagesWritten = 0;
            Percent = 0;

            for (i = 0; i < PhysMem->NumberOfRuns; i++)
            {
                Offset = 0;
                Offset = PhysMem->Run[i].BasePage*g_Machine->m_PageSize;

                if (CheckUserInterrupt())
                {
                    ErrOut("Creation of crashdump file interrupted\n");
                    Status = E_ABORT;
                    break;
                }

                for (j = 0; j< PhysMem->Run[i].PageCount; j++)
                {
                    //
                    // printout the percent done every 5% increments
                    //

                    if ((CurrentPagesWritten*100) / PhysMem->NumberOfPages ==
                        Percent)
                    {
                        dprintf("Percent written %d \n", Percent);
                        FlushCallbacks();
                        if (KdTrans &&
                            KdTrans->m_DirectPhysicalMemory)
                        {
                            Percent += 5;
                        }
                        else
                        {
                            Percent += 1;
                        }
                    }

                    if (KdTrans &&
                        KdTrans->m_DirectPhysicalMemory)
                    {
                        Status = KdTrans->
                            ReadTargetPhysicalMemory(Offset,
                                                     PageBuffer,
                                                     g_Machine->m_PageSize,
                                                     &BytesWritten);
                    }
                    else
                    {
                        Status = g_Target->ReadPhysical(Offset,
                                                        PageBuffer,
                                                        g_Machine->m_PageSize,
                                                        PHYS_FLAG_DEFAULT,
                                                        &BytesWritten);
                    }

                    if (g_EngStatus & ENG_STATUS_USER_INTERRUPT)
                    {
                        break;
                    }
                    else if (Status != S_OK)
                    {
                        ErrOut("Failed Reading page for crashdump file\n");
                        break;
                    }
                    else
                    {
                        //
                        // now write the page to the local crashdump file
                        //

                        if (!WriteFile(File,
                                       PageBuffer,
                                       g_Machine->m_PageSize,
                                       &BytesWritten,
                                       NULL))
                        {
                            Status = WIN32_LAST_STATUS();
                            ErrOut("Failed writing header to crashdump file - %s\n    \"%s\"\n",
                                    FormatStatusCode(Status),
                                    FormatStatusArgs(Status, NULL));
                            break;
                        }

                        Offset += g_Machine->m_PageSize;
                        CurrentPagesWritten++;
                    }
                }
            }

            if (Status == S_OK)
            {
                dprintf("CrashDump write complete\n");
            }
            LocalFree(PageBuffer);
        }
    }

    LocalFree(DumpHeader32);

    return Status;
}

enum
{
    GNME_ENTRY,
    GNME_DONE,
    GNME_NO_NAME,
    GNME_CORRUPT,
};

DWORD
GetNextModuleEntry(
    ModuleInfo *ModIter,
    MODULE_INFO_ENTRY *ModEntry
    )
{
    HRESULT Status;
    
    ZeroMemory(ModEntry, sizeof(MODULE_INFO_ENTRY));

    if ((Status = ModIter->GetEntry(ModEntry)) != S_OK)
    {
        return Status == S_FALSE ? GNME_DONE : GNME_CORRUPT;
    }

    if (ModEntry->NameLength > (MAX_IMAGE_PATH - 1) *
        (ModEntry->UnicodeNamePtr ? sizeof(WCHAR) : sizeof(CHAR)))
    {
        ErrOut("Module list is corrupt.");
        if (IS_KERNEL_TARGET(g_Target))
        {
            ErrOut("  Check your kernel symbols.\n");
        }
        else
        {
            ErrOut("  Loader list may be invalid\n");
        }
        return GNME_CORRUPT;
    }

    // If this entry has no name just skip it.
    if (!ModEntry->NamePtr || !ModEntry->NameLength)
    {
        ErrOut("  Module List has empty entry in it - skipping\n");
        return GNME_NO_NAME;
    }

    // If the image header information couldn't be read
    // we end up with placeholder values for certain entries.
    // The kernel writes out zeroes in this case so copy
    // its behavior so that there's one consistent value
    // for unknown.
    if (ModEntry->CheckSum == UNKNOWN_CHECKSUM)
    {
        ModEntry->CheckSum = 0;
    }
    if (ModEntry->TimeDateStamp == UNKNOWN_TIMESTAMP)
    {
        ModEntry->TimeDateStamp = 0;
    }

    return GNME_ENTRY;
}

//----------------------------------------------------------------------------
//
// Shared triage writing things.
//
//----------------------------------------------------------------------------

#define ExtractValue(NAME, val)  {                                        \
    if (!g_Target->m_KdDebuggerData.NAME) {                               \
        val = 0;                                                          \
        ErrOut("KdDebuggerData." #NAME " is NULL\n");                     \
    } else {                                                              \
        g_Target->ReadAllVirtual(g_Process,                               \
                                 g_Target->m_KdDebuggerData.NAME, &(val), \
                                 sizeof(val));                            \
    }                                                                     \
}

inline ALIGN_8(unsigned Offset)
{
    return (Offset + 7) & 0xfffffff8;
}

const unsigned MAX_TRIAGE_STACK_SIZE32 = 16 * 1024;
const unsigned MAX_TRIAGE_STACK_SIZE64 = 32 * 1024;
const unsigned MAX_TRIAGE_BSTORE_SIZE = 16 * 4096;  // as defined in ntia64.h
const ULONG TRIAGE_DRIVER_NAME_SIZE_GUESS = 0x40;

typedef struct _TRIAGE_PTR_DATA_BLOCK
{
    ULONG64 MinAddress;
    ULONG64 MaxAddress;
} TRIAGE_PTR_DATA_BLOCK, *PTRIAGE_PTR_DATA_BLOCK;

// A triage dump is sixteen pages long.  Some of that is
// header information and at least a few other pages will
// be used for basic dump information so limit the number
// of extra data blocks to something less than sixteen
// to save array space.
#define IO_MAX_TRIAGE_DUMP_DATA_BLOCKS 8

ULONG IopNumTriageDumpDataBlocks;
TRIAGE_PTR_DATA_BLOCK IopTriageDumpDataBlocks[IO_MAX_TRIAGE_DUMP_DATA_BLOCKS];

//
// If space is available in a triage dump it's possible
// to add "interesting" data pages referenced by runtime
// information such as context registers.  The following
// lists are offsets into the CONTEXT structure of pointers
// which usually point to interesting data.  They are
// in priority order.
//

#define IOP_LAST_CONTEXT_OFFSET 0xffff

USHORT IopRunTimeContextOffsetsX86[] =
{
    FIELD_OFFSET(X86_NT5_CONTEXT, Ebx),
    FIELD_OFFSET(X86_NT5_CONTEXT, Esi),
    FIELD_OFFSET(X86_NT5_CONTEXT, Edi),
    FIELD_OFFSET(X86_NT5_CONTEXT, Ecx),
    FIELD_OFFSET(X86_NT5_CONTEXT, Edx),
    FIELD_OFFSET(X86_NT5_CONTEXT, Eax),
    FIELD_OFFSET(X86_NT5_CONTEXT, Eip),
    IOP_LAST_CONTEXT_OFFSET
};

USHORT IopRunTimeContextOffsetsIa64[] =
{
    FIELD_OFFSET(IA64_CONTEXT, IntS0),
    FIELD_OFFSET(IA64_CONTEXT, IntS1),
    FIELD_OFFSET(IA64_CONTEXT, IntS2),
    FIELD_OFFSET(IA64_CONTEXT, IntS3),
    FIELD_OFFSET(IA64_CONTEXT, StIIP),
    IOP_LAST_CONTEXT_OFFSET
};

USHORT IopRunTimeContextOffsetsAmd64[] =
{
    FIELD_OFFSET(AMD64_CONTEXT, Rbx),
    FIELD_OFFSET(AMD64_CONTEXT, Rsi),
    FIELD_OFFSET(AMD64_CONTEXT, Rdi),
    FIELD_OFFSET(AMD64_CONTEXT, Rcx),
    FIELD_OFFSET(AMD64_CONTEXT, Rdx),
    FIELD_OFFSET(AMD64_CONTEXT, Rax),
    FIELD_OFFSET(AMD64_CONTEXT, Rip),
    IOP_LAST_CONTEXT_OFFSET
};

USHORT IopRunTimeContextOffsetsEmpty[] =
{
    IOP_LAST_CONTEXT_OFFSET
};

BOOLEAN
IopIsAddressRangeValid(
    IN ULONG64 VirtualAddress,
    IN ULONG Length
    )
{
    VirtualAddress = PAGE_ALIGN(g_Machine, VirtualAddress);
    Length = (Length + g_Machine->m_PageSize - 1) >> g_Machine->m_PageShift;
    while (Length > 0)
    {
        UCHAR Data;

        if (CurReadAllVirtual(VirtualAddress, &Data, sizeof(Data)) != S_OK)
        {
            return FALSE;
        }

        VirtualAddress += g_Machine->m_PageSize;
        Length--;
    }

    return TRUE;
}

BOOLEAN
IoAddTriageDumpDataBlock(
    IN ULONG64 Address,
    IN ULONG Length
    )
{
    ULONG i;
    PTRIAGE_PTR_DATA_BLOCK Block;
    ULONG64 MinAddress, MaxAddress;

    // Check against SIZE32 for both 32 and 64-bit dumps
    // as no data block needs to be larger than that.
    if (Length >= TRIAGE_DUMP_SIZE32 ||
        !IopIsAddressRangeValid(Address, Length))
    {
        return FALSE;
    }

    MinAddress = Address;
    MaxAddress = MinAddress + Length;

    //
    // Minimize overlap between the new block and existing blocks.
    // Blocks cannot simply be merged as blocks are inserted in
    // priority order for storage in the dump.  Combining a low-priority
    // block with a high-priority block could lead to a medium-
    // priority block being bumped improperly from the dump.
    //

    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < IopNumTriageDumpDataBlocks; i++, Block++)
    {
        if (MinAddress >= Block->MaxAddress ||
            MaxAddress <= Block->MinAddress)
        {
            // No overlap.
            continue;
        }

        //
        // Trim overlap out of the new block.  If this
        // would split the new block into pieces don't
        // trim to keep things simple.  Content may then
        // be duplicated in the dump.
        //

        if (MinAddress >= Block->MinAddress)
        {
            if (MaxAddress <= Block->MaxAddress)
            {
                // New block is completely contained.
                return TRUE;
            }

            // New block extends above the current block
            // so trim off the low-range overlap.
            MinAddress = Block->MaxAddress;
        }
        else if (MaxAddress <= Block->MaxAddress)
        {
            // New block extends below the current block
            // so trim off the high-range overlap.
            MaxAddress = Block->MinAddress;
        }
    }

    if (IopNumTriageDumpDataBlocks >= IO_MAX_TRIAGE_DUMP_DATA_BLOCKS)
    {
        return FALSE;
    }

    Block = IopTriageDumpDataBlocks + IopNumTriageDumpDataBlocks++;
    Block->MinAddress = MinAddress;
    Block->MaxAddress = MaxAddress;

    return TRUE;
}

VOID
IopAddRunTimeTriageDataBlocks(
    IN PCROSS_PLATFORM_CONTEXT Context,
    IN ULONG64 StackMin,
    IN ULONG64 StackMax,
    IN ULONG64 StoreMin,
    IN ULONG64 StoreMax
    )
{
    PUSHORT ContextOffset;

    switch(g_Target->m_MachineType)
    {
    case IMAGE_FILE_MACHINE_I386:
        ContextOffset = IopRunTimeContextOffsetsX86;
        break;
    case IMAGE_FILE_MACHINE_IA64:
        ContextOffset = IopRunTimeContextOffsetsIa64;
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        ContextOffset = IopRunTimeContextOffsetsAmd64;
        break;
    default:
        ContextOffset = IopRunTimeContextOffsetsEmpty;
        break;
    }

    while (*ContextOffset < IOP_LAST_CONTEXT_OFFSET)
    {
        ULONG64 Ptr;

        //
        // Retrieve possible pointers from the context
        // registers.
        //

        if (g_Machine->m_Ptr64)
        {
            Ptr = *(PULONG64)((PUCHAR)Context + *ContextOffset);
        }
        else
        {
            Ptr = EXTEND64(*(PULONG)((PUCHAR)Context + *ContextOffset));
        }

        // Stack and backing store memory is already saved
        // so ignore any pointers that fall into those ranges.
        if ((Ptr < StackMin || Ptr >= StackMax) &&
            (Ptr < StoreMin || Ptr >= StoreMax))
        {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(g_Machine, Ptr),
                                     g_Machine->m_PageSize);
        }

        ContextOffset++;
    }
}

void
AddInMemoryTriageDataBlocks(void)
{
    //
    // Look at the global data for nt!IopTriageDumpDataBlocks
    // and include the same data blocks so that dump conversion
    // preserves data blocks.
    //
    
    // If we don't know where IopTriageDumpDataBlocks is then
    // we don't have anything to do.
    if (!g_Target->m_KdDebuggerData.IopNumTriageDumpDataBlocks ||
        !g_Target->m_KdDebuggerData.IopTriageDumpDataBlocks)
    {
        return;
    }

    ULONG NumBlocks;

    if (g_Target->
        ReadAllVirtual(g_Process, g_Target->
                       m_KdDebuggerData.IopNumTriageDumpDataBlocks,
                       &NumBlocks, sizeof(NumBlocks)) != S_OK)
    {
        return;
    }

    if (NumBlocks > IO_MAX_TRIAGE_DUMP_DATA_BLOCKS)
    {
        NumBlocks = IO_MAX_TRIAGE_DUMP_DATA_BLOCKS;
    }
    
    ULONG64 BlockDescOffs =
        g_Target->m_KdDebuggerData.IopTriageDumpDataBlocks;
    TRIAGE_PTR_DATA_BLOCK BlockDesc;
    ULONG i;
    ULONG PtrSize = g_Machine->m_Ptr64 ? 8 : 4;

    for (i = 0; i < NumBlocks; i++)
    {
        if (g_Target->ReadPointer(g_Process, g_Machine,
                                  BlockDescOffs,
                                  &BlockDesc.MinAddress) != S_OK ||
            g_Target->ReadPointer(g_Process, g_Machine,
                                  BlockDescOffs + PtrSize,
                                  &BlockDesc.MaxAddress) != S_OK)
        {
            return;
        }

        BlockDescOffs += 2 * PtrSize;

        IoAddTriageDumpDataBlock(BlockDesc.MinAddress,
                                 (LONG)(BlockDesc.MaxAddress -
                                        BlockDesc.MinAddress));
    }
}

ULONG
IopSizeTriageDumpDataBlocks(
    ULONG Offset,
    ULONG BufferSize,
    PULONG StartOffset,
    PULONG Count
    )
{
    ULONG i;
    ULONG Size;
    PTRIAGE_PTR_DATA_BLOCK Block;

    *Count = 0;

    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < IopNumTriageDumpDataBlocks; i++, Block++)
    {
        Size = ALIGN_8(sizeof(TRIAGE_DATA_BLOCK)) +
            ALIGN_8((ULONG)(Block->MaxAddress - Block->MinAddress));
        if (Offset + Size >= BufferSize)
        {
            break;
        }

        if (i == 0)
        {
            *StartOffset = Offset;
        }

        Offset += Size;
        (*Count)++;
    }

    return Offset;
}

VOID
IopWriteTriageDumpDataBlocks(
    ULONG StartOffset,
    ULONG Count,
    PUCHAR BufferAddress
    )
{
    ULONG i;
    PTRIAGE_PTR_DATA_BLOCK Block;
    PUCHAR DataBuffer;
    PTRIAGE_DATA_BLOCK DumpBlock;

    DumpBlock = (PTRIAGE_DATA_BLOCK)
        (BufferAddress + StartOffset);
    DataBuffer = (PUCHAR)(DumpBlock + Count);

    Block = IopTriageDumpDataBlocks;
    for (i = 0; i < Count; i++, Block++)
    {
        DumpBlock->Address = Block->MinAddress;
        DumpBlock->Offset = (ULONG)(DataBuffer - BufferAddress);
        DumpBlock->Size = (ULONG)(Block->MaxAddress - Block->MinAddress);

        CurReadAllVirtual(Block->MinAddress, DataBuffer, DumpBlock->Size);

        DataBuffer += DumpBlock->Size;
        DumpBlock++;
    }
}

//----------------------------------------------------------------------------
//
// KernelTriage32DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

HRESULT
KernelTriage32DumpTargetInfo::Write(HANDLE File, ULONG FormatFlags,
                                    PCSTR CommentA, PCWSTR CommentW)
{
    HRESULT Status;
    PMEMORY_DUMP32 NewHeader;
    ULONG64 ThreadAddr;
    ULONG   CodeMod;
    ULONG   BugCheckCode;
    ULONG64 BugCheckData[4];
    ULONG64 SaveDataPage = 0;
    ULONG64 PrcbAddr;
    ContextSave* PushedContext;

    if (!IS_KERNEL_TARGET(g_Target))
    {
        ErrOut("kernel minidumps can only be written "
               "in kernel-mode sessions\n");
        return E_UNEXPECTED;
    }

    dprintf("mini kernel dump\n");
    FlushCallbacks();

    NewHeader = (PMEMORY_DUMP32) malloc(TRIAGE_DUMP_SIZE32);
    if (NewHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Get the current thread address, used to extract various blocks of data.
    // For some bugchecks the interesting thread is a different
    // thread than the current thread, so make the following code
    // generic so it handles any thread.
    //

    if ((Status = g_Target->
         ReadBugCheckData(&BugCheckCode, BugCheckData)) != S_OK)
    {
        goto NewHeader;
    }

    // Set a special marker to indicate there is no pushed context.
    PushedContext = (ContextSave*)&PushedContext;

    if (BugCheckCode == THREAD_STUCK_IN_DEVICE_DRIVER)
    {
        CROSS_PLATFORM_CONTEXT Context;

        // Modify the bugcheck code to indicate this
        // minidump represents a special state.
        CodeMod = MINIDUMP_BUGCHECK;

        // The interesting thread is the first bugcheck parameter.
        ThreadAddr = BugCheckData[0];

        // We need to make the thread's context the current
        // machine context for the duration of dump generation.
        if ((Status = g_Target->
             GetContextFromThreadStack(ThreadAddr, &Context, FALSE)) != S_OK)
        {
            goto NewHeader;
        }

        PushedContext = g_Machine->PushContext(&Context);
    }
    else if (BugCheckCode == SYSTEM_THREAD_EXCEPTION_NOT_HANDLED)
    {
        //
        // System thread stores a context record as the 4th parameter.
        // use that.
        // Also save the context record in case someone needs to look
        // at it.
        //

        if (BugCheckData[3])
        {
            CROSS_PLATFORM_CONTEXT TargetContext, Context;

            if (CurReadAllVirtual(BugCheckData[3], &TargetContext,
                                  g_Target->m_TypeInfo.
                                  SizeTargetContext) == S_OK &&
                g_Machine->ConvertContextFrom(&Context,
                                              g_Target->m_SystemVersion,
                                              g_Target->
                                              m_TypeInfo.SizeTargetContext,
                                              &TargetContext) == S_OK)
            {
                CodeMod = MINIDUMP_BUGCHECK;
                PushedContext = g_Machine->PushContext(&Context);
                SaveDataPage = BugCheckData[3];
            }
        }
    }
    else if (BugCheckCode == KERNEL_MODE_EXCEPTION_NOT_HANDLED)
    {
        CROSS_PLATFORM_CONTEXT Context;

        //
        // 3rd parameter is a trap frame.
        //
        // Build a context record out of that only if it's a kernel mode
        // failure because esp may be wrong in that case ???.
        //
        if (BugCheckData[2] &&
            g_Machine->GetContextFromTrapFrame(BugCheckData[2], &Context,
                                               FALSE) == S_OK)
        {
            CodeMod = MINIDUMP_BUGCHECK;
            PushedContext = g_Machine->PushContext(&Context);
            SaveDataPage = BugCheckData[2];
        }
    }
    else if (BugCheckCode == UNEXPECTED_KERNEL_MODE_TRAP)
    {
        CROSS_PLATFORM_CONTEXT Context;

        //
        // Double fault
        //
        // The thread is correct in this case.
        // Second parameter is the TSS.  If we have a TSS, convert
        // the context and mark the bugcheck as converted.
        //

        if (BugCheckData[0] == 8 &&
            BugCheckData[1] &&
            g_Machine->GetContextFromTaskSegment(BugCheckData[1], &Context,
                                                 FALSE) == S_OK)
        {
            CodeMod = MINIDUMP_BUGCHECK;
            PushedContext = g_Machine->PushContext(&Context);
        }
    }
    else
    {
        CodeMod = 0;

        if ((Status = g_Process->
             GetImplicitThreadData(g_Thread, &ThreadAddr)) != S_OK)
        {
            goto NewHeader;
        }
    }

    CCrashDumpWrapper32 Wrapper;

    //
    // setup the main header
    //

    KernelDumpTargetInfo::InitDumpHeader32(&NewHeader->Header,
                                           CommentA, CommentW,
                                           CodeMod);
    NewHeader->Header.DumpType = DUMP_TYPE_TRIAGE;
    NewHeader->Header.MiniDumpFields = TRIAGE_DUMP_BASIC_INFO;
    NewHeader->Header.WriterStatus = DUMP_DBGENG_SUCCESS;

    //
    // triage dump header begins on second page
    //

    TRIAGE_DUMP32 *ptdh = &NewHeader->Triage;

    ULONG i;

    ptdh->ServicePackBuild = g_Target->m_ServicePackNumber;
    ptdh->SizeOfDump = TRIAGE_DUMP_SIZE32;

    ptdh->ContextOffset = FIELD_OFFSET (DUMP_HEADER32, ContextRecord);
    ptdh->ExceptionOffset = FIELD_OFFSET (DUMP_HEADER32, Exception);

    //
    // starting offset in triage dump follows the triage dump header
    //

    unsigned Offset =
        ALIGN_8(sizeof(DUMP_HEADER32) + sizeof(TRIAGE_DUMP32));

    //
    // write mm information for Win2K and above only
    //

    if (g_Target->m_SystemVersion >= NT_SVER_W2K)
    {
        ptdh->MmOffset = Offset;
        Wrapper.WriteMmTriageInformation((PBYTE)NewHeader + ptdh->MmOffset);
        Offset += ALIGN_8(sizeof(DUMP_MM_STORAGE32));
    }

    //
    // write unloaded drivers
    //

    ptdh->UnloadedDriversOffset = Offset;
    Wrapper.WriteUnloadedDrivers((PBYTE)NewHeader +
                                 ptdh->UnloadedDriversOffset);
    Offset += ALIGN_8(sizeof(ULONG) +
                      MI_UNLOADED_DRIVERS * sizeof(DUMP_UNLOADED_DRIVERS32));

    //
    // write processor control block (KPRCB)
    //

    if (S_OK == g_Target->GetProcessorSystemDataOffset(CURRENT_PROC,
                                                       DEBUG_DATA_KPRCB_OFFSET,
                                                       &PrcbAddr))
    {
        ptdh->PrcbOffset = Offset;
        CurReadAllVirtual(PrcbAddr,
                          ((PBYTE)NewHeader) + ptdh->PrcbOffset,
                          g_Target->m_KdDebuggerData.SizePrcb);
        Offset += ALIGN_8(g_Target->m_KdDebuggerData.SizePrcb);
    }
    else
    {
        PrcbAddr = 0;
    }

    //
    // Write the thread and process data structures.
    //

    ptdh->ProcessOffset = Offset;
    Offset += ALIGN_8(g_Target->m_KdDebuggerData.SizeEProcess);
    ptdh->ThreadOffset = Offset;
    Offset += ALIGN_8(g_Target->m_KdDebuggerData.SizeEThread);

    CurReadAllVirtual(ThreadAddr +
                      g_Target->m_KdDebuggerData.OffsetKThreadApcProcess,
                      (PBYTE)NewHeader + ptdh->ProcessOffset,
                      g_Target->m_KdDebuggerData.SizeEProcess);
    CurReadAllVirtual(ThreadAddr,
                      (PBYTE)NewHeader + ptdh->ThreadOffset,
                      g_Target->m_KdDebuggerData.SizeEThread);

    //
    // write the call stack
    //

    ADDR StackPtr;
    ULONG64 StackBase = 0;

    g_Machine->GetSP(&StackPtr);
    ptdh->TopOfStack = (ULONG)(ULONG_PTR)Flat(StackPtr);

    g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                          g_Target->m_KdDebuggerData.OffsetKThreadInitialStack +
                          ThreadAddr,
                          &StackBase);

    // Take the Min in case something goes wrong getting the stack base.

    ptdh->SizeOfCallStack = min((ULONG)(ULONG_PTR)(StackBase - Flat(StackPtr)),
                                MAX_TRIAGE_STACK_SIZE32);

    ptdh->CallStackOffset = Offset;

    if (ptdh->SizeOfCallStack)
    {
        CurReadAllVirtual(EXTEND64(ptdh->TopOfStack),
                          ((PBYTE)NewHeader) + ptdh->CallStackOffset,
                          ptdh->SizeOfCallStack);
    }
    Offset += ALIGN_8(ptdh->SizeOfCallStack);

    //
    // write debugger data
    //

    if (g_Target->m_SystemVersion >= NT_SVER_XP &&
        g_Target->m_KdDebuggerDataOffset &&
        (!IS_KERNEL_TRIAGE_DUMP(g_Target) ||
         ((KernelTriageDumpTargetInfo*)g_Target)->m_HasDebuggerData) &&
        Offset +
        ALIGN_8(sizeof(g_Target->m_KdDebuggerData)) < TRIAGE_DUMP_SIZE32)
    {
        NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DEBUGGER_DATA;
        ptdh->DebuggerDataOffset = Offset;
        Offset += ALIGN_8(sizeof(g_Target->m_KdDebuggerData));
        ptdh->DebuggerDataSize = sizeof(g_Target->m_KdDebuggerData);
        memcpy((PBYTE)NewHeader + ptdh->DebuggerDataOffset,
               &g_Target->m_KdDebuggerData,
               sizeof(g_Target->m_KdDebuggerData));
    }

    //
    // write loaded driver list
    //

    ModuleInfo* ModIter;
    ULONG MaxEntries;

    // Use a heuristic to guess how many entries we
    // can pack into the remaining space.
    MaxEntries = (TRIAGE_DUMP_SIZE32 - Offset) /
        (sizeof(DUMP_DRIVER_ENTRY32) + TRIAGE_DRIVER_NAME_SIZE_GUESS);

    ptdh->DriverCount = 0;
    if (ModIter = g_Target->GetModuleInfo(FALSE))
    {
        if ((Status = ModIter->Initialize(g_Thread)) == S_OK)
        {
            while (ptdh->DriverCount < MaxEntries)
            {
                MODULE_INFO_ENTRY ModEntry;
                
                ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);
                
                if (retval == GNME_CORRUPT ||
                    retval == GNME_DONE)
                {
                    if (retval == GNME_CORRUPT)
                    {
                        NewHeader->Header.WriterStatus =
                            DUMP_DBGENG_CORRUPT_MODULE_LIST;
                    }
                    break;
                }
                else if (retval == GNME_NO_NAME)
                {
                    continue;
                }

                ptdh->DriverCount++;
            }
        }
        else
        {
            NewHeader->Header.WriterStatus =
                DUMP_DBGENG_NO_MODULE_LIST;
        }
    }

    ptdh->DriverListOffset = Offset;
    Offset += ALIGN_8(ptdh->DriverCount * sizeof(DUMP_DRIVER_ENTRY32));
    ptdh->StringPoolOffset = Offset;
    ptdh->BrokenDriverOffset = 0;

    Wrapper.WriteDriverList((PBYTE)NewHeader, ptdh);

    Offset = ptdh->StringPoolOffset + ptdh->StringPoolSize;
    Offset = ALIGN_8(Offset);

    //
    // For XP and above add in any additional data pages and write out
    // whatever fits.
    //

    if (g_Target->m_SystemVersion >= NT_SVER_XP)
    {
        if (SaveDataPage)
        {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(g_Machine, SaveDataPage),
                                     g_Machine->m_PageSize);
        }

        // If there are other interesting data pages, such as
        // alternate stacks for DPCs and such, pick them up.
        if (PrcbAddr)
        {
            ADDR_RANGE AltData[MAX_ALT_ADDR_RANGES];

            ZeroMemory(AltData, sizeof(AltData));
            if (g_Machine->GetAlternateTriageDumpDataRanges(PrcbAddr,
                                                            ThreadAddr,
                                                            AltData) == S_OK)
            {
                for (i = 0; i < MAX_ALT_ADDR_RANGES; i++)
                {
                    if (AltData[i].Base)
                    {
                        IoAddTriageDumpDataBlock(AltData[i].Base,
                                                 AltData[i].Size);
                    }
                }
            }
        }

        // Add any data blocks that were registered
        // in the debuggee.
        AddInMemoryTriageDataBlocks();
        
        // Add data blocks which might be referred to by
        // the context or other runtime state.
        IopAddRunTimeTriageDataBlocks(&g_Machine->m_Context,
                                      EXTEND64(ptdh->TopOfStack),
                                      EXTEND64(ptdh->TopOfStack +
                                               ptdh->SizeOfCallStack),
                                      0, 0);

        // Check which data blocks fit and write them.
        Offset = IopSizeTriageDumpDataBlocks(Offset, TRIAGE_DUMP_SIZE32,
                                             &ptdh->DataBlocksOffset,
                                             &ptdh->DataBlocksCount);
        Offset = ALIGN_8(Offset);
        if (ptdh->DataBlocksCount)
        {
            NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DATA_BLOCKS;
            IopWriteTriageDumpDataBlocks(ptdh->DataBlocksOffset,
                                         ptdh->DataBlocksCount,
                                         (PUCHAR)NewHeader);
        }
    }

    //
    // all options are enabled
    //

    ptdh->TriageOptions = 0xffffffff;

    //
    // end of triage dump validated
    //

    ptdh->ValidOffset = TRIAGE_DUMP_SIZE32 - sizeof(ULONG);
    *(PULONG)(((PBYTE) NewHeader) + ptdh->ValidOffset) = TRIAGE_DUMP_VALID;

    //
    // Write it out to the file.
    //

    ULONG cbWritten;

    if (!WriteFile(File,
                   NewHeader,
                   TRIAGE_DUMP_SIZE32,
                   &cbWritten,
                   NULL))
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Write to minidump file failed for reason %s\n     \"%s\"\n",
               FormatStatusCode(Status),
               FormatStatusArgs(Status, NULL));
    }
    else if (cbWritten != TRIAGE_DUMP_SIZE32)
    {
        ErrOut("Write to minidump failed because disk is full.\n");
        Status = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
    }
    else
    {
        Status = S_OK;
    }

    if (PushedContext != (ContextSave*)&PushedContext)
    {
        g_Machine->PopContext(PushedContext);
    }

 NewHeader:
    free(NewHeader);
    return Status;
}

//----------------------------------------------------------------------------
//
// KernelTriage64DumpTargetInfo::Write.
//
//----------------------------------------------------------------------------

HRESULT
KernelTriage64DumpTargetInfo::Write(HANDLE File, ULONG FormatFlags,
                                    PCSTR CommentA, PCWSTR CommentW)
{
    HRESULT Status;
    PMEMORY_DUMP64 NewHeader;
    ULONG64 ThreadAddr;
    ULONG   CodeMod;
    ULONG   BugCheckCode;
    ULONG64 BugCheckData[4];
    ULONG64 SaveDataPage = 0;
    ULONG64 BStoreBase = 0;
    ULONG   BStoreSize = 0;
    ULONG64 PrcbAddr;
    ContextSave* PushedContext;

    if (!IS_KERNEL_TARGET(g_Target))
    {
        ErrOut("kernel minidumps can only be written "
               "in kernel-mode sessions\n");
        return E_UNEXPECTED;
    }

    dprintf("mini kernel dump\n");
    FlushCallbacks();

    NewHeader = (PMEMORY_DUMP64) malloc(TRIAGE_DUMP_SIZE64);
    if (NewHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Get the current thread address, used to extract various blocks of data.
    // For some bugchecks the interesting thread is a different
    // thread than the current thread, so make the following code
    // generic so it handles any thread.
    //

    if ((Status = g_Target->
         ReadBugCheckData(&BugCheckCode, BugCheckData)) != S_OK)
    {
        goto NewHeader;
    }

    // Set a special marker to indicate there is no pushed context.
    PushedContext = (ContextSave*)&PushedContext;

    if (BugCheckCode == THREAD_STUCK_IN_DEVICE_DRIVER)
    {
        CROSS_PLATFORM_CONTEXT Context;

        // Modify the bugcheck code to indicate this
        // minidump represents a special state.
        CodeMod = MINIDUMP_BUGCHECK;

        // The interesting thread is the first bugcheck parameter.
        ThreadAddr = BugCheckData[0];

        // We need to make the thread's context the current
        // machine context for the duration of dump generation.
        if ((Status = g_Target->
             GetContextFromThreadStack(ThreadAddr, &Context, FALSE)) != S_OK)
        {
            goto NewHeader;
        }

        PushedContext = g_Machine->PushContext(&Context);
    }
    else if (BugCheckCode == SYSTEM_THREAD_EXCEPTION_NOT_HANDLED)
    {
        //
        // System thread stores a context record as the 4th parameter.
        // use that.
        // Also save the context record in case someone needs to look
        // at it.
        //

        if (BugCheckData[3])
        {
            CROSS_PLATFORM_CONTEXT TargetContext, Context;

            if (CurReadAllVirtual(BugCheckData[3], &TargetContext,
                                  g_Target->
                                  m_TypeInfo.SizeTargetContext) == S_OK &&
                g_Machine->ConvertContextFrom(&Context,
                                              g_Target->m_SystemVersion,
                                              g_Target->
                                              m_TypeInfo.SizeTargetContext,
                                              &TargetContext) == S_OK)
            {
                CodeMod = MINIDUMP_BUGCHECK;
                PushedContext = g_Machine->PushContext(&Context);
                SaveDataPage = BugCheckData[3];
            }
        }
    }
    else if (BugCheckCode == KERNEL_MODE_EXCEPTION_NOT_HANDLED)
    {
        CROSS_PLATFORM_CONTEXT Context;

        //
        // 3rd parameter is a trap frame.
        //
        // Build a context record out of that only if it's a kernel mode
        // failure because esp may be wrong in that case ???.
        //
        if (BugCheckData[2] &&
            g_Machine->GetContextFromTrapFrame(BugCheckData[2], &Context,
                                               FALSE) == S_OK)
        {
            CodeMod = MINIDUMP_BUGCHECK;
            PushedContext = g_Machine->PushContext(&Context);
            SaveDataPage = BugCheckData[2];
        }
    }
    else
    {
        CodeMod = 0;

        if ((Status = g_Process->
             GetImplicitThreadData(g_Thread, &ThreadAddr)) != S_OK)
        {
            goto NewHeader;
        }
    }

    CCrashDumpWrapper64 Wrapper;

    //
    // setup the main header
    //

    KernelDumpTargetInfo::InitDumpHeader64(&NewHeader->Header,
                                           CommentA, CommentW,
                                           CodeMod);
    NewHeader->Header.DumpType = DUMP_TYPE_TRIAGE;
    NewHeader->Header.MiniDumpFields = TRIAGE_DUMP_BASIC_INFO;
    NewHeader->Header.WriterStatus = DUMP_DBGENG_SUCCESS;

    //
    // triage dump header begins on second page
    //

    TRIAGE_DUMP64 *ptdh = &NewHeader->Triage;

    ULONG i;

    ptdh->ServicePackBuild = g_Target->m_ServicePackNumber;
    ptdh->SizeOfDump = TRIAGE_DUMP_SIZE64;

    ptdh->ContextOffset = FIELD_OFFSET (DUMP_HEADER64, ContextRecord);
    ptdh->ExceptionOffset = FIELD_OFFSET (DUMP_HEADER64, Exception);

    //
    // starting Offset in triage dump follows the triage dump header
    //

    unsigned Offset =
        ALIGN_8(sizeof(DUMP_HEADER64) + sizeof(TRIAGE_DUMP64));

    //
    // write mm information
    //

    ptdh->MmOffset = Offset;
    Wrapper.WriteMmTriageInformation((PBYTE)NewHeader + ptdh->MmOffset);
    Offset += ALIGN_8(sizeof(DUMP_MM_STORAGE64));

    //
    // write unloaded drivers
    //

    ptdh->UnloadedDriversOffset = Offset;
    Wrapper.WriteUnloadedDrivers((PBYTE)NewHeader + ptdh->UnloadedDriversOffset);
    Offset += ALIGN_8(sizeof(ULONG64) +
                      MI_UNLOADED_DRIVERS * sizeof(DUMP_UNLOADED_DRIVERS64));

    //
    // write processor control block (KPRCB)
    //

    if (S_OK == g_Target->GetProcessorSystemDataOffset(CURRENT_PROC,
                                                       DEBUG_DATA_KPRCB_OFFSET,
                                                       &PrcbAddr))
    {
        ptdh->PrcbOffset = Offset;
        CurReadAllVirtual(PrcbAddr,
                          ((PBYTE)NewHeader) + ptdh->PrcbOffset,
                          g_Target->m_KdDebuggerData.SizePrcb);
        Offset += ALIGN_8(g_Target->m_KdDebuggerData.SizePrcb);
    }
    else
    {
        PrcbAddr = 0;
    }

    //
    // Write the thread and process data structures.
    //

    ptdh->ProcessOffset = Offset;
    Offset += ALIGN_8(g_Target->m_KdDebuggerData.SizeEProcess);
    ptdh->ThreadOffset = Offset;
    Offset += ALIGN_8(g_Target->m_KdDebuggerData.SizeEThread);

    CurReadAllVirtual(ThreadAddr +
                      g_Target->m_KdDebuggerData.OffsetKThreadApcProcess,
                      (PBYTE)NewHeader + ptdh->ProcessOffset,
                      g_Target->m_KdDebuggerData.SizeEProcess);
    CurReadAllVirtual(ThreadAddr,
                      (PBYTE)NewHeader + ptdh->ThreadOffset,
                      g_Target->m_KdDebuggerData.SizeEThread);

    //
    // write the call stack
    //

    ADDR StackPtr;
    ULONG64 StackBase = 0;

    g_Machine->GetSP(&StackPtr);
    ptdh->TopOfStack = Flat(StackPtr);

    g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                          g_Target->m_KdDebuggerData.OffsetKThreadInitialStack +
                          ThreadAddr, &StackBase);

    // Take the Min in case something goes wrong getting the stack base.

    ptdh->SizeOfCallStack =
        min((ULONG)(ULONG_PTR)(StackBase - Flat(StackPtr)),
            MAX_TRIAGE_STACK_SIZE64);

    ptdh->CallStackOffset = Offset;

    if (ptdh->SizeOfCallStack)
    {
        CurReadAllVirtual(ptdh->TopOfStack,
                          ((PBYTE)NewHeader) + ptdh->CallStackOffset,
                          ptdh->SizeOfCallStack);
    }
    Offset += ALIGN_8(ptdh->SizeOfCallStack);

    //
    // The IA64 contains two callstacks. The first is the normal
    // callstack, and the second is a scratch region where
    // the processor can spill registers. It is this latter stack,
    // the backing-store, that we now save.
    //

    if (g_Target->m_MachineType == IMAGE_FILE_MACHINE_IA64)
    {
        ULONG64 BStoreLimit;

        g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                              ThreadAddr +
                              g_Target->m_KdDebuggerData.OffsetKThreadBStore,
                              &BStoreBase);
        g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                              ThreadAddr +
                              g_Target->m_KdDebuggerData.OffsetKThreadBStoreLimit,
                              &BStoreLimit);

        ptdh->ArchitectureSpecific.Ia64.BStoreOffset = Offset;
        ptdh->ArchitectureSpecific.Ia64.LimitOfBStore = BStoreLimit;
        ptdh->ArchitectureSpecific.Ia64.SizeOfBStore =
            min((ULONG)(BStoreLimit - BStoreBase),
                MAX_TRIAGE_BSTORE_SIZE);
        BStoreSize = ptdh->ArchitectureSpecific.Ia64.SizeOfBStore;

        if (ptdh->ArchitectureSpecific.Ia64.SizeOfBStore)
        {
            CurReadAllVirtual(BStoreBase, ((PBYTE)NewHeader) +
                              ptdh->ArchitectureSpecific.Ia64.BStoreOffset,
                              ptdh->ArchitectureSpecific.Ia64.SizeOfBStore);
            Offset +=
                ALIGN_8(ptdh->ArchitectureSpecific.Ia64.SizeOfBStore);
        }
    }

    //
    // write debugger data
    //

    if (g_Target->m_SystemVersion >= NT_SVER_XP &&
        g_Target->m_KdDebuggerDataOffset &&
        (!IS_KERNEL_TRIAGE_DUMP(g_Target) ||
         ((KernelTriageDumpTargetInfo*)g_Target)->m_HasDebuggerData) &&
        Offset +
        ALIGN_8(sizeof(g_Target->m_KdDebuggerData)) < TRIAGE_DUMP_SIZE64)
    {
        NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DEBUGGER_DATA;
        ptdh->DebuggerDataOffset = Offset;
        Offset += ALIGN_8(sizeof(g_Target->m_KdDebuggerData));
        ptdh->DebuggerDataSize = sizeof(g_Target->m_KdDebuggerData);
        memcpy((PBYTE)NewHeader + ptdh->DebuggerDataOffset,
               &g_Target->m_KdDebuggerData,
               sizeof(g_Target->m_KdDebuggerData));
    }

    //
    // write loaded driver list
    //

    ModuleInfo* ModIter;
    ULONG MaxEntries;

        // Use a heuristic to guess how many entries we
        // can pack into the remaining space.
    MaxEntries = (TRIAGE_DUMP_SIZE64 - Offset) /
        (sizeof(DUMP_DRIVER_ENTRY64) + TRIAGE_DRIVER_NAME_SIZE_GUESS);

    ptdh->DriverCount = 0;
    if (ModIter = g_Target->GetModuleInfo(FALSE))
    {
        if ((Status = ModIter->Initialize(g_Thread)) == S_OK)
        {
            while (ptdh->DriverCount < MaxEntries)
            {
                MODULE_INFO_ENTRY ModEntry;
                
                ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);
            
                if (retval == GNME_CORRUPT ||
                    retval == GNME_DONE)
                {
                    if (retval == GNME_CORRUPT)
                    {
                        NewHeader->Header.WriterStatus =
                            DUMP_DBGENG_CORRUPT_MODULE_LIST;
                    }
                    break;
                }
                else if (retval == GNME_NO_NAME)
                {
                    continue;
                }

                ptdh->DriverCount++;
            }
        }
        else
        {
            NewHeader->Header.WriterStatus =
                DUMP_DBGENG_NO_MODULE_LIST;
        }
    }

    ptdh->DriverListOffset = Offset;
    Offset += ALIGN_8(ptdh->DriverCount * sizeof(DUMP_DRIVER_ENTRY64));
    ptdh->StringPoolOffset = Offset;
    ptdh->BrokenDriverOffset = 0;

    Wrapper.WriteDriverList((PBYTE)NewHeader, ptdh);

    Offset = ptdh->StringPoolOffset + ptdh->StringPoolSize;
    Offset = ALIGN_8(Offset);

    //
    // For XP and above add in any additional data pages and write out
    // whatever fits.
    //

    if (g_Target->m_SystemVersion >= NT_SVER_XP)
    {
        if (SaveDataPage)
        {
            IoAddTriageDumpDataBlock(PAGE_ALIGN(g_Machine, SaveDataPage),
                                     g_Machine->m_PageSize);
        }

        // If there are other interesting data pages, such as
        // alternate stacks for DPCs and such, pick them up.
        if (PrcbAddr)
        {
            ADDR_RANGE AltData[MAX_ALT_ADDR_RANGES];

            ZeroMemory(AltData, sizeof(AltData));
            if (g_Machine->GetAlternateTriageDumpDataRanges(PrcbAddr,
                                                            ThreadAddr,
                                                            AltData) == S_OK)
            {
                for (i = 0; i < MAX_ALT_ADDR_RANGES; i++)
                {
                    if (AltData[i].Base)
                    {
                        IoAddTriageDumpDataBlock(AltData[i].Base,
                                                 AltData[i].Size);
                    }
                }
            }
        }

        // Add any data blocks that were registered
        // in the debuggee.
        AddInMemoryTriageDataBlocks();

        // Add data blocks which might be referred to by
        // the context or other runtime state.
        IopAddRunTimeTriageDataBlocks(&g_Machine->m_Context,
                                      ptdh->TopOfStack,
                                      ptdh->TopOfStack +
                                      ptdh->SizeOfCallStack,
                                      BStoreBase,
                                      BStoreSize);

        // Check which data blocks fit and write them.
        Offset = IopSizeTriageDumpDataBlocks(Offset, TRIAGE_DUMP_SIZE64,
                                             &ptdh->DataBlocksOffset,
                                             &ptdh->DataBlocksCount);
        Offset = ALIGN_8(Offset);
        if (ptdh->DataBlocksCount)
        {
            NewHeader->Header.MiniDumpFields |= TRIAGE_DUMP_DATA_BLOCKS;
            IopWriteTriageDumpDataBlocks(ptdh->DataBlocksOffset,
                                         ptdh->DataBlocksCount,
                                         (PUCHAR)NewHeader);
        }
    }

    //
    // all options are enabled
    //

    ptdh->TriageOptions = 0xffffffff;

    //
    // end of triage dump validated
    //

    ptdh->ValidOffset = TRIAGE_DUMP_SIZE64 - sizeof(ULONG);
    *(PULONG)(((PBYTE) NewHeader) + ptdh->ValidOffset) = TRIAGE_DUMP_VALID;

    //
    // Write it out to the file.
    //
    
    ULONG cbWritten;

    if (!WriteFile(File,
                   NewHeader,
                   TRIAGE_DUMP_SIZE64,
                   &cbWritten,
                   NULL))
    {
        Status = WIN32_LAST_STATUS();
        ErrOut("Write to minidump file failed for reason %s\n     \"%s\"\n",
               FormatStatusCode(Status),
               FormatStatusArgs(Status, NULL));
    }
    else if (cbWritten != TRIAGE_DUMP_SIZE64)
    {
        ErrOut("Write to minidump failed because disk is full.\n");
        Status = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
    }
    else
    {
        Status = S_OK;
    }

    if (PushedContext != (ContextSave*)&PushedContext)
    {
        g_Machine->PopContext(PushedContext);
    }

 NewHeader:
    free(NewHeader);
    return Status;
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

HRESULT
WriteDumpFile(PCWSTR FileName, ULONG64 FileHandle,
              ULONG Qualifier, ULONG FormatFlags,
              PCSTR CommentA, PCWSTR CommentW)
{
    ULONG DumpType = DTYPE_COUNT;
    DumpTargetInfo* WriteTarget;
    HRESULT Status;
    ULONG OldMachine;
    WCHAR TempFile[2 * MAX_PATH];
    PCWSTR DumpWriteFile;
    HANDLE DumpWriteHandle;
    PSTR AnsiFile = NULL;
    BOOL CreatedAnsi = FALSE;

    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        return E_UNEXPECTED;
    }

    if (IS_KERNEL_TARGET(g_Target))
    {
        DbgKdTransport* KdTrans;

        if (FormatFlags & ~GENERIC_FORMATS)
        {
            return E_INVALIDARG;
        }

        //
        // not much we can do without the processor block
        // or at least the PRCB for the current process in a minidump.
        //

        if (!g_Target->m_KdDebuggerData.KiProcessorBlock &&
            IS_DUMP_TARGET(g_Target) &&
            !((KernelDumpTargetInfo*)g_Target)->m_KiProcessors[CURRENT_PROC])
        {
            ErrOut("Cannot find KiProcessorBlock - "
                   "can not create dump file\n");

            return E_FAIL;
        }

        if (IS_CONN_KERNEL_TARGET(g_Target))
        {
            KdTrans = ((ConnLiveKernelTargetInfo*)g_Target)->m_Transport;
        }
        else
        {
            KdTrans = NULL;
        }

        switch(Qualifier)
        {
        case DEBUG_KERNEL_SMALL_DUMP:
            DumpType = g_Target->m_Machine->m_Ptr64 ?
                DTYPE_KERNEL_TRIAGE64 : DTYPE_KERNEL_TRIAGE32;
            break;
        case DEBUG_KERNEL_FULL_DUMP:
            if (KdTrans != NULL &&
                KdTrans->m_DirectPhysicalMemory == FALSE)
            {
                WarnOut("Creating a full kernel dump over the COM port is a "
                        "VERY VERY slow operation.\n"
                        "This command may take many HOURS to complete.  "
                        "Ctrl-C if you want to terminate the command.\n");
            }
            DumpType = g_Target->m_Machine->m_Ptr64 ?
                DTYPE_KERNEL_FULL64 : DTYPE_KERNEL_FULL32;
            break;
        default:
            // Other formats are not supported.
            return E_INVALIDARG;
        }
    }
    else
    {
        DBG_ASSERT(IS_USER_TARGET(g_Target));

        switch(Qualifier)
        {
        case DEBUG_USER_WINDOWS_SMALL_DUMP:
            if (FormatFlags & ~(GENERIC_FORMATS |
                                UMINI_FORMATS |
                                FORMAT_USER_MICRO))
            {
                return E_INVALIDARG;
            }

            DumpType = (FormatFlags & DEBUG_FORMAT_USER_SMALL_FULL_MEMORY) ?
                DTYPE_USER_MINI_FULL : DTYPE_USER_MINI_PARTIAL;
            break;

        case DEBUG_USER_WINDOWS_DUMP:
            if (FormatFlags & ~GENERIC_FORMATS)
            {
                return E_INVALIDARG;
            }

            DumpType = g_Target->m_Machine->m_Ptr64 ?
                DTYPE_USER_FULL64 : DTYPE_USER_FULL32;
            break;
        default:
            // Other formats are not supported.
            return E_INVALIDARG;
        }
    }

    WriteTarget = NewDumpTargetInfo(DumpType);
    if (WriteTarget == NULL)
    {
        ErrOut("Unable to create dump write target\n");
        return E_OUTOFMEMORY;
    }

    // Ensure that the dump is always written according to the
    // target machine type and not any emulated machine.
    OldMachine = g_Target->m_EffMachineType;
    g_Target->SetEffMachine(g_Target->m_MachineType, FALSE);

    // Flush context first so that the minidump reads the
    // same register values the debugger has.
    g_Target->FlushRegContext();

    //
    // If we're producing a CAB put the dump in a temp file.
    //

    if (FormatFlags & DEBUG_FORMAT_WRITE_CAB)
    {
        if (FileHandle)
        {
            Status = E_INVALIDARG;
            goto Exit;
        }

        if (!GetTempPathW(DIMA(TempFile), TempFile))
        {
            wcscpy(TempFile, L".\\");
        }
        // Use the CAB name as the dump file name so the
        // name in the CAB will match.
        CatStringW(TempFile, PathTailW(FileName), DIMA(TempFile));
        CatStringW(TempFile, L".dmp", DIMA(TempFile));

        DumpWriteFile = TempFile;
        FormatFlags &= ~DEBUG_FORMAT_NO_OVERWRITE;
    }
    else
    {
        DumpWriteFile = FileName;
        if (!DumpWriteFile)
        {
            DumpWriteFile = L"<HandleOnly>";
        }
    }

    if (FileHandle)
    {
        DumpWriteHandle = OS_HANDLE(FileHandle);
        if (!DumpWriteHandle || DumpWriteHandle == INVALID_HANDLE_VALUE)
        {
            Status = E_INVALIDARG;
        }
        else
        {
            Status = S_OK;
        }
    }
    else if ((Status = WideToAnsi(DumpWriteFile, &AnsiFile)) == S_OK)
    {
        // Dumps are almost always written sequentially so
        // add that hint to the file flags.
        DumpWriteHandle =
            CreateFileW(DumpWriteFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        (FormatFlags & DEBUG_FORMAT_NO_OVERWRITE) ?
                        CREATE_NEW : CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);
        if ((!DumpWriteHandle || DumpWriteHandle == INVALID_HANDLE_VALUE) &&
            GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            //
            // ANSI-only system.  It's Win9x so don't
            // bother with sequential scan.
            //

            DumpWriteHandle =
                CreateFileA(AnsiFile,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            (FormatFlags & DEBUG_FORMAT_NO_OVERWRITE) ?
                            CREATE_NEW : CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            CreatedAnsi = TRUE;
        }

        if (!DumpWriteHandle || DumpWriteHandle == INVALID_HANDLE_VALUE)
        {
            Status = WIN32_LAST_STATUS();
            ErrOut("Unable to create file '%ws' - %s\n    \"%s\"\n",
                   DumpWriteFile,
                   FormatStatusCode(Status), FormatStatus(Status));
        }
    }

    if (Status == S_OK)
    {
        dprintf("Creating %ws - ", DumpWriteFile);
        Status = WriteTarget->Write(DumpWriteHandle, FormatFlags,
                                    CommentA, CommentW);

        if (!FileHandle)
        {
            CloseHandle(DumpWriteHandle);
            if (Status != S_OK)
            {
                if (CreatedAnsi)
                {
                    DeleteFileA(AnsiFile);
                }
                else
                {
                    DeleteFileW(DumpWriteFile);
                }
            }
        }
    }

    if (Status == S_OK && (FormatFlags & DEBUG_FORMAT_WRITE_CAB))
    {
        PSTR AnsiBaseFile;

        if ((Status = WideToAnsi(FileName, &AnsiBaseFile)) == S_OK)
        {
            Status = CreateCabFromDump(AnsiFile, AnsiBaseFile, FormatFlags);
            FreeAnsi(AnsiBaseFile);
        }
        if (CreatedAnsi)
        {
            DeleteFileA(AnsiFile);
        }
        else
        {
            DeleteFileW(TempFile);
        }
    }

 Exit:
    FreeAnsi(AnsiFile);
    g_Target->SetEffMachine(OldMachine, FALSE);
    delete WriteTarget;
    return Status;
}

void
DotDump(PDOT_COMMAND Cmd, DebugClient* Client)
{
    BOOL Usage = FALSE;
    ULONG Qual;
    ULONG FormatFlags;

    //
    // Default to minidumps
    //

    if (IS_KERNEL_TARGET(g_Target))
    {
        Qual = DEBUG_KERNEL_SMALL_DUMP;

        if (IS_LOCAL_KERNEL_TARGET(g_Target))
        {
            error(SESSIONNOTSUP);
        }
    }
    else
    {
        Qual = DEBUG_USER_WINDOWS_SMALL_DUMP;
    }
    FormatFlags = DEBUG_FORMAT_DEFAULT | DEBUG_FORMAT_NO_OVERWRITE;

    //
    // Scan for options.
    //

    CHAR Save;
    PSTR FileName;
    BOOL SubLoop;
    PCSTR Comment = NULL;
    PSTR CommentEnd = NULL;
    BOOL Unique = FALSE;
    ProcessInfo* DumpProcess = g_Process;

    for (;;)
    {
        if (PeekChar() == '-' || *g_CurCmd == '/')
        {
            SubLoop = TRUE;

            g_CurCmd++;
            switch(*g_CurCmd)
            {
            case 'a':
                DumpProcess = NULL;
                break;

            case 'b':
                FormatFlags |= DEBUG_FORMAT_WRITE_CAB;
                g_CurCmd++;
                if (*g_CurCmd == 'a')
                {
                    FormatFlags |= DEBUG_FORMAT_CAB_SECONDARY_FILES;
                    g_CurCmd++;
                }
                break;

            case 'c':
                g_CurCmd++;
                Comment = StringValue(STRV_SPACE_IS_SEPARATOR |
                                      STRV_TRIM_TRAILING_SPACE, &Save);
                *g_CurCmd = Save;
                CommentEnd = g_CurCmd;
                break;

            case 'f':
                if (IS_KERNEL_TARGET(g_Target))
                {
                    Qual = DEBUG_KERNEL_FULL_DUMP;
                }
                else
                {
                    Qual = DEBUG_USER_WINDOWS_DUMP;
                }
                break;

            case 'm':
                if (IS_KERNEL_TARGET(g_Target))
                {
                    Qual = DEBUG_KERNEL_SMALL_DUMP;
                }
                else
                {
                    Qual = DEBUG_USER_WINDOWS_SMALL_DUMP;

                    for (;;)
                    {
                        switch(*(g_CurCmd + 1))
                        {
                        case 'a':
                            // Synthetic flag meaning "save the
                            // maximum amount of data."
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_FULL_MEMORY |
                                DEBUG_FORMAT_USER_SMALL_HANDLE_DATA |
                                DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES;
                            break;
                        case 'C':
                            // Flag to test microdump code.
                            FormatFlags |= FORMAT_USER_MICRO;
                            break;
                        case 'd':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS;
                            break;
                        case 'f':
                            FormatFlags |= DEBUG_FORMAT_USER_SMALL_FULL_MEMORY;
                            break;
                        case 'h':
                            FormatFlags |= DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
                            break;
                        case 'i':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY;
                            break;
                        case 'p':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA;
                            break;
                        case 'r':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY;
                            break;
                        case 'R':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_FILTER_PATHS;
                            break;
                        case 'u':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES;
                            break;
                        case 'w':
                            FormatFlags |=
                                DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY;
                            break;
                        default:
                            SubLoop = FALSE;
                            break;
                        }

                        if (SubLoop)
                        {
                            g_CurCmd++;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                break;

            case 'o':
                FormatFlags &= ~DEBUG_FORMAT_NO_OVERWRITE;
                break;

            case 'u':
                Unique = TRUE;
                break;

            case '?':
                Usage = TRUE;
                break;

            default:
                ErrOut("Unknown option '%c'\n", *g_CurCmd);
                Usage = TRUE;
                break;
            }

            g_CurCmd++;
        }
        else
        {
            FileName = StringValue(STRV_TRIM_TRAILING_SPACE, &Save);
            if (*FileName)
            {
                break;
            }
            else
            {
                *g_CurCmd = Save;
                Usage = TRUE;
            }
        }

        if (Usage)
        {
            break;
        }
    }

    if (DumpProcess == NULL && !Unique)
    {
        Usage = TRUE;
    }

    if (Usage)
    {
        ErrOut("Usage: .dump [options] filename\n");
        ErrOut("Options are:\n");
        ErrOut("  /a - Create dumps for all processes (requires -u)\n");
        ErrOut("  /b[a] - Package dump in a CAB and delete dump\n");
        ErrOut("  /c <comment> - Add a comment "
               "(not supported in all formats)\n");
        ErrOut("  /f - Create a full dump\n");
        if (IS_KERNEL_TARGET(g_Target))
        {
            ErrOut("  /m - Create a minidump (default)\n");
        }
        else
        {
            ErrOut("  /m[adfhiprRuw] - Create a minidump (default)\n");
        }
        ErrOut("  /o - Overwrite any existing file\n");
        ErrOut("  /u - Append unique identifier to dump name\n");

        ErrOut("\nUse \".hh .dump\" or open debugger.chm in the "
               "debuggers directory to get\n"
               "detailed documentation on this command.\n\n");

        return;
    }

    if (CommentEnd != NULL)
    {
        *CommentEnd = 0;
    }

    ThreadInfo* OldThread = g_Thread;
    TargetInfo* Target;
    ProcessInfo* Process;

    ForAllLayersToProcess()
    {
        PSTR DumpFileName;
        char UniqueName[2 * MAX_PATH];

        if (DumpProcess != NULL && Process != DumpProcess)
        {
            continue;
        }

        if (Process != g_Process)
        {
            SetCurrentThread(Process->m_ThreadHead, TRUE);
        }

        if (Unique)
        {
            MakeFileNameUnique(FileName, UniqueName, DIMA(UniqueName),
                               TRUE, g_Process);
            DumpFileName = UniqueName;
        }
        else
        {
            DumpFileName = FileName;
        }

        PWSTR WideName;

        if (AnsiToWide(DumpFileName, &WideName) == S_OK)
        {
            WriteDumpFile(WideName, 0, Qual, FormatFlags, Comment, NULL);
            FreeWide(WideName);
        }
        else
        {
            ErrOut("Unable to convert dump filename\n");
        }
    }

    if (!OldThread || OldThread->m_Process != g_Process)
    {
        SetCurrentThread(OldThread, TRUE);
    }

    *g_CurCmd = Save;
}

BOOL
DumpCabAdd(PCSTR File)
{
    HRESULT Status;

    dprintf("  Adding %s - ", File);
    FlushCallbacks();
    if ((Status = AddToDumpCab(File)) != S_OK)
    {
        ErrOut("%s\n", FormatStatusCode(Status));
    }
    else
    {
        dprintf("added\n");
    }

    if (CheckUserInterrupt())
    {
        return FALSE;
    }
    FlushCallbacks();
    return TRUE;
}

HRESULT
CreateCabFromDump(PCSTR DumpFile, PCSTR CabFile, ULONG Flags)
{
    HRESULT Status;

    if ((Status = CreateDumpCab(CabFile)) != S_OK)
    {
        ErrOut("Unable to create CAB, %s\n", FormatStatusCode(Status));
        return Status;
    }


    WarnOut("Creating a cab file can take a VERY VERY long time\n."
            "Ctrl-C can only interrupt the command after a file "
             "has been added to the cab.\n");
    //
    // First add all base dump files.
    //

    if (!DumpFile)
    {
        DumpTargetInfo* Dump = (DumpTargetInfo*)g_Target;
        ULONG i;

        for (i = DUMP_INFO_DUMP; i < DUMP_INFO_COUNT; i++)
        {
            if (Dump->m_InfoFiles[i].m_File)
            {
                if (!DumpCabAdd(Dump->m_InfoFiles[i].m_FileNameA))
                {
                    Status = E_UNEXPECTED;
                    goto Leave;
                }
            }
        }
    }
    else
    {
        if (!DumpCabAdd(DumpFile))
        {
            Status = E_UNEXPECTED;
            goto Leave;
        }
    }

    if (Flags & DEBUG_FORMAT_CAB_SECONDARY_FILES)
    {
        ImageInfo* Image;

        //
        // Add all symbols and images.
        //

        for (Image = g_Process->m_ImageHead; Image; Image = Image->m_Next)
        {
            if (Image->m_MappedImagePath[0])
            {
                if (!DumpCabAdd(Image->m_MappedImagePath))
                {
                    Status = E_UNEXPECTED;
                    break;
                }
            }

            IMAGEHLP_MODULE64 ModInfo;

            ModInfo.SizeOfStruct = sizeof(ModInfo);
            if (SymGetModuleInfo64(g_Process->m_SymHandle,
                                   Image->m_BaseOfImage, &ModInfo))
            {
                ULONG Len;

                // The loaded image name often refers directly to the
                // image.  Only save the loaded image file if it
                // refers to a .dbg file.
                if (ModInfo.LoadedImageName[0] &&
                    (Len = strlen(ModInfo.LoadedImageName)) > 4 &&
                    !_stricmp(ModInfo.LoadedImageName + (Len - 4), ".dbg"))
                {
                    if (!DumpCabAdd(ModInfo.LoadedImageName))
                    {
                        Status = E_UNEXPECTED;
                        break;
                    }
                }

                // Save any PDB that was opened.
                if (ModInfo.LoadedPdbName[0])
                {
                    if (!DumpCabAdd(ModInfo.LoadedPdbName))
                    {
                        Status = E_UNEXPECTED;
                        break;
                    }
                }
            }
        }
    }

Leave:
    CloseDumpCab();

    if (Status == S_OK)
    {
        dprintf("Wrote %s\n", CabFile);
    }

    return Status;
}


// extern PKDDEBUGGER_DATA64 blocks[];


#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

//----------------------------------------------------------------------------
//
// CCrashDumpWrapper32.
//
//----------------------------------------------------------------------------

void
CCrashDumpWrapper32::WriteDriverList(
    BYTE *pb,
    TRIAGE_DUMP32 *ptdh
    )
{
    PDUMP_DRIVER_ENTRY32 pdde;
    PDUMP_STRING pds;
    ModuleInfo* ModIter;
    ULONG MaxEntries = ptdh->DriverCount;

    ptdh->DriverCount = 0;

    if (((ModIter = g_Target->GetModuleInfo(FALSE)) == NULL) ||
        ((ModIter->Initialize(g_Thread)) != S_OK))
    {
        return;
    }

    // pointer to first driver entry to write out
    pdde = (PDUMP_DRIVER_ENTRY32) (pb + ptdh->DriverListOffset);

    // pointer to first module name to write out
    pds = (PDUMP_STRING) (pb + ptdh->StringPoolOffset);

    while ((PBYTE)(pds + 1) < pb + TRIAGE_DUMP_SIZE32 &&
           ptdh->DriverCount < MaxEntries)
    {
        MODULE_INFO_ENTRY ModEntry;

        ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);

        if (retval == GNME_CORRUPT ||
            retval == GNME_DONE)
        {
            break;
        }
        else if (retval == GNME_NO_NAME)
        {
            continue;
        }

        pdde->LdrEntry.DllBase       = (ULONG)(ULONG_PTR)ModEntry.Base;
        pdde->LdrEntry.SizeOfImage   = ModEntry.Size;
        pdde->LdrEntry.CheckSum      = ModEntry.CheckSum;
        pdde->LdrEntry.TimeDateStamp = ModEntry.TimeDateStamp;

        if (ModEntry.UnicodeNamePtr)
        {
            // convert length from bytes to characters
            pds->Length = ModEntry.NameLength / sizeof(WCHAR);
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE32)
            {
                break;
            }

            CopyMemory(pds->Buffer,
                       ModEntry.NamePtr,
                       ModEntry.NameLength);
        }
        else
        {
            pds->Length = ModEntry.NameLength;
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE32)
            {
                break;
            }

            MultiByteToWideChar(CP_ACP, 0,
                                ModEntry.NamePtr, ModEntry.NameLength,
                                pds->Buffer, ModEntry.NameLength);
        }

        // null terminate string
        pds->Buffer[pds->Length] = '\0';

        pdde->DriverNameOffset = (ULONG)((ULONG_PTR) pds - (ULONG_PTR) pb);


        // get pointer to next string
        pds = (PDUMP_STRING) ALIGN_UP_POINTER(((LPBYTE) pds) +
                      sizeof(DUMP_STRING) + sizeof(WCHAR) * (pds->Length + 1),
                                               ULONGLONG);

        pdde = (PDUMP_DRIVER_ENTRY32)(((PUCHAR) pdde) + sizeof(*pdde));

        ptdh->DriverCount++;
    }

    ptdh->StringPoolSize = (ULONG) ((ULONG_PTR)pds -
                                    (ULONG_PTR)(pb + ptdh->StringPoolOffset));
}


void CCrashDumpWrapper32::WriteUnloadedDrivers(BYTE *pb)
{
    ULONG i;
    ULONG Index;
    UNLOADED_DRIVERS32 ud;
    PDUMP_UNLOADED_DRIVERS32 pdud;
    ULONG64 pvMiUnloadedDrivers=0;
    ULONG ulMiLastUnloadedDriver=0;

    *((PULONG) pb) = 0;

    //
    // find location of unloaded drivers
    //

    if (!g_Target->m_KdDebuggerData.MmUnloadedDrivers ||
        !g_Target->m_KdDebuggerData.MmLastUnloadedDriver)
    {
        return;
    }

    g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                          g_Target->m_KdDebuggerData.MmUnloadedDrivers,
                          &pvMiUnloadedDrivers);
    CurReadAllVirtual(g_Target->m_KdDebuggerData.MmLastUnloadedDriver,
                      &ulMiLastUnloadedDriver,
                      sizeof(ULONG));

    if (pvMiUnloadedDrivers == NULL || ulMiLastUnloadedDriver == 0)
    {
        return;
    }

    // point to last unloaded drivers
    pdud = (PDUMP_UNLOADED_DRIVERS32)(((PULONG) pb) + 1);

    //
    // Write the list with the most recently unloaded driver first to the
    // least recently unloaded driver last.
    //

    Index = ulMiLastUnloadedDriver - 1;

    for (i = 0; i < MI_UNLOADED_DRIVERS; i += 1)
    {
        if (Index >= MI_UNLOADED_DRIVERS)
        {
            Index = MI_UNLOADED_DRIVERS - 1;
        }

        // read in unloaded driver
        if (CurReadAllVirtual(pvMiUnloadedDrivers +
                              Index * sizeof(UNLOADED_DRIVERS32),
                              &ud, sizeof(ud)) != S_OK)
        {
            ErrOut("Can't read memory from %s",
                   FormatAddr64(pvMiUnloadedDrivers +
                                Index * sizeof(UNLOADED_DRIVERS32)));
        }

        // copy name lengths
        pdud->Name.MaximumLength = ud.Name.MaximumLength;
        pdud->Name.Length = ud.Name.Length;
        if (ud.Name.Buffer == NULL)
        {
            break;
        }

        // copy start and end address
        pdud->StartAddress = ud.StartAddress;
        pdud->EndAddress = ud.EndAddress;

        // restrict name length and maximum name length to 12 characters
        if (pdud->Name.Length > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.Length = MAX_UNLOADED_NAME_LENGTH;
        }
        if (pdud->Name.MaximumLength > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.MaximumLength = MAX_UNLOADED_NAME_LENGTH;
        }
        // Can't store pointers in the dump so just zero it.
        pdud->Name.Buffer = 0;
        // Read in name.
        if (CurReadAllVirtual(EXTEND64(ud.Name.Buffer),
                              pdud->DriverName,
                              pdud->Name.MaximumLength) != S_OK)
        {
            ErrOut("Can't read memory at address %08x",
                   (ULONG)(ud.Name.Buffer));
        }

        // move to previous driver
        pdud += 1;
        Index -= 1;
    }

    // number of drivers in the list
    *((PULONG) pb) = i;
}

void CCrashDumpWrapper32::WriteMmTriageInformation(BYTE *pb)
{
    DUMP_MM_STORAGE32 TriageInformation;
    ULONG64 pMmVerifierData;
    ULONG64 pvMmPagedPoolInfo;
    ULONG cbNonPagedPool;
    ULONG cbPagedPool;


    // version information
    TriageInformation.Version = 1;

    // size information
    TriageInformation.Size = sizeof(TriageInformation);

    // get special pool tag
    ExtractValue(MmSpecialPoolTag, TriageInformation.MmSpecialPoolTag);

    // get triage action taken
    ExtractValue(MmTriageActionTaken, TriageInformation.MiTriageActionTaken);
    pMmVerifierData = g_Target->m_KdDebuggerData.MmVerifierData;

    // read in verifier level
    // BUGBUG - should not read internal data structures in MM
    //if (pMmVerifierData)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_DRIVER_VERIFIER_DATA *) pMmVerifierData)->Level,
    //        &TriageInformation.MmVerifyDriverLevel,
    //        sizeof(TriageInformation.MmVerifyDriverLevel));
    //else
        TriageInformation.MmVerifyDriverLevel = 0;

    // read in verifier
    ExtractValue(KernelVerifier, TriageInformation.KernelVerifier);

    // read non paged pool info
    ExtractValue(MmMaximumNonPagedPoolInBytes, cbNonPagedPool);
    TriageInformation.MmMaximumNonPagedPool = cbNonPagedPool /
                                              g_Target->m_Machine->m_PageSize;
    ExtractValue(MmAllocatedNonPagedPool, TriageInformation.MmAllocatedNonPagedPool);

    // read paged pool info
    ExtractValue(MmSizeOfPagedPoolInBytes, cbPagedPool);
    TriageInformation.PagedPoolMaximum = cbPagedPool /
                                         g_Target->m_Machine->m_PageSize;
    pvMmPagedPoolInfo = g_Target->m_KdDebuggerData.MmPagedPoolInformation;

    // BUGBUG - should not read internal data structures in MM
    //if (pvMmPagedPoolInfo)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_PAGED_POOL_INFO *) pvMmPagedPoolInfo)->AllocatedPagedPool,
    //        &TriageInformation.PagedPoolAllocated,
    //        sizeof(TriageInformation.PagedPoolAllocated));
    //else
        TriageInformation.PagedPoolAllocated = 0;

    // read committed pages info
    ExtractValue(MmTotalCommittedPages, TriageInformation.CommittedPages);
    ExtractValue(MmPeakCommitment, TriageInformation.CommittedPagesPeak);
    ExtractValue(MmTotalCommitLimitMaximum, TriageInformation.CommitLimitMaximum);
    memcpy(pb, &TriageInformation, sizeof(TriageInformation));
}

//----------------------------------------------------------------------------
//
// CCrashDumpWrapper64.
//
//----------------------------------------------------------------------------

void
CCrashDumpWrapper64::WriteDriverList(
    BYTE *pb,
    TRIAGE_DUMP64 *ptdh
    )
{
    PDUMP_DRIVER_ENTRY64 pdde;
    PDUMP_STRING pds;
    ModuleInfo* ModIter;
    ULONG MaxEntries = ptdh->DriverCount;

    ptdh->DriverCount = 0;

    if (((ModIter = g_Target->GetModuleInfo(FALSE)) == NULL) ||
        ((ModIter->Initialize(g_Thread)) != S_OK))
    {
        return;
    }

    // pointer to first driver entry to write out
    pdde = (PDUMP_DRIVER_ENTRY64) (pb + ptdh->DriverListOffset);

    // pointer to first module name to write out
    pds = (PDUMP_STRING) (pb + ptdh->StringPoolOffset);

    while ((PBYTE)(pds + 1) < pb + TRIAGE_DUMP_SIZE64 &&
           ptdh->DriverCount < MaxEntries)
    {
        MODULE_INFO_ENTRY ModEntry;

        ULONG retval = GetNextModuleEntry(ModIter, &ModEntry);

        if (retval == GNME_CORRUPT ||
            retval == GNME_DONE)
        {
            break;
        }
        else if (retval == GNME_NO_NAME)
        {
            continue;
        }

        pdde->LdrEntry.DllBase       = ModEntry.Base;
        pdde->LdrEntry.SizeOfImage   = ModEntry.Size;
        pdde->LdrEntry.CheckSum      = ModEntry.CheckSum;
        pdde->LdrEntry.TimeDateStamp = ModEntry.TimeDateStamp;

        if (ModEntry.UnicodeNamePtr)
        {
            // convert length from bytes to characters
            pds->Length = ModEntry.NameLength / sizeof(WCHAR);
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE64)
            {
                break;
            }

            CopyMemory(pds->Buffer,
                       ModEntry.NamePtr,
                       ModEntry.NameLength);
        }
        else
        {
            pds->Length = ModEntry.NameLength;
            if ((PBYTE)pds->Buffer + pds->Length + sizeof(WCHAR) >
                pb + TRIAGE_DUMP_SIZE64)
            {
                break;
            }

            MultiByteToWideChar(CP_ACP, 0,
                                ModEntry.NamePtr, ModEntry.NameLength,
                                pds->Buffer, ModEntry.NameLength);
        }

        // null terminate string
        pds->Buffer[pds->Length] = '\0';

        pdde->DriverNameOffset = (ULONG)((ULONG_PTR) pds - (ULONG_PTR) pb);


        // get pointer to next string
        pds = (PDUMP_STRING) ALIGN_UP_POINTER(((LPBYTE) pds) +
                      sizeof(DUMP_STRING) + sizeof(WCHAR) * (pds->Length + 1),
                                               ULONGLONG);

        pdde = (PDUMP_DRIVER_ENTRY64)(((PUCHAR) pdde) + sizeof(*pdde));

        ptdh->DriverCount++;
    }

    ptdh->StringPoolSize = (ULONG) ((ULONG_PTR)pds -
                                    (ULONG_PTR)(pb + ptdh->StringPoolOffset));
}


void CCrashDumpWrapper64::WriteUnloadedDrivers(BYTE *pb)
{
    ULONG i;
    ULONG Index;
    UNLOADED_DRIVERS64 ud;
    PDUMP_UNLOADED_DRIVERS64 pdud;
    ULONG64 pvMiUnloadedDrivers;
    ULONG ulMiLastUnloadedDriver;

    *((PULONG) pb) = 0;

    //
    // find location of unloaded drivers
    //

    if (!g_Target->m_KdDebuggerData.MmUnloadedDrivers ||
        !g_Target->m_KdDebuggerData.MmLastUnloadedDriver)
    {
        return;
    }

    g_Target->ReadPointer(g_Process, g_Target->m_Machine,
                          g_Target->m_KdDebuggerData.MmUnloadedDrivers,
                          &pvMiUnloadedDrivers);
    CurReadAllVirtual(g_Target->m_KdDebuggerData.MmLastUnloadedDriver,
                      &ulMiLastUnloadedDriver,
                      sizeof(ULONG));

    if (pvMiUnloadedDrivers == NULL || ulMiLastUnloadedDriver == 0)
    {
        return;
    }

    // point to last unloaded drivers
    pdud = (PDUMP_UNLOADED_DRIVERS64)(((PULONG64) pb) + 1);

    //
    // Write the list with the most recently unloaded driver first to the
    // least recently unloaded driver last.
    //

    Index = ulMiLastUnloadedDriver - 1;

    for (i = 0; i < MI_UNLOADED_DRIVERS; i += 1)
    {
        if (Index >= MI_UNLOADED_DRIVERS)
        {
            Index = MI_UNLOADED_DRIVERS - 1;
        }

        // read in unloaded driver
        if (CurReadAllVirtual(pvMiUnloadedDrivers +
                              Index * sizeof(UNLOADED_DRIVERS64),
                              &ud, sizeof(ud)) != S_OK)
        {
            ErrOut("Can't read memory from %s",
                   FormatAddr64(pvMiUnloadedDrivers +
                                Index * sizeof(UNLOADED_DRIVERS64)));
        }

        // copy name lengths
        pdud->Name.MaximumLength = ud.Name.MaximumLength;
        pdud->Name.Length = ud.Name.Length;
        if (ud.Name.Buffer == NULL)
        {
            break;
        }

        // copy start and end address
        pdud->StartAddress = ud.StartAddress;
        pdud->EndAddress = ud.EndAddress;

        // restrict name length and maximum name length to 12 characters
        if (pdud->Name.Length > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.Length = MAX_UNLOADED_NAME_LENGTH;
        }
        if (pdud->Name.MaximumLength > MAX_UNLOADED_NAME_LENGTH)
        {
            pdud->Name.MaximumLength = MAX_UNLOADED_NAME_LENGTH;
        }
        // Can't store pointers in the dump so just zero it.
        pdud->Name.Buffer = 0;
        // Read in name.
        if (CurReadAllVirtual(ud.Name.Buffer,
                              pdud->DriverName,
                              pdud->Name.MaximumLength) != S_OK)
        {
            ErrOut("Can't read memory at address %s",
                   FormatAddr64(ud.Name.Buffer));
        }

        // move to previous driver
        pdud += 1;
        Index -= 1;
    }

    // number of drivers in the list
    *((PULONG) pb) = i;
}

void CCrashDumpWrapper64::WriteMmTriageInformation(BYTE *pb)
{
    DUMP_MM_STORAGE64 TriageInformation;
    ULONG64 pMmVerifierData;
    ULONG64 pvMmPagedPoolInfo;
    ULONG64 cbNonPagedPool;
    ULONG64 cbPagedPool;


    // version information
    TriageInformation.Version = 1;

    // size information
    TriageInformation.Size = sizeof(TriageInformation);

    // get special pool tag
    ExtractValue(MmSpecialPoolTag, TriageInformation.MmSpecialPoolTag);

    // get triage action taken
    ExtractValue(MmTriageActionTaken, TriageInformation.MiTriageActionTaken);
    pMmVerifierData = g_Target->m_KdDebuggerData.MmVerifierData;

    // read in verifier level
    // BUGBUG - should not read internal data structures in MM
    //if (pMmVerifierData)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_DRIVER_VERIFIER_DATA *) pMmVerifierData)->Level,
    //        &TriageInformation.MmVerifyDriverLevel,
    //        sizeof(TriageInformation.MmVerifyDriverLevel));
    //else
        TriageInformation.MmVerifyDriverLevel = 0;

    // read in verifier
    ExtractValue(KernelVerifier, TriageInformation.KernelVerifier);

    // read non paged pool info
    ExtractValue(MmMaximumNonPagedPoolInBytes, cbNonPagedPool);
    TriageInformation.MmMaximumNonPagedPool = cbNonPagedPool /
                                              g_Target->m_Machine->m_PageSize;
    ExtractValue(MmAllocatedNonPagedPool, TriageInformation.MmAllocatedNonPagedPool);

    // read paged pool info
    ExtractValue(MmSizeOfPagedPoolInBytes, cbPagedPool);
    TriageInformation.PagedPoolMaximum = cbPagedPool /
                                         g_Target->m_Machine->m_PageSize;
    pvMmPagedPoolInfo = g_Target->m_KdDebuggerData.MmPagedPoolInformation;

    // BUGBUG - should not read internal data structures in MM
    //if (pvMmPagedPoolInfo)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_PAGED_POOL_INFO *) pvMmPagedPoolInfo)->AllocatedPagedPool,
    //        &TriageInformation.PagedPoolAllocated,
    //        sizeof(TriageInformation.PagedPoolAllocated));
    //else
        TriageInformation.PagedPoolAllocated = 0;

    // read committed pages info
    ExtractValue(MmTotalCommittedPages, TriageInformation.CommittedPages);
    ExtractValue(MmPeakCommitment, TriageInformation.CommittedPagesPeak);
    ExtractValue(MmTotalCommitLimitMaximum, TriageInformation.CommitLimitMaximum);
    memcpy(pb, &TriageInformation, sizeof(TriageInformation));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ee_masm.cpp ===
//----------------------------------------------------------------------------
//
// MASM-syntax expression evaluation.
//
// Copyright (C) Microsoft Corporation, 1990-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

//  token classes (< 100) and types (>= 100)

#define EOL_CLASS       0
#define ADDOP_CLASS     1
#define ADDOP_PLUS      100
#define ADDOP_MINUS     101
#define MULOP_CLASS     2
#define MULOP_MULT      200
#define MULOP_DIVIDE    201
#define MULOP_MOD       202
#define MULOP_SEG       203
//#define MULOP_64        204
#define LOGOP_CLASS     3
#define LOGOP_AND       300
#define LOGOP_OR        301
#define LOGOP_XOR       302
#define LRELOP_CLASS    4
#define LRELOP_EQ       400
#define LRELOP_NE       401
#define LRELOP_LT       402
#define LRELOP_GT       403
#define UNOP_CLASS      5
#define UNOP_NOT        500
#define UNOP_BY         501
#define UNOP_WO         502
#define UNOP_DWO        503
#define UNOP_POI        504
#define UNOP_LOW        505
#define UNOP_HI         506
#define UNOP_QWO        507
#define UNOP_VAL        508
#define LPAREN_CLASS    6
#define RPAREN_CLASS    7
#define LBRACK_CLASS    8
#define RBRACK_CLASS    9
#define REG_CLASS       10
#define NUMBER_CLASS    11
#define SYMBOL_CLASS    12
#define LINE_CLASS      13
#define SHIFT_CLASS     14
#define SHIFT_LEFT              1400
#define SHIFT_RIGHT_LOGICAL     1401
#define SHIFT_RIGHT_ARITHMETIC  1402

#define ERROR_CLASS     99              //only used for PeekToken()
#define INVALID_CLASS   -1

struct Res
{
    char     chRes[3];
    ULONG    classRes;
    ULONG    valueRes;
};

Res g_Reserved[] =
{
    { 'o', 'r', '\0', LOGOP_CLASS, LOGOP_OR  },
    { 'b', 'y', '\0', UNOP_CLASS,  UNOP_BY   },
    { 'w', 'o', '\0', UNOP_CLASS,  UNOP_WO   },
    { 'd', 'w', 'o',  UNOP_CLASS,  UNOP_DWO  },
    { 'q', 'w', 'o',  UNOP_CLASS,  UNOP_QWO  },
    { 'h', 'i', '\0', UNOP_CLASS,  UNOP_HI   },
    { 'm', 'o', 'd',  MULOP_CLASS, MULOP_MOD },
    { 'x', 'o', 'r',  LOGOP_CLASS, LOGOP_XOR },
    { 'a', 'n', 'd',  LOGOP_CLASS, LOGOP_AND },
    { 'p', 'o', 'i',  UNOP_CLASS,  UNOP_POI  },
    { 'n', 'o', 't',  UNOP_CLASS,  UNOP_NOT  },
    { 'l', 'o', 'w',  UNOP_CLASS,  UNOP_LOW  },
    { 'v', 'a', 'l',  UNOP_CLASS,  UNOP_VAL  }
};

Res g_X86Reserved[] =
{
    { 'e', 'a', 'x',  REG_CLASS,   X86_EAX   },
    { 'e', 'b', 'x',  REG_CLASS,   X86_EBX   },
    { 'e', 'c', 'x',  REG_CLASS,   X86_ECX   },
    { 'e', 'd', 'x',  REG_CLASS,   X86_EDX   },
    { 'e', 'b', 'p',  REG_CLASS,   X86_EBP   },
    { 'e', 's', 'p',  REG_CLASS,   X86_ESP   },
    { 'e', 'i', 'p',  REG_CLASS,   X86_EIP   },
    { 'e', 's', 'i',  REG_CLASS,   X86_ESI   },
    { 'e', 'd', 'i',  REG_CLASS,   X86_EDI   },
    { 'e', 'f', 'l',  REG_CLASS,   X86_EFL   }
};

#define RESERVESIZE (sizeof(g_Reserved) / sizeof(Res))
#define X86_RESERVESIZE (sizeof(g_X86Reserved) / sizeof(Res))

char * g_X86SegRegs[] =
{
    "cs", "ds", "es", "fs", "gs", "ss"
};
#define X86_SEGREGSIZE (sizeof(g_X86SegRegs) / sizeof(char *))

//----------------------------------------------------------------------------
//
// MasmEvalExpression.
//
//----------------------------------------------------------------------------

MasmEvalExpression::MasmEvalExpression(void)
    : EvalExpression(DEBUG_EXPR_MASM,
                     "Microsoft Assembler expressions",
                     "MASM")
{
    m_SavedClass = INVALID_CLASS;
    m_ForcePositiveNumber = FALSE;
    m_AddrExprType = 0;
    m_TypedExpr = FALSE;
}

MasmEvalExpression::~MasmEvalExpression(void)
{
}

PCSTR
MasmEvalExpression::Evaluate(PCSTR Expr, PCSTR Desc, ULONG Flags,
                             TypedData* Result)
{
    ULONG64 Value;
    
    Start(Expr, Desc, Flags);

    if (m_Flags & EXPRF_SINGLE_TERM)
    {
        m_SavedClass = INVALID_CLASS;
        Value = GetTerm();
    }
    else
    {
        Value = GetCommonExpression();
    }

    ZeroMemory(Result, sizeof(*Result));
    Result->SetToNativeType(DNTYPE_UINT64);
    Result->m_U64 = Value;
    
    Expr = m_Lex;
    End(Result);
    return Expr;
}

PCSTR
MasmEvalExpression::EvaluateAddr(PCSTR Expr, PCSTR Desc,
                                 ULONG SegReg, PADDR Addr)
{
    TypedData Result;
    
    Start(Expr, Desc, EXPRF_DEFAULT);

    Result.SetU64(GetCommonExpression());

    Expr = m_Lex;
    End(&Result);

    ForceAddrExpression(SegReg, Addr, Result.m_U64);
    
    return Expr;
}

void
MasmEvalExpression::ForceAddrExpression(ULONG SegReg, PADDR Address,
                                        ULONG64 Value)
{
    DESCRIPTOR64 DescBuf, *Desc = NULL;
        
    *Address = m_TempAddr;
    // Rewriting the offset may change flat address so
    // be sure to recompute it later.
    Off(*Address) = Value;

    //  If it wasn't an explicit address expression
    //  force it to be an address

    if (!(m_AddrExprType & ~INSTR_POINTER))
    {
        // Default to a flat address.
        m_AddrExprType = ADDR_FLAT;
        // Apply various overrides.
        if (g_X86InVm86)
        {
            m_AddrExprType = ADDR_V86;
        }
        else if (g_X86InCode16)
        {
            m_AddrExprType = ADDR_16;
        }
        else if (g_Machine &&
                 g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
                 !g_Amd64InCode64)
        {
            m_AddrExprType = ADDR_1632;
        }

        Address->type = m_AddrExprType;
        if (m_AddrExprType != ADDR_FLAT &&
            SegReg < SEGREG_COUNT &&
            g_Machine &&
            g_Machine->GetSegRegDescriptor(SegReg, &DescBuf) == S_OK)
        {
            ContextSave* Push;
            PCROSS_PLATFORM_CONTEXT ScopeContext =
                GetCurrentScopeContext();
            if (ScopeContext)
            {
                Push = g_Machine->PushContext(ScopeContext);
            }

            Address->seg = (USHORT)
                g_Machine->FullGetVal32(g_Machine->GetSegRegNum(SegReg));
            Desc = &DescBuf;
            
            if (ScopeContext)
            {
                g_Machine->PopContext(Push);
            }
        }
        else
        {
            Address->seg = 0;
        }
    }
    else if fnotFlat(*Address)
    {
        //  This case (i.e., m_AddrExprType && !flat) results from
        //  an override (i.e., %,,&, or #) being used but no segment
        //  being specified to force a flat address computation.

        Type(*Address) = m_AddrExprType;
        Address->seg = 0;

        if (SegReg < SEGREG_COUNT)
        {
            //  test flag for IP or EIP as register argument
            //      if so, use CS as default register
            if (fInstrPtr(*Address))
            {
                SegReg = SEGREG_CODE;
            }
        
            if (g_Machine &&
                g_Machine->GetSegRegDescriptor(SegReg, &DescBuf) == S_OK)
            {
                ContextSave* Push;
                PCROSS_PLATFORM_CONTEXT ScopeContext =
                    GetCurrentScopeContext();
		if (ScopeContext)
                {
                    Push = g_Machine->PushContext(ScopeContext);
                }

                Address->seg = (USHORT)
                    g_Machine->FullGetVal32(g_Machine->GetSegRegNum(SegReg));
                Desc = &DescBuf;
                
		if (ScopeContext)
                {
                    g_Machine->PopContext(Push);
                }
            }
        }
    }

    // Force sign-extension of 32-bit flat addresses.
    if (Address->type == ADDR_FLAT &&
        g_Machine &&
        !g_Machine->m_Ptr64)
    {
	Off(*Address) = EXTEND64(Off(*Address));
    }

    // Force an updated flat address to be computed.
    NotFlat(*Address);
    ComputeFlatAddress(Address, Desc);
}


/*
      Inputs
       Must be ([*|&] Sym[(.->)Field])
         
      Outputs
       Evaluates typed expression and returns value
*/

LONG64
MasmEvalExpression::GetTypedExpression(void)
{
    ULONG64 Value=0;
    BOOL    AddrOf=FALSE, ValueAt=FALSE;
    CHAR    c;
    static CHAR    Name[MAX_NAME], Field[MAX_NAME];

    c = Peek();

    switch (c)
    { 
    case '(':
        m_Lex++;
        Value = GetTypedExpression();
        c = Peek();
        if (c != ')') 
        {
            EvalError(SYNTAX);
            return 0;
        }
        ++m_Lex;
        return Value;
    case '&':
        // Get Offset/Address
//        AddrOf = TRUE;
//        m_Lex++;
//        Peek();
        break;
    case '*':
    default:
        break;
    }

#if 0
    ULONG i=0;
    ValueAt = TRUE;
    m_Lex++;
    Peek();
    break;
    c = Peek();
    while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
           (c >= '0' && c <= '9') || (c == '_') || (c == '$') ||
           (c == '!'))
    { 
        // Sym Name
        Name[i++] = c;
        c = *++m_Lex;
    }
    Name[i]=0;

    if (c=='.') 
    {
        ++m_Lex;
    }
    else if (c=='-' && *++m_Lex == '>') 
    {
        ++m_Lex;
    }

    i=0;
    c = Peek();

    while ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
           (c >= '0' && c <= '9') || (c == '_') || (c == '$') ||
           (c == '.') || (c == '-') || (c == '>'))
    { 
        Field[i++]= c;
        c = *++m_Lex;
    }
    Field[i] = 0;

    SYM_DUMP_PARAM Sym = {0};
    FIELD_INFO     FieldInfo ={0};

    Sym.size      = sizeof(SYM_DUMP_PARAM);
    Sym.sName     = (PUCHAR) Name;
    Sym.Options   = DBG_DUMP_NO_PRINT;    

    if (Field[0]) 
    {
        Sym.nFields = 1;
        Sym.Fields  = &FieldInfo;

        FieldInfo.fName = (PUCHAR) Field;

        if (AddrOf) 
        {
            FieldInfo.fOptions |= DBG_DUMP_FIELD_RETURN_ADDRESS;
        }
    }
    else if (AddrOf)
    {
        PUCHAR pch = m_Lex;
        
        m_Lex = &Name[0];
        Value = GetMterm();
        m_Lex = pch;
        return Value;
    }
    else
    {
        Sym.Options |= DBG_DUMP_GET_SIZE_ONLY;
    }
    
    ULONG Status=0;
    ULONG Size = SymbolTypeDump(0, NULL, &Sym, &Status);

    if (!Status) 
    {
        if (!Field[0] && (Size <= sizeof (Value)))
        {
            // Call routine again to read value
            Sym.Options |= DBG_DUMP_COPY_TYPE_DATA;
            Sym.Context = (PVOID) &Value;
            if ((SymbolTypeDump(0, NULL, &Sym, &Status) == 8) && (Size == 4))
            {
                Value = (ULONG) Value;
            }
        }
        else if (Field[0] && (FieldInfo.size <= sizeof(ULONG64)))
        {
            Value = FieldInfo.address;
        }
        else  // too big
        {
            Value = 0;
        }
    }
#endif

    ULONG PreferVal = m_Flags & EXPRF_PREFER_SYMBOL_VALUES;
    m_Flags |= EXPRF_PREFER_SYMBOL_VALUES;
    Value = GetMterm();
    m_Flags = (m_Flags & ~EXPRF_PREFER_SYMBOL_VALUES) | PreferVal;

    return Value;
}

/*
  Evaluate the value in symbol expression Symbol
*/

BOOL
MasmEvalExpression::GetSymValue(PSTR Symbol, PULONG64 RetValue)
{
    TYPES_INFO_ALL Typ;

    if (GetExpressionTypeInfo(Symbol, &Typ))
    {
        if (Typ.Flags)
        {
            if (Typ.Flags & SYMFLAG_VALUEPRESENT)
            {
                *RetValue = Typ.Value;
                return TRUE;
            }
            
            TranslateAddress(Typ.Module, Typ.Flags, Typ.Register,
                             &Typ.Address, &Typ.Value);
            if (Typ.Value && (Typ.Flags & SYMFLAG_REGISTER))
            {
                *RetValue = Typ.Value;
                return TRUE;
            }
        }
        if (Symbol[0] == '&')
        {
            *RetValue = Typ.Address;
            return TRUE;
        }
        else if (Typ.Size <= sizeof(*RetValue))
        {
            ULONG64 Val = 0;
            if (CurReadAllVirtual(Typ.Address, &Val, Typ.Size) == S_OK)
            {
                *RetValue = Val;
                return TRUE;
            }
        }
    }

    *RetValue = 0;
    return FALSE;
}

char
MasmEvalExpression::Peek(void)
{
    char Ch;

    do
    {
        Ch = *m_Lex++;
    } while (Ch == ' ' || Ch == '\t' || Ch == '\r' || Ch == '\n');
    
    m_Lex--;
    return Ch;
}

ULONG64
MasmEvalExpression::GetCommonExpression(void)
{
    CHAR ch;

    m_SavedClass = INVALID_CLASS;

    ch = Peek();
    switch(ch)
    {
    case '&':
        m_Lex++;
        m_AddrExprType = ADDR_V86;
        break;
    case '#':
        m_Lex++;
        m_AddrExprType = ADDR_16;
        break;
    case '%':
        m_Lex++;
        m_AddrExprType = ADDR_FLAT;
        break;
    default:
        m_AddrExprType = ADDR_NONE;
        break;
    }
    
    Peek();
    return (ULONG64)StartExpr();
}

/*** StartExpr - Get expression
*
*   Purpose:
*       Parse logical-terms separated by logical operators into
*       expression value.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<logic-op> <lterm>]*
*       <logic-op> = AND (&), OR (|), XOR (^)
*
*************************************************************************/

LONG64
MasmEvalExpression::StartExpr(void)
{
    LONG64    value1;
    LONG64    value2;
    ULONG     opclass;
    LONG64    oRetValue;

//dprintf("LONG64 StartExpr ()\n");
    value1 = GetLRterm();
    while ((opclass = PeekToken(&oRetValue)) == LOGOP_CLASS)
    {
        AcceptToken();
        value2 = GetLRterm();
        switch (oRetValue)
        {
        case LOGOP_AND:
            value1 &= value2;
            break;
        case LOGOP_OR:
            value1 |= value2;
            break;
        case LOGOP_XOR:
            value1 ^= value2;
            break;
        default:
            EvalError(SYNTAX);
        }
    }
    return value1;
}

/*** GetLRterm - get logical relational term
*
*   Purpose:
*       Parse logical-terms separated by logical relational
*       operators into the expression value.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<rel-logic-op> <lterm>]*
*       <logic-op> = '==' or '=', '!=', '>', '<'
*
*************************************************************************/

LONG64
MasmEvalExpression::GetLRterm(void)
{
    LONG64    value1;
    LONG64    value2;
    ULONG  opclass;
    LONG64    oRetValue;

//dprintf("LONG64 GetLRterm ()\n");
    value1 = GetLterm();
    while ((opclass = PeekToken(&oRetValue)) == LRELOP_CLASS)
    {
        AcceptToken();
        value2 = GetLterm();
        switch (oRetValue)
        {
        case LRELOP_EQ:
            value1 = (value1 == value2);
            break;
        case LRELOP_NE:
            value1 = (value1 != value2);
            break;
        case LRELOP_LT:
            value1 = (value1 < value2);
            break;
        case LRELOP_GT:
            value1 = (value1 > value2);
            break;
        default:
            EvalError(SYNTAX);
        }
    }
    return value1;
}

/*** GetLterm - get logical term
*
*   Purpose:
*       Parse shift-terms separated by shift operators into
*       logical term value.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of sum.
*
*   Exceptions:
*       error exit: SYNTAX - bad logical term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <lterm> = <sterm> [<shift-op> <sterm>]*
*       <shift-op> = <<, >>, >>>
*
*************************************************************************/

LONG64
MasmEvalExpression::GetLterm(void)
{
    LONG64    value1 = GetShiftTerm();
    LONG64    value2;
    ULONG     opclass;
    LONG64    oRetValue;

//dprintf("LONG64 GetLterm ()\n");
    while ((opclass = PeekToken(&oRetValue)) == SHIFT_CLASS)
    {
        AcceptToken();
        value2 = GetShiftTerm();
        switch (oRetValue)
        {
        case SHIFT_LEFT:
            value1 <<= value2;
            break;
        case SHIFT_RIGHT_LOGICAL:
            value1 = (LONG64)((ULONG64)value1 >> value2);
            break;
        case SHIFT_RIGHT_ARITHMETIC:
            value1 >>= value2;
            break;
        default:
            EvalError(SYNTAX);
        }
    }
    return value1;
}

/*** GetShiftTerm - get logical term
*
*   Purpose:
*       Parse additive-terms separated by additive operators into
*       shift term value.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of sum.
*
*   Exceptions:
*       error exit: SYNTAX - bad shift term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <sterm> = <aterm> [<add-op> <aterm>]*
*       <add-op> = +, -
*
*************************************************************************/

LONG64
MasmEvalExpression::GetShiftTerm(void)
{
    LONG64    value1 = GetAterm();
    LONG64    value2;
    ULONG     opclass;
    LONG64    oRetValue;
    USHORT    AddrType1 = m_AddrExprType;

//dprintf("LONG64 GetShifTerm ()\n");
    while ((opclass = PeekToken(&oRetValue)) == ADDOP_CLASS)
    {
        AcceptToken();
        value2 = GetAterm();

        // If either item is an address we want
        // to use the special address arithmetic functions.
        // They only handle address+-value, so we may need
        // to swap things around to allow their use.
        // We can't swap the order of subtraction, plus the
        // result of a subtraction should be a constant.
        if (AddrType1 == ADDR_NONE && m_AddrExprType != ADDR_NONE &&
            oRetValue == ADDOP_PLUS)
        {
            LONG64 Tmp = value1;
            value1 = value2;
            value2 = Tmp;
            AddrType1 = m_AddrExprType;
        }
        
        if (AddrType1 & ~INSTR_POINTER)
        {
            switch (oRetValue)
            {
            case ADDOP_PLUS:
                AddrAdd(&m_TempAddr, value2);
                value1 += value2;
                break;
            case ADDOP_MINUS:
                AddrSub(&m_TempAddr, value2);
                value1 -= value2;
                break;
            default:
                EvalError(SYNTAX);
            }
        }
        else
        {
            switch (oRetValue)
            {
            case ADDOP_PLUS:
                value1 += value2;
                break;
            case ADDOP_MINUS:
                value1 -= value2;
                break;
            default:
                EvalError(SYNTAX);
            }
        }
    }
    return value1;
}

/*** GetAterm - get additive term
*
*   Purpose:
*       Parse multiplicative-terms separated by multipicative operators
*       into additive term value.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of product.
*
*   Exceptions:
*       error exit: SYNTAX - bad additive term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <aterm> = <mterm> [<mult-op> <mterm>]*
*       <mult-op> = *, /, MOD (%)
*
*************************************************************************/

LONG64
MasmEvalExpression::GetAterm(void)
{
    LONG64    value1;
    LONG64    value2;
    ULONG     opclass;
    LONG64    oRetValue;

//dprintf("LONG64 GetAterm ()\n");
    value1 = GetMterm();
    while ((opclass = PeekToken(&oRetValue)) == MULOP_CLASS)
    {
        AcceptToken();
        value2 = GetMterm();
        switch (oRetValue)
        {
        case MULOP_MULT:
            value1 *= value2;
            break;
        case MULOP_DIVIDE:
            if (value2 == 0)
            {
                EvalError(OPERAND);
            }
            value1 /= value2;
            break;
        case MULOP_MOD:
            if (value2 == 0)
            {
                EvalError(OPERAND);
            }
            value1 %= value2;
            break;
        case MULOP_SEG:
            PDESCRIPTOR64 pdesc;
            DESCRIPTOR64 desc;

            pdesc = NULL;
            if (m_AddrExprType != ADDR_NONE)
            {
                Type(m_TempAddr) = m_AddrExprType;
            }
            else
            {
                // We don't know what kind of address this is
                // Let's try to figure it out.
                if (g_X86InVm86)
                {
                    m_AddrExprType = Type(m_TempAddr) = ADDR_V86;
                }
                else if (g_Target->GetSelDescriptor
                         (g_Thread, g_Machine,
                          (ULONG)value1, &desc) != S_OK)
                {
                    EvalError(BADSEG);
                }
                else
                {
                    m_AddrExprType = Type(m_TempAddr) =
                        (desc.Flags & X86_DESC_DEFAULT_BIG) ?
                        ADDR_1632 : ADDR_16;
                    pdesc = &desc;
                }
            }

            m_TempAddr.seg  = (USHORT)value1;
            m_TempAddr.off  = value2;
            ComputeFlatAddress(&m_TempAddr, pdesc);
            value1 = value2;
            break;

        default:
            EvalError(SYNTAX);
        }
    }

    return value1;
}

/*** GetMterm - get multiplicative term
*
*   Purpose:
*       Parse basic-terms optionally prefaced by one or more
*       unary operators into a multiplicative term.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of multiplicative term.
*
*   Exceptions:
*       error exit: SYNTAX - bad multiplicative term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <mterm> = [<unary-op>] <term> | <unary-op> <mterm>
*       <unary-op> = <add-op>, ~ (NOT), BY, WO, DW, HI, LOW
*
*************************************************************************/

LONG64
MasmEvalExpression::GetMterm(void)
{
    LONG64  value;
    ULONG   opclass;
    LONG64  oRetValue;
    ULONG   size = 0;

//dprintf("LONG64 GetMterm ()\n");
    if ((opclass = PeekToken(&oRetValue)) == UNOP_CLASS ||
                                opclass == ADDOP_CLASS)
    {
        AcceptToken();
        if (oRetValue == UNOP_VAL) 
        {
            // Do not use default expression handler for type expressions.
            value = GetTypedExpression();
        }
        else
        {
            value = GetMterm();
        }
        switch (oRetValue)
        {
        case UNOP_NOT:
            value = !value;
            break;
        case UNOP_BY:
            size = 1;
            break;
        case UNOP_WO:
            size = 2;
            break;
        case UNOP_DWO:
            size = 4;
            break;
        case UNOP_POI:
            size = 0xFFFF;
            break;
        case UNOP_QWO:
            size = 8;
            break;
        case UNOP_LOW:
            value &= 0xffff;
            break;
        case UNOP_HI:
            value = (ULONG)value >> 16;
            break;
        case ADDOP_PLUS:
            break;
        case ADDOP_MINUS:
            value = -value;
            break;
        case UNOP_VAL:
            break;
        default:
            EvalError(SYNTAX);
        }

        if (size)
        {
            ADDR CurAddr;
            
            NotFlat(CurAddr);

            ForceAddrExpression(SEGREG_COUNT, &CurAddr, value);

            value = 0;

            //
            // For pointers, call read pointer so we read the correct size
            // and sign extend.
            //

            if (size == 0xFFFF)
            {
                if (g_Target->ReadPointer(g_Process, g_Machine,
                                          Flat(CurAddr),
                                          (PULONG64)&value) != S_OK)
                {
                    EvalError(MEMORY);
                }
            }
            else
            {
                if (g_Target->ReadAllVirtual(g_Process, Flat(CurAddr),
                                             &value, size) != S_OK)
                {
                    EvalError(MEMORY);
                }
            }

            // We've looked up an arbitrary value so we can
            // no longer consider this an address expression.
            m_AddrExprType = ADDR_NONE;
        }
    }
    else
    {
        value = GetTerm();
    }
    return value;
}

/*** GetTerm - get basic term
*
*   Purpose:
*       Parse numeric, variable, or register name into a basic
*       term value.
*
*   Input:
*       m_Lex - present command line position
*
*   Returns:
*       long value of basic term.
*
*   Exceptions:
*       error exit: SYNTAX - empty basic term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <term> = ( <expr> ) | <register-value> | <number> | <variable>
*       <register-value> = @<register-name>
*
*************************************************************************/

LONG64
MasmEvalExpression::GetTerm(void)
{
    LONG64 value;
    ULONG  opclass;
    LONG64 oRetValue;

//dprintf("LONG64 GetTerm ()\n");
    opclass = GetTokenSym(&oRetValue);
    if (opclass == LPAREN_CLASS)
    {
        value = StartExpr();
        if (GetTokenSym(&oRetValue) != RPAREN_CLASS)
        {
            EvalError(SYNTAX);
        }
    }
    else if (opclass == LBRACK_CLASS)
    {
        value = StartExpr();
        if (GetTokenSym(&oRetValue) != RBRACK_CLASS)
        {
            EvalError(SYNTAX);
        }
    }
    else if (opclass == REG_CLASS)
    {
        REGVAL Val;
        
        if (g_Machine &&
            ((g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 &&
              (oRetValue == X86_EIP || oRetValue == X86_IP)) ||
             (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
              (oRetValue == AMD64_RIP || oRetValue == AMD64_EIP ||
               oRetValue == AMD64_IP))))
        {
            m_AddrExprType |= INSTR_POINTER;
        }

        GetPseudoOrRegVal(TRUE, (ULONG)oRetValue, &Val);
        value = Val.I64;
    }
    else if (opclass == NUMBER_CLASS ||
             opclass == SYMBOL_CLASS ||
             opclass == LINE_CLASS)
    {
        value = oRetValue;
    }
    else
    {
        EvalErrorDesc(SYNTAX, m_ExprDesc);
    }

    return value;
}

ULONG
MasmEvalExpression::GetRegToken(char *str, PULONG64 value)
{
    if ((*value = RegIndexFromName(str)) != REG_ERROR)
    {
        return REG_CLASS;
    }
    else
    {
        *value = BADREG;
        return ERROR_CLASS;
    }
}

/*** PeekToken - peek the next command line token
*
*   Purpose:
*       Return the next command line token, but do not advance
*       the m_Lex pointer.
*
*   Input:
*       m_Lex - present command line position.
*
*   Output:
*       *RetValue - optional value of token
*   Returns:
*       class of token
*
*   Notes:
*       m_SavedClass, m_SavedValue, and m_SavedCommand saves the token getting
*       state for future peeks.  To get the next token, a GetToken or
*       AcceptToken call must first be made.
*
*************************************************************************/

ULONG
MasmEvalExpression::PeekToken(PLONG64 RetValue)
{
    PCSTR Temp;

//dprintf("ULONG PeekToken (PLONG64 RetValue)\n");
    //  Get next class and value, but do not
    //  move m_Lex, but save it in m_SavedCommand.
    //  Do not report any error condition.

    if (m_SavedClass == INVALID_CLASS)
    {
        Temp = m_Lex;
        m_SavedClass = NextToken(&m_SavedValue);
        m_SavedCommand = m_Lex;
        m_Lex = Temp;
        if (m_SavedClass == ADDOP_CLASS && m_SavedValue == ADDOP_PLUS)
        {
            m_ForcePositiveNumber = TRUE;
        }
        else
        {
            m_ForcePositiveNumber = FALSE;
        }
    }
    *RetValue = m_SavedValue;
    return m_SavedClass;
}

/*** AcceptToken - accept any peeked token
*
*   Purpose:
*       To reset the PeekToken saved variables so the next PeekToken
*       will get the next token in the command line.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void
MasmEvalExpression::AcceptToken(void)
{
//dprintf("void AcceptToken (void)\n");
    m_SavedClass = INVALID_CLASS;
    m_Lex = m_SavedCommand;
}

/*** GetTokenSym - peek and accept the next token
*
*   Purpose:
*       Combines the functionality of PeekToken and AcceptToken
*       to return the class and optional value of the next token
*       as well as updating the command pointer m_Lex.
*
*   Input:
*       m_Lex - present command string pointer
*
*   Output:
*       *RetValue - pointer to the token value optionally set.
*   Returns:
*       class of the token read.
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *RetValue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
MasmEvalExpression::GetTokenSym(PLONG64 RetValue)
{
    ULONG   opclass;

//dprintf("ULONG GetTokenSym (PLONG RetValue)\n");
    if (m_SavedClass != INVALID_CLASS)
    {
        opclass = m_SavedClass;
        m_SavedClass = INVALID_CLASS;
        *RetValue = m_SavedValue;
        m_Lex = m_SavedCommand;
    }
    else
    {
        opclass = NextToken(RetValue);
    }

    if (opclass == ERROR_CLASS)
    {
        EvalError((ULONG)*RetValue);
    }

    return opclass;
}

struct DISPLAY_AMBIGUOUS_SYMBOLS
{
    PSTR MatchString;
    PSTR Module;
    MachineInfo* Machine;
};

BOOL CALLBACK
DisplayAmbiguousSymbols(
    PSYMBOL_INFO    SymInfo,
    ULONG           Size,
    PVOID           UserContext
    )
{
    DISPLAY_AMBIGUOUS_SYMBOLS* Context =
        (DISPLAY_AMBIGUOUS_SYMBOLS*)UserContext;

    if (IgnoreEnumeratedSymbol(g_Process, Context->MatchString,
                               Context->Machine, SymInfo))
    {
        return TRUE;
    }
        
    dprintf("Matched: %s %s!%s",
            FormatAddr64(SymInfo->Address), Context->Module, SymInfo->Name);
    ShowSymbolInfo(SymInfo);
    dprintf("\n");
    
    return TRUE;
}

ULONG
MasmEvalExpression::EvalSymbol(PSTR Name, PULONG64 Value)
{
    if (m_Process == NULL)
    {
        return INVALID_CLASS;
    }

    if (m_Flags & EXPRF_PREFER_SYMBOL_VALUES)
    {
        if (GetSymValue(Name, Value))
        {
            return SYMBOL_CLASS;
        }
        else
        {
            return INVALID_CLASS;
        }
    }

    ULONG Count;
    ImageInfo* Image;
    
    if (!(Count = GetOffsetFromSym(g_Process, Name, Value, &Image)))
    {
        // If a valid module name was given we can assume
        // the user really intended this as a symbol reference
        // and return a not-found error rather than letting
        // the text be checked for other kinds of matches.
        if (Image != NULL)
        {
            *Value = VARDEF;
            return ERROR_CLASS;
        }
        else
        {
            return INVALID_CLASS;
        }
    }
    
    if (Count == 1)
    {
        // Found an unambiguous match.
        Type(m_TempAddr) = ADDR_FLAT | FLAT_COMPUTED;
        Flat(m_TempAddr) = Off(m_TempAddr) = *Value;
        m_AddrExprType = Type(m_TempAddr);
        return SYMBOL_CLASS;
    }
            
    //
    // Multiple matches were found so the name is ambiguous.
    // Enumerate the instances and display them.
    //

    Image = m_Process->FindImageByOffset(*Value, FALSE);
    if (Image != NULL)
    {
        DISPLAY_AMBIGUOUS_SYMBOLS Context;
        char FoundSymbol[MAX_SYMBOL_LEN];
        ULONG64 Disp;
        PSTR Bang;

        // The symbol found may not have exactly the name
        // passed in due to prefixing or other modifications.
        // Look up the actual name found.
        GetSymbol(*Value, FoundSymbol, sizeof(FoundSymbol), &Disp);

        Bang = strchr(FoundSymbol, '!');
        if (Bang &&
            !_strnicmp(Image->m_ModuleName, FoundSymbol,
                       Bang - FoundSymbol))
        {
            Context.MatchString = Bang + 1;
        }
        else
        {
            Context.MatchString = FoundSymbol;
        }
        Context.Module = Image->m_ModuleName;
        Context.Machine = MachineTypeInfo(g_Target, Image->GetMachineType());
        if (Context.Machine == NULL)
        {
            Context.Machine = g_Machine;
        }
        SymEnumSymbols(m_Process->m_SymHandle, Image->m_BaseOfImage,
                       FoundSymbol, DisplayAmbiguousSymbols, &Context);
    }
    
    *Value = AMBIGUOUS;
    return ERROR_CLASS;
}

/*** NextToken - process the next token
*
*   Purpose:
*       Parse the next token from the present command string.
*       After skipping any leading white space, first check for
*       any single character tokens or register variables.  If
*       no match, then parse for a number or variable.  If a
*       possible variable, check the reserved word list for operators.
*
*   Input:
*       m_Lex - pointer to present command string
*
*   Output:
*       *RetValue - optional value of token returned
*       m_Lex - updated to point past processed token
*   Returns:
*       class of token returned
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *RetValue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
MasmEvalExpression::NextToken(PLONG64 RetValue)
{
    ULONG               Base = g_DefaultRadix;
    BOOL                AllowSignExtension;
    CHAR                Symbol[MAX_SYMBOL_LEN];
    CHAR                SymbolString[MAX_SYMBOL_LEN];
    CHAR                PreSym[9];
    ULONG               SymbolLen = 0;
    BOOL                IsNumber = TRUE;
    BOOL                IsSymbol = TRUE;
    BOOL                ForceReg = FALSE;
    BOOL                ForceSym = FALSE;
    ULONG               ErrNumber = 0;
    CHAR                Ch;
    CHAR                ChLow;
    CHAR                ChTemp;
    CHAR                Limit1 = '9';
    CHAR                Limit2 = '9';
    BOOL                IsDigit = FALSE;
    ULONG64             Value = 0;
    ULONG64             TmpValue;
    ULONG               Index;
    PCSTR               CmdSave;
    BOOL                WasDigit;
    ULONG               SymClass;
    ULONG               Len;

    // Do sign extension for kernel only.
    AllowSignExtension = IS_KERNEL_TARGET(g_Target);

    Peek();
    m_LexemeSourceStart = m_Lex;
    Ch = *m_Lex++;

    ChLow = (CHAR)tolower(Ch);

    // Check to see if we're at a symbol prefix followed by
    // a symbol character.  Symbol prefixes often contain
    // characters meaningful in other ways in expressions so
    // this check must be performed before the specific expression
    // character checks below.
    if (g_Machine != NULL &&
        g_Machine->m_SymPrefix != NULL &&
        ChLow == g_Machine->m_SymPrefix[0] &&
        (g_Machine->m_SymPrefixLen == 1 ||
         !strncmp(m_Lex, g_Machine->m_SymPrefix + 1,
                 g_Machine->m_SymPrefixLen - 1)))
    {
        CHAR ChNext = *(m_Lex + g_Machine->m_SymPrefixLen - 1);
        CHAR ChNextLow = (CHAR)tolower(ChNext);

        if (ChNextLow == '_' ||
            (ChNextLow >= 'a' && ChNextLow <= 'z'))
        {
            // A symbol character followed the prefix so assume it's
            // a symbol.
            SymbolLen = g_Machine->m_SymPrefixLen;
            DBG_ASSERT(SymbolLen <= sizeof(PreSym));

            m_Lex--;
            memcpy(PreSym, m_Lex, g_Machine->m_SymPrefixLen);
            memcpy(Symbol, m_Lex, g_Machine->m_SymPrefixLen);
            m_Lex += g_Machine->m_SymPrefixLen + 1;
            Ch = ChNext;
            ChLow = ChNextLow;

            ForceSym = TRUE;
            ForceReg = FALSE;
            IsNumber = FALSE;
            goto ProbableSymbol;
        }
    }
    
    // Test for special character operators and register variable.

    switch(ChLow)
    {
    case '\0':
    case ';':
        m_Lex--;
        return EOL_CLASS;
    case '+':
        *RetValue = ADDOP_PLUS;
        return ADDOP_CLASS;
    case '-':
        *RetValue = ADDOP_MINUS;
        return ADDOP_CLASS;
    case '*':
        *RetValue = MULOP_MULT;
        return MULOP_CLASS;
    case '/':
        *RetValue = MULOP_DIVIDE;
        return MULOP_CLASS;
    case '%':
        *RetValue = MULOP_MOD;
        return MULOP_CLASS;
    case '&':
        *RetValue = LOGOP_AND;
        return LOGOP_CLASS;
    case '|':
        *RetValue = LOGOP_OR;
        return LOGOP_CLASS;
    case '^':
        *RetValue = LOGOP_XOR;
        return LOGOP_CLASS;
    case '=':
        if (*m_Lex == '=')
        {
            m_Lex++;
        }
        *RetValue = LRELOP_EQ;
        return LRELOP_CLASS;
    case '>':
        if (*m_Lex == '>')
        {
            m_Lex++;
            if (*m_Lex == '>')
            {
                m_Lex++;
                *RetValue = SHIFT_RIGHT_ARITHMETIC;
            }
            else
            {
                *RetValue = SHIFT_RIGHT_LOGICAL;
            }
            return SHIFT_CLASS;
        }
        *RetValue = LRELOP_GT;
        return LRELOP_CLASS;
    case '<':
        if (*m_Lex == '<')
        {
            m_Lex++;
            *RetValue = SHIFT_LEFT;
            return SHIFT_CLASS;
        }
        *RetValue = LRELOP_LT;
        return LRELOP_CLASS;
    case '!':
        if (*m_Lex != '=')
        {
            break;
        }
        m_Lex++;
        *RetValue = LRELOP_NE;
        return LRELOP_CLASS;
    case '~':
        *RetValue = UNOP_NOT;
        return UNOP_CLASS;
    case '(':
        return LPAREN_CLASS;
    case ')':
        return RPAREN_CLASS;
    case '[':
        return LBRACK_CLASS;
    case ']':
        return RBRACK_CLASS;
    case '.':
        ContextSave* Push;
        PCROSS_PLATFORM_CONTEXT ScopeContext;
        
        if (!IS_CUR_MACHINE_ACCESSIBLE())
        {
            *RetValue = BADTHREAD;
            return ERROR_CLASS;
        }
        
        ScopeContext = GetCurrentScopeContext();
        if (ScopeContext)
        {
            Push = g_Machine->PushContext(ScopeContext);
        }

        g_Machine->GetPC(&m_TempAddr);
        *RetValue = Flat(m_TempAddr);
        m_AddrExprType = Type(m_TempAddr);

        if (ScopeContext)
        {
            g_Machine->PopContext(Push);
        }
        return NUMBER_CLASS;
    case ':':
        *RetValue = MULOP_SEG;
        return MULOP_CLASS;
    }

    //
    // Look for source line expressions.  Because source file names
    // can contain a lot of expression characters which are meaningful
    // to the lexer the whole expression is enclosed in ` characters.
    // This makes them easy to identify and scan.
    //

    if (ChLow == '`')
    {
        ULONG FoundLine;

        // Scan forward for closing `

        CmdSave = m_Lex;

        while (*m_Lex != '`' && *m_Lex != ';' && *m_Lex != 0)
        {
            m_Lex++;
        }

        if (*m_Lex == ';' || *m_Lex == 0)
        {
            *RetValue = SYNTAX;
            return ERROR_CLASS;
        }

        Len = (ULONG)(m_Lex - CmdSave);
        if (Len >= sizeof(m_LexemeBuffer))
        {
            EvalError(OVERFLOW);
        }
        memcpy(m_LexemeBuffer, CmdSave, Len);
        m_LexemeBuffer[Len] = 0;
        m_Lex++;

        FoundLine = GetOffsetFromLine(m_LexemeBuffer, &Value);
        if (FoundLine == LINE_NOT_FOUND && m_AllowUnresolvedSymbols)
        {
            m_NumUnresolvedSymbols++;
            FoundLine = LINE_FOUND;
            Value = 0;
        }
        
        if (FoundLine == LINE_FOUND)
        {
            *RetValue = Value;
            Type(m_TempAddr) = ADDR_FLAT | FLAT_COMPUTED;
            Flat(m_TempAddr) = Off(m_TempAddr) = Value;
            m_AddrExprType = Type(m_TempAddr);
            return LINE_CLASS;
        }
        else
        {
            *RetValue = NOTFOUND;
            return ERROR_CLASS;
        }
    }

    //
    // Check for an alternate evaluator expression.  As with line
    // expressions alteval expressions have different
    // lexical rules and therefore represent a text
    // blob that is parsed with different rules.
    //

    if (ChLow == '@' && *m_Lex == '@')
    {
        TypedData Result;

        //
        // Scan to '(', picking up the optional evaluator name.
        //
        
        CmdSave = ++m_Lex;

        while (*m_Lex != '(' && *m_Lex != ';' && *m_Lex != 0)
        {
            m_Lex++;
        }

        if (*m_Lex == ';' || *m_Lex == 0)
        {
            *RetValue = SYNTAX;
            return ERROR_CLASS;
        }

        Len = (ULONG)(m_Lex - CmdSave);
        if (Len >= sizeof(m_LexemeBuffer))
        {
            EvalError(OVERFLOW);
        }
        memcpy(m_LexemeBuffer, CmdSave, Len);
        m_LexemeBuffer[Len] = 0;
        m_Lex++;

        EvalExpression* Eval;

        if (Len > 0)
        {
            GetEvaluatorByName(m_LexemeBuffer, FALSE, &Eval);
        }
        else
        {
            Eval = GetEvaluator(DEBUG_EXPR_CPLUSPLUS, FALSE);
        }

        Eval->InheritStart(this);
        // Allow all nested evaluators to get cleaned up.
        Eval->m_ChainTop = FALSE;
        m_Lex = (PSTR)Eval->
            Evaluate(m_Lex, NULL, EXPRF_DEFAULT, &Result);

        Eval->InheritEnd(this);
        ReleaseEvaluator(Eval);
        
        if (*m_Lex != ')')
        {
            *RetValue = SYNTAX;
            return ERROR_CLASS;
        }

        m_Lex++;
        if (ErrNumber = Result.ConvertToU64())
        {
            EvalError(ErrNumber);
        }
        *RetValue = Result.m_U64;
        return NUMBER_CLASS;
    }
    
    // Special prefixes - '@' for register - '!' for symbol.

    if (ChLow == '@' || ChLow == '!')
    {
        ForceReg = (BOOL)(ChLow == '@');
        ForceSym = (BOOL)!ForceReg;
        IsNumber = FALSE;
        Ch = *m_Lex++;
        ChLow = (CHAR)tolower(Ch);
    }

    // If string is followed by '!', but not '!=',
    // then it is a module name and treat as text.

    CmdSave = m_Lex;

    WasDigit = FALSE;
    while ((ChLow >= 'a' && ChLow <= 'z') ||
           (ChLow >= '0' && ChLow <= '9') ||
           ((WasDigit || ForceSym) && ChLow == '`') ||
           (ForceSym && ChLow == '\'') ||
           (ChLow == '_') || (ChLow == '$') || (ChLow == '~') ||
           (!ForceReg && ChLow == ':' && *m_Lex == ':'))
    {
        WasDigit = (ChLow >= '0' && ChLow <= '9') ||
            (ChLow >= 'a' && ChLow <= 'f');
        if (ChLow == ':')
        {
            // Colons must come in pairs so skip the second colon
            // right away.
            m_Lex++;
            IsNumber = FALSE;
        }
        ChLow = (CHAR)tolower(*m_Lex);
        m_Lex++;
    }

    // Treat as symbol if a nonnull string is followed by '!',
    // but not '!='.

    if (ChLow == '!' && *m_Lex != '=' && CmdSave != m_Lex)
    {
        IsNumber = FALSE;
    }

    m_Lex = CmdSave;
    ChLow = (CHAR)tolower(Ch);       //  ch was NOT modified

    if (IsNumber)
    {
        if (ChLow == '\'')
        {
            *RetValue = 0;
            while (TRUE)
            {
                Ch = *m_Lex++;

                if (!Ch)
                {
                    *RetValue = SYNTAX;
                    return ERROR_CLASS;
                }

                if (Ch == '\'')
                {
                    if (*m_Lex != '\'')
                    {
                        break;
                    }
                    Ch = *m_Lex++;
                }
                else if (Ch == '\\')
                {
                    Ch = *m_Lex++;
                }

                *RetValue = (*RetValue << 8) | Ch;
            }

            return NUMBER_CLASS;
        }

        // If first character is a decimal digit, it cannot
        // be a symbol.  leading '0' implies octal, except
        // a leading '0x' implies hexadecimal.

        if (ChLow >= '0' && ChLow <= '9')
        {
            if (ForceReg)
            {
                *RetValue = SYNTAX;
                return ERROR_CLASS;
            }
            IsSymbol = FALSE;
            if (ChLow == '0')
            {
                //
                // too many people type in leading 0x so we can't use it to
                // deal with sign extension.
                //
                Ch = *m_Lex++;
                ChLow = (CHAR)tolower(Ch);
                if (ChLow == 'n')
                {
                    Base = 10;
                    Ch = *m_Lex++;
                    ChLow = (CHAR)tolower(Ch);
                    IsDigit = TRUE;
                }
                else if (ChLow == 't')
                {
                    Base = 8;
                    Ch = *m_Lex++;
                    ChLow = (CHAR)tolower(Ch);
                    IsDigit = TRUE;
                }
                else if (ChLow == 'x')
                {
                    Base = 16;
                    Ch = *m_Lex++;
                    ChLow = (CHAR)tolower(Ch);
                    IsDigit = TRUE;
                }
                else if (ChLow == 'y')
                {
                    Base = 2;
                    Ch = *m_Lex++;
                    ChLow = (CHAR)tolower(Ch);
                    IsDigit = TRUE;
                }
                else
                {
                    // Leading zero is used only to imply a positive value
                    // that shouldn't get sign extended.
                    IsDigit = TRUE;
                }
            }
        }

        // A number can start with a letter only if base is
        // hexadecimal and it is a hexadecimal digit 'a'-'f'.

        else if ((ChLow < 'a' || ChLow > 'f') || Base != 16)
        {
            IsNumber = FALSE;
        }

        // Set limit characters for the appropriate base.

        if (Base == 2)
        {
            Limit1 = '1';
        }
        else if (Base == 8)
        {
            Limit1 = '7';
        }
        else if (Base == 16)
        {
            Limit2 = 'f';
        }
    }

 ProbableSymbol:
    
    // Perform processing while character is a letter,
    // digit, underscore, tilde or dollar-sign.

    while ((ChLow >= 'a' && ChLow <= 'z') ||
           (ChLow >= '0' && ChLow <= '9') ||
           ((ForceSym || (IsDigit && Base == 16)) && ChLow == '`') ||
           (ForceSym && ChLow == '\'') ||
           (ChLow == '_') || (ChLow == '$') || (ChLow == '~') ||
           (!ForceReg && ChLow == ':' && *m_Lex == ':'))
    {
        if (ChLow == ':')
        {
            IsNumber = FALSE;
        }
        
        // If possible number, test if within proper range,
        // and if so, accumulate sum.

        if (IsNumber)
        {
            if ((ChLow >= '0' && ChLow <= Limit1) ||
                (ChLow >= 'a' && ChLow <= Limit2))
            {
                IsDigit = TRUE;
                TmpValue = Value * Base;
                if (TmpValue < Value)
                {
                    ErrNumber = OVERFLOW;
                }
                ChTemp = (CHAR)(ChLow - '0');
                if (ChTemp > 9)
                {
                    ChTemp -= 'a' - '0' - 10;
                }
                Value = TmpValue + (ULONG64)ChTemp;
                if (Value < TmpValue)
                {
                    ErrNumber = OVERFLOW;
                }
            }
            else if (IsDigit && ChLow == '`')
            {
                // If ` character is seen, disallow sign extension.
                AllowSignExtension = FALSE;
            }
            else
            {
                IsNumber = FALSE;
                ErrNumber = SYNTAX;
            }
        }
        if (IsSymbol)
        {
            if (SymbolLen < sizeof(PreSym))
            {
                PreSym[SymbolLen] = ChLow;
            }
            if (SymbolLen < MAX_SYMBOL_LEN - 1)
            {
                Symbol[SymbolLen++] = Ch;
            }
            
            // Colons must come in pairs so process the second colon.
            if (ChLow == ':')
            {
                if (SymbolLen < sizeof(PreSym))
                {
                    PreSym[SymbolLen] = ChLow;
                }
                if (SymbolLen < MAX_SYMBOL_LEN - 1)
                {
                    Symbol[SymbolLen++] = Ch;
                }
                m_Lex++;
            }
        }
        Ch = *m_Lex++;
        
        if (m_Flags & EXPRF_PREFER_SYMBOL_VALUES)
        {
            if (Ch == '.')
            {
                Symbol[SymbolLen++] = Ch;
                Ch = *m_Lex++;
            }
            else if (Ch == '-' && *m_Lex == '>')
            {
                Symbol[SymbolLen++] = Ch;
                Ch = *m_Lex++;
                Symbol[SymbolLen++] = Ch;
                Ch = *m_Lex++;
            }
        }
        ChLow = (CHAR)tolower(Ch);
    }

    // Back up pointer to first character after token.

    m_Lex--;

    if (SymbolLen < sizeof(PreSym))
    {
        PreSym[SymbolLen] = '\0';
    }

    if (g_Machine &&
        (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 ||
         g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64))
    {
        // Catch segment overrides.
        if (!ForceReg && Ch == ':')
        {
            for (Index = 0; Index < X86_SEGREGSIZE; Index++)
            {
                if (!strncmp(PreSym, g_X86SegRegs[Index], 2))
                {
                    ForceReg = TRUE;
                    IsSymbol = FALSE;
                    break;
                }
            }
        }
    }

    // If ForceReg, check for register name and return
    // success or failure.

    if (ForceReg)
    {
        return GetRegToken(PreSym, (PULONG64)RetValue);
    }

    // Test if number.

    if (IsNumber && !ErrNumber && IsDigit)
    {
        if (AllowSignExtension && !m_ForcePositiveNumber && 
            ((Value >> 32) == 0)) 
        {
            *RetValue = (LONG)Value;
        } 
        else 
        {
            *RetValue = Value;
        }
        return NUMBER_CLASS;
    }

    // Next test for reserved word and symbol string.

    if (IsSymbol && !ForceReg)
    {
        //  check lowercase string in PreSym for text operator
        //  or register name.
        //  otherwise, return symbol value from name in Symbol.

        if (!ForceSym && (SymbolLen == 2 || SymbolLen == 3))
        {
            for (Index = 0; Index < RESERVESIZE; Index++)
            {
                if (!strncmp(PreSym, g_Reserved[Index].chRes, 3))
                {
                    *RetValue = g_Reserved[Index].valueRes;
                    return g_Reserved[Index].classRes;
                }
            }
            if (g_Machine &&
                (g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_I386 ||
                 g_Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64))
            {
                for (Index = 0; Index < X86_RESERVESIZE; Index++)
                {
                    if (!strncmp(PreSym,
                                 g_X86Reserved[Index].chRes, 3))
                    {
                        *RetValue = g_X86Reserved[Index].valueRes;
                        return g_X86Reserved[Index].classRes;
                    }
                }
            }
        }

        // Start processing string as symbol.

        Symbol[SymbolLen] = '\0';

        // Test if symbol is a module name (followed by '!')
        // if so, get next token and treat as symbol.

        if (Peek() == '!')
        {
            // SymbolString holds the name of the symbol to be searched.
            // Symbol holds the symbol image file name.

            m_Lex++;
            Ch = Peek();
            m_Lex++;

            // Scan prefix if one is present.
            if (g_Machine != NULL &&
                g_Machine->m_SymPrefix != NULL &&
                Ch == g_Machine->m_SymPrefix[0] &&
                (g_Machine->m_SymPrefixLen == 1 ||
                 !strncmp(m_Lex, g_Machine->m_SymPrefix + 1,
                          g_Machine->m_SymPrefixLen - 1)))
            {
                SymbolLen = g_Machine->m_SymPrefixLen;
                memcpy(SymbolString, m_Lex - 1,
                       g_Machine->m_SymPrefixLen);
                m_Lex += g_Machine->m_SymPrefixLen - 1;
                Ch = *m_Lex++;
            }
            else
            {
                SymbolLen = 0;
            }
            
            while ((Ch >= 'A' && Ch <= 'Z') || (Ch >= 'a' && Ch <= 'z') ||
                   (Ch >= '0' && Ch <= '9') || (Ch == '_') || (Ch == '$') ||
                   (Ch == '`') || (Ch == '\'') ||
                   (Ch == ':' && *m_Lex == ':'))
            {
                SymbolString[SymbolLen++] = Ch;

                // Handle :: and ::~.
                if (Ch == ':')
                {
                    SymbolString[SymbolLen++] = Ch;
                    m_Lex++;
                    if (*m_Lex == '~')
                    {
                        SymbolString[SymbolLen++] = '~';
                        m_Lex++;
                    }
                }
                
                Ch = *m_Lex++;
                if (m_Flags & EXPRF_PREFER_SYMBOL_VALUES)
                {
                    if (Ch == '.')
                    {
                        SymbolString[SymbolLen++] = Ch;
                        Ch = *m_Lex++;
                    }
                    else if (Ch == '-' && *m_Lex == '>')
                    {
                        SymbolString[SymbolLen++] = Ch;
                        Ch = *m_Lex++;
                        SymbolString[SymbolLen++] = Ch;
                        Ch = *m_Lex++;
                    }
                }
            }
            SymbolString[SymbolLen] = '\0';
            m_Lex--;

            if (SymbolLen == 0)
            {
                *RetValue = SYNTAX;
                return ERROR_CLASS;
            }

            CatString(Symbol, "!", DIMA(Symbol));
            CatString(Symbol, SymbolString, DIMA(Symbol));

            SymClass = EvalSymbol(Symbol, &Value);
            if (SymClass != INVALID_CLASS)
            {
                *RetValue = Value;
                return SymClass;
            }
        }
        else
        {
            if (SymbolLen == 0)
            {
                *RetValue = SYNTAX;
                return ERROR_CLASS;
            }

            SymClass = EvalSymbol(Symbol, &Value);
            if (SymClass != INVALID_CLASS)
            {
                *RetValue = Value;
                return SymClass;
            }

            // Quick test for register names too
            if (!ForceSym &&
                (TmpValue = GetRegToken(PreSym,
                                        (PULONG64)RetValue)) != ERROR_CLASS)
            {
                return (ULONG)TmpValue;
            }
        }

        //
        // Symbol is undefined.
        // If a possible hex number, do not set the error type.
        //
        if (!IsNumber)
        {
            ErrNumber = VARDEF;
        }
    }

    //
    // Last chance, undefined symbol and illegal number,
    // so test for register, will handle old format.
    //
    
    if (!ForceSym &&
        (TmpValue = GetRegToken(PreSym,
                                (PULONG64)RetValue)) != ERROR_CLASS)
    {
        return (ULONG)TmpValue;
    }

    if (m_AllowUnresolvedSymbols)
    {
        m_NumUnresolvedSymbols++;
        *RetValue = 0;
        Type(m_TempAddr) = ADDR_FLAT | FLAT_COMPUTED;
        Flat(m_TempAddr) = Off(m_TempAddr) = *RetValue;
        m_AddrExprType = Type(m_TempAddr);
        return SYMBOL_CLASS;
    }

    //
    // No success, so set error message and return.
    //
    *RetValue = (ULONG64)ErrNumber;
    return ERROR_CLASS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ee_cpp.cpp ===
//----------------------------------------------------------------------------
//
// C++ source expression evaluation.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#define DBG_TOKENS 0
#define DBG_TYPES 0

//----------------------------------------------------------------------------
//
// CppEvalExpression.
//
//----------------------------------------------------------------------------

char CppEvalExpression::s_EscapeChars[] = "?afvbntr\"'\\";
char CppEvalExpression::s_EscapeCharValues[] = "?\a\f\v\b\n\t\r\"'\\";

PCSTR CppEvalExpression::s_MultiTokens[] =
{
    "EOF",
    "identifier",
    "integer literal",
    "floating-point literal",
    "char string literal",
    "char literal",
    "wchar string literal",
    "wchar literal",
    "debugger register",
    "module name",
    "MASM expression",
    "Preprocessor function",
    "==",
    "!=",
    "<=",
    ">=",
    "&&",
    "||",
    "U+",
    "U-",
    "<<",
    ">>",
    "address of",
    "dereference",
    "->",
    ".*",
    "->*",
    "/=",
    "*=",
    "%=",
    "+=",
    "-=",
    "<<=",
    ">>=",
    "&=",
    "|=",
    "^=",
    "++",
    "--",
    "++",
    "--",
    "::",
    "::~",
    "sizeof",
    "this",
    "operator",
    "new",
    "delete",
    "const",
    "struct",
    "class",
    "union",
    "enum",
    "volatile",
    "signed",
    "unsigned",
    "dynamic_cast",
    "static_cast",
    "const_cast",
    "reinterpret_cast",
    "typeid",
};

CppEvalExpression::CppEvalExpression(void)
    : EvalExpression(DEBUG_EXPR_CPLUSPLUS,
                     "C++ source expressions",
                     "C++")
{
    m_PreprocEval = FALSE;
}

CppEvalExpression::~CppEvalExpression(void)
{
}

PCSTR
CppEvalExpression::TokenImage(CppToken Token)
{
#define TOKIM_CHARS 8
    static char s_CharImage[2 * TOKIM_CHARS];
    static int s_CharImageIdx = 0;

    C_ASSERT(DIMA(s_MultiTokens) == CppTokenCount - CPP_TOKEN_MULTI);

    if (Token <= CppTokenError || Token >= CppTokenCount)
    {
        return NULL;
    }
    else if (Token < CPP_TOKEN_MULTI)
    {
        PSTR Image;

        Image = s_CharImage + s_CharImageIdx;
        s_CharImageIdx += 2;
        if (s_CharImageIdx >= sizeof(s_CharImage))
        {
            s_CharImageIdx = 0;
        }
        Image[0] = (char)Token;
        Image[1] = 0;
        return Image;
    }
    else
    {
        return s_MultiTokens[Token - CPP_TOKEN_MULTI];
    }
}

char
CppEvalExpression::GetStringChar(PBOOL Escaped)
{
    char Ch;
    PSTR Esc;
    int V;

    *Escaped = FALSE;
    
    Ch = *m_Lex++;
    if (!Ch)
    {
        m_Lex--;
        EvalErrorDesc(SYNTAX, "EOF in literal");
    }
    else if (Ch == '\n' || Ch == '\r')
    {
        m_Lex--;
        EvalErrorDesc(SYNTAX, "Newline in literal");
    }
    else if (Ch == '\\')
    {
        *Escaped = TRUE;
        
        Ch = *m_Lex++;
        if (!Ch)
        {
            EvalErrorDesc(SYNTAX, "EOF in literal");
        }
        else if (Ch == 'x')
        {
            // Hex character literal.
            
            V = 0;
            for (;;)
            {
                Ch = *m_Lex++;
                if (!isxdigit(Ch))
                {
                    break;
                }
                
                if (isupper(Ch))
                {
                    Ch = (char)tolower(Ch);
                }
                
                V = V * 16 + (Ch >= 'a' ? Ch - 'a' + 10 : Ch - '0');
            }

            m_Lex--;
            Ch = (char)V;
        }
        else if (IS_OCTAL_DIGIT(Ch))
        {
            // Octal character literal.
            
            V = 0;
            do
            {
                V = V * 8 + Ch - '0';
                Ch = *m_Lex++;
            } while (IS_OCTAL_DIGIT(Ch));
            
            m_Lex--;
            Ch = (char)V;
        }
        else
        {
            Esc = strchr(s_EscapeChars, Ch);
            if (Esc == NULL)
            {
                EvalErrorDesc(SYNTAX, "Unknown escape character");
            }
            else
            {
                Ch = s_EscapeCharValues[Esc - s_EscapeChars];
            }
        }
    }
    
    return Ch;
}

void
CppEvalExpression::FinishFloat(LONG64 IntPart, int Sign)
{
    double Val = (double)IntPart;
    double Frac = 1;
    char Ch;

    Ch = *(m_Lex - 1);
    if (Ch == '.')
    {
        for (;;)
        {
            Ch = *m_Lex++;
            if (!isdigit(Ch))
            {
                break;
            }
            
            Frac /= 10;
            Val += ((int)Ch - (int)'0') * Frac;
            AddLexeme(Ch);
        }
    }
    
    if (Ch == 'e' || Ch == 'E')
    {
        long Power = 0;
        BOOL Neg = FALSE;
        
        Ch = *m_Lex++;
        if (Ch == '-' || Ch == '+')
        {
            AddLexeme(Ch);
            if (Ch == '-')
            {
                Neg = TRUE;
            }
            Ch = *m_Lex++;
        }
        
        while (isdigit(Ch))
        {
            AddLexeme(Ch);
            Power = Power * 10 + Ch - '0';
            Ch = *m_Lex++;
        }
        
        if (Neg)
        {
            Power = -Power;
        }
        
        Val *= pow(10.0, Power);
    }

    m_Lex--;

    BOOL Long = FALSE;
    BOOL Float = FALSE;

    for (;;)
    {
        if (*m_Lex == 'f' || *m_Lex == 'F')
        {
            Float = TRUE;
            AddLexeme(*m_Lex++);
        }
        else if (*m_Lex == 'l' || *m_Lex == 'L')
        {
            Long = TRUE;
            AddLexeme(*m_Lex++);
        }
        else
        {
            break;
        }
    }
    
    ZeroMemory(&m_TokenValue, sizeof(m_TokenValue));
    if (Long || !Float)
    {
        m_TokenValue.m_BaseType = DNTYPE_FLOAT64;
        m_TokenValue.m_F64 = Val * Sign;
    }
    else
    {
        m_TokenValue.m_BaseType = DNTYPE_FLOAT32;
        m_TokenValue.m_F32 = (float)(Val * Sign);
    }
    
    AddLexeme(0);
    m_TokenValue.SetToNativeType(m_TokenValue.m_BaseType);
}

CppToken
CppEvalExpression::ReadNumber(int Sign)
{
    ULONG64 IntVal;
    char Ch, Nch;
    BOOL Decimal = FALSE;

    //
    // Many number outputs use ` as a separator between
    // the high and low parts of a 64-bit number.  Ignore
    // ` here to make it simple to use such values.
    //
    
    Ch = *(m_Lex - 1);
    Nch = *m_Lex++;
    if (Ch != '0' ||
        (Nch != 'x' && Nch != 'X' && !IS_OCTAL_DIGIT(Nch)))
    {
        IntVal = Ch - '0';
        Ch = Nch;
        while (isdigit(Ch) || Ch == '`')
        {
            if (Ch != '`')
            {
                IntVal = IntVal * 10 + (Ch - '0');
            }
            AddLexeme(Ch);
            Ch = *m_Lex++;
        }
                
        if (Ch == '.' || Ch == 'e' || Ch == 'E' || Ch == 'f' || Ch == 'F')
        {
            AddLexeme(Ch);
            FinishFloat((LONG64)IntVal, Sign);
            return CppTokenFloat;
        }

        Decimal = TRUE;
    }
    else
    {
        Ch = Nch;
        IntVal = 0;
        if (Ch == 'x' || Ch == 'X')
        {
            AddLexeme(Ch);
            for (;;)
            {
                Ch = *m_Lex++;
                if (!isxdigit(Ch) && Ch != '`')
                {
                    break;
                }

                AddLexeme(Ch);
                if (Ch == '`')
                {
                    continue;
                }
                
                if (isupper(Ch))
                {
                    Ch = (char)tolower(Ch);
                }
                IntVal = IntVal * 16 + (Ch >= 'a' ? Ch - 'a' + 10 : Ch - '0');
            }
        }
        else if (IS_OCTAL_DIGIT(Ch))
        {
            do
            {
                AddLexeme(Ch);
                if (Ch != '`')
                {
                    IntVal = IntVal * 8 + (Ch - '0');
                }
                Ch = *m_Lex++;
            }
            while (IS_OCTAL_DIGIT(Ch) || Ch == '`');
        }
    }

    m_Lex--;

    BOOL Unsigned = FALSE, I64 = FALSE;
    
    for (;;)
    {
        if (*m_Lex == 'l' || *m_Lex == 'L')
        {
            AddLexeme(*m_Lex++);
        }
        else if ((*m_Lex == 'i' || *m_Lex == 'I') &&
                 *(m_Lex + 1) == '6' && *(m_Lex + 2) == '4')
        {
            AddLexeme(*m_Lex++);
            AddLexeme(*m_Lex++);
            AddLexeme(*m_Lex++);
            I64 = TRUE;
        }
        else if (*m_Lex == 'u' || *m_Lex == 'U')
        {
            AddLexeme(*m_Lex++);
            Unsigned = TRUE;
        }
        else
        {
            break;
        }
    }

    AddLexeme(0);
    ZeroMemory(&m_TokenValue, sizeof(m_TokenValue));

    // Constants are given the smallest type which can contain
    // their value.
    if (!Unsigned)
    {
        if (I64)
        {
            if (IntVal >= 0x8000000000000000)
            {
                // Value has to be an unsigned int64.
                m_TokenValue.m_BaseType = DNTYPE_UINT64;
            }
            else
            {
                m_TokenValue.m_BaseType = DNTYPE_INT64;
            }
        }
        else
        {
            if (IntVal >= 0x8000000000000000)
            {
                // Value has to be an unsigned int64.
                m_TokenValue.m_BaseType = DNTYPE_UINT64;
            }
            else if ((Decimal && IntVal >= 0x80000000) ||
                     (!Decimal && IntVal >= 0x100000000))
            {
                // Value has to be an int64.
                m_TokenValue.m_BaseType = DNTYPE_INT64;
            }
            else if (IntVal >= 0x80000000)
            {
                // Value has to be an unsigned int.
                m_TokenValue.m_BaseType = DNTYPE_UINT32;
            }
            else
            {
                m_TokenValue.m_BaseType = DNTYPE_INT32;
            }
        }
    }
    else if (!I64)
    {
        if (IntVal >= 0x100000000)
        {
            // Value has to be an unsigned int64.
            m_TokenValue.m_BaseType = DNTYPE_UINT64;
        }
        else
        {
            m_TokenValue.m_BaseType = DNTYPE_UINT32;
        }
    }
    else
    {
        m_TokenValue.m_BaseType = DNTYPE_UINT64;
    }
    
    m_TokenValue.SetToNativeType(m_TokenValue.m_BaseType);
    m_TokenValue.m_S64 = (LONG64)IntVal * Sign;
    return CppTokenInteger;
}

CppToken
CppEvalExpression::Lex(void)
{
    char Ch, Nch, Tch;
    PSTR Single;
    BOOL UnaryOp;
    BOOL CharToken;
    BOOL Escaped;

    UnaryOp = m_AllowUnaryOp;
    m_AllowUnaryOp = TRUE;
    
    for (;;)
    {
        for (;;)
        {
            Ch = *m_Lex++;
            if (IS_EOF(Ch))
            {
                m_Lex--;
                StartLexeme();
                m_LexemeSourceStart = m_Lex;
                AddLexeme(0);
                return CppTokenEof;
            }

            if (!isspace(Ch))
            {
                break;
            }
        }

        StartLexeme();
        m_LexemeSourceStart = m_Lex - 1;
        AddLexeme(Ch);

        Nch = *m_Lex;
        
        /* String literals */
        if (Ch == '\"' ||
            (Ch == 'L' && Nch == '\"'))
        {
            BOOL Wide = FALSE;
            
            if (Ch == 'L')
            {
                m_Lex++;
                Wide = TRUE;
            }
            
            // Store the translated literal in
            // the lexeme rather than the source text to
            // avoid having two large buffers where one is
            // only used for string literals.  This means
            // the lexeme isn't really the source text but
            // that's not a problem for now or the forseeable
            // future.
            m_LexemeChar--;
            for (;;)
            {
                AddLexeme(GetStringChar(&Escaped));
                if (!Escaped &&
                    (*(m_LexemeChar - 1) == 0 || *(m_LexemeChar - 1) == '\"'))
                {
                    break;
                }
            }
            *(m_LexemeChar - 1) = 0;

            m_AllowUnaryOp = FALSE;
            return Wide ? CppTokenWcharString : CppTokenCharString;
        }
            
        /* Character literals */
        if (Ch == '\'' ||
            (Ch == 'L' && Nch == '\''))
        {
            BOOL Wide = FALSE;
            
            if (Ch == 'L')
            {
                AddLexeme(Nch);
                m_Lex++;
                Wide = TRUE;
            }

            int Chars = 0;
            ZeroMemory(&m_TokenValue, sizeof(m_TokenValue));

            for (;;)
            {
                Ch = GetStringChar(&Escaped);
                AddLexeme(Ch);
                if (!Escaped && Ch == '\'')
                {
                    if (Chars == 0)
                    {
                        EvalError(SYNTAX);
                    }
                    break;
                }

                if (++Chars > 8)
                {
                    EvalError(OVERFLOW);
                }
                
                m_TokenValue.m_S64 = (m_TokenValue.m_S64 << 8) + Ch;
            }
            AddLexeme(0);
            
            switch(Chars)
            {
            case 1:
                if (Wide)
                {
                    m_TokenValue.SetToNativeType(DNTYPE_WCHAR_T);
                }
                else
                {
                    m_TokenValue.SetToNativeType(DNTYPE_CHAR);
                }
                break;
            case 2:
                m_TokenValue.SetToNativeType(DNTYPE_INT16);
                break;
            case 3:
            case 4:
                m_TokenValue.SetToNativeType(DNTYPE_INT32);
            case 5:
            case 6:
            case 7:
            case 8:
                m_TokenValue.SetToNativeType(DNTYPE_INT64);
                break;
            }

            m_AllowUnaryOp = FALSE;
            return Wide ? CppTokenWchar : CppTokenChar;
        }
        
        /* Identifiers */
        if (isalpha(Ch) || Ch == '_')
        {
            int KwToken;
            
            for (;;)
            {
                Ch = *m_Lex++;
                if (!isalnum(Ch) && Ch != '_')
                {
                    break;
                }

                AddLexeme(Ch);
            }

            m_Lex--;
            AddLexeme(0);
            m_AllowUnaryOp = FALSE;

            for (KwToken = CPP_KEYWORD_FIRST;
                 KwToken <= CPP_KEYWORD_LAST;
                 KwToken++)
            {
                if (!strcmp(m_LexemeStart,
                            s_MultiTokens[KwToken - CPP_TOKEN_MULTI]))
                {
                    return (CppToken)KwToken;
                }
            }

            return CppTokenIdentifier;
        }

        // For some reason the compiler emits symbols with
        // sections between ` and '.  There only seem to be
        // normal characters in between them so it's unclear
        // why this is done, but allow it as a special
        // form of identifier.
        if (Ch == '`')
        {
            for (;;)
            {
                Ch = *m_Lex++;
                if (!Ch)
                {
                    EvalError(SYNTAX);
                }

                AddLexeme(Ch);
                if (Ch == '\'')
                {
                    break;
                }
            }

            AddLexeme(0);
            m_AllowUnaryOp = FALSE;

            return CppTokenIdentifier;
        }
        
        /* Numeric literals */
        if (isdigit(Ch))
        {
            m_AllowUnaryOp = FALSE;
            return ReadNumber(1);
        }
        
        /* Handle .[digits] floating-point literals */
        if (Ch == '.')
        {
            if (isdigit(Nch))
            {
                FinishFloat(0, 1);
                m_AllowUnaryOp = FALSE;
                return CppTokenFloat;
            }
            else
            {
                AddLexeme(0);
                return CppTokenPeriod;
            }
        }
        
        /* Unambiguous single character tokens that allow unary */
        if (Single = strchr("({}[;,?~.", Ch))
        {
            AddLexeme(0);
            return (CppToken)*Single;
        }
        
        /* Unambiguous single character tokens that disallow unary */
        if (Single = strchr(")]", Ch))
        {
            AddLexeme(0);
            m_AllowUnaryOp = FALSE;
            return (CppToken)*Single;
        }
        
        /* All other characters */
        Nch = *m_Lex++;
        CharToken = TRUE;
        switch(Ch)
        {
            /* Comments, / and /= */
        case '/':
            if (Nch == '*')
            {
                for (;;)
                {
                    Ch = *m_Lex++;
                CheckChar:
                    if (!Ch)
                    {
                        break;
                    }
                    else if (Ch == '*')
                    {
                        if ((Ch = *m_Lex++) == '/')
                        {
                            break;
                        }
                        else
                        {
                            goto CheckChar;
                        }
                    }
                }
                
                if (!Ch)
                {
                    EvalErrorDesc(SYNTAX, "EOF in comment");
                }
                
                CharToken = FALSE;
            }
            else if (Nch == '/')
            {
                while ((Ch = *m_Lex++) != '\n' && !IS_EOF(Ch))
                {
                    // Iterate.
                }

                if (IS_EOF(Ch))
                {
                    // IS_EOF includes EOL so EOF is not an error,
                    // just back up to the EOL.
                    m_Lex--;
                }
                
                CharToken = FALSE;
            }
            else if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenDivideAssign;
            }
            break;

            /* :, :: and ::~ */
        case ':':
            if (Nch == ':')
            {
                AddLexeme(Nch);
                Tch = *m_Lex++;
                if (Tch == '~')
                {
                    AddLexeme(Tch);
                    AddLexeme(0);
                    return CppTokenDestructor;
                }
                AddLexeme(0);
                m_Lex--;
                return CppTokenNameQualifier;
            }
            break;
                
            /* *, *= and dereference */
        case '*':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenMultiplyAssign;
            }
            else if (UnaryOp)
            {
                AddLexeme(0);
                m_Lex--;
                return CppTokenDereference;
            }
            break;

            /* % and %= */
        case '%':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenModuloAssign;
            }
            break;
            
            /* = and == */
        case '=':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenEqual;
            }
            break;
            
            /* ! and != */
        case '!':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenNotEqual;
            }
            break;
            
            /* <, <<, <<= and <= */
        case '<':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenLessEqual;
            }
            else if (Nch == '<')
            {
                AddLexeme(Nch);
                Tch = *m_Lex++;
                if (Tch == '=')
                {
                    AddLexeme(Tch);
                    AddLexeme(0);
                    return CppTokenLeftShiftAssign;
                }
                AddLexeme(0);
                m_Lex--;
                return CppTokenLeftShift;
            }
            break;

            /* >, >>, >>= and >= */
        case '>':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenGreaterEqual;
            }
            else if (Nch == '>')
            {
                AddLexeme(Nch);
                Tch = *m_Lex++;
                if (Tch == '=')
                {
                    AddLexeme(Tch);
                    AddLexeme(0);
                    return CppTokenRightShiftAssign;
                }
                AddLexeme(0);
                m_Lex--;
                return CppTokenRightShift;
            }
            break;

            /* &, &= and && */
        case '&':
            if (Nch == '&')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenLogicalAnd;
            }
            else if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenAndAssign;
            }
            else if (UnaryOp)
            {
                AddLexeme(0);
                m_Lex--;
                return CppTokenAddressOf;
            }
            break;

            /* |, |= and || */
        case '|':
            if (Nch == '|')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenLogicalOr;
            }
            else if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenOrAssign;
            }
            break;

            /* ^ and ^= */
        case '^':
            if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenExclusiveOrAssign;
            }
            break;
            
            /* U+, +, ++X, X++ and += */
        case '+':
            if (Nch == '+')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                if (UnaryOp)
                {
                    return CppTokenPreIncrement;
                }
                else
                {
                    m_AllowUnaryOp = FALSE;
                    return CppTokenPostIncrement;
                }
            }
            else if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenAddAssign;
            }
            else if (UnaryOp)
            {
                if (isdigit(Nch))
                {
                    AddLexeme(Nch);
                    m_AllowUnaryOp = FALSE;
                    return ReadNumber(1);
                }
                else
                {
                    AddLexeme(0);
                    m_Lex--;
                    return CppTokenUnaryPlus;
                }
            }
            break;
            
            /* U-, -, --, -> and -= */
        case '-':
            if (Nch == '-')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                if (UnaryOp)
                {
                    return CppTokenPreDecrement;
                }
                else
                {
                    m_AllowUnaryOp = FALSE;
                    return CppTokenPostDecrement;
                }
            }
            else if (Nch == '=')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenSubtractAssign;
            }
            else if (Nch == '>')
            {
                AddLexeme(Nch);
                AddLexeme(0);
                return CppTokenPointerMember;
            }
            else if (UnaryOp)
            {
                if (isdigit(Nch))
                {
                    AddLexeme(Nch);
                    m_AllowUnaryOp = FALSE;
                    return ReadNumber(-1);
                }
                else
                {
                    AddLexeme(0);
                    m_Lex--;
                    return CppTokenUnaryMinus;
                }
            }
            break;

            /* Special character prefix for debugger registers
               and alternate evaluator expressions */
        case '@':
            if (Nch == '@')
            {
                ULONG Parens = 1;
                PSTR Name;

                AddLexeme(Nch);

                //
                // Look for an optional evaluator name.
                //
                
                Name = m_LexemeChar;
                while (*m_Lex != '(' && *m_Lex != ';' && *m_Lex)
                {
                    AddLexeme(*m_Lex++);
                }
                if (Name != m_LexemeChar)
                {
                    EvalExpression* Eval;
                    
                    // Name was given, identify the evaluator
                    // and remember the evaluator syntax.
                    AddLexeme(0);
                    GetEvaluatorByName(Name, FALSE, &Eval);
                    m_SwitchEvalSyntax = Eval->m_Syntax;
                    ReleaseEvaluator(Eval);
                    
                    // Back up to overwrite the terminator.
                    m_LexemeChar--;
                }
                else
                {
                    // No name given, default to MASM.
                    m_SwitchEvalSyntax = DEBUG_EXPR_MASM;
                }
                
                AddLexeme('(');
                m_Lex++;
                
                // Collect expression text to a balanced paren.
                for (;;)
                {
                    if (!*m_Lex)
                    {
                        EvalErrorDesc(SYNTAX,
                                      "EOF in alternate evaluator expression");
                    }
                    else if (*m_Lex == '(')
                    {
                        Parens++;
                    }
                    else if (*m_Lex == ')' && --Parens == 0)
                    {
                        break;
                    }

                    AddLexeme(*m_Lex++);
                }

                m_Lex++;
                AddLexeme(')');
                AddLexeme(0);
                m_AllowUnaryOp = FALSE;
                return CppTokenSwitchEvalExpression;
            }
            else
            {
                if (Nch == '!')
                {
                    AddLexeme(Nch);
                    Nch = *m_Lex++;
                }
                
                while (isalnum(Nch) || Nch == '_' || Nch == '$')
                {
                    AddLexeme(Nch);
                    Nch = *m_Lex++;
                }
                AddLexeme(0);
                m_Lex--;
                m_AllowUnaryOp = FALSE;
                return m_LexemeStart[1] == '!' ?
                    CppTokenModule : CppTokenDebugRegister;
            }
            
            /* Special character prefix for built-in
               equivalents to common preprocessor macros */
        case '#':
            m_Lex--;
            while (isalnum(*m_Lex) || *m_Lex == '_')
            {
                AddLexeme(*m_Lex++);
            }
            AddLexeme(0);
            m_AllowUnaryOp = FALSE;
            return CppTokenPreprocFunction;

        default:
            m_Lex--;
            EvalErrorDesc(SYNTAX, "Unexpected character in");
            CharToken = FALSE;
            break;
        }
        
        if (CharToken)
        {
            m_Lex--;
            AddLexeme(0);
            return (CppToken)Ch;
        }
    }

    DBG_ASSERT(!"Abnormal exit in CppLex");
    return CppTokenError;
}

void
CppEvalExpression::NextToken(void)
{
    m_Token = Lex();
    
#if DBG_TOKENS
    dprintf("Token is %s (%s)\n", TokenImage(m_Token), m_LexemeStart);
#endif
}

void
CppEvalExpression::Match(CppToken Token)
{
    if (m_Token != Token)
    {
        EvalErrorDesc(SYNTAX, "Unexpected token");
    }

    NextToken();
}

PCSTR
CppEvalExpression::Evaluate(PCSTR Expr, PCSTR Desc, ULONG Flags,
                            TypedData* Result)
{
    Start(Expr, Desc, Flags);
    NextToken();

    if (m_Flags & EXPRF_SINGLE_TERM)
    {
        Match(CppTokenOpenBracket);
        Expression(Result);
        Match(CppTokenCloseBracket);
    }
    else
    {
        Expression(Result);
    }
    
    End(Result);
    
    return m_LexemeSourceStart;
}

PCSTR
CppEvalExpression::EvaluateAddr(PCSTR Expr, PCSTR Desc,
                                ULONG SegReg, PADDR Addr)
{
    // This result must be on the stack so it
    // isn't caught by the empty-allocator check in end.
    TypedData Result;
    
    Start(Expr, Desc, EXPRF_DEFAULT);
    NextToken();
    Expression(&Result);
    End(&Result);

    EvalCheck(Result.ConvertToU64());
    ADDRFLAT(Addr, Result.m_U64);
    
    return m_LexemeSourceStart;
}

void
CppEvalExpression::Expression(TypedData* Result)
{
    for (;;)
    {
        Assignment(Result);

        if (m_Token == CppTokenComma)
        {
            Accept();
        }
        else
        {
            break;
        }
    }
}

void
CppEvalExpression::Assignment(TypedData* Result)
{
    TypedDataOp Op;
    
    Conditional(Result);

    switch(m_Token)
    {
    case '=':
        Op = TDOP_ASSIGN;
        break;
    case CppTokenDivideAssign:
        Op = TDOP_DIVIDE;
        break;
    case CppTokenMultiplyAssign:
        Op = TDOP_MULTIPLY;
        break;
    case CppTokenModuloAssign:
        Op = TDOP_REMAINDER;
        break;
    case CppTokenAddAssign:
        Op = TDOP_ADD;
        break;
    case CppTokenSubtractAssign:
        Op = TDOP_SUBTRACT;
        break;
    case CppTokenLeftShiftAssign:
        Op = TDOP_LEFT_SHIFT;
        break;
    case CppTokenRightShiftAssign:
        Op = TDOP_RIGHT_SHIFT;
        break;
    case CppTokenAndAssign:
        Op = TDOP_BIT_AND;
        break;
    case CppTokenOrAssign:
        Op = TDOP_BIT_OR;
        break;
    case CppTokenExclusiveOrAssign:
        Op = TDOP_BIT_XOR;
        break;
    default:
        return;
    }

    if (!Result->IsWritable())
    {
        EvalError(TYPECONFLICT);
    }
        
    Accept();

    TypedData* Next = NewResult();
    Assignment(Next);
    
    switch(Op)
    {
    case TDOP_ASSIGN:
        m_Tmp = *Next;
        EvalCheck(m_Tmp.ConvertToSource(Result));
        break;
    case TDOP_ADD:
    case TDOP_SUBTRACT:
    case TDOP_MULTIPLY:
    case TDOP_DIVIDE:
    case TDOP_REMAINDER:
        // Carry out the operation in a temporary as the
        // address will be wiped out by the operation.
        m_Tmp = *Result;
        EvalCheck(m_Tmp.BinaryArithmetic(Next, Op));
        // The result may be of a different type due
        // to promotions or other implicit conversions.
        // Force conversion to the actual result type.
        EvalCheck(m_Tmp.ConvertTo(Result));
        break;
    case TDOP_LEFT_SHIFT:
    case TDOP_RIGHT_SHIFT:
        m_Tmp = *Result;
        EvalCheck(m_Tmp.Shift(Next, Op));
        EvalCheck(m_Tmp.ConvertTo(Result));
        break;
    case TDOP_BIT_OR:
    case TDOP_BIT_XOR:
    case TDOP_BIT_AND:
        m_Tmp = *Result;
        EvalCheck(m_Tmp.BinaryBitwise(Next, Op));
        EvalCheck(m_Tmp.ConvertTo(Result));
        break;
    }

    // Source and destination types should be compatible
    // at this point to copy the data.
    EvalCheck(Result->WriteData(&m_Tmp, CurrentAccess()));
    Result->CopyData(&m_Tmp);

    DelResult(Next);
}

void
CppEvalExpression::Conditional(TypedData* Result)
{
    TypedData* Discard;
    TypedData* Left, *Right;
    
    LogicalOr(Result);
    if (m_Token != CppTokenQuestionMark)
    {
        return;
    }

    EvalCheck(Result->ConvertToBool());
    Accept();

    Discard = NewResult();
    if (Result->m_Bool)
    {
        Left = Result;
        Right = Discard;
    }
    else
    {
        Left = Discard;
        Right = Result;
        m_ParseOnly++;
    }

    Expression(Left);
    Match(CppTokenColon);

    if (Right == Discard)
    {
        m_ParseOnly++;
    }
    else
    {
        m_ParseOnly--;
    }

    Conditional(Right);

    if (Right == Discard)
    {
        m_ParseOnly--;
    }

    DelResult(Discard);
}

void
CppEvalExpression::LogicalOr(TypedData* Result)
{
    LogicalAnd(Result);
    for (;;)
    {
        TypedData* Next;

        switch(m_Token)
        {
        case CppTokenLogicalOr:
            EvalCheck(Result->ConvertToBool());
            Accept();
            if (Result->m_Bool)
            {
                m_ParseOnly++;
            }
            Next = NewResult();
            LogicalAnd(Next);
            EvalCheck(Next->ConvertToBool());
            if (Result->m_Bool)
            {
                m_ParseOnly--;
            }
            else
            {
                Result->m_Bool = Result->m_Bool || Next->m_Bool;
            }
            DelResult(Next);
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::LogicalAnd(TypedData* Result)
{
    BitwiseOr(Result);
    for (;;)
    {
        TypedData* Next;

        switch(m_Token)
        {
        case CppTokenLogicalAnd:
            EvalCheck(Result->ConvertToBool());
            Accept();
            if (!Result->m_Bool)
            {
                m_ParseOnly++;
            }
            Next = NewResult();
            BitwiseOr(Next);
            EvalCheck(Next->ConvertToBool());
            if (!Result->m_Bool)
            {
                m_ParseOnly--;
            }
            else
            {
                Result->m_Bool = Result->m_Bool && Next->m_Bool;
            }
            DelResult(Next);
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::BitwiseOr(TypedData* Result)
{
    BitwiseXor(Result);
    for (;;)
    {
        TypedData* Next;

        switch(m_Token)
        {
        case '|':
            Accept();
            Next = NewResult();
            BitwiseXor(Next);
            EvalCheck(Result->BinaryBitwise(Next, TDOP_BIT_OR));
            DelResult(Next);
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::BitwiseXor(TypedData* Result)
{
    BitwiseAnd(Result);
    for (;;)
    {
        TypedData* Next;

        switch(m_Token)
        {
        case '^':
            Accept();
            Next = NewResult();
            BitwiseAnd(Next);
            EvalCheck(Result->BinaryBitwise(Next, TDOP_BIT_XOR));
            DelResult(Next);
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::BitwiseAnd(TypedData* Result)
{
    Equality(Result);
    for (;;)
    {
        TypedData* Next;

        switch(m_Token)
        {
        case '&':
            Accept();
            Next = NewResult();
            Equality(Next);
            EvalCheck(Result->BinaryBitwise(Next, TDOP_BIT_AND));
            DelResult(Next);
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::Equality(TypedData* Result)
{
    Relational(Result);
    for (;;)
    {
        TypedDataOp Op;

        switch(m_Token)
        {
        case CppTokenEqual:
            Op = TDOP_EQUAL;
            break;
        case CppTokenNotEqual:
            Op = TDOP_NOT_EQUAL;
            break;
        default:
            return;
        }

        Accept();

        TypedData* Next = NewResult();
        Relational(Next);
        EvalCheck(Result->Relate(Next, Op));
        DelResult(Next);
    }
}

void
CppEvalExpression::Relational(TypedData* Result)
{
    Shift(Result);
    for (;;)
    {
        TypedDataOp Op;

        switch(m_Token)
        {
        case '<':
            Op = TDOP_LESS;
            break;
        case '>':
            Op = TDOP_GREATER;
            break;
        case CppTokenLessEqual:
            Op = TDOP_LESS_EQUAL;
            break;
        case CppTokenGreaterEqual:
            Op = TDOP_GREATER_EQUAL;
            break;
        default:
            return;
        }
        
        Accept();

        TypedData* Next = NewResult();
        Shift(Next);
        EvalCheck(Result->Relate(Next, Op));
        DelResult(Next);
    }
}

void
CppEvalExpression::Shift(TypedData* Result)
{
    Additive(Result);
    for (;;)
    {
        TypedDataOp Op;

        switch(m_Token)
        {
        case CppTokenLeftShift:
            Op = TDOP_LEFT_SHIFT;
            break;
        case CppTokenRightShift:
            Op = TDOP_RIGHT_SHIFT;
            break;
        default:
            return;
        }
        
        Accept();

        TypedData* Next = NewResult();
        Additive(Next);
        EvalCheck(Result->Shift(Next, Op));
        DelResult(Next);
    }
}

void
CppEvalExpression::Additive(TypedData* Result)
{
    Multiplicative(Result);
    for (;;)
    {
        TypedDataOp Op;
    
        switch(m_Token)
        {
        case '+':
            Op = TDOP_ADD;
            break;
        case '-':
            Op = TDOP_SUBTRACT;
            break;
        default:
            return;
        }
        
        Accept();

        TypedData* Next = NewResult();
        Multiplicative(Next);
        EvalCheck(Result->BinaryArithmetic(Next, Op));
        DelResult(Next);
    }
}

void
CppEvalExpression::Multiplicative(TypedData* Result)
{
    ClassMemberRef(Result);
    for (;;)
    {
        TypedDataOp Op;

        switch(m_Token)
        {
        case '*':
            Op = TDOP_MULTIPLY;
            break;
        case '/':
            Op = TDOP_DIVIDE;
            break;
        case '%':
            Op = TDOP_REMAINDER;
            break;
        default:
            return;
        }
        
        Accept();

        TypedData* Next = NewResult();
        ClassMemberRef(Next);
        EvalCheck(Result->BinaryArithmetic(Next, Op));
        DelResult(Next);
    }
}

void
CppEvalExpression::ClassMemberRef(TypedData* Result)
{
    Cast(Result);
    for (;;)
    {
        //
        // Calling through pointers to members isn't
        // supported, just as normal function calls
        // aren't supported.  We could potentially
        // determine the actual method value for
        // simple references to methods but there's
        // virtual no need for that, so just fail
        // these constructs.
        //
        
        switch(m_Token)
        {
        case CppTokenClassDereference:
        case CppTokenClassPointerMember:
            EvalErrorDesc(UNIMPLEMENT,
                          "Pointer to member evaluation is not supported");
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::Cast(TypedData* Result)
{
    if (m_Token == '(')
    {
        PCSTR LexRestart = m_Lex;
        
        Accept();
        if (TryTypeName(Result) == ERES_TYPE)
        {
            //
            // It was a type name, so process the cast.
            //
            
            TypedData* CastType = NewResult();
            *CastType = *Result;
            // Unary is allowed after a cast.
            m_AllowUnaryOp = TRUE;
            Match(CppTokenCloseParen);
            Cast(Result);
            EvalCheck(Result->CastTo(CastType));
            DelResult(CastType);
            return;
        }
        else
        {
            // It wasn't a type, so restart the lexer
            // and reparse as an expression.
            StartLexer(LexRestart);
            strcpy(m_LexemeStart, "(");
            m_Token = CppTokenOpenParen;
        }
    }

    Unary(Result);
}

void
CppEvalExpression::Unary(TypedData* Result)
{
    CppToken Op = m_Token;
    switch(Op)
    {
    case CppTokenSizeof:
        Accept();
        if (m_Token == '(')
        {
            PCSTR LexRestart = m_Lex;
            Accept();
            if (TryTypeName(Result) == ERES_TYPE)
            {
                // It was a type name.
                Match(CppTokenCloseParen);
            }
            else
            {
                // It wasn't a type, so restart the lexer
                // and reparse as an expression.
                StartLexer(LexRestart);
                strcpy(m_LexemeStart, "(");
                m_Token = CppTokenOpenParen;
                Unary(Result);
            }
        }
        else
        {
            Unary(Result);
        }
        Result->m_U64 = Result->m_BaseSize;
        Result->SetToNativeType(m_PtrSize == sizeof(ULONG64) ?
                                DNTYPE_UINT64 : DNTYPE_UINT32);
        break;
    case CppTokenUnaryPlus:
    case CppTokenUnaryMinus:
    case '~':
        Accept();
        Cast(Result);
        if (Op == CppTokenUnaryPlus)
        {
            // Nothing to do.
            break;
        }
        EvalCheck(Result->Unary(Op == CppTokenUnaryMinus ?
                                TDOP_NEGATE : TDOP_BIT_NOT));
        break;
    case '!':
        Accept();
        Cast(Result);
        EvalCheck(Result->ConvertToBool());
        Result->m_Bool = !Result->m_Bool;
        break;
    case CppTokenAddressOf:
        Accept();
        Cast(Result);
        if (!Result->HasAddress())
        {
            EvalErrorDesc(SYNTAX, "No address for operator&");
        }
        EvalCheck(Result->ConvertToAddressOf(FALSE, m_PtrSize));
#if DBG_TYPES
        dprintf("& -> id %s!%x, base %x, size %x\n",
                Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
                Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        break;
    case CppTokenDereference:
        Accept();
        Cast(Result);
        if (!Result->IsPointer())
        {
            EvalErrorDesc(SYNTAX, "No pointer for operator*");
        }
        EvalCheck(Result->ConvertToDereference(CurrentAccess(), m_PtrSize));
#if DBG_TYPES
        dprintf("* -> id %s!%x, base %x, size %x\n",
                Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
                Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        break;
    case CppTokenPreIncrement:
    case CppTokenPreDecrement:
        Accept();
        Unary(Result);
        if (!Result->IsInteger() && !Result->IsPointer())
        {
            EvalError(TYPECONFLICT);
        }
        // Carry out the operation in a temporary as the
        // address will be wiped out by the operation.
        m_Tmp = *Result;
        if ((m_Err = m_Tmp.ConstIntOp(Op == CppTokenPreIncrement ? 1 : -1,
                                      TRUE, TDOP_ADD)) ||
            (m_Err = Result->WriteData(&m_Tmp, CurrentAccess())))
        {
            EvalError(m_Err);
        }
        Result->CopyData(&m_Tmp);
        break;
    default:
        Postfix(Result);
        break;
    }
}

void
CppEvalExpression::Postfix(TypedData* Result)
{
    TypedData* Next;

    if (m_Token == CppTokenDynamicCast ||
        m_Token == CppTokenStaticCast ||
        m_Token == CppTokenConstCast ||
        m_Token == CppTokenReinterpretCast)
    {
        // Don't bother trying to emulate
        // the precise rules on casting for
        // these operators, just cast.
        Accept();
        Match(CppTokenOpenAngle);
        Next = NewResult();
        if (TryTypeName(Next) != ERES_TYPE)
        {
            EvalError(TYPECONFLICT);
        }
        Match(CppTokenCloseAngle);
        Match(CppTokenOpenParen);
        Expression(Result);
        Match(CppTokenCloseParen);
        EvalCheck(Result->CastTo(Next));
        DelResult(Next);
        return;
    }
    
    Term(Result);
    for (;;)
    {
        CppToken Op = m_Token;
        switch(Op)
        {
        case '.':
            if (!Result->IsUdt())
            {
                EvalErrorDesc(TYPECONFLICT,
                              "Type is not struct/class/union for operator.");
            }
            Accept();
            UdtMember(Result);
            break;
        case CppTokenPointerMember:
            if (!Result->IsPointer())
            {
                EvalErrorDesc(TYPECONFLICT,
                              "Type is not pointer for operator->");
            }
            Accept();
            UdtMember(Result);
            break;
        case '[':
            if (Result->IsArray())
            {
                // There's no need to do a full address convert
                // as all we're going to do is deref later.
                EvalCheck(Result->GetAbsoluteAddress(&Result->m_Ptr));
            }
            else if (!Result->IsPointer())
            {
                EvalErrorDesc(TYPECONFLICT,
                              "Type is not a pointer for operator[]");
            }
            if (!Result->m_NextSize)
            {
                EvalError(TYPECONFLICT);
            }
            Accept();
            Next = NewResult();
            Expression(Next);
            if (!Next->IsInteger())
            {
                EvalErrorDesc(TYPECONFLICT,
                              "Array index not integral");
            }
            EvalCheck(Next->ConvertToU64());
            Result->m_Ptr += Next->m_U64 * Result->m_NextSize;
            DelResult(Next);
            EvalCheck(Result->
                      ConvertToDereference(CurrentAccess(), m_PtrSize));
            Match(CppTokenCloseBracket);
            break;
        case CppTokenPostIncrement:
        case CppTokenPostDecrement:
            if (!Result->IsInteger() && !Result->IsPointer())
            {
                EvalError(TYPECONFLICT);
            }
            m_Tmp = *Result;
            if ((m_Err = m_Tmp.ConstIntOp(Op == CppTokenPostIncrement ? 1 : -1,
                                          TRUE, TDOP_ADD)) ||
                (m_Err = Result->WriteData(&m_Tmp, CurrentAccess())))
            {
                EvalError(m_Err);
            }
            Accept();
            break;
        default:
            return;
        }
    }
}

void
CppEvalExpression::Term(TypedData* Result)
{
    EVAL_RESULT_KIND IdKind;
    
    switch(m_Token)
    {
    case CppTokenInteger:
    case CppTokenFloat:
    case CppTokenWchar:
    case CppTokenChar:
        *Result = m_TokenValue;
#if DBG_TYPES
    dprintf("%s -> id %s!%x, base %x, size %x\n",
            m_LexemeStart,
            Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
            Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        Accept();
        break;

    case CppTokenWcharString:
    case CppTokenCharString:
        EvalErrorDesc(SYNTAX, "String literals not allowed in");

    case CppTokenIdentifier:
        IdKind = CollectTypeOrSymbolName(Result);
        if (IdKind == ERES_TYPE)
        {
            TypedData* Type = NewResult();
            *Type = *Result;
            
            Match(CppTokenOpenParen);
            Expression(Result);
            Match(CppTokenCloseParen);
            EvalCheck(Result->CastTo(Type));
            DelResult(Type);
        }
        else if (IdKind == ERES_SYMBOL)
        {
#if DBG_TYPES
            dprintf("symbol -> id %s!%x, base %x, size %x\n",
                    Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
                    Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        }
        else
        {
            EvalError(VARDEF);
        }
        break;
        
    case CppTokenThis:
        if (!m_Process)
        {
            EvalError(BADPROCESS);
        }
        EvalCheck(Result->FindSymbol(m_Process, m_LexemeStart,
                                     CurrentAccess(), m_PtrSize));
#if DBG_TYPES
        dprintf("%s -> id %s!%x, base %x, size %x\n",
                m_LexemeStart,
                Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
                Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        Accept();
        break;

    case '(':
        Accept();
        Expression(Result);
        Match(CppTokenCloseParen);
        break;

    case CppTokenDebugRegister:
        // Skip @ at the beginning.
        if (!GetPsuedoOrRegTypedData(TRUE, m_LexemeStart + 1, Result))
        {
            if (GetOffsetFromBreakpoint(m_LexemeStart + 1, &Result->m_U64))
            {
                Result->SetToNativeType(DNTYPE_UINT64);
                Result->ClearAddress();
            }
            else
            {
                EvalError(VARDEF);
            }
        }
#if DBG_TYPES
        dprintf("%s -> id %s!%x, base %x, size %x\n",
                m_LexemeStart,
                Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
                Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        Accept();
        break;

    case CppTokenModule:
        // Skip the @! at the beginning.
        if (g_Process->GetOffsetFromMod(m_LexemeStart + 2, &Result->m_U64))
        {
            Result->SetToNativeType(DNTYPE_UINT64);
            Result->ClearAddress();
        }
        else
        {
            EvalError(VARDEF);
        }
        Accept();
        break;
        
    case CppTokenSwitchEvalExpression:
        EvalExpression* Eval;
        PSTR ExprStart;

        Eval = GetEvaluator(m_SwitchEvalSyntax, FALSE);
        Eval->InheritStart(this);
        // Allow all nested evaluators to get cleaned up.
        Eval->m_ChainTop = FALSE;
        ExprStart = m_LexemeStart + 2;
        while (*ExprStart && *ExprStart != '(')
        {
            ExprStart++;
        }
        Eval->Evaluate(ExprStart, NULL, EXPRF_DEFAULT, Result);
        Eval->InheritEnd(this);
        ReleaseEvaluator(Eval);
        
        Accept();
        break;

    case CppTokenPreprocFunction:
        PreprocFunction(Result);
        break;
        
    default:
        EvalErrorDesc(SYNTAX, m_ExprDesc);
    }
}

EVAL_RESULT_KIND
CppEvalExpression::TryTypeName(TypedData* Result)
{
    //
    // If the following tokens can be evaluated as
    // a type then do so, otherwise exit.
    //

    if (CollectTypeOrSymbolName(Result) == ERES_TYPE)
    {
        BOOL Scan = TRUE;
        
        while (Scan)
        {
            TypedData* Elements;
            
            switch(m_Token)
            {
            case '*':
            case CppTokenDereference:
                EvalCheck(Result->ConvertToAddressOf(TRUE, m_PtrSize));
                Accept();
                break;
            case '[':
                Elements = NewResult();
                Accept();
                if (m_Token != ']')
                {
                    Conditional(Elements);
                    if (!Elements->IsInteger())
                    {
                        EvalErrorDesc(SYNTAX, "Array length not integral");
                    }
                    EvalCheck(Elements->ConvertToU64());
                    Elements->m_U64 *= Result->m_BaseSize;
                }
                else
                {
                    // For a elementless array make it the same
                    // size as a pointer as that's essentially.
                    // what it is.
                    Elements->m_U64 = m_PtrSize;
                }
                Match(CppTokenCloseBracket);
                EvalCheck(Result->ConvertToArray((ULONG)Elements->m_U64));
                DelResult(Elements);
                break;
            default:
                Scan = FALSE;
                break;
            }
        }

#if DBG_TYPES
        dprintf("type -> id %s!%x, base %x, size %x\n",
                Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
                Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
        return ERES_TYPE;
    }
    else
    {
        // It wasn't a cast, let the caller handle it.
        return ERES_UNKNOWN;
    }
}

EVAL_RESULT_KIND
CppEvalExpression::CollectTypeOrSymbolName(TypedData* Result)
{
    EVAL_RESULT_KIND ResKind = ERES_UNKNOWN;
    CppToken LastToken = CppTokenError;
    PCSTR SourceStart = m_LexemeSourceStart;
    ULONG Len;

    for (;;)
    {
        if (IsTypeKeyword(m_Token))
        {
            if (!(LastToken == CppTokenError ||
                  LastToken == CppTokenIdentifier ||
                  IsTypeKeyword(LastToken)) ||
                (ResKind != ERES_TYPE && ResKind != ERES_UNKNOWN))
            {
                break;
            }

            m_LexemeRestart += strlen(m_LexemeRestart);
            *m_LexemeRestart++ = ' ';
            *m_LexemeRestart = 0;

            LastToken = m_Token;
            Accept();
            ResKind = ERES_TYPE;
        }
        else if (m_Token == CppTokenIdentifier)
        {
            if (LastToken == CppTokenIdentifier)
            {
                break;
            }

            m_LexemeRestart += strlen(m_LexemeRestart);
            *m_LexemeRestart++ = ' ';
            *m_LexemeRestart = 0;
            LastToken = m_Token;
            Accept();
        }
        else if (m_Token == CppTokenModule)
        {
            if (LastToken != CppTokenError)
            {
                break;
            }

            // Back up over @!.
            Len = strlen(m_LexemeRestart) - 2;
            memmove(m_LexemeRestart, m_LexemeRestart + 2, Len);
            m_LexemeRestart += Len;
            *m_LexemeRestart++ = ' ';
            *m_LexemeRestart = 0;
            LastToken = m_Token;
            Accept();
        }
        else if (m_Token == CppTokenNameQualifier ||
                 m_Token == CppTokenDestructor)
        {
            if (LastToken != CppTokenIdentifier &&
                LastToken != CppTokenCloseAngle)
            {
                break;
            }
                
            //
            // Some kind of member reference so keep collecting.
            //

            // Eliminate unnecessary space after identifier.
            Len = strlen(m_LexemeRestart) + 1;
            memmove(m_LexemeRestart - 1, m_LexemeRestart, Len);
            m_LexemeRestart += Len - 2;
            LastToken = m_Token;
            Accept();
        }
        else if (m_Token == '!')
        {
            if (LastToken != CppTokenIdentifier &&
                LastToken != CppTokenModule)
            {
                break;
            }
                
            //
            // Special syntax to allow module scoping for symbols.
            //

            // Eliminate unnecessary space after identifier.
            *(m_LexemeRestart - 1) = (char)m_Token;
            *m_LexemeRestart = 0;
            LastToken = m_Token;
            Accept();
        }
        else if (m_Token == CppTokenOpenAngle)
        {
            if (LastToken != CppTokenIdentifier)
            {
                break;
            }

            if (CollectTemplateName() == ERES_UNKNOWN)
            {
                break;
            }

            *++m_LexemeRestart = 0;
            LastToken = m_Token;
            Accept();
        }
        else if (m_Token == CppTokenOperator)
        {
            if (LastToken != CppTokenError &&
                LastToken != '!' &&
                LastToken != CppTokenNameQualifier)
            {
                break;
            }

            // Set LastToken first so it's CppTokenOperator for
            // all operators.
            LastToken = m_Token;
            ResKind = ERES_SYMBOL;
            
            CollectOperatorName();
        }
        else
        {
            break;
        }
    }

    if (LastToken == CppTokenNameQualifier ||
        LastToken == CppTokenDestructor ||
        LastToken == '!')
    {
        // Incomplete name.
        m_LexemeSourceStart = SourceStart;
        EvalErrorDesc(SYNTAX, "Incomplete symbol or type name");
    }

    if (LastToken == CppTokenModule)
    {
        // If the last token was a module name assume this
        // is a plain module name expression.
        return ERES_EXPRESSION;
    }

    PSTR End;
    char Save;

    End = m_LexemeRestart;
    if (End > m_LexemeBuffer && *(End - 1) == ' ')
    {
        End--;
    }

    if (!m_Process || End == m_LexemeBuffer)
    {
        // Can't look anything up without a process or name.
        return ERES_UNKNOWN;
    }

    Save = *End;
    *End = 0;

    // Clear the data address up front for the type cases
    // with no addresses.
    Result->ClearAddress();
    Result->ClearData();
    
    m_Err = VARDEF;

    if (ResKind != ERES_SYMBOL)
    {
        // First check for a built-in type as this greatly speeds
        // up references to them.  This should always be legal
        // because they're keywords so they can't be overriden
        // by symbols.
        PDBG_NATIVE_TYPE Native = FindNativeTypeByName(m_LexemeBuffer);
        if (Native)
        {
            Result->SetToNativeType(DbgNativeTypeId(Native));
            m_Err = NO_ERROR;
            ResKind = ERES_TYPE;
        }
    }
    
    if (m_Err && ResKind != ERES_TYPE)
    {
        m_Err = Result->FindSymbol(m_Process, m_LexemeBuffer,
                                   CurrentAccess(), m_PtrSize);
        if (!m_Err)
        {
            ResKind = ERES_SYMBOL;
        }
    }

    if (m_Err && ResKind != ERES_SYMBOL)
    {
        m_Err = Result->FindType(m_Process, m_LexemeBuffer, m_PtrSize);
        if (!m_Err)
        {
            ResKind = ERES_TYPE;
        }
    }

    if (m_Err)
    {
        if (m_AllowUnresolvedSymbols)
        {
            // Always assume that unresolved symbols are symbols.
            m_NumUnresolvedSymbols++;
            ResKind = ERES_SYMBOL;
        }
        else
        {
            m_LexemeSourceStart = SourceStart;
            EvalError(m_Err);
        }
    }

    *End = Save;
    m_LexemeRestart = m_LexemeBuffer;
    return ResKind;
}

EVAL_RESULT_KIND
CppEvalExpression::CollectTemplateName(void)
{
    EVAL_RESULT_KIND ResKind;
    
    //
    // Templates are difficult to distinguish from
    // normal arithmetic expressions.  Do a prefix
    // search for any symbol starting with what we
    // have so far and a <.  If something hits, assume
    // that this is a template reference and consume
    // everything to a matching >.
    //

    if (!m_Process)
    {
        // Can't look up anything without a process.
        return ERES_UNKNOWN;
    }
    
    // Eliminate unnecessary space after identifier.
    *(m_LexemeRestart - 1) = (char)m_Token;
    *m_LexemeRestart++ = '*';
    *m_LexemeRestart = 0;

    //
    // Check for a symbol or type match.
    //

    SYMBOL_INFO SymInfo = {0};

    if (!SymFromName(m_Process->m_SymHandle, m_LexemeBuffer, &SymInfo))
    {
        PSTR ModNameEnd;
        ImageInfo* Mod, *ModList;
        
        ModNameEnd = strchr(m_LexemeBuffer, '!');
        if (!ModNameEnd)
        {
            ModNameEnd = m_LexemeBuffer;
            Mod = NULL;
        }
        else
        {
            Mod = m_Process->
                FindImageByName(m_LexemeBuffer,
                                (ULONG)(ModNameEnd - m_LexemeBuffer),
                                INAME_MODULE, FALSE);
            if (!Mod)
            {
                goto Error;
            }

            ModNameEnd++;
        }

        for (ModList = m_Process->m_ImageHead;
             ModList;
             ModList = ModList->m_Next)
        {
            if (Mod && ModList != Mod)
            {
                continue;
            }

            if (SymGetTypeFromName(m_Process->m_SymHandle,
                                   ModList->m_BaseOfImage,
                                   ModNameEnd, &SymInfo))
            {
                break;
            }
        }

        if (!ModList)
        {
            goto Error;
        }
        
        ResKind = ERES_TYPE;
    }
    else
    {
        ResKind = ERES_SYMBOL;
    }

    //
    // Collect everything until a matching >.
    //

    ULONG Nest = 1;

    *--m_LexemeRestart  = 0;
    
    for (;;)
    {
        Accept();
            
        if (m_Token == CppTokenEof)
        {
            EvalErrorDesc(SYNTAX, "EOF in template");
        }
                
        // Put a space after commas and pack everything else.
        m_LexemeRestart += strlen(m_LexemeRestart);
        if (m_Token == CppTokenCloseAngle && --Nest == 0)
        {
            break;
        }
        else if (m_Token == CppTokenOpenAngle)
        {
            Nest++;
        }
        else if (m_Token == ',')
        {
            *m_LexemeRestart++ = ' ';
            *m_LexemeRestart = 0;
        }
    }

    return ResKind;

 Error:
    // No match.
    m_LexemeRestart -= 2;
    *m_LexemeRestart++ = ' ';
    *m_LexemeRestart = 0;
    return ERES_UNKNOWN;
}

void
CppEvalExpression::CollectOperatorName(void)
{
    PSTR OpEnd;
    
    //
    // Add in "operator".
    //
    
    m_LexemeRestart += strlen(m_LexemeRestart);
    OpEnd = m_LexemeRestart;
    Accept();

    //
    // Immediately process the specific operator tokens.
    //

    if (m_Token == CppTokenNew || m_Token == CppTokenDelete)
    {
        ULONG Len;
        
        // Put a space before new/delete.
        Len = strlen(OpEnd) + 1;
        memmove(OpEnd + 1, OpEnd, Len);
        *OpEnd = ' ';
        
        m_LexemeRestart = OpEnd + Len;
        Accept();

        // Check for vector forms.
        if (m_Token == CppTokenOpenBracket)
        {
            m_LexemeRestart += strlen(m_LexemeRestart);
            Accept();
            if (m_Token != CppTokenCloseBracket)
            {
                EvalError(SYNTAX);
            }
            m_LexemeRestart += strlen(m_LexemeRestart);
            Accept();
        }
    }
    else
    {
        switch(m_Token)
        {
        case '+':
        case '-':
        case '*':
        case '/':
        case '%':
        case '^':
        case '&':
        case '|':
        case '~':
        case '!':
        case '=':
        case '<':
        case '>':
        case ',':
        case CppTokenEqual:
        case CppTokenNotEqual:
        case CppTokenLessEqual:
        case CppTokenGreaterEqual:
        case CppTokenLogicalAnd:
        case CppTokenLogicalOr:
        case CppTokenUnaryPlus:
        case CppTokenUnaryMinus:
        case CppTokenLeftShift:
        case CppTokenRightShift:
        case CppTokenAddressOf:
        case CppTokenDereference:
        case CppTokenPointerMember:
        case CppTokenClassDereference:
        case CppTokenClassPointerMember:
        case CppTokenDivideAssign:
        case CppTokenMultiplyAssign:
        case CppTokenModuloAssign:
        case CppTokenAddAssign:
        case CppTokenSubtractAssign:
        case CppTokenLeftShiftAssign:
        case CppTokenRightShiftAssign:
        case CppTokenAndAssign:
        case CppTokenOrAssign:
        case CppTokenExclusiveOrAssign:
        case CppTokenPreIncrement:
        case CppTokenPreDecrement:
        case CppTokenPostIncrement:
        case CppTokenPostDecrement:
            break;
        case '(':
            m_LexemeRestart += strlen(m_LexemeRestart);
            Accept();
            if (m_Token != CppTokenCloseParen)
            {
                EvalError(SYNTAX);
            }
            break;
        case '[':
            m_LexemeRestart += strlen(m_LexemeRestart);
            Accept();
            if (m_Token != CppTokenCloseBracket)
            {
                EvalError(SYNTAX);
            }
            break;
        default:
            // Unrecognized operator.
            EvalError(SYNTAX);
        }
                
        m_LexemeRestart += strlen(m_LexemeRestart);
        Accept();
    }
}

void
CppEvalExpression::UdtMember(TypedData* Result)
{
    if (m_Token != CppTokenIdentifier)
    {
        EvalError(SYNTAX);
    }

    EvalCheck(Result->ConvertToMember(m_LexemeStart, CurrentAccess(),
                                      m_PtrSize));
#if DBG_TYPES
    dprintf("%s -> id %s!%x, base %x, size %x\n",
            m_LexemeStart,
            Result->m_Image ? Result->m_Image->m_ModuleName : "<>",
            Result->m_Type, Result->m_BaseType, Result->m_BaseSize);
#endif
    Accept();
}

#define MAX_CPP_ARGS 16

struct CPP_REPLACEMENT
{
    PSTR Name;
    ULONG NumArgs;
    PSTR Repl;
};

CPP_REPLACEMENT g_CppPreProcFn[] =
{
    "CONTAINING_RECORD", 3,
        "(($1$ *)((char*)($0$) - (int64)(&(($1$ *)0)->$2$)))",
    "FIELD_OFFSET", 2,
        "((long)&((($0$ *)0)->$1$))",
    "RTL_FIELD_SIZE", 2,
        "(sizeof((($0$ *)0)->$1$))",
    "RTL_SIZEOF_THROUGH_FIELD", 2,
        "(#FIELD_OFFSET($0$, $1$) + #RTL_FIELD_SIZE($0$, $1$))",
    "RTL_CONTAINS_FIELD", 3,
        "((((char*)(&($0$)->$2$)) + sizeof(($0$)->$2$)) <= "
        "((char*)($0$))+($1$)))",
    "RTL_NUMBER_OF", 1,
        "(sizeof($0$)/sizeof(($0$)[0]))",
};

void
CppEvalExpression::PreprocFunction(TypedData* Result)
{
    PCSTR Args[MAX_CPP_ARGS];
    ULONG ArgsLen[MAX_CPP_ARGS];
    ULONG i;
    CPP_REPLACEMENT* Repl;
    PCSTR Scan;

    Repl = g_CppPreProcFn;
    for (i = 0; i < DIMA(g_CppPreProcFn); i++)
    {
        // Skip '#' when comparing names.
        if (!strcmp(m_LexemeStart + 1, Repl->Name))
        {
            break;
        }

        Repl++;
    }

    if (i == DIMA(g_CppPreProcFn))
    {
        EvalError(SYNTAX);
    }

    DBG_ASSERT(Repl->NumArgs <= MAX_CPP_ARGS);

    // Accept the name token and verify that the next
    // token is an open paren.  Don't accept that token
    // as we're going to switch to grabbing raw characters.
    Accept();
    if (m_Token != CppTokenOpenParen)
    {
        EvalError(SYNTAX);
    }

    i = 0;
    for (;;)
    {
        ULONG Nest;

        // Check for too many arguments.
        if (i >= Repl->NumArgs)
        {
            EvalError(SYNTAX);
        }
        
        //
        // Gather raw text up to the first comma or extra
        // close paren.
        //

        while (isspace(*m_Lex))
        {
            m_Lex++;
        }
        
        Scan = m_Lex;
        Nest = 0;
        for (;;)
        {
            if (!*Scan)
            {
                EvalError(SYNTAX);
            }

            if (*Scan == '(')
            {
                Nest++;
            }
            else if ((*Scan == ',' && !Nest) ||
                     (*Scan == ')' && Nest-- == 0))
            {
                break;
            }

            Scan++;
        }

        Args[i] = m_Lex;
        ArgsLen[i] = (ULONG)(Scan - m_Lex);

        if (*Scan == ')')
        {
            // Check for too few arguments.
            if (i != Repl->NumArgs - 1)
            {
                EvalError(SYNTAX);
            }

            m_Lex = Scan;
            break;
        }
        else
        {
            m_Lex = Scan + 1;
        }

        i++;
    }

    // Switch back to token lexing.
    NextToken();
    Match(CppTokenCloseParen);

    PSTR NewExpr;
    PSTR Dest;
    ULONG ExprLen;
    
    //
    // We've accumlated all the arguments, so allocate a destination
    // buffer and do the necessary string replacements.
    // Make the buffer relatively large to allow for complicated
    // replacements.
    //

    ExprLen = 16384;
    NewExpr = new char[ExprLen];
    if (!NewExpr)
    {
        EvalError(NOMEMORY);
    }

    Scan = Repl->Repl;
    Dest = NewExpr;
    for (;;)
    {
        if (*Scan == '$')
        {
            //
            // Argument that needs replacement.
            //
            
            i = 0;
            Scan++;
            while (isdigit(*Scan))
            {
                i = i * 10 + (ULONG)(*Scan - '0');
                Scan++;
            }

            if (*Scan != '$' ||
                i >= Repl->NumArgs)
            {
                delete [] NewExpr;
                EvalError(IMPLERR);
            }

            Scan++;

            if ((Dest - NewExpr) + ArgsLen[i] >= ExprLen - 1)
            {
                delete [] NewExpr;
                EvalError(OVERFLOW);
            }

            memcpy(Dest, Args[i], ArgsLen[i]);
            Dest += ArgsLen[i];
        }
        else if (*Scan)
        {
            if ((ULONG)(Dest - NewExpr) >= ExprLen - 1)
            {
                delete [] NewExpr;
                EvalError(OVERFLOW);
            }
            
            *Dest++ = *Scan++;
        }
        else
        {
            *Dest = 0;
            break;
        }
    }

    //
    // Evaluate the new expression for the final result.
    //

    EvalExpression* Eval;

    Eval = GetEvaluator(DEBUG_EXPR_CPLUSPLUS, TRUE);
    if (!Eval)
    {
        delete [] NewExpr;
        EvalError(NOMEMORY);
    }

    Eval->InheritStart(this);
    ((CppEvalExpression*)Eval)->m_PreprocEval = TRUE;
    
    __try
    {
        Eval->Evaluate(NewExpr, NULL, EXPRF_DEFAULT, Result);
        Eval->InheritEnd(this);
        ReleaseEvaluator(Eval);
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        delete [] NewExpr;
        ReleaseEvaluators();
        RaiseException(GetExceptionCode(), 0, 0, NULL);
    }

    delete [] NewExpr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\event.h ===
//----------------------------------------------------------------------------
//
// Event waiting and processing.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __EVENT_H__
#define __EVENT_H__

struct LAST_EVENT_INFO
{
    union
    {
        DEBUG_LAST_EVENT_INFO_BREAKPOINT Breakpoint;
        DEBUG_LAST_EVENT_INFO_EXCEPTION Exception;
        DEBUG_LAST_EVENT_INFO_EXIT_THREAD ExitThread;
        DEBUG_LAST_EVENT_INFO_EXIT_PROCESS ExitProcess;
        DEBUG_LAST_EVENT_INFO_LOAD_MODULE LoadModule;
        DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE UnloadModule;
        DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR SystemError;
    };
};

extern TargetInfo* g_EventTarget;
extern ProcessInfo* g_EventProcess;
extern ThreadInfo* g_EventThread;
extern MachineInfo* g_EventMachine;

extern ULONG g_EventProcessSysId;
extern ULONG g_EventThreadSysId;
extern ULONG g_LastEventType;
extern char g_LastEventDesc[MAX_IMAGE_PATH + 64];
extern PVOID g_LastEventExtraData;
extern ULONG g_LastEventExtraDataSize;
extern LAST_EVENT_INFO g_LastEventInfo;
extern ULONG64 g_TargetEventPc;
extern PDEBUG_EXCEPTION_FILTER_PARAMETERS g_EventExceptionFilter;
extern ULONG g_ExceptionFirstChance;

extern ADDR g_EventPc;
extern ADDR g_PrevEventPc;
extern ADDR g_PrevRelatedPc;

extern ULONG64 g_ThreadToResume;
extern PUSER_DEBUG_SERVICES g_ThreadToResumeServices;
extern HANDLE g_EventToSignal;
extern ULONG g_SystemErrorOutput;
extern ULONG g_SystemErrorBreak;
extern ULONG g_ExecutionStatusRequest;
extern ULONG g_PendingBreakInTimeoutLimit;
extern char g_OutputCommandRedirectPrefix[];
extern ULONG g_OutputCommandRedirectPrefixLen;

extern PCHAR g_StateChangeData;
extern PDBGKD_ANY_CONTROL_REPORT g_ControlReport;

void DiscardLastEvent(void);
void ClearEventLog(void);
void DotEventLog(PDOT_COMMAND Cmd, DebugClient* Client);
BOOL AnyEventsPossible(void);
ULONG EventStatusToContinue(ULONG EventStatus);
HRESULT PrepareForWait(ULONG Flags, PULONG ContinueStatus);
void ProcessDeferredWork(PULONG ContinueStatus);
    
BOOL SuspendExecution(void);
HRESULT ResumeExecution(void);
    
// PrepareForCalls must gracefully handle failures so that
// it is always possible to enter call-handling mode.
void PrepareForCalls(ULONG64 ExtraStatusFlags);
    
// PrepareForExecution should report failures so that
// execution is not started until command mode can be left cleanly.
// This biases things towards running in command mode, which
// is the right thing to do.
HRESULT PrepareForExecution(ULONG NewStatus);

HRESULT PrepareForSeparation(void);
    
void FindEventProcessThread(void);
ULONG MergeVotes(ULONG Cur, ULONG Vote);
    
ULONG ProcessBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                       ULONG FirstChance);
ULONG CheckBreakpointOrStepTrace(PADDR BpAddr, ULONG BreakType);
ULONG CheckStepTrace(PADDR PcAddr, ULONG DefaultStatus);

void AnalyzeDeadlock(EXCEPTION_RECORD64* Exception,
                     ULONG FirstChance);
void OutputDeadlock(EXCEPTION_RECORD64* Exception,
                    ULONG FirstChance);
    
void GetEventName(ULONG64 ImageFile, ULONG64 ImageBase,
                  ULONG64 NamePtr, WORD Unicode,
                  PSTR NameBuffer, ULONG BufferSize);

//----------------------------------------------------------------------------
//
// Event filtering.
//
//----------------------------------------------------------------------------

extern ULONG64 g_UnloadDllBase;

BOOL BreakOnThisImageTail(PCSTR ImagePath, PCSTR FilterArg);
BOOL BreakOnThisDllUnload(ULONG64 DllBase);
BOOL BreakOnThisOutString(PCSTR OutString);

#define FILTER_MAX_ARGUMENT MAX_IMAGE_PATH

#define FILTER_SPECIFIC_FIRST  DEBUG_FILTER_CREATE_THREAD
#define FILTER_SPECIFIC_LAST   DEBUG_FILTER_DEBUGGEE_OUTPUT

#define FILTER_EXCEPTION_FIRST (FILTER_SPECIFIC_LAST + 1)
#define FILTER_EXCEPTION_LAST  (FILTER_SPECIFIC_LAST + 25)
#define FILTER_DEFAULT_EXCEPTION FILTER_EXCEPTION_FIRST

#define FILTER_COUNT (FILTER_EXCEPTION_LAST + 1)

#define IS_EFEXECUTION_BREAK(Execution) \
    ((Execution) == DEBUG_FILTER_SECOND_CHANCE_BREAK || \
     (Execution) == DEBUG_FILTER_BREAK)

#define FILTER_CHANGED_EXECUTION 0x00000001
#define FILTER_CHANGED_CONTINUE  0x00000002
#define FILTER_CHANGED_COMMAND   0x00000004

struct EVENT_COMMAND
{
    DebugClient* Client;
    // Both first and second chances have commands.
    PSTR Command[2];
    ULONG CommandSize[2];
};

struct EVENT_FILTER
{
    PCSTR Name;
    PCSTR ExecutionAbbrev;
    PCSTR ContinueAbbrev;
    PCSTR OutArgFormat;
    ULONG OutArgIndex;
    DEBUG_EXCEPTION_FILTER_PARAMETERS Params;
    EVENT_COMMAND Command;
    PSTR Argument;
    ULONG Flags;
};

#define OTHER_EXCEPTION_LIST_MAX 32

extern EVENT_FILTER g_EventFilters[];
extern DEBUG_EXCEPTION_FILTER_PARAMETERS g_OtherExceptionList[];
extern EVENT_COMMAND g_OtherExceptionCommands[];
extern ULONG g_NumOtherExceptions;

EVENT_FILTER* GetSpecificExceptionFilter(ULONG Code);
ULONG GetOtherExceptionParameters(ULONG Code, BOOL DefaultOnNotFound,
                                  PDEBUG_EXCEPTION_FILTER_PARAMETERS* Params,
                                  EVENT_COMMAND** Command);
void RemoveOtherException(ULONG Index);
void ParseSetEventFilter(DebugClient* Client);

#define SXCMDS_ONE_LINE 0x00000001

void ListFiltersAsCommands(DebugClient* Client, ULONG Flags);

BOOL SyncFiltersWithOptions(void);
BOOL SyncOptionsWithFilters(void);

#endif // #ifndef __EVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\expr.cpp ===
//----------------------------------------------------------------------------
//
// General expression evaluation support.
//
// Copyright (C) Microsoft Corporation, 1990-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

ULONG g_EvalSyntax;
TypedData g_LastEvalResult;

EvalExpression* g_EvalReleaseChain;
EvalExpression* g_EvalCache[EVAL_COUNT];

EvalExpression*
GetEvaluator(ULONG Syntax, BOOL RetFail)
{
    EvalExpression* Eval;
    
    //
    // Evaluators contain state and so a single
    // global evaluator instance cannot be used
    // if there's any possibility of nested
    // evaluation.  Instead we dynamically provide
    // an evaluator any time there's a need for
    // evaluation so that each nesting of a nested
    // evaluation will have its own state.
    //

    Eval = g_EvalCache[Syntax];
    if (Eval)
    {
        g_EvalCache[Syntax] = NULL;
    }
    else
    {
        switch(Syntax)
        {
        case DEBUG_EXPR_MASM:
            Eval = new MasmEvalExpression;
            break;
        case DEBUG_EXPR_CPLUSPLUS:
            Eval = new CppEvalExpression;
            break;
        default:
            if (RetFail)
            {
                return NULL;
            }
            else
            {
                error(IMPLERR);
            }
        }
        if (!Eval)
        {
            if (RetFail)
            {
                return NULL;
            }
            else
            {
                error(NOMEMORY);
            }
        }
    }

    Eval->m_ReleaseChain = g_EvalReleaseChain;
    g_EvalReleaseChain = Eval;
    
    return Eval;
}

void
ReleaseEvaluator(EvalExpression* Eval)
{
    if (g_EvalReleaseChain == Eval)
    {
        g_EvalReleaseChain = Eval->m_ReleaseChain;
    }
    
    if (!g_EvalCache[Eval->m_Syntax])
    {
        Eval->Reset();
        g_EvalCache[Eval->m_Syntax] = Eval;
    }
    else
    {
        delete Eval;
    }
}

void
ReleaseEvaluators(void)
{
    BOOL ChainTop = FALSE;
    while (g_EvalReleaseChain && !ChainTop)
    {
        ChainTop = g_EvalReleaseChain->m_ChainTop;
        ReleaseEvaluator(g_EvalReleaseChain);
    }
}

HRESULT
GetEvaluatorByName(PCSTR AbbrevName, BOOL RetFail,
                   EvalExpression** EvalRet)
{
    for (ULONG i = 0; i < EVAL_COUNT; i++)
    {
        EvalExpression* Eval = GetEvaluator(i, RetFail);
        if (!Eval)
        {
            return E_OUTOFMEMORY;
        }
        
        if (!_stricmp(AbbrevName, Eval->m_AbbrevName))
        {
            *EvalRet = Eval;
            return S_OK;
        }
        
        ReleaseEvaluator(Eval);
    }

    if (!RetFail)
    {
        error(SYNTAX);
    }
    return E_NOINTERFACE;
}

CHAR
PeekChar(void)
{
    CHAR Ch;

    do
    {
        Ch = *g_CurCmd++;
    } while (Ch == ' ' || Ch == '\t' || Ch == '\r' || Ch == '\n');
    
    g_CurCmd--;
    return Ch;
}

/*** GetRange - parse address range specification
*
*   Purpose:
*       With the current command line position, parse an
*       address range specification.  Forms accepted are:
*       <start-addr>            - starting address with default length
*       <start-addr> <end-addr> - inclusive address range
*       <start-addr> l<count>   - starting address with item count
*
*   Input:
*       g_CurCmd - present command line location
*       size - nonzero - (for data) size in bytes of items to list
*                        specification will be "length" type with
*                        *fLength forced to TRUE.
*              zero - (for instructions) specification either "length"
*                     or "range" type, no size assumption made.
*
*   Output:
*       *addr - starting address of range
*       *value - if *fLength = TRUE, count of items (forced if size != 0)
*                              FALSE, ending address of range
*       (*addr and *value unchanged if no second argument in command)
*
*   Returns:
*       A value of TRUE is returned if no length is specified, or a length
*       or an ending address is specified and size is not zero. Otherwise,
*       a value of FALSE is returned.
*
*   Exceptions:
*       error exit:
*               SYNTAX - expression error
*               BADRANGE - if ending address before starting address
*
*************************************************************************/

BOOL
GetRange(PADDR Addr,
         PULONG64 Value,
         ULONG Size,
         ULONG SegReg,
         ULONG SizeLimit)
{
    CHAR Ch;
    PSTR Scan;
    ADDR EndRange;
    BOOL HasL = FALSE;
    BOOL HasLength;
    BOOL WasSpace = FALSE;

    //  skip leading whitespace first
    PeekChar();

    //  Pre-parse the line, look for a " L"

    for (Scan = g_CurCmd; *Scan; Scan++)
    {
        if ((*Scan == 'L' || *Scan == 'l') && WasSpace)
        {
            HasL = TRUE;
            *Scan = '\0';
            break;
        }
        else if (*Scan == ';')
        {
            break;
        }

        WasSpace = *Scan == ' ';
    }

    HasLength = TRUE;
    if ((Ch = PeekChar()) != '\0' && Ch != ';')
    {
        GetAddrExpression(SegReg, Addr);
        if (((Ch = PeekChar()) != '\0' && Ch != ';') || HasL)
        {
            if (!HasL)
            {
                GetAddrExpression(SegReg, &EndRange);
                if (AddrGt(*Addr, EndRange))
                {
                    error(BADRANGE);
                }

                if (Size)
                {
                    *Value = AddrDiff(EndRange, *Addr) / Size + 1;
                }
                else
                {
                    *Value = Flat(EndRange);
                    HasLength = FALSE;
                }
            }
            else
            {
                BOOL Invert;
                
                g_CurCmd = Scan + 1;
                if (*g_CurCmd == '-')
                {
                    Invert = TRUE;
                    g_CurCmd++;
                }
                else
                {
                    Invert = FALSE;
                }

                if (*g_CurCmd == '?')
                {
                    // Turn off range length checking.
                    SizeLimit = 0;
                    g_CurCmd++;
                }
                
                *Value = GetExpressionDesc("Length of range missing from");
                *Scan = 'l';

                if (Invert)
                {
                    // The user has given an l- range which indicates
                    // a length before the first address instead of
                    // a length after the first address.
                    if (Size)
                    {
                        AddrSub(Addr, *Value * Size);
                    }
                    else
                    {
                        ULONG64 Back = *Value;
                        *Value = Flat(*Addr);
                        AddrSub(Addr, Back);
                        HasLength = FALSE;
                    }
                }
            }

            // If the length is huge assume the user made
            // some kind of mistake.
            if (SizeLimit && Size && *Value * Size > SizeLimit)
            {
                error(BADRANGE);
            }
        }
    }

    return HasLength;
}

ULONG64
EvalStringNumAndCatch(PCSTR String)
{
    ULONG64 Result;

    EvalExpression* RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;
    
    __try
    {
        EvalExpression* Eval = GetCurEvaluator();
        Result = Eval->EvalStringNum(String);
        ReleaseEvaluator(Eval);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Result = 0;
    }

    g_EvalReleaseChain = RelChain;
    return Result;
}

ULONG64
GetExpression(void)
{
    EvalExpression* Eval = GetCurEvaluator();
    ULONG64 Result = Eval->EvalCurNum();
    ReleaseEvaluator(Eval);
    return Result;
}

ULONG64
GetExpressionDesc(PCSTR Desc)
{
    EvalExpression* Eval = GetCurEvaluator();
    ULONG64 Result = Eval->EvalCurNumDesc(Desc);
    ReleaseEvaluator(Eval);
    return Result;
}

ULONG64
GetTermExpression(PCSTR Desc)
{
    EvalExpression* Eval = GetCurEvaluator();
    ULONG64 Result = Eval->EvalCurTermNumDesc(Desc);
    ReleaseEvaluator(Eval);
    return Result;
}

void
GetAddrExpression(ULONG SegReg, PADDR Addr)
{
    EvalExpression* Eval = GetCurEvaluator();
    Eval->EvalCurAddr(SegReg, Addr);
    ReleaseEvaluator(Eval);
}

//----------------------------------------------------------------------------
//
// TypedDataStackAllocator.
//
//----------------------------------------------------------------------------

void*
TypedDataStackAllocator::RawAlloc(ULONG Bytes)
{
    void* Mem = malloc(Bytes);
    if (!Mem)
    {
        m_Eval->EvalError(NOMEMORY);
    }
    return Mem;
}

//----------------------------------------------------------------------------
//
// EvalExpression.
//
//----------------------------------------------------------------------------

// 'this' used in initializer list.
#pragma warning(disable:4355)

EvalExpression::EvalExpression(ULONG Syntax, PCSTR FullName, PCSTR AbbrevName)
    : m_ResultAlloc(this)
{
    m_Syntax = Syntax;
    m_FullName = FullName;
    m_AbbrevName = AbbrevName;
    m_ParseOnly = 0;
    m_AllowUnresolvedSymbols = 0;
    m_NumUnresolvedSymbols = 0;
    m_ReleaseChain = NULL;
    m_ChainTop = TRUE;
    m_Lex = NULL;
}

#pragma warning(default:4355)

EvalExpression::~EvalExpression(void)
{
}

void
EvalExpression::EvalCurrent(TypedData* Result)
{
    g_CurCmd = (PSTR)
        Evaluate(g_CurCmd, NULL, EXPRF_DEFAULT, Result);
}

void
EvalExpression::EvalCurAddrDesc(ULONG SegReg, PCSTR Desc, PADDR Addr)
{
    //
    // Evaluate a normal expression and then
    // force the result to be an address.
    //

    if (Desc == NULL)
    {
        Desc = "Address expression missing from";
    }
    
    NotFlat(*Addr);

    g_CurCmd = (PSTR)
        EvaluateAddr(g_CurCmd, Desc, SegReg, Addr);
}
    
ULONG64
EvalExpression::EvalStringNum(PCSTR String)
{
    ULONG Err;
    TypedData Result;
    
    Evaluate(String, "Numeric expression missing from",
             EXPRF_DEFAULT, &Result);
    if (Err = Result.ConvertToU64())
    {
        error(Err);
    }
    return Result.m_U64;
}

ULONG64
EvalExpression::EvalCurNumDesc(PCSTR Desc)
{
    ULONG Err;
    TypedData Result;
    
    if (Desc == NULL)
    {
        Desc = "Numeric expression missing from";
    }

    g_CurCmd = (PSTR)
        Evaluate(g_CurCmd, Desc, EXPRF_DEFAULT, &Result);
    if (Err = Result.ConvertToU64())
    {
        error(Err);
    }
    return Result.m_U64;
}

ULONG64
EvalExpression::EvalCurTermNumDesc(PCSTR Desc)
{
    ULONG Err;
    TypedData Result;
    
    if (Desc == NULL)
    {
        Desc = "Numeric term missing from";
    }
    
    g_CurCmd = (PSTR)
        Evaluate(g_CurCmd, Desc, EXPRF_SINGLE_TERM, &Result);
    if (Err = Result.ConvertToU64())
    {
        error(Err);
    }
    return Result.m_U64;
}

void DECLSPEC_NORETURN
EvalExpression::EvalErrorDesc(ULONG Error, PCSTR Desc)
{
    if (!g_DisableErrorPrint)
    {
        PCSTR Text =
            !m_LexemeSourceStart || !*m_LexemeSourceStart ?
            "<EOL>" : m_LexemeSourceStart;
        if (Desc != NULL)
        {
            ErrOut("%s '%s'\n", Desc, Text);
        }
        else
        {
            ErrOut("%s error at '%s'\n", ErrorString(Error), Text);
        }
    }

    ReleaseEvaluators();
    RaiseException(COMMAND_EXCEPTION_BASE + Error, 0, 0, NULL);
}

void
EvalExpression::Reset(void)
{
    // Clear out any temporary memory that may have been allocated.
    m_ResultAlloc.FreeAll();
    m_NumUnresolvedSymbols = 0;
    m_Lex = NULL;
    m_ParseOnly = 0;
    m_ReleaseChain = NULL;
}

void
EvalExpression::StartLexer(PCSTR Expr)
{
    m_Lex = Expr;
    m_LexemeRestart = m_LexemeBuffer;
    m_LexemeSourceStart = NULL;
    m_AllowUnaryOp = TRUE;
}

void
EvalExpression::Start(PCSTR Expr, PCSTR Desc, ULONG Flags)
{
    // This class can't be used recursively.
    if (m_Lex || m_ResultAlloc.NumAllocatedChunks())
    {
        error(IMPLERR);
    }
    
    RequireCurrentScope();

    m_ExprDesc = Desc;
    m_Flags = Flags;
    
    m_Process = g_Process;
    if (IS_CUR_MACHINE_ACCESSIBLE())
    {
        m_Machine = g_Machine;
    }
    else
    {
        m_Machine = NULL;
    }
    
    m_PtrSize = (m_Machine && m_Machine->m_Ptr64) ? 8 : 4;

    StartLexer(Expr);
}

void
EvalExpression::End(TypedData* Result)
{
    g_LastEvalResult = *Result;
    // Allocator should have been left clean.
    DBG_ASSERT(m_ResultAlloc.NumAllocatedChunks() == 0);
}

void
EvalExpression::AddLexeme(char Ch)
{
    if (m_LexemeChar - m_LexemeBuffer >= sizeof(m_LexemeBuffer) - 1)
    {
        EvalErrorDesc(STRINGSIZE, "Lexeme too long in");
    }

    *m_LexemeChar++ = Ch;
}

void
EvalExpression::InheritStart(EvalExpression* Parent)
{
    //
    // Pick up heritable state from the parent.
    //
    
    if (Parent->m_ParseOnly)
    {
        m_ParseOnly++;
    }

    if (Parent->m_AllowUnresolvedSymbols)
    {
        m_AllowUnresolvedSymbols++;
    }
}

void
EvalExpression::InheritEnd(EvalExpression* Parent)
{
    //
    // Pass heritable state back to the parent.
    //

    if (Parent->m_ParseOnly)
    {
        m_ParseOnly--;
    }

    if (Parent->m_AllowUnresolvedSymbols)
    {
        Parent->m_NumUnresolvedSymbols += m_NumUnresolvedSymbols;
        m_AllowUnresolvedSymbols--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\exts.cpp ===
//----------------------------------------------------------------------------
//
// Extension DLL support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"
#include <time.h>

/*
 * _NT_DEBUG_OPTIONS support. Each option in g_EnvDbgOptionNames must have a
 *  corresponding OPTION_* define, in the same order.
 */
DWORD g_EnvDbgOptions;
char* g_EnvDbgOptionNames[OPTION_COUNT] =
{
    "NOEXTWARNING",
    "NOVERSIONCHECK",
};

EXTDLL *g_ExtDlls;
LPTSTR g_BaseExtensionSearchPath = NULL;

ULONG64 g_ExtThread;

ULONG g_ExtGetExpressionRemainderIndex;
BOOL g_ExtGetExpressionSuccess;

WOW64EXTSPROC g_Wow64exts;
EXTDLL* g_Wow64ExtDll;

WMI_FORMAT_TRACE_DATA g_WmiFormatTraceData;
EXTDLL* g_WmiExtDll;

DEBUG_SCOPE g_ExtThreadSavedScope;
BOOL g_ExtThreadScopeSaved;

//
// Functions prototyped specifically for compatibility with extension
// callback prototypes.
//

VOID WDBGAPIV
ExtOutput64(
    PCSTR lpFormat,
    ...
    );

VOID WDBGAPIV
ExtOutput32(
    PCSTR lpFormat,
    ...
    );

ULONG64
ExtGetExpression(
    PCSTR CommandString
    );

ULONG
ExtGetExpression32(
    PCSTR CommandString
    );

void
ExtGetSymbol(
    ULONG64 Offset,
    PCHAR Buffer,
    PULONG64 Displacement
    );

void
ExtGetSymbol32(
    ULONG Offset,
    PCHAR Buffer,
    PULONG Displacement
    );

DWORD
ExtDisasm(
    PULONG64 lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    );

DWORD
ExtDisasm32(
    PULONG lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    );

BOOL
ExtReadVirtualMemory(
    IN ULONG64 Address,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG BytesRead
    );

BOOL
ExtReadVirtualMemory32(
    IN ULONG Address,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG BytesRead
    );

ULONG
ExtWriteVirtualMemory(
    IN ULONG64 Address,
    IN LPCVOID Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

ULONG
ExtWriteVirtualMemory32(
    IN ULONG Address,
    IN LPCVOID Buffer,
    IN ULONG Length,
    OUT PULONG BytesWritten
    );

BOOL ExtGetThreadContext(DWORD Processor,
                         PVOID Context,
                         DWORD SizeOfContext);
BOOL ExtSetThreadContext(DWORD Processor,
                         PVOID Context,
                         DWORD SizeOfContext);

BOOL
ExtIoctl(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    );

BOOL
ExtIoctl32(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    );

DWORD
ExtCallStack(
    DWORD64           FramePointer,
    DWORD64           StackPointer,
    DWORD64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    DWORD             Frames
    );

DWORD
ExtCallStack32(
    DWORD             FramePointer,
    DWORD             StackPointer,
    DWORD             ProgramCounter,
    PEXTSTACKTRACE32  StackFrames,
    DWORD             Frames
    );

BOOL
ExtReadPhysicalMemory(
    ULONGLONG Address,
    PVOID Buffer,
    ULONG Length,
    PULONG BytesRead
    );

BOOL
ExtWritePhysicalMemory(
    ULONGLONG Address,
    LPCVOID Buffer,
    ULONG Length,
    PULONG BytesWritten
    );

WINDBG_EXTENSION_APIS64 g_WindbgExtensions64 =
{
    sizeof(g_WindbgExtensions64),
    ExtOutput64,
    ExtGetExpression,
    ExtGetSymbol,
    ExtDisasm,
    CheckUserInterrupt,
    (PWINDBG_READ_PROCESS_MEMORY_ROUTINE64)ExtReadVirtualMemory,
    ExtWriteVirtualMemory,
    (PWINDBG_GET_THREAD_CONTEXT_ROUTINE)ExtGetThreadContext,
    (PWINDBG_SET_THREAD_CONTEXT_ROUTINE)ExtSetThreadContext,
    (PWINDBG_IOCTL_ROUTINE)ExtIoctl,
    ExtCallStack
};

WINDBG_EXTENSION_APIS32 g_WindbgExtensions32 =
{
    sizeof(g_WindbgExtensions32),
    ExtOutput32,
    ExtGetExpression32,
    ExtGetSymbol32,
    ExtDisasm32,
    CheckUserInterrupt,
    (PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)ExtReadVirtualMemory32,
    ExtWriteVirtualMemory32,
    (PWINDBG_GET_THREAD_CONTEXT_ROUTINE)ExtGetThreadContext,
    (PWINDBG_SET_THREAD_CONTEXT_ROUTINE)ExtSetThreadContext,
    (PWINDBG_IOCTL_ROUTINE)ExtIoctl32,
    ExtCallStack32
};

WINDBG_OLDKD_EXTENSION_APIS g_KdExtensions =
{
    sizeof(g_KdExtensions),
    ExtOutput32,
    ExtGetExpression32,
    ExtGetSymbol32,
    ExtDisasm32,
    CheckUserInterrupt,
    (PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)ExtReadVirtualMemory32,
    ExtWriteVirtualMemory32,
    (PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)ExtReadPhysicalMemory,
    (PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)ExtWritePhysicalMemory
};

//----------------------------------------------------------------------------
//
// Callback functions for extensions.
//
//----------------------------------------------------------------------------

VOID WDBGAPIV
ExtOutput64(
    PCSTR lpFormat,
    ...
    )
{
    va_list Args;
    va_start(Args, lpFormat);
    MaskOutVa(DEBUG_OUTPUT_NORMAL, lpFormat, Args, TRUE);
    va_end(Args);

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

VOID WDBGAPIV
ExtOutput32(
    PCSTR lpFormat,
    ...
    )
{
    va_list Args;
    va_start(Args, lpFormat);
    MaskOutVa(DEBUG_OUTPUT_NORMAL, lpFormat, Args, FALSE);
    va_end(Args);

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

ULONG64
ExtGetExpression(
    PCSTR CommandString
    )
{
    g_ExtGetExpressionSuccess = FALSE;

    if (CommandString == NULL)
    {
        return 0;
    }

    ULONG64 ReturnValue;
    PSTR SaveCommand = g_CurCmd;
    PSTR SaveStart = g_CommandStart;

    if (IS_USER_TARGET(g_Target))
    {
        if ( strcmp(CommandString, "WOW_BIG_BDE_HACK") == 0 )
        {
            return( (ULONG_PTR)(&segtable[0]) );
        }

        //
        // this is because the kdexts MUST include the address-of operator
        // on all getexpression calls for windbg/c expression evaluators
        //
        if (*CommandString == '&')
        {
            CommandString++;
        }
    }

    g_CurCmd = (PSTR)CommandString;
    g_CommandStart = (PSTR)CommandString;
    g_DisableErrorPrint++;

    EvalExpression* RelChain = g_EvalReleaseChain;
    g_EvalReleaseChain = NULL;

    __try
    {
        // ntsd/windbg extensions always use the MASM-style
        // expression evaluator for compatibility.
        EvalExpression* Eval = GetEvaluator(DEBUG_EXPR_MASM, FALSE);
        ReturnValue = Eval->EvalCurNum();
        ReleaseEvaluator(Eval);
        g_ExtGetExpressionSuccess = TRUE;
    }
    __except(CommandExceptionFilter(GetExceptionInformation()))
    {
        ReturnValue = 0;
    }
    g_ExtGetExpressionRemainderIndex =
        (ULONG)(g_CurCmd - g_CommandStart);
    g_EvalReleaseChain = RelChain;
    g_DisableErrorPrint--;
    g_CurCmd = SaveCommand;
    g_CommandStart = SaveStart;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    return ReturnValue;
}

ULONG
ExtGetExpression32(
    LPCSTR CommandString
    )
{
    return (ULONG)ExtGetExpression(CommandString);
}

void
ExtGetSymbol (
    ULONG64 offset,
    PCHAR pchBuffer,
    PULONG64 pDisplacement
    )
{
    // No way to know how much space we're given, so
    // just assume 256, which many extensions pass in
    GetSymbol(offset, pchBuffer, 256, pDisplacement);

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

void
ExtGetSymbol32(
    ULONG offset,
    PCHAR pchBuffer,
    PULONG pDisplacement
    )
{
    ULONG64 Displacement;

    // No way to know how much space we're given, so
    // just assume 256, which many extensions pass in
    GetSymbol(EXTEND64(offset), pchBuffer, 256, &Displacement);
    *pDisplacement = (ULONG)Displacement;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();
}

DWORD
ExtDisasm(
    ULONG64 *lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    )
{
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        ErrOut("ExtDisasm called before debugger initialized\n");
        return FALSE;
    }

    ADDR    tempAddr;
    BOOL    ret;

    Type(tempAddr) = ADDR_FLAT | FLAT_COMPUTED;
    Off(tempAddr) = Flat(tempAddr) = *lpOffset;
    ret = g_Machine->
        Disassemble(g_Process, &tempAddr, (PSTR)lpBuffer, (BOOL) fShowEA);
    *lpOffset = Flat(tempAddr);
    return ret;
}

DWORD
ExtDisasm32(
    ULONG *lpOffset,
    PCSTR lpBuffer,
    ULONG fShowEA
    )
{
    ULONG64 Offset = EXTEND64(*lpOffset);
    DWORD rval = ExtDisasm(&Offset, lpBuffer, fShowEA);
    *lpOffset = (ULONG)Offset;
    return rval;
}

BOOL
ExtGetThreadContext(DWORD Processor,
                    PVOID Context,
                    DWORD SizeOfContext)
{
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        return FALSE;
    }

    // This get may be getting the context of the thread
    // currently cached by the register code.  Make sure
    // the cache is flushed.
    g_Target->FlushRegContext();

    CROSS_PLATFORM_CONTEXT TargetContext;

    g_Target->m_Machine->
        InitializeContextFlags(&TargetContext, g_Target->m_SystemVersion);
    if (g_Target->GetContext(IS_KERNEL_TARGET(g_Target) ?
                             VIRTUAL_THREAD_HANDLE(Processor) : Processor,
                             &TargetContext) == S_OK &&
        g_Machine->ConvertContextTo(&TargetContext, g_Target->m_SystemVersion,
                                    SizeOfContext, Context) == S_OK)
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
ExtSetThreadContext(DWORD Processor,
                    PVOID Context,
                    DWORD SizeOfContext)
{
    if (!IS_CUR_MACHINE_ACCESSIBLE())
    {
        return FALSE;
    }

    BOOL Status;

    // This set may be setting the context of the thread
    // currently cached by the register code.  Make sure
    // the cache is invalidated.
    g_Target->ChangeRegContext(NULL);

    CROSS_PLATFORM_CONTEXT TargetContext;
    if (g_Machine->
        ConvertContextFrom(&TargetContext, g_Target->m_SystemVersion,
                           SizeOfContext, Context) == S_OK &&
        g_Target->SetContext(IS_KERNEL_TARGET(g_Target) ?
                             VIRTUAL_THREAD_HANDLE(Processor) : Processor,
                             &TargetContext) == S_OK)
    {
        Status = TRUE;
    }
    else
    {
        Status = FALSE;
    }

    // Reset the current thread.
    g_Target->ChangeRegContext(g_Thread);

    return Status;
}

BOOL
ExtReadVirtualMemory(
    IN ULONG64 pBufSrc,
    OUT PUCHAR pBufDest,
    IN ULONG count,
    OUT PULONG pcTotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    ULONG BytesTemp;
    return g_Target->
        ReadVirtual(g_Process,
                    pBufSrc, pBufDest, count, pcTotalBytesRead != NULL ?
                    pcTotalBytesRead : &BytesTemp) == S_OK;
}

BOOL
ExtReadVirtualMemory32(
    IN ULONG pBufSrc,
    OUT PUCHAR pBufDest,
    IN ULONG count,
    OUT PULONG pcTotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    ULONG BytesTemp;
    return g_Target->
        ReadVirtual(g_Process, EXTEND64(pBufSrc), pBufDest, count,
                    pcTotalBytesRead != NULL ?
                    pcTotalBytesRead : &BytesTemp) == S_OK;
}

DWORD
ExtWriteVirtualMemory(
    IN ULONG64 addr,
    IN LPCVOID buffer,
    IN ULONG count,
    OUT PULONG pcBytesWritten
    )
{
    ULONG BytesTemp;

    return (g_Target->WriteVirtual(g_Process, addr, (PVOID)buffer, count,
                                   pcBytesWritten != NULL ?
                                   pcBytesWritten : &BytesTemp) == S_OK);
}

ULONG
ExtWriteVirtualMemory32 (
    IN ULONG addr,
    IN LPCVOID buffer,
    IN ULONG count,
    OUT PULONG pcBytesWritten
    )
{
    ULONG BytesTemp;
    return (g_Target->WriteVirtual(g_Process, EXTEND64(addr),
                                   (PVOID)buffer, count,
                                   pcBytesWritten != NULL ?
                                   pcBytesWritten : &BytesTemp) == S_OK);
}

BOOL
ExtReadPhysicalMemory(
    ULONGLONG pBufSrc,
    PVOID pBufDest,
    ULONG count,
    PULONG TotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    if (ARGUMENT_PRESENT(TotalBytesRead))
    {
        *TotalBytesRead = 0;
    }

    ULONG BytesTemp;
    return g_Target->ReadPhysical(pBufSrc, pBufDest, count,
                                  PHYS_FLAG_DEFAULT,
                                  TotalBytesRead != NULL ?
                                  TotalBytesRead : &BytesTemp) == S_OK;
}

BOOL
ExtWritePhysicalMemory (
    ULONGLONG pBufDest,
    LPCVOID pBufSrc,
    ULONG count,
    PULONG TotalBytesWritten
    )
{
    if (ARGUMENT_PRESENT(TotalBytesWritten))
    {
        *TotalBytesWritten = 0;
    }

    ULONG BytesTemp;
    return g_Target->WritePhysical(pBufDest, (PVOID)pBufSrc, count,
                                   PHYS_FLAG_DEFAULT,
                                   TotalBytesWritten != NULL ?
                                   TotalBytesWritten : &BytesTemp) == S_OK;
}

BOOL
ExtReadPhysicalMemoryWithFlags(
    ULONGLONG pBufSrc,
    PVOID pBufDest,
    ULONG count,
    ULONG Flags,
    PULONG TotalBytesRead
    )
{
    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    if (ARGUMENT_PRESENT(TotalBytesRead))
    {
        *TotalBytesRead = 0;
    }

    ULONG BytesTemp;
    return g_Target->ReadPhysical(pBufSrc, pBufDest, count, Flags,
                                  TotalBytesRead != NULL ?
                                  TotalBytesRead : &BytesTemp) == S_OK;
}

BOOL
ExtWritePhysicalMemoryWithFlags(
    ULONGLONG pBufDest,
    LPCVOID pBufSrc,
    ULONG count,
    ULONG Flags,
    PULONG TotalBytesWritten
    )
{
    if (ARGUMENT_PRESENT(TotalBytesWritten))
    {
        *TotalBytesWritten = 0;
    }

    ULONG BytesTemp;
    return g_Target->WritePhysical(pBufDest, (PVOID)pBufSrc, count, Flags,
                                   TotalBytesWritten != NULL ?
                                   TotalBytesWritten : &BytesTemp) == S_OK;
}

DWORD
ExtCallStack(
    DWORD64           FramePointer,
    DWORD64           StackPointer,
    DWORD64           ProgramCounter,
    PEXTSTACKTRACE64  ExtStackFrames,
    DWORD             Frames
    )
{
    PDEBUG_STACK_FRAME StackFrames;
    DWORD              FrameCount;
    DWORD              i;

    StackFrames = (PDEBUG_STACK_FRAME)
        malloc( sizeof(StackFrames[0]) * Frames );
    if (!StackFrames)
    {
        return 0;
    }

    ULONG PtrDef =
        (!ProgramCounter ? STACK_INSTR_DEFAULT : 0) |
        (!StackPointer ? STACK_STACK_DEFAULT : 0) |
        (!FramePointer ? STACK_FRAME_DEFAULT : 0);

    FrameCount = StackTrace( NULL,
                             FramePointer, StackPointer, ProgramCounter,
                             PtrDef, StackFrames, Frames,
                             g_ExtThread, 0, FALSE );

    for (i = 0; i < FrameCount; i++)
    {
        ExtStackFrames[i].FramePointer    =  StackFrames[i].FrameOffset;
        ExtStackFrames[i].ProgramCounter  =  StackFrames[i].InstructionOffset;
        ExtStackFrames[i].ReturnAddress   =  StackFrames[i].ReturnOffset;
        ExtStackFrames[i].Args[0]         =  StackFrames[i].Params[0];
        ExtStackFrames[i].Args[1]         =  StackFrames[i].Params[1];
        ExtStackFrames[i].Args[2]         =  StackFrames[i].Params[2];
        ExtStackFrames[i].Args[3]         =  StackFrames[i].Params[3];
    }

    free( StackFrames );

    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }

    g_ExtThread = 0;

    return FrameCount;
}

DWORD
ExtCallStack32(
    DWORD             FramePointer,
    DWORD             StackPointer,
    DWORD             ProgramCounter,
    PEXTSTACKTRACE32  ExtStackFrames,
    DWORD             Frames
    )
{
    PDEBUG_STACK_FRAME StackFrames;
    DWORD              FrameCount;
    DWORD              i;

    StackFrames = (PDEBUG_STACK_FRAME)
        malloc( sizeof(StackFrames[0]) * Frames );
    if (!StackFrames)
    {
        return 0;
    }

    ULONG PtrDef =
        (!ProgramCounter ? STACK_INSTR_DEFAULT : 0) |
        (!StackPointer ? STACK_STACK_DEFAULT : 0) |
        (!FramePointer ? STACK_FRAME_DEFAULT : 0);

    FrameCount = StackTrace(NULL,
                            EXTEND64(FramePointer),
                            EXTEND64(StackPointer),
                            EXTEND64(ProgramCounter),
                            PtrDef,
                            StackFrames,
                            Frames,
                            g_ExtThread,
                            0,
                            FALSE);

    for (i=0; i<FrameCount; i++)
    {
        ExtStackFrames[i].FramePointer    =  (ULONG)StackFrames[i].FrameOffset;
        ExtStackFrames[i].ProgramCounter  =  (ULONG)StackFrames[i].InstructionOffset;
        ExtStackFrames[i].ReturnAddress   =  (ULONG)StackFrames[i].ReturnOffset;
        ExtStackFrames[i].Args[0]         =  (ULONG)StackFrames[i].Params[0];
        ExtStackFrames[i].Args[1]         =  (ULONG)StackFrames[i].Params[1];
        ExtStackFrames[i].Args[2]         =  (ULONG)StackFrames[i].Params[2];
        ExtStackFrames[i].Args[3]         =  (ULONG)StackFrames[i].Params[3];
    }

    free( StackFrames );
    if (g_ExtThreadScopeSaved)
    {
        PopScope(&g_ExtThreadSavedScope);
        g_ExtThreadScopeSaved = FALSE;
    }

    g_ExtThread = 0;

    return FrameCount;
}

BOOL
ExtIoctl(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    )
{
    HRESULT            Status;
    BOOL               Bool;
    DWORD              cb = 0;
    PPHYSICAL          phy;
    PPHYSICAL_WITH_FLAGS phyf;
    PIOSPACE64         is;
    PIOSPACE_EX64      isex;
    PBUSDATA           busdata;
    PREAD_WRITE_MSR    msr;
    PREADCONTROLSPACE64 prc;
    PPROCESSORINFO     pi;
    PSEARCHMEMORY      psr;
    PSYM_DUMP_PARAM    pSym;
    PGET_CURRENT_THREAD_ADDRESS pct;
    PGET_CURRENT_PROCESS_ADDRESS pcp;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    if (!g_Target)
    {
        return FALSE;
    }

    switch( IoctlType )
    {
    case IG_KD_CONTEXT:
        if (!g_Target)
        {
            return FALSE;
        }
        pi = (PPROCESSORINFO) lpvData;
        pi->Processor = (USHORT)CURRENT_PROC;
        pi->NumberProcessors = (USHORT) g_Target->m_NumProcessors;
        return TRUE;

    case IG_READ_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_CUR_MACHINE_ACCESSIBLE())
        {
            g_Target->FlushRegContext();
        }

        prc = (PREADCONTROLSPACE64)lpvData;
        Status = g_Target->ReadControl( prc->Processor,
                                        prc->Address,
                                        prc->Buf,
                                        prc->BufLen,
                                        &cb
                                        );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_WRITE_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_CUR_MACHINE_ACCESSIBLE())
        {
            g_Target->FlushRegContext();
        }

        prc = (PREADCONTROLSPACE64)lpvData;
        Status = g_Target->WriteControl( prc->Processor,
                                         prc->Address,
                                         prc->Buf,
                                         prc->BufLen,
                                         &cb
                                         );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_READ_IO_SPACE:
        is = (PIOSPACE64)lpvData;
        Status = g_Target->ReadIo( Isa, 0, 1, is->Address, &is->Data,
                                   is->Length, &cb );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE:
        is = (PIOSPACE64)lpvData;
        Status = g_Target->WriteIo( Isa, 0, 1, is->Address, &is->Data,
                                    is->Length, &cb );
        return Status == S_OK;

    case IG_READ_IO_SPACE_EX:
        isex = (PIOSPACE_EX64)lpvData;
        Status = g_Target->ReadIo( isex->InterfaceType,
                                   isex->BusNumber,
                                   isex->AddressSpace,
                                   isex->Address,
                                   &isex->Data,
                                   isex->Length,
                                   &cb
                                   );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE_EX:
        isex = (PIOSPACE_EX64)lpvData;
        Status = g_Target->WriteIo( isex->InterfaceType,
                                    isex->BusNumber,
                                    isex->AddressSpace,
                                    isex->Address,
                                    &isex->Data,
                                    isex->Length,
                                    &cb
                                    );
        return Status == S_OK;

    case IG_READ_PHYSICAL:
        phy = (PPHYSICAL)lpvData;
        Bool =
            ExtReadPhysicalMemory( phy->Address, phy->Buf, phy->BufLen, &cb );
        phy->BufLen = cb;
        return Bool;

    case IG_WRITE_PHYSICAL:
        phy = (PPHYSICAL)lpvData;
        Bool =
            ExtWritePhysicalMemory( phy->Address, phy->Buf, phy->BufLen, &cb );
        phy->BufLen = cb;
        return Bool;

    case IG_READ_PHYSICAL_WITH_FLAGS:
        phyf = (PPHYSICAL_WITH_FLAGS)lpvData;
        Bool =
            ExtReadPhysicalMemoryWithFlags( phyf->Address, phyf->Buf,
                                            phyf->BufLen, phyf->Flags,
                                            &cb );
        phyf->BufLen = cb;
        return Bool;

    case IG_WRITE_PHYSICAL_WITH_FLAGS:
        phyf = (PPHYSICAL_WITH_FLAGS)lpvData;
        Bool =
            ExtWritePhysicalMemoryWithFlags( phyf->Address, phyf->Buf,
                                             phyf->BufLen, phyf->Flags,
                                             &cb );
        phyf->BufLen = cb;
        return Bool;

    case IG_LOWMEM_CHECK:
        Status = g_Target->CheckLowMemory();
        return Status == S_OK;

    case IG_SEARCH_MEMORY:
        psr = (PSEARCHMEMORY)lpvData;
        Status = g_Target->SearchVirtual(g_Process,
                                         psr->SearchAddress,
                                         psr->SearchLength,
                                         psr->Pattern,
                                         psr->PatternLength,
                                         1,
                                         &psr->FoundAddress);
        return Status == S_OK;

    case IG_SET_THREAD:
        Bool = FALSE;
        if (IS_KERNEL_TARGET(g_Target))
        {
            // Turn off engine notifications since this setthread is temporary
            g_EngNotify++;
            PushScope(&g_ExtThreadSavedScope);
            g_ExtThread = *(PULONG64)lpvData;
            Bool = SetScopeContextFromThreadData(g_ExtThread, FALSE) == S_OK;
            g_ExtThreadScopeSaved = TRUE;
            g_EngNotify--;
        }
        return Bool;

    case IG_READ_MSR:
        msr = (PREAD_WRITE_MSR)lpvData;
        Status = g_Target->ReadMsr(msr->Msr, (PULONG64)&msr->Value);
        return Status == S_OK;

    case IG_WRITE_MSR:
        msr = (PREAD_WRITE_MSR)lpvData;
        Status = g_Target->WriteMsr(msr->Msr, msr->Value);
        return Status == S_OK;

    case IG_GET_KERNEL_VERSION:
        if (!g_Target)
        {
            return FALSE;
        }
        *((PDBGKD_GET_VERSION64)lpvData) = g_Target->m_KdVersion;
        return TRUE;

    case IG_GET_BUS_DATA:
        busdata = (PBUSDATA)lpvData;
        Status = g_Target->ReadBusData( busdata->BusDataType,
                                        busdata->BusNumber,
                                        busdata->SlotNumber,
                                        busdata->Offset,
                                        busdata->Buffer,
                                        busdata->Length,
                                        &cb
                                        );
        busdata->Length = cb;
        return Status == S_OK;

    case IG_SET_BUS_DATA:
        busdata = (PBUSDATA)lpvData;
        Status = g_Target->WriteBusData( busdata->BusDataType,
                                         busdata->BusNumber,
                                         busdata->SlotNumber,
                                         busdata->Offset,
                                         busdata->Buffer,
                                         busdata->Length,
                                         &cb
                                         );
        busdata->Length = cb;
        return Status == S_OK;

    case IG_GET_CURRENT_THREAD:
        if (!g_Target)
        {
            return FALSE;
        }
        pct = (PGET_CURRENT_THREAD_ADDRESS) lpvData;
        return g_Target->
            GetThreadInfoDataOffset(NULL,
                                    VIRTUAL_THREAD_HANDLE(pct->Processor),
                                    &pct->Address) == S_OK;

    case IG_GET_CURRENT_PROCESS:
        if (!g_Target)
        {
            return FALSE;
        }
        pcp = (PGET_CURRENT_PROCESS_ADDRESS) lpvData;
        return g_Target->
            GetProcessInfoDataOffset(NULL,
                                     pcp->Processor,
                                     pcp->CurrentThread,
                                     &pcp->Address) == S_OK;

    case IG_GET_DEBUGGER_DATA:
        if (!IS_KERNEL_TARGET(g_Target) ||
            !g_Target ||
            ((PDBGKD_DEBUG_DATA_HEADER64)lpvData)->OwnerTag != KDBG_TAG)
        {
            return FALSE;
        }

        // Don't refresh if asking for the kernel header.

        memcpy(lpvData, &g_Target->m_KdDebuggerData,
               min(sizeof(g_Target->m_KdDebuggerData), cbSize));
        return TRUE;

    case IG_RELOAD_SYMBOLS:
        PCSTR ArgsRet;
        return g_Target->Reload(g_Thread, (PCHAR)lpvData, &ArgsRet) == S_OK;

    case IG_GET_SET_SYMPATH:
        PGET_SET_SYMPATH pgs;
        pgs = (PGET_SET_SYMPATH)lpvData;
        ChangeSymPath((PCHAR)pgs->Args, FALSE, (PCHAR)pgs->Result,
                      pgs->Length);
        return TRUE;

    case IG_IS_PTR64:
        if (!g_Target)
        {
            return FALSE;
        }
        *((PBOOL)lpvData) = g_Target->m_Machine->m_Ptr64;
        return TRUE;

    case IG_DUMP_SYMBOL_INFO:
        if (!g_Process)
        {
            return FALSE;
        }
        pSym = (PSYM_DUMP_PARAM) lpvData;
        SymbolTypeDump(g_Process->m_SymHandle,
                       g_Process->m_ImageHead,
                       pSym, (PULONG)&Status);
        return (BOOL)(ULONG)Status;

    case IG_GET_TYPE_SIZE:
        if (!g_Process)
        {
            return FALSE;
        }
        pSym = (PSYM_DUMP_PARAM) lpvData;
        return SymbolTypeDump(g_Process->m_SymHandle,
                              g_Process->m_ImageHead,
                              pSym, (PULONG)&Status);

    case IG_GET_TEB_ADDRESS:
        if (!g_Target)
        {
            return FALSE;
        }
        PGET_TEB_ADDRESS pTeb;
        pTeb = (PGET_TEB_ADDRESS) lpvData;
        return g_Target->
            GetThreadInfoTeb(g_Thread,
                             CURRENT_PROC,
                             0,
                             &pTeb->Address) == S_OK;

    case IG_GET_PEB_ADDRESS:
        if (!g_Target)
        {
            return FALSE;
        }
        PGET_PEB_ADDRESS pPeb;
        pPeb = (PGET_PEB_ADDRESS) lpvData;
        return g_Target->
            GetProcessInfoPeb(g_Thread,
                              CURRENT_PROC,
                              pPeb->CurrentThread,
                              &pPeb->Address) == S_OK;

    case IG_GET_CURRENT_PROCESS_HANDLE:
        if (!g_Process)
        {
            return FALSE;
        }
        *(PHANDLE)lpvData = OS_HANDLE(g_Process->m_SysHandle);
        return TRUE;

    case IG_GET_INPUT_LINE:
        PGET_INPUT_LINE Gil;
        Gil = (PGET_INPUT_LINE)lpvData;
        Gil->InputSize = GetInput(Gil->Prompt, Gil->Buffer, Gil->BufferSize,
                                  GETIN_LOG_INPUT_LINE);
        return TRUE;

    case IG_GET_EXPRESSION_EX:
        PGET_EXPRESSION_EX Gee;
        Gee = (PGET_EXPRESSION_EX)lpvData;
        Gee->Value = ExtGetExpression(Gee->Expression);
        Gee->Remainder = Gee->Expression + g_ExtGetExpressionRemainderIndex;
        return g_ExtGetExpressionSuccess;

    case IG_TRANSLATE_VIRTUAL_TO_PHYSICAL:
        if (!IS_CUR_MACHINE_ACCESSIBLE())
        {
            return FALSE;
        }
        PTRANSLATE_VIRTUAL_TO_PHYSICAL Tvtp;
        Tvtp = (PTRANSLATE_VIRTUAL_TO_PHYSICAL)lpvData;
        ULONG Levels, PfIndex;
        return g_Machine->
            GetVirtualTranslationPhysicalOffsets(g_Thread,
                                                 Tvtp->Virtual, NULL, 0,
                                                 &Levels, &PfIndex,
                                                 &Tvtp->Physical) == S_OK;

    case IG_GET_CACHE_SIZE:
        if (!g_Process)
        {
            return FALSE;
        }
        PULONG64 pCacheSize;

        pCacheSize = (PULONG64)lpvData;
        if (IS_KERNEL_TARGET(g_Target))
        {
            *pCacheSize = g_Process->m_VirtualCache.m_MaxSize;
            return TRUE;
        }
        return FALSE;

    case IG_POINTER_SEARCH_PHYSICAL:
        if (!IS_CUR_MACHINE_ACCESSIBLE())
        {
            return FALSE;
        }

        PPOINTER_SEARCH_PHYSICAL Psp;
        Psp = (PPOINTER_SEARCH_PHYSICAL)lpvData;
        return g_Target->PointerSearchPhysical(Psp->Offset,
                                               Psp->Length,
                                               Psp->PointerMin,
                                               Psp->PointerMax,
                                               Psp->Flags,
                                               Psp->MatchOffsets,
                                               Psp->MatchOffsetsSize,
                                               &Psp->MatchOffsetsCount) ==
            S_OK;

    case IG_GET_COR_DATA_ACCESS:
        if (cbSize != sizeof(void*) ||
            !g_Process ||
            g_Process->LoadCorDebugDll() != S_OK)
        {
            return FALSE;
        }

        *(ICorDataAccess**)lpvData = g_Process->m_CorAccess;
        return TRUE;

    default:
        ErrOut( "\n*** Bad IOCTL request from an extension [%d]\n\n",
                IoctlType );
        return FALSE;
    }

    // NOTREACHED.
    DBG_ASSERT(FALSE);
    return FALSE;
}

BOOL
ExtIoctl32(
    USHORT   IoctlType,
    LPVOID   lpvData,
    DWORD    cbSize
    )
/*++

Routine Description:

    This is the extension Ioctl routine for backward compatibility with
    old extension dlls.  This routine is frozen, and new ioctl support
    should not be added to it.

Arguments:


Return Value:

--*/
{
    HRESULT            Status;
    DWORD              cb = 0;
    PIOSPACE32         is;
    PIOSPACE_EX32      isex;
    PREADCONTROLSPACE  prc;
    PDBGKD_GET_VERSION32 pv32;
    PKDDEBUGGER_DATA32   pdbg32;

    // Make sure output for long-running extensions appears regularly.
    TimedFlushCallbacks();

    switch( IoctlType )
    {
    case IG_READ_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_CUR_MACHINE_ACCESSIBLE())
        {
            g_Target->FlushRegContext();
        }

        prc = (PREADCONTROLSPACE)lpvData;
        Status = g_Target->ReadControl( prc->Processor,
                                        prc->Address,
                                        prc->Buf,
                                        prc->BufLen,
                                        &cb
                                        );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_WRITE_CONTROL_SPACE:
        // KSPECIAL_REGISTER content is kept in control space
        // so accessing control space may touch data that's
        // cached in the current machine KSPECIAL_REGISTERS.
        // Flush the current machine to maintain consistency.
        if (IS_CUR_MACHINE_ACCESSIBLE())
        {
            g_Target->FlushRegContext();
        }

        prc = (PREADCONTROLSPACE)lpvData;
        Status = g_Target->WriteControl( prc->Processor,
                                         prc->Address,
                                         prc->Buf,
                                         prc->BufLen,
                                         &cb
                                         );
        prc->BufLen = cb;
        return Status == S_OK;

    case IG_READ_IO_SPACE:
        is = (PIOSPACE32)lpvData;
        Status = g_Target->ReadIo( Isa, 0, 1, is->Address, &is->Data,
                                   is->Length, &cb );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE:
        is = (PIOSPACE32)lpvData;
        Status = g_Target->WriteIo( Isa, 0, 1, is->Address, &is->Data,
                                    is->Length, &cb );
        return Status == S_OK;

    case IG_READ_IO_SPACE_EX:
        isex = (PIOSPACE_EX32)lpvData;
        Status = g_Target->ReadIo( isex->InterfaceType,
                                   isex->BusNumber,
                                   isex->AddressSpace,
                                   isex->Address,
                                   &isex->Data,
                                   isex->Length,
                                   &cb
                                   );
        return Status == S_OK;

    case IG_WRITE_IO_SPACE_EX:
        isex = (PIOSPACE_EX32)lpvData;
        Status = g_Target->WriteIo( isex->InterfaceType,
                                    isex->BusNumber,
                                    isex->AddressSpace,
                                    isex->Address,
                                    &isex->Data,
                                    isex->Length,
                                    &cb
                                    );
        return Status == S_OK;

    case IG_SET_THREAD:
        if (IS_KERNEL_TARGET(g_Target))
        {
            g_EngNotify++; // Turn off engine notifications since this setthread is temporary
            g_ExtThread = EXTEND64(*(PULONG)lpvData);
            PushScope(&g_ExtThreadSavedScope);
            SetScopeContextFromThreadData(g_ExtThread, FALSE);
            g_ExtThreadScopeSaved = TRUE;
            g_EngNotify--;
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    case IG_GET_KERNEL_VERSION:
        if (!g_Target)
        {
            return FALSE;
        }

        //
        // Convert to 32 bit
        //

        pv32 = (PDBGKD_GET_VERSION32)lpvData;

        pv32->MajorVersion    = g_Target->m_KdVersion.MajorVersion;
        pv32->MinorVersion    = g_Target->m_KdVersion.MinorVersion;
        pv32->ProtocolVersion = g_Target->m_KdVersion.ProtocolVersion;
        pv32->Flags           = g_Target->m_KdVersion.Flags;

        pv32->KernBase           =
            (ULONG)g_Target->m_KdVersion.KernBase;
        pv32->PsLoadedModuleList =
            (ULONG)g_Target->m_KdVersion.PsLoadedModuleList;
        pv32->MachineType        =
            g_Target->m_KdVersion.MachineType;
        pv32->DebuggerDataList   =
            (ULONG)g_Target->m_KdVersion.DebuggerDataList;

        pv32->ThCallbackStack = g_Target->m_KdDebuggerData.ThCallbackStack;
        pv32->NextCallback    = g_Target->m_KdDebuggerData.NextCallback;
        pv32->FramePointer    = g_Target->m_KdDebuggerData.FramePointer;

        pv32->KiCallUserMode =
            (ULONG)g_Target->m_KdDebuggerData.KiCallUserMode;
        pv32->KeUserCallbackDispatcher =
            (ULONG)g_Target->m_KdDebuggerData.KeUserCallbackDispatcher;
        pv32->BreakpointWithStatus =
            (ULONG)g_Target->m_KdDebuggerData.BreakpointWithStatus;
        return TRUE;

    case IG_GET_DEBUGGER_DATA:
        if (!IS_KERNEL_TARGET(g_Target) ||
            !g_Target ||
            ((PDBGKD_DEBUG_DATA_HEADER32)lpvData)->OwnerTag != KDBG_TAG)
        {
            return FALSE;
        }

        // Don't refresh if asking for the kernel header.

        pdbg32 = (PKDDEBUGGER_DATA32)lpvData;

        pdbg32->Header.List.Flink =
            (ULONG)g_Target->m_KdDebuggerData.Header.List.Flink;
        pdbg32->Header.List.Blink =
            (ULONG)g_Target->m_KdDebuggerData.Header.List.Blink;
        pdbg32->Header.OwnerTag = KDBG_TAG;
        pdbg32->Header.Size = sizeof(KDDEBUGGER_DATA32);

#undef UIP
#undef CP
#define UIP(f) pdbg32->f = (ULONG)(g_Target->m_KdDebuggerData.f)
#define CP(f) pdbg32->f = (g_Target->m_KdDebuggerData.f)

        UIP(KernBase);
        UIP(BreakpointWithStatus);
        UIP(SavedContext);
        CP(ThCallbackStack);
        CP(NextCallback);
        CP(FramePointer);
        CP(PaeEnabled);
        UIP(KiCallUserMode);
        UIP(KeUserCallbackDispatcher);
        UIP(PsLoadedModuleList);
        UIP(PsActiveProcessHead);
        UIP(PspCidTable);
        UIP(ExpSystemResourcesList);
        UIP(ExpPagedPoolDescriptor);
        UIP(ExpNumberOfPagedPools);
        UIP(KeTimeIncrement);
        UIP(KeBugCheckCallbackListHead);
        UIP(KiBugcheckData);
        UIP(IopErrorLogListHead);
        UIP(ObpRootDirectoryObject);
        UIP(ObpTypeObjectType);
        UIP(MmSystemCacheStart);
        UIP(MmSystemCacheEnd);
        UIP(MmSystemCacheWs);
        UIP(MmPfnDatabase);
        UIP(MmSystemPtesStart);
        UIP(MmSystemPtesEnd);
        UIP(MmSubsectionBase);
        UIP(MmNumberOfPagingFiles);
        UIP(MmLowestPhysicalPage);
        UIP(MmHighestPhysicalPage);
        UIP(MmNumberOfPhysicalPages);
        UIP(MmMaximumNonPagedPoolInBytes);
        UIP(MmNonPagedSystemStart);
        UIP(MmNonPagedPoolStart);
        UIP(MmNonPagedPoolEnd);
        UIP(MmPagedPoolStart);
        UIP(MmPagedPoolEnd);
        UIP(MmPagedPoolInformation);
        UIP(MmPageSize);
        UIP(MmSizeOfPagedPoolInBytes);
        UIP(MmTotalCommitLimit);
        UIP(MmTotalCommittedPages);
        UIP(MmSharedCommit);
        UIP(MmDriverCommit);
        UIP(MmProcessCommit);
        UIP(MmPagedPoolCommit);
        UIP(MmExtendedCommit);
        UIP(MmZeroedPageListHead);
        UIP(MmFreePageListHead);
        UIP(MmStandbyPageListHead);
        UIP(MmModifiedPageListHead);
        UIP(MmModifiedNoWritePageListHead);
        UIP(MmAvailablePages);
        UIP(MmResidentAvailablePages);
        UIP(PoolTrackTable);
        UIP(NonPagedPoolDescriptor);
        UIP(MmHighestUserAddress);
        UIP(MmSystemRangeStart);
        UIP(MmUserProbeAddress);
        UIP(KdPrintCircularBuffer);
        UIP(KdPrintCircularBufferEnd);
        UIP(KdPrintWritePointer);
        UIP(KdPrintRolloverCount);
        UIP(MmLoadedUserImageList);
        //
        // DO NOT ADD ANY FIELDS HERE
        // The 32 bit structure should not be changed
        //
        return TRUE;

    case IG_KD_CONTEXT:
    case IG_READ_PHYSICAL:
    case IG_WRITE_PHYSICAL:
    case IG_READ_PHYSICAL_WITH_FLAGS:
    case IG_WRITE_PHYSICAL_WITH_FLAGS:
    case IG_LOWMEM_CHECK:
    case IG_SEARCH_MEMORY:
    case IG_READ_MSR:
    case IG_WRITE_MSR:
    case IG_GET_BUS_DATA:
    case IG_SET_BUS_DATA:
    case IG_GET_CURRENT_THREAD:
    case IG_GET_CURRENT_PROCESS:
    case IG_RELOAD_SYMBOLS:
    case IG_GET_SET_SYMPATH:
    case IG_IS_PTR64:
    case IG_DUMP_SYMBOL_INFO:
    case IG_GET_TYPE_SIZE:
    case IG_GET_TEB_ADDRESS:
    case IG_GET_PEB_ADDRESS:
    case IG_GET_INPUT_LINE:
    case IG_GET_EXPRESSION_EX:
    case IG_TRANSLATE_VIRTUAL_TO_PHYSICAL:
    case IG_POINTER_SEARCH_PHYSICAL:
    case IG_GET_COR_DATA_ACCESS:
        // All of these ioctls are handled identically for
        // 32 and 64 bits.  Avoid duplicating all the code.
        return ExtIoctl(IoctlType, lpvData, cbSize);

    default:
        ErrOut( "\n*** Bad IOCTL32 request from an extension [%d]\n\n",
                IoctlType );
        return FALSE;
    }

    // NOTREACHED.
    DBG_ASSERT(FALSE);
    return FALSE;
}

//----------------------------------------------------------------------------
//
// Extension management.
//
//----------------------------------------------------------------------------

DebugClient*
FindExtClient(void)
{
    DebugClient* Client;

    //
    // Try to find the most appropriate client for
    // executing an extension command on.  The first
    // choice is the session client, then any local
    // primary client, then any primary client.
    //

    if (!(Client = FindClient(g_SessionThread, CLIENT_PRIMARY, 0)) &&
        !(Client = FindClient(0, CLIENT_PRIMARY, CLIENT_REMOTE)) &&
        !(Client = FindClient(0, CLIENT_PRIMARY, 0)))
    {
        Client = g_Clients;
    }

    return Client;
}

LONG
ExtensionExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo,
                         PCSTR Module,
                         PCSTR Func)
{
    // Any references to objects will be leaked.
    // There's not much the engine can do about this, although
    // it would be possible to record old refcounts and
    // try to restore them.

    if (Module != NULL && Func != NULL)
    {
        ErrOut("%08x Exception in %s.%s debugger extension.\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               Module,
               Func
               );
    }
    else
    {
        ErrOut("%08x Exception in debugger client %s callback.\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               Func
               );
    }

    ErrOut("      PC: %s  VA: %s  R/W: %x  Parameter: %s\n",
           FormatAddr64((ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress),
           FormatAddr64(ExceptionInfo->ExceptionRecord->ExceptionInformation[1]),
           ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
           FormatAddr64(ExceptionInfo->ExceptionRecord->ExceptionInformation[2])
           );

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL
CallExtension(DebugClient* Client,
              EXTDLL *Ext,
              PSTR Func,
              PCSTR Args,
              HRESULT* ExtStatus)
{
    FARPROC Routine;
    ADDR TempAddr;

    if (IS_KERNEL_TARGET(g_Target))
    {
        _strlwr(Func);
    }

    Routine = GetProcAddress(Ext->Dll, Func);
    if (Routine == NULL)
    {
        return FALSE;
    }

    if (!(g_EnvDbgOptions & OPTION_NOVERSIONCHECK) && Ext->CheckVersionRoutine)
    {
        Ext->CheckVersionRoutine();
    }

    if (IS_KERNEL_TARGET(g_Target) && !strcmp(Func, "version"))
    {
        //
        // This is a bit of a hack to avoid a problem with the
        // extension version checking.  Extension version checking
        // comes before the KD connection is established so there's
        // no register context.  If the version checking fails it
        // prints out version information, which tries to call
        // version extensions, which will get here when there's
        // no register context.
        //
        // To work around this, just pass zero to the version extension
        // function since it presumably doesn't care about the
        // address.
        //
        ADDRFLAT(&TempAddr, 0);
    }
    else if (IS_CONTEXT_POSSIBLE(g_Target))
    {
        g_Machine->GetPC(&TempAddr);
    }
    else
    {
        if (!IS_LOCAL_KERNEL_TARGET(g_Target))
        {
            WarnOut("Extension called without current PC\n");
        }

        ADDRFLAT(&TempAddr, 0);
    }

    *ExtStatus = S_OK;

    __try
    {
        HANDLE ProcHandle, ThreadHandle;

        if (g_Process)
        {
            ProcHandle = OS_HANDLE(g_Process->m_SysHandle);
        }
        else
        {
            ProcHandle = NULL;
        }
        if (g_Thread)
        {
            ThreadHandle = OS_HANDLE(g_Thread->m_Handle);
        }
        else
        {
            ThreadHandle = NULL;
        }

        switch(Ext->ExtensionType)
        {
        case NTSD_EXTENSION_TYPE:
            //
            // NOTE:
            // Eventhough this type should receive an NTSD_EXTENSION_API
            // structure, ntsdexts.dll (and possibly others) depend on
            // receiving the WinDBG version of the extensions, because they
            // check the size of the structure, and actually use some of the
            // newer exports.  This works because the WinDBG extension API was
            // a superset of the NTSD version.
            //

            ((PNTSD_EXTENSION_ROUTINE)Routine)
                (ProcHandle,
                 ThreadHandle,
                 (ULONG)Flat(TempAddr),
                 g_Target->m_Machine->m_Ptr64 ?
                 (PNTSD_EXTENSION_APIS)&g_WindbgExtensions64 :
                 (PNTSD_EXTENSION_APIS)&g_WindbgExtensions32,
                 (PSTR)Args
                 );
            break;

        case DEBUG_EXTENSION_TYPE:
            if (Client == NULL)
            {
                Client = FindExtClient();
            }
            if (Client == NULL)
            {
                ErrOut("Unable to call client-style extension "
                       "without a client\n");
            }
            else
            {
                *ExtStatus = ((PDEBUG_EXTENSION_CALL)Routine)
                    ((PDEBUG_CLIENT)(IDebugClientN *)Client, Args);
            }
            break;

        case WINDBG_EXTENSION_TYPE:
            //
            // Support Windbg type extensions for ntsd too
            //
            if (Ext->ApiVersion.Revision < 6 )
            {
                ((PWINDBG_EXTENSION_ROUTINE32)Routine) (
                   ProcHandle,
                   ThreadHandle,
                   (ULONG)Flat(TempAddr),
                   CURRENT_PROC,
                   Args
                   );
            }
            else
            {
                ((PWINDBG_EXTENSION_ROUTINE64)Routine) (
                   ProcHandle,
                   ThreadHandle,
                   Flat(TempAddr),
                   CURRENT_PROC,
                   Args
                   );
            }
            break;

        case WINDBG_OLDKD_EXTENSION_TYPE:
            ((PWINDBG_OLDKD_EXTENSION_ROUTINE)Routine) (
                (ULONG)Flat(TempAddr),
                &g_KdExtensions,
                Args
                );
            break;
        }
    }
    __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                      Ext->Name, Func))
    {
        ;
    }

    return TRUE;
}

void
LinkExtensionDll(EXTDLL* Ext)
{
    // Put user-loaded DLLs before default DLLs.
    if (Ext->UserLoaded)
    {
        Ext->Next = g_ExtDlls;
        g_ExtDlls = Ext;
    }
    else
    {
        EXTDLL* Prev;
        EXTDLL* Cur;

        Prev = NULL;
        for (Cur = g_ExtDlls; Cur != NULL; Cur = Cur->Next)
        {
            if (!Cur->UserLoaded)
            {
                break;
            }

            Prev = Cur;
        }

        Ext->Next = Cur;
        if (Prev == NULL)
        {
            g_ExtDlls = Ext;
        }
        else
        {
            Prev->Next = Ext;
        }
    }
}

EXTDLL *
AddExtensionDll(char *Name, BOOL UserLoaded, TargetInfo* Target,
                char **End)
{
    EXTDLL *Ext;
    ULONG Len;
    char *Last;

    while (*Name == ' ' || *Name == '\t')
    {
        Name++;
    }
    if (*Name == 0)
    {
        ErrOut("No extension DLL name provided\n");
        return NULL;
    }

    Len = strlen(Name);
    if (End != NULL)
    {
        *End = Name + Len;
    }

    Last = Name + (Len - 1);
    while (Last >= Name && (*Last == ' ' || *Last == '\t'))
    {
        Last--;
    }
    Len = (ULONG)((Last + 1) - Name);

    // See if it's already in the list.
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if ((!Target || Target == Ext->Target) &&
            strlen(Ext->Name) == Len &&
            !_memicmp(Name, Ext->Name, Len))
        {
            return Ext;
        }
    }

    Ext = (EXTDLL *)malloc(sizeof(EXTDLL) + Len);
    if (Ext == NULL)
    {
        ErrOut("Unable to allocate memory for extension DLL\n");
        return NULL;
    }

    ZeroMemory(Ext, sizeof(EXTDLL) + Len);
    memcpy(Ext->Name, Name, Len + 1);
    Ext->UserLoaded = UserLoaded;
    Ext->Target = Target;

    LinkExtensionDll(Ext);

    NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
    return Ext;
}

PCTSTR
BuildExtensionSearchPath(TargetInfo* Target)
{
    DWORD Size;
    DWORD TotalSize;
    CHAR  ExeDir[MAX_PATH];
    int   ExeRootLen;
    PSTR  OsDirPath;
    CHAR  OsDirTail[32];
    BOOL  PriPaths = FALSE;
    BOOL  WinPaths = FALSE;
    PSTR  NewPath;

    //
    // If we are not connected, don't build a path, since we have to pick
    // up extensions based on the OS version.
    //
    if (Target && Target->m_ActualSystemVersion == SVER_INVALID)
    {
        return NULL;
    }

    //
    // If we already have a search path, do not rebuild it.
    //

    if (Target)
    {
        if (Target->m_ExtensionSearchPath)
        {
            return Target->m_ExtensionSearchPath;
        }
    }
    else
    {
        if (g_BaseExtensionSearchPath)
        {
            return g_BaseExtensionSearchPath;
        }
    }

    // Get the directory the debugger executable is in.
    // -8 because we assume we're adding \w2kfre to the path.
    if (!GetEngineDirectory(ExeDir, MAX_PATH - 8))
    {
        // Error.  Using the current directory.
        ExeRootLen = 1;
    }
    else
    {
        if (ExeDir[0] == '\\' && ExeDir[1] == '\\')
        {
            PSTR ExeRootEnd;

            // UNC path root.
            ExeRootEnd = strchr(ExeDir + 2, '\\');
            if (ExeRootEnd != NULL)
            {
                ExeRootEnd = strchr(ExeRootEnd + 1, '\\');
            }
            if (ExeRootEnd == NULL)
            {
                ExeRootLen = strlen(ExeDir);
            }
            else
            {
                ExeRootLen = (int)(ExeRootEnd - ExeDir);
            }
        }
        else
        {
            // Drive letter and colon root.
            ExeRootLen = 2;
        }
    }

    //
    // Calc how much space we will need to use.
    //
    // Leave extra room for the current directory, path, and directory of
    // where debugger extensions are located.
    //

    TotalSize = GetEnvironmentVariable("PATH", NULL, 0) +
        GetEnvironmentVariable("_NT_DEBUGGER_EXTENSION_PATH",
                               NULL, 0) + MAX_PATH * 4;

    NewPath = (LPTSTR)calloc(TotalSize, sizeof(TCHAR));
    if (!NewPath)
    {
        return NULL;
    }
    *NewPath = 0;

    //
    // 1 - User specified search path
    //

    if (GetEnvironmentVariable("_NT_DEBUGGER_EXTENSION_PATH",
                               NewPath, TotalSize - 2))
    {
        CatString(NewPath, ";", TotalSize);
    }

    // Generate default path for the exe dir
    // Skip root as it is already taken from ExeDir.
    OsDirPath = ExeDir + ExeRootLen;
    if (*OsDirPath == '\\')
    {
        OsDirPath++;
    }

    //
    // Figure out whether we need NT6, or NT5/NT4 free or checked extensions
    //

    if (!Target)
    {
        OsDirPath = "";
        OsDirTail[0] = 0;
    }
    else if (Target->m_ActualSystemVersion > BIG_SVER_START &&
             Target->m_ActualSystemVersion < BIG_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "BIG");
    }
    else if (Target->m_ActualSystemVersion > XBOX_SVER_START &&
             Target->m_ActualSystemVersion < XBOX_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "XBox");
    }
    else if (Target->m_ActualSystemVersion > NTBD_SVER_START &&
             Target->m_ActualSystemVersion < NTBD_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "NtBd");
    }
    else if (Target->m_ActualSystemVersion > EFI_SVER_START &&
             Target->m_ActualSystemVersion < EFI_SVER_END)
    {
        OsDirPath = "DbgExt";
        strcpy(OsDirTail, "EFI");
    }
    else if (Target->m_ActualSystemVersion > W9X_SVER_START &&
             Target->m_ActualSystemVersion < W9X_SVER_END)
    {
        strcpy(OsDirTail, "Win9X");
        WinPaths = TRUE;
    }
    else if (Target->m_ActualSystemVersion > WCE_SVER_START &&
             Target->m_ActualSystemVersion < WCE_SVER_END)
    {
        strcpy(OsDirTail, "WinCE");
        WinPaths = TRUE;
    }
    else
    {
        // Treat everything else as an NT system.  Use
        // the translated system version now rather than
        // the actual system version.

        PriPaths = TRUE;
        WinPaths = TRUE;

        if (Target->m_SystemVersion > NT_SVER_W2K)
        {
            strcpy(OsDirTail, "WINXP");
        }
        else
        {
            if (Target->m_SystemVersion <= NT_SVER_NT4)
            {
                strcpy(OsDirTail, "NT4");
            }
            else
            {
                strcpy(OsDirTail, "W2K");
            }

            if (0xC == Target->m_CheckedBuild)
            {
                strcat(OsDirTail, "Chk");
            }
            else
            {
                strcat(OsDirTail, "Fre");
            }
        }
    }

    //
    // 2 - OS specific subdirectories from where we launched the debugger.
    // 3 - pri subdirectory from where we launched the debugger.
    // 4 - Directory from where we launched the debugger.
    //

    PSTR End;

    Size = strlen(NewPath);
    End = NewPath + Size;
    memcpy(End, ExeDir, ExeRootLen);
    End += ExeRootLen;
    TotalSize -= Size + ExeRootLen;
    if (*OsDirPath)
    {
        if (TotalSize)
        {
            *End++ = '\\';
            TotalSize--;
        }
        CopyString(End, OsDirPath, TotalSize);
        Size = strlen(End);
        End += Size;
        TotalSize -= Size;
    }
    if (WinPaths)
    {
        PrintString(End, TotalSize, "\\winext;%s", ExeDir);
        Size = strlen(End);
        End += Size;
        TotalSize -= Size;
    }
    if (*OsDirTail)
    {
        PrintString(End, TotalSize, "\\%s;%s", OsDirTail, ExeDir);
        Size = strlen(End);
        End += Size;
        TotalSize -= Size;
    }
    if (PriPaths)
    {
        PrintString(End, TotalSize, "\\pri;%s", ExeDir);
        Size = strlen(End);
        End += Size;
        TotalSize -= Size;
    }

    if (*--End == ':')
    {
        *++End = '\\';
    }
    else
    {
        TotalSize--;
    }

    if (TotalSize > 1)
    {
        *++End = ';';
        *++End = 0;
        TotalSize -= 2;
    }

    //
    // 4 - Copy environment path
    //

    GetEnvironmentVariable("PATH", End, TotalSize);

    if (Target)
    {
        Target->m_ExtensionSearchPath = NewPath;
    }
    else
    {
        g_BaseExtensionSearchPath = NewPath;
    }
    return NewPath;
}

BOOL
IsAbsolutePath(PCTSTR Path)

/*++

Routine Description:

    Is this path an absolute path? Does not guarentee that the path exists. The
    method is:

        "\\<anything>" is an absolute path

        "{char}:\<anything>" is an absolute path

        anything else is not
--*/

{
    BOOL Ret;

    if ( (Path [0] == '\\' && Path [1] == '\\') ||
         (isalpha ( Path [0] ) && Path [1] == ':' && Path [ 2 ] == '\\') )
    {
        Ret = TRUE;
    }
    else
    {
        Ret = FALSE;
    }

    return Ret;
}

void
FreeExtensionLibrary(EXTDLL* Ext)
{
    FreeLibrary(Ext->Dll);
    Ext->Dll = NULL;

    if (Ext == g_Wow64ExtDll)
    {
        g_Wow64exts = NULL;
        g_Wow64ExtDll = NULL;
    }

    if (Ext == g_WmiExtDll)
    {
        g_WmiFormatTraceData = NULL;
        g_WmiExtDll = NULL;
    }
}

BOOL
LoadExtensionDll(TargetInfo* Target, EXTDLL *Ext)
{
    BOOL Found;
    CHAR ExtPath[_MAX_PATH];

    if (Ext->Dll != NULL)
    {
        // Extension is already loaded.
        return TRUE;
    }

    //
    // Do not allow extensions to be loaded via arbitrary UNC
    // paths when in secure mode.
    //

    if ((g_SymOptions & SYMOPT_SECURE) &&
        ((IS_SLASH(Ext->Name[0]) && IS_SLASH(Ext->Name[1])) ||
         IsUrlPathComponent(Ext->Name)))
    {
        ErrOut("SECURE: UNC paths not allowed for extension DLLs - %s\n",
               Ext->Name);
        return FALSE;
    }

    //
    // If we are not allowing network paths, verify that the extension will
    // not be loaded from a network path.
    //

    if (g_EngOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
    {
        DWORD NetCheck;

        NetCheck = NetworkPathCheck(BuildExtensionSearchPath(Target));

        //
        // Check full path of the extension.
        //

        if (NetCheck != ERROR_FILE_OFFLINE)
        {
            CHAR Drive [ _MAX_DRIVE + 1];
            CHAR Dir [ _MAX_DIR + 1];
            CHAR Path [ _MAX_PATH + 1];

            *Drive = '\000';
            *Dir = '\000';
            _splitpath (Ext->Name, Drive, Dir, NULL, NULL);
            _makepath (Path, Drive, Dir, NULL, NULL);

            NetCheck = NetworkPathCheck (Path);
        }

        if (NetCheck == ERROR_FILE_OFFLINE)
        {
            ErrOut("ERROR: extension search path contains "
                   "network references.\n");
            return FALSE;
        }
    }

    Found = SearchPath(BuildExtensionSearchPath(Target),
                       Ext->Name,
                       ".dll",
                       DIMA(ExtPath),
                       ExtPath,
                       NULL);

    UINT OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( Found )
    {
        Ext->Dll = LoadLibrary(ExtPath);
    }
    else if (IsAbsolutePath(Ext->Name))
    {
        Ext->Dll = LoadLibrary(Ext->Name);
    }

    SetErrorMode(OldMode);

    if (Ext->Dll == NULL)
    {
        HRESULT Status = WIN32_LAST_STATUS();

        ErrOut("The call to LoadLibrary(%s) failed, %s\n    \"%s\"\n"
               "Please check your debugger configuration "
               "and/or network access.\n",
               Ext->Name, FormatStatusCode(Status), FormatStatus(Status));
        return FALSE;
    }

    PCSTR ExtPathTail = PathTail(Ext->Name);

    if (!_stricmp(ExtPathTail, "wow64exts.dll") ||
        !_stricmp(ExtPathTail, "wow64exts"))
    {
        g_Wow64exts = (WOW64EXTSPROC)GetProcAddress(Ext->Dll,"Wow64extsfn");
        DBG_ASSERT(g_Wow64exts);
        g_Wow64ExtDll = Ext;
    }

    if (!_stricmp(ExtPathTail, "wmitrace.dll") ||
        !_stricmp(ExtPathTail, "wmitrace"))
    {
        g_WmiFormatTraceData = (WMI_FORMAT_TRACE_DATA)
            GetProcAddress(Ext->Dll, "WmiFormatTraceData");
        g_WmiExtDll = Ext;
    }

    if (!g_QuietMode)
    {
        VerbOut("Loaded %s extension DLL\n", Ext->Name);
    }

    //
    // Now that the extension is loaded, refresh it.
    //

    Ext->Uninit = NULL;

    PDEBUG_EXTENSION_INITIALIZE EngExt;

    EngExt = (PDEBUG_EXTENSION_INITIALIZE)
        GetProcAddress(Ext->Dll, "DebugExtensionInitialize");
    if (EngExt != NULL)
    {
        ULONG Version, Flags;
        HRESULT Status;

        // This is an engine extension.  Initialize it.

        Status = EngExt(&Version, &Flags);
        if (Status != S_OK)
        {
            ErrOut("%s!DebugExtensionInitialize failed with 0x%08lX\n",
                   Ext->Name, Status);
            goto EH_Free;
        }

        Ext->ApiVersion.MajorVersion = HIWORD(Version);
        Ext->ApiVersion.MinorVersion = LOWORD(Version);
        Ext->ApiVersion.Revision = 0;

        Ext->Notify = (PDEBUG_EXTENSION_NOTIFY)
            GetProcAddress(Ext->Dll, "DebugExtensionNotify");
        Ext->Uninit = (PDEBUG_EXTENSION_UNINITIALIZE)
            GetProcAddress(Ext->Dll, "DebugExtensionUninitialize");

        Ext->ExtensionType = DEBUG_EXTENSION_TYPE;
        Ext->Init = NULL;
        Ext->ApiVersionRoutine = NULL;
        Ext->CheckVersionRoutine = NULL;

        goto VersionCheck;
    }

    Ext->Init = (PWINDBG_EXTENSION_DLL_INIT64)
        GetProcAddress(Ext->Dll, "WinDbgExtensionDllInit");
// Windbg Api
    if (Ext->Init != NULL)
    {
        Ext->ExtensionType = WINDBG_EXTENSION_TYPE;
        Ext->ApiVersionRoutine = (PWINDBG_EXTENSION_API_VERSION)
            GetProcAddress(Ext->Dll, "ExtensionApiVersion");
        if (Ext->ApiVersionRoutine == NULL)
        {
            ErrOut("%s is not a valid windbg extension DLL\n",
                   Ext->Name);
            goto EH_Free;
        }
        Ext->CheckVersionRoutine = (PWINDBG_CHECK_VERSION)
            GetProcAddress(Ext->Dll, "CheckVersion");

        Ext->ApiVersion = *(Ext->ApiVersionRoutine());

        if (Ext->ApiVersion.Revision >= 6)
        {
            (Ext->Init)(&g_WindbgExtensions64,
                        Target ? (USHORT)Target->m_CheckedBuild : 0,
                        Target ? (USHORT)Target->m_BuildNumber : 0);
        }
        else
        {
            (Ext->Init)((PWINDBG_EXTENSION_APIS64)&g_WindbgExtensions32,
                        Target ? (USHORT)Target->m_CheckedBuild : 0,
                        Target ? (USHORT)Target->m_BuildNumber : 0);
        }
    }
    else if (g_SymOptions & SYMOPT_SECURE)
    {
        ErrOut("SECURE: Cannot determine extension DLL type - %s\n",
               Ext->Name);
        goto EH_Free;
    }
    else
    {
        Ext->ApiVersion.Revision = EXT_API_VERSION_NUMBER;
        Ext->ApiVersionRoutine = NULL;
        Ext->CheckVersionRoutine = NULL;
        if (GetProcAddress(Ext->Dll, "NtsdExtensionDllInit"))
        {
            Ext->ExtensionType = NTSD_EXTENSION_TYPE;
        }
        else
        {
            Ext->ExtensionType = IS_KERNEL_TARGET(g_Target) ?
                WINDBG_OLDKD_EXTENSION_TYPE : NTSD_EXTENSION_TYPE;
        }
    }

 VersionCheck:

#if 0
    // Temporarily remove this print statements.

    if (!(g_EnvDbgOptions & OPTION_NOVERSIONCHECK))
    {
        if (Ext->ApiVersion.Revision < 6)
        {
            dprintf("%s uses the old 32 bit extension API and may not be fully\n", Ext->Name);
            dprintf("compatible with current systems.\n");
        }
        else if (Ext->ApiVersion.Revision < EXT_API_VERSION_NUMBER)
        {
            dprintf("%s uses an earlier version of the extension API than that\n", Ext->Name);
            dprintf("supported by this debugger, and should work properly, but there\n");
            dprintf("may be unexpected incompatibilities.\n");
        }
        else if (Ext->ApiVersion.Revision > EXT_API_VERSION_NUMBER)
        {
            dprintf("%s uses a later version of the extension API than that\n", Ext->Name);
            dprintf("supported by this debugger, and might not function correctly.\n");
            dprintf("You should use the debugger from the SDK or DDK which was used\n");
            dprintf("to build the extension library.\n");
        }
    }
#endif

    // If the extension has a notification routine send
    // notifications appropriate to the current state.
    if (Ext->Notify != NULL)
    {
        __try
        {
            if (IS_MACHINE_SET(g_Target))
            {
                Ext->Notify(DEBUG_NOTIFY_SESSION_ACTIVE, 0);
            }
            if (IS_CUR_MACHINE_ACCESSIBLE())
            {
                Ext->Notify(DEBUG_NOTIFY_SESSION_ACCESSIBLE, 0);
            }
        }
        __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                          Ext->Name,
                                          "DebugExtensionNotify"))
        {
            // Empty.
        }
    }

    return TRUE;

 EH_Free:
    FreeExtensionLibrary(Ext);
    return FALSE;
}

void
UnlinkExtensionDll(EXTDLL* Match)
{
    EXTDLL *Ext;
    EXTDLL *Prev;

    Prev = NULL;
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (Match == Ext)
        {
            break;
        }

        Prev = Ext;
    }

    if (Ext == NULL)
    {
        ErrOut("! Extension DLL list inconsistency !\n");
    }
    else if (Prev == NULL)
    {
        g_ExtDlls = Ext->Next;
    }
    else
    {
        Prev->Next = Ext->Next;
    }
}

void
DeferExtensionDll(EXTDLL *Ext, BOOL Verbose)
{
    if (Ext->Dll == NULL)
    {
        // Already deferred.
        return;
    }

    Ext->Init = NULL;
    Ext->Notify = NULL;
    Ext->ApiVersionRoutine = NULL;
    Ext->CheckVersionRoutine = NULL;

    if (Ext->Uninit != NULL)
    {
        Ext->Uninit();
        Ext->Uninit = NULL;
    }

    if (Ext->Dll != NULL)
    {
        if (Verbose)
        {
            dprintf("Unloading %s extension DLL\n", Ext->Name);
        }
        else if (!g_QuietMode)
        {
            VerbOut("Unloading %s extension DLL\n", Ext->Name);
        }

        FreeExtensionLibrary(Ext);
    }
}

void
UnloadExtensionDll(EXTDLL *Ext, BOOL Verbose)
{
    UnlinkExtensionDll(Ext);
    DeferExtensionDll(Ext, Verbose);
    free(Ext);
    NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
}

void
MoveExtensionToHead(EXTDLL* Ext)
{
    UnlinkExtensionDll(Ext);
    LinkExtensionDll(Ext);
}

void
UnloadTargetExtensionDlls(TargetInfo* Target)
{
    EXTDLL* Ext;

    for (;;)
    {
        for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
        {
            if (Ext->Target == Target)
            {
                UnloadExtensionDll(Ext, FALSE);
                // Force a loop around as the list has
                // changed.
                break;
            }
        }

        if (!Ext)
        {
            return;
        }
    }
}

void
DeferAllExtensionDlls(void)
{
    EXTDLL* Ext;

    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        DeferExtensionDll(Ext, FALSE);
    }
}

BOOL
CallAnyExtension(DebugClient* Client,
                 EXTDLL* Ext, PSTR Function, PCSTR Arguments,
                 BOOL ModuleSpecified, BOOL ShowWarnings,
                 HRESULT* ExtStatus)
{
    if (Ext == NULL)
    {
        Ext = g_ExtDlls;
    }

    // Walk through the list of extension DLLs and attempt to
    // call the given extension function on them.
    while (Ext != NULL)
    {
        //
        // hack : only dbghelp extensions or analyzebugcheck
        // will work on minidump files right now.
        //

        // Let all the extensions run on minidumps since there is more data
        // in the dumps now.
        //
        // char Name[_MAX_FNAME + 1];
        //
        // _splitpath(Ext->Name, NULL, NULL, Name, NULL);
        //
        // if (!IS_KERNEL_TRIAGE_DUMP(g_Target) ||
        //     !_stricmp(Name, "dbghelp") ||
        //     !_stricmp(Name, "dbgtstext") ||     // used by the test team
        //     !_stricmp(Name, "dt_exts") ||       // used by the test team
        //     !_stricmp(Name, "ext"))
        {
            if ((!Ext->Target || Ext->Target == g_Target) &&
                LoadExtensionDll(g_Target, Ext))
            {
                BOOL DidCall;

                DidCall = CallExtension(Client, Ext, Function, Arguments,
                                        ExtStatus);
                if (DidCall &&
                    *ExtStatus != DEBUG_EXTENSION_CONTINUE_SEARCH)
                {
                    return TRUE;
                }

                if (!DidCall && ModuleSpecified)
                {
                    // If a DLL was explicitly specified then the
                    // missing function is an error.
                    if (ShowWarnings &&
                        !(g_EnvDbgOptions & OPTION_NOEXTWARNING))
                    {
                        MaskOut(DEBUG_OUTPUT_EXTENSION_WARNING,
                                "%s has no %s export\n", Ext->Name, Function);
                    }

                    return FALSE;
                }
            }
        }

        Ext = Ext->Next;
    }

    if (ShowWarnings && !(g_EnvDbgOptions & OPTION_NOEXTWARNING))
    {
        MaskOut(DEBUG_OUTPUT_EXTENSION_WARNING,
                "No export %s found\n", Function);
    }

    return FALSE;
}

void
OutputModuleIdInfo(HMODULE Mod, PSTR ModFile, LPEXT_API_VERSION ApiVer)
{
    WCHAR FileBuf[MAX_IMAGE_PATH];
    char *File;
    time_t TimeStamp;
    char *TimeStr;
    char VerStr[64];

    if (Mod == NULL)
    {
        Mod = GetModuleHandle(ModFile);
    }

    if (MultiByteToWideChar(CP_ACP, 0, ModFile, -1,
                            FileBuf, DIMA(FileBuf)) &&
        GetFileStringFileInfo(FileBuf, "ProductVersion",
                              VerStr, sizeof(VerStr)))
    {
        dprintf("image %s, ", VerStr);
    }

    if (ApiVer != NULL)
    {
        dprintf("API %d.%d.%d, ",
                ApiVer->MajorVersion,
                ApiVer->MinorVersion,
                ApiVer->Revision);
    }

    TimeStamp = GetTimestampForLoadedLibrary(Mod);
    TimeStr = ctime(&TimeStamp);
    // Delete newline.
    TimeStr[strlen(TimeStr) - 1] = 0;

    if (GetModuleFileName(Mod, (PSTR)FileBuf, DIMA(FileBuf) - 1) == 0)
    {
        File = "Unable to get filename";
    }
    else
    {
        File = (PSTR)FileBuf;
    }

    dprintf("built %s\n        [path: %s]\n", TimeStr, File);
}

void
OutputExtensions(DebugClient* Client, BOOL Versions)
{
    if ((g_Target && g_Target->m_ExtensionSearchPath) ||
        (!g_Target && g_BaseExtensionSearchPath))
    {
        dprintf("Extension DLL search Path:\n    %s\n",
                g_Target ?
                g_Target->m_ExtensionSearchPath : g_BaseExtensionSearchPath);
    }
    else
    {
        dprintf("Default extension DLLs are not loaded until "
                "after initial connection\n");
        if (g_ExtDlls == NULL)
        {
            return;
        }
    }

    dprintf("Extension DLL chain:\n");
    if (g_ExtDlls == NULL)
    {
        dprintf("    <Empty>\n");
        return;
    }

    EXTDLL *Ext;

    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if (Ext->Target && Ext->Target != g_Target)
        {
            continue;
        }

        if (Versions & (Ext->Dll == NULL))
        {
            LoadExtensionDll(g_Target, Ext);
        }

        dprintf("    %s: ", Ext->Name);
        if (Ext->Dll != NULL)
        {
            LPEXT_API_VERSION ApiVer;

            if ((Ext->ExtensionType == DEBUG_EXTENSION_TYPE) ||
                (Ext->ApiVersionRoutine != NULL))
            {
                ApiVer = &Ext->ApiVersion;
            }
            else
            {
                ApiVer = NULL;
            }

            OutputModuleIdInfo(Ext->Dll, Ext->Name, ApiVer);

            if (Versions)
            {
                HRESULT ExtStatus;

                CallExtension(Client, Ext, "version", "", &ExtStatus);
            }
        }
        else
        {
            dprintf("(Not loaded)\n");
        }
    }
}

void
NotifyExtensions(ULONG Notify, ULONG64 Argument)
{
    EXTDLL *Ext;

    // This routine deliberately does not provoke
    // a DLL load.
    for (Ext = g_ExtDlls; Ext != NULL; Ext = Ext->Next)
    {
        if ((!Ext->Target || Ext->Target == g_Target) &&
            Ext->Notify != NULL)
        {
            __try
            {
                Ext->Notify(Notify, Argument);
            }
            __except(ExtensionExceptionFilter(GetExceptionInformation(),
                                              Ext->Name,
                                              "DebugExtensionNotify"))
            {
                // Empty.
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Built-in extension commands.
//
//----------------------------------------------------------------------------

VOID
ParseBangCmd(DebugClient* Client,
             BOOL BuiltInOnly)
{
    PSTR Cmd, Scan;
    PSTR ModName;
    PSTR FnName;
    EXTDLL* Ext;
    char CmdCopy[MAX_COMMAND];
    char Save;
    PSTR FnArgs;

    //
    // Shell escape always consumes the entire string.
    //

    if (*g_CurCmd == '!')
    {
        g_CurCmd++;
        DotShell(NULL, Client);
        *g_CurCmd = 0;
        return;
    }

    PeekChar();

    // Make a copy of the command string so that modifications
    // do not change the actual command string the debugger is processing.
    CopyString(CmdCopy, g_CurCmd, DIMA(CmdCopy));

    //
    // Syntax is [path-without-spaces]module.function argument-string.
    //

    ModName = CmdCopy;
    FnName = NULL;

    Cmd = CmdCopy;
    while (*Cmd != ' ' && *Cmd != '\t' && *Cmd &&
           *Cmd != ';' && *Cmd != '"')
    {
        Cmd++;
    }

    Scan = Cmd;
    if (*Cmd && *Cmd != ';' && *Cmd != '"')
    {
        *Cmd = 0;
        Cmd++;
    }

    while (*Scan != '.' && Scan != ModName)
    {
        Scan--;
    }

    if (*Scan == '.' && !BuiltInOnly)
    {
        *Scan = 0;
        Scan++;
        FnName = Scan;
    }
    else
    {
        FnName = ModName;
        ModName = NULL;
    }

    if ((FnArgs = BufferStringValue(&Cmd,
                                    STRV_ESCAPED_CHARACTERS |
                                    STRV_ALLOW_EMPTY_STRING,
                                    NULL, &Save)) == NULL)
    {
        ErrOut("Syntax error in extension string\n");
        return;
    }

    // Update the real command string pointer to account for
    // the characters parsed in the copy.
    g_CurCmd += Cmd - CmdCopy;

    //
    //  ModName -> Name of module
    //  FnName -> Name of command to process
    //  FnArgs -> argument to command
    //

    if (ModName != NULL)
    {
        Ext = AddExtensionDll(ModName, TRUE, NULL, NULL);
        if (Ext == NULL)
        {
            return;
        }
    }
    else
    {
        Ext = g_ExtDlls;
    }

    if (!_stricmp(FnName, "load"))
    {
        if (ModName == NULL)
        {
            Ext = AddExtensionDll(FnArgs, TRUE, NULL, NULL);
            if (Ext == NULL)
            {
                return;
            }
        }
        LoadExtensionDll(g_Target, Ext);
        return;
    }
    else if (!_stricmp(FnName, "setdll"))
    {
        if (ModName == NULL)
        {
            Ext = AddExtensionDll(FnArgs, TRUE, NULL, NULL);
            if (Ext == NULL)
            {
                return;
            }
        }
        MoveExtensionToHead(Ext);
        if (ModName != NULL && Ext->Dll == NULL)
        {
            dprintf("Added %s to extension DLL chain\n", Ext->Name);
        }
        return;
    }
    else if (!_stricmp(FnName, "unload"))
    {
        if (ModName == NULL)
        {
            if (*FnArgs == '\0')
            {
                Ext = g_ExtDlls;
            }
            else
            {
                Ext = AddExtensionDll(FnArgs, TRUE, NULL, NULL);
            }
            if (Ext == NULL)
            {
                return;
            }
        }
        if (Ext != NULL)
        {
            UnloadExtensionDll(Ext, TRUE);
        }
        return;
    }
    else if (!_stricmp(FnName, "unloadall"))
    {
        g_EngNotify++;
        while (g_ExtDlls != NULL)
        {
            UnloadExtensionDll(g_ExtDlls, TRUE);
        }
        g_EngNotify--;
        NotifyChangeEngineState(DEBUG_CES_EXTENSIONS, 0, TRUE);
        return;
    }

    if (BuiltInOnly)
    {
        error(SYNTAX);
    }

    HRESULT ExtStatus;

    CallAnyExtension(Client, Ext, FnName, FnArgs, ModName != NULL, TRUE,
                     &ExtStatus);
}

void
ReadDebugOptions (BOOL fQuiet, char * pszOptionsStr)
/*++

Routine Description:

    Parses an options string (see g_EnvDbgOptionNames) and maps
    it to OPTION_ flags (in g_EnvDbgOptions).

Arguments:

    fQuiet - If TRUE, do not print option settings.
    pszOptionsStr - Options string; if NULL, get it from _NT_DEBUG_OPTIONS

Return Value:

    None
--*/
{
    BOOL fInit;
    char ** ppszOption;
    char * psz;
    DWORD dwMask;
    int iOptionCount;

    fInit = (pszOptionsStr == NULL);
    if (fInit)
    {
        g_EnvDbgOptions = 0;
        pszOptionsStr = getenv("_NT_DEBUG_OPTIONS");
    }
    if (pszOptionsStr == NULL)
    {
        if (!fQuiet)
        {
            dprintf("_NT_DEBUG_OPTIONS is not defined\n");
        }
        return;
    }
    psz = pszOptionsStr;
    while (*psz != '\0')
    {
        *psz = (char)toupper(*psz);
        psz++;
    }
    ppszOption = g_EnvDbgOptionNames;
    for (iOptionCount = 0;
         iOptionCount < OPTION_COUNT;
         iOptionCount++, ppszOption++)
    {
        if ((strstr(pszOptionsStr, *ppszOption) == NULL))
        {
            continue;
        }
        dwMask = (1 << iOptionCount);
        if (fInit)
        {
            g_EnvDbgOptions |= dwMask;
        }
        else
        {
            g_EnvDbgOptions ^= dwMask;
        }
    }
    if (!fQuiet)
    {
        dprintf("Debug Options:");
        if (g_EnvDbgOptions == 0)
        {
            dprintf(" <none>\n");
        }
        else
        {
            dwMask = g_EnvDbgOptions;
            ppszOption = g_EnvDbgOptionNames;
            while (dwMask != 0)
            {
                if (dwMask & 0x1)
                {
                    dprintf(" %s", *ppszOption);
                }
                dwMask >>= 1;
                ppszOption++;
            }
            dprintf("\n");
        }
    }
}

//----------------------------------------------------------------------------
//
// LoadWow64ExtsIfNeeded
//
//----------------------------------------------------------------------------

VOID
LoadWow64ExtsIfNeeded(ULONG64 Process)
{
   LONG_PTR Wow64Info;
   NTSTATUS Status;
   EXTDLL * Extension;

   // wx86 only runs on NT.
   if (g_DebuggerPlatformId != VER_PLATFORM_WIN32_NT)
   {
       return;
   }

   //
   // if New process is a Wx86 process, load in the wx86 extensions
   // dll. This will stay loaded until ntsd exits.
   //

   Status = g_NtDllCalls.NtQueryInformationProcess(OS_HANDLE(Process),
                                                   ProcessWow64Information,
                                                   &Wow64Info,
                                                   sizeof(Wow64Info),
                                                   NULL
                                                   );

   if (NT_SUCCESS(Status) && Wow64Info)
   {
       Extension = AddExtensionDll("wow64exts", FALSE, g_Target, NULL);

       //
       // Force load it so we get the entry point the debugger needs
       //
       LoadExtensionDll(g_Target, Extension);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\exts.h ===
//----------------------------------------------------------------------------
//
// Extension DLL support.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _EXTS_H_
#define _EXTS_H_

#define OPTION_NOEXTWARNING         0x00000001
#define OPTION_NOVERSIONCHECK       0x00000002
#define OPTION_COUNT                2

extern DWORD g_EnvDbgOptions;

#define WOW64EXTS_FLUSH_CACHE       0
#define WOW64EXTS_GET_CONTEXT       1
#define WOW64EXTS_SET_CONTEXT       2
#define WOW64EXTS_FLUSH_CACHE_WITH_HANDLE   3

typedef VOID (*WOW64EXTSPROC)(ULONG64, ULONG64, ULONG64, ULONG64);

typedef ULONG (CALLBACK* WMI_FORMAT_TRACE_DATA)
    (PDEBUG_CONTROL Ctrl, ULONG Mask, ULONG DataLen, PVOID Data);

extern ULONG64 g_ExtThread;

extern WOW64EXTSPROC g_Wow64exts;
extern WMI_FORMAT_TRACE_DATA g_WmiFormatTraceData;

extern DEBUG_SCOPE g_ExtThreadSavedScope;
extern BOOL g_ExtThreadScopeSaved;

extern WINDBG_EXTENSION_APIS64 g_WindbgExtensions64;
extern WINDBG_EXTENSION_APIS32 g_WindbgExtensions32;
extern WINDBG_OLDKD_EXTENSION_APIS g_KdExtensions;

DebugClient* FindExtClient(void);

void ParseBangCmd(DebugClient* Client,
                  BOOL BuiltInOnly);

enum ExtensionType
{
    NTSD_EXTENSION_TYPE = 1,
    DEBUG_EXTENSION_TYPE,
    WINDBG_EXTENSION_TYPE,
    WINDBG_OLDKD_EXTENSION_TYPE,
};
    
typedef struct _EXTDLL
{
    struct _EXTDLL *Next;
    HINSTANCE Dll;
    EXT_API_VERSION ApiVersion;

    BOOL UserLoaded;
    
    ExtensionType ExtensionType;
    PDEBUG_EXTENSION_NOTIFY Notify;
    PDEBUG_EXTENSION_UNINITIALIZE Uninit;

    PWINDBG_EXTENSION_DLL_INIT64 Init;
    PWINDBG_EXTENSION_API_VERSION ApiVersionRoutine;
    PWINDBG_CHECK_VERSION CheckVersionRoutine;

    TargetInfo* Target;
    
    // Array extends to contain the full name.
    char Name[1];

} EXTDLL;

extern EXTDLL* g_ExtDlls;

LONG
ExtensionExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo,
    PCSTR Module,
    PCSTR Func
    );

EXTDLL* AddExtensionDll(char *Name, BOOL UserLoaded, TargetInfo* Target,
                        char **End);
BOOL LoadExtensionDll(TargetInfo* Target, EXTDLL *Ext);
void DeferExtensionDll(EXTDLL *Match, BOOL Verbose);
void UnloadExtensionDll(EXTDLL *Match, BOOL Verbose);
void UnloadTargetExtensionDlls(TargetInfo* Target);
void DeferAllExtensionDlls(void);

BOOL
CallAnyExtension(DebugClient* Client,
                 EXTDLL* Ext, PSTR Function, PCSTR Arguments,
                 BOOL ModuleSpecified, BOOL ShowWarnings,
                 HRESULT* ExtStatus);

void OutputModuleIdInfo(HMODULE Mod, PSTR ModFile, LPEXT_API_VERSION ApiVer);
void OutputExtensions(DebugClient* Client, BOOL Versions);

void NotifyExtensions(ULONG Notify, ULONG64 Argument);

void ReadDebugOptions (BOOL fQuiet, char * pszOptionsStr);

VOID LoadWow64ExtsIfNeeded(ULONG64 Process);

#endif // #ifndef _EXTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_asm.cpp ===
//----------------------------------------------------------------------------
//
// Assemble X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "i386_asm.h"

UCHAR asm386(ULONG, PUCHAR, PUCHAR);

UCHAR CheckData(void);
PUCHAR ProcessOpcode(void);
PUCHAR GetTemplate(PUCHAR);
UCHAR MatchTemplate(PULONG);
void CheckTemplate(void);
UCHAR CheckPrefix(PUCHAR);
void AssembleInstr(void);
UCHAR MatchOperand(PASM_VALUE, UCHAR);
void OutputInstr(void);
void OutputValue(UCHAR size, PUCHAR pchValue);

extern UCHAR PeekAsmChar(void);
extern ULONG PeekAsmToken(PULONG);
extern void AcceptAsmToken(void);

extern void GetAsmExpr(PASM_VALUE, UCHAR);
extern void GetAsmOperand(PASM_VALUE);
extern PUCHAR X86SearchOpcode(PUCHAR);
extern ULONG savedAsmClass;
extern OPNDTYPE mapOpndType[];

//  flags and values to build the assembled instruction

static UCHAR   fWaitPrfx;       //  if set, use WAIT prefix for float instr
static UCHAR   fOpndOvrd;       //  if set, use operand override prefix
static UCHAR   fAddrOvrd;       //  if set, use address override prefix
static UCHAR   segOvrd;         //  if nonzero, use segment override prefix
static UCHAR   preOpcode;       //  if nonzero, use byte before opcode
static UCHAR   inOpcode;        //  opcode of instruction
static UCHAR   postOpcode;      //  if nonzero, use byte after opcode
static UCHAR   fModrm;          //  if set, modrm byte is defined
static UCHAR   modModrm;        //  if fModrm, mod component of modrm
static UCHAR   regModrm;        //  if fModrm, reg component of modrm
static UCHAR   rmModrm;         //  if fModrm, rm component of modrm
static UCHAR   fSib;            //  if set, sib byte is defined
static UCHAR   scaleSib;        //  if fSib, scale component of sib
static UCHAR   indexSib;        //  if fSib, index component of sib
static UCHAR   baseSib;         //  if fSib, base component of sib
static UCHAR   fSegPtr;         //  if set, segment for far call defined
static USHORT  segPtr;          //  if fSegPtr, value of far call segment
static UCHAR   addrSize;        //  size of address: 0, 1, 2, 4
static LONG    addrValue;       //  value of address, if used
static UCHAR   immedSize;       //  size of immediate: 0, 1, 2, 4
static LONG    immedValue;      //  value of immediate, if used
static UCHAR   immedSize2;      //  size of second immediate, if used
static LONG    immedValue2;     //  value of second immediate, if used
static ULONG   addrAssem;       //  assembly address (formal)
static PUCHAR  pchBin;          //  pointer to binary result string

//  flags and values of the current instruction template being used

static UCHAR   cntTmplOpnd;     //  count of operands in template
static UCHAR   tmplType[3];     //  operand types for current template
static UCHAR   tmplSize[3];     //  operand sizes for current template
static UCHAR   fForceSize;      //  set if operand size must be specified
static UCHAR   fAddToOp;        //  set if addition to opcode
static UCHAR   fNextOpnd;       //  set if character exists for next operand
static UCHAR   fSegOnly;        //  set if only segment is used for operand
static UCHAR   fMpNext;         //  set on 'Mv' tmpl if next tmpl is 'Mp'
static UCHAR   segIndex;        //  index of segment for PUSH/POP

//  values describing the operands processed from the command line

static UCHAR   cntInstOpnd;     //  count of operands read from input line
static UCHAR   sizeOpnd;        //  size of operand for template with size v
static ASM_VALUE avInstOpnd[3];  //  asm values from input line

PUCHAR  pchAsmLine;             //  pointer to input line (formal)
UCHAR fDBit = TRUE;             //  set for 32-bit addr/operand mode

UCHAR segToOvrdByte[] = {
        0x00,                   //  segX
        0x26,                   //  segES
        0x2e,                   //  segCS
        0x36,                   //  segSS
        0x3e,                   //  segDS
        0x64,                   //  segFS
        0x65                    //  segGS
        };

void
BaseX86MachineInfo::Assemble(ProcessInfo* Process, PADDR paddr, PSTR pchInput)
{
    ULONG   length;
    UCHAR   chBinary[60];

    length = (ULONG)asm386((ULONG)Flat(*paddr), (PUCHAR)pchInput, chBinary);

    if (length)
    {
        if (g_Target->WriteAllVirtual(Process, Flat(*paddr),
                                      chBinary, length) != S_OK)
        {
            error(MEMORY);
        }
        AddrAdd(paddr,length);
    }
}

UCHAR asm386 (ULONG addrAssemble, PUCHAR pchAssemble, PUCHAR pchBinary)
{
    PUCHAR  pchTemplate;

    UCHAR   index;              //  loop index and temp
    ULONG   temp;               //  general temporary value

    UCHAR   errIndex;           //  error index of all templates
    ULONG   errType;            //  error type of all templates

    //  initialize flags and state variables

    addrAssem = addrAssemble;   //  make assembly address global
    pchAsmLine = pchAssemble;   //  make input string pointer global
    pchBin = pchBinary;         //  make binary string pointer global

    savedAsmClass = (ULONG)-1;  //  no peeked token

    segOvrd = 0;                            //  no segment override
    cntInstOpnd = 0;                        //  no input operands read yet
    fModrm = fSib = fSegPtr = FALSE;        //  no modrm, sib, or far seg
    addrSize = immedSize = immedSize2 = 0;  //  no addr or immed

    //  check for data entry commands for byte (db), word (dw), dword (dd)
    //      if so, process multiple operands directly

    if (!CheckData()) {

        //  from the string in pchAsmLine, parse and lookup the opcode
        //      to return a pointer to its template.  check and process
        //      any prefixes, reading the next opcode for each prefix

        do
            pchTemplate = ProcessOpcode();
        while (CheckPrefix(pchTemplate));

        //  if a pending opcode to process, pchTemplate is not NULL

        if (pchTemplate) {

            //  fNextOpnd is initially set on the condition of characters
            //      being available for the first operand on the input line

            fNextOpnd = (UCHAR)(PeekAsmToken(&temp) != ASM_EOL_CLASS);

            //  continue until match occurs or last template read

            errIndex = 0;               //  start with no error
            do {

                //  get infomation on next template - return pointer to
                //      next template or NULL if last in list

                pchTemplate = GetTemplate(pchTemplate);

                //  match the loaded template against the operands input
                //      if mismatch, index has the operand index + 1 of
                //      the error while temp has the error type.

                index = MatchTemplate(&temp);

                //  determine the error to report as templates are matched
                //      update errIndex to index if later operand
                //      if same operand index, prioritize to give best error:
                //          high: SIZE, BADRANGE, OVERFLOW
                //          medium: OPERAND
                //          low: TOOFEW, TOOMANY

                if (index > errIndex
                       || (index == errIndex &&
                              (errType == TOOFEW || errType == TOOMANY
                                  || temp == BADSIZE || temp == BADRANGE
                                  || temp == OVERFLOW))) {
                    errIndex = index;
                    errType = temp;
                    };

                }
            while (index && pchTemplate);

            //  if error occured on template match, process it

            if (index)
                error(errType);

            //  preliminary type and size matching has been
            //      successful on the current template.
            //  perform further checks for size ambiguity.
            //  at this point, the assembly is committed to the current
            //       template.  either an error or a successful assembly
            //       follows.

            CheckTemplate();

            //  from the template and operand information, set the field
            //      information of the assembled instruction

            AssembleInstr();

            //  from the assembled instruction information, create the
            //      corresponding binary information

            OutputInstr();
            }
        }

    //  return the size of the binary string output (can be zero)

    return (UCHAR)(pchBin - pchBinary);         //  length of binary string
}

UCHAR CheckData (void)
{
    PUCHAR  pchBinStart = pchBin;
    UCHAR   ch;
    UCHAR   size = 0;
    ASM_VALUE avItem;
    ULONG   temp;

    //  perform an explicit parse for 'db', 'dw', and 'dd'
    //      and set size to that of the data item

    ch = PeekAsmChar();
    if (tolower(ch) == 'd') {
        ch = (UCHAR)tolower(*(pchAsmLine + 1));
        if (ch == 'b')
           size = 1;
        if (ch == 'w')
           size = 2;
        if (ch == 'd')
           size = 4;
        if (size) {
            ch = *(pchAsmLine + 2);
            if (ch != ' ' && ch != '\t' && ch != '\0')
                size = 0;
            }
        }

    //  if a valid command entered, then size is nonzero

    if (size) {

        //  move pointer over command and set loop condition

        pchAsmLine += 2;
        temp = ASM_COMMA_CLASS;

        //  for each item in list:
        //      check for binary buffer overflow
        //      get expression value - error if not immediate value
        //      test for byte and word overflow, if applicable
        //      write the value to the binary buffer
        //      check for comma for next operand

        while (temp == ASM_COMMA_CLASS) {
            if (pchBin >= pchBinStart + 40)
                error(LISTSIZE);
            GetAsmExpr(&avItem, FALSE);
            if (!(avItem.flags & fIMM))
                error(OPERAND);
            if (avItem.reloc > 1)
                error(RELOC);
            if ((size == 1 && ((LONG)avItem.value < -0x80L
                                  || (LONG)avItem.value > 0xffL))
                   || (size == 2 && ((LONG)avItem.value < -0x8000L
                                        || (LONG)avItem.value > 0xffffL)))
                error(OVERFLOW);
            OutputValue(size, (PUCHAR)&avItem.value);

            temp = PeekAsmToken(&temp);
            if (temp == ASM_COMMA_CLASS)
                AcceptAsmToken();
            else if (temp != ASM_EOL_CLASS)
                error(SYNTAX);
            }

        //  check for any remaining part after the last operand

        if (PeekAsmChar() != '\0')
            error(SYNTAX);
        }

    //  return size of item listed (zero for none)

    return size;
}

PUCHAR ProcessOpcode (void)
{
    UCHAR   ch;
    UCHAR   cbOpcode = 0;
    PUCHAR  pchTemplate;
    UCHAR   szOpcode[12];

    //  skip over any leading white space

    do
        ch = *pchAsmLine++;
    while (ch == ' ' || ch == '\t');

    //  return NULL if end of line

    if (ch == '\0')
        return NULL;

    //  parse out opcode - first string [a-z] [0-9] (case insensitive)

    ch = (UCHAR)tolower(ch);
    while (((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')) &&
                        cbOpcode < 11) {
        szOpcode[cbOpcode++] = ch;
        ch = (UCHAR)tolower(*pchAsmLine); pchAsmLine++;
        }

    //  if empty or too long, then error

    if (cbOpcode == 0 || cbOpcode == 11)
        error(BADOPCODE);

    //  allow opcode to have trailing colon and terminate

    if (ch == ':') {
        szOpcode[cbOpcode++] = ch;
        ch = (UCHAR)tolower(*pchAsmLine); pchAsmLine++;
        }
    szOpcode[cbOpcode] = '\0';
    pchAsmLine--;

    //  get pointer to template series for opcode found

    pchTemplate = X86SearchOpcode(szOpcode);
    if (pchTemplate == NULL)
        error(BADOPCODE);

    return pchTemplate;
}

PUCHAR GetTemplate (PUCHAR pchTemplate)
{
    UCHAR   ch;
    UCHAR   ftEnd;              //  set if tEnd for last template in list
    UCHAR   feEnd;              //  set if eEnd for last token in template

    //  initialize template variables and flags

    cntTmplOpnd = segIndex = 0;
    tmplType[0] = tmplType[1] = tmplType[2] = typNULL;
    tmplSize[0] = tmplSize[1] = tmplSize[2] = sizeX;
    fForceSize = fAddToOp = fSegOnly = fMpNext = FALSE;

    fWaitPrfx = FALSE;                  //  no WAIT prefix
    fOpndOvrd = fAddrOvrd = FALSE;      //  no operand or addr overrides
    preOpcode = postOpcode = 0;         //  no pre- or post-opcode
    regModrm = 0;                       //  this is part of some opcodes

    ch = *pchTemplate++;

    //  set pre-opcode for two-byte opcodes (0x0f??) and advance
    //      template if needed

    if (ch == 0x0f) {
        preOpcode = ch;
        ch = *pchTemplate++;
        }

    inOpcode = ch;              //  set opcode

    //  set post-opcode and advance template for floating-point
    //      instructions (0xd8 - 0xdf) using a second byte in
    //      the range 0xc0 - 0xff that is read from the template

    if ((ch & ~0x7) == 0xd8) {
        ch = *pchTemplate;
        if (ch >= 0xc0) {
            postOpcode = ch;
            pchTemplate++;
            }
        }

    //  loop for each flag and/or operand token in template
    //  the last token in the list has the eEnd bit set.

    do {
        //  read the next template token

        ch = *pchTemplate++;

        //  extract the tEnd and eEnd bits from the token

        ftEnd = (UCHAR)(ch & tEnd);
        feEnd = (UCHAR)(ch & eEnd);
        ch &= ~(tEnd | eEnd);

        //  if extracted token is a flag, do the appropriate action

        if (ch < asRegBase)
        switch (ch) {
            case as0x0a:

                //  the postOpcode is set for some decimal instructions

                postOpcode = 0x0a;
                break;

            case asOpRg:

                //  fAddToOp is set if the register index is added
                //      directly to the base opcode value

                fAddToOp = TRUE;
                break;

            case asSiz0:

                //  fOpndOvrd is set or cleared to force a 16-bit operand

                fOpndOvrd = fDBit;
                break;

            case asSiz1:

                //  fOpndOvrd is set or cleared to force a 32-bit operand

                fOpndOvrd = (UCHAR)!fDBit;
                break;

            case asWait:

                //  the flag fWaitPrfx is set to emit WAIT before the
                //      instruction

                fWaitPrfx = TRUE;
                break;

            case asSeg:

                //  in XLAT, the optional memory operand is used to
                //      just specify a segment override prefix

                fSegOnly = TRUE;
                break;

            case asFSiz:

                //  fForceSize is set when a specific size of a memory
                //      operand must be given for some floating instrs

                fForceSize = TRUE;
                break;

            case asMpNx:

                //  fMpNext is set when the next template operand is
                //      'Mp' and is used to determine how to match
                //      'Md' since it matches both 'Mp' and 'Mv'

                fMpNext = TRUE;
                break;
            }

        //  if token is REG value bit, set the variable regModrm to
        //      set the opcode-dependent reg value in the modrm byte

        else if (ch < opnBase)
            regModrm = (UCHAR)(ch - asRegBase);

        //  otherwise, token is operand descriptor.
        //  if segment operand, get segment number from template
        //  normalize and map to get operand type and size.

        else {
            if (ch == opnSeg)
                segIndex = *pchTemplate++;
            ch -= opnBase;
            tmplType[cntTmplOpnd] = mapOpndType[ch].type;
            tmplSize[cntTmplOpnd++] = mapOpndType[ch].size;
            }
        }
    while (!ftEnd);

    //  return either the pointer to the next template or NULL if
    //      the last template for the opcode has been processed

    return (feEnd ? NULL : pchTemplate);
}

UCHAR MatchTemplate (PULONG pErrType)
{
    UCHAR   fMatch = TRUE;
    UCHAR   index;
    ULONG   temp;
    PASM_VALUE pavInstOpnd;     //  pointer to current operand from input

    //  process matching for each operand in the specified template
    //  stop at last operand or when mismatch occurs

    for (index = 0; index < cntTmplOpnd && fMatch; index++) {

        //  set pointer to current instruction operand

        pavInstOpnd = &avInstOpnd[index];

        //  if input operand has not yet been read, check flag
        //  for existence and process it.

        if (index == cntInstOpnd) {
            fMatch = fNextOpnd;
            *pErrType = TOOFEW;
            if (fMatch) {
                cntInstOpnd++;
                GetAsmOperand(pavInstOpnd);

                //  recompute existence of next possible operand
                //      comma implies TRUE, EOL implies FALSE, else error

                temp = PeekAsmToken(&temp);
                if (temp == ASM_COMMA_CLASS) {
                    AcceptAsmToken();
                    fNextOpnd = TRUE;
                    }
                else if (temp == ASM_EOL_CLASS)
                    fNextOpnd = FALSE;
                else
                    error(EXTRACHARS);  // bad parse - immediate error
                }
            }

        if (fMatch) {
            fMatch = MatchOperand(pavInstOpnd, tmplType[index]);
            *pErrType = OPERAND;
            }

        //  if the template and operand type match, do preliminary
        //  check on size based solely on template size specified

        if (fMatch) {
            if (tmplType[index] == typJmp) {

                //  for relative jumps, test if byte offset is
                //      sufficient by computing offset which is
                //      the target offset less the offset of the
                //      next instruction.  (assume Jb instructions
                //      are two bytes in length.

                temp = pavInstOpnd->value - (addrAssem + 2);
                fMatch = (UCHAR)(tmplSize[index] == sizeV
                             || ((LONG)temp >= -0x80 && (LONG)temp <= 0x7f));
                *pErrType = BADRANGE;
                }

            else if (tmplType[index] == typImm ||
                     tmplType[index] == typImmEx) {

                //  for immediate operand,
                //      template sizeV matches sizeB, sizeW, sizeV (all)
                //      template sizeW matches sizeB, sizeW
                //      template sizeB matches sizeB

                fMatch = (UCHAR)(tmplSize[index] == sizeV
                             || pavInstOpnd->size == tmplSize[index]
                             || pavInstOpnd->size == sizeB);
                *pErrType = OVERFLOW;
                }
            else {

                //  for nonimmediate operand,
                //      template sizeX (unspecified) matches all
                //      operand sizeX (unspecified) matches all
                //      same template and operand size matches
                //      template sizeV matches operand sizeW and sizeD
                //          (EXCEPT for sizeD when fMpNext and fDBit set)
                //      template sizeP matches operand sizeD and sizeF
                //      template sizeA matches operand sizeD and sizeQ

                fMatch = (UCHAR)(tmplSize[index] == sizeX
                             || pavInstOpnd->size == sizeX
                             || tmplSize[index] == pavInstOpnd->size
                             || (tmplSize[index] == sizeV
                                    && (pavInstOpnd->size == sizeW
                                           || (pavInstOpnd->size == sizeD
                                                  && (!fMpNext || fDBit))))
                             || (tmplSize[index] == sizeP
                                    && (pavInstOpnd->size == sizeD
                                           || pavInstOpnd->size == sizeF))
                             || (tmplSize[index] == sizeA
                                    && (pavInstOpnd->size == sizeD
                                           || pavInstOpnd->size == sizeQ)));
                *pErrType = BADSIZE;
                }
            }
        }

    //  if more operands to read, then no match

    if (fMatch & fNextOpnd) {
        fMatch = FALSE;
        index++;                //  next operand is in error
        *pErrType = TOOMANY;
        }

    return fMatch ? (UCHAR)0 : index;
}

void CheckTemplate (void)
{
    UCHAR   index;

    //  if fForceSize is set, then the first (and only) operand is a
    //      memory type.  return an error if its size is unspecified.

    if (fForceSize && avInstOpnd[0].size == sizeX)
        error(OPERAND);

    //  test for template with leading entries of 'Xb', where
    //      'X' includes all types except immediate ('I').  if any
    //      are defined, at least one operand must have a byte size.
    //  this handles the cases of byte or word/dword ambiguity for
    //      instructions with no register operands.

    sizeOpnd = sizeX;
    for (index = 0; index < 2; index++)
        if ((tmplType[index] != typImm && tmplType[index] != typImmEx) &&
            tmplSize[index] == sizeB) {
            if (avInstOpnd[index].size != sizeX)
                sizeOpnd = avInstOpnd[index].size;
            }
        else
            break;
    if (index != 0 && sizeOpnd == sizeX)
        error(BADSIZE);

    //  for templates with one entry of 'Xp', where 'X' is
    //      not 'A', allowable sizes are sizeX (unspecified),
    //      sizeD (dword), and sizeF (fword).  process by
    //      mapping entry sizes 'p' -> 'v', sizeD -> sizeW,
    //      and sizeF -> sizeD
    //  (template 'Ap' is absolute with explicit segment and
    //       'v'-sized offset - really treated as 'Av')

    if (tmplSize[0] == sizeP) {
        tmplSize[0] = sizeV;
        if (avInstOpnd[0].size == sizeD)
            avInstOpnd[0].size = sizeW;
        if (avInstOpnd[0].size == sizeF)
            avInstOpnd[0].size = sizeD;
        }

    //  for templates with the second entry of 'Ma', the
    //      allowable sizes are sizeX (unspecified),
    //      sizeD (dword), and sizeQ (qword).  process by
    //      mapping entry sizes 'a' -> 'v', sizeD -> sizeW,
    //      and sizeQ -> sizeD
    //  (template entry 'Ma' is used only with the BOUND instruction)

    if (tmplSize[1] == sizeA) {
        tmplSize[1] = sizeV;
        if (avInstOpnd[1].size == sizeD)
            avInstOpnd[1].size = sizeW;
        if (avInstOpnd[1].size == sizeQ)
            avInstOpnd[1].size = sizeD;
        }

    //  test for template with leading entries of 'Xv' optionally
    //      followed by one 'Iv' entry.  if two 'Xv' entries, set
    //      size error if one is word and the other is dword.  if
    //      'Iv' entry, test for overflow.

    sizeOpnd = sizeX;
    for (index = 0; index < 3; index++)
        if (tmplSize[index] == sizeV)
            if (tmplType[index] != typImm &&
                tmplType[index] != typImmEx) {

                //  template entry is 'Xv', set size and check size

                if (avInstOpnd[index].size != sizeX) {
                    if (sizeOpnd != sizeX && sizeOpnd
                                        != avInstOpnd[index].size)
                        error(BADSIZE);
                    sizeOpnd = avInstOpnd[index].size;
                    }
                }
            else {

                //  template entry is 'Iv', set sizeOpnd to either
                //      sizeW or sizeD and check for overflow

                if (sizeOpnd == sizeX)
                    sizeOpnd = (UCHAR)(fDBit ? sizeD : sizeW);
                if (sizeOpnd == sizeW && avInstOpnd[index].size == sizeD)
                    error(OVERFLOW);
                }
}

UCHAR CheckPrefix (PUCHAR pchTemplate)
{
    UCHAR   fPrefix;

    fPrefix = (UCHAR)(pchTemplate && *pchTemplate != 0x0f
                           && (*pchTemplate & ~7) != 0xd8
                           && *(pchTemplate + 1) == (asPrfx + tEnd + eEnd));
    if (fPrefix)
        *pchBin++ = *pchTemplate;

    return fPrefix;
}

void AssembleInstr (void)
{
    UCHAR   size;
    UCHAR   index;
    PASM_VALUE pavInstOpnd;

    //  set operand override flag if operand size differs than fDBit
    //      (the flag may already be set due to opcode template flag)

    if ((sizeOpnd == sizeW && fDBit)
                                || (sizeOpnd == sizeD && !fDBit))
        fOpndOvrd = TRUE;

    //  for each operand of the successfully matched template,
    //      build the assembled instruction
    //  for template entries with size 'v', sizeOpnd has the size

    for (index = 0; index < cntTmplOpnd; index++) {
        pavInstOpnd = &avInstOpnd[index];
        size = tmplSize[index];
        if (size == sizeV)
            size = sizeOpnd;

        switch (tmplType[index]) {
            case typExp:
            case typMem:
                if (!segOvrd)  //  first one only (movsb...)
                    segOvrd = segToOvrdByte[pavInstOpnd->segovr];
                if (fSegOnly)
                    break;

                fModrm = TRUE;
                if (pavInstOpnd->flags == fREG) {
                    modModrm = 3;
                    rmModrm = pavInstOpnd->base;
                    }
                else {
                    addrValue = (LONG)pavInstOpnd->value;

                    //  for 16-bit or 32-bit index off (E)BP, make
                    //      zero displacement a byte one

                    if (addrValue == 0
                          && (pavInstOpnd->flags != fPTR16
                                        || pavInstOpnd->base != 6)
                          && (pavInstOpnd->flags != fPTR32
                                        || pavInstOpnd->base != indBP))
                            modModrm = 0;
                    else if (addrValue >= -0x80L && addrValue <= 0x7fL) {
                        modModrm = 1;
                        addrSize = 1;
                        }
                    else if (pavInstOpnd->flags == fPTR32
                                 || (pavInstOpnd->flags == fPTR && fDBit)) {
                        modModrm = 2;
                        addrSize = 4;
                        }
                    else if (addrValue >= -0x8000L && addrValue <= 0xffffL) {
                        modModrm = 2;
                        addrSize = 2;
                        }
                    else
                        error(OVERFLOW);
                    if (pavInstOpnd->flags == fPTR) {
                        modModrm = 0;
                        addrSize = (UCHAR)((1 + fDBit) << 1);
                        rmModrm = (UCHAR)(6 - fDBit);
                        }
                    else if (pavInstOpnd->flags == fPTR16) {
                        fAddrOvrd = fDBit;
                        rmModrm = pavInstOpnd->base;
                        if (modModrm == 0 && rmModrm == 6)
                            modModrm = 1;
                        }
                    else {
                        fAddrOvrd = (UCHAR)!fDBit;
                        if (pavInstOpnd->index == 0xff
                                && pavInstOpnd->base != indSP) {
                            rmModrm = pavInstOpnd->base;
                            if (modModrm == 0 && rmModrm == 5)
                                modModrm++;
                            }
                        else {
                            rmModrm = 4;
                            fSib = TRUE;
                            if (pavInstOpnd->base != 0xff) {
                                baseSib = pavInstOpnd->base;
                                if (modModrm == 0 && baseSib == 5)
                                    modModrm++;
                                }
                            else
                                baseSib = 5;
                            if (pavInstOpnd->index != 0xff) {
                                indexSib = pavInstOpnd->index;
                                scaleSib = pavInstOpnd->scale;
                                }
                            else {
                                indexSib = 4;
                                scaleSib = 0;
                                }
                            }
                        }
                    }
                break;

            case typGen:
                if (fAddToOp)
                    inOpcode += pavInstOpnd->base;
                else
                    regModrm = pavInstOpnd->base;
                break;

            case typSgr:
                regModrm = (UCHAR)(pavInstOpnd->base - 1);
                                                //  remove list offset
                break;

            case typReg:
                rmModrm = pavInstOpnd->base;
                break;

            case typImm:
            case typImmEx:
                if (immedSize == 0) {
                    immedSize = size;
                    immedValue = pavInstOpnd->value;
                    }
                else {
                    immedSize2 = size;
                    immedValue2 = pavInstOpnd->value;
                    }
                break;

            case typJmp:

                //  compute displacment for byte offset instruction
                //      and test if in range
                //  skip this check if the template is a rel16/32
                //      type

                addrValue = pavInstOpnd->value - (addrAssem + 2);
                if (tmplSize[index] != sizeV &&
                    addrValue >= -0x80L && addrValue <= 0x7fL)
                    addrSize = 1;
                else {

                    //  too large for byte, compute for word offset
                    //      and test again if in range
                    //  also allow for two-byte opcode 0f xx

                    addrValue -= 1 + (preOpcode == 0x0f);
                    if (!fDBit) {
                        if (addrValue >= -0x8000L && addrValue <= 0x7fffL)
                            addrSize = 2;
                        else
                            error(BADRANGE);
                        }
                    else {

                        //  recompute again for dword offset instruction

                        addrValue -= 2;
                        addrSize = 4;
                        }
                    }
                fOpndOvrd = FALSE;      //  operand size override is NOT set
                break;

            case typCtl:
            case typDbg:
            case typTrc:
                fModrm = TRUE;
                modModrm = 3;
                regModrm = pavInstOpnd->base;
                break;

            case typSti:
                postOpcode += pavInstOpnd->base;
                break;

            case typSeg:
                break;

            case typXsi:
            case typYdi:
                fAddrOvrd = (UCHAR)
                        ((UCHAR)(pavInstOpnd->flags == fPTR32) != fDBit);
                break;

            case typOff:
                segOvrd = segToOvrdByte[pavInstOpnd->segovr];
                goto jumpAssem;

            case typAbs:
                fSegPtr = TRUE;
                segPtr = pavInstOpnd->segment;
jumpAssem:
                addrValue = (LONG)pavInstOpnd->value;
                if (!fDBit)
                    if (addrValue >= -0x8000L && addrValue <= 0xffffL)
                        addrSize = 2;
                    else
                        error(OVERFLOW);
                else
                    addrSize = 4;
                break;
            }
        }
}

UCHAR MatchOperand (PASM_VALUE pavOpnd, UCHAR tmplType)
{
    UCHAR    fMatch;

    //  if immediate operand, set minimum unsigned size

    if (pavOpnd->flags & fIMM) {
        pavOpnd->size = sizeD;
        if ((pavOpnd->flags & fSIGNED) || tmplType == typImmEx) {
            if ((LONG)pavOpnd->value >= -0x80L &&
                (LONG)pavOpnd->value <= 0x7fL)
                pavOpnd->size = sizeB;
            else if ((LONG)pavOpnd->value >= -0x8000L &&
                     (LONG)pavOpnd->value <= 0x7fffL)
                pavOpnd->size = sizeW;
            }
        else {
            if (pavOpnd->value <= 0xffL)
                pavOpnd->size = sizeB;
            else if (pavOpnd->value <= 0xffffL)
                pavOpnd->size = sizeW;
            }
        }

    //  start matching of operands
    //    compare the template and input operand types

    switch (tmplType) {
        case typAX:
            fMatch = (UCHAR)((pavOpnd->flags & fREG)
                        && pavOpnd->index == regG && pavOpnd->base == indAX);
            break;

        case typCL:
            fMatch = (UCHAR)((pavOpnd->flags & fREG)
                         && pavOpnd->index == regG && pavOpnd->size == sizeB
                         && pavOpnd->base == indCX);
            break;

        case typDX:
            fMatch = (UCHAR)((pavOpnd->flags & fREG)
                         && pavOpnd->index == regG && pavOpnd->size == sizeW
                         && pavOpnd->base == indDX);
            break;

        case typAbs:
            fMatch = (UCHAR)(pavOpnd->flags & fFPTR);
            break;

        case typExp:
            fMatch = (UCHAR)((pavOpnd->flags == fREG
                                        && pavOpnd->index == regG)
                        || ((pavOpnd->flags & fIMM) && pavOpnd->reloc == 1)
                        || (pavOpnd->flags & (fPTR | fPTR16 | fPTR32)) != 0);
            break;

        case typGen:
        case typReg:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                        && pavOpnd->index == regG);
            break;

        case typIm1:
            fMatch = (UCHAR)((pavOpnd->flags & fIMM) && pavOpnd->value == 1);
            break;

        case typIm3:
            fMatch = (UCHAR)((pavOpnd->flags & fIMM) && pavOpnd->value == 3);
            break;

        case typImm:
        case typImmEx:
            fMatch = (UCHAR)((pavOpnd->flags & fIMM) && pavOpnd->reloc == 0);
            break;

        case typJmp:
            fMatch = (UCHAR)(pavOpnd->flags & fIMM);
            break;

        case typMem:
            fMatch = (UCHAR)(((pavOpnd->flags & fIMM) && pavOpnd->reloc == 1)
                     || ((pavOpnd->flags & (fPTR | fPTR16 | fPTR32)) != 0));
            break;

        case typCtl:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regC);
            break;

        case typDbg:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regD);
            break;

        case typTrc:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regT);
            break;

        case typSt:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regF);
            break;

        case typSti:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regI);
            break;

        case typSeg:
            fMatch = (UCHAR)(pavOpnd->flags == fREG && pavOpnd->index == regS
                                && pavOpnd->base == segIndex);
            break;

        case typSgr:
            fMatch = (UCHAR)(pavOpnd->flags == fREG
                                                && pavOpnd->index == regS);
            break;

        case typXsi:
            fMatch = (UCHAR)(((pavOpnd->flags == fPTR16 && pavOpnd->base == 4)
                       || (pavOpnd->flags == fPTR32 && pavOpnd->base == indSI
                                                 && pavOpnd->index == 0xff))
                     && pavOpnd->value == 0
                     && (pavOpnd->segovr == segX
                                                || pavOpnd->segovr == segDS));
            break;

        case typYdi:
            fMatch = (UCHAR)(((pavOpnd->flags == fPTR16 && pavOpnd->base == 5)
                       || (pavOpnd->flags == fPTR32 && pavOpnd->base == indDI
                                                  && pavOpnd->index == 0xff))
                      && pavOpnd->value == 0
                      && pavOpnd->segovr == segES);
            break;

        case typOff:
            fMatch = (UCHAR)(((pavOpnd->flags & fIMM) && pavOpnd->reloc == 1)
                                                || pavOpnd->flags == fPTR);
            break;

        default:
            fMatch = FALSE;
            break;
        }

    return fMatch;
}

void OutputInstr (void)
{
    if (fWaitPrfx)
        *pchBin++ = 0x9b;
    if (fAddrOvrd)
        *pchBin++ = 0x67;
    if (fOpndOvrd)
        *pchBin++ = 0x66;
    if (segOvrd)
        *pchBin++ = segOvrd;
    if (preOpcode)
        *pchBin++ = preOpcode;
    *pchBin++ = inOpcode;
    if (postOpcode)
        *pchBin++ = postOpcode;
    if (fModrm)
        *pchBin++ = (UCHAR)((((modModrm << 3) + regModrm) << 3) + rmModrm);
    if (fSib)
        *pchBin++ = (UCHAR)((((scaleSib << 3) + indexSib) << 3) + baseSib);

    OutputValue(addrSize, (PUCHAR)&addrValue);     //  size = 0, 1, 2, 4
    OutputValue((UCHAR)(fSegPtr << 1), (PUCHAR)&segPtr); //  size = 0, 2
    OutputValue(immedSize, (PUCHAR)&immedValue);   //  size = 0, 1, 2, 4
    OutputValue(immedSize2, (PUCHAR)&immedValue2); //  size = 0, 1, 2, 4
}

void OutputValue (UCHAR size, PUCHAR pchValue)
{
    while (size--)
        *pchBin++ = *pchValue++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\expr.hpp ===
//----------------------------------------------------------------------------
//
// Expression evaluation.
//
// Copyright (C) Microsoft Corporation, 1997-2002.
//
//----------------------------------------------------------------------------

#ifndef _EXPR_H_
#define _EXPR_H_

#include <alloc.hpp>

#define DEFAULT_RANGE_LIMIT 0x100000

// Evaluator indices are in dbgeng.h:DEBUG_EXPR_*.
#define EVAL_COUNT 2

class EvalExpression;

extern ULONG g_EvalSyntax;
extern EvalExpression* g_EvalReleaseChain;
extern TypedData g_LastEvalResult;

EvalExpression* GetEvaluator(ULONG Syntax, BOOL RetFail);
#define GetCurEvaluator() GetEvaluator(g_EvalSyntax, FALSE)
void ReleaseEvaluator(EvalExpression* Eval);
void ReleaseEvaluators(void);
HRESULT GetEvaluatorByName(PCSTR AbbrevName, BOOL RetFail,
                           EvalExpression** EvalRet);

CHAR PeekChar(void);
BOOL GetRange(PADDR Addr, PULONG64 Value,
              ULONG Size, ULONG SegReg, ULONG SizeLimit);
ULONG64 EvalStringNumAndCatch(PCSTR String);
ULONG64 GetExpression(void);
ULONG64 GetExpressionDesc(PCSTR Desc);
ULONG64 GetTermExpression(PCSTR Desc);
void GetAddrExpression(ULONG SegReg, PADDR Addr);

// The recursive descent parsers can take a considerable amount
// of stack for just a simple expression due to the many layers
// of calls on the stack.  As most of the layers have trivial
// frames they respond well to optimization and fastcall to
// avoid using stack.  However, we don't currently build
// optimized binaries so this is useless and just makes the
// code harder to understand.
#if 1
#define EECALL
#else
#define EECALL FASTCALL
#endif

//----------------------------------------------------------------------------
//
// TypedDataStackAllocator.
//
// Specialized allocator for getting TypedData during evaluation.
// This is much more space-efficient than using the stack as
// many layers of the recursive decent will not need results of
// their own.
//
// Allocator throws NOMEMORY when out of memory.
//
//----------------------------------------------------------------------------

class TypedDataStackAllocator : public FixedSizeStackAllocator
{
public:
    TypedDataStackAllocator(EvalExpression* Eval)
        : FixedSizeStackAllocator(sizeof(TypedData), 64, TRUE)
    {
        m_Eval = Eval;
    }

private:
    virtual void* RawAlloc(ULONG Bytes);

    EvalExpression* m_Eval;
};

//----------------------------------------------------------------------------
//
// EvalExpression.
//
//----------------------------------------------------------------------------

enum EVAL_RESULT_KIND
{
    ERES_UNKNOWN,
    ERES_SYMBOL,
    ERES_TYPE,
    ERES_EXPRESSION,
};

#define EXPRF_DEFAULT              0x000000000
// In the MASM evaluator this indicates whether to evaluate
// symbols as their values or their addresses.  No effect
// on the C++ evaluator.
#define EXPRF_PREFER_SYMBOL_VALUES 0x000000001
// Evaluate just a single term.  Currently the term
// is always bracketed by '[' and ']'.
#define EXPRF_SINGLE_TERM          0x000000002

#define EvalCheck(Expr) \
    if (m_Err = (Expr)) EvalError(m_Err); else 0

class EvalExpression
{
public:
    EvalExpression(ULONG Syntax, PCSTR FullName, PCSTR AbbrevName);
    virtual ~EvalExpression(void);

    virtual PCSTR Evaluate(PCSTR Expr, PCSTR Desc, ULONG Flags,
                           TypedData* Result) = 0;
    virtual PCSTR EvaluateAddr(PCSTR Expr, PCSTR Desc,
                               ULONG SegReg, PADDR Addr) = 0;

    PCSTR EvalString(PCSTR String, TypedData* Result)
    {
        return Evaluate(String, NULL, EXPRF_DEFAULT, Result);
    }

    void EvalCurrent(TypedData* Result);
    void EvalCurAddrDesc(ULONG SegReg, PCSTR Desc, PADDR Addr);
    void EvalCurAddr(ULONG SegReg, PADDR Addr)
    {
        EvalCurAddrDesc(SegReg, NULL, Addr);
    }
    
    ULONG64 EvalStringNum(PCSTR String);
    ULONG64 EvalCurNumDesc(PCSTR Desc);
    ULONG64 EvalCurNum(void)
    {
        return EvalCurNumDesc(NULL);
    }

    ULONG64 EvalCurTermNumDesc(PCSTR Desc);

    void DECLSPEC_NORETURN EvalErrorDesc(ULONG Error, PCSTR Desc);
    void DECLSPEC_NORETURN EvalError(ULONG Error)
    {
        EvalErrorDesc(Error, NULL);
    }

    void Reset(void);
    
    void InheritStart(EvalExpression* Parent);
    void InheritEnd(EvalExpression* Parent);
    
    ULONG m_Syntax;
    PCSTR m_FullName;
    PCSTR m_AbbrevName;
    
    ULONG m_ParseOnly;

    ULONG m_AllowUnresolvedSymbols;
    ULONG m_NumUnresolvedSymbols;

    EvalExpression* m_ReleaseChain;
    BOOL m_ChainTop;
    
protected:
    void StartLexer(PCSTR Expr);
    void Start(PCSTR Expr, PCSTR Desc, ULONG Flags);
    void End(TypedData* Result);
    void StartLexeme(void)
    {
        m_LexemeStart = m_LexemeRestart;
        m_LexemeChar = m_LexemeStart;
        *m_LexemeChar = 0;
    }
    void AddLexeme(char Ch);
    
    TypedData* NewResult(void)
    {
        return (TypedData*)m_ResultAlloc.Alloc();
    }
    void DelResult(TypedData* Result)
    {
        m_ResultAlloc.Free(Result);
    }

    PCSTR m_ExprDesc;
    ULONG m_Flags;
    
    ProcessInfo* m_Process;
    MachineInfo* m_Machine;
    PCSTR m_Lex;
    char m_LexemeBuffer[1024];
    PSTR m_LexemeRestart;
    PSTR m_LexemeStart;
    PSTR m_LexemeChar;
    PCSTR m_LexemeSourceStart;
    TypedData m_TokenValue;
    BOOL m_AllowUnaryOp;
    ULONG m_PtrSize;
    TypedDataStackAllocator m_ResultAlloc;

    // Temporary local storage to avoid using space
    // for short-lived data.
    TypedData m_Tmp;
    ULONG m_Err;
};

//----------------------------------------------------------------------------
//
// MasmEvalExpression.
//
//----------------------------------------------------------------------------

class MasmEvalExpression : public EvalExpression
{
public:
    MasmEvalExpression(void);
    virtual ~MasmEvalExpression(void);

    virtual PCSTR Evaluate(PCSTR Expr, PCSTR Desc, ULONG Flags,
                           TypedData* Result);
    virtual PCSTR EvaluateAddr(PCSTR Expr, PCSTR Desc,
                               ULONG SegReg, PADDR Addr);

private:
    void ForceAddrExpression(ULONG SegReg, PADDR Address, ULONG64 Value);
    LONG64 GetTypedExpression(void);
    BOOL GetSymValue(PSTR Symbol, PULONG64 Value);
    char Peek(void);
    ULONG64 GetCommonExpression(void);
    LONG64 StartExpr(void);
    LONG64 GetLRterm(void);
    LONG64 GetLterm(void);
    LONG64 GetShiftTerm(void);
    LONG64 GetAterm(void);
    LONG64 GetMterm(void);
    LONG64 GetTerm(void);
    ULONG GetRegToken(PCHAR Str, PULONG64 Value);
    ULONG PeekToken(PLONG64 Value);
    void AcceptToken(void);
    ULONG GetTokenSym(PLONG64 Value);
    ULONG EvalSymbol(PSTR Name, PULONG64 Value);
    ULONG NextToken(PLONG64 Value);
    
    ULONG m_SavedClass;
    LONG64 m_SavedValue;
    PCSTR m_SavedCommand;
    BOOL m_ForcePositiveNumber;
    USHORT m_AddrExprType;
    ADDR m_TempAddr;
    // Syms in a expression evaluate to values rather than address
    BOOL m_TypedExpr;
};

//----------------------------------------------------------------------------
//
// CppEvalExpression.
//
//----------------------------------------------------------------------------

#define CPP_TOKEN_MULTI 256
#define CPP_KEYWORD_FIRST CppTokenSizeof
#define CPP_KEYWORD_LAST CppTokenTypeid

enum CppToken
{
    CppTokenError = 0,
    // Single-character tokens use the character value.
    CppTokenPeriod = '.', CppTokenQuestionMark = '?',
    CppTokenColon = ':', CppTokenComma = ',',
    CppTokenOpenParen = '(', CppTokenCloseParen = ')',
    CppTokenOpenBracket = '[', CppTokenCloseBracket = ']',
    CppTokenOpenAngle = '<', CppTokenCloseAngle = '>',
    CppTokenEof = CPP_TOKEN_MULTI,
    // Literals.
    CppTokenIdentifier, CppTokenInteger, CppTokenFloat,
    CppTokenCharString, CppTokenChar, CppTokenWcharString, CppTokenWchar,
    CppTokenDebugRegister, CppTokenModule, CppTokenSwitchEvalExpression,
    CppTokenPreprocFunction,
    // Relational operators.
    CppTokenEqual, CppTokenNotEqual, CppTokenLessEqual,
    CppTokenGreaterEqual,
    // Logical operators.
    CppTokenLogicalAnd, CppTokenLogicalOr,
    // Unary operators.
    CppTokenUnaryPlus, CppTokenUnaryMinus,
    // Shifts.
    CppTokenLeftShift, CppTokenRightShift,
    // Addresses.
    CppTokenAddressOf, CppTokenDereference, CppTokenPointerMember,
    CppTokenClassDereference, CppTokenClassPointerMember,
    // Assignment operators.
    CppTokenDivideAssign, CppTokenMultiplyAssign, CppTokenModuloAssign,
    CppTokenAddAssign, CppTokenSubtractAssign,
    CppTokenLeftShiftAssign, CppTokenRightShiftAssign,
    CppTokenAndAssign, CppTokenOrAssign, CppTokenExclusiveOrAssign,
    // Increments and decrements.
    CppTokenPreIncrement, CppTokenPreDecrement,
    CppTokenPostIncrement, CppTokenPostDecrement,
    // Namespaces.
    CppTokenNameQualifier, CppTokenDestructor,
    // Keywords.
    CppTokenSizeof, CppTokenThis, CppTokenOperator,
    CppTokenNew, CppTokenDelete,
    // Keep type keywords together for easy identification.
    CppTokenConst, CppTokenStruct, CppTokenClass, CppTokenUnion,
    CppTokenEnum, CppTokenVolatile, CppTokenSigned, CppTokenUnsigned,
    CppTokenDynamicCast, CppTokenStaticCast, CppTokenConstCast,
    CppTokenReinterpretCast, CppTokenTypeid,
    
    CppTokenCount
};

class CppEvalExpression : public EvalExpression
{
public:
    CppEvalExpression(void);
    virtual ~CppEvalExpression(void);

    PCSTR TokenImage(CppToken Token);
    
    CppToken Lex(void);
    
    virtual PCSTR Evaluate(PCSTR Expr, PCSTR Desc, ULONG Flags,
                           TypedData* Result);
    virtual PCSTR EvaluateAddr(PCSTR Expr, PCSTR Desc,
                               ULONG SegReg, PADDR Addr);

private:
    char GetStringChar(PBOOL Escaped);
    void FinishFloat(LONG64 IntPart, int Sign);
    CppToken ReadNumber(int Sign);
    void NextToken(void);
    void Match(CppToken Token);
    void Accept(void)
    {
        Match(m_Token);
    }

    void EECALL Expression(TypedData* Result);
    void EECALL Assignment(TypedData* Result);
    void EECALL Conditional(TypedData* Result);
    void EECALL LogicalOr(TypedData* Result);
    void EECALL LogicalAnd(TypedData* Result);
    void EECALL BitwiseOr(TypedData* Result);
    void EECALL BitwiseXor(TypedData* Result);
    void EECALL BitwiseAnd(TypedData* Result);
    void EECALL Equality(TypedData* Result);
    void EECALL Relational(TypedData* Result);
    void EECALL Shift(TypedData* Result);
    void EECALL Additive(TypedData* Result);
    void EECALL Multiplicative(TypedData* Result);
    void EECALL ClassMemberRef(TypedData* Result);
    void EECALL Cast(TypedData* Result);
    void EECALL Unary(TypedData* Result);
    void EECALL Postfix(TypedData* Result);
    void EECALL Term(TypedData* Result);
    EVAL_RESULT_KIND EECALL TryTypeName(TypedData* Result);
    EVAL_RESULT_KIND EECALL CollectTypeOrSymbolName(TypedData* Result);
    EVAL_RESULT_KIND EECALL CollectTemplateName(void);
    void EECALL CollectOperatorName(void);
    void EECALL UdtMember(TypedData* Result);
    void EECALL PreprocFunction(TypedData* Result);

    BOOL IsTypeKeyword(CppToken Token)
    {
        return Token >= CppTokenConst && Token <= CppTokenUnsigned;
    }
    BOOL IsAssignOp(CppToken Token)
    {
        return Token == '=' ||
            (Token >= CppTokenDivideAssign &&
             Token <= CppTokenExclusiveOrAssign);
    }

    TypedDataAccess CurrentAccess(void)
    {
        if (m_ParseOnly > 0)
        {
            return TDACC_NONE;
        }
        else if (m_PreprocEval)
        {
            return TDACC_ATTEMPT;
        }
        else
        {
            return TDACC_REQUIRE;
        }
    }
    
    static char s_EscapeChars[];
    static char s_EscapeCharValues[];
    static PCSTR s_MultiTokens[];

    CppToken m_Token;
    ULONG m_SwitchEvalSyntax;
    BOOL m_PreprocEval;
};

#endif // #ifndef _EXPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "i386_dis.h"

UCHAR g_X86Int3[] = { 0xcc };

//----------------------------------------------------------------------------
//
// BaseX86MachineInfo methods.
//
//----------------------------------------------------------------------------

/*****                     macros and defines                          *****/

#define X86_CS_OVR 0x2e

#define BIT20(b) ((b) & 0x07)
#define BIT53(b) (((b) >> 3) & 0x07)
#define BIT76(b) (((b) >> 6) & 0x03)
#define MAXOPLEN 10

/*****                     static tables and variables                 *****/

char* g_X86Reg8[] =
{
    "al", "cl", "dl", "bl", "ah", "ch", "dh", "bh",
    "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b"
};
char* g_Amd64ExtendedReg8[] =
{
    "al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil"
};
char* g_X86RegBase[] =
{
    "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
    "8", "9", "10", "11", "12", "13", "14", "15"
};
char *g_X86Mrm16[] =
{
    "bx+si", "bx+di", "bp+si", "bp+di", "si", "di", "bp", "bx",
    "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"
};
char *g_X86Mrm32[] =
{
    "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
    "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
};
char *g_X86Mrm64[] =
{
    "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};

UCHAR g_X86Reg16Idx[] =
{
    X86_NBX, X86_NBX, X86_NBP, X86_NBP,
    X86_NSI, X86_NDI, X86_NBP, X86_NBX,
};
UCHAR g_X86Reg16Idx2[] =
{
    X86_NSI, X86_NDI, X86_NSI, X86_NDI
};
UCHAR g_X86RegIdx[] =
{
    X86_NAX, X86_NCX, X86_NDX, X86_NBX,
    X86_NSP, X86_NBP, X86_NSI, X86_NDI,
    AMD64_R8, AMD64_R9, AMD64_R10, AMD64_R11,
    AMD64_R12, AMD64_R13, AMD64_R14, AMD64_R15
};

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char* g_CompareIb[] = { "eq", "lt", "le", "unord", "ne", "nlt", "nle", "ord" };

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

static int              g_MrmMod;       /* mod of mod/rm byte */
static int              g_MrmRm;        /* rm of mod/rm byte */
static int              g_MrmArg;       /* return reg value (of mod/rm) */
static unsigned char    *g_InstrMem;    /* current position in instruction */

ADDR                    EAaddr[2];      //  offset of effective address
static int              EAsize[2];      //  size of effective address item
static char             *g_EaSegNames[2];   //  normal segment for operand

#define IPREL_MARKER "<-IPREL->"

BOOL g_X86ModrmHasIpRelOffset;
LONG g_X86IpRelOffset;

int g_SegAddrMode;      /* global address size in bits */
int g_SegOpSize;        /* global operand size in bits */
int g_AddrMode;         /* local address size in bits */
int g_OpSize;           /* operand size in bits */

int g_ExtendOpCode;
int g_ExtendAny;
int g_ExtendMrmReg;
int g_ExtendSibIndex;
int g_ExtendRm;

BOOL g_MovX;            // Indicates a MOVSX or MOVZX.
BOOL g_MovSXD;
BOOL g_ForceMrmReg32;   // M/RM register is always 32-bit.
BOOL g_MmRegEa;         // Use mm? registers in reg-only EA.
BOOL g_XmmRegEa;        // Use xmm? registers in reg-only EA.
BOOL g_ControlFlow;     // Control flow instruction.

int  g_RepPrefix;

enum
{
    XMM_SS,
    XMM_SD,
    XMM_PS,
    XMM_PD,
};

int                     g_XmmOpSize;

enum
{
    JCC_EA_NONE,
    // Branch must be no-branch + 1.
    JCC_EA_NO_BRANCH,
    JCC_EA_BRANCH,
};

// First entry are bits that must be zero, second
// and third entries are bit shifts for bits that must match.
ULONG g_JccCheckTable[][3] =
{
    X86_BIT_FLAGOF, 0, 0,                               // JNO
    X86_BIT_FLAGCF, 0, 0,                               // JNB
    X86_BIT_FLAGZF, 0, 0,                               // JNZ
    X86_BIT_FLAGCF | X86_BIT_FLAGZF, 0, 0,              // JNBE
    X86_BIT_FLAGSF, 0, 0,                               // JNS
    X86_BIT_FLAGPF, 0, 0,                               // JNP
    0, 7, 11,                                           // JNL
    X86_BIT_FLAGZF, 7, 11,                              // JNLE
};

//      internal function definitions

void OutputHexString(char **, PUCHAR, int);
void OutputHexValue(char **, PUCHAR, int, int);
void OutputExHexValue(char **, PUCHAR, int, int);
void OutputHexCode(char **, PUCHAR, int);
void X86OutputString(char **, char *);

void OutputHexAddr(PSTR *, PADDR);

#define FormSelAddress(Addr, Sel, Off) \
    FormAddr(Sel, Off, 0, Addr)
#define FormSegRegAddress(Addr, SegReg, Off) \
    FormAddr(SegReg, Off, FORM_SEGREG, Addr)

void
GetSegAddrOpSizes(MachineInfo* Machine, PADDR Addr)
{
    if ((Type(*Addr) & ADDR_1664) ||
        ((Type(*Addr) & ADDR_FLAT) &&
         Machine->m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64))
    {
        g_SegAddrMode = 64;
        // X86-64 defaults to 32-bit operand sizes even in 64-bit code.
        // Only the address size changes.  An operand size prefix
        // switches from 32- to 64-bit.
        g_SegOpSize = 32;
    }
    else if (Type(*Addr) & (ADDR_V86 | ADDR_16))
    {
        g_SegAddrMode = 16;
        g_SegOpSize = 16;
    }
    else
    {
        g_SegAddrMode = 32;
        g_SegOpSize = 32;
    }

    g_AddrMode = g_SegAddrMode;
    g_OpSize = g_SegOpSize;
}

void
OverrideAddrMode(void)
{
    switch(g_SegAddrMode)
    {
    case 16:
        g_AddrMode = 32;
        break;
    case 32:
        g_AddrMode = 16;
        break;
    case 64:
        g_AddrMode = 32;
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
OverrideOpSize(int OverrideOp)
{
    switch(g_SegAddrMode)
    {
    case 16:
        g_OpSize = 32;
        break;
    case 32:
        g_OpSize = 16;
        break;
    case 64:
        // X86-64 defaults to 32-bit operand sizes even in 64-bit code.
        // Only the address size changes.  A REX operand size prefix
        // switches from 32- to 64-bit.
        if (OverrideOp == 0x66)
        {
            g_OpSize = 16;
        }
        else if (OverrideOp & 8)
        {
            g_OpSize = 64;
        }
        break;
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
ExtendOps(int opcode)
{
    // x86-64 uses these opcodes as the REX override.
    OverrideOpSize(opcode);

    g_ExtendOpCode = opcode;
    g_ExtendAny = 8;
    if (opcode & 1)
    {
        g_ExtendRm = 8;
    }
    if (opcode & 2)
    {
        g_ExtendSibIndex = 8;
    }
    if (opcode & 4)
    {
        g_ExtendMrmReg = 8;
    }
}

void
IgnoreExtend(BOOL Verbose)
{
    //
    // Resets any extensions that may have happened.
    // The REX prefix must be the last
    // prefix of an instruction and is ignored otherwise,
    // so this reset is done when any prefix is encountered
    // after the REX prefix.  This should normally never
    // happen but technically it's valid code so we should handle it.
    //

    if (g_ExtendOpCode)
    {
        if (Verbose)
        {
            WarnOut("REX prefix ignored\n");
        }

        if (g_ExtendOpCode & 8)
        {
            // Op size was changed so put it back.  This
            // is tricky since in theory an op size override
            // prefix could also be present, but let's not
            // worry about that for now.
            g_OpSize = g_SegOpSize;
        }

        g_ExtendOpCode = 0;
        g_ExtendAny = 0;
        g_ExtendRm = 0;
        g_ExtendSibIndex = 0;
        g_ExtendMrmReg = 0;
    }
}

struct AMD_3DNOW_OPSTR
{
    PSTR Str;
    UCHAR Opcode;
};

AMD_3DNOW_OPSTR g_Amd3DNowOpStr[] =
{
    "pavgusb", 0xBF,
    "pfadd", 0x9E,
    "pfsub", 0x9A,
    "pfsubr", 0xAA,
    "pfacc", 0xAE,
    "pfcmpge", 0x90,
    "pfcmpgt", 0xA0,
    "pfcmpeq", 0xB0,
    "pfmin", 0x94,
    "pfmax", 0xA4,
    "pi2fd", 0x0D,
    "pf2id", 0x1D,
    "pfrcp", 0x96,
    "pfrsqrt", 0x97,
    "pfmul", 0xB4,
    "pfrcpit1", 0xA6,
    "pfrsqit1", 0xA7,
    "pfrcpit2", 0xB6,
    "pmulhrw", 0xB7,
    "pf2iw", 0x1C,
    "pfnacc", 0x8A,
    "pfpnacc", 0x8E,
    "pi2fw", 0x0C,
    "pswapd", 0xBB,
};

PSTR
GetAmd3DNowOpString(UCHAR Opcode)
{
    UCHAR i;

    for (i = 0; i < sizeof(g_Amd3DNowOpStr) / sizeof(g_Amd3DNowOpStr[0]); i++)
    {
        if (g_Amd3DNowOpStr[i].Opcode == Opcode)
        {
            return g_Amd3DNowOpStr[i].Str;
        }
    }

    return NULL;
}

BOOL
BaseX86MachineInfo::Disassemble(ProcessInfo* Process,
                                PADDR paddr, PSTR pchDst, BOOL fEAout)
{
    ULONG64 Offset = Off(*paddr);
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    ULONG   instlen;                    /* instruction length */
    ULONG   cBytes;                     //  bytes read into instr buffer
    int     segOvr = 0;                 /* segment override opcode */
    UCHAR   membuf[X86_MAX_INSTRUCTION_LEN]; /* current instruction buffer */
    char    *pEAlabel = "";             //  optional label for operand

    char    *pchResultBuf = pchDst;     //  working copy of pchDst pointer
    char    RepPrefixBuffer[32];        //  rep prefix buffer
    char    *pchRepPrefixBuf = RepPrefixBuffer; //  pointer to prefix buffer
    char    OpcodeBuffer[16];           //  opcode buffer
    char    *pchOpcodeBuf = OpcodeBuffer;   //  pointer to opcode buffer
    char    OperandBuffer[MAX_SYMBOL_LEN + 20]; //  operand buffer
    char    *pchOperandBuf = OperandBuffer; //  pointer to operand buffer
    char    ModrmBuffer[MAX_SYMBOL_LEN + 20];   //  modRM buffer
    char    *pchModrmBuf = ModrmBuffer; //  pointer to modRM buffer
    char    EABuffer[128];              //  effective address buffer
    char    *pchEABuf = EABuffer;       //  pointer to EA buffer

    unsigned char BOPaction;
    int     subcode;                    /* bop subcode */
    int     JccEa;
    LONGLONG Branch;

    g_X86ModrmHasIpRelOffset = FALSE;
    g_MovX = FALSE;
    g_MovSXD = FALSE;
    g_ForceMrmReg32 = FALSE;
    g_MmRegEa = FALSE;
    g_XmmRegEa = FALSE;
    g_ControlFlow = FALSE;
    EAsize[0] = EAsize[1] = 0;          //  no effective address
    g_EaSegNames[0] = dszDS_;
    g_EaSegNames[1] = dszES_;
    g_RepPrefix = 0;
    g_XmmOpSize = XMM_PS;
    g_ExtendOpCode = 0;
    g_ExtendAny = 0;
    g_ExtendMrmReg = 0;
    g_ExtendSibIndex = 0;
    g_ExtendRm = 0;
    JccEa = JCC_EA_NONE;

    GetSegAddrOpSizes(this, paddr);
    alen = g_AddrMode / 8;
    olen = g_OpSize / 8;

    OutputHexAddr(&pchResultBuf, paddr);

    *pchResultBuf++ = ' ';

    if (fnotFlat(*paddr) ||
        m_Target->ReadVirtual(Process, Flat(*paddr),
                              membuf, X86_MAX_INSTRUCTION_LEN,
                              &cBytes) != S_OK)
    {
        ZeroMemory(membuf, X86_MAX_INSTRUCTION_LEN);
        cBytes = 0;
    }

    g_InstrMem = membuf;                /* point to begin of instruction */
    opcode = *g_InstrMem++;                   /* get opcode */

    if ( opcode == 0xc4 && *g_InstrMem == 0xC4 )
    {
        g_InstrMem++;
        X86OutputString(&pchOpcodeBuf,"BOP");
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *g_InstrMem;
        if ( subcode == 0x50 || subcode == 0x52 || subcode == 0x53 ||
             subcode == 0x54 || subcode == 0x57 || subcode == 0x58 ||
             subcode == 0x58 )
        {
            BOPaction = IW | END;
        }
    }
    else
    {
        X86OutputString(&pchOpcodeBuf, distbl[opcode].instruct);
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

/*****          loop through all operand actions               *****/

    do
    {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f)
        {
        case ALT:                   /* alter the opcode if not 16-bit */
            if (g_OpSize > 16)
            {
                indx = *action++;
                pchOpcodeBuf = &OpcodeBuffer[indx];
                if (indx == 0)
                {
                    X86OutputString(&pchOpcodeBuf, g_OpSize == 32 ?
                                    dszCWDE : dszCDQE);
                }
                else if (g_OpSize == 64)
                {
                    *pchOpcodeBuf++ = 'q';
                    if (indx == 1)
                    {
                        *pchOpcodeBuf++ = 'o';
                    }
                }
                else
                {
                    *pchOpcodeBuf++ = 'd';
                    if (indx == 1)
                    {
                        *pchOpcodeBuf++ = 'q';
                    }
                }
            }
            break;

        case XMMSD:                 /* SSE-style opcode rewriting */
            {
                char ScalarOrPacked, SingleOrDouble;
                char* DquOrQ, *DqOrQ, *SsdOrUpsd, *CvtPd, *CvtPs;
                char* MovQD6, *Shuf;
                char* Scan;

                g_MmRegEa = TRUE;
                DquOrQ = "q";
                DqOrQ = "q";
                SsdOrUpsd = "s?";
                CvtPd = NULL;
                CvtPs = NULL;
                MovQD6 = NULL;
                switch(g_RepPrefix)
                {
                case X86_REPN:
                    // Scalar double operation.
                    ScalarOrPacked = 's';
                    SingleOrDouble = 'd';
                    CvtPd = "pd2dq";
                    MovQD6 = "dq2q";
                    Shuf = "lw";
                    g_XmmOpSize = XMM_SD;
                    // Assume there was no other lock/rep/etc.
                    pchRepPrefixBuf = RepPrefixBuffer;
                    break;
                case X86_REP:
                    // Scalar single operation.
                    ScalarOrPacked = 's';
                    SingleOrDouble = 's';
                    CvtPd = "dq2pd";
                    CvtPs = "tps2dq";
                    MovQD6 = "q2dq";
                    Shuf = "hw";
                    g_XmmOpSize = XMM_SS;
                    // Assume there was no other lock/rep/etc.
                    pchRepPrefixBuf = RepPrefixBuffer;
                    break;
                default:
                    // No rep prefix means packed single or double
                    // depending on operand size.
                    ScalarOrPacked = 'p';
                    SsdOrUpsd = "up?";
                    if (g_OpSize == g_SegOpSize)
                    {
                        SingleOrDouble = 's';
                        CvtPs = "dq2ps";
                        Shuf = "w";
                        g_XmmOpSize = XMM_PS;
                    }
                    else
                    {
                        SingleOrDouble = 'd';
                        DqOrQ = "dq";
                        DquOrQ = "dqu";
                        CvtPd = "tpd2dq";
                        CvtPs = "ps2dq";
                        MovQD6 = "q";
                        Shuf = "d";
                        g_XmmRegEa = TRUE;
                        g_XmmOpSize = XMM_PD;
                    }
                    break;
                }

                pchOpcodeBuf = OpcodeBuffer;
                while (*pchOpcodeBuf && *pchOpcodeBuf != ' ')
                {
                    switch(*pchOpcodeBuf)
                    {
                    case ':':
                        *pchOpcodeBuf = ScalarOrPacked;
                        break;
                    case '?':
                        *pchOpcodeBuf = SingleOrDouble;
                        break;
                    case ',':
                        *pchOpcodeBuf = SingleOrDouble == 's' ? 'd' : 's';
                        break;
                    }

                    pchOpcodeBuf++;
                }

                switch(opcode)
                {
                case X86_MOVFREGMEM:
                case X86_MOVFMEMREG:
                    // Append characters for MOVS[SD] and MOVUP[SD].
                    strcpy(pchOpcodeBuf, SsdOrUpsd);
                    if ((Scan = strchr(pchOpcodeBuf, '?')) != NULL)
                    {
                        *Scan = SingleOrDouble;
                    }
                    pchOpcodeBuf += strlen(pchOpcodeBuf);
                    break;
                case X86_MOVNT:
                    // Append characters for MOVNTQ and MOVNTDQ.
                    X86OutputString(&pchOpcodeBuf, DqOrQ);
                    break;
                case X86_MASKMOV:
                    // Append characters for MASKMOVQ and MASKMOVDQU.
                    X86OutputString(&pchOpcodeBuf, DquOrQ);
                    break;
                case X86_CVTPD:
                    if (CvtPd == NULL)
                    {
                        // Invalid opcode.
                        pchOpcodeBuf = OpcodeBuffer;
                        X86OutputString(&pchOpcodeBuf, dszRESERVED);
                        action2 = END;
                    }
                    else
                    {
                        // Append characters for CVT<PD>.
                        X86OutputString(&pchOpcodeBuf, CvtPd);
                    }
                    break;
                case X86_CVTPS:
                    if (CvtPs == NULL)
                    {
                        // Invalid opcode.
                        pchOpcodeBuf = OpcodeBuffer;
                        X86OutputString(&pchOpcodeBuf, dszRESERVED);
                        action2 = END;
                    }
                    else
                    {
                        // Append characters for CVT<PS>.
                        X86OutputString(&pchOpcodeBuf, CvtPs);
                    }
                    break;
                case X86_MOVQ_D6:
                    if (MovQD6 == NULL)
                    {
                        // Invalid opcode.
                        pchOpcodeBuf = OpcodeBuffer;
                        X86OutputString(&pchOpcodeBuf, dszRESERVED);
                        action2 = END;
                    }
                    else
                    {
                        // Append characters for MOVQ D6 family.
                        X86OutputString(&pchOpcodeBuf, MovQD6);
                    }
                    break;
                case X86_PSHUF:
                    // Append characters for PSHUF variants.
                    X86OutputString(&pchOpcodeBuf, Shuf);
                    break;
                }
            }
            break;

        case AMD3DNOW:          /* AMD 3DNow post-instruction byte */
            {
                PSTR OpStr;

                // Get the trailing byte and look up
                // the opcode string.
                OpStr = GetAmd3DNowOpString(*g_InstrMem++);
                if (OpStr == NULL)
                {
                    // Not a defined 3DNow instruction.
                    // Leave the ??? in the opstring.
                    break;
                }

                // Update opstring to real text.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, OpStr);
            }
            break;

        case STROP:
            //  compute size of operands in indx
            //  also if dword operands, change fifth
            //  opcode letter from 'w' to 'd'.

            if (opcode & 1)
            {
                if (g_OpSize == 64)
                {
                    indx = 8;
                    OpcodeBuffer[4] = 'q';
                }
                else if (g_OpSize == 32)
                {
                    indx = 4;
                    OpcodeBuffer[4] = 'd';
                }
                else
                {
                    indx = 2;
                }
            }
            else
            {
                indx = 1;
            }

            if (*action & 1)
            {
                if (fEAout)
                {
                    if (g_AddrMode > 16)
                    {
                        FormSelAddress(&EAaddr[0], 0, GetReg64(X86_NSI));
                    }
                    else
                    {
                        FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                          GetReg16(X86_NSI));
                    }
                    EAsize[0] = indx;
                }
            }
            if (*action++ & 2)
            {
                if (fEAout)
                {
                    if (g_AddrMode > 16)
                    {
                        FormSelAddress(&EAaddr[1], 0, GetReg64(X86_NDI));
                    }
                    else
                    {
                        FormSegRegAddress(&EAaddr[1], SEGREG_ES,
                                          GetReg16(X86_NDI));
                    }
                    EAsize[1] = indx;
                }
            }
            break;

        case CHR:                   /* insert a character */
            *pchOperandBuf++ = *action++;
            break;

        case CREG:                  /* set debug, test or control reg */
            if (opcode & 0x04)
            {
                *pchOperandBuf++ = 't';
            }
            else if (opcode & 0x01)
            {
                *pchOperandBuf++ = 'd';
            }
            else
            {
                *pchOperandBuf++ = 'c';
            }
            *pchOperandBuf++ = 'r';
            if (g_MrmArg >= 10)
            {
                *pchOperandBuf++ = (char)('0' + g_MrmArg / 10);
                g_MrmArg %= 10;
            }
            *pchOperandBuf++ = (char)('0' + g_MrmArg);
            break;

        case SREG2:                 /* segment register */
            g_MrmArg = BIT53(opcode);    //  set value to fall through

        case SREG3:                 /* segment register */
            *pchOperandBuf++ = sregtab[g_MrmArg];  // reg is part of modrm
            *pchOperandBuf++ = 's';
            break;

        case BRSTR:                 /* get index to register string */
            g_MrmArg = *action++;        /*    from action table */
            goto BREGlabel;

        case BOREG:                 /* byte register (in opcode) */
            g_MrmArg = BIT20(opcode);    /* register is part of opcode */
            goto BREGlabel;

        case ALSTR:
            g_MrmArg = 0;                /* point to AL register */
        BREGlabel:
        case BREG:                  /* general register */
            if (g_ExtendAny && g_MrmArg < 8)
            {
                X86OutputString(&pchOperandBuf, g_Amd64ExtendedReg8[g_MrmArg]);
            }
            else
            {
                X86OutputString(&pchOperandBuf, g_X86Reg8[g_MrmArg]);
            }
            break;

        case WRSTR:                 /* get index to register string */
            g_MrmArg = *action++;        /*    from action table */
            goto WREGlabel;

        case VOREG:                 /* register is part of opcode */
            if (m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
                opcode >= 0x40 && opcode <= 0x4f)
            {
                // Get rid of the inc/dec text as this
                // isn't really an inc/dec.
                pchOpcodeBuf = OpcodeBuffer;

                // Process the REX override.
                ExtendOps(opcode);
                olen = g_OpSize / 8;
                action2 = 0;
                goto getNxtByte;
            }

            g_MrmArg = BIT20(opcode) + g_ExtendRm;
            goto VREGlabel;

        case AXSTR:
            g_MrmArg = 0;                /* point to eAX register */
        VREGlabel:
        case VREG:                  /* general register */
            if ((g_SegAddrMode == 64 &&
                 opcode >= 0x50 && opcode <= 0x5f) ||
                g_MrmArg >= 8)
            {
                // Push/pops are always 64-bit in 64-bit segments.
                *pchOperandBuf++ = 'r';
            }
            else if (g_OpSize == 32 ||
                     opcode == X86_PEXTRW ||
                     opcode == X86_PMOVMSKB)
            {
                *pchOperandBuf++ = 'e';
            }
            else if (g_OpSize == 64)
            {
                *pchOperandBuf++ = 'r';
            }
        WREGlabel:
        case WREG:                  /* register is word size */
            X86OutputString(&pchOperandBuf, g_X86RegBase[g_MrmArg]);
            if (g_MrmArg >= 8)
            {
                if (g_OpSize == 32)
                {
                    *pchOperandBuf++ = 'd';
                }
                else if (g_OpSize == 16)
                {
                    *pchOperandBuf++ = 'w';
                }
            }
            break;

        case MMORWREG:
            if (g_XmmOpSize == XMM_SS || g_XmmOpSize == XMM_SD)
            {
                goto VREGlabel;
            }
            // Fall through.
        MMWREGlabel:
        case MMWREG:
            if ((g_OpSize != g_SegOpSize &&
                 opcode != X86_CVTSPSD2SPI) ||
                (g_RepPrefix == X86_REP &&
                 (opcode == X86_MOVDQAU_MR || opcode == X86_MOVDQAU_RM)))
            {
                *pchOperandBuf++ = 'x';
            }
            *pchOperandBuf++ = 'm';
            *pchOperandBuf++ = 'm';
            if (g_MrmArg >= 10)
            {
                *pchOperandBuf++ = (char)('0' + g_MrmArg / 10);
                g_MrmArg %= 10;
            }
            *pchOperandBuf++ = g_MrmArg + '0';
            break;

        case XORMMREG:
            if (g_OpSize == g_SegOpSize)
            {
                goto MMWREGlabel;
            }
            // Fall through.
        case XMMWREG:
            if (opcode != X86_PSHUF || g_XmmOpSize != XMM_PS)
            {
                *pchOperandBuf++ = 'x';
            }
            *pchOperandBuf++ = 'm';
            *pchOperandBuf++ = 'm';
            if (g_MrmArg >= 10)
            {
                *pchOperandBuf++ = (char)('0' + g_MrmArg / 10);
                g_MrmArg %= 10;
            }
            *pchOperandBuf++ = g_MrmArg + '0';
            break;

        case IST_ST:
            X86OutputString(&pchOperandBuf, "st(0),st");
            *(pchOperandBuf - 5) += (char)g_MrmRm;
            break;

        case ST_IST:
            X86OutputString(&pchOperandBuf, "st,");
        case IST:
            X86OutputString(&pchOperandBuf, "st(0)");
            *(pchOperandBuf - 2) += (char)g_MrmRm;
            break;

        case xBYTE:                 /* set instruction to byte only */
            EAsize[0] = 1;
            pEAlabel = "byte ptr ";
            break;

        case VAR:
            if ((g_SegAddrMode == 64 || g_ExtendAny > 0) &&
                opcode == 0x63)
            {
                // In AMD64 REX32 and 64-bit modes this instruction
                // is MOVSXD r64, r/m32 instead of ARPL r/m, reg.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVSXD);
                action = &actiontbl[O_Reg_Modrm] + 1;
                g_OpSize = 64;
                g_MovSXD = TRUE;
                goto DWORDlabel;
            }
            else if (opcode == 0xff)
            {
                UCHAR Extra = BIT53(*g_InstrMem);
                if (Extra >= 2 && Extra <= 5)
                {
                    g_ControlFlow = TRUE;

                    // On x86-64 control-flow operations default to
                    // 64-bit opsize.
                    if (g_SegAddrMode == 64)
                    {
                        if (g_OpSize == 32)
                        {
                            g_OpSize = 64;
                        }
                    }
                }
                else if (g_SegAddrMode == 64 && Extra == 6)
                {
                    // Push/pops are always 64-bit in 64-bit segments.
                    g_OpSize = 64;
                }
            }
            else if (g_SegAddrMode == 64 && opcode == 0x8f)
            {
                // Push/pops are always 64-bit in 64-bit segments.
                g_OpSize = 64;
            }
            olen = g_OpSize / 8;

            if (g_OpSize == 64)
            {
                goto QWORDlabel;
            }
            else if (g_OpSize == 32)
            {
                goto DWORDlabel;
            }

        case xWORD:
            if (opcode == X86_PINSRW)
            {
                g_ForceMrmReg32 = TRUE;
            }
            EAsize[0] = 2;
            pEAlabel = "word ptr ";
            break;

        case EDWORD:
            // Control register opsize is mode-independent.
            g_OpSize = g_SegAddrMode;
            if (g_OpSize == 64)
            {
                goto QWORDlabel;
            }
        case xDWORD:
            if (opcode == X86_MOVDQ_7E && g_RepPrefix == X86_REP)
            {
                // Switch to MOVQ xmm1, xmm2/m64.
                pchRepPrefixBuf = RepPrefixBuffer;
                *(pchOpcodeBuf - 1) = 'q';
                EAsize[0] = 8;
                pEAlabel = "qword ptr ";
                g_XmmRegEa = TRUE;
                action = &actiontbl[O_Sd_XmmReg_qModrm] + 2;
                break;
            }
            // Fall through.
        DWORDlabel:
            EAsize[0] = 4;
            pEAlabel = "dword ptr ";
            break;

        case XMMOWORD:
            if (opcode == X86_PSHUF)
            {
                if (g_XmmOpSize == XMM_PS)
                {
                    g_MmRegEa = TRUE;
                    goto QWORDlabel;
                }
                else
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                    break;
                }
            }

            g_XmmRegEa = TRUE;
            if (opcode == X86_CVTPD)
            {
                if (g_XmmOpSize == XMM_SS)
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
                else
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                }
                break;
            }
            else if (opcode == X86_CVTPS)
            {
                EAsize[0] = 16;
                pEAlabel = "oword ptr ";
                break;
            }
            else if (opcode == X86_MOVQ_D6)
            {
                if (g_XmmOpSize == XMM_SD)
                {
                    // Switch to MOVDQ2Q mm, xmm.
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                    action = &actiontbl[O_MmReg_qModrm] + 1;
                    break;
                }
            }
            else if (opcode == X86_MOVHLPS && g_XmmOpSize == XMM_PS &&
                     BIT76(*g_InstrMem) == 3)
            {
                // reg-reg form of MOVLPS is called MOVHLPS.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVHLPS);
            }
            else if (opcode == X86_MOVLHPS && g_XmmOpSize == XMM_PS &&
                     BIT76(*g_InstrMem) == 3)
            {
                // reg-reg form of MOVHPS is called MOVLHPS.
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVLHPS);
            }

            // Fall through.

        OWORDlabel:
        case OWORD:
            switch(g_XmmOpSize)
            {
            case XMM_SS:
                EAsize[0] = 4;
                pEAlabel = "dword ptr ";
                if (opcode == X86_MOVQ_D6)
                {
                    // Switch to MOVQ xmm1, xmm2/m64.
                    g_XmmRegEa = FALSE;
                    action = &actiontbl[O_Sd_XmmReg_qModrm] + 1;
                }
                break;
            case XMM_SD:
                EAsize[0] = 8;
                pEAlabel = "qword ptr ";
                break;
            default:
                if (opcode == 0x112 || opcode == 0x113 ||
                    opcode == 0x116 || opcode == 0x117 ||
                    opcode == X86_MOVQ_D6 ||
                    (g_OpSize == g_SegOpSize &&
                     (opcode == 0x12c || opcode == X86_CVTSPSD2SPI ||
                      opcode == X86_CVTSPSD2SPSD)))
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
                else
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                }
                break;
            }
            break;

        case XMMXWORD:
            g_XmmRegEa = TRUE;
            if (g_OpSize == g_SegOpSize)
            {
                if (opcode == X86_MOVNT)
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
                else
                {
                    EAsize[0] = 4;
                    pEAlabel = "dword ptr ";
                }
            }
            else
            {
                if (opcode == X86_MOVNT)
                {
                    EAsize[0] = 16;
                    pEAlabel = "oword ptr ";
                }
                else
                {
                    EAsize[0] = 8;
                    pEAlabel = "qword ptr ";
                }
            }
            break;

        case MMQWORD:
            // The REX prefix is ignored in front of most
            // FP and MM operations.  The only affect it
            // has is to allow extended register selection.
            // Reset the opsize as the 64-bit opsize behavior
            // of the REX prefix is ignored.
            if (g_ExtendOpCode & 8)
            {
                g_OpSize = g_SegOpSize;
            }

            if (g_OpSize != g_SegOpSize &&
                (opcode == X86_MOVDQAU_MR || opcode == X86_MOVDQAU_RM))
            {
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVDQA);
            }
            else if (g_RepPrefix == X86_REP &&
                     (opcode == X86_MOVDQAU_MR || opcode == X86_MOVDQAU_RM))
            {
                pchRepPrefixBuf = RepPrefixBuffer;
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszMOVDQU);
                g_XmmRegEa = TRUE;
                goto OWORDlabel;
            }

            if (opcode == X86_CVTSPI2SPSD)
            {
                g_XmmRegEa = FALSE;
                if (g_XmmOpSize == XMM_SS || g_XmmOpSize == XMM_SD)
                {
                    g_MmRegEa = FALSE;
                    goto DWORDlabel;
                }
            }
            else if (g_OpSize != g_SegOpSize)
            {
                g_XmmRegEa = TRUE;
                goto OWORDlabel;
            }
            g_MmRegEa = TRUE;
        QWORDlabel:
        case QWORD:
            EAsize[0] = 8;
            pEAlabel = "qword ptr ";
            break;

        case TBYTE:
            EAsize[0] = 10;
            pEAlabel = "tbyte ptr ";
            break;

        case FARPTR:
            g_ControlFlow = TRUE;

            // On x86-64 control-flow operations default to
            // 64-bit opsize.
            if (g_SegAddrMode == 64)
            {
                if (g_OpSize == 32)
                {
                    g_OpSize = 64;
                }
            }

            switch(g_OpSize)
            {
            case 16:
                EAsize[0] = 4;
                pEAlabel = "dword ptr ";
                break;
            default:
                EAsize[0] = 6;
                pEAlabel = "fword ptr ";
                break;
            }
            break;

        case LMODRM:                //  output modRM data type
            if (g_MrmMod != 3)
            {
                X86OutputString(&pchOperandBuf, pEAlabel);
            }
            else
            {
                EAsize[0] = 0;
            }

        case MODRM:                 /* output modrm string */
            if (segOvr)             /* in case of segment override */
            {
                X86OutputString(&pchOperandBuf, distbl[segOvr].instruct);
            }
            *pchModrmBuf = '\0';
            X86OutputString(&pchOperandBuf, ModrmBuffer);
            break;

        case ADDRP:                 /* address pointer */
            // segment
            OutputHexString(&pchOperandBuf, g_InstrMem + olen, 2);
            *pchOperandBuf++ = ':';
            // offset
            OutputSymbol(&pchOperandBuf, g_InstrMem, olen, segOvr);
            g_InstrMem += olen + 2;
            break;

        case JCC8:
            JccEa = ComputeJccEa(opcode, fEAout);
            // Fall through.
        case REL8:                  /* relative address 8-bit */
            if (opcode == 0xe3 && g_AddrMode > 16)
            {
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, g_AddrMode == 64 ?
                                dszJRCXZ : dszJECXZ);
            }
            Branch = *(char *)g_InstrMem++; /* get the 8-bit rel offset */
            goto DoRelDispl;

        case JCCX:
            JccEa = ComputeJccEa(opcode, fEAout);
            // Fall through.
        case REL16:                 /* relative address 16-/32-bit */
            switch(g_AddrMode)
            {
            case 16:
                Branch = *(short UNALIGNED *)g_InstrMem;
                g_InstrMem += 2;
                break;
            default:
                Branch = *(long UNALIGNED *)g_InstrMem;
                g_InstrMem += 4;
                break;
            }
        DoRelDispl:
            /* calculate address */
            Branch += Offset + (g_InstrMem - membuf);
            // rel8 and rel16 are only used in control-flow
            // instructions so the target is always relative
            // to CS.  Pass in the CS override to force this.
            OutputSymbol(&pchOperandBuf, (PUCHAR)&Branch, alen, X86_CS_OVR);
            break;

        case UBYTE:                 //  unsigned byte for int/in/out
            OutputHexString(&pchOperandBuf, g_InstrMem, 1);  //  ubyte
            g_InstrMem++;
            break;

        case CMPIB:
            // Immediate byte comparison encoding for CMP[SP][SD].
            if (*g_InstrMem < 8)
            {
                X86OutputString(&pchOperandBuf, g_CompareIb[*g_InstrMem]);
                g_InstrMem++;
            }
            else
            {
                olen = 1;
                goto DoImmed;
            }
            break;

        case IB:                    /* operand is immediate byte */
            // postop for AAD/AAM is 0x0a
            if ((opcode & ~1) == 0xd4)
            {
                // test post-opcode byte
                if (*g_InstrMem++ != 0x0a)
                {
                    X86OutputString(&pchOperandBuf, dszRESERVED);
                }
                break;
            }
            olen = 1;               /* set operand length */
            goto DoImmed;

        case IW:                    /* operand is immediate word */
            olen = 2;               /* set operand length */

        case IV:                    /* operand is word or dword */
        DoImmed:
            // AMD64 immediates are only 64-bit in the case of
            // mov reg, immed.  All other operations involving
            // immediates stay 32-bit.
            if (olen == 8 &&
                (opcode < 0xb8 || opcode > 0xbf))
            {
                olen = 4;
            }
            OutputHexValue(&pchOperandBuf, g_InstrMem, olen, FALSE);
            g_InstrMem += olen;
            break;

        case XB:
            OutputExHexValue(&pchOperandBuf, g_InstrMem, 1, g_OpSize / 8);
            g_InstrMem++;
            break;

        case OFFS:                  /* operand is offset */
            EAsize[0] = (opcode & 1) ? olen : 1;

            if (segOvr)             /* in case of segment override */
            {
                X86OutputString(&pchOperandBuf, distbl[segOvr].instruct);
            }

            *pchOperandBuf++ = '[';
            //  offset
            OutputSymbol(&pchOperandBuf, g_InstrMem, alen, segOvr);
            g_InstrMem += alen;
            *pchOperandBuf++ = ']';
            break;

        case X86_GROUP:             /* operand is of group 1,2,4,6 or 8 */
            /* output opcode symbol */
            X86OutputString(&pchOpcodeBuf, group[*action++][g_MrmArg]);
            break;

        case GROUPT:                /* operand is of group 3,5 or 7 */
            indx = *action;         /* get indx into group from action */
            goto doGroupT;

        case EGROUPT:               /* x87 ESC (D8-DF) group index */
            indx = BIT20(opcode) * 2; /* get group index from opcode */
            /* some operand variations exist */
            if (g_MrmMod == 3)
            {
                /* for x87 and mod == 3 */
                ++indx;             /* take the next group table entry */
                if (indx == 3)
                {
                    /* for x87 ESC==D9 and mod==3 */
                    if (g_MrmArg > 3)
                    {
                        /* for those D9 instructions */
                        indx = 12 + g_MrmArg; /* offset index to table by 12 */
                        g_MrmArg = g_MrmRm;   /* set secondary index to rm */
                    }
                }
                else if (indx == 7)
                {
                    /* for x87 ESC==DB and mod==3 */
                    if (g_MrmArg == 4)
                    {
                        /* if g_MrmArg==4 */
                        g_MrmArg = g_MrmRm;     /* set secondary group table index */
                    }
                    else if ((g_MrmArg < 4) || (g_MrmArg > 4 && g_MrmArg < 7))
                    {
                        // adjust for pentium pro opcodes
                        indx = 24;   /* offset index to table by 24*/
                    }
                }
            }
        doGroupT:
            /* handle group with different types of operands */

            X86OutputString(&pchOpcodeBuf, groupt[indx][g_MrmArg].instruct);
            action = actiontbl + groupt[indx][g_MrmArg].opr;
            /* get new action */
            break;

        case OPC0F:              /* secondary opcode table (opcode 0F) */
            opcode = *g_InstrMem++;    /* get real opcode */
            g_MovX = (BOOL)(opcode == 0xBF || opcode == 0xB7);
            // Point opcode into secondary opcode portion of table.
            opcode += 256;
            goto getNxtByte1;

        case ADR_OVR:               /* address override */
            IgnoreExtend(TRUE);
            olen = g_OpSize / 8;
            OverrideAddrMode();
            alen = g_AddrMode / 8;
            goto getNxtByte;

        case OPR_OVR:               /* operand size override */
            IgnoreExtend(TRUE);
            OverrideOpSize(opcode);
            olen = g_OpSize / 8;
            goto getNxtByte;

        case SEG_OVR:               /* handle segment override */
            IgnoreExtend(TRUE);
            olen = g_OpSize / 8;
            segOvr = opcode;        /* save segment override opcode */
            pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
            goto getNxtByte;

        case REP:                   /* handle rep/lock prefixes */
            IgnoreExtend(TRUE);
            olen = g_OpSize / 8;
            g_RepPrefix = opcode;
            *pchOpcodeBuf = '\0';
            if (pchRepPrefixBuf != RepPrefixBuffer)
            {
                *pchRepPrefixBuf++ = ' ';
            }
            X86OutputString(&pchRepPrefixBuf, OpcodeBuffer);
            pchOpcodeBuf = OpcodeBuffer;
        getNxtByte:
            opcode = *g_InstrMem++;        /* next byte is opcode */
        getNxtByte1:
            action = actiontbl + distbl[opcode].opr;
            X86OutputString(&pchOpcodeBuf, distbl[opcode].instruct);
            break;

        case NOP:
            if (opcode == X86_PAUSE && g_RepPrefix == X86_REP)
            {
                pchRepPrefixBuf = RepPrefixBuffer;
                pchOpcodeBuf = OpcodeBuffer;
                X86OutputString(&pchOpcodeBuf, dszPAUSE);
            }
            // Fall through.
        default:                    /* opcode has no operand */
            break;
        }

        /* secondary action */
        switch (action2)
        {
        case MRM:
            /* generate modrm for later use */
            /* ignore if it has been generated */
            if (!mrm)
            {
                /* generate modrm */
                DIdoModrm(Process, &pchModrmBuf, segOvr, fEAout);
                mrm = TRUE;         /* remember its generation */
            }
            break;

        case COM:                   /* insert a comma after operand */
            *pchOperandBuf++ = ',';
            break;

        case END:                   /* end of instruction */
            end = TRUE;
            break;
        }
    } while (!end);                        /* loop til end of instruction */

/*****       prepare disassembled instruction for output              *****/

//    dprintf("EAaddr[] = %08lx\n", (ULONG)Flat(EAaddr[0]));


    instlen = (ULONG)(g_InstrMem - membuf);

    if (instlen < cBytes)
    {
        cBytes = instlen;
    }

    int obOpcode = m_Ptr64 ? 35 : 26;
    int obOpcodeMin;
    int obOpcodeMax;

    int obOperand = m_Ptr64 ? 43 : 34;
    int obOperandMin;
    int obOperandMax;

    int cbOpcode;
    int cbOperand;
    int cbOffset;
    int cbEAddr;

    int obLineEnd = g_OutputWidth - 3;

    if (g_AsmOptions & DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH)
    {
        // Extend the line end out a long way but
        // not so much that overflows may occur.
        obLineEnd = 0x7fffff;
    }

    if (!(g_AsmOptions & DEBUG_ASMOPT_NO_CODE_BYTES))
    {
        OutputHexCode(&pchResultBuf, membuf, cBytes);
    }
    else
    {
        obOpcode -= 16;
        obOperand -= 16;
    }

    if (instlen > cBytes)
    {
        *pchResultBuf++ = '?';
        *pchResultBuf++ = '?';
        //  point past unread byte
        AddrAdd(paddr, 1);
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + obOpcode);
        X86OutputString(&pchResultBuf, "???\n");
        *pchResultBuf++ = '\0';
        return FALSE;
    }

    AddrAdd(paddr, instlen);

    PSTR Mark;

    // Now that we know the complete size of the instruction
    // we can correctly compute IP-relative absolute addresses.
    *pchOperandBuf = 0;
    if (g_X86ModrmHasIpRelOffset &&
        (Mark = strstr(OperandBuffer, IPREL_MARKER)) != NULL)
    {
        PSTR TailFrom, TailTo;
        ULONG64 IpRelAddr;
        size_t TailLen;

        // Move the tail of the string to the end of the buffer
        // to make space.
        TailFrom = Mark + sizeof(IPREL_MARKER) - 1;
        TailLen = pchOperandBuf - TailFrom;
        TailTo = OperandBuffer + (sizeof(OperandBuffer) - 1 - TailLen);
        memmove(TailTo, TailFrom, TailLen);

        // Compute the absolute address from the new IP
        // and the offset and format it into the buffer.
        IpRelAddr = Flat(*paddr) + g_X86IpRelOffset;
        OutputSymbol(&Mark, (PUCHAR)&IpRelAddr, g_SegAddrMode == 64 ? 8 : 4,
                     X86_CS_OVR);
        if (Mark < TailTo)
        {
            memmove(Mark, TailTo, TailLen);
            pchOperandBuf = Mark + TailLen;
        }
        else if (Mark >= TailTo + TailLen)
        {
            pchOperandBuf = Mark;
        }
        else
        {
            pchOperandBuf = Mark + (TailLen - (Mark - TailTo));
        }
    }

    //  if fEAout is set, build each EA with trailing space in EABuf
    //  point back over final trailing space if buffer nonnull

    if (fEAout)
    {
        for (indx = 0; indx < 2; indx++)
        {
            if (EAsize[indx])
            {
                X86OutputString(&pchEABuf, segOvr ? distbl[segOvr].instruct
                                               : g_EaSegNames[indx]);
                OutputHexAddr(&pchEABuf, &EAaddr[indx]);
                *pchEABuf++ = '=';
                if (fFlat(EAaddr[indx]) &&
                    m_Target->ReadAllVirtual(Process, Flat(EAaddr[indx]),
                                             membuf, EAsize[indx]) == S_OK)
                {
                    OutputHexString(&pchEABuf, membuf, EAsize[indx]);
                }
                else
                {
                    while (EAsize[indx]--)
                    {
                        *pchEABuf++ = '?';
                        *pchEABuf++ = '?';
                    }
                }
                *pchEABuf++ = ' ';
            }
        }

        if (pchEABuf != EABuffer)
        {
            pchEABuf--;
        }

        switch(JccEa)
        {
        case JCC_EA_NO_BRANCH:
            X86OutputString(&pchEABuf, "[br=0]");
            break;
        case JCC_EA_BRANCH:
            X86OutputString(&pchEABuf, "[br=1]");
            break;
        }
    }

    //  compute lengths of component strings.
    //  if the rep string is nonnull,
    //      add the opcode string length to the operand
    //      make the rep string the opcode string

    cbOffset = (int)(pchResultBuf - pchDst);
    cbOperand = (int)(pchOperandBuf - OperandBuffer);
    cbOpcode = (int)(pchOpcodeBuf - OpcodeBuffer);
    if (pchRepPrefixBuf != RepPrefixBuffer)
    {
        cbOperand += cbOpcode + (cbOperand != 0);
        cbOpcode = (int)(pchRepPrefixBuf - RepPrefixBuffer);
    }
    cbEAddr = (int)(pchEABuf - EABuffer);

    //  compute the minimum and maximum offset values for
    //      opcode and operand strings.
    //  if strings are nonnull, add extra for separating space

    obOpcodeMin = cbOffset + 1;
    obOperandMin = obOpcodeMin + cbOpcode + 1;
    obOperandMax = obLineEnd - cbEAddr - (cbEAddr != 0) - cbOperand;
    obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;

    //  compute the opcode and operand offsets.  set offset as
    //      close to the default values as possible.

    if (obOpcodeMin > obOpcode)
    {
        obOpcode = obOpcodeMin;
    }
    else if (obOpcodeMax < obOpcode)
    {
        obOpcode = obOpcodeMax;
    }

    obOperandMin = obOpcode + cbOpcode + 1;

    if (obOperandMin > obOperand)
    {
        obOperand = obOperandMin;
    }
    else if (obOperandMax < obOperand)
    {
        obOperand = obOperandMax;
    }

    //  build the resultant string with the offsets computed

    //  output rep, opcode, and operand strings

    do
    {
        *pchResultBuf++ = ' ';
    } while (pchResultBuf < pchDst + obOpcode);

    if (pchRepPrefixBuf != RepPrefixBuffer)
    {
        *pchRepPrefixBuf = '\0';
        X86OutputString(&pchResultBuf, RepPrefixBuffer);
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + obOperand);
    }

    *pchOpcodeBuf = '\0';
    X86OutputString(&pchResultBuf, OpcodeBuffer);

    if (pchOperandBuf != OperandBuffer)
    {
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + obOperand);
        *pchOperandBuf = '\0';
        X86OutputString(&pchResultBuf, OperandBuffer);
    }

    //  append the EAddr string

    if (pchEABuf != EABuffer)
    {
        *pchEABuf = '\0';
        do
        {
            *pchResultBuf++ = ' ';
        } while (pchResultBuf < pchDst + obLineEnd - cbEAddr);
        X86OutputString(&pchResultBuf, EABuffer);
    }

    *pchResultBuf++ = '\n';
    *pchResultBuf = '\0';
    return TRUE;
}

void
BaseX86MachineInfo::GetNextOffset(ProcessInfo* Process, BOOL StepOver,
                                  PADDR NextAddr, PULONG NextMachine)
{
    ULONG   cBytes;
    UCHAR   membuf[X86_MAX_INSTRUCTION_LEN]; //  current instruction buffer
    UCHAR   *InstrMem;
    UCHAR   opcode;
    int     fPrefix = TRUE;
    int     fRepPrefix = FALSE;
    int     MrmMod;
    int     MrmArg;
    int     MrmRm;
    ULONG64 instroffset;
    int     subcode;

    // NextMachine is always the same.
    *NextMachine = m_ExecTypes[0];

    //  read instruction stream bytes into membuf and set mode and
    //      opcode size flags

    GetPC(NextAddr);
    instroffset = Flat(*NextAddr);
    GetSegAddrOpSizes(this, NextAddr);

    /* move full inst to local buffer */
    if (fnotFlat(*NextAddr) ||
        m_Target->ReadVirtual(Process, Flat(*NextAddr),
                              membuf, X86_MAX_INSTRUCTION_LEN,
                              &cBytes) != S_OK)
    {
        cBytes = 0;
    }

    // Ensure that membuf is padded with innocuous bytes in
    // the section that wasn't read.
    if (cBytes < X86_MAX_INSTRUCTION_LEN)
    {
        memset(membuf + cBytes, 0xcc, X86_MAX_INSTRUCTION_LEN - cBytes);
    }

    /* point to begin of instruction */
    InstrMem = membuf;

    //  read and process any prefixes first

    do
    {
        opcode = *InstrMem++;        /* get opcode */
        if (opcode == 0x66)
        {
            OverrideOpSize(opcode);
        }
        else if (m_ExecTypes[0] == IMAGE_FILE_MACHINE_AMD64 &&
                 opcode >= 0x40 && opcode <= 0x4f)
        {
            ExtendOps(opcode);
        }
        else if (opcode == 0x67)
        {
            OverrideAddrMode();
        }
        else if ((opcode & ~1) == 0xf2)
        {
            fRepPrefix = TRUE;
        }
        else if (opcode != 0xf0 && (opcode & ~0x18) != 0x26 &&
                 (opcode & ~1) != 0x64)
        {
            fPrefix = FALSE;
        }
    } while (fPrefix);

    //  for instructions that alter the TF (trace flag), return the
    //      offset of the next instruction despite the flag of StepOver

    if (((opcode & ~0x3) == 0x9c) && !g_WatchTrace)
    {
        //  9c-9f, pushf, popf, sahf, lahf
        ;
    }
    else if (opcode == 0xcf)
    {
        ULONG64 RetAddr[2];
        ADDR Sp;
        ULONG Seg;

        //  cf - iret - get RA from stack
        FormSegRegAddress(&Sp, SEGREG_STACK, GetReg64(X86_NSP));

        if (fnotFlat(Sp) ||
            m_Target->ReadAllVirtual(Process, Flat(Sp),
                                     RetAddr, g_SegAddrMode / 4) != S_OK)
        {
            instroffset = OFFSET_TRACE;
            goto Exit;
        }

        Seg = *(PUSHORT)((PUCHAR)RetAddr + g_SegAddrMode / 8);
        switch(g_SegAddrMode)
        {
        case 16:
            instroffset = EXTEND64(*(PUSHORT)RetAddr);
            break;
        case 32:
            instroffset = EXTEND64(*(PULONG)RetAddr);
            break;
        case 64:
            instroffset = RetAddr[0];
            break;
        }

        FormSelAddress(NextAddr, Seg, instroffset);
        ComputeFlatAddress(NextAddr, NULL);
        return;
    }
    else if (opcode == 0xc4 && *InstrMem == 0xc4)
    {
        subcode = *(InstrMem+1);
        if ( subcode == 0x50 ||
             subcode == 0x52 ||
             subcode == 0x53 ||
             subcode == 0x54 ||
             subcode == 0x57 ||
             subcode == 0x58 ||
             subcode == 0x5D )
        {
            InstrMem += 3;
        }
        else
        {
            InstrMem += 2;
        }
    }
    else if (!StepOver)
    {
        //  if tracing just return OFFSET_TRACE to trace
        instroffset = OFFSET_TRACE;
    }
    else if (opcode == 0xe8)
    {
        //  near direct jump
        InstrMem += g_OpSize > 16 ? 4 : 2;
    }
    else if (opcode == 0x9a)
    {
        //  far direct jump
        InstrMem += g_OpSize > 16 ? 6 : 4;
    }
    else if (opcode == 0xcd ||
             (opcode >= 0xe0 && opcode <= 0xe2))
    {
        //  loop / int nn instrs
        InstrMem++;
    }
    else if (opcode == 0xff)
    {
        //  indirect call - compute length
        opcode = *InstrMem++;               //  get modRM
        MrmArg = BIT53(opcode);
        if ((MrmArg & ~1) == 2)
        {
            MrmMod = BIT76(opcode);
            if (MrmMod != 3)
            {
                //  nonregister operand
                MrmRm = BIT20(opcode);
                if (g_AddrMode > 16)
                {
                    if (MrmRm == 4)
                    {
                        MrmRm = BIT20(*InstrMem++);    //  get base from SIB
                    }
                    if (MrmMod == 0)
                    {
                        if (MrmRm == 5)
                        {
                            InstrMem += 4;          //  long direct address
                        }                       //  else register
                    }
                    else if (MrmMod == 1)
                    {
                        InstrMem++;                 //  register with byte offset
                    }
                    else
                    {
                        InstrMem += 4;              //  register with long offset
                    }
                }
                else
                {
                    // 16-bit mode
                    if (MrmMod == 0)
                    {
                        if (MrmRm == 6)
                        {
                            InstrMem += 2;          //  short direct address
                        }
                    }
                    else
                    {
                        InstrMem += MrmMod;            //  reg, byte, word offset
                    }
                }
            }
        }
        else
        {
            instroffset = OFFSET_TRACE;         //  0xff, but not call
        }
    }
    else if (!((fRepPrefix && ((opcode & ~3) == 0x6c ||
                               (opcode & ~3) == 0xa4 ||
                               (opcode & ~1) == 0xaa ||
                               (opcode & ~3) == 0xac)) ||
                               opcode == 0xcc || opcode == 0xce))
    {
        instroffset = OFFSET_TRACE;             //  not repeated string op
    }                                           //  or int 3 / into

    //  if not enough bytes were read for instruction parse,
    //      just give up and trace the instruction

    if (cBytes < (ULONG)(InstrMem - (PUCHAR)membuf))
    {
        instroffset = OFFSET_TRACE;
    }

 Exit:
    //  if not tracing, compute the new instruction offset

    if (instroffset != OFFSET_TRACE)
    {
        instroffset += InstrMem - (PUCHAR)membuf;
    }

    Flat(*NextAddr) = instroffset;
    ComputeNativeAddress(NextAddr);
}

/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void
BaseX86MachineInfo::DIdoModrm(ProcessInfo* Process,
                              char **ppchBuf, int segOvr, BOOL fEAout)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *g_InstrMem++;                      /* get the mrm byte from instruction */
    g_MrmMod = BIT76(mrm);                   /* get mod */
    g_MrmArg = BIT53(mrm) + g_ExtendMrmReg;  /* get reg - used outside routine */
    g_MrmRm  = BIT20(mrm);                   /* get rm */

    if (g_MrmMod == 3)
    {
        g_MrmRm += g_ExtendRm;

        /* register only mode */
        if (g_XmmRegEa)
        {
            *(*ppchBuf)++ = 'x';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            if (g_MrmRm >= 10)
            {
                *(*ppchBuf)++ = (char)('0' + g_MrmRm / 10);
                g_MrmRm %= 10;
            }
            *(*ppchBuf)++ = g_MrmRm + '0';
        }
        else if (g_MmRegEa)
        {
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = g_MrmRm + '0';
        }
        else
        {
            if (EAsize[0] == 1)
            {
                /* point to 8-bit register */
                if (g_ExtendAny && g_MrmRm < 8)
                {
                    src = g_Amd64ExtendedReg8[g_MrmRm];
                }
                else
                {
                    src = g_X86Reg8[g_MrmRm];
                }
                X86OutputString(ppchBuf, src);
            }
            else
            {
                src = g_X86RegBase[g_MrmRm];
                if (g_ForceMrmReg32)
                {
                    *(*ppchBuf)++ = 'e';
                }
                else if (g_OpSize > 16 &&
                         (!g_MovX || g_MrmRm >= 8))
                {
                    /* make it a 32- or 64-bit register */
                    *(*ppchBuf)++ = (g_MrmRm >= 8 || g_OpSize == 64 && !g_MovSXD) ?
                        'r' : 'e';
                }
                X86OutputString(ppchBuf, src);
                if (g_MrmRm >= 8)
                {
                    if (g_OpSize == 32)
                    {
                        *(*ppchBuf)++ = 'd';
                    }
                    else if (g_OpSize == 16)
                    {
                        *(*ppchBuf)++ = 'w';
                    }
                }

                if (g_ControlFlow && fEAout)
                {
                    // This is a call/jmp through a register.
                    // Output a code symbol for the target.
                    ULONG64 Target = GetReg64(g_X86RegIdx[g_MrmRm]);
                    *(*ppchBuf)++ = ' ';
                    *(*ppchBuf)++ = '{';
                    OutputSymbol(ppchBuf, (PUCHAR)&Target, g_OpSize / 8,
                                 X86_CS_OVR);
                    *(*ppchBuf)++ = '}';
                }
            }
        }
        EAsize[0] = 0;                  //  no EA value to output
        return;
    }

    if (g_AddrMode == 64)
    {
        oldrm = g_MrmRm;
        if (g_MrmRm == 4)
        {
            /* g_MrmRm == 4 implies sib byte */
            sib = *g_InstrMem++;              /* get s_i_b byte */
            g_MrmRm = BIT20(sib);
        }

        *(*ppchBuf)++ = '[';
        if (g_MrmMod == 0 && g_MrmRm == 5)
        {
            if (g_SegAddrMode == 64 && oldrm == 5)
            {
                // IP-relative 32-bit displacement.  The
                // displacement is relative to the IP of the
                // next instruction, which can't be computed
                // yet so just put in a marker for post-processing.
                g_X86ModrmHasIpRelOffset = TRUE;
                g_X86IpRelOffset = *(LONG UNALIGNED *)g_InstrMem;
                X86OutputString(ppchBuf, IPREL_MARKER);
            }
            else
            {
                // Absolute 32-bit displacement.
                OutputSymbol(ppchBuf, g_InstrMem, 4, segOvr);
            }

            g_InstrMem += 4;
        }
        else
        {
            g_MrmRm += g_ExtendRm;

            if (fEAout)
            {
                if (segOvr)
                {
                    FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr),
                                      GetReg64(g_X86RegIdx[g_MrmRm]));
                    g_EaSegNames[0] = distbl[segOvr].instruct;
                }
                else if (g_X86RegIdx[g_MrmRm] == X86_NBP ||
                         g_X86RegIdx[g_MrmRm] == X86_NSP)
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_STACK,
                                      GetReg64(g_X86RegIdx[g_MrmRm]));
                    g_EaSegNames[0] = dszSS_;
                }
                else
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                      GetReg64(g_X86RegIdx[g_MrmRm]));
                }
            }
            X86OutputString(ppchBuf, g_X86Mrm64[g_MrmRm]);
        }

        if (oldrm == 4)
        {
            //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4)
            {
                ind += g_ExtendSibIndex;
                *(*ppchBuf)++ = '+';
                X86OutputString(ppchBuf, g_X86Mrm64[ind]);
                ss = 1 << BIT76(sib);
                if (ss != 1)
                {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                }
                if (fEAout)
                {
                    AddrAdd(&EAaddr[0], GetReg64(g_X86RegIdx[ind]) * ss);
                }
            }
        }
    }
    else if (g_AddrMode == 32)
    {
        oldrm = g_MrmRm;
        if (g_MrmRm == 4)
        {
            /* g_MrmRm == 4 implies sib byte */
            sib = *g_InstrMem++;              /* get s_i_b byte */
            g_MrmRm = BIT20(sib);
        }

        *(*ppchBuf)++ = '[';
        if (g_MrmMod == 0 && g_MrmRm == 5)
        {
            if (g_SegAddrMode == 64 && oldrm == 5)
            {
                // IP-relative 32-bit displacement.  The
                // displacement is relative to the IP of the
                // next instruction, which can't be computed
                // yet so just put in a marker for post-processing.
                g_X86ModrmHasIpRelOffset = TRUE;
                g_X86IpRelOffset = *(LONG UNALIGNED *)g_InstrMem;
                X86OutputString(ppchBuf, IPREL_MARKER);
            }
            else
            {
                // Absolute 32-bit displacement.
                OutputSymbol(ppchBuf, g_InstrMem, 4, segOvr);
            }

            g_InstrMem += 4;
        }
        else
        {
            g_MrmRm += g_ExtendRm;

            if (fEAout)
            {
                if (segOvr)
                {
                    FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr),
                                      EXTEND64(GetReg32(g_X86RegIdx[g_MrmRm])));
                    g_EaSegNames[0] = distbl[segOvr].instruct;
                }
                else if (g_X86RegIdx[g_MrmRm] == X86_NBP ||
                         g_X86RegIdx[g_MrmRm] == X86_NSP)
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_STACK,
                                      EXTEND64(GetReg32(g_X86RegIdx[g_MrmRm])));
                    g_EaSegNames[0] = dszSS_;
                }
                else
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                      EXTEND64(GetReg32(g_X86RegIdx[g_MrmRm])));
                }
            }
            X86OutputString(ppchBuf, g_X86Mrm32[g_MrmRm]);
        }

        if (oldrm == 4)
        {
            //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4)
            {
                ind += g_ExtendSibIndex;
                *(*ppchBuf)++ = '+';
                X86OutputString(ppchBuf, g_X86Mrm32[ind]);
                ss = 1 << BIT76(sib);
                if (ss != 1)
                {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                }
                if (fEAout)
                {
                    AddrAdd(&EAaddr[0],
                            EXTEND64(GetReg32(g_X86RegIdx[ind])) * ss);
                }
            }
        }
    }
    else
    {
        //  16-bit addressing mode
        *(*ppchBuf)++ = '[';
        if (g_MrmMod == 0 && g_MrmRm == 6)
        {
            OutputSymbol(ppchBuf, g_InstrMem, 2, segOvr);   // 16-bit offset
            g_InstrMem += 2;
        }
        else
        {
            if (fEAout)
            {
                if (segOvr)
                {
                    FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr),
                                      GetReg16(g_X86Reg16Idx[g_MrmRm]));
                    g_EaSegNames[0] = distbl[segOvr].instruct;
                }
                else if (g_X86Reg16Idx[g_MrmRm] == X86_NBP)
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_STACK,
                                      GetReg16(g_X86Reg16Idx[g_MrmRm]));
                    g_EaSegNames[0] = dszSS_;
                }
                else
                {
                    FormSegRegAddress(&EAaddr[0], SEGREG_DATA,
                                      GetReg16(g_X86Reg16Idx[g_MrmRm]));
                }
                if (g_MrmRm < 4)
                {
                    AddrAdd(&EAaddr[0], GetReg16(g_X86Reg16Idx2[g_MrmRm]));
                }
            }
            X86OutputString(ppchBuf, g_X86Mrm16[g_MrmRm]);
        }
    }

    //  output any displacement

    if (g_MrmMod == 1)
    {
        if (fEAout)
        {
            AddrAdd(&EAaddr[0], (long)*(char *)g_InstrMem);
        }
        OutputHexValue(ppchBuf, g_InstrMem, 1, TRUE);
        g_InstrMem++;
    }
    else if (g_MrmMod == 2)
    {
        long tmp = 0;
        if (g_AddrMode > 16)
        {
            memmove(&tmp, g_InstrMem, sizeof(long));
            if (fEAout)
            {
                AddrAdd(&EAaddr[0], tmp);
            }
            OutputHexValue(ppchBuf, g_InstrMem, 4, TRUE);
            g_InstrMem += 4;
        }
        else
        {
            memmove(&tmp,g_InstrMem,sizeof(short));
            if (fEAout)
            {
                AddrAdd(&EAaddr[0], tmp);
            }
            OutputHexValue(ppchBuf, g_InstrMem, 2, TRUE);
            g_InstrMem += 2;
        }
    }

    if (g_AddrMode == 16 && fEAout)
    {
        Off(EAaddr[0]) &= 0xffff;
        NotFlat(EAaddr[0]);
        Off(EAaddr[1]) &= 0xffff;
        NotFlat(EAaddr[1]);
        ComputeFlatAddress(&EAaddr[0], NULL);
        ComputeFlatAddress(&EAaddr[1], NULL);
    }

    *(*ppchBuf)++ = ']';

    // The value at the effective address may be pointing to an interesting
    // symbol, as with indirect jumps or memory operations.
    // If there's an EA and an exact symbol match, display
    // the extra symbol.
    if (fEAout)
    {
        DWORD64 symbol;

        if (m_Target->
            ReadPointer(Process, this, Flat(EAaddr[0]), &symbol) == S_OK)
        {
            char* pchBuf = *ppchBuf;

            (*ppchBuf)++;
            if (OutputExactSymbol(ppchBuf, (PUCHAR)&symbol,
                                  m_Ptr64 ? 8 : 4, segOvr))
            {
                *pchBuf = '{';
                *(*ppchBuf)++ = '}';
            }
            else
            {
                (*ppchBuf)--;
            }
        }
    }
}

LONGLONG
GetSignExtendedValue(int OpLen, PUCHAR Mem)
{
    switch(OpLen)
    {
    case 1:
        return *(char *)Mem;
    case 2:
        return *(short UNALIGNED *)Mem;
    case 4:
        return *(long UNALIGNED *)Mem;
    case 8:
        return *(LONGLONG UNALIGNED *)Mem;
    }

    DBG_ASSERT(FALSE);
    return 0;
}

/*** OutputHexValue - output hex value
*  07-Jun-1999 -by- Andre Vachon
*   Purpose:
*       Output the value pointed by *ppchBuf of the specified
*       length.  The value is treated as signed and leading
*       zeroes are not printed.  The string is prefaced by a
*       '+' or '-' sign as appropriate.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value (1, 2, and 4 supported)
*       fDisp - set if displacement to output '+'
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void
OutputHexValue (char **ppchBuf, PUCHAR pchMemBuf, int length, int fDisp)
{
    LONGLONG value;
    int index;
    char digit[32];

    value = GetSignExtendedValue(length, pchMemBuf);

    length <<= 1;               //  shift once to get hex length

    if (value != 0 || !fDisp)
    {
        if (fDisp)
        {
            //  use neg value for byte displacement
            //  assume very large DWORDs are negative too
            if (value < 0 &&
                (length == 2 ||
                 ((unsigned long)value & 0xff000000) == 0xff000000))
            {
                value = -value;
                *(*ppchBuf)++ = '-';
            }
            else
            {
                *(*ppchBuf)++ = '+';
            }
        }

        *(*ppchBuf)++ = '0';
        *(*ppchBuf)++ = 'x';
        for (index = length - 1; index != -1; index--)
        {
            digit[index] = (char)(value & 0xf);
            value >>= 4;
        }
        index = 0;
        while (digit[index] == 0 && index < length - 1)
        {
            index++;
        }
        while (index < length)
        {
            *(*ppchBuf)++ = hexdigit[digit[index++]];
        }
    }
}

void
OutputExHexValue(char **ppchBuf, PUCHAR pchMemBuf, int MemLen, int OpLen)
{
    LONGLONG Value = GetSignExtendedValue(MemLen, pchMemBuf);
    OutputHexValue(ppchBuf, (PUCHAR)&Value, OpLen, FALSE);
}

/*** OutputHexString - output hex string
*
*   Purpose:
*       Output the value pointed by *ppchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*       *ppchMemBuf - pointer update to next memory byte
*
*************************************************************************/

void
OutputHexString (char **ppchBuf, PUCHAR pchValue, int length)
{
    UCHAR chMem;

    pchValue += length;
    while (length--)
    {
        chMem = *--pchValue;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
    }
}

/*** OutputHexCode - output hex code
*
*   Purpose:
*       Output the code pointed by pchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.  This differs from OutputHexString
*       in that bytes are printed from low to high addresses.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void OutputHexCode (char **ppchBuf, PUCHAR pchMemBuf, int length)
{
    UCHAR chMem;

    while (length--)
    {
        chMem = *pchMemBuf++;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
    }
}

/*** X86OutputString - output string
*
*   Purpose:
*       Copy the string into the buffer pointed by *ppBuf.
*
*   Input:
*       *pStr - pointer to string
*
*   Output:
*       *ppBuf points to next character in buffer.
*
*************************************************************************/

void
X86OutputString (
    char **ppBuf,
    char *pStr
    )
{
    while (*pStr)
    {
        *(*ppBuf)++ = *pStr++;
    }
}


/*** OutputSymbol - output symbolic value
*
*   Purpose:
*       Output the value in outvalue into the buffer
*       pointed by *pBuf.  Express the value as a
*       symbol plus displacment, if possible.
*
*   Input:
*       *ppBuf - pointer to text buffer to fill
*       *pValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppBuf - pointer updated to next text character
*
*************************************************************************/

void
BaseX86MachineInfo::OutputSymbol (
    char **ppBuf,
    PUCHAR pValue,
    int length,
    int segOvr
    )
{
    CHAR   chSymbol[MAX_SYMBOL_LEN];
    ULONG64 displacement;
    ULONG64 value;

    value = 0;
    memcpy(&value, pValue, length);
    if (length == 4)
    {
        value = EXTEND64(value);
    }

    if (IS_CONTEXT_POSSIBLE(m_Target))
    {
        FormSegRegAddress(&EAaddr[0], GetSegReg(segOvr), value);
        value = Flat(EAaddr[0]);
    }

    GetSymbol(value, chSymbol, sizeof(chSymbol), &displacement);
    if (chSymbol[0])
    {
        X86OutputString(ppBuf, chSymbol);
        OutputHexValue(ppBuf, (PUCHAR)&displacement, length, TRUE);
        *(*ppBuf)++ = ' ';
        *(*ppBuf)++ = '(';
        OutputHexString(ppBuf, pValue, length);
        *(*ppBuf)++ = ')';
    }
    else
    {
        OutputHexString(ppBuf, pValue, length);
    }
}

/*** OutputExactSymbol - Output symbolic value only for exact symbol
*                        matches.
*
*************************************************************************/

BOOL
BaseX86MachineInfo::OutputExactSymbol (
    char **ppBuf,
    PUCHAR pValue,
    int length,
    int segOvr
    )
{
    CHAR   chSymbol[MAX_SYMBOL_LEN];
    ULONG64 displacement;
    ULONG64 value;

    value = 0;
    memcpy(&value, pValue, length);
    if (length == 4)
    {
        value = EXTEND64(value);
    }

    GetSymbol(value, chSymbol, sizeof(chSymbol), &displacement);
    if (chSymbol[0] && displacement == 0)
    {
        X86OutputString(ppBuf, chSymbol);
        OutputHexValue(ppBuf, (PUCHAR)&displacement, length, TRUE);
        *(*ppBuf)++ = ' ';
        *(*ppBuf)++ = '(';
        OutputHexString(ppBuf, pValue, length);
        *(*ppBuf)++ = ')';
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
OutputHexAddr(PSTR *ppBuffer, PADDR paddr)
{
    sprintAddr(ppBuffer, paddr);
    // Remove trailing space.
    (*ppBuffer)--;
    **ppBuffer = 0;
}

ULONG
BaseX86MachineInfo::GetSegReg(int SegOpcode)
{
    switch(SegOpcode)
    {
    case 0x26:
        return SEGREG_ES;
    case X86_CS_OVR:
        return SEGREG_CODE;
    case 0x36:
        return SEGREG_STACK;
    case 0x64:
        return SEGREG_FS;
    case 0x65:
        return SEGREG_GS;
    case 0x3e:
    default:
        return SEGREG_DATA;
    }
}

int
BaseX86MachineInfo::ComputeJccEa(int Opcode, BOOL EaOut)
{
    if (!EaOut)
    {
        return JCC_EA_NONE;
    }

    ULONG Flags;
    int Branch;

    if ((Opcode >= 0x70 && Opcode <= 0x7f) ||
        (Opcode >= 0x180 && Opcode <= 0x18f))
    {
        int Table = (Opcode >> 1) & 7;

        Flags = GetReg32(X86_NFL);
        Branch = Opcode & 1;
        if ((Flags & g_JccCheckTable[Table][0]) != 0 ||
            ((Flags >> g_JccCheckTable[Table][1]) & 1) !=
            ((Flags >> g_JccCheckTable[Table][2]) & 1))
        {
            Branch ^= 1;
        }

        return JCC_EA_NO_BRANCH + Branch;
    }
    else
    {
        ULONG64 Cx = GetReg64(X86_NCX);
        switch(g_OpSize)
        {
        case 16:
            Cx &= 0xffff;
            break;
        case 32:
            Cx &= 0xffffffff;
            break;
        }

        switch(Opcode)
        {
        case 0xe0: // LOOPNE.
            Flags = GetReg32(X86_NFL);
            Branch = (Flags & X86_BIT_FLAGZF) == 0 && Cx != 1 ?
                JCC_EA_BRANCH : JCC_EA_NO_BRANCH;
            break;
        case 0xe1: // LOOPE.
            Flags = GetReg32(X86_NFL);
            Branch = (Flags & X86_BIT_FLAGZF) != 0 && Cx != 1 ?
                JCC_EA_BRANCH : JCC_EA_NO_BRANCH;
            break;
        case 0xe2: // LOOP.
            Branch = Cx == 1 ? JCC_EA_NO_BRANCH : JCC_EA_BRANCH;
            break;
        case 0xe3: // J*CXZ.
            Branch = Cx == 0 ? JCC_EA_BRANCH : JCC_EA_NO_BRANCH;
            break;
        default:
            DBG_ASSERT(FALSE);
            Branch = JCC_EA_NONE;
            break;
        }

        return Branch;
    }
}

BOOL
BaseX86MachineInfo::IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr)
{
    UCHAR Instr[X86_INT3_LEN];

    if (fnotFlat(*Addr) ||
        m_Target->ReadAllVirtual(Process, Flat(*Addr),
                                 Instr, X86_INT3_LEN) != S_OK)
    {
        return FALSE;
    }

    return !memcmp(Instr, g_X86Int3, X86_INT3_LEN);
}

HRESULT
BaseX86MachineInfo::InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                ULONG Flags,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen)
{
    if (Flags != IBI_DEFAULT)
    {
        return E_INVALIDARG;
    }

    if ((m_Target->m_MachineType != IMAGE_FILE_MACHINE_I386) &&
        (g_Wow64exts != NULL))
    {
        ProcessInfo* ProcInfo = m_Target->FindProcessByHandle(Process);
        if (ProcInfo != NULL)
        {
            (*g_Wow64exts)(WOW64EXTS_FLUSH_CACHE_WITH_HANDLE,
                           ProcInfo->m_SysHandle, Offset, X86_INT3_LEN);
        }
    }

    *ChangeStart = Offset;
    *ChangeLen = X86_INT3_LEN;

    ULONG Done;
    HRESULT Status;

    Status = Services->ReadVirtual(Process, Offset, SaveInstr,
                                   X86_INT3_LEN, &Done);
    if (Status == S_OK && Done != X86_INT3_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    if (Status == S_OK)
    {
        Status = Services->WriteVirtual(Process, Offset, g_X86Int3,
                                        X86_INT3_LEN, &Done);
        if (Status == S_OK && Done != X86_INT3_LEN)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
        }
    }

    return Status;
}

HRESULT
BaseX86MachineInfo::RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                                ULONG64 Process,
                                                ULONG64 Offset,
                                                PUCHAR SaveInstr,
                                                PULONG64 ChangeStart,
                                                PULONG ChangeLen)
{
    if ((m_Target->m_MachineType != IMAGE_FILE_MACHINE_I386) &&
        (g_Wow64exts != NULL))
    {
        ProcessInfo* ProcInfo = m_Target->FindProcessByHandle(Process);
        if (ProcInfo != NULL)
        {
            (*g_Wow64exts)(WOW64EXTS_FLUSH_CACHE_WITH_HANDLE,
                           ProcInfo->m_SysHandle, Offset, X86_INT3_LEN);
        }
    }

    *ChangeStart = Offset;
    *ChangeLen = X86_INT3_LEN;

    ULONG Done;
    HRESULT Status;

    Status = Services->WriteVirtual(Process, Offset, SaveInstr,
                                    X86_INT3_LEN, &Done);
    if (Status == S_OK && Done != X86_INT3_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

void
BaseX86MachineInfo::AdjustPCPastBreakpointInstruction(PADDR Addr,
                                                      ULONG BreakType)
{
    if (BreakType == DEBUG_BREAKPOINT_CODE)
    {
        AddrAdd(Addr, X86_INT3_LEN);
        SetPC(Addr);
    }
}

BOOL
BaseX86MachineInfo::IsCallDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " call") != NULL;
}

BOOL
BaseX86MachineInfo::IsReturnDisasm(PCSTR Disasm)
{
    return strstr(Disasm, " ret") != NULL ||
        (IS_KERNEL_TARGET(m_Target) && strstr(Disasm, " iretd") != NULL);
}

BOOL
BaseX86MachineInfo::IsSystemCallDisasm(PCSTR Disasm)
{
    return (strstr(Disasm, " int ") != NULL &&
            strstr(Disasm, " 2e") != NULL) ||
        strstr(Disasm, " sysenter") != NULL ||
        strstr(Disasm, " syscall") != NULL;
}

BOOL
BaseX86MachineInfo::IsDelayInstruction(PADDR Addr)
{
    // X86 does not have delay slots.
    return FALSE;
}

void
BaseX86MachineInfo::GetEffectiveAddr(PADDR Addr, PULONG Size)
{
    *Addr = EAaddr[0];
    *Size = EAsize[0];
}

void
BaseX86MachineInfo::IncrementBySmallestInstruction(PADDR Addr)
{
    AddrAdd(Addr, 1);
}

void
BaseX86MachineInfo::DecrementBySmallestInstruction(PADDR Addr)
{
    AddrSub(Addr, 1);
}

//----------------------------------------------------------------------------
//
// X86MachineInfo methods.
//
//----------------------------------------------------------------------------

HRESULT
X86MachineInfo::NewBreakpoint(DebugClient* Client,
                              ULONG Type,
                              ULONG Id,
                              Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_I386);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new X86DataBreakpoint(Client, Id, X86_CR4, X86_DR6,
                                       IMAGE_FILE_MACHINE_I386);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

void
X86MachineInfo::InsertThreadDataBreakpoints(void)
{
    ULONG Dr7Value;

    BpOut("Thread %d data breaks %d\n",
          g_Thread->m_UserId, g_Thread->m_NumDataBreaks);

    // Start with all breaks turned off.
    Dr7Value = GetIntReg(X86_DR7) & ~X86_DR7_CTRL_03_MASK;

    if (g_Thread->m_NumDataBreaks > 0)
    {
        ULONG i;

        for (i = 0; i < g_Thread->m_NumDataBreaks; i++)
        {
            X86DataBreakpoint* Bp =
                (X86DataBreakpoint *)g_Thread->m_DataBreakBps[i];

            ULONG64 Addr = Flat(*Bp->GetAddr());
            BpOut("  dbp %d at %p\n", i, Addr);
            if (g_DataBreakpointsChanged)
            {
                SetReg32(X86_DR0 + i, (ULONG)Addr);
            }
            // There are two enable bits per breakpoint
            // and four len/rw bits so split up enables
            // and len/rw when shifting into place.
            Dr7Value |=
                ((Bp->m_Dr7Bits & 0xffff0000) << (i * 4)) |
                ((Bp->m_Dr7Bits & X86_DR7_ALL_ENABLES) << (i * 2));
        }

        // The kernel automatically clears DR6 when it
        // processes a DBGKD_CONTROL_SET.
        if (IS_USER_TARGET(m_Target))
        {
            SetReg32(X86_DR6, 0);
        }

        // Set local exact match, which is effectively global on NT.
        Dr7Value |= X86_DR7_LOCAL_EXACT_ENABLE;
            }

    BpOut("  thread %d DR7 %X\n", g_Thread->m_UserId, Dr7Value);
    SetReg32(X86_DR7, Dr7Value);
}

void
X86MachineInfo::RemoveThreadDataBreakpoints(void)
{
    SetReg32(X86_DR7, 0);
}

ULONG
X86MachineInfo::IsBreakpointOrStepException(PEXCEPTION_RECORD64 Record,
                                            ULONG FirstChance,
                                            PADDR BpAddr,
                                            PADDR RelAddr)
{
    if (Record->ExceptionCode == STATUS_BREAKPOINT ||
        Record->ExceptionCode == STATUS_WX86_BREAKPOINT)
    {
        // Data breakpoints hit as STATUS_SINGLE_STEP so
        // this can only be a code breakpoint.
        if (IS_USER_TARGET(m_Target) && FirstChance)
        {
            // Back up to the actual breakpoint instruction.
            AddrSub(BpAddr, X86_INT3_LEN);
            SetPC(BpAddr);
        }
        return EXBS_BREAKPOINT_CODE;
    }
    else if (Record->ExceptionCode == STATUS_SINGLE_STEP ||
             Record->ExceptionCode == STATUS_WX86_SINGLE_STEP)
    {
        // XXX t-tcheng - Conversion for Dr6, Dr7 not implemented yet...

        ULONG Dr6 = GetIntReg(X86_DR6);
        ULONG Dr7 = GetIntReg(X86_DR7);

        BpOut("X86 step: DR6 %X, DR7 %X\n", Dr6, Dr7);

        // The single step bit should always be clear if a data breakpoint
        // is hit but also check the DR7 enables just in case.
        // We've also seen cases where DR6 shows no hits, so consider
        // that a single step also.
        if ((Dr6 & X86_DR6_SINGLE_STEP) || (Dr7 & X86_DR7_ALL_ENABLES) == 0 ||
            (Dr6 & X86_DR6_BREAK_03) == 0)
        {
            // There's no way to tell if this particular
            // step was a branch step or not so only
            // try to look up the branch source if we're
            // in branch-trace mode.
            if (m_SupportsBranchTrace &&
                g_CmdState == 'b')
            {
                HRESULT Status;
                ULONG64 LastIp;

                // The Pentium IV handles last-branch tracking
                // differently from the P6.
                if (m_Target->m_FirstProcessorId.X86.Family >= 15)
                {
                    ULONG64 LbrTos;

                    Status = m_Target->ReadMsr(X86_MSR_LAST_BRANCH_TOS,
                                               &LbrTos);
                    if (Status == S_OK)
                    {
                        Status = m_Target->ReadMsr(X86_MSR_LAST_BRANCH_0 +
                                                   (ULONG)LbrTos,
                                                   &LastIp);
                        // The result is a 64-bit value with the
                        // from address in the upper 32-bits.
                        LastIp >>= 32;
                    }
                }
                else
                {
                    Status = m_Target->ReadMsr(X86_MSR_LAST_BRANCH_FROM_IP,
                                               &LastIp);
                }

                if (Status == S_OK)
                {
                    // The branch may have come from a different
                    // segment.  We could try and determine what
                    // code segment it was by reading the stack to
                    // get the saved CS value but it's not worth
                    // it right now.
                    FormAddr(SEGREG_CODE, EXTEND64(LastIp),
                             FORM_CODE | FORM_SEGREG |
                             X86_FORM_VM86(GetIntReg(X86_EFL)),
                             RelAddr);
                }
            }

            // This is a true single step exception, not
            // a data breakpoint.
            return EXBS_STEP_INSTRUCTION;
        }
        else
        {
            // Some data breakpoint must be hit.
            // There doesn't appear to be any way to get the
            // faulting instruction address so just leave the PC.
            return EXBS_BREAKPOINT_DATA;
        }
    }

    return EXBS_NONE;
}

void
X86MachineInfo::PrintStackFrameAddressesTitle(ULONG Flags)
{
    PrintMultiPtrTitle("ChildEBP", 1);
    PrintMultiPtrTitle("RetAddr", 1);
}

void
X86MachineInfo::PrintStackFrameAddresses(ULONG Flags,
                                         PDEBUG_STACK_FRAME StackFrame)
{
    dprintf("%s %s ",
        FormatAddr64(StackFrame->FrameOffset),
        FormatAddr64(StackFrame->ReturnOffset));
}

void
X86MachineInfo::PrintStackArgumentsTitle(ULONG Flags)
{
    PrintMultiPtrTitle("Args to Child", 3);
}

void
X86MachineInfo::PrintStackArguments(ULONG Flags,
                                    PDEBUG_STACK_FRAME StackFrame)
{
    dprintf("%s %s %s ",
            FormatAddr64(StackFrame->Params[0]),
            FormatAddr64(StackFrame->Params[1]),
            FormatAddr64(StackFrame->Params[2]));
}

void
X86MachineInfo::PrintStackCallSiteTitle(ULONG Flags)
{
}

void
X86MachineInfo::PrintStackCallSite(ULONG Flags,
                                   PDEBUG_STACK_FRAME StackFrame,
                                   PSYMBOL_INFO SiteSymbol,
                                   PSTR SymName,
                                   DWORD64 Displacement)
{
    // Truncate the displacement to 32 bits since it can never be
    // greater than 32 bit for X86, and we don't want addresses with no
    // symbols to show up with the leading 0xfffffff

    MachineInfo::PrintStackCallSite(Flags, StackFrame, SiteSymbol, SymName,
                                    (DWORD64)(DWORD)Displacement);

    if (!(Flags & DEBUG_STACK_FUNCTION_INFO))
    {
        return;
    }

    if (StackFrame->FuncTableEntry)
    {
        PFPO_DATA FpoData = (PFPO_DATA)StackFrame->FuncTableEntry;
        switch(FpoData->cbFrame)
        {
        case FRAME_FPO:
            if (FpoData->fHasSEH)
            {
                dprintf(" (FPO: [SEH])");
            }
            else
            {
                dprintf(" (FPO:");
                if (FpoData->fUseBP)
                {
                    dprintf(" [EBP 0x%s]",
                            FormatAddr64(SAVE_EBP(StackFrame)));
                }
                dprintf(" [%d,%d,%d])",
                        FpoData->cdwParams,
                        FpoData->cdwLocals,
                        FpoData->cbRegs);
            }
            break;

        case FRAME_NONFPO:
            dprintf(" (FPO: [Non-Fpo])" );
            break;

        case FRAME_TRAP:
            if (!IS_KERNEL_TARGET(m_Target))
            {
                goto UnknownFpo;
            }

            dprintf(" (FPO: [%d,%d] TrapFrame%s @ %s)",
                    FpoData->cdwParams,
                    FpoData->cdwLocals,
                    TRAP_EDITED(StackFrame) ? "" : "-EDITED",
                    FormatAddr64(SAVE_TRAP(StackFrame)));
            break;

        case FRAME_TSS:
            if (!IS_KERNEL_TARGET(m_Target))
            {
                goto UnknownFpo;
            }

            dprintf(" (FPO: TaskGate %lx:0)",
                    (ULONG)TRAP_TSS(StackFrame));
            break;

        default:
        UnknownFpo:
            dprintf(" (UNKNOWN FPO TYPE)");
            break;
        }
    }

    if (SiteSymbol->Tag == SymTagFunction)
    {
        ULONG CallConv;

        // Look up the type symbol for the function.
        if (SymGetTypeInfo(g_Process->m_SymHandle,
                           SiteSymbol->ModBase,
                           SiteSymbol->TypeIndex,
                           TI_GET_CALLING_CONVENTION,
                           &CallConv) &&
            CallConv < CV_CALL_RESERVED)
        {
            dprintf(" (CONV: %s)", g_CallConv[CallConv]);
        }
    }
}

void
X86MachineInfo::PrintStackFrameMemoryUsage(PDEBUG_STACK_FRAME CurFrame,
                                           PDEBUG_STACK_FRAME PrevFrame)
{
    if (CurFrame->FrameOffset >= PrevFrame->FrameOffset)
    {
        dprintf(" %6x ",
                (ULONG)(CurFrame->FrameOffset - PrevFrame->FrameOffset));
    }
    else
    {
        dprintf("        ");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_asmexp.cpp ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1991-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "i386_asm.h"

UCHAR   PeekAsmChar(void);
ULONG   PeekAsmToken(PULONG);
void    AcceptAsmToken(void);
ULONG   GetAsmToken(PULONG);
ULONG   NextAsmToken(PULONG);
ULONG   GetAsmReg(PUCHAR, PULONG);

void    GetAsmOperand(PASM_VALUE);
void    GetAsmExpr(PASM_VALUE, UCHAR);
void    GetAsmOrTerm(PASM_VALUE, UCHAR);
void    GetAsmAndTerm(PASM_VALUE, UCHAR);
void    GetAsmNotTerm(PASM_VALUE, UCHAR);
void    GetAsmRelTerm(PASM_VALUE, UCHAR);
void    GetAsmAddTerm(PASM_VALUE, UCHAR);
void    GetAsmMulTerm(PASM_VALUE, UCHAR);
void    GetAsmSignTerm(PASM_VALUE, UCHAR);
void    GetAsmByteTerm(PASM_VALUE, UCHAR);
void    GetAsmOffTerm(PASM_VALUE, UCHAR);
void    GetAsmColnTerm(PASM_VALUE, UCHAR);
void    GetAsmDotTerm(PASM_VALUE, UCHAR);
void    GetAsmIndxTerm(PASM_VALUE, UCHAR);
void    AddAsmValues(PASM_VALUE, PASM_VALUE);
void    SwapPavs(PASM_VALUE, PASM_VALUE);

extern  PUCHAR pchAsmLine;

struct _AsmRes {
    PCHAR    pchRes;
    ULONG    valueRes;
    } AsmReserved[] = {
        { "mod",    ASM_MULOP_MOD },
        { "shl",    ASM_MULOP_SHL },
        { "shr",    ASM_MULOP_SHR },
        { "and",    ASM_ANDOP_CLASS },
        { "not",    ASM_NOTOP_CLASS },
        { "or",     ASM_OROP_OR },
        { "xor",    ASM_OROP_XOR },
        { "eq",     ASM_RELOP_EQ },
        { "ne",     ASM_RELOP_NE },
        { "le",     ASM_RELOP_LE },
        { "lt",     ASM_RELOP_LT },
        { "ge",     ASM_RELOP_GE },
        { "gt",     ASM_RELOP_GT },
        { "by",     ASM_UNOP_BY },
        { "wo",     ASM_UNOP_WO },
        { "dw",     ASM_UNOP_DW },
        { "poi",    ASM_UNOP_POI },
        { "low",    ASM_LOWOP_LOW },
        { "high",   ASM_LOWOP_HIGH },
        { "offset", ASM_OFFOP_CLASS },
        { "ptr",    ASM_PTROP_CLASS },
        { "byte",   ASM_SIZE_BYTE },
        { "word",   ASM_SIZE_WORD },
        { "dword",  ASM_SIZE_DWORD },
        { "fword",  ASM_SIZE_FWORD },
        { "qword",  ASM_SIZE_QWORD },
        { "tbyte",  ASM_SIZE_TBYTE }
        };

#define RESERVESIZE (sizeof(AsmReserved) / sizeof(struct _AsmRes))

UCHAR regSize[] = {
        sizeB,          //  byte
        sizeW,          //  word
        sizeD,          //  dword
        sizeW,          //  segment
        sizeD,          //  control
        sizeD,          //  debug
        sizeD,          //  trace
        sizeT,          //  float
        sizeT           //  float with index
        };

UCHAR regType[] = {
        regG,           //  byte - general
        regG,           //  word - general
        regG,           //  dword - general
        regS,           //  segment
        regC,           //  control
        regD,           //  debug
        regT,           //  trace
        regF,           //  float (st)
        regI            //  float-index (st(n))
        };

UCHAR tabWordReg[8] = {         //  rm value
        (UCHAR)-1,              //  AX - error
        (UCHAR)-1,              //  CX - error
        (UCHAR)-1,              //  DX - error
        7,                      //  BX - 111
        (UCHAR)-1,              //  SP - error
        6,                      //  BP - 110
        4,                      //  SI - 100
        5,                      //  DI - 101
        };

UCHAR rm16Table[16] = {         //  new rm         left rm      right rm
        (UCHAR)-1,              //  error          100 = [SI]   100 = [SI]
        (UCHAR)-1,              //  error          100 = [SI]   101 = [DI]
        2,                      //  010 = [BP+SI]  100 = [SI]   110 = [BP]
        0,                      //  000 = [BX+SI]  100 = [SI]   111 = [BX]
        (UCHAR)-1,              //  error          101 = [DI]   100 = [SI]
        (UCHAR)-1,              //  error          101 = [DI]   101 = [DI]
        3,                      //  011 = [BP+DI]  101 = [DI]   110 = [BP]
        1,                      //  001 = [BX+DI]  101 = [DI]   111 = [BX]
        2,                      //  010 = [BP+SI]  110 = [BP]   100 = [SI]
        3,                      //  011 = [BP+DI]  110 = [BP]   101 = [DI]
        (UCHAR)-1,              //  error          110 = [BP]   110 = [BP]
        (UCHAR)-1,              //  error          110 = [BP]   111 = [BX]
        0,                      //  000 = [BX+SI]  111 = [BX]   100 = [SI]
        1,                      //  001 = [BX+DI]  111 = [BX]   101 = [DI]
        (UCHAR)-1,              //  error          111 = [BX]   110 = [BP]
        (UCHAR)-1               //  error          111 = [BX]   111 = [BX]
        };

PUCHAR  savedpchAsmLine;
ULONG   savedAsmClass;
ULONG   savedAsmValue;

/*** PeekAsmChar - peek the next non-white-space character
*
*   Purpose:
*       Return the next non-white-space character and update
*       pchAsmLine to point to it.
*
*   Input:
*       pchAsmLine - present command line position.
*
*   Returns:
*       next non-white-space character
*
*************************************************************************/

UCHAR PeekAsmChar (void)
{
    UCHAR    ch;

    do
        ch = *pchAsmLine++;
    while (ch == ' ' || ch == '\t');
    pchAsmLine--;

    return ch;
}

/*** PeekAsmToken - peek the next command line token
*
*   Purpose:
*       Return the next command line token, but do not advance
*       the pchAsmLine pointer.
*
*   Input:
*       pchAsmLine - present command line position.
*
*   Output:
*       *pvalue - optional value of token
*   Returns:
*       class of token
*
*   Notes:
*       savedAsmClass, savedAsmValue, and savedpchAsmLine saves the
*           token getting state for future peeks.
*       To get the next token, a GetAsmToken or AcceptAsmToken call
*           must first be made.
*
*************************************************************************/

ULONG PeekAsmToken (PULONG pvalue)
{
    UCHAR   *pchTemp;

    //  Get next class and value, but do not
    //  move pchAsmLine, but save it in savedpchAsmLine.
    //  Do not report any error condition.

    if (savedAsmClass == (ULONG)-1) {
        pchTemp = pchAsmLine;
        savedAsmClass = NextAsmToken(&savedAsmValue);
        savedpchAsmLine = pchAsmLine;
        pchAsmLine = pchTemp;
        }
    *pvalue = savedAsmValue;
    return savedAsmClass;
}

/*** AcceptAsmToken - accept any peeked token
*
*   Purpose:
*       To reset the PeekAsmToken saved variables so the next PeekAsmToken
*       will get the next token in the command line.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void AcceptAsmToken (void)
{
    savedAsmClass = (ULONG)-1;
    pchAsmLine = savedpchAsmLine;
}

/*** GetAsmToken - peek and accept the next token
*
*   Purpose:
*       Combines the functionality of PeekAsmToken and AcceptAsmToken
*       to return the class and optional value of the next token
*       as well as updating the command pointer pchAsmLine.
*
*   Input:
*       pchAsmLine - present command string pointer
*
*   Output:
*       *pvalue - pointer to the token value optionally set.
*   Returns:
*       class of the token read.
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG GetAsmToken (PULONG pvalue)
{
    ULONG   opclass;

    if (savedAsmClass != (ULONG)-1) {
        opclass = savedAsmClass;
        savedAsmClass = (ULONG)-1;
        *pvalue = savedAsmValue;
        pchAsmLine = savedpchAsmLine;
        }
    else
        opclass = NextAsmToken(pvalue);

    if (opclass == ASM_ERROR_CLASS)
        error(*pvalue);

    return opclass;
}

/*** NextAsmToken - process the next token
*
*   Purpose:
*       Parse the next token from the present command string.
*       After skipping any leading white space, first check for
*       any single character tokens or register variables.  If
*       no match, then parse for a number or variable.  If a
*       possible variable, check the reserved word list for operators.
*
*   Input:
*       pchAsmLine - pointer to present command string
*
*   Output:
*       *pvalue - optional value of token returned
*       pchAsmLine - updated to point past processed token
*   Returns:
*       class of token returned
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG NextAsmToken (PULONG pvalue)
{
    ULONG    base;
    UCHAR    chSymbol[MAX_SYMBOL_LEN];
    UCHAR    chPreSym[9];
    ULONG    cbSymbol = 0;
    UCHAR    fNumber = TRUE;
    UCHAR    fNumberSigned;
    UCHAR    fSymbol = TRUE;
    UCHAR    fForceReg = FALSE;
    ULONG    errNumber = 0;
    UCHAR    ch;
    UCHAR    chlow;
    UCHAR    chtemp;
    UCHAR    limit1 = '9';
    UCHAR    limit2 = '9';
    UCHAR    fDigit = FALSE;
    ULONG    value = 0;
    ULONG    tmpvalue;
    ULONG    index;
    ImageInfo* pImage;
    ULONG64  value64;

    base = g_DefaultRadix;
    fNumberSigned = base == 10;

    //  skip leading white space

    ch = PeekAsmChar();
    chlow = (UCHAR)tolower(ch);
    pchAsmLine++;

    //  test for special character operators and register variable

    switch (chlow) {
        case '\0':
            pchAsmLine--;
            return ASM_EOL_CLASS;
        case ',':
            return ASM_COMMA_CLASS;
        case '+':
            *pvalue = ASM_ADDOP_PLUS;
            return ASM_ADDOP_CLASS;
        case '-':
            *pvalue = ASM_ADDOP_MINUS;
            return ASM_ADDOP_CLASS;
        case '*':
            *pvalue = ASM_MULOP_MULT;
            return ASM_MULOP_CLASS;
        case '/':
            *pvalue = ASM_MULOP_DIVIDE;
            return ASM_MULOP_CLASS;
        case ':':
            return ASM_COLNOP_CLASS;
        case '(':
            return ASM_LPAREN_CLASS;
        case ')':
            return ASM_RPAREN_CLASS;
        case '[':
            return ASM_LBRACK_CLASS;
        case ']':
            return ASM_RBRACK_CLASS;
        case '@':
            fForceReg = TRUE;
            chlow = (UCHAR)tolower(*pchAsmLine); pchAsmLine++;
            break;
        case '.':
            return ASM_DOTOP_CLASS;
        case '\'':
            for (index = 0; index < 5; index++) {
                ch = *pchAsmLine++;
                if (ch == '\'' || ch == '\0')
                    break;
                value = (value << 8) + (ULONG)ch;
                }
            if (ch == '\0' || index == 0 || index == 5) {
                pchAsmLine--;
                *pvalue = SYNTAX;
                return ASM_ERROR_CLASS;
                }
            pchAsmLine++;
            *pvalue = value;
            return ASM_NUMBER_CLASS;
        }

    //  if first character is a decimal digit, it cannot
    //  be a symbol.  leading '0' implies octal, except
    //  a leading '0x' implies hexadecimal.

    if (chlow >= '0' && chlow <= '9') {
        if (fForceReg) {
            *pvalue = SYNTAX;
            return ASM_ERROR_CLASS;
            }
        fSymbol = FALSE;
        if (chlow == '0') {
            ch = *pchAsmLine++;
            chlow = (UCHAR)tolower(ch);
            if (chlow == 'x') {
                base = 16;
                ch = *pchAsmLine++;
                chlow = (UCHAR)tolower(ch);
                fNumberSigned = FALSE;
                }
            else if (chlow == 'n') {
                base = 10;
                ch = *pchAsmLine++;
                chlow = (UCHAR)tolower(ch);
                fNumberSigned = TRUE;
                }
            else {
                base = 8;
                fDigit = TRUE;
                fNumberSigned = FALSE;
                }
            }
        }

    //  a number can start with a letter only if base is
    //  hexadecimal and it is a hexadecimal digit 'a'-'f'.

    else if ((chlow < 'a' && chlow > 'f') || base != 16)
        fNumber = FALSE;

    //  set limit characters for the appropriate base.

    if (base == 8)
        limit1 = '7';
    if (base == 16)
        limit2 = 'f';

    //  perform processing while character is a letter,
    //  digit, or underscore.

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') || (chlow == '_')) {

        //  if possible number, test if within proper range,
        //  and if so, accumulate sum.

        if (fNumber) {
            if ((chlow >= '0' && chlow <= limit1) ||
                    (chlow >= 'a' && chlow <= limit2)) {
                fDigit = TRUE;
                tmpvalue = value * base;
                if (tmpvalue < value)
                    errNumber = OVERFLOW;
                chtemp = (UCHAR)(chlow - '0');
                if (chtemp > 9)
                    chtemp -= 'a' - '0' - 10;
                value = tmpvalue + (ULONG)chtemp;
                if (value < tmpvalue)
                    errNumber = OVERFLOW;
                }
            else {
                fNumber = FALSE;
                errNumber = SYNTAX;
                }
            }
        if (fSymbol) {
            if (cbSymbol < 9)
                chPreSym[cbSymbol] = chlow;
            if (cbSymbol < MAX_SYMBOL_LEN - 1)
                chSymbol[cbSymbol++] = ch;
            }
        ch = *pchAsmLine++;
        chlow = (UCHAR)tolower(ch);
        }

    //  back up pointer to first character after token.

    pchAsmLine--;

    if (cbSymbol < 9)
        chPreSym[cbSymbol] = '\0';

    //  if fForceReg, check for register name and return
    //      success or failure

    if (fForceReg)
        if ((index = GetAsmReg(chPreSym, pvalue)) != 0) {
            if (index == ASM_REG_SEGMENT)
                if (PeekAsmChar() == ':') {
                    pchAsmLine++;
                    index = ASM_SEGOVR_CLASS;
                    }
            return index;               //  class type returned by GetAsmReg
            }
        else {
            *pvalue = BADREG;
            return ASM_ERROR_CLASS;
            }

    //  next test for reserved word and symbol string

    if (fSymbol) {

        //  if possible symbol, check lowercase string in chPreSym
        //  for text operator or register name.
        //  otherwise, return symbol value from name in chSymbol.

        for (index = 0; index < RESERVESIZE; index++)
            if (!strcmp((PSTR)chPreSym, AsmReserved[index].pchRes)) {
                *pvalue = AsmReserved[index].valueRes;
                return AsmReserved[index].valueRes & ASM_CLASS_MASK;
                }

        //  start processing string as symbol

        chSymbol[cbSymbol] = '\0';

        //  test if symbol is a module name (with '!' after it)
        //  if so, get next token and treat as symbol

        pImage = g_Process->FindImageByName((PSTR)chSymbol, cbSymbol,
                                            INAME_MODULE, FALSE);
        if (pImage && (ch = PeekAsmChar()) == '!')
        {
            pchAsmLine++;
            ch = PeekAsmChar();
            pchAsmLine++;
            cbSymbol = 0;
            while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') ||
                   (ch >= '0' && ch <= '9') || (ch == '_'))
            {
                chSymbol[cbSymbol++] = ch;
                ch = *pchAsmLine++;
            }
            chSymbol[cbSymbol] = '\0';
            pchAsmLine--;
        }

        if (GetOffsetFromSym(g_Process, (PSTR)chSymbol, &value64, NULL))
        {
            *pvalue = (ULONG)value64;
            return ASM_SYMBOL_CLASS;
        }

        //  symbol is undefined.
        //  if a possible hex number, do not set the error type

        if (!fNumber)
            errNumber = VARDEF;
        }

    //  if possible number and no error, return the number

    if (fNumber && !errNumber) {
        if (fDigit) {

            //  check for possible segment specification
            //          "<16-bit number>:"

            if (PeekAsmChar() == ':') {
                pchAsmLine++;
                if (value > 0xffff)
                    error(BADSEG);
                *pvalue = value;
                return ASM_SEGMENT_CLASS;
                }

            *pvalue = value;
            return fNumberSigned ? ASM_SIGNED_NUMBER_CLASS : ASM_NUMBER_CLASS;
            }
        else
            errNumber = SYNTAX;
        }

    //  last chance, undefined symbol and illegal number,
    //      so test for register, will handle old format

    if ((index = GetAsmReg(chPreSym, pvalue)) != 0) {
        if (index == ASM_REG_SEGMENT)
            if (PeekAsmChar() == ':') {
                pchAsmLine++;
                index = ASM_SEGOVR_CLASS;
                }
        return index;           //  class type returned by GetAsmReg
        }

    *pvalue = (ULONG) errNumber;
    return ASM_ERROR_CLASS;
}

ULONG GetAsmReg (PUCHAR pSymbol, PULONG pValue)
{
    static UCHAR vRegList[] = "axcxdxbxspbpsidi";
    static UCHAR bRegList[] = "alcldlblahchdhbh";
    static UCHAR sRegList[] = "ecsdfg";         //  second char is 's'
                                                //  same order as seg enum

    ULONG       index;
    UCHAR       ch0 = *pSymbol;
    UCHAR       ch1 = *(pSymbol + 1);
    UCHAR       ch2 = *(pSymbol + 2);
    UCHAR       ch3 = *(pSymbol + 3);

    //  only test strings with two or three characters

    if (ch0 && ch1) {
        if (ch2 == '\0') {

            //  symbol has two characters, first test for 16-bit register

            for (index = 0; index < 8; index++)
                if (*(PUSHORT)pSymbol == *((PUSHORT)vRegList + index)) {
                    *pValue = index;
                    return ASM_REG_WORD;
                    }

            //  next test for 8-bit register

            for (index = 0; index < 8; index++)
                if (*(PUSHORT)pSymbol == *((PUSHORT)bRegList + index)) {
                    *pValue = index;
                    return ASM_REG_BYTE;
                    }

            //  test for segment register

            if (ch1 == 's')
                for (index = 0; index < 6; index++)
                    if (ch0 == *(sRegList + index)) {
                        *pValue = index + 1;    //  list offset is 1
                        return ASM_REG_SEGMENT;
                        }

            //  finally test for floating register "st" or "st(n)"
            //  parse the arg here as '(', <octal value>, ')'
            //  return value for "st" is REG_FLOAT,
            //     for "st(n)" is REG_INDFLT with value 0-7

            if (ch0 == 's' && ch1 == 't') {
                if (PeekAsmChar() != '(')
                    return ASM_REG_FLOAT;
                else {
                    pchAsmLine++;
                    index = (ULONG)(PeekAsmChar() - '0');
                    if (index < 8) {
                        pchAsmLine++;
                        if (PeekAsmChar() == ')') {
                            pchAsmLine++;
                            *pValue = index;
                            return ASM_REG_INDFLT;
                            }
                        }
                    }
                }
            }

        else if (ch3 == '\0') {

            //  if three-letter symbol, test for leading 'e' and
            //  second and third character being in the 16-bit list

            if (ch0 == 'e') {
                for (index = 0; index < 8; index++)
                    if (*(UNALIGNED USHORT *)(pSymbol + 1) ==
                                        *((PUSHORT)vRegList + index)) {
                        *pValue = index;
                        return ASM_REG_DWORD;
                        }
                }

            //  test for control, debug, and test registers

            else if (ch1 == 'r') {
                ch2 -= '0';
                *pValue = ch2;

                //  legal control registers are CR0, CR2, CR3, CR4

                if (ch0 == 'c') {
                    if (ch2 >= 0 && ch2 <= 4)
                        return ASM_REG_CONTROL;
                    }

                //  legal debug registers are DR0 - DR3, DR6, DR7

                else if (ch0 == 'd') {
                    if (ch2 <= 3 || ch2 == 6 || ch2 == 7)
                        return ASM_REG_DEBUG;
                    }

                //  legal trace registers are TR3 - TR7

                else if (ch0 == 't') {
                    if (ch2 >= 3 && ch2 <= 7)
                        return ASM_REG_TRACE;
                    }
                }
            }
        }
    return 0;
}

//      Operand parser - recursive descent
//
//      Grammar productions:
//
//      <Operand>  ::= <register> | <Expr>
//      <Expr>     ::= <orTerm> [(XOR | OR) <orTerm>]*
//      <orTerm>   ::= <andTerm> [AND <andTerm>]*
//      <andTerm>  ::= [NOT]* <notTerm>
//      <notTerm>  ::= <relTerm> [(EQ | NE | GE | GT | LE | LT) <relTerm>]*
//      <relTerm>  ::= <addTerm> [(- | +) <addTerm>]*
//      <addTerm>  ::= <mulTerm> [(* | / | MOD | SHL | SHR) <mulTerm>]*
//      <mulTerm>  ::= [(- | +)]* <signTerm>
//      <signTerm> ::= [(HIGH | LOW)]* <byteTerm>
//      <byteTerm> ::= [(OFFSET | <type> PTR)]* <offTerm>
//      <offTerm>  ::= [<segovr>] <colnTerm>
//      <colnTerm> ::= <dotTerm> [.<dotTerm>]*
//      <dotTerm>  ::= <indxTerm> ['['<Expr>']']*
//      <indxTerm> ::= <index-reg> | <symbol> | <number> | '('<Expr>')'
//                                                       | '['<Expr>']'

//      <Operand>  ::= <register> | <Expr>

void GetAsmOperand (PASM_VALUE pavExpr)
{
    ULONG   tokenvalue;
    ULONG   classvalue;

    classvalue = PeekAsmToken(&tokenvalue);
    if ((classvalue & ASM_CLASS_MASK) == ASM_REG_CLASS) {
        AcceptAsmToken();
        classvalue &= ASM_TYPE_MASK;
        pavExpr->flags = fREG;
        pavExpr->base = (UCHAR)tokenvalue;      //  index within reg group
        pavExpr->index = regType[classvalue - 1];
        pavExpr->size = regSize[classvalue - 1];
        }
    else {
        GetAsmExpr(pavExpr, FALSE);
        if (pavExpr->reloc > 1)         //  only 0 and 1 are allowed
            error(OPERAND);
        }
}

//      <Expr> ::=  <orTerm> [(XOR | OR) <orTerm>]*

void GetAsmExpr (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmExpr\n");
    GetAsmOrTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_OROP_CLASS) {
        AcceptAsmToken();
        GetAsmOrTerm(&avTerm, fBracket);
        if (!(pavValue->flags & avTerm.flags & fIMM))
            error(OPERAND);
        if (tokenvalue == ASM_OROP_OR)
            pavValue->value |= avTerm.value;
        else
            pavValue->value ^= avTerm.value;
        }
dprintf("exit  GetAsmExpr with %lx\n", pavValue->value);
}

//      <orTerm> ::=  <andTerm> [AND <andTerm>]*

void GetAsmOrTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmOrTerm\n");
    GetAsmAndTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_ANDOP_CLASS) {
        AcceptAsmToken();
        GetAsmAndTerm(&avTerm, fBracket);
        if (!(pavValue->flags & avTerm.flags & fIMM))
            error(OPERAND);
        pavValue->value &= avTerm.value;
        }
dprintf("exit  GetAsmOrTerm with %lx\n", pavValue->value);
}

//      <andTerm> ::= [NOT]* <notTerm>

void GetAsmAndTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;

dprintf("enter GetAsmAndTerm\n");
    if (PeekAsmToken(&tokenvalue) == ASM_NOTOP_CLASS) {
        AcceptAsmToken();
        GetAsmAndTerm(pavValue, fBracket);
        if (!(pavValue->flags & fIMM))
            error(OPERAND);
        pavValue->value = ~pavValue->value;
        }
    else
        GetAsmNotTerm(pavValue, fBracket);
dprintf("exit  GetAsmAndTerm with %lx\n", pavValue->value);
}

//      <notTerm> ::= <relTerm> [(EQ | NE | GE | GT | LE | LT) <relTerm>]*

void GetAsmNotTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ULONG   fTest;
    ULONG   fAddress;
    ASM_VALUE avTerm;

dprintf("enter GetAsmNotTerm\n");
    GetAsmRelTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_RELOP_CLASS) {
        AcceptAsmToken();
        GetAsmRelTerm(&avTerm, fBracket);
        if (!(pavValue->flags & avTerm.flags & fIMM) ||
                pavValue->reloc > 1 || avTerm.reloc > 1)
            error(OPERAND);
        fAddress = pavValue->reloc | avTerm.reloc;
        switch (tokenvalue) {
            case ASM_RELOP_EQ:
                fTest = pavValue->value == avTerm.value;
                break;
            case ASM_RELOP_NE:
                fTest = pavValue->value != avTerm.value;
                break;
            case ASM_RELOP_GE:
                if (fAddress)
                    fTest = pavValue->value >= avTerm.value;
                else
                    fTest = (LONG)pavValue->value >= (LONG)avTerm.value;
                break;
            case ASM_RELOP_GT:
                if (fAddress)
                    fTest = pavValue->value > avTerm.value;
                else
                    fTest = (LONG)pavValue->value > (LONG)avTerm.value;
                break;
            case ASM_RELOP_LE:
                if (fAddress)
                    fTest = pavValue->value <= avTerm.value;
                else
                    fTest = (LONG)pavValue->value <= (LONG)avTerm.value;
                break;
            case ASM_RELOP_LT:
                if (fAddress)
                    fTest = pavValue->value < avTerm.value;
                else
                    fTest = (LONG)pavValue->value < (LONG)avTerm.value;
                break;
            default:
                printf("bad RELOP type\n");
            }
        pavValue->value = (ULONG)(-((LONG)fTest));       //  FALSE = 0; TRUE = -1
        pavValue->reloc = 0;
        pavValue->size = sizeB;         //  immediate value is byte
        }
dprintf("exit  GetAsmNotTerm with %lx\n", pavValue->value);
}

//      <relTerm> ::= <addTerm> [(- | +) <addTerm>]*

void GetAsmRelTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmRelTerm\n");
    GetAsmAddTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_ADDOP_CLASS) {
        AcceptAsmToken();
        GetAsmAddTerm(&avTerm, fBracket);
        if (tokenvalue == ASM_ADDOP_MINUS) {
            if (!(avTerm.flags & (fIMM | fPTR)))
                error(OPERAND);
            avTerm.value = (ULONG)(-((LONG)avTerm.value));
            avTerm.reloc = (UCHAR)(-avTerm.reloc);
            // Assume that negating an immediate means it's
            // fundamentally a signed immediate.
            if (avTerm.flags & fIMM)
                avTerm.flags |= fSIGNED;
            }
        AddAsmValues(pavValue, &avTerm);
        }
dprintf("exit  GetAsmRelTerm with %lx\n", pavValue->value);
}

//      <addTerm> ::= <mulTerm> [(* | / | MOD | SHL | SHR) <mulTerm>]*

void GetAsmAddTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmAddTerm\n");
    GetAsmMulTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_MULOP_CLASS) {
        AcceptAsmToken();
        GetAsmMulTerm(&avTerm, fBracket);

        if (tokenvalue == ASM_MULOP_MULT) {
            if (pavValue->flags & fIMM)
                SwapPavs(pavValue, &avTerm);
            if (!(avTerm.flags & fIMM))
                error(OPERAND);
            if (pavValue->flags & fIMM)
                pavValue->value *= avTerm.value;
            else if ((pavValue->flags & fPTR32)
                        && pavValue->value == 0
                        && pavValue->base != indSP
                        && pavValue->index == 0xff) {
                pavValue->index = pavValue->base;
                pavValue->base = 0xff;
                pavValue->scale = 0xff;
                if (avTerm.value == 1)
                    pavValue->scale = 0;
                if (avTerm.value == 2)
                    pavValue->scale = 1;
                if (avTerm.value == 4)
                    pavValue->scale = 2;
                if (avTerm.value == 8)
                    pavValue->scale = 3;
                if (pavValue->scale == 0xff)
                    error(OPERAND);
                }
            else
                error(OPERAND);
            }
        else if (!(pavValue->flags & avTerm.flags & fIMM))
            error(OPERAND);
        else if (tokenvalue == ASM_MULOP_DIVIDE
                         || tokenvalue == ASM_MULOP_MOD) {
            if (avTerm.value == 0)
                error(DIVIDE);
            if (tokenvalue == ASM_MULOP_DIVIDE)
                pavValue->value /= avTerm.value;
            else
                pavValue->value %= avTerm.value;
            }
        else if (tokenvalue == ASM_MULOP_SHL)
            pavValue->value <<= avTerm.value;
        else
            pavValue->value >>= avTerm.value;
        }
dprintf("exit  GetAsmAddTerm with %lx\n", pavValue->value);
}

//      <mulTerm> ::= [(- | +)]* <signTerm>

void GetAsmMulTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;

dprintf("enter GetAsmMulTerm\n");
    if (PeekAsmToken(&tokenvalue) == ASM_ADDOP_CLASS) { //  BY WO DW POI UNDN
        AcceptAsmToken();
        GetAsmMulTerm(pavValue, fBracket);
        if (tokenvalue == ASM_ADDOP_MINUS) {
            if (!(pavValue->flags & (fIMM | fPTR)))
                error(OPERAND);
            pavValue->value = (ULONG)(-((LONG)pavValue->value));
            pavValue->reloc = (UCHAR)(-pavValue->reloc);
            // Assume that negating an immediate means it's
            // fundamentally a signed immediate.
            if (pavValue->flags & fIMM)
                pavValue->flags |= fSIGNED;
            }
        }
    else
        GetAsmSignTerm(pavValue, fBracket);
dprintf("exit  GetAsmMulTerm with %lx\n", pavValue->value);
}

//      <signTerm> ::= [(HIGH | LOW)]* <byteTerm>

void GetAsmSignTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;

dprintf("enter GetAsmSignTerm\n");
    if (PeekAsmToken(&tokenvalue) == ASM_LOWOP_CLASS) {
        AcceptAsmToken();
        GetAsmSignTerm(pavValue, fBracket);
        if (!(pavValue->flags & (fIMM | fPTR)))
            error(OPERAND);
        if (tokenvalue == ASM_LOWOP_LOW)
            pavValue->value = pavValue->value & 0xff;
        else
            pavValue->value = (pavValue->value & ~0xff) >> 8;
        pavValue->flags = fIMM;         //  make an immediate value
        pavValue->reloc = 0;
        pavValue->segment = segX;
        pavValue->size = sizeB;         //  byte value
        }
    else
        GetAsmByteTerm(pavValue, fBracket);
dprintf("exit  GetAsmSignTerm with %lx\n", pavValue->value);
}

//      <byteTerm> ::= [(OFFSET | <size> PTR)]* <offTerm>

void GetAsmByteTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ULONG   classvalue;

dprintf("enter GetAsmByteTerm\n");
    classvalue = PeekAsmToken(&tokenvalue);
    if (classvalue == ASM_OFFOP_CLASS) {
        AcceptAsmToken();
        GetAsmByteTerm(pavValue, fBracket);
        if (!(pavValue->flags & (fIMM | fPTR)) || pavValue->reloc > 1)
            error(OPERAND);
        pavValue->flags = fIMM;         //  make offset an immediate value
        pavValue->reloc = 0;
        pavValue->size = sizeX;
        pavValue->segment = segX;
        }
    else if (classvalue == ASM_SIZE_CLASS) {
        AcceptAsmToken();
        if (GetAsmToken(&classvalue) != ASM_PTROP_CLASS)    //  dummy token
            error(SYNTAX);
        GetAsmByteTerm(pavValue, fBracket);
        if (!(pavValue->flags & (fIMM | fPTR | fPTR16 | fPTR32))
                || pavValue->reloc > 1
                || pavValue->size != sizeX)
            error(OPERAND);
        pavValue->reloc = 1;            // make ptr a relocatable value
        if (pavValue->flags & fIMM)
            pavValue->flags = fPTR;
        pavValue->size = (UCHAR)(tokenvalue & ASM_TYPE_MASK);
                                                //  value has "size?"
        }
    else
        GetAsmOffTerm(pavValue, fBracket);
dprintf("exit  GetAsmByteTerm with %lx\n", pavValue->value);
}

//      <offTerm>  ::= [<segovr>] <colnTerm>

void GetAsmOffTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   classvalue;
    ULONG   tokenvalue;

dprintf("enter GetAsmOffTerm\n");
    classvalue = PeekAsmToken(&tokenvalue);
    if (classvalue == ASM_SEGOVR_CLASS || classvalue == ASM_SEGMENT_CLASS) {
        if (fBracket)
            error(SYNTAX);
        AcceptAsmToken();
        }
    GetAsmColnTerm(pavValue, fBracket);
    if (classvalue == ASM_SEGOVR_CLASS) {
        if (pavValue->reloc > 1 || pavValue->segovr != segX)
            error(OPERAND);
        pavValue->reloc = 1;            //  make ptr a relocatable value
        if (pavValue->flags & fIMM)
            pavValue->flags = fPTR;
        pavValue->segovr = (UCHAR)tokenvalue;   //  has segment override
        }
    else if (classvalue == ASM_SEGMENT_CLASS) {
        if (!(pavValue->flags & fIMM) || pavValue->reloc > 1)
            error(OPERAND);
        pavValue->segment = (USHORT)tokenvalue; //  segment has segment value
        pavValue->flags = fFPTR;        //  set flag for far pointer
        }
dprintf("exit  GetAsmOffTerm with %lx\n", pavValue->value);
}

//      <colnTerm> ::= <dotTerm> [.<dotTerm>]*

void GetAsmColnTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avTerm;

dprintf("enter GetAsmColnTerm\n");
    GetAsmDotTerm(pavValue, fBracket);
    while (PeekAsmToken(&tokenvalue) == ASM_DOTOP_CLASS) {
        AcceptAsmToken();
        GetAsmDotTerm(&avTerm, fBracket);
        AddAsmValues(pavValue, &avTerm);
        }
dprintf("exit  GetAsmColnTerm with %lx\n", pavValue->value);
}

//      <dotTerm>  ::= <indxTerm> ['['<Expr>']']*

void GetAsmDotTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ASM_VALUE avExpr;

dprintf("enter GetAsmDotTerm\n");
    GetAsmIndxTerm(pavValue, fBracket);
    if (pavValue->reloc > 1)
        error(OPERAND);
    while (PeekAsmToken(&tokenvalue) == ASM_LBRACK_CLASS) {
        AcceptAsmToken();
        if (fBracket)
            error(SYNTAX);
        GetAsmExpr(&avExpr, TRUE);
        AddAsmValues(pavValue, &avExpr);
        if (GetAsmToken(&tokenvalue) != ASM_RBRACK_CLASS)
            error(SYNTAX);
        if (pavValue->flags & fIMM)
            pavValue->flags = fPTR;
        }
dprintf("exit  GetAsmDotTerm with %lx\n", pavValue->value);
}

//      <indxTerm> ::= <index-reg> | <symbol> | <number> | '('<Expr>')'
//                                                       | '['<Expr>']'

void GetAsmIndxTerm (PASM_VALUE pavValue, UCHAR fBracket)
{
    ULONG   tokenvalue;
    ULONG   classvalue;

dprintf("enter GetAsmIndxTerm\n");
    classvalue = GetAsmToken(&tokenvalue);
    pavValue->segovr = segX;
    pavValue->size = sizeX;
    pavValue->reloc = 0;
    pavValue->value = 0;
    if (classvalue == ASM_LPAREN_CLASS) {
        GetAsmExpr(pavValue, fBracket);
        if (GetAsmToken(&tokenvalue) != ASM_RPAREN_CLASS)
            error(SYNTAX);
        }
    else if (classvalue == ASM_LBRACK_CLASS) {
        if (fBracket)
            error(SYNTAX);
        GetAsmExpr(pavValue, TRUE);
        if (GetAsmToken(&tokenvalue) != ASM_RBRACK_CLASS)
            error(SYNTAX);
        if (pavValue->flags == fIMM)
            pavValue->flags = fPTR;
        }
    else if (classvalue == ASM_SYMBOL_CLASS) {
        pavValue->value = tokenvalue;
        pavValue->flags = fIMM;
        pavValue->reloc = 1;
        }
    else if (classvalue == ASM_NUMBER_CLASS ||
             classvalue == ASM_SIGNED_NUMBER_CLASS) {
        pavValue->value = tokenvalue;
        pavValue->flags = fIMM |
            (classvalue == ASM_SIGNED_NUMBER_CLASS ? fSIGNED : 0);
        }
    else if (classvalue == ASM_REG_WORD) {
        if (!fBracket)
            error(SYNTAX);
        pavValue->flags = fPTR16;
        pavValue->base = tabWordReg[tokenvalue];
        if (pavValue->base == 0xff)
            error(OPERAND);
        }
    else if (classvalue == ASM_REG_DWORD) {
        if (!fBracket)
            error(SYNTAX);
        pavValue->flags = fPTR32;
        pavValue->base = (UCHAR)tokenvalue;
        pavValue->index = 0xff;
        }
    else
        error(SYNTAX);
dprintf("exit  GetAsmIndxTerm with %lx\n", pavValue->value);
}

void AddAsmValues (PASM_VALUE pavLeft, PASM_VALUE pavRight)
{
    //  swap values if left one is a pointer

    if (pavLeft->flags & fPTR)
        SwapPavs(pavLeft, pavRight);

    //  swap values if left one is an immediate

    if (pavLeft->flags & fIMM)
        SwapPavs(pavLeft, pavRight);

    //  the above swaps reduce the cases to test.
    //      pairs with an immediate will have it on the right
    //      pairs with a pointer will have it on the right,
    //          except for a pointer-immediate pair

    //  if both values are 16-bit pointers, combine them

    if (pavLeft->flags & pavRight->flags & fPTR16) {

        //  if either side has both registers (rm < 4), error

        if (!(pavLeft->base & pavRight->base & 4))
            error(OPERAND);

        //  use lookup table to compute new rm value

        pavLeft->base = rm16Table[((pavLeft->base & 3) << 2) +
                                  (pavRight->base & 3)];
        if (pavLeft->base == 0xff)
            error(OPERAND);

        pavRight->flags = fPTR;
        }

    //  if both values are 32-bit pointers, combine them

    if (pavLeft->flags & pavRight->flags & fPTR32) {

        //  error if either side has both base and index,
        //      or if both have index

        if (((pavLeft->base | pavLeft->index) != 0xff)
                || ((pavRight->base | pavRight->index) != 0xff)
                || ((pavLeft->index | pavRight->index) != 0xff))
            error(OPERAND);

        //  if left side has base, swap sides

        if (pavLeft->base != 0xff)
            SwapPavs(pavLeft, pavRight);

        //  two cases remaining, index-base and base-base

        if (pavLeft->base != 0xff) {

            //  left side has base, promote to index but swap if left
            //      base is ESP since it cannot be an index register

            if (pavLeft->base == indSP)
                SwapPavs(pavLeft, pavRight);
            if (pavLeft->base == indSP)
                error(OPERAND);
            pavLeft->index = pavLeft->base;
            pavLeft->scale = 0;
            }

        //  finish by setting left side base to right side value

        pavLeft->base = pavRight->base;

        pavRight->flags = fPTR;
        }

    //  if left side is any pointer and right is nonindex pointer,
    //      combine them.  (above cases set right side to use this code)

    if ((pavLeft->flags & (fPTR | fPTR16 | fPTR32))
                                        && (pavRight->flags & fPTR)) {
        if (pavLeft->segovr + pavRight->segovr != segX
                                && pavLeft->segovr != pavRight->segovr)
            error(OPERAND);
        if (pavLeft->size + pavRight->size != sizeX
                                && pavLeft->size != pavRight->size)
            error(OPERAND);
        pavRight->flags = fIMM;
        }

    //  if right side is immediate, add values and relocs
    //      (above case sets right side to use this code)
    //  illegal value types do not have right side set to fIMM

    if (pavRight->flags & fIMM) {
        pavLeft->value += pavRight->value;
        pavLeft->reloc += pavRight->reloc;
        }
    else
        error(OPERAND);
}

void SwapPavs (PASM_VALUE pavFirst, PASM_VALUE pavSecond)
{
    ASM_VALUE   temp;

    memmove(&temp, pavFirst, sizeof(ASM_VALUE));
    memmove(pavFirst, pavSecond, sizeof(ASM_VALUE));
    memmove(pavSecond, &temp, sizeof(ASM_VALUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_asm.h ===
#ifdef  DEBUG
#define dprintf printf
#else
#define dprintf //
#endif

//  token classes and types

#define ASM_CLASS_MASK          0xff00
#define ASM_TYPE_MASK           0x00ff

#define ASM_EOL_CLASS           0x000

#define ASM_ADDOP_CLASS         0x100
#define ASM_ADDOP_PLUS          0x101
#define ASM_ADDOP_MINUS         0x102

#define ASM_MULOP_CLASS         0x200
#define ASM_MULOP_MULT          0x201
#define ASM_MULOP_DIVIDE        0x202
#define ASM_MULOP_MOD           0x203
#define ASM_MULOP_SHL           0x204
#define ASM_MULOP_SHR           0x205

#define ASM_ANDOP_CLASS         0x300

#define ASM_NOTOP_CLASS         0x400

#define ASM_OROP_CLASS          0x500
#define ASM_OROP_OR             0x501
#define ASM_OROP_XOR            0x502

#define ASM_RELOP_CLASS         0x600
#define ASM_RELOP_EQ            0x601
#define ASM_RELOP_NE            0x602
#define ASM_RELOP_LE            0x603
#define ASM_RELOP_LT            0x604
#define ASM_RELOP_GE            0x605
#define ASM_RELOP_GT            0x606

#define ASM_UNOP_CLASS          0x700
#define ASM_UNOP_BY             0x701   //  UNDONE
#define ASM_UNOP_WO             0x702   //  UNDONE
#define ASM_UNOP_DW             0x703   //  UNDONE
#define ASM_UNOP_POI            0x704   //  UNDONE

#define ASM_LOWOP_CLASS         0x800
#define ASM_LOWOP_LOW           0x801
#define ASM_LOWOP_HIGH          0x802

#define ASM_PTROP_CLASS         0x900

#define ASM_SIZE_CLASS          0xa00
#define ASM_SIZE_BYTE           (0xa00 + sizeB)
#define ASM_SIZE_WORD           (0xa00 + sizeW)
#define ASM_SIZE_DWORD          (0xa00 + sizeD)
#define ASM_SIZE_FWORD          (0xa00 + sizeF)
#define ASM_SIZE_QWORD          (0xa00 + sizeQ)
#define ASM_SIZE_TBYTE          (0xa00 + sizeT)
#define ASM_SIZE_SWORD          (0xa00 + sizeS)

#define ASM_OFFOP_CLASS         0xb00
#define ASM_COLNOP_CLASS        0xc00
#define ASM_LPAREN_CLASS        0xd00
#define ASM_RPAREN_CLASS        0xe00
#define ASM_LBRACK_CLASS        0xf00
#define ASM_RBRACK_CLASS        0x1000
#define ASM_DOTOP_CLASS         0x1100
#define ASM_SEGOVR_CLASS        0x1200
#define ASM_SEGMENT_CLASS       0x1300          //  value has 16-bit value
#define ASM_COMMA_CLASS         0x1400

#define ASM_REG_CLASS           0x1500
#define ASM_REG_BYTE            0x1501
#define ASM_REG_WORD            0x1502
#define ASM_REG_DWORD           0x1503
#define ASM_REG_SEGMENT         0x1504
#define ASM_REG_CONTROL         0x1505
#define ASM_REG_DEBUG           0x1506
#define ASM_REG_TRACE           0x1507
#define ASM_REG_FLOAT           0x1508
#define ASM_REG_INDFLT          0x1509

#define ASM_NUMBER_CLASS        0x1600
#define ASM_SIGNED_NUMBER_CLASS 0x1601
#define ASM_SYMBOL_CLASS        0x1700

#define ASM_ERROR_CLASS         0xff00  //  only used for PeekToken

#define tEnd    0x80
#define eEnd    0x40

//  template flag and operand tokens

enum {
        asNone, as0x0a, asOpRg, asSiz0, asSiz1, asWait, asSeg,  asFSiz,
        asMpNx, asPrfx,

        asReg0, asReg1, asReg2, asReg3, asReg4, asReg5, asReg6, asReg7,

        opnAL,  opnAX,  opneAX, opnCL,  opnDX,  opnAp,  opnEb,  opnEw,
        opnEv,  opnGb,  opnGw,  opnGv,  opnGd,  opnIm1, opnIm3, opnIb,
        opnIw,  opnIv,  opnJb,  opnJv,  opnM,   opnMa,  opnMb,  opnMw,
        opnMd,  opnMp,  opnMs,  opnMq,  opnMt,  opnMv,  opnCd,  opnDd,
        opnTd,  opnRd,  opnSt,  opnSti, opnSeg, opnSw,  opnXb,  opnXv,
        opnYb,  opnYv,  opnOb,  opnOv,  opnIbe,
        };

#define asRegBase asReg0        //  first of REG flags
#define opnBase   opnAL         //  first template operand type
                                //  if less, then flag, else operand

enum {
        segX, segES,  segCS,  segSS,  segDS,  segFS,  segGS
        };

enum {
        typNULL,        //  no defined type
        typAX,          //  general register, value EAX
        typCL,          //  general register, value ECX
        typDX,          //  general register, value EDX
        typAbs,         //  absolute type (direct address)
        typExp,         //  expr (mod-r/m) general register or memory pointer
        typGen,         //  general register
        typReg,         //  general register (special reg MOV)
        typIm1,         //  immediate, value 1
        typIm3,         //  immediate, value 3
        typImm,         //  immediate
        typJmp,         //  jump relative offset
        typMem,         //  memory pointer
        typCtl,         //  control register
        typDbg,         //  debug register
        typTrc,         //  trace register
        typSt,          //  floating point top-of-stack
        typSti,         //  floating point index-on-stack
        typSeg,         //  segment register (PUSH/POP opcode)
        typSgr,         //  segment register (MOV opcode)
        typXsi,         //  string source address
        typYdi,         //  string destination address
        typOff,         //  memory offset
        typImmEx,       //  immediate, sign-extended
        };

enum {
        regG,           //  general register
        regS,           //  segment register
        regC,           //  control register
        regD,           //  debug register
        regT,           //  trace register
        regF,           //  float register (st)
        regI            //  float-index register (st(n))
        };

enum {
        indAX,          //  index for EAX, AX, AL
        indCX,          //  index for ECX, CX, CL
        indDX,          //  index for EDX, DX, DL
        indBX,          //  index for EBX, BX, BL
        indSP,          //  index for ESP, SP, AH
        indBP,          //  index for EBP, BP, CH
        indSI,          //  index for ESI, SI, DH
        indDI           //  index for EDI, DI, BH
        };

enum {
        sizeX,          //  no size
        sizeB,          //  byte size
        sizeW,          //  word size
        sizeV,          //  variable size (word or dword)
        sizeD,          //  dword size
        sizeP,          //  pointer size (dword or fword)
        sizeA,          //  dword or qword
        sizeF,          //  fword
        sizeQ,          //  qword
        sizeT,          //  ten-byte
        sizeS           //  sword
        };

//  mapping from operand token to operand type (class and opt. value)

typedef struct tagOPNDTYPE {
        UCHAR   type;
        UCHAR   size;
        } OPNDTYPE, *POPNDTYPE;

typedef struct tagASM_VALUE {
        ULONG   value;
        USHORT  segment;
        UCHAR   reloc;
        UCHAR   size;
        UCHAR   flags;
        UCHAR   segovr;
        UCHAR   index;
        UCHAR   base;
        UCHAR   scale;
        } ASM_VALUE, *PASM_VALUE;

//  bit values of flags in ASM_VALUE
//      flags are mutually exclusive

#define fREG    0x80            //  set if register
#define fIMM    0x40            //  set if immediate
#define fFPTR   0x20            //  set if far ptr
#define fPTR    0x10            //  set if memory ptr (no reg index)
#define fPTR16  0x08            //  set if memory ptr with 16-bit reg index
#define fPTR32  0x04            //  set if memory ptr with 32-bit reg index
#define fSIGNED 0x02            //  combine with fIMM for signed immediate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_asmtpl.cpp ===
#include "ntsdp.hpp"

#include "i386_asm.h"

PUCHAR X86SearchOpcode(PUCHAR);

//  type and size table is ordered on enum of operand types

OPNDTYPE mapOpndType[] = {
    { typAX,  sizeB },          //  opnAL  - AL register - byte
    { typAX,  sizeW },          //  opnAX  - AX register - word
    { typAX,  sizeV },          //  opneAX - eAX register - (d)word
    { typCL,  sizeB },          //  opnCL  - CX register - byte
    { typDX,  sizeW },          //  opnDX -  DX register - word (DX)
    { typAbs, sizeV },          //  opnAp -  absolute pointer (16:16/32)
    { typExp, sizeB },          //  opnEb -  expression (mem/reg) - byte
    { typExp, sizeW },          //  opnEw -  expression (mem/reg) - word
    { typExp, sizeV },          //  opnEv -  expression (mem/reg) - (d)word
    { typGen, sizeB },          //  opnGb -  general register - byte
    { typGen, sizeW },          //  opnGw -  general register - word
    { typGen, sizeV },          //  opnGv -  general register - (d)word
    { typGen, sizeD },          //  opnGd -  general register - dword
    { typIm1, sizeB },          //  opnIm1 - immediate - value 1
    { typIm3, sizeB },          //  opnIm3 - immediate - value 3
    { typImm, sizeB },          //  opnIb -  immediate - byte
    { typImm, sizeW },          //  opnIw -  immediate - word
    { typImm, sizeV },          //  opnIv -  immediate - (d)word
    { typJmp, sizeB },          //  opnJb -  relative jump - byte
    { typJmp, sizeV },          //  opnJv -  relative jump - (d)word
    { typMem, sizeX },          //  opnM  -  memory pointer - nosize
    { typMem, sizeA },          //  opnMa -  memory pointer - (16:16, 32:32)
    { typMem, sizeB },          //  opnMb -  memory pointer - byte
    { typMem, sizeW },          //  opnMw -  memory pointer - word
    { typMem, sizeD },          //  opnMd -  memory pointer - dword
    { typMem, sizeP },          //  opnMp -  memory pointer - (d)(f)word
    { typMem, sizeS },          //  opnMs -  memory pointer - sword
    { typMem, sizeQ },          //  opnMq -  memory pointer - qword
    { typMem, sizeT },          //  opnMt -  memory pointer - ten-byte
    { typMem, sizeV },          //  opnMv -  memory pointer - (d)word
    { typCtl, sizeD },          //  opnCd -  control register - dword
    { typDbg, sizeD },          //  opnDd -  debug register - dword
    { typTrc, sizeD },          //  opnTd -  trace register - dword
    { typReg, sizeD },          //  opnRd -  general register - dword
    { typSt,  sizeT },          //  opnSt -  floating point top-of-stack
    { typSti, sizeT },          //  opnSti - floating point index-on-stack
    { typSeg, sizeW },          //  opnSeg - segment register - PUSH / POP
    { typSgr, sizeW },          //  opnSw -  segment register - MOV
    { typXsi, sizeB },          //  opnXb -  string source - byte
    { typXsi, sizeV },          //  opnXv -  string source - (d)word
    { typYdi, sizeB },          //  opnYb -  string destination - byte
    { typYdi, sizeV },          //  opnYv -  string destination - (d)word
    { typOff, sizeB },          //  opnOb -  memory offset - byte
    { typOff, sizeV },          //  opnOv -  memory offset - (d)word
    { typImmEx, sizeB },        //  opnIbe - immediate - sign-extended byte
    };

UCHAR szAAA[] = {
          'a', 'a', 'a', '\0',
                0x37, asNone                       + tEnd + eEnd };

UCHAR szAAD[] = {
          'a', 'a', 'd', '\0',
                0xd5, as0x0a                       + tEnd + eEnd };

UCHAR szAAM[] = {
          'a', 'a', 'm', '\0',
                0xd4, as0x0a                       + tEnd + eEnd };

UCHAR szAAS[] = {
          'a', 'a', 's', '\0',
                0x3f, asNone                       + tEnd + eEnd };

UCHAR szADC[] = {
          'a', 'd', 'c', '\0',
                0x14,         opnAL,   opnIb       + tEnd,
                0x15,         opneAX,  opnIv       + tEnd,
                0x80, asReg2, opnEb,   opnIb       + tEnd,
                0x83, asReg2, opnEv,   opnIbe      + tEnd,
                0x81, asReg2, opnEv,   opnIv       + tEnd,
                0x10,         opnEb,   opnGb       + tEnd,
                0x11,         opnEv,   opnGv       + tEnd,
                0x12,         opnGb,   opnEb       + tEnd,
                0x13,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szADD[] = {
          'a', 'd', 'd', '\0',
                0x04,         opnAL,   opnIb       + tEnd,
                0x05,         opneAX,  opnIv       + tEnd,
                0x80, asReg0, opnEb,   opnIb       + tEnd,
                0x83, asReg0, opnEv,   opnIbe      + tEnd,
                0x81, asReg0, opnEv,   opnIv       + tEnd,
                0x00,         opnEb,   opnGb       + tEnd,
                0x01,         opnEv,   opnGv       + tEnd,
                0x02,         opnGb,   opnEb       + tEnd,
                0x03,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szAND[] = {
          'a', 'n', 'd', '\0',
                0x24,         opnAL,   opnIb       + tEnd,
                0x25,         opneAX,  opnIv       + tEnd,
                0x80, asReg4, opnEb,   opnIb       + tEnd,
                0x83, asReg4, opnEv,   opnIb       + tEnd,
                0x81, asReg4, opnEv,   opnIv       + tEnd,
                0x20,         opnEb,   opnGb       + tEnd,
                0x21,         opnEv,   opnGv       + tEnd,
                0x22,         opnGb,   opnEb       + tEnd,
                0x23,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szARPL[] = {
          'a', 'r', 'p', 'l', '\0',
                0x63,         opnEw,   opnGw       + tEnd + eEnd };

UCHAR szBOUND[] = {
          'b', 'o', 'u', 'n', 'd', '\0',
                0x62,         opnGv,   opnMa       + tEnd + eEnd };

UCHAR szBSF[] = {
          'b', 's', 'f', '\0',
          0x0f, 0xbc,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szBSR[] = {
          'b', 's', 'r', '\0',
          0x0f, 0xbd,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szBSWAP[] = {
          'b', 's', 'w', 'a', 'p', '\0',
          0x0f, 0xc8, asOpRg, opnGd                + tEnd + eEnd };

UCHAR szBT[] = {
          'b', 't', '\0',
          0x0f, 0xa3,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg4, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szBTC[] = {
          'b', 't', 'c', '\0',
          0x0f, 0xbb,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg7, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szBTR[] = {
          'b', 't', 'r', '\0',
          0x0f, 0xb3,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg6, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szBTS[] = {
          'b', 't', 's', '\0',
          0x0f, 0xab,         opnEv,   opnGv       + tEnd,
          0x0f, 0xba, asReg5, opnEv,   opnIb       + tEnd + eEnd };

UCHAR szCALL[] = {
          'c', 'a', 'l', 'l', '\0',
                0xe8,         opnJv                + tEnd,
                0xff, asReg2, asMpNx, opnEv        + tEnd,
                0xff, asReg3, opnMp                + tEnd,
                0x9a,         opnAp                + tEnd + eEnd };

UCHAR szCBW[] = {
          'c', 'b', 'w', '\0',
                0x98, asSiz0                       + tEnd + eEnd };

UCHAR szCDQ[] = {
          'c', 'd', 'q', '\0',
                0x99, asSiz1                       + tEnd + eEnd };

UCHAR szCLC[] = {
          'c', 'l', 'c', '\0',
                0xf8, asNone                       + tEnd + eEnd };

UCHAR szCLD[] = {
          'c', 'l', 'd', '\0',
                0xfc, asNone                       + tEnd + eEnd };

UCHAR szCLI[] = {
          'c', 'l', 'i', '\0',
                0xfa, asNone                       + tEnd + eEnd };

UCHAR szCLTS[] = {
          'c', 'l', 't', 's', '\0',
          0x0f, 0x06, asNone                       + tEnd + eEnd };

UCHAR szCMC[] = {
          'c', 'm', 'c', '\0',
                0xf5, asNone                       + tEnd + eEnd };

UCHAR szCMP[] = {
          'c', 'm', 'p', '\0',
                0x3c,         opnAL,   opnIb       + tEnd,
                0x3d,         opneAX,  opnIv       + tEnd,
                0x80, asReg7, opnEb,   opnIb       + tEnd,
                0x83, asReg7, opnEv,   opnIb       + tEnd,
                0x81, asReg7, opnEv,   opnIv       + tEnd,
                0x38,         opnEb,   opnGb       + tEnd,
                0x39,         opnEv,   opnGv       + tEnd,
                0x3a,         opnGb,   opnEb       + tEnd,
                0x3b,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szCMPS[] = {
          'c', 'm', 'p', 's', '\0',
                0xa6,         opnXb,   opnYb       + tEnd,
                0xa7,         opnXv,   opnYv       + tEnd + eEnd };

UCHAR szCMPSB[] = {
          'c', 'm', 'p', 's', 'b', '\0',
                0xa6, asNone                       + tEnd + eEnd };

UCHAR szCMPSD[] = {
          'c', 'm', 'p', 's', 'd', '\0',
                0xa7, asSiz1                       + tEnd + eEnd };

UCHAR szCMPSW[] = {
          'c', 'm', 'p', 's', 'w', '\0',
                0xa7, asSiz0                       + tEnd + eEnd };

UCHAR szCMPXCHG[] = {
          'c', 'm', 'p', 'x', 'c', 'h', 'g', '\0',
          0x0f, 0xb0,          opnEb,  opnGb       + tEnd,
          0x0f, 0xb1,          opnEv,  opnGv       + tEnd + eEnd };

UCHAR szCMPXCHG8B[] = {
          'c', 'm', 'p', 'x', 'c', 'h', 'g', '8', 'b', '\0',
                0x0f, 0xc7, asReg1,  opnMq         + tEnd + eEnd };

UCHAR szCPUID[] = {
          'c', 'p', 'u', 'i', 'd', '\0',
                0x0f, 0xa2, asNone                 + tEnd + eEnd };


UCHAR szCS[] = {
          'c', 's', ':', '\0',
                0x2e, asPrfx                       + tEnd + eEnd };

UCHAR szCWD[] = {
          'c', 'w', 'd', '\0',
                0x99, asSiz0                       + tEnd + eEnd };

UCHAR szCWDE[] = {
          'c', 'w', 'd', 'e', '\0',
                0x98, asSiz1                       + tEnd + eEnd };

UCHAR szDAA[] = {
          'd', 'a', 'a', '\0',
                0x27, asNone                       + tEnd + eEnd };

UCHAR szDAS[] = {
          'd', 'a', 's', '\0',
                0x2f, asNone                       + tEnd + eEnd };

UCHAR szDEC[] = {
          'd', 'e', 'c', '\0',
                0x48, asOpRg, opnGv                + tEnd,
                0xfe, asReg1, opnEb                + tEnd,
                0xff, asReg1, opnEv                + tEnd + eEnd };

UCHAR szDIV[] = {
          'd', 'i', 'v', '\0',
                0xf6, asReg6, opnEb                + tEnd,
                0xf7, asReg6, opnEv                + tEnd,
                0xf6, asReg6, opnAL,  opnEb        + tEnd,
                0xf7, asReg6, opneAX, opnEv        + tEnd + eEnd };

UCHAR szDS[] = {
          'd', 's', ':', '\0',
                0x3e, asPrfx                       + tEnd + eEnd };

UCHAR szENTER[] = {
          'e', 'n', 't', 'e', 'r', '\0',
                0xc8,         opnIw,  opnIb        + tEnd + eEnd };

UCHAR szES[] = {
          'e', 's', ':', '\0',
                0x36, asPrfx                       + tEnd + eEnd };

UCHAR szF2XM1[] = {
          'f', '2', 'x', 'm', '1', '\0',
          0xd8, 0xf0, asNone                       + tEnd + eEnd };

UCHAR szFABS[] = {
          'f', 'a', 'b', 's', '\0',
          0xd9, 0xe1, asNone                       + tEnd + eEnd };

UCHAR szFADD[] = {
          'f', 'a', 'd', 'd', '\0',
          0xd8,       asReg0, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg0, opnMq                + tEnd,
          0xd8, 0xc0,         opnSt,   opnSti      + tEnd,
          0xdc, 0xc0,         opnSti,  opnSt       + tEnd,
          0xdc, 0xc1, asNone                       + tEnd + eEnd };

UCHAR szFADDP[] = {
          'f', 'a', 'd', 'd', 'p', '\0',
          0xde, 0xc0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFBLD[] = {
          'f', 'b', 'l', 'd', '\0',
          0xdf,       asReg4, opnMt                + tEnd + eEnd };

UCHAR szFBSTP[] = {
          'f', 'b', 's', 't', 'p', '\0',
          0xdf,       asReg6, opnMt                + tEnd + eEnd };

UCHAR szFCHS[] = {
          'f', 'c', 'h', 's', '\0',
          0xd9, 0xe0, asNone                       + tEnd + eEnd };

UCHAR szFCLEX[] = {
          'f', 'c', 'l', 'e', 'x', '\0',
          0xdb, 0xe2, asWait                       + tEnd + eEnd };

UCHAR szFCOM[] = {
          'f', 'c', 'o', 'm', '\0',
          0xd8, 0xd1, asNone                       + tEnd,
          0xd8, 0xd0,         opnSti               + tEnd,
          0xd8,       asReg2, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg2, opnMq                + tEnd + eEnd };

UCHAR szFCOMP[] = {
          'f', 'c', 'o', 'm', 'p', '\0',
          0xd8, 0xd9, asNone                       + tEnd,
          0xd8, 0xd8,         opnSti               + tEnd,
          0xd8,       asReg3, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg3, opnMq                + tEnd + eEnd };

UCHAR szFCOMPP[] = {
          'f', 'c', 'o', 'm', 'p', 'p', '\0',
          0xde, 0xd9, asNone                       + tEnd + eEnd };

UCHAR szFCOS[] = {
          'f', 'c', 'o', 's', '\0',
          0xd9, 0xff, asNone                       + tEnd + eEnd };

UCHAR szFDECSTP[] = {
          'f', 'd', 'e', 'c', 's', 't', 'p', '\0',
          0xd9, 0xf6, asWait                       + tEnd + eEnd };

UCHAR szFDISI[] = {
          'f', 'd', 'i', 's', 'i', '\0',
          0xdb, 0xe1, asWait                       + tEnd + eEnd };

UCHAR szFDIV[] = {
          'f', 'd', 'i', 'v', '\0',
          0xdc, 0xf9, asNone                       + tEnd,
          0xd8,       asReg6, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg6, opnMq                + tEnd,
          0xd8, 0xf0,         opnSt,   opnSti      + tEnd,
          0xdc, 0xf8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFDIVP[] = {
          'f', 'd', 'i', 'v', 'p', '\0',
          0xde, 0xf8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFDIVR[] = {
          'f', 'd', 'i', 'v', 'r', '\0',
          0xde, 0xf1, asNone                       + tEnd,
          0xd8,       asReg7, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg7, opnMq                + tEnd,
          0xd8, 0xf8,         opnSt,   opnSti      + tEnd,
          0xdc, 0xf0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFDIVRP[] = {
          'f', 'd', 'i', 'v', 'r', 'p', '\0',
          0xde, 0xf0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFENI[] = {
          'f', 'e', 'n', 'i', '\0',
          0xdb, 0xe0, asWait                       + tEnd + eEnd };

UCHAR szFFREE[] = {
          'f', 'f', 'r', 'e', 'e', '\0',
          0xdd, 0xc0, asWait, opnSti               + tEnd + eEnd };

UCHAR szFIADD[] = {
          'f', 'i', 'a', 'd', 'd', '\0',
          0xde,       asReg0, opnMw,   asFSiz      + tEnd,
          0xda,       asReg0, opnMd                + tEnd + eEnd };

UCHAR szFICOM[] = {
          'f', 'i', 'c', 'o', 'm', '\0',
          0xde,       asReg2, opnMw,   asFSiz      + tEnd,
          0xda,       asReg2, opnMd                + tEnd + eEnd };

UCHAR szFICOMP[] = {
          'f', 'i', 'c', 'o', 'm', 'p', '\0',
          0xde,       asReg3, opnMw,   asFSiz      + tEnd,
          0xda,       asReg3, opnMd                + tEnd + eEnd };

UCHAR szFIDIV[] = {
          'f', 'i', 'd', 'i', 'v', '\0',
          0xde,       asReg6, opnMw,   asFSiz      + tEnd,
          0xda,       asReg6, opnMd                + tEnd + eEnd };

UCHAR szFIDIVR[] = {
          'f', 'i', 'd', 'i', 'v', 'r', '\0',
          0xde,       asReg7, opnMw,   asFSiz      + tEnd,
          0xda,       asReg7, opnMd                + tEnd + eEnd };

UCHAR szFILD[] = {
          'f', 'i', 'l', 'd', '\0',
          0xdf,       asReg0, opnMw,   asFSiz      + tEnd,
          0xdb,       asReg0, opnMd                + tEnd,
          0xdf,       asReg5, opnMq                + tEnd + eEnd };

UCHAR szFIMUL[] = {
          'f', 'i', 'm', 'u', 'l', '\0',
          0xde,       asReg1, opnMw,   asFSiz      + tEnd,
          0xda,       asReg1, opnMd                + tEnd + eEnd };

UCHAR szFINCSTP[] = {
          'f', 'i', 'n', 'c', 's', 't', 'p', '\0',
          0xd9, 0xf7, asWait                       + tEnd + eEnd };

UCHAR szFINIT[] = {
          'f', 'i', 'n', 'i', 't', '\0',
          0xdb, 0xe3, asWait                       + tEnd + eEnd };

UCHAR szFIST[] = {
          'f', 'i', 's', 't', '\0',
          0xdf,       asReg2, opnMw,   asFSiz      + tEnd,
          0xdb,       asReg2, opnMd                + tEnd + eEnd };

UCHAR szFISTP[] = {
          'f', 'i', 's', 't', 'p', '\0',
          0xdf,       asReg3, opnMw,   asFSiz      + tEnd,
          0xdb,       asReg3, opnMd                + tEnd,
          0xdf,       asReg7, opnMq                + tEnd + eEnd };

UCHAR szFISUB[] = {
          'f', 'i', 's', 'u', 'b', '\0',
          0xde,       asReg4, opnMw,   asFSiz      + tEnd,
          0xda,       asReg4, opnMd                + tEnd + eEnd };

UCHAR szFISUBR[] = {
          'f', 'i', 's', 'u', 'b', 'r', '\0',
          0xde,       asReg5, opnMw,   asFSiz      + tEnd,
          0xda,       asReg5, opnMd                + tEnd + eEnd };

UCHAR szFLD[] = {
          'f', 'l', 'd', '\0',
          0xd9,       asReg0, opnMd,   asFSiz      + tEnd,
          0xdd,       asReg0, opnMq                + tEnd,
          0xdb,       asReg5, opnMt                + tEnd,
          0xd9, 0xc0,         opnSti               + tEnd + eEnd };

UCHAR szFLD1[] = {
          'f', 'l', 'd', '1', '\0',
          0xd9, 0xe8, asNone                       + tEnd + eEnd };

UCHAR szFLDCW[] = {
          'f', 'l', 'd', 'c', 'w', '\0',
          0xd9,       asWait, asReg5, opnMw        + tEnd + eEnd };

UCHAR szFLDENV[] = {
          'f', 'l', 'd', 'e', 'n', 'v', '\0',
          0xd9,       asWait, asReg4, opnMw        + tEnd + eEnd };

UCHAR szFLDL2E[] = {
          'f', 'l', 'd', 'l', '2', 'e', '\0',
          0xd9, 0xea, asNone                       + tEnd + eEnd };

UCHAR szFLDL2T[] = {
          'f', 'l', 'd', 'l', '2', 't', '\0',
          0xd9, 0xe9, asNone                       + tEnd + eEnd };

UCHAR szFLDLG2[] = {
          'f', 'l', 'd', 'l', 'g', '2', '\0',
          0xd9, 0xec, asNone                       + tEnd + eEnd };

UCHAR szFLDLN2[] = {
          'f', 'l', 'd', 'l', 'n', '2', '\0',
          0xd9, 0xed, asNone                       + tEnd + eEnd };

UCHAR szFLDPI[] = {
          'f', 'l', 'd', 'p', 'i', '\0',
          0xd9, 0xeb, asNone                       + tEnd + eEnd };

UCHAR szFLDZ[] = {
          'f', 'l', 'd', 'z', '\0',
          0xd9, 0xee, asNone                       + tEnd + eEnd };

UCHAR szFMUL[] = {
          'f', 'm', 'u', 'l', '\0',
          0xde, 0xc9, asNone                       + tEnd,
          0xd8,       asReg1, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg1, opnMq                + tEnd,
          0xd8, 0xc8,         opnSt,   opnSti      + tEnd,
          0xdc, 0xc8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFMULP[] = {
          'f', 'm', 'u', 'l', 'p', '\0',
          0xde, 0xc8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFNCLEX[] = {
          'f', 'n', 'c', 'l', 'e', 'x', '\0',
          0xdb, 0xe2, asNone                       + tEnd + eEnd };

UCHAR szFNDISI[] = {
          'f', 'n', 'd', 'i', 's', 'i', '\0',
          0xdb, 0xe1, asNone                       + tEnd + eEnd };

UCHAR szFNENI[] = {
          'f', 'n', 'e', 'n', 'i', '\0',
          0xdb, 0xe0, asNone                       + tEnd + eEnd };

UCHAR szFNINIT[] = {
          'f', 'n', 'i', 'n', 'i', 't', '\0',
          0xdb, 0xe3, asNone                       + tEnd + eEnd };

UCHAR szFNOP[] = {
          'f', 'n', 'o', 'p', '\0',
          0xd9, 0xd0, asNone                       + tEnd + eEnd };

UCHAR szFNSAVE[] = {
          'f', 'n', 's', 'a', 'v', 'e', '\0',
          0xdd,       asReg6, opnM                 + tEnd + eEnd };

UCHAR szFNSTCW[] = {
          'f', 'n', 's', 't', 'c', 'w', '\0',
          0xd9,       asReg7, opnMw                + tEnd + eEnd };

UCHAR szFNSTENV[] = {
          'f', 'n', 's', 't', 'e', 'n', 'v', '\0',
          0xd9,       asReg6, opnM                 + tEnd + eEnd };

UCHAR szFNSTSW[] = {
          'f', 'n', 's', 't', 's', 'w', '\0',
          0xdf, 0xe0, asNone                       + tEnd,
          0xdf, 0xe0,         opnAX                + tEnd,
          0xdf,       asReg7, opnMw                + tEnd + eEnd };

UCHAR szFPATAN[] = {
          'f', 'p', 'a', 't', 'a', 'n', '\0',
          0xd9, 0xf3, asNone                       + tEnd + eEnd };

UCHAR szFPREM[] = {
          'f', 'p', 'r', 'e', 'm', '\0',
          0xd9, 0xf8, asNone                       + tEnd + eEnd };

UCHAR szFPREM1[] = {
          'f', 'p', 'r', 'e', 'm', '1', '\0',
          0xd9, 0xf5, asNone                       + tEnd + eEnd };

UCHAR szFPTAN[] = {
          'f', 'p', 't', 'a', 'n', '\0',
          0xd9, 0xf2, asNone                       + tEnd + eEnd };

UCHAR szFRNDINT[] = {
          'f', 'r', 'n', 'd', 'i', 'n', 't', '\0',
          0xd9, 0xfc, asNone                       + tEnd + eEnd };

UCHAR szFRSTOR[] = {
          'f', 'r', 's', 't', 'o', 'r', '\0',
          0xdd,       asWait, asReg4, opnM         + tEnd + eEnd };

UCHAR szFS[] = {
          'f', 's', ':', '\0',
                0x64, asPrfx                       + tEnd + eEnd };

UCHAR szFSAVE[] = {
          'f', 's', 'a', 'v', 'e', '\0',
          0xdd,       asWait, asReg6, opnM         + tEnd + eEnd };

UCHAR szFSCALE[] = {
          'f', 's', 'c', 'a', 'l', 'e', '\0',
          0xd9, 0xfd, asNone                       + tEnd + eEnd };

UCHAR szFSETPM[] = {
          'f', 's', 'e', 't', 'p', 'm', '\0',
          0xdb, 0xe4, asWait                       + tEnd + eEnd };

UCHAR szFSIN[] = {
          'f', 's', 'i', 'n', '\0',
          0xd9, 0xfe, asNone                       + tEnd + eEnd };

UCHAR szFSINCOS[] = {
          'f', 's', 'i', 'n', 'c', 'o', 's', '\0',
          0xd9, 0xfb, asNone                       + tEnd + eEnd };

UCHAR szFSQRT[] = {
          'f', 's', 'q', 'r', 't', '\0',
          0xd9, 0xfa, asNone                       + tEnd + eEnd };

UCHAR szFST[] = {
          'f', 's', 't', '\0',
          0xd9,       asReg2, opnMd,   asFSiz      + tEnd,
          0xdd,       asReg2, opnMq                + tEnd,
          0xdd, 0xd0,         opnSti               + tEnd + eEnd };

UCHAR szFSTCW[] = {
          'f', 's', 't', 'c', 'w', '\0',
          0xd9,       asWait, asReg7, opnMw        + tEnd + eEnd };

UCHAR szFSTENV[] = {
          'f', 's', 't', 'e', 'n', 'v', '\0',
          0xd9,       asWait, asReg6, opnM         + tEnd + eEnd };

UCHAR szFSTP[] = {
          'f', 's', 't', 'p', '\0',
          0xd9,       asReg3, opnMd,   asFSiz      + tEnd,
          0xdd,       asReg3, opnMq                + tEnd,
          0xdb,       asReg7, opnMt                + tEnd,
          0xdd, 0xd8,         opnSti               + tEnd + eEnd };

UCHAR szFSTSW[] = {
          'f', 's', 't', 's', 'w', '\0',
          0xdf, 0xe0, asWait                       + tEnd,
          0xdf, 0xe0, asWait, opnAX                + tEnd,
          0xdd,       asWait, asReg7, opnMw        + tEnd + eEnd };

UCHAR szFSUB[] = {
          'f', 's', 'u', 'b', '\0',
          0xde, 0xe9, asNone                       + tEnd,
          0xd8,       asReg4, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg4, opnMq                + tEnd,
          0xd8, 0xe0,         opnSt,   opnSti      + tEnd,
          0xdc, 0xe8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFSUBP[] = {
          'f', 's', 'u', 'b', 'p', '\0',
          0xde, 0xe8,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFSUBR[] = {
          'f', 's', 'u', 'b', 'r', '\0',
          0xde, 0xe1, asNone                       + tEnd,
          0xd8,       asReg5, opnMd,   asFSiz      + tEnd,
          0xdc,       asReg5, opnMq                + tEnd,
          0xd8, 0xe8,         opnSt,   opnSti      + tEnd,
          0xdc, 0xe0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFSUBRP[] = {
          'f', 's', 'u', 'b', 'r', 'p', '\0',
          0xde, 0xe0,         opnSti,  opnSt       + tEnd + eEnd };

UCHAR szFTST[] = {
          'f', 't', 's', 't', '\0',
          0xd9, 0xe4, asNone                       + tEnd + eEnd };

UCHAR szFUCOM[] = {
          'f', 'u', 'c', 'o', 'm', '\0',
          0xdd, 0xe1, asNone,                      + tEnd,
          0xdd, 0xe0,         opnSti               + tEnd + eEnd };

UCHAR szFUCOMP[] = {
          'f', 'u', 'c', 'o', 'm', 'p', '\0',
          0xdd, 0xe9, asNone                       + tEnd,
          0xdd, 0xe8,         opnSti               + tEnd + eEnd };

UCHAR szFUCOMPP[] = {
          'f', 'u', 'c', 'o', 'm', 'p', 'p', '\0',
          0xda, 0xe9, asNone                       + tEnd + eEnd };

UCHAR szFWAIT[] = {                             //  same as WAIT
          'f', 'w', 'a', 'i', 't', '\0',
          0x9b,       asPrfx                       + tEnd + eEnd };

UCHAR szFXAM[] = {
          'f', 'x', 'a', 'm', '\0',
          0xd9, 0xe5, asNone                       + tEnd + eEnd };

UCHAR szFXCH[] = {
          'f', 'x', 'c', 'h', '\0',
          0xd9, 0xc9, asNone                       + tEnd,
          0xd9, 0xc8,         opnSti               + tEnd + eEnd };

UCHAR szFXTRACT[] = {
          'f', 'x', 't', 'r', 'a', 'c', 't', '\0',
          0xd9, 0xf4, asNone                       + tEnd + eEnd };

UCHAR szFYL2X[] = {
          'f', 'y', 'l', '2', 'x', '\0',
          0xd9, 0xf1, asNone                       + tEnd + eEnd };

UCHAR szFYL2XP1[] = {
          'f', 'y', 'l', '2', 'x', 'p', '1', '\0',
          0xd9, 0xf9, asNone                       + tEnd + eEnd };

UCHAR szGS[] = {
          'g', 's', ':', '\0',
                0x65, asPrfx                       + tEnd + eEnd };

UCHAR szHLT[] = {
          'h', 'l', 't', '\0',
                0xf4, asNone                       + tEnd + eEnd };

UCHAR szIDIV[] = {
          'i', 'd', 'i', 'v', '\0',
                0xf6, asReg7, opnEb                + tEnd,
                0xf7, asReg7, opnEv                + tEnd,
                0xf6, asReg7, opnAL,  opnEb        + tEnd,
                0xf7, asReg7, opneAX, opnEv        + tEnd + eEnd };

UCHAR szIMUL[] = {
          'i', 'm', 'u', 'l', '\0',
                0xf6, asReg5, opnEb                + tEnd,
                0xf7, asReg5, opnEv                + tEnd,
                0xf6, asReg5, opnAL,  opnEb        + tEnd,
                0xf7, asReg5, opneAX, opnEv        + tEnd,
          0x0f, 0xaf,         opnGv,  opnEv        + tEnd,
                0x6b,         opnGv,  opnIbe       + tEnd,
                0x69,         opnGv,  opnIv        + tEnd,
                0x6b,         opnGv,  opnEv, opnIbe + tEnd,
                0x69,         opnGv,  opnEv, opnIv + tEnd + eEnd };

UCHAR szIN[] = {
          'i', 'n', '\0',
                0xe4,         opnAL,  opnIb        + tEnd,
                0xe5,         opneAX, opnIb        + tEnd,
                0xec,         opnAL,  opnDX        + tEnd,
                0xed,         opneAX, opnDX        + tEnd + eEnd };

UCHAR szINC[] = {
          'i', 'n', 'c', '\0',
                0x40, asOpRg, opnGv                + tEnd,
                0xfe, asReg0, opnEb                + tEnd,
                0xff, asReg0, opnEv                + tEnd + eEnd };

UCHAR szINS[] = {
          'i', 'n', 's', '\0',
                0x6c,         opnYb,  opnDX        + tEnd,
                0x6d,         opnYv,  opnDX        + tEnd + eEnd };

UCHAR szINSB[] = {
          'i', 'n', 's', 'b', '\0',
                0x6c, asNone                       + tEnd + eEnd };

UCHAR szINSD[] = {
          'i', 'n', 's', 'd', '\0',
                0x6d, asSiz1                       + tEnd + eEnd };

UCHAR szINSW[] = {
          'i', 'n', 's', 'w', '\0',
                0x6d, asSiz0                       + tEnd + eEnd };

UCHAR szINT[] = {
          'i', 'n', 't', '\0',
                0xcc,         opnIm3               + tEnd,
                0xcd,         opnIb                + tEnd + eEnd };

UCHAR szINTO[] = {
          'i', 'n', 't', 'o', '\0',
                0xce, asNone                       + tEnd + eEnd };

UCHAR szINVD[] = {
          'i', 'n', 'v', 'd', '\0',
          0x0f, 0x08, asNone                       + tEnd + eEnd };

UCHAR szINVLPG[] = {
          'i', 'n', 'v', 'l', 'p', 'g', '\0',
          0x0f, 0x01, asReg7, opnM                 + tEnd + eEnd };

UCHAR szIRET[] = {
          'i', 'r', 'e', 't', '\0',
                0xcf, asSiz0                       + tEnd + eEnd };

UCHAR szIRETD[] = {
          'i', 'r', 'e', 't', 'd', '\0',
                0xcf, asSiz1                       + tEnd + eEnd };

UCHAR szJA[] = {                                //  same as JNBE
          'j', 'a', '\0',
                0x77,         opnJb                + tEnd,
          0x0f, 0x87,         opnJv                + tEnd + eEnd };

UCHAR szJAE[] = {                               //  same as JNB, JNC
          'j', 'a', 'e', '\0',
                0x73,         opnJb                + tEnd,
          0x0f, 0x83,         opnJv                + tEnd + eEnd };

UCHAR szJB[] = {                                //  same as JC, JNAE
          'j', 'b', '\0',
                0x72,         opnJb                + tEnd,
          0x0f, 0x82,         opnJv                + tEnd + eEnd };

UCHAR szJBE[] = {                               //  same as JNA
          'j', 'b', 'e', '\0',
                0x76,         opnJb                + tEnd,
          0x0f, 0x86,         opnJv                + tEnd + eEnd };

UCHAR szJC[] = {                                //  same as JB, JNAE
          'j', 'c', '\0',
                0x72,         opnJb                + tEnd,
          0x0f, 0x82,         opnJv                + tEnd + eEnd };

UCHAR szJCXZ[] = {
          'j', 'c', 'x', 'z', '\0',
                0xe3, asSiz0, opnJb                + tEnd + eEnd };

UCHAR szJECXZ[] = {
          'j', 'e', 'c', 'x', 'z', '\0',
                0xe3, asSiz1, opnJb                + tEnd + eEnd };

UCHAR szJE[] = {                                //  same as JZ
          'j', 'e', '\0',
                0x74,         opnJb                + tEnd,
          0x0f, 0x84,         opnJv                + tEnd + eEnd };

UCHAR szJG[] = {                                //  same as JNLE
          'j', 'g', '\0',
                0x7f,         opnJb                + tEnd,
          0x0f, 0x8f,         opnJv                + tEnd + eEnd };

UCHAR szJGE[] = {                               //  same as JNL
          'j', 'g', 'e', '\0',
                0x7d,         opnJb                + tEnd,
          0x0f, 0x8d,         opnJv                + tEnd + eEnd };

UCHAR szJL[] = {                                //  same as JNGE
          'j', 'l', '\0',
                0x7c,         opnJb                + tEnd,
          0x0f, 0x8c,         opnJv                + tEnd + eEnd };

UCHAR szJLE[] = {                               //  same as JNG
          'j', 'l', 'e', '\0',
                0x7e,         opnJb                + tEnd,
          0x0f, 0x8e,         opnJv                + tEnd + eEnd };

UCHAR szJMP[] = {
          'j', 'm', 'p', '\0',
                0xeb,         opnJb                + tEnd,
                0xe9,         opnJv                + tEnd,
                0xff, asReg4, opnEv, asMpNx        + tEnd,
                0xff, asReg5, opnMp                + tEnd,
                0xea,         opnAp                + tEnd, + eEnd };

UCHAR szJNA[] = {                               //  same as JBE
          'j', 'n', 'a', '\0',
                0x76,         opnJb                + tEnd,
          0x0f, 0x86,         opnJv                + tEnd + eEnd };

UCHAR szJNAE[] = {                              //  same as JB, JC
          'j', 'n', 'a', 'e','\0',
                0x72,         opnJb                + tEnd,
          0x0f, 0x82,         opnJv                + tEnd + eEnd };

UCHAR szJNB[] = {                               //  same as JAE, JNC
          'j', 'n', 'b', '\0',
                0x73,         opnJb                + tEnd,
          0x0f, 0x83,         opnJv                + tEnd + eEnd };

UCHAR szJNBE[] = {                              //  same as JA
          'j', 'n', 'b', 'e', '\0',
                0x77,         opnJb                + tEnd,
          0x0f, 0x87,         opnJv                + tEnd + eEnd };

UCHAR szJNC[] = {                               //  same as JAE, JNB
          'j', 'n', 'c', '\0',
                0x73,         opnJb                + tEnd,
          0x0f, 0x83,         opnJv                + tEnd + eEnd };

UCHAR szJNG[] = {                               //  same as JLE
          'j', 'n', 'g', '\0',
                0x7e,         opnJb                + tEnd,
          0x0f, 0x8e,         opnJv                + tEnd + eEnd };

UCHAR szJNGE[] = {                              //  same as JNL
          'j', 'n', 'g', 'e', '\0',
                0x7c,         opnJb                + tEnd,
          0x0f, 0x8c,         opnJv                + tEnd + eEnd };

UCHAR szJNE[] = {                               //  same as JNZ
          'j', 'n', 'e', '\0',
                0x75,         opnJb                + tEnd,
          0x0f, 0x85,         opnJv                + tEnd + eEnd };

UCHAR szJNL[] = {                               //  same as JGE
          'j', 'n', 'l', '\0',
                0x7d,         opnJb                + tEnd,
          0x0f, 0x8d,         opnJv                + tEnd + eEnd };

UCHAR szJNLE[] = {                              //  same as JNG
          'j', 'n', 'l', 'e', '\0',
                0x7f,         opnJb                + tEnd,
          0x0f, 0x8f,         opnJv                + tEnd + eEnd };

UCHAR szJNO[] = {
          'j', 'n', 'o', '\0',
                0x71,         opnJb                + tEnd,
          0x0f, 0x81,         opnJv                + tEnd + eEnd };

UCHAR szJNP[] = {                               //  same as JPO
          'j', 'n', 'p', '\0',
                0x7b,         opnJb                + tEnd,
          0x0f, 0x8b,         opnJv                + tEnd + eEnd };

UCHAR szJNS[] = {
          'j', 'n', 's', '\0',
                0x79,         opnJb                + tEnd,
          0x0f, 0x89,         opnJv                + tEnd + eEnd };

UCHAR szJNZ[] = {                               //  same as JNE
          'j', 'n', 'z', '\0',
                0x75,         opnJb                + tEnd,
          0x0f, 0x85,         opnJv                + tEnd + eEnd };

UCHAR szJO[] = {
          'j', 'o', '\0',
                0x70,         opnJb                + tEnd,
          0x0f, 0x80,         opnJv                + tEnd + eEnd };

UCHAR szJP[] = {                                //  same as JPE
          'j', 'p', '\0',
                0x7a,         opnJb                + tEnd,
          0x0f, 0x8a,         opnJv                + tEnd + eEnd };

UCHAR szJPE[] = {                               //  same as JP
          'j', 'p', 'e', '\0',
                0x7a,         opnJb                + tEnd,
          0x0f, 0x8a,         opnJv                + tEnd + eEnd };

UCHAR szJPO[] = {                               //  same as JNP
          'j', 'p', 'o', '\0',
                0x7b,         opnJb                + tEnd,
          0x0f, 0x8b,         opnJv                + tEnd + eEnd };

UCHAR szJS[] = {
          'j', 's', '\0',
                0x78,         opnJb                + tEnd,
          0x0f, 0x88,         opnJv                + tEnd + eEnd };

UCHAR szJZ[] = {                                //  same as JE
          'j', 'z', '\0',
                0x74,         opnJb                + tEnd,
          0x0f, 0x84,         opnJv                + tEnd + eEnd };

UCHAR szLAHF[] = {
          'l', 'a', 'h', 'f', '\0',
                0x9f, asNone                       + tEnd + eEnd };

UCHAR szLAR[] = {
          'l', 'a', 'r', '\0',
          0x0f, 0x02,         opnGv,  opnEv        + tEnd + eEnd };

UCHAR szLDS[] = {
          'l', 'd', 's', '\0',
                0xc5,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLEA[] = {
          'l', 'e', 'a', '\0',
                0x8d,         opnGv,  opnM         + tEnd + eEnd };

UCHAR szLEAVE[] = {
          'l', 'e', 'a', 'v', 'e', '\0',
                0xc9, asNone                       + tEnd + eEnd };

UCHAR szLES[] = {
          'l', 'e', 's', '\0',
                0xc4,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLFS[] = {
          'l', 'f', 's', '\0',
          0x0f, 0xb4,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLGDT[] = {
          'l', 'g', 'd', 't', '\0',
          0x0f, 0x01, asReg2, opnMs                + tEnd + eEnd };

UCHAR szLGS[] = {
          'l', 'g', 's', '\0',
          0x0f, 0xb5,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLIDT[] = {
          'l', 'i', 'd', 't', '\0',
          0x0f, 0x01, asReg3, opnMs                + tEnd + eEnd };

UCHAR szLLDT[] = {
          'l', 'l', 'd', 't', '\0',
          0x0f, 0x00, asReg2, opnEw                + tEnd + eEnd };

UCHAR szLMSW[] = {
          'l', 'm', 's', 'w', '\0',
          0x0f, 0x01, asReg6, opnEw                + tEnd + eEnd };

UCHAR szLOCK[] = {
          'l', 'o', 'c', 'k', '\0',
                0xf0, asPrfx                       + tEnd + eEnd };

UCHAR szLODS[] = {
          'l', 'o', 'd', 's', '\0',
                0xac,         opnXb                + tEnd,
                0xad,         opnXv                + tEnd + eEnd };

UCHAR szLODSB[] = {
          'l', 'o', 'd', 's', 'b', '\0',
                0xac, asNone                       + tEnd + eEnd };

UCHAR szLODSD[] = {
          'l', 'o', 'd', 's', 'd', '\0',
                0xad, asSiz1                       + tEnd + eEnd };

UCHAR szLODSW[] = {
          'l', 'o', 'd', 's', 'w', '\0',
                0xad, asSiz0                       + tEnd + eEnd };

UCHAR szLOOP[] = {
          'l', 'o', 'o', 'p', '\0',
                0xe2,         opnJb                + tEnd + eEnd };

UCHAR szLOOPE[] = {                             //  same as LOOPZ
          'l', 'o', 'o', 'p', 'e', '\0',
                0xe1,         opnJb                + tEnd + eEnd };

UCHAR szLOOPNE[] = {                            //  same as LOOPNZ
          'l', 'o', 'o', 'p', 'n', 'e', '\0',
                0xe0,         opnJb                + tEnd + eEnd };

UCHAR szLOOPNZ[] = {                            //  same as LOOPNE
          'l', 'o', 'o', 'p', 'n', 'z', '\0',
                0xe0,         opnJb                + tEnd + eEnd };

UCHAR szLOOPZ[] = {                             //  same as LOOPE
          'l', 'o', 'o', 'p', 'z', '\0',
                0xe1,         opnJb                + tEnd + eEnd };

UCHAR szLSL[] = {
          'l', 's', 'l', '\0',
          0x0f, 0x03,         opnGv,  opnEv        + tEnd + eEnd };

UCHAR szLSS[] = {
          'l', 's', 's', '\0',
          0x0f, 0xb2,         opnGv,  opnMp        + tEnd + eEnd };

UCHAR szLTR[] = {
          'l', 't', 'r', '\0',
          0x0f, 0x00, asReg3, opnEw                + tEnd + eEnd };

UCHAR szMOV[] = {
          'm', 'o', 'v', '\0',
                0xa0,         opnAL,  opnOb        + tEnd,
                0xa1,         opneAX, opnOv        + tEnd,
                0xa2,         opnOb,  opnAL        + tEnd,
                0xa3,         opnOv,  opneAX       + tEnd,
                0x8a,         opnGb,  opnEb        + tEnd,
                0x8b,         opnGv,  opnEv        + tEnd,
                0x88,         opnEb,  opnGb        + tEnd,
                0x89,         opnEv,  opnGv        + tEnd,
                0x8c, asSiz0, opnEw,  opnSw        + tEnd,
                0x8e, asSiz0, opnSw,  opnEw        + tEnd,
                0xb0, asOpRg, opnGb,  opnIb        + tEnd,
                0xb8, asOpRg, opnGv,  opnIv        + tEnd,
                0xc6,         opnEb,  opnIb        + tEnd,
                0xc7,         opnEv,  opnIv        + tEnd,
          0x0f, 0x20,         opnRd,  opnCd        + tEnd,
          0x0f, 0x21,         opnRd,  opnDd        + tEnd,
          0x0f, 0x22,         opnCd,  opnRd        + tEnd,
          0x0f, 0x23,         opnDd,  opnRd        + tEnd,
          0x0f, 0x24,         opnRd,  opnTd        + tEnd,
          0x0f, 0x26,         opnTd,  opnRd        + tEnd + eEnd };

UCHAR szMOVS[] = {
          'm', 'o', 'v', 's', '\0',
                0xa4,         opnXb,   opnYb       + tEnd,
                0xa5,         opnXv,   opnYv       + tEnd + eEnd };

UCHAR szMOVSB[] = {
          'm', 'o', 'v', 's', 'b', '\0',
                0xa4, asNone                       + tEnd + eEnd };

UCHAR szMOVSD[] = {
          'm', 'o', 'v', 's', 'd', '\0',
                0xa5, asSiz1                       + tEnd + eEnd };

UCHAR szMOVSW[] = {
          'm', 'o', 'v', 's', 'w', '\0',
                0xa5, asSiz0                       + tEnd + eEnd };

UCHAR szMOVSX[] = {
          'm', 'o', 'v', 's', 'x', '\0',
          0x0f, 0xbe,         opnGv,  opnEb        + tEnd,
          0x0f, 0xbf,         opnGv,  opnEw        + tEnd + eEnd };

UCHAR szMOVZX[] = {
          'm', 'o', 'v', 'z', 'x', '\0',
          0x0f, 0xb6,         opnGv,  opnEb        + tEnd,
          0x0f, 0xb7,         opnGv,  opnEw        + tEnd + eEnd };

UCHAR szMUL[] = {
          'm', 'u', 'l', '\0',
                0xf6, asReg4, opnEb                + tEnd,
                0xf7, asReg4, opnEv                + tEnd,
                0xf6, asReg4, opnAL,  opnEb        + tEnd,
                0xf7, asReg4, opneAX, opnEv        + tEnd + eEnd };

UCHAR szNEG[] = {
          'n', 'e', 'g', '\0',
                0xf6, asReg3, opnEb                + tEnd,
                0xf7, asReg3, opnEv                + tEnd + eEnd };

UCHAR szNOP[] = {
          'n', 'o', 'p', '\0',
                0x90, asNone                       + tEnd };

UCHAR szNOT[] = {
          'n', 'o', 't', '\0',
                0xf6, asReg2, opnEb                + tEnd,
                0xf7, asReg2, opnEv                + tEnd + eEnd };

UCHAR szOR[] = {
          'o', 'r', '\0',
                0x0c,         opnAL,   opnIb       + tEnd,
                0x0d,         opneAX,  opnIv       + tEnd,
                0x80, asReg1, opnEb,   opnIb       + tEnd,
                0x83, asReg1, opnEv,   opnIb       + tEnd,
                0x81, asReg1, opnEv,   opnIv       + tEnd,
                0x08,         opnEb,   opnGb       + tEnd,
                0x09,         opnEv,   opnGv       + tEnd,
                0x0a,         opnGb,   opnEb       + tEnd,
                0x0b,         opnGv,   opnEv       + tEnd + eEnd };

UCHAR szOUT[] = {
          'o', 'u', 't', '\0',
                0xe6,         opnIb,   opnAL       + tEnd,
                0xe7,         opnIb,   opneAX      + tEnd,
                0xee,         opnDX,   opnAL       + tEnd,
                0xef,         opnDX,   opneAX      + tEnd + eEnd };

UCHAR szOUTS[] = {
          'o', 'u', 't', 's', '\0',
                0x6e,         opnDX,  opnYb        + tEnd,
                0x6f,         opnDX,  opnYv        + tEnd + eEnd };

UCHAR szOUTSB[] = {
          'o', 'u', 't', 's', 'b', '\0',
                0x6e, asNone                       + tEnd + eEnd };

UCHAR szOUTSD[] = {
          'o', 'u', 't', 's', 'd', '\0',
                0x6f, asSiz1                       + tEnd + eEnd };

UCHAR szOUTSW[] = {
          'o', 'u', 't', 's', 'w', '\0',
                0x6f, asSiz0                       + tEnd + eEnd };

UCHAR szPOP[] = {
          'p', 'o', 'p', '\0',
                0x58, asOpRg, opnGv                + tEnd,
                0x8f, asReg0, opnMv                + tEnd,
                0x1f,         opnSeg, segDS, asNone+ tEnd,
                0x07,         opnSeg, segES, asNone+ tEnd,
                0x17,         opnSeg, segSS, asNone+ tEnd,
          0x0f, 0xa1,         opnSeg, segFS, asNone+ tEnd,
          0x0f, 0xa9,         opnSeg, segGS, asNone+ tEnd + eEnd };

UCHAR szPOPA[] = {
          'p', 'o', 'p', 'a', '\0',
                0x61, asSiz0                       + tEnd + eEnd };

UCHAR szPOPAD[] = {
          'p', 'o', 'p', 'a', 'd', '\0',
                0x61, asSiz1                       + tEnd + eEnd };

UCHAR szPOPF[] = {
          'p', 'o', 'p', 'f', '\0',
                0x9d, asSiz0                       + tEnd + eEnd };

UCHAR szPOPFD[] = {
          'p', 'o', 'p', 'f', 'd', '\0',
                0x9d, asSiz1                       + tEnd + eEnd };

UCHAR szPUSH[] = {
          'p', 'u', 's', 'h', '\0',
                0x50, asOpRg, opnGv                + tEnd,
                0xff, asReg6, opnMv                + tEnd,
                0x6a,         opnIb                + tEnd,
                0x68,         opnIv                + tEnd,
                0x0e,         opnSeg, segCS, asNone+ tEnd,
                0x1e,         opnSeg, segDS, asNone+ tEnd,
                0x06,         opnSeg, segES, asNone+ tEnd,
                0x16,         opnSeg, segSS, asNone+ tEnd,
          0x0f, 0xa0,         opnSeg, segFS, asNone+ tEnd,
          0x0f, 0xa8,         opnSeg, segGS, asNone+ tEnd + eEnd };

UCHAR szPUSHA[] = {
          'p', 'u', 's', 'h', 'a', '\0',
                0x60, asSiz0                       + tEnd + eEnd };

UCHAR szPUSHAD[] = {
          'p', 'u', 's', 'h', 'a', 'd', '\0',
                0x60, asSiz1                       + tEnd + eEnd };

UCHAR szPUSHF[] = {
          'p', 'u', 's', 'h', 'f', '\0',
                0x9c, asSiz0                       + tEnd + eEnd };

UCHAR szPUSHFD[] = {
          'p', 'u', 's', 'h', 'f', 'd', '\0',
                0x9c, asSiz1                       + tEnd + eEnd };

UCHAR szRCL[] = {
          'r', 'c', 'l', '\0',
                0xd0, asReg2, opnEb,  opnIm1       + tEnd,
                0xd2, asReg2, opnEb,  opnCL        + tEnd,
                0xc0, asReg2, opnEb,  opnIb        + tEnd,
                0xd1, asReg2, opnEv,  opnIm1       + tEnd,
                0xd3, asReg2, opnEv,  opnCL        + tEnd,
                0xc1, asReg2, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szRCR[] = {
          'r', 'c', 'r', '\0',
                0xd0, asReg3, opnEb,  opnIm1       + tEnd,
                0xd2, asReg3, opnEb,  opnCL        + tEnd,
                0xc0, asReg3, opnEb,  opnIb        + tEnd,
                0xd1, asReg3, opnEv,  opnIm1       + tEnd,
                0xd3, asReg3, opnEv,  opnCL        + tEnd,
                0xc1, asReg3, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szRDMSR[] = {
          'r', 'd', 'm', 's', 'r', '\0',
                0x0f, 0x32, asNone                 + tEnd + eEnd };

UCHAR szRDTSC[] = {
          'r', 'd', 't', 's', 'c', '\0',
                0x0f, 0x31, asNone                 + tEnd + eEnd };

UCHAR szREP[] = {                               //  same as REPE, REPZ
          'r', 'e', 'p', '\0',
                0xf3, asPrfx                       + tEnd + eEnd };

UCHAR szREPE[] = {                              //  same as REP, REPZ
          'r', 'e', 'p', 'e', '\0',
                0xf3, asPrfx                       + tEnd + eEnd };

UCHAR szREPZ[] = {                              //  same as REP, REPE
          'r', 'e', 'p', 'z', '\0',
                0xf3, asPrfx                       + tEnd + eEnd };

UCHAR szREPNE[] = {                             //  same as REPNZ
          'r', 'e', 'p', 'n', 'e', '\0',
                0xf2, asPrfx                       + tEnd + eEnd };

UCHAR szREPNZ[] = {                             //  same as REPNE
          'r', 'e', 'p', 'n', 'z', '\0',
                0xf2, asPrfx                       + tEnd + eEnd };

UCHAR szRET[] = {                               //  same as RETN
          'r', 'e', 't', '\0',
                0xc3, asNone                       + tEnd,
                0xc2,         opnIw                + tEnd + eEnd };

UCHAR szRETF[] = {
          'r', 'e', 't', 'f', '\0',
                0xcb, asNone                       + tEnd,
                0xca,         opnIw                + tEnd + eEnd };

UCHAR szRETN[] = {                              //  same as RET
          'r', 'e', 't', 'n', '\0',
                0xc3, asNone                       + tEnd,
                0xc2,         opnIw                + tEnd + eEnd };

UCHAR szROL[] = {
          'r', 'o', 'l', '\0',
                0xd0, asReg0, opnEb,  opnIm1       + tEnd,
                0xd2, asReg0, opnEb,  opnCL        + tEnd,
                0xc0, asReg0, opnEb,  opnIb        + tEnd,
                0xd1, asReg0, opnEv,  opnIm1       + tEnd,
                0xd3, asReg0, opnEv,  opnCL        + tEnd,
                0xc1, asReg0, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szROR[] = {
          'r', 'o', 'r', '\0',
                0xd0, asReg1, opnEb,  opnIm1       + tEnd,
                0xd2, asReg1, opnEb,  opnCL        + tEnd,
                0xc0, asReg1, opnEb,  opnIb        + tEnd,
                0xd1, asReg1, opnEv,  opnIm1       + tEnd,
                0xd3, asReg1, opnEv,  opnCL        + tEnd,
                0xc1, asReg1, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szRSM[] = {
          'r', 's', 'm', '\0',
                0x0f, 0xaa, asNone                 + tEnd + eEnd };

UCHAR szSAHF[] = {
          's', 'a', 'h', 'f', '\0',
                0x9e, asNone                       + tEnd + eEnd };

UCHAR szSAL[] = {
          's', 'a', 'l', '\0',
                0xd0, asReg4, opnEb,  opnIm1       + tEnd,
                0xd2, asReg4, opnEb,  opnCL        + tEnd,
                0xc0, asReg4, opnEb,  opnIb        + tEnd,
                0xd1, asReg4, opnEv,  opnIm1       + tEnd,
                0xd3, asReg4, opnEv,  opnCL        + tEnd,
                0xc1, asReg4, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSAR[] = {
          's', 'a', 'r', '\0',
                0xd0, asReg7, opnEb,  opnIm1       + tEnd,
                0xd2, asReg7, opnEb,  opnCL        + tEnd,
                0xc0, asReg7, opnEb,  opnIb        + tEnd,
                0xd1, asReg7, opnEv,  opnIm1       + tEnd,
                0xd3, asReg7, opnEv,  opnCL        + tEnd,
                0xc1, asReg7, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSBB[] = {
          's', 'b', 'b', '\0',
                0x1c,         opnAL,   opnIb       + tEnd,
                0x1d,         opneAX,  opnIv       + tEnd,
                0x80, asReg3, opnEb,   opnIb       + tEnd,
                0x83, asReg3, opnEv,   opnIbe      + tEnd,
                0x81, asReg3, opnEv,   opnIv       + tEnd,
                0x18,         opnEb,   opnGb       + tEnd,
                0x19,         opnEv,   opnGv       + tEnd,
                0x1a,         opnGb,   opnEb       + tEnd,
                0x1b,         opnGv,   opnEv       + tEnd + eEnd };


UCHAR szSCAS[] = {
          's', 'c', 'a', 's', '\0',
                0xae,         opnYb                + tEnd,
                0xaf,         opnYv                + tEnd + eEnd };

UCHAR szSCASB[] = {
          's', 'c', 'a', 's', 'b', '\0',
                0xae, asNone                       + tEnd + eEnd };

UCHAR szSCASD[] = {
          's', 'c', 'a', 's', 'd', '\0',
                0xaf, asSiz1                       + tEnd + eEnd };

UCHAR szSCASW[] = {
          's', 'c', 'a', 's', 'w', '\0',
                0xaf, asSiz0                       + tEnd + eEnd };

UCHAR szSETA[] = {                              //  same as SETNBE
          's', 'e', 't', 'a', '\0',
          0x0f, 0x97,         opnEb                + tEnd + eEnd };

UCHAR szSETAE[] = {                             //  same as SETNB, SETNC
          's', 'e', 't', 'a', 'e', '\0',
          0x0f, 0x93,         opnEb                + tEnd + eEnd };

UCHAR szSETB[] = {                              //  same as SETC, SETNAE
          's', 'e', 't', 'b', '\0',
          0x0f, 0x92,         opnEb                + tEnd + eEnd };

UCHAR szSETBE[] = {                             //  same as SETNA
          's', 'e', 't', 'b', 'e', '\0',
          0x0f, 0x96,         opnEb                + tEnd + eEnd };

UCHAR szSETC[] = {                              //  same as SETB, SETNAE
          's', 'e', 't', 'c', '\0',
          0x0f, 0x92,         opnEb                + tEnd + eEnd };

UCHAR szSETE[] = {                              //  same as SETZ
          's', 'e', 't', 'e', '\0',
          0x0f, 0x94,         opnEb                + tEnd + eEnd };

UCHAR szSETG[] = {                              //  same as SETNLE
          's', 'e', 't', 'g', '\0',
          0x0f, 0x9f,         opnEb                + tEnd + eEnd };

UCHAR szSETGE[] = {                             //  same as SETNL
          's', 'e', 't', 'g', 'e', '\0',
          0x0f, 0x9d,         opnEb                + tEnd + eEnd };

UCHAR szSETL[] = {                              //  same as SETNGE
          's', 'e', 't', 'l', '\0',
          0x0f, 0x9c,         opnEb                + tEnd + eEnd };

UCHAR szSETLE[] = {                             //  same as SETNG
          's', 'e', 't', 'l', 'e', '\0',
          0x0f, 0x9e,         opnEb                + tEnd + eEnd };

UCHAR szSETNA[] = {                             //  same as SETBE
          's', 'e', 't', 'n', 'a', '\0',
          0x0f, 0x96,         opnEb                + tEnd + eEnd };

UCHAR szSETNAE[] = {                            //  same as SETB, SETC
          's', 'e', 't', 'n', 'a', 'e', '\0',
          0x0f, 0x92,         opnEb                + tEnd + eEnd };

UCHAR szSETNB[] = {                             //  same as SETAE, SETNC
          's', 'e', 't', 'n', 'b', '\0',
          0x0f, 0x93,         opnEb                + tEnd + eEnd };

UCHAR szSETNBE[] = {                            //  same as SETA
          's', 'e', 't', 'n', 'b', 'e', '\0',
          0x0f, 0x97,         opnEb                + tEnd + eEnd };

UCHAR szSETNC[] = {                             //  same as SETAE, SETNC
          's', 'e', 't', 'n', 'c', '\0',
          0x0f, 0x93,         opnEb                + tEnd + eEnd };

UCHAR szSETNE[] = {                             //  same as SETNZ
          's', 'e', 't', 'n', 'e', '\0',
          0x0f, 0x95,         opnEb                + tEnd + eEnd };

UCHAR szSETNG[] = {                             //  same as SETLE
          's', 'e', 't', 'n', 'g', '\0',
          0x0f, 0x9e,         opnEb                + tEnd + eEnd };

UCHAR szSETNGE[] = {                            //  same as SETL
          's', 'e', 't', 'n', 'g', 'e', '\0',
          0x0f, 0x9c,         opnEb                + tEnd + eEnd };

UCHAR szSETNL[] = {                             //  same as SETGE
          's', 'e', 't', 'n', 'l', '\0',
          0x0f, 0x9d,         opnEb                + tEnd + eEnd };

UCHAR szSETNLE[] = {                            //  same as SETG
          's', 'e', 't', 'n', 'l', 'e', '\0',
          0x0f, 0x9f,         opnEb                + tEnd + eEnd };

UCHAR szSETNO[] = {
          's', 'e', 't', 'n', 'o', '\0',
          0x0f, 0x91,         opnEb                + tEnd + eEnd };

UCHAR szSETNP[] = {                             //  same as SETPO
          's', 'e', 't', 'n', 'p', '\0',
          0x0f, 0x9b,         opnEb                + tEnd + eEnd };

UCHAR szSETNS[] = {
          's', 'e', 't', 'n', 's', '\0',
          0x0f, 0x99,         opnEb                + tEnd + eEnd };

UCHAR szSETNZ[] = {                             //  same as SETNE
          's', 'e', 't', 'n', 'z', '\0',
          0x0f, 0x95,         opnEb                + tEnd + eEnd };

UCHAR szSETO[] = {
          's', 'e', 't', 'o', '\0',
          0x0f, 0x90,         opnEb                + tEnd + eEnd };

UCHAR szSETP[] = {                              //  same as SETPE
          's', 'e', 't', 'p', '\0',
          0x0f, 0x9a,         opnEb                + tEnd + eEnd };

UCHAR szSETPE[] = {                             //  same as SETP
          's', 'e', 't', 'p', 'e', '\0',
          0x0f, 0x9a,         opnEb                + tEnd + eEnd };

UCHAR szSETPO[] = {                             //  same as SETNP
          's', 'e', 't', 'p', 'o', '\0',
          0x0f, 0x9b,         opnEb                + tEnd + eEnd };

UCHAR szSETS[] = {
          's', 'e', 't', 's', '\0',
          0x0f, 0x98,         opnEb                + tEnd + eEnd };

UCHAR szSETZ[] = {                              //  same as SETE
          's', 'e', 't', 'z', '\0',
          0x0f, 0x94,         opnEb                + tEnd + eEnd };

UCHAR szSGDT[] = {
          's', 'g', 'd', 't', '\0',
          0x0f, 0x01, asReg0, opnMs                + tEnd + eEnd };

UCHAR szSHL[] = {
          's', 'h', 'l', '\0',
                0xd0, asReg4, opnEb,  opnIm1       + tEnd,
                0xd2, asReg4, opnEb,  opnCL        + tEnd,
                0xc0, asReg4, opnEb,  opnIb        + tEnd,
                0xd1, asReg4, opnEv,  opnIm1       + tEnd,
                0xd3, asReg4, opnEv,  opnCL        + tEnd,
                0xc1, asReg4, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSHLD[] = {
          's', 'h', 'l', 'd', '\0',
          0x0f, 0xa4,         opnEv,  opnGv, opnIb + tEnd,
          0x0f, 0xa5,         opnEv,  opnGv, opnCL + tEnd + eEnd };

UCHAR szSHR[] = {
          's', 'h', 'r', '\0',
                0xd0, asReg5, opnEb,  opnIm1       + tEnd,
                0xd2, asReg5, opnEb,  opnCL        + tEnd,
                0xc0, asReg5, opnEb,  opnIb        + tEnd,
                0xd1, asReg5, opnEv,  opnIm1       + tEnd,
                0xd3, asReg5, opnEv,  opnCL        + tEnd,
                0xc1, asReg5, opnEv,  opnIb        + tEnd + eEnd };

UCHAR szSHRD[] = {
          's', 'h', 'r', 'd', '\0',
          0x0f, 0xac,         opnEv,  opnGv, opnIb + tEnd,
          0x0f, 0xad,         opnEv,  opnGv, opnCL + tEnd + eEnd };

UCHAR szSIDT[] = {
          's', 'i', 'd', 't', '\0',
          0x0f, 0x01, asReg1, opnMs                + tEnd + eEnd };

UCHAR szSLDT[] = {
          's', 'l', 'd', 't', '\0',
          0x0f, 0x00, asReg0, opnEw                + tEnd + eEnd };

UCHAR szSMSW[] = {
          's', 'm', 's', 'w', '\0',
          0x0f, 0x01, asReg4, opnEw                + tEnd + eEnd };

UCHAR szSS[] = {
          's', 's', ':', '\0',
                0x26, asPrfx                       + tEnd + eEnd };

UCHAR szSTC[] = {
          's', 't', 'c', '\0',
                0xf9, asNone                       + tEnd + eEnd };

UCHAR szSTD[] = {
          's', 't', 'd', '\0',
                0xfd, asNone                       + tEnd + eEnd };

UCHAR szSTI[] = {
          's', 't', 'i', '\0',
                0xfb, asNone                       + tEnd + eEnd };

UCHAR szSTOS[] = {
          's', 't', 'o', 's', '\0',
                0xaa,         opnYb                + tEnd,
                0xab,         opnYv                + tEnd + eEnd };

UCHAR szSTOSB[] = {
          's', 't', 'o', 's', 'b', '\0',
                0xaa, asNone                       + tEnd + eEnd };

UCHAR szSTOSD[] = {
          's', 't', 'o', 's', 'd', '\0',
                0xab, asSiz1                       + tEnd + eEnd };

UCHAR szSTOSW[] = {
          's', 't', 'o', 's', 'w', '\0',
                0xab, asSiz0                       + tEnd + eEnd };

UCHAR szSTR[] = {
          's', 't', 'r', '\0',
          0x0f, 0x00, asReg1, opnEw                + tEnd + eEnd };

UCHAR szSUB[] = {
          's', 'u', 'b', '\0',
                0x2c,         opnAL,  opnIb        + tEnd,
                0x2d,         opneAX, opnIv        + tEnd,
                0x80, asReg5, opnEb,  opnIb        + tEnd,
                0x83, asReg5, opnEv,  opnIbe       + tEnd,
                0x81, asReg5, opnEv,  opnIv        + tEnd,
                0x28,         opnEb,  opnGb        + tEnd,
                0x29,         opnEv,  opnGv        + tEnd,
                0x2a,         opnGb,  opnEb        + tEnd,
                0x2b,         opnGv,  opnEv        + tEnd + eEnd };

UCHAR szTEST[] = {
          't', 'e', 's', 't', '\0',
                0xa8,         opnAL,  opnIb        + tEnd,
                0xa9,         opneAX, opnIv        + tEnd,
                0xf6, asReg0, opnEb,  opnIb        + tEnd,
                0xf7, asReg0, opnEv,  opnIv        + tEnd,
                0x84,         opnEb,  opnGb        + tEnd,
                0x85,         opnEv,  opnGv        + tEnd + eEnd };

UCHAR szVERR[] = {
          'v', 'e', 'r', 'r', '\0',
          0x0f, 0x00, asReg4, opnEw               + tEnd + eEnd };

UCHAR szVERW[] = {
          'v', 'e', 'r', 'w', '\0',
          0x0f, 0x00, asReg5, opnEw               + tEnd + eEnd };

UCHAR szWAIT[] = {                              //  same as FWAIT
          'w', 'a', 'i', 't', '\0',
          0x9b,       asPrfx                      + tEnd + eEnd };

UCHAR szWBINVD[] = {
          'w', 'b', 'i', 'n', 'v', 'd', '\0',
          0x0f, 0x09, asNone                      + tEnd + eEnd };

UCHAR szWRMSR[] = {
          'w', 'r', 'm', 's', 'r', '\0',
          0x0f, 0x30, asNone                      + tEnd + eEnd };


UCHAR szXADD[] = {
          'x', 'a', 'd', 'd', '\0',
          0x0f, 0xc0,         opnEb,  opnGb        + tEnd,
          0x0f, 0xc1,         opnEv,  opnGv        + tEnd + eEnd };

UCHAR szXCHG[] = {
          'x', 'c', 'h', 'g', '\0',
                0x90, asOpRg, opneAX, opnGv        + tEnd,
                0x90, asOpRg, opnGv,  opneAX       + tEnd,
                0x86,         opnGb,  opnEb        + tEnd,
                0x86,         opnEb,  opnGb        + tEnd,
                0x87,         opnGv,  opnEv        + tEnd,
                0x87,         opnEv,  opnGv        + tEnd + eEnd };

UCHAR szXLAT[] = {
          'x', 'l', 'a', 't', '\0',
                0xd7, asNone                       + tEnd,
                0xd7, asSeg,  opnM                 + tEnd + eEnd };

UCHAR szXOR[] = {
          'x', 'o', 'r', '\0',
                0x34,         opnAL,  opnIb        + tEnd,
                0x35,         opneAX, opnIv        + tEnd,
                0x80, asReg6, opnEb,  opnIb        + tEnd,
                0x83, asReg6, opnEv,  opnIb        + tEnd,
                0x81, asReg6, opnEv,  opnIv        + tEnd,
                0x30,         opnEb,  opnGb        + tEnd,
                0x31,         opnEv,  opnGv        + tEnd,
                0x32,         opnGb,  opnEb        + tEnd,
                0x33,         opnGv,  opnEv        + tEnd + eEnd };

PUCHAR OpTable[] = {
    szAAA,     szAAD,     szAAM,     szAAS,     szADC,     szADD,
    szAND,     szARPL,    szBOUND,   szBSF,     szBSR,     szBSWAP,
    szBT,      szBTC,     szBTR,     szBTS,     szCALL,    szCBW,
    szCDQ,     szCLC,     szCLD,     szCLI,     szCLTS,    szCMC,
    szCMP,     szCMPS,    szCMPSB,   szCMPSD,   szCMPSW,   szCMPXCHG,
    szCMPXCHG8B, szCPUID, szCS,      szCWD,     szCWDE,    szDAA,
    szDAS,     szDEC,     szDIV,     szDS,      szENTER,   szES,
    szF2XM1,   szFABS,    szFADD,    szFADDP,   szFBLD,    szFBSTP,
    szFCHS,    szFCLEX,   szFCOM,    szFCOMP,   szFCOMPP,  szFCOS,
    szFDECSTP, szFDISI,   szFDIV,    szFDIVP,   szFDIVR,   szFDIVRP,
    szFENI,    szFFREE,   szFIADD,   szFICOM,   szFICOMP,  szFIDIV,
    szFIDIVR,  szFILD,    szFIMUL,   szFINCSTP, szFINIT,   szFIST,
    szFISTP,   szFISUB,   szFISUBR,  szFLD,     szFLD1,    szFLDCW,
    szFLDENV,  szFLDL2E,  szFLDL2T,  szFLDLG2,  szFLDLN2,  szFLDPI,
    szFLDZ,    szFMUL,    szFMULP,   szFNCLEX,  szFNDISI,  szFNENI,
    szFNINIT,  szFNOP,    szFNSAVE,  szFNSTCW,  szFNSTENV, szFNSTSW,
    szFPATAN,  szFPREM,   szFPREM1,  szFPTAN,   szFRNDINT, szFRSTOR,
    szFS,      szFSAVE,   szFSCALE,  szFSETPM,  szFSIN,    szFSINCOS,
    szFSQRT,   szFST,     szFSTCW,   szFSTENV,  szFSTP,    szFSTSW,
    szFSUB,    szFSUBP,   szFSUBR,   szFSUBRP,  szFTST,    szFUCOM,
    szFUCOMP,  szFUCOMPP, szFWAIT,   szFXAM,    szFXCH,    szFXTRACT,
    szFYL2X,   szFYL2XP1, szGS,      szHLT,     szIDIV,    szIMUL,
    szIN,      szINC,     szINS,     szINSB,    szINSD,    szINSW,
    szINT,     szINTO,    szINVD,    szINVLPG,  szIRET,    szIRETD,
    szJA,      szJAE,     szJB,      szJBE,     szJC,      szJCXZ,
    szJE,      szJECXZ,   szJG,      szJGE,     szJL,      szJLE,
    szJMP,     szJNA,     szJNAE,    szJNB,     szJNBE,    szJNC,
    szJNE,     szJNG,     szJNGE,    szJNL,     szJNLE,    szJNO,
    szJNP,     szJNS,     szJNZ,     szJO,      szJP,      szJPE,
    szJPO,     szJS,      szJZ,      szLAHF,    szLAR,     szLDS,
    szLEA,     szLEAVE,   szLES,     szLFS,     szLGDT,    szLGS,
    szLIDT,    szLLDT,    szLMSW,    szLOCK,    szLODS,    szLODSB,
    szLODSD,   szLODSW,   szLOOP,    szLOOPE,   szLOOPNE,  szLOOPNZ,
    szLOOPZ,   szLSL,     szLSS,     szLTR,     szMOV,     szMOVS,
    szMOVSB,   szMOVSD,   szMOVSW,   szMOVSX,   szMOVZX,   szMUL,
    szNEG,     szNOP,     szNOT,     szOR,      szOUT,     szOUTS,
    szOUTSB,   szOUTSD,   szOUTSW,   szPOP,     szPOPA,    szPOPAD,
    szPOPF,    szPOPFD,   szPUSH,    szPUSHA,   szPUSHAD,  szPUSHF,
    szPUSHFD,  szRCL,     szRCR,     szRDMSR,   szRDTSC,   szREP,
    szREPE,    szREPNE,   szREPNZ,   szREPZ,    szRET,     szRETF,
    szRETN,    szROL,     szROR,     szRSM,     szSAHF,    szSAL,
    szSAR,     szSBB,     szSCAS,    szSCASB,   szSCASD,   szSCASW,
    szSETA,    szSETAE,   szSETB,    szSETBE,   szSETC,    szSETE,
    szSETG,    szSETGE,   szSETL,    szSETLE,   szSETNA,   szSETNAE,
    szSETNB,   szSETNBE,  szSETNC,   szSETNE,   szSETNG,   szSETNGE,
    szSETNL,   szSETNLE,  szSETNO,   szSETNP,   szSETNS,   szSETNZ,
    szSETO,    szSETP,    szSETPE,   szSETPO,   szSETS,    szSETZ,
    szSGDT,    szSHL,     szSHLD,    szSHR,     szSHRD,    szSIDT,
    szSLDT,    szSMSW,    szSS,      szSTC,     szSTD,     szSTI,
    szSTOS,    szSTOSB,   szSTOSD,   szSTOSW,   szSTR,     szSUB,
    szTEST,    szVERR,    szVERW,    szWAIT,    szWBINVD,  szWRMSR,
    szXADD,    szXCHG,    szXLAT,    szXOR
  };

#define OPTABLESIZE (sizeof(OpTable) / sizeof(PUCHAR))


/*** X86SearchOpcode - search for opcode
*
*   Purpose:
*       Search the opcode table for a match with the string
*       pointed by *pszOp.
*
*   Input:
*       *pszOp - string to search as opcode
*
*   Returns:
*       if not -1, index of match entry in opcode table
*       if -1, not found
*
*************************************************************************/

PUCHAR X86SearchOpcode (PUCHAR pszop)
{
    LONG   low = 0;
    LONG   mid;
    LONG   high = OPTABLESIZE - 1;
    LONG   match;

    while (low <= high) {
        mid = (low + high) / 2;
        match = (ULONG)strcmp((char *)pszop, (char *)OpTable[mid]);
        if (match == -1)
            high = mid - 1;
        else if (match == 1)
            low = mid + 1;
        else
            return OpTable[mid] + strlen((char *)OpTable[mid]) + 1;
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_reg.h ===
//
// Register bit constants.
//

#define X86_CR4_DEBUG_EXTENSIONS 0x8

#define X86_DR6_BREAK_03 0xf
#define X86_DR6_SINGLE_STEP 0x4000

#define X86_DR7_LOCAL_EXACT_ENABLE 0x100
#define X86_DR7_LEN0_SHIFT 18
#define X86_DR7_RW0_EXECUTE    0x00000
#define X86_DR7_RW0_WRITE      0x10000
#define X86_DR7_RW0_IO         0x20000
#define X86_DR7_RW0_READ_WRITE 0x30000
#define X86_DR7_L0_ENABLE 0x1
#define X86_DR7_ALL_ENABLES 0xff
// All control bits used by breaks 0-3.
#define X86_DR7_CTRL_03_MASK ((ULONG)0xffff00ff)

#define X86_IS_VM86(x) ((unsigned short)(((x) >> 17) & 1))

#define X86_BIT_FLAGOF (1 << 11)
#define X86_BIT_FLAGDF (1 << 10)
#define X86_BIT_FLAGIF (1 << 9)
#define X86_BIT_FLAGTF (1 << 8)
#define X86_BIT_FLAGSF (1 << 7)
#define X86_BIT_FLAGZF (1 << 6)
#define X86_BIT_FLAGAF (1 << 4)
#define X86_BIT_FLAGPF (1 << 2)
#define X86_BIT_FLAGCF (1 << 0)
#define X86_BIT_FLAGVIP (1 << 20)
#define X86_BIT_FLAGVIF (1 << 19)
#define X86_BIT_FLAGIOPL 3
#define X86_SHIFT_FLAGIOPL 12

//
// MSRs and their bits.
//

#define X86_MSR_DEBUG_CTL 0x1d9

#define X86_DEBUG_CTL_LAST_BRANCH_RECORD 0x0001
#define X86_DEBUG_CTL_BRANCH_TRACE       0x0002

// P6 core last-branch MSRs.
#define X86_MSR_LAST_BRANCH_FROM_IP 0x1db
#define X86_MSR_LAST_BRANCH_TO_IP 0x1dc
#define X86_MSR_LAST_EXCEPTION_FROM_IP 0x1dd
#define X86_MSR_LAST_EXCEPTION_TO_IP 0x1de

// PIV core last-branch MSRs.  These are mostly
// the same as the P6 but are interpreted differently.
#define X86_MSR_LAST_BRANCH_TOS 0x1da
#define X86_MSR_LAST_BRANCH_0 0x1db

//
// Native register values.  These register values are shared
// between plain X86 and AMD64.  In IA32 intregs have 32-bit values,
// in AMD64 they have 64-bit values.
// Logically they are the same register, though, and the shared
// disassembler uses them.
//

// 32/64 bit.
#define X86_NAX         1
#define X86_NBX         2
#define X86_NCX         3
#define X86_NDX         4
#define X86_NSI         5
#define X86_NDI         6
#define X86_NSP         7
#define X86_NBP         8
#define X86_NIP         9

// 32 bit.
#define X86_NFL         10

// 16 bit.  These must be a group of consecutive values.
#define X86_NCS         11
#define X86_NDS         12
#define X86_NES         13
#define X86_NFS         14
#define X86_NGS         15
#define X86_NSS         16

#define X86_NSEG_FIRST X86_NCS
#define X86_NSEG_LAST  X86_NSS

//
// IA32 definitions.
//

#define X86_GS          X86_NGS
#define X86_FS          X86_NFS
#define X86_ES          X86_NES
#define X86_DS          X86_NDS
#define X86_EDI         X86_NDI
#define X86_ESI         X86_NSI
#define X86_EBX         X86_NBX
#define X86_EDX         X86_NDX
#define X86_ECX         X86_NCX
#define X86_EAX         X86_NAX
#define X86_EBP         X86_NBP
#define X86_EIP         X86_NIP
#define X86_CS          X86_NCS
#define X86_EFL         X86_NFL
#define X86_ESP         X86_NSP
#define X86_SS          X86_NSS

#define X86_CR0         17
#define X86_CR2         18
#define X86_CR3         19
#define X86_CR4         20

#define X86_DR0         21
#define X86_DR1         22
#define X86_DR2         23
#define X86_DR3         24
#define X86_DR6         25
#define X86_DR7         26

#define X86_GDTR        27
#define X86_GDTL        28
#define X86_IDTR        29
#define X86_IDTL        30
#define X86_TR          31
#define X86_LDTR        32

// SSE registers:
#define X86_MXCSR       50

#define X86_XMM0        51
#define X86_XMM1        52
#define X86_XMM2        53
#define X86_XMM3        54
#define X86_XMM4        55
#define X86_XMM5        56
#define X86_XMM6        57
#define X86_XMM7        58

#define X86_XMM_FIRST   X86_XMM0
#define X86_XMM_LAST    X86_XMM7

// Floating-point registers:
#define X86_FPCW        60
#define X86_FPSW        61
#define X86_FPTW        62

#define X86_ST0         70
#define X86_ST1         71
#define X86_ST2         72
#define X86_ST3         73
#define X86_ST4         74
#define X86_ST5         75
#define X86_ST6         76
#define X86_ST7         77

#define X86_ST_FIRST    X86_ST0
#define X86_ST_LAST     X86_ST7

// MMX registers:
#define X86_MM0         80
#define X86_MM1         81
#define X86_MM2         82
#define X86_MM3         83
#define X86_MM4         84
#define X86_MM5         85
#define X86_MM6         86
#define X86_MM7         87

#define X86_MM_FIRST    X86_MM0
#define X86_MM_LAST     X86_MM7

#define X86_FLAGBASE    100
#define X86_DI          100
#define X86_SI          101
#define X86_BX          102
#define X86_DX          103
#define X86_CX          104
#define X86_AX          105
#define X86_BP          106
#define X86_IP          107
#define X86_FL          108
#define X86_SP          109
#define X86_BL          110
#define X86_DL          111
#define X86_CL          112
#define X86_AL          113
#define X86_BH          114
#define X86_DH          115
#define X86_CH          116
#define X86_AH          117
#define X86_IOPL        118
#define X86_OF          119
#define X86_DF          120
#define X86_IF          121
#define X86_TF          122
#define X86_SF          123
#define X86_ZF          124
#define X86_AF          125
#define X86_PF          126
#define X86_CF          127
#define X86_VIP         128
#define X86_VIF         129
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ia64_asm.cpp ===
//----------------------------------------------------------------------------
//
// Assemble IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

void
Ia64MachineInfo::Assemble(ProcessInfo* Process, PADDR paddr, PSTR pchInput)
{
    // Not going to implement assemble command at this time
    ErrOut("No assemble support for IA64\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_reg.cpp ===
//----------------------------------------------------------------------------
//
// Register portions of X86 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

BOOL g_X86InCode16;
BOOL g_X86InVm86;

#define REGALL_SEGREG   REGALL_EXTRA0
#define REGALL_MMXREG   REGALL_EXTRA1
#define REGALL_DREG     REGALL_EXTRA2

REGALLDESC g_X86AllExtraDesc[] =
{
    REGALL_SEGREG, "Segment registers",
    REGALL_MMXREG, "MMX registers",
    REGALL_DREG,   "Debug registers and, in kernel, CR4",
    REGALL_XMMREG, "SSE XMM registers",
    0,             NULL,
};

#define REGALL_CREG     REGALL_EXTRA4
#define REGALL_DESC     REGALL_EXTRA5
REGALLDESC g_X86KernelExtraDesc[] =
{
    REGALL_CREG,   "CR0, CR2 and CR3",
    REGALL_DESC,   "Descriptor and task state",
    0,             NULL,
};

char g_Gs[]    = "gs";
char g_Fs[]    = "fs";
char g_Es[]    = "es";
char g_Ds[]    = "ds";
char g_Edi[]   = "edi";
char g_Esi[]   = "esi";
char g_Ebx[]   = "ebx";
char g_Edx[]   = "edx";
char g_Ecx[]   = "ecx";
char g_Eax[]   = "eax";
char g_Ebp[]   = "ebp";
char g_Eip[]   = "eip";
char g_Cs[]    = "cs";
char g_Efl[]   = "efl";
char g_Esp[]   = "esp";
char g_Ss[]    = "ss";
char g_Dr0[]   = "dr0";
char g_Dr1[]   = "dr1";
char g_Dr2[]   = "dr2";
char g_Dr3[]   = "dr3";
char g_Dr6[]   = "dr6";
char g_Dr7[]   = "dr7";
char g_Cr0[]   = "cr0";
char g_Cr2[]   = "cr2";
char g_Cr3[]   = "cr3";
char g_Cr4[]   = "cr4";
char g_Gdtr[]  = "gdtr";
char g_Gdtl[]  = "gdtl";
char g_Idtr[]  = "idtr";
char g_Idtl[]  = "idtl";
char g_Tr[]    = "tr";
char g_Ldtr[]  = "ldtr";
char g_Di[]    = "di";
char g_Si[]    = "si";
char g_Bx[]    = "bx";
char g_Dx[]    = "dx";
char g_Cx[]    = "cx";
char g_Ax[]    = "ax";
char g_Bp[]    = "bp";
char g_Ip[]    = "ip";
char g_Fl[]    = "fl";
char g_Sp[]    = "sp";
char g_Bl[]    = "bl";
char g_Dl[]    = "dl";
char g_Cl[]    = "cl";
char g_Al[]    = "al";
char g_Bh[]    = "bh";
char g_Dh[]    = "dh";
char g_Ch[]    = "ch";
char g_Ah[]    = "ah";
char g_Iopl[] = "iopl";
char g_Of[]   = "of";
char g_Df[]   = "df";
char g_If[]   = "if";
char g_Tf[]   = "tf";
char g_Sf[]   = "sf";
char g_Zf[]   = "zf";
char g_Af[]   = "af";
char g_Pf[]   = "pf";
char g_Cf[]   = "cf";
char g_Vip[]  = "vip";
char g_Vif[]  = "vif";

char g_Fpcw[]  = "fpcw";
char g_Fpsw[]  = "fpsw";
char g_Fptw[]  = "fptw";
char g_St0[]   = "st0";
char g_St1[]   = "st1";
char g_St2[]   = "st2";
char g_St3[]   = "st3";
char g_St4[]   = "st4";
char g_St5[]   = "st5";
char g_St6[]   = "st6";
char g_St7[]   = "st7";

char g_Mm0[]   = "mm0";
char g_Mm1[]   = "mm1";
char g_Mm2[]   = "mm2";
char g_Mm3[]   = "mm3";
char g_Mm4[]   = "mm4";
char g_Mm5[]   = "mm5";
char g_Mm6[]   = "mm6";
char g_Mm7[]   = "mm7";

char g_Mxcsr[] = "mxcsr";
char g_Xmm0[]  = "xmm0";
char g_Xmm1[]  = "xmm1";
char g_Xmm2[]  = "xmm2";
char g_Xmm3[]  = "xmm3";
char g_Xmm4[]  = "xmm4";
char g_Xmm5[]  = "xmm5";
char g_Xmm6[]  = "xmm6";
char g_Xmm7[]  = "xmm7";

REGDEF g_X86Defs[] =
{
    { g_Gs,    X86_GS   },
    { g_Fs,    X86_FS   },
    { g_Es,    X86_ES   },
    { g_Ds,    X86_DS   },
    { g_Edi,   X86_EDI  },
    { g_Esi,   X86_ESI  },
    { g_Ebx,   X86_EBX  },
    { g_Edx,   X86_EDX  },
    { g_Ecx,   X86_ECX  },
    { g_Eax,   X86_EAX  },
    { g_Ebp,   X86_EBP  },
    { g_Eip,   X86_EIP  },
    { g_Cs,    X86_CS   },
    { g_Efl,   X86_EFL  },
    { g_Esp,   X86_ESP  },
    { g_Ss,    X86_SS   },
    { g_Dr0,   X86_DR0  },
    { g_Dr1,   X86_DR1  },
    { g_Dr2,   X86_DR2  },
    { g_Dr3,   X86_DR3  },
    { g_Dr6,   X86_DR6  },
    { g_Dr7,   X86_DR7  },
    { g_Di,    X86_DI   },
    { g_Si,    X86_SI   },
    { g_Bx,    X86_BX   },
    { g_Dx,    X86_DX   },
    { g_Cx,    X86_CX   },
    { g_Ax,    X86_AX   },
    { g_Bp,    X86_BP   },
    { g_Ip,    X86_IP   },
    { g_Fl,    X86_FL   },
    { g_Sp,    X86_SP   },
    { g_Bl,    X86_BL   },
    { g_Dl,    X86_DL   },
    { g_Cl,    X86_CL   },
    { g_Al,    X86_AL   },
    { g_Bh,    X86_BH   },
    { g_Dh,    X86_DH   },
    { g_Ch,    X86_CH   },
    { g_Ah,    X86_AH   },
    { g_Fpcw,  X86_FPCW },
    { g_Fpsw,  X86_FPSW },
    { g_Fptw,  X86_FPTW },
    { g_St0,   X86_ST0  },
    { g_St1,   X86_ST1  },
    { g_St2,   X86_ST2  },
    { g_St3,   X86_ST3  },
    { g_St4,   X86_ST4  },
    { g_St5,   X86_ST5  },
    { g_St6,   X86_ST6  },
    { g_St7,   X86_ST7  },
    { g_Mm0,   X86_MM0  },
    { g_Mm1,   X86_MM1  },
    { g_Mm2,   X86_MM2  },
    { g_Mm3,   X86_MM3  },
    { g_Mm4,   X86_MM4  },
    { g_Mm5,   X86_MM5  },
    { g_Mm6,   X86_MM6  },
    { g_Mm7,   X86_MM7  },
    { g_Mxcsr, X86_MXCSR},
    { g_Xmm0,  X86_XMM0 },
    { g_Xmm1,  X86_XMM1 },
    { g_Xmm2,  X86_XMM2 },
    { g_Xmm3,  X86_XMM3 },
    { g_Xmm4,  X86_XMM4 },
    { g_Xmm5,  X86_XMM5 },
    { g_Xmm6,  X86_XMM6 },
    { g_Xmm7,  X86_XMM7 },
    { g_Iopl,  X86_IOPL },
    { g_Of,    X86_OF   },
    { g_Df,    X86_DF   },
    { g_If,    X86_IF   },
    { g_Tf,    X86_TF   },
    { g_Sf,    X86_SF   },
    { g_Zf,    X86_ZF   },
    { g_Af,    X86_AF   },
    { g_Pf,    X86_PF   },
    { g_Cf,    X86_CF   },
    { g_Vip,   X86_VIP  },
    { g_Vif,   X86_VIF  },
    { NULL,    REG_ERROR },
};

REGDEF g_X86KernelReg[] =
{
    { g_Cr0,   X86_CR0  },
    { g_Cr2,   X86_CR2  },
    { g_Cr3,   X86_CR3  },
    { g_Cr4,   X86_CR4  },
    { g_Gdtr,  X86_GDTR },
    { g_Gdtl,  X86_GDTL },
    { g_Idtr,  X86_IDTR },
    { g_Idtl,  X86_IDTL },
    { g_Tr,    X86_TR   },
    { g_Ldtr,  X86_LDTR },
    { NULL,    REG_ERROR },
};

REGSUBDEF g_X86SubDefs[] =
{
    { X86_DI,    X86_EDI, 0, 0xffff }, //  DI register
    { X86_SI,    X86_ESI, 0, 0xffff }, //  SI register
    { X86_BX,    X86_EBX, 0, 0xffff }, //  BX register
    { X86_DX,    X86_EDX, 0, 0xffff }, //  DX register
    { X86_CX,    X86_ECX, 0, 0xffff }, //  CX register
    { X86_AX,    X86_EAX, 0, 0xffff }, //  AX register
    { X86_BP,    X86_EBP, 0, 0xffff }, //  BP register
    { X86_IP,    X86_EIP, 0, 0xffff }, //  IP register
    { X86_FL,    X86_EFL, 0, 0xffff }, //  FL register
    { X86_SP,    X86_ESP, 0, 0xffff }, //  SP register
    { X86_BL,    X86_EBX, 0,   0xff }, //  BL register
    { X86_DL,    X86_EDX, 0,   0xff }, //  DL register
    { X86_CL,    X86_ECX, 0,   0xff }, //  CL register
    { X86_AL,    X86_EAX, 0,   0xff }, //  AL register
    { X86_BH,    X86_EBX, 8,   0xff }, //  BH register
    { X86_DH,    X86_EDX, 8,   0xff }, //  DH register
    { X86_CH,    X86_ECX, 8,   0xff }, //  CH register
    { X86_AH,    X86_EAX, 8,   0xff }, //  AH register
    { X86_IOPL,  X86_EFL,12,      3 }, //  IOPL level value
    { X86_OF,    X86_EFL,11,      1 }, //  OF (overflow flag)
    { X86_DF,    X86_EFL,10,      1 }, //  DF (direction flag)
    { X86_IF,    X86_EFL, 9,      1 }, //  IF (interrupt enable flag)
    { X86_TF,    X86_EFL, 8,      1 }, //  TF (trace flag)
    { X86_SF,    X86_EFL, 7,      1 }, //  SF (sign flag)
    { X86_ZF,    X86_EFL, 6,      1 }, //  ZF (zero flag)
    { X86_AF,    X86_EFL, 4,      1 }, //  AF (aux carry flag)
    { X86_PF,    X86_EFL, 2,      1 }, //  PF (parity flag)
    { X86_CF,    X86_EFL, 0,      1 }, //  CF (carry flag)
    { X86_VIP,   X86_EFL,20,      1 }, //  VIP (virtual interrupt pending)
    { X86_VIF,   X86_EFL,19,      1 }, //  VIF (virtual interrupt flag)
    { REG_ERROR, REG_ERROR, 0, 0    }
};

RegisterGroup g_X86BaseGroup =
{
    0, g_X86Defs, g_X86SubDefs, g_X86AllExtraDesc
};
RegisterGroup g_X86KernelGroup =
{
    0, g_X86KernelReg, NULL, g_X86KernelExtraDesc
};

// First ExecTypes entry must be the actual processor type.
ULONG g_X86ExecTypes[] =
{
    IMAGE_FILE_MACHINE_I386
};

// This array must be sorted by CV reg value.
CvRegMap g_X86CvRegMap[] =
{
    { CV_REG_AL, X86_AL},
    { CV_REG_CL, X86_CL},
    { CV_REG_DL, X86_DL},
    { CV_REG_BL, X86_BL},
    { CV_REG_AH, X86_AH},
    { CV_REG_CH, X86_CH},
    { CV_REG_DH, X86_DH},
    { CV_REG_BH, X86_BH},
    { CV_REG_AX, X86_AX},
    { CV_REG_CX, X86_CX},
    { CV_REG_DX, X86_DX},
    { CV_REG_BX, X86_BX},
    { CV_REG_SP, X86_SP},
    { CV_REG_BP, X86_BP},
    { CV_REG_SI, X86_SI},
    { CV_REG_DI, X86_DI},
    { CV_REG_EAX, X86_EAX},
    { CV_REG_ECX, X86_ECX},
    { CV_REG_EDX, X86_EDX},
    { CV_REG_EBX, X86_EBX},
    { CV_REG_ESP, X86_ESP},
    { CV_REG_EBP, X86_EBP},
    { CV_REG_ESI, X86_ESI},
    { CV_REG_EDI, X86_EDI},
    { CV_REG_ES, X86_ES},
    { CV_REG_CS, X86_CS},
    { CV_REG_SS, X86_SS},
    { CV_REG_DS, X86_DS},
    { CV_REG_FS, X86_FS},
    { CV_REG_GS, X86_GS},
    { CV_REG_IP, X86_IP},
    { CV_REG_FLAGS, X86_FL},
    { CV_REG_EIP, X86_EIP},
    { CV_REG_EFLAGS, X86_EFL},
//    { CV_REG_TEMP, REGTEMP},
//    { CV_REG_TEMPH, REGTEMPH},
//    { CV_REG_QUOTE, REGQUOTE},
//    { CV_REG_PCDR3, REGPCDR3},
//    { CV_REG_PCDR4, REGPCDR4},
//    { CV_REG_PCDR5, REGPCDR5},
//    { CV_REG_PCDR6, REGPCDR6},
//    { CV_REG_PCDR7, REGPCDR7},
    { CV_REG_CR0, X86_CR0},
//    { CV_REG_CR1, REGCR1},
    { CV_REG_CR2, X86_CR2},
    { CV_REG_CR3, X86_CR3},
    { CV_REG_CR4, X86_CR4},
    { CV_REG_DR0, X86_DR0},
    { CV_REG_DR1, X86_DR1},
    { CV_REG_DR2, X86_DR2},
    { CV_REG_DR3, X86_DR3},
//    { CV_REG_DR4, REGDR4},
//    { CV_REG_DR5, REGDR5},
    { CV_REG_DR6, X86_DR6},
    { CV_REG_DR7, X86_DR7},
    { CV_REG_GDTR, X86_GDTR},
    { CV_REG_GDTL, X86_GDTL},
    { CV_REG_IDTR, X86_IDTR},
    { CV_REG_IDTL, X86_IDTL},
    { CV_REG_LDTR, X86_LDTR},
    { CV_REG_TR, X86_TR},

//    { CV_REG_PSEUDO1, REGPSEUDO1},
//    { CV_REG_PSEUDO2, REGPSEUDO2},
//    { CV_REG_PSEUDO3, REGPSEUDO3},
//    { CV_REG_PSEUDO4, REGPSEUDO4},
//    { CV_REG_PSEUDO5, REGPSEUDO5},
//    { CV_REG_PSEUDO6, REGPSEUDO6},
//    { CV_REG_PSEUDO7, REGPSEUDO7},
//    { CV_REG_PSEUDO8, REGPSEUDO8},
//    { CV_REG_PSEUDO9, REGPSEUDO9},

    { CV_REG_ST0, X86_ST0},
    { CV_REG_ST1, X86_ST1},
    { CV_REG_ST2, X86_ST2},
    { CV_REG_ST3, X86_ST3},
    { CV_REG_ST4, X86_ST4},
    { CV_REG_ST5, X86_ST5},
    { CV_REG_ST6, X86_ST6},
    { CV_REG_ST7, X86_ST7},
    { CV_REG_CTRL, X86_FPCW},
    { CV_REG_STAT, X86_FPSW},
    { CV_REG_TAG, X86_FPTW},
//    { CV_REG_FPIP, REGFPIP},
//    { CV_REG_FPCS, REGFPCS},
//    { CV_REG_FPDO, REGFPDO},
//    { CV_REG_FPDS, REGFPDS},
//    { CV_REG_ISEM, REGISEM},
//    { CV_REG_FPEIP, REGFPEIP},
//    { CV_REG_FPEDO, REGFPEDO},

    { CV_REG_MM0, X86_MM0},
    { CV_REG_MM1, X86_MM1},
    { CV_REG_MM2, X86_MM2},
    { CV_REG_MM3, X86_MM3},
    { CV_REG_MM4, X86_MM4},
    { CV_REG_MM5, X86_MM5},
    { CV_REG_MM6, X86_MM6},
    { CV_REG_MM7, X86_MM7},
};

X86MachineInfo::X86MachineInfo(TargetInfo* Target)
    : BaseX86MachineInfo(Target)
{
    m_FullName = "x86 compatible";
    m_AbbrevName = "x86";
    m_PageSize = X86_PAGE_SIZE;
    m_PageShift = X86_PAGE_SHIFT;
    m_NumExecTypes = 1;
    m_ExecTypes = g_X86ExecTypes;
    m_Ptr64 = FALSE;
    m_RetRegIndex = X86_EAX;
    
    m_AllMask = REGALL_INT32 | REGALL_SEGREG,
    
    m_MaxDataBreakpoints = 4;
    m_SymPrefix = NULL;

    m_SizeCanonicalContext = sizeof(X86_NT5_CONTEXT);
    m_SverCanonicalContext = NT_SVER_W2K;

    m_SupportsBranchTrace = FALSE;
    m_ResetBranchTrace = TRUE;

    m_CvRegMapSize = DIMA(g_X86CvRegMap);
    m_CvRegMap = g_X86CvRegMap;
}

HRESULT
X86MachineInfo::Initialize(void)
{
    m_Groups[0] = &g_X86BaseGroup;
    m_NumGroups = 1;
    if (IS_KERNEL_TARGET(m_Target))
    {
        m_Groups[m_NumGroups] = &g_X86KernelGroup;
        m_NumGroups++;
    }
    
    return MachineInfo::Initialize();
}

HRESULT
X86MachineInfo::InitializeForProcessor(void)
{
    if (!strcmp(m_Target->m_FirstProcessorId.X86.VendorString, "GenuineIntel"))
    {
        // Branch trace support was added for the Pentium Pro.
        m_SupportsBranchTrace = m_Target->m_FirstProcessorId.X86.Family >= 6;
    }
    
    return MachineInfo::InitializeForProcessor();
}

void
X86MachineInfo::GetSystemTypeInfo(PSYSTEM_TYPE_INFO Info)
{
    Info->TriagePrcbOffset = EXTEND64(X86_TRIAGE_PRCB_ADDRESS);
    Info->SizeTargetContext = sizeof(X86_CONTEXT);
    Info->OffsetSpecialRegisters = sizeof(X86_CONTEXT);
    Info->OffsetTargetContextFlags = FIELD_OFFSET(X86_CONTEXT, ContextFlags);
    Info->SizeControlReport = sizeof(X86_DBGKD_CONTROL_REPORT);
    Info->SizeKspecialRegisters = sizeof(X86_KSPECIAL_REGISTERS);
    Info->SizePageFrameNumber = sizeof(ULONG);
    Info->SizePte = m_Target->m_KdDebuggerData.PaeEnabled ?
        sizeof(ULONG64) : sizeof(ULONG);
    Info->SizeDynamicFunctionTable = 0;
    Info->SizeRuntimeFunction = 0;
    
    Info->SharedUserDataOffset = 0;
    Info->UmSharedUserDataOffset = 0;
    Info->UmSharedSysCallOffset = 0;
    Info->UmSharedSysCallSize = 0;
    if (m_Target->m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        Info->SharedUserDataOffset = IS_KERNEL_TARGET(m_Target) ?
            EXTEND64(X86_KI_USER_SHARED_DATA) : MM_SHARED_USER_DATA_VA;
        Info->UmSharedUserDataOffset = MM_SHARED_USER_DATA_VA;

        if (m_Target->m_SystemVersion >= NT_SVER_XP)
        {
            // The syscall offset should really be provided in the debugger
            // data block so that it automatically tracks system changes.  It's
            // relatively stable, now, though.
            if (m_Target->m_BuildNumber >= 2492)
            {
                Info->UmSharedSysCallOffset = X86_SHARED_SYSCALL_BASE_GTE2492;
            }
            else if (m_Target->m_BuildNumber >= 2412)
            {
                Info->UmSharedSysCallOffset = X86_SHARED_SYSCALL_BASE_GTE2412;
            }
            else
            {
                Info->UmSharedSysCallOffset = X86_SHARED_SYSCALL_BASE_LT2412;
            }
            Info->UmSharedSysCallSize = X86_SHARED_SYSCALL_SIZE;
        }
    }

    if (m_Target->m_SystemVersion > NT_SVER_NT4)
    {
        Info->SizeTargetContext = sizeof(X86_NT5_CONTEXT);
        Info->OffsetSpecialRegisters = sizeof(X86_NT5_CONTEXT);
        Info->OffsetTargetContextFlags =
            FIELD_OFFSET(X86_NT5_CONTEXT, ContextFlags);
    }
}

void
X86MachineInfo::GetDefaultKdData(PKDDEBUGGER_DATA64 KdData)
{
    //
    // Parts of the data block may already be filled out
    // so don't destroy anything that's already set.
    //

    if (!KdData->OffsetKThreadApcProcess)
    {
        KdData->OffsetKThreadNextProcessor = X86_KTHREAD_NEXTPROCESSOR_OFFSET;
        KdData->OffsetKThreadTeb = X86_KTHREAD_TEB_OFFSET;
        KdData->OffsetKThreadKernelStack = X86_KTHREAD_KERNELSTACK_OFFSET;
        KdData->OffsetKThreadInitialStack = X86_KTHREAD_INITSTACK_OFFSET;
        KdData->OffsetKThreadApcProcess = X86_KTHREAD_APCPROCESS_OFFSET;
        KdData->OffsetKThreadState = X86_KTHREAD_STATE_OFFSET;
        KdData->OffsetEprocessPeb = X86_NT4_PEB_IN_EPROCESS;
        KdData->OffsetEprocessParentCID = X86_NT4_PCID_IN_EPROCESS;
        KdData->OffsetEprocessDirectoryTableBase =
            X86_DIRECTORY_TABLE_BASE_IN_EPROCESS;
        KdData->SizeEProcess = X86_NT5_EPROCESS_SIZE;
        
        KdData->SizePrcb = X86_NT4_KPRCB_SIZE;
        KdData->OffsetPrcbDpcRoutine = X86_KPRCB_DPC_ROUTINE_ACTIVE;
        KdData->OffsetPrcbCurrentThread = DEF_KPRCB_CURRENT_THREAD_OFFSET_32;
        KdData->OffsetPrcbMhz = X86_1381_KPRCB_MHZ;
        KdData->OffsetPrcbCpuType = X86_KPRCB_CPU_TYPE;
        KdData->OffsetPrcbVendorString = X86_1387_KPRCB_VENDOR_STRING;
        KdData->OffsetPrcbProcStateContext = X86_KPRCB_CONTEXT;
        KdData->OffsetPrcbNumber = X86_KPRCB_NUMBER;
        KdData->SizeEThread = X86_ETHREAD_SIZE;

        if (m_Target->m_SystemVersion > NT_SVER_NT4)
        {
            KdData->SizePrcb = X86_NT5_KPRCB_SIZE;
            KdData->OffsetEprocessPeb = X86_PEB_IN_EPROCESS;
            KdData->OffsetEprocessParentCID = X86_PCID_IN_EPROCESS;
            KdData->OffsetPrcbMhz = X86_2195_KPRCB_MHZ;
        }
        if (m_Target->m_BuildNumber >= 2087)
        {
            KdData->OffsetPrcbVendorString = X86_2087_KPRCB_VENDOR_STRING;
        }
        if (m_Target->m_BuildNumber > 2230)
        {
            KdData->OffsetKThreadNextProcessor =
                X86_2230_KTHREAD_NEXTPROCESSOR_OFFSET;
        }
        if (m_Target->m_BuildNumber >= 2251)
        {
            KdData->OffsetPrcbVendorString = X86_2251_KPRCB_VENDOR_STRING;
        }
        if (m_Target->m_SystemVersion > NT_SVER_W2K)
        {
            KdData->SizeEProcess = X86_NT51_EPROCESS_SIZE;
        }
        if (m_Target->m_BuildNumber > 2407)
        {
            KdData->SizeEThread = X86_NT51_ETHREAD_SIZE;
            KdData->OffsetKThreadNextProcessor =
                X86_NT51_KTHREAD_NEXTPROCESSOR_OFFSET;
        }
        if (m_Target->m_BuildNumber >= 2462)
        {
            KdData->OffsetPrcbMhz = X86_2462_KPRCB_MHZ;
        }
        if (m_Target->m_BuildNumber >= 2474)
        {
            KdData->OffsetPrcbVendorString = X86_2474_KPRCB_VENDOR_STRING;
        }
        if (m_Target->m_BuildNumber >= 2505)
        {
            KdData->OffsetPrcbMhz = X86_2505_KPRCB_MHZ;
        }
        if (m_Target->m_SystemVersion > NT_SVER_XP)
        {
            KdData->SizeEProcess = X86_NT511_EPROCESS_SIZE;
        }
        if (m_Target->m_BuildNumber > 3558)
        {
            KdData->OffsetKThreadApcProcess =
                X86_3555_KTHREAD_APCPROCESS_OFFSET;
            KdData->OffsetKThreadTeb =
                X86_3555_KTHREAD_TEB_OFFSET;
            KdData->OffsetKThreadKernelStack =
                X86_3555_KTHREAD_KERNELSTACK_OFFSET;
            KdData->OffsetKThreadNextProcessor =
                X86_3555_KTHREAD_NEXTPROCESSOR_OFFSET;
            KdData->OffsetKThreadState =
                X86_3555_KTHREAD_STATE_OFFSET;
        }
    }

    if (!KdData->SizePcr)
    {
        KdData->SizePcr = X86_1381_KPCR_SIZE;
        if (m_Target->m_BuildNumber >= 2195)
        {
            KdData->SizePcr = X86_2195_KPCR_SIZE;
        }
        if (m_Target->m_BuildNumber >= 2600)
        {
            KdData->SizePcr = X86_KPCR_SIZE;
        }
        KdData->OffsetPcrSelfPcr = X86_KPCR_SELF_PCR;
        KdData->OffsetPcrCurrentPrcb = X86_KPCR_PRCB;
        KdData->OffsetPcrContainedPrcb = X86_KPCR_PRCB_DATA;
        KdData->OffsetPcrInitialBStore = 0;
        KdData->OffsetPcrBStoreLimit = 0;
        KdData->OffsetPcrInitialStack = 0;
        KdData->OffsetPcrStackLimit = 0;
        KdData->OffsetPrcbPcrPage = 0;
        KdData->OffsetPrcbProcStateSpecialReg = X86_KPRCB_SPECIAL_REG;
        KdData->GdtR0Code = X86_KGDT_R0_CODE;
        KdData->GdtR0Data = X86_KGDT_R0_DATA;
        KdData->GdtR0Pcr = X86_KGDT_R0_PCR;
        KdData->GdtR3Code = X86_KGDT_R3_CODE + 3;
        KdData->GdtR3Data = X86_KGDT_R3_DATA + 3;
        KdData->GdtR3Teb = X86_KGDT_R3_TEB + 3;
        KdData->GdtLdt = X86_KGDT_LDT;
        KdData->GdtTss = X86_KGDT_TSS;
        KdData->Gdt64R3CmCode = 0;
        KdData->Gdt64R3CmTeb = 0;
    }
}

void
X86MachineInfo::
InitializeContext(ULONG64 Pc,
                  PDBGKD_ANY_CONTROL_REPORT ControlReport)
{
    ULONG Pc32 = (ULONG)Pc;

    m_Context.X86Nt5Context.Eip = Pc32;
    m_ContextState = Pc32 ? MCTX_PC : MCTX_NONE;

    if (ControlReport != NULL)
    {
        BpOut("InitializeContext(%d) DR6 %X DR7 %X\n",
              m_Target->m_RegContextProcessor,
              ControlReport->X86ControlReport.Dr6,
              ControlReport->X86ControlReport.Dr7);
        
        m_Context.X86Nt5Context.Dr6 = ControlReport->X86ControlReport.Dr6;
        m_Context.X86Nt5Context.Dr7 = ControlReport->X86ControlReport.Dr7;
        m_ContextState = MCTX_DR67_REPORT;

        if (ControlReport->X86ControlReport.ReportFlags &
            X86_REPORT_INCLUDES_SEGS)
        {
            //
            // This is for backwards compatibility - older kernels
            // won't pass these registers in the report record.
            //

            m_Context.X86Nt5Context.SegCs =
                ControlReport->X86ControlReport.SegCs;
            m_Context.X86Nt5Context.SegDs =
                ControlReport->X86ControlReport.SegDs;
            m_Context.X86Nt5Context.SegEs =
                ControlReport->X86ControlReport.SegEs;
            m_Context.X86Nt5Context.SegFs =
                ControlReport->X86ControlReport.SegFs;
            m_Context.X86Nt5Context.EFlags =
                ControlReport->X86ControlReport.EFlags;
            m_ContextState = MCTX_REPORT;
        }
    }

    if (!IS_CONTEXT_POSSIBLE(m_Target))
    {
        g_X86InVm86 = FALSE;
        g_X86InCode16 = FALSE;
    }
    else
    {
        // Check whether we're currently in V86 mode or 16-bit code.
        g_X86InVm86 = X86_IS_VM86(GetIntReg(X86_EFL));
        if (IS_KERNEL_TARGET(m_Target) && !g_X86InVm86)
        {
            if (ControlReport == NULL ||
                (ControlReport->X86ControlReport.ReportFlags &
                 X86_REPORT_STANDARD_CS) == 0)
            {
                DESCRIPTOR64 Desc;
                
                if (GetSegRegDescriptor(SEGREG_CODE, &Desc) != S_OK)
                {
                    WarnOut("CS descriptor lookup failed\n");
                    g_X86InCode16 = FALSE;
                }
                else
                {
                    g_X86InCode16 = (Desc.Flags & X86_DESC_DEFAULT_BIG) == 0;
                }
            }
            else
            {
                g_X86InCode16 = FALSE;

                // We're in a standard code segment so cache
                // a default descriptor for CS to avoid further
                // CS lookups.
                m_Target->
                    EmulateNtX86SelDescriptor(m_Target->m_RegContextThread,
                                              this,
                                              m_Context.X86Nt5Context.SegCs,
                                              &m_SegRegDesc[SEGREG_CODE]);
            }
        }
    }

    // Add instructions to cache only if we're in 32-bit flat mode.
    if (Pc32 && ControlReport != NULL &&
        !g_X86InVm86 && !g_X86InCode16)
    {
        CacheReportInstructions
            (Pc, ControlReport->X86ControlReport.InstructionCount,
             ControlReport->X86ControlReport.InstructionStream);
    }
}

HRESULT
X86MachineInfo::KdGetContextState(ULONG State)
{
    HRESULT Status;
        
    if (State >= MCTX_CONTEXT && m_ContextState < MCTX_CONTEXT)
    {
        Status = m_Target->
            GetContext(m_Target->m_RegContextThread->m_Handle,
                       &m_Context);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_CONTEXT;
    }

    if (State >= MCTX_FULL && m_ContextState < MCTX_FULL)
    {
        Status = m_Target->GetTargetSpecialRegisters
            (m_Target->m_RegContextThread->m_Handle,
             (PCROSS_PLATFORM_KSPECIAL_REGISTERS)&m_Special.X86Special);
        if (Status != S_OK)
        {
            return Status;
        }
        
        Status = m_Target->GetTargetSegRegDescriptors
            (m_Target->m_RegContextThread->m_Handle,
             0, SEGREG_COUNT, m_SegRegDesc);
        if (Status != S_OK)
        {
            return Status;
        }

        m_ContextState = MCTX_FULL;
        KdSetSpecialRegistersInContext();

        BpOut("GetContextState(%d) DR6 %X DR7 %X DR0 %X\n",
              m_Target->m_RegContextProcessor, m_Special.X86Special.KernelDr6,
              m_Special.X86Special.KernelDr7, m_Special.X86Special.KernelDr0);
    }

    return S_OK;
}

HRESULT
X86MachineInfo::KdSetContext(void)
{
    HRESULT Status;
    
    Status = m_Target->SetContext(m_Target->m_RegContextThread->m_Handle,
                                  &m_Context);
    if (Status != S_OK)
    {
        return Status;
    }

    KdGetSpecialRegistersFromContext();
    Status = m_Target->SetTargetSpecialRegisters
        (m_Target->m_RegContextThread->m_Handle,
         (PCROSS_PLATFORM_KSPECIAL_REGISTERS)&m_Special.X86Special);
    if (Status != S_OK)
    {
        return Status;
    }
    
    BpOut("SetContext(%d) DR6 %X DR7 %X DR0 %X\n",
          m_Target->m_RegContextProcessor, m_Special.X86Special.KernelDr6,
          m_Special.X86Special.KernelDr7, m_Special.X86Special.KernelDr0);
    
    return S_OK;
}

HRESULT
X86MachineInfo::ConvertContextFrom(PCROSS_PLATFORM_CONTEXT Context,
                                   ULONG FromSver, ULONG FromSize, PVOID From)
{
    if (FromSver <= NT_SVER_NT4)
    {
        if (FromSize < sizeof(X86_CONTEXT))
        {
            return E_INVALIDARG;
        }

        memcpy(Context, From, sizeof(X86_CONTEXT));
        ZeroMemory(Context->X86Nt5Context.ExtendedRegisters,
                   sizeof(Context->X86Nt5Context.ExtendedRegisters));
    }
    else if (FromSize >= sizeof(X86_NT5_CONTEXT))
    {
        memcpy(Context, From, sizeof(X86_NT5_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
X86MachineInfo::ConvertContextTo(PCROSS_PLATFORM_CONTEXT Context,
                                 ULONG ToSver, ULONG ToSize, PVOID To)
{
    if (ToSver <= NT_SVER_NT4)
    {
        if (ToSize < sizeof(X86_CONTEXT))
        {
            return E_INVALIDARG;
        }

        memcpy(To, Context, sizeof(X86_CONTEXT));
    }
    else if (ToSize >= sizeof(X86_NT5_CONTEXT))
    {
        memcpy(To, Context, sizeof(X86_NT5_CONTEXT));
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

void
X86MachineInfo::InitializeContextFlags(PCROSS_PLATFORM_CONTEXT Context,
                                       ULONG Version)
{
    ULONG ContextFlags;
    
    ContextFlags = VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |
        VDMCONTEXT_SEGMENTS | VDMCONTEXT_FLOATING_POINT;
    if (IS_USER_TARGET(m_Target))
    {
        ContextFlags |= VDMCONTEXT_DEBUG_REGISTERS;
    }
    
    if (Version <= NT_SVER_NT4)
    {
        Context->X86Context.ContextFlags = ContextFlags;
    }
    else
    {
        Context->X86Nt5Context.ContextFlags = ContextFlags |
            VDMCONTEXT_EXTENDED_REGISTERS;
    }
}

HRESULT
X86MachineInfo::GetContextFromThreadStack(ULONG64 ThreadBase,
                                          PCROSS_PLATFORM_CONTEXT Context,
                                          ULONG64 Stack)
{
    HRESULT Status;
    X86_KSWITCHFRAME SwitchFrame;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           Stack,
                                           &SwitchFrame,
                                           sizeof(SwitchFrame))) != S_OK)
    {
        return Status;
    }
    
    ZeroMemory(Context, sizeof(*Context));

    Context->X86Nt5Context.Eip = SwitchFrame.RetAddr;
    Context->X86Nt5Context.Esp = (ULONG)Stack + sizeof(SwitchFrame);

    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        EXTEND64(Context->X86Nt5Context.Esp),
                        &Context->X86Nt5Context.Ebp,
                        sizeof(Context)->X86Nt5Context.Ebp)) != S_OK)
    {
        return Status;
    }

    // Fill the segments in from current information
    // instead of just leaving them blank.
    Context->X86Nt5Context.SegSs = GetIntReg(X86_SS);
    Context->X86Nt5Context.SegCs = GetIntReg(X86_CS);

    return S_OK;
}

HRESULT
X86MachineInfo::GetContextFromFiber(ProcessInfo* Process,
                                    ULONG64 FiberBase,
                                    PCROSS_PLATFORM_CONTEXT Context,
                                    BOOL Verbose)
{
    HRESULT Status;
    X86_FIBER Fiber;

    if ((Status = m_Target->
         ReadAllVirtual(Process, FiberBase, &Fiber, sizeof(Fiber))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read fiber data at %s\n",
                   FormatMachineAddr64(this, FiberBase));
        }
        return Status;
    }

    if ((Status = ConvertContextFrom(Context, m_Target->m_SystemVersion,
                                     m_Target->m_TypeInfo.SizeTargetContext,
                                     &Fiber.FiberContext)) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to convert context to canonical form\n");
        }
        return Status;
    }

    if (Verbose)
    {
        dprintf("Fiber at %s  Fiber data: %08X\n",
                FormatMachineAddr64(this, FiberBase),
                Fiber.FiberData);
        dprintf("  Stack base: %08X  Stack limit: %08X\n",
                Fiber.StackBase,
                Fiber.StackLimit);
    }
    
    return S_OK;
}

HRESULT
X86MachineInfo::GetContextFromTrapFrame(ULONG64 TrapBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Verbose)
{
    HRESULT Status;
    X86_KTRAP_FRAME Trap;
    
    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        TrapBase, &Trap, sizeof(Trap))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read trap frame at %s\n",
                   FormatMachineAddr64(this, TrapBase));
        }
        return Status;
    }
    
    ZeroMemory(Context, sizeof(*Context));
    
    if ((Trap.SegCs & 1) || X86_IS_VM86(Trap.EFlags))
    {
        Context->X86Nt5Context.Esp = Trap.HardwareEsp;
    }
    else
    {
        Context->X86Nt5Context.Esp = (ULONG)TrapBase +
            FIELD_OFFSET(X86_KTRAP_FRAME, HardwareEsp);
    }
    if (X86_IS_VM86(Trap.EFlags))
    {
        Context->X86Nt5Context.SegSs =
            (USHORT)(Trap.HardwareSegSs & 0xffff);
    }
    else if ((Trap.SegCs & X86_MODE_MASK) != 0 /*KernelMode*/)
    {
        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //

        Context->X86Nt5Context.SegSs =
            (USHORT)(Trap.HardwareSegSs | 3) & 0xffff;
    }
    else
    {
        Context->X86Nt5Context.SegSs = m_Target->m_KdDebuggerData.GdtR0Data;
    }

    Context->X86Nt5Context.SegGs = Trap.SegGs & 0xffff;
    Context->X86Nt5Context.SegFs = Trap.SegFs & 0xffff;
    Context->X86Nt5Context.SegEs = Trap.SegEs & 0xffff;
    Context->X86Nt5Context.SegDs = Trap.SegDs & 0xffff;
    Context->X86Nt5Context.SegCs = Trap.SegCs & 0xffff;
    Context->X86Nt5Context.Eip = Trap.Eip;
    Context->X86Nt5Context.Ebp = Trap.Ebp;
    Context->X86Nt5Context.Eax = Trap.Eax;
    Context->X86Nt5Context.Ebx = Trap.Ebx;
    Context->X86Nt5Context.Ecx = Trap.Ecx;
    Context->X86Nt5Context.Edx = Trap.Edx;
    Context->X86Nt5Context.Edi = Trap.Edi;
    Context->X86Nt5Context.Esi = Trap.Esi;
    Context->X86Nt5Context.EFlags = Trap.EFlags;

    return Status;
}

HRESULT
X86MachineInfo::GetContextFromTaskSegment(ULONG64 TssBase,
                                          PCROSS_PLATFORM_CONTEXT Context,
                                          BOOL Verbose)
{
    HRESULT Status;
    X86_KTSS Tss;

    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        TssBase, &Tss, sizeof(Tss))) != S_OK)
    {
        if (Verbose)
        {
            ErrOut("Unable to read TSS at %s\n",
                   FormatMachineAddr64(this, TssBase));
        }
        return Status;
    }
    
    ZeroMemory(Context, sizeof(*Context));
    
    if (X86_IS_VM86(Tss.EFlags))
    {
        Context->X86Nt5Context.SegSs = (USHORT)(Tss.Ss & 0xffff);
    }
    else if ((Tss.Cs & X86_MODE_MASK) != 0)
    {
        //
        // It's user mode.
        // The HardwareSegSs contains R3 data selector.
        //

        Context->X86Nt5Context.SegSs =
            (USHORT)(Tss.Ss | 3) & 0xffff;
    }
    else
    {
        Context->X86Nt5Context.SegSs = m_Target->m_KdDebuggerData.GdtR0Data;
    }

    Context->X86Nt5Context.SegGs = Tss.Gs & 0xffff;
    Context->X86Nt5Context.SegFs = Tss.Fs & 0xffff;
    Context->X86Nt5Context.SegEs = Tss.Es & 0xffff;
    Context->X86Nt5Context.SegDs = Tss.Ds & 0xffff;
    Context->X86Nt5Context.SegCs = Tss.Cs & 0xffff;
    Context->X86Nt5Context.Esp = Tss.Esp;
    Context->X86Nt5Context.Eip = Tss.Eip;
    Context->X86Nt5Context.Ebp = Tss.Ebp;
    Context->X86Nt5Context.Eax = Tss.Eax;
    Context->X86Nt5Context.Ebx = Tss.Ebx;
    Context->X86Nt5Context.Ecx = Tss.Ecx;
    Context->X86Nt5Context.Edx = Tss.Edx;
    Context->X86Nt5Context.Edi = Tss.Edi;
    Context->X86Nt5Context.Esi = Tss.Esi;
    Context->X86Nt5Context.EFlags = Tss.EFlags;

    return Status;
}

void 
X86MachineInfo::GetScopeFrameFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                         PDEBUG_STACK_FRAME ScopeFrame)
{
    ZeroMemory(ScopeFrame, sizeof(*ScopeFrame));
    StackTrace(NULL,
               EXTEND64(Context->X86Context.Ebp),
               EXTEND64(Context->X86Context.Esp),
               EXTEND64(Context->X86Context.Eip),
               STACK_NO_DEFAULT, ScopeFrame, 1, 0, 0, 0);
}

void
X86MachineInfo::GetStackDefaultsFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                            LPADDRESS64 Instr,
                                            LPADDRESS64 Stack,
                                            LPADDRESS64 Frame)
{
    //
    // On x86 we want to fill out the addresses so that
    // dbghelp doesn't have to deal with segmentation and
    // such.
    //
    // At least, that's the theory, but most of the
    // segmented stack support has been ripped out and
    // this code doesn't really do much useful.
    //
    
    Instr->Mode = AddrModeFlat;
    Instr->Segment = (USHORT)(Context->X86Nt5Context.SegCs & 0xffff);
    Instr->Offset = EXTEND64(Context->X86Nt5Context.Eip);

    Stack->Mode = AddrModeFlat;
    Stack->Segment = (USHORT)(Context->X86Nt5Context.SegSs & 0xffff);
    Stack->Offset = EXTEND64(Context->X86Nt5Context.Esp);

    Frame->Mode = AddrModeFlat;
    Frame->Segment = (USHORT)(Context->X86Nt5Context.SegSs & 0xffff);
    Frame->Offset = EXTEND64(Context->X86Nt5Context.Ebp);
}

HRESULT
X86MachineInfo::GetScopeFrameRegister(ULONG Reg,
                                      PDEBUG_STACK_FRAME ScopeFrame,
                                      PULONG64 Value)
{
    HRESULT Status;
    REGVAL RegVal;
    
    switch(Reg)
    {
    case X86_ESP:
        *Value = ScopeFrame->StackOffset;
        return S_OK;

    case X86_EBP:
        if (ScopeFrame->FuncTableEntry)
        {
            PFPO_DATA FpoData = (PFPO_DATA)ScopeFrame->FuncTableEntry;
            if (FpoData->cbFrame == FRAME_FPO)
            {
                //
                // Get EBP from FPO data, if available
                //
                if (SAVE_EBP(ScopeFrame) &&
                    (FpoData->fUseBP ||
                     ((SAVE_EBP(ScopeFrame) >> 32) == 0xEB)))
                {
                    // Either the frame saved EBP or we saved it
                    // during stackwalk along with tag 0xEB on upper 32 bits.
                    *Value = EXTEND64(SAVE_EBP(ScopeFrame));
                    return S_OK;
                }
                else
                {
                    //
                    // Guess the ebp value, in most cases for FPO frames its
                    // a DWORD off frameoffset
                    //
                    *Value = ScopeFrame->FrameOffset + sizeof(DWORD);
                    return S_OK;
                }
            }
        }

        *Value = ScopeFrame->FrameOffset;
        return S_OK;

    default:
        RegVal.I64 = 0;
        if ((Status = FullGetVal(Reg, &RegVal)) != S_OK)
        {
            return Status;
        }
        *Value = RegVal.I64;
        return S_OK;
    }
}

HRESULT
X86MachineInfo::SetScopeFrameRegister(ULONG Reg,
                                      PDEBUG_STACK_FRAME ScopeFrame,
                                      ULONG64 Value)
{
    REGVAL RegVal;
    
    switch(Reg)
    {
    case X86_ESP:
        ScopeFrame->StackOffset = Value;
        return S_OK;
    case X86_EBP:
        // Don't allow EBP updating due to the FPO complexities.
        return E_INVALIDARG;
    default:
        RegVal.Type = GetType(Reg);
        RegVal.I64 = Value;
        return FullSetVal(Reg, &RegVal);
    }
}

void
X86MachineInfo::SanitizeMemoryContext(PCROSS_PLATFORM_CONTEXT Context)
{
    if (Context->X86Context.EFlags & X86_EFLAGS_V86_MASK)
    {
        Context->X86Context.SegSs &= 0xffff;
    }
    else if (Context->X86Context.SegCs & X86_MODE_MASK)
    {
        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //
        Context->X86Context.SegSs =
            (USHORT)(Context->X86Context.SegSs | X86_RPL_MASK) & 0xffff;
    }
    else
    {
        Context->X86Context.SegSs = m_Target->m_KdDebuggerData.GdtR0Data;
    }
}

HRESULT
X86MachineInfo::GetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                               EXDI_CONTEXT_TYPE CtxType)
{
    // Always ask for everything.
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        Context->X86Context.RegGroupSelection.fSegmentRegs = TRUE;
        Context->X86Context.RegGroupSelection.fControlRegs = TRUE;
        Context->X86Context.RegGroupSelection.fIntegerRegs = TRUE;
        Context->X86Context.RegGroupSelection.fFloatingPointRegs = TRUE;
        Context->X86Context.RegGroupSelection.fDebugRegs = TRUE;
        return ((IeXdiX86Context*)Exdi)->GetContext(&Context->X86Context);
    case EXDI_CTX_X86_EX:
        Context->X86ExContext.RegGroupSelection.fSegmentRegs = TRUE;
        Context->X86ExContext.RegGroupSelection.fControlRegs = TRUE;
        Context->X86ExContext.RegGroupSelection.fIntegerRegs = TRUE;
        Context->X86ExContext.RegGroupSelection.fFloatingPointRegs = TRUE;
        Context->X86ExContext.RegGroupSelection.fDebugRegs = TRUE;
        Context->X86ExContext.RegGroupSelection.fSegmentDescriptors = TRUE;
        Context->X86ExContext.RegGroupSelection.fSSERegisters = TRUE;
        Context->X86ExContext.RegGroupSelection.fSystemRegisters = TRUE;
        return ((IeXdiX86ExContext*)Exdi)->GetContext(&Context->X86ExContext);
    default:
        return E_INVALIDARG;
    }
}

HRESULT
X86MachineInfo::SetExdiContext(IUnknown* Exdi, PEXDI_CONTEXT Context,
                               EXDI_CONTEXT_TYPE CtxType)
{
    // Don't change the existing group selections on the assumption
    // that there was a full get prior to any modifications so
    // all groups are valid.
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        return ((IeXdiX86Context*)Exdi)->SetContext(Context->X86Context);
    case EXDI_CTX_X86_EX:
        return ((IeXdiX86ExContext*)Exdi)->SetContext(Context->X86ExContext);
    default:
        return E_INVALIDARG;
    }
}

void
X86MachineInfo::ConvertExdiContextFromContext(PCROSS_PLATFORM_CONTEXT Context,
                                              PEXDI_CONTEXT ExdiContext,
                                              EXDI_CONTEXT_TYPE CtxType)
{
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_SEGMENTS)
        {
            ExdiContext->X86Context.SegGs =
                (USHORT)Context->X86Nt5Context.SegGs;
            ExdiContext->X86Context.SegFs =
                (USHORT)Context->X86Nt5Context.SegFs;
            ExdiContext->X86Context.SegEs =
                (USHORT)Context->X86Nt5Context.SegEs;
            ExdiContext->X86Context.SegDs =
                (USHORT)Context->X86Nt5Context.SegDs;
        }

        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_CONTROL)
        {
            ExdiContext->X86Context.Ebp = Context->X86Nt5Context.Ebp;
            ExdiContext->X86Context.Eip = Context->X86Nt5Context.Eip;
            ExdiContext->X86Context.SegCs =
                (USHORT)Context->X86Nt5Context.SegCs;
            ExdiContext->X86Context.EFlags = Context->X86Nt5Context.EFlags;
            ExdiContext->X86Context.Esp = Context->X86Nt5Context.Esp;
            ExdiContext->X86Context.SegSs =
                (USHORT)Context->X86Nt5Context.SegSs;
        }
    
        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_INTEGER)
        {
            ExdiContext->X86Context.Eax = Context->X86Nt5Context.Eax;
            ExdiContext->X86Context.Ebx = Context->X86Nt5Context.Ebx;
            ExdiContext->X86Context.Ecx = Context->X86Nt5Context.Ecx;
            ExdiContext->X86Context.Edx = Context->X86Nt5Context.Edx;
            ExdiContext->X86Context.Esi = Context->X86Nt5Context.Esi;
            ExdiContext->X86Context.Edi = Context->X86Nt5Context.Edi;
        }

        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_FLOATING_POINT)
        {
            C_ASSERT(sizeof(X86_FLOATING_SAVE_AREA) ==
                     FIELD_OFFSET(CONTEXT_X86, Dr0) -
                     FIELD_OFFSET(CONTEXT_X86, ControlWord));
            memcpy(&ExdiContext->X86Context.ControlWord,
                   &Context->X86Nt5Context.FloatSave,
                   sizeof(X86_FLOATING_SAVE_AREA));
        }
        
        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_DEBUG_REGISTERS)
        {
            ExdiContext->X86Context.Dr0 = Context->X86Nt5Context.Dr0;
            ExdiContext->X86Context.Dr1 = Context->X86Nt5Context.Dr1;
            ExdiContext->X86Context.Dr2 = Context->X86Nt5Context.Dr2;
            ExdiContext->X86Context.Dr3 = Context->X86Nt5Context.Dr3;
            ExdiContext->X86Context.Dr6 = Context->X86Nt5Context.Dr6;
            ExdiContext->X86Context.Dr7 = Context->X86Nt5Context.Dr7;
        }
        break;
        
    case EXDI_CTX_X86_EX:
        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_SEGMENTS)
        {
            ExdiContext->X86ExContext.SegGs =
                (USHORT)Context->X86Nt5Context.SegGs;
            ExdiContext->X86ExContext.SegFs =
                (USHORT)Context->X86Nt5Context.SegFs;
            ExdiContext->X86ExContext.SegEs =
                (USHORT)Context->X86Nt5Context.SegEs;
            ExdiContext->X86ExContext.SegDs =
                (USHORT)Context->X86Nt5Context.SegDs;
        }

        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_CONTROL)
        {
            ExdiContext->X86ExContext.Ebp = Context->X86Nt5Context.Ebp;
            ExdiContext->X86ExContext.Eip = Context->X86Nt5Context.Eip;
            ExdiContext->X86ExContext.SegCs =
                (USHORT)Context->X86Nt5Context.SegCs;
            ExdiContext->X86ExContext.EFlags = Context->X86Nt5Context.EFlags;
            ExdiContext->X86ExContext.Esp = Context->X86Nt5Context.Esp;
            ExdiContext->X86ExContext.SegSs =
                (USHORT)Context->X86Nt5Context.SegSs;
        }
    
        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_INTEGER)
        {
            ExdiContext->X86ExContext.Eax = Context->X86Nt5Context.Eax;
            ExdiContext->X86ExContext.Ebx = Context->X86Nt5Context.Ebx;
            ExdiContext->X86ExContext.Ecx = Context->X86Nt5Context.Ecx;
            ExdiContext->X86ExContext.Edx = Context->X86Nt5Context.Edx;
            ExdiContext->X86ExContext.Esi = Context->X86Nt5Context.Esi;
            ExdiContext->X86ExContext.Edi = Context->X86Nt5Context.Edi;
        }

        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_FLOATING_POINT)
        {
            C_ASSERT(sizeof(X86_FLOATING_SAVE_AREA) ==
                     FIELD_OFFSET(CONTEXT_X86_EX, Dr0) -
                     FIELD_OFFSET(CONTEXT_X86_EX, ControlWord));
            memcpy(&ExdiContext->X86ExContext.ControlWord,
                   &Context->X86Nt5Context.FloatSave,
                   sizeof(X86_FLOATING_SAVE_AREA));
        }
        
        if (Context->X86Nt5Context.ContextFlags & VDMCONTEXT_DEBUG_REGISTERS)
        {
            ExdiContext->X86ExContext.Dr0 = Context->X86Nt5Context.Dr0;
            ExdiContext->X86ExContext.Dr1 = Context->X86Nt5Context.Dr1;
            ExdiContext->X86ExContext.Dr2 = Context->X86Nt5Context.Dr2;
            ExdiContext->X86ExContext.Dr3 = Context->X86Nt5Context.Dr3;
            ExdiContext->X86ExContext.Dr6 = Context->X86Nt5Context.Dr6;
            ExdiContext->X86ExContext.Dr7 = Context->X86Nt5Context.Dr7;
        }

        if (Context->X86Nt5Context.ContextFlags &
            VDMCONTEXT_EXTENDED_REGISTERS)
        {
            C_ASSERT(X86_SIZE_OF_FX_REGISTERS ==
                     sizeof(ExdiContext->X86ExContext.Sse));
            memcpy(ExdiContext->X86ExContext.Sse,
                   Context->X86Nt5Context.FxSave.Reserved3,
                   X86_SIZE_OF_FX_REGISTERS);
            ExdiContext->X86ExContext.Mxcsr =
                Context->X86Nt5Context.FxSave.MXCsr;
        }
        break;
        
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
X86MachineInfo::ConvertExdiContextToContext(PEXDI_CONTEXT ExdiContext,
                                            EXDI_CONTEXT_TYPE CtxType,
                                            PCROSS_PLATFORM_CONTEXT Context)
{
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        Context->X86Nt5Context.SegCs = ExdiContext->X86Context.SegCs;
        Context->X86Nt5Context.SegSs = ExdiContext->X86Context.SegSs;
        Context->X86Nt5Context.SegGs = ExdiContext->X86Context.SegGs;
        Context->X86Nt5Context.SegFs = ExdiContext->X86Context.SegFs;
        Context->X86Nt5Context.SegEs = ExdiContext->X86Context.SegEs;
        Context->X86Nt5Context.SegDs = ExdiContext->X86Context.SegDs;

        Context->X86Nt5Context.EFlags = ExdiContext->X86Context.EFlags;
        Context->X86Nt5Context.Ebp = ExdiContext->X86Context.Ebp;
        Context->X86Nt5Context.Eip = ExdiContext->X86Context.Eip;
        Context->X86Nt5Context.Esp = ExdiContext->X86Context.Esp;
    
        Context->X86Nt5Context.Eax = ExdiContext->X86Context.Eax;
        Context->X86Nt5Context.Ebx = ExdiContext->X86Context.Ebx;
        Context->X86Nt5Context.Ecx = ExdiContext->X86Context.Ecx;
        Context->X86Nt5Context.Edx = ExdiContext->X86Context.Edx;
        Context->X86Nt5Context.Esi = ExdiContext->X86Context.Esi;
        Context->X86Nt5Context.Edi = ExdiContext->X86Context.Edi;

        C_ASSERT(sizeof(X86_FLOATING_SAVE_AREA) ==
                 FIELD_OFFSET(CONTEXT_X86, Dr0) -
                 FIELD_OFFSET(CONTEXT_X86, ControlWord));
        memcpy(&Context->X86Nt5Context.FloatSave,
               &ExdiContext->X86Context.ControlWord,
               sizeof(X86_FLOATING_SAVE_AREA));

        Context->X86Nt5Context.Dr0 = ExdiContext->X86Context.Dr0;
        Context->X86Nt5Context.Dr1 = ExdiContext->X86Context.Dr1;
        Context->X86Nt5Context.Dr2 = ExdiContext->X86Context.Dr2;
        Context->X86Nt5Context.Dr3 = ExdiContext->X86Context.Dr3;
        Context->X86Nt5Context.Dr6 = ExdiContext->X86Context.Dr6;
        Context->X86Nt5Context.Dr7 = ExdiContext->X86Context.Dr7;
        break;
        
    case EXDI_CTX_X86_EX:
        Context->X86Nt5Context.SegCs = ExdiContext->X86ExContext.SegCs;
        Context->X86Nt5Context.SegSs = ExdiContext->X86ExContext.SegSs;
        Context->X86Nt5Context.SegGs = ExdiContext->X86ExContext.SegGs;
        Context->X86Nt5Context.SegFs = ExdiContext->X86ExContext.SegFs;
        Context->X86Nt5Context.SegEs = ExdiContext->X86ExContext.SegEs;
        Context->X86Nt5Context.SegDs = ExdiContext->X86ExContext.SegDs;

        Context->X86Nt5Context.EFlags = ExdiContext->X86ExContext.EFlags;
        Context->X86Nt5Context.Ebp = ExdiContext->X86ExContext.Ebp;
        Context->X86Nt5Context.Eip = ExdiContext->X86ExContext.Eip;
        Context->X86Nt5Context.Esp = ExdiContext->X86ExContext.Esp;
    
        Context->X86Nt5Context.Eax = ExdiContext->X86ExContext.Eax;
        Context->X86Nt5Context.Ebx = ExdiContext->X86ExContext.Ebx;
        Context->X86Nt5Context.Ecx = ExdiContext->X86ExContext.Ecx;
        Context->X86Nt5Context.Edx = ExdiContext->X86ExContext.Edx;
        Context->X86Nt5Context.Esi = ExdiContext->X86ExContext.Esi;
        Context->X86Nt5Context.Edi = ExdiContext->X86ExContext.Edi;

        C_ASSERT(sizeof(X86_FLOATING_SAVE_AREA) ==
                 FIELD_OFFSET(CONTEXT_X86, Dr0) -
                 FIELD_OFFSET(CONTEXT_X86, ControlWord));
        memcpy(&Context->X86Nt5Context.FloatSave,
               &ExdiContext->X86ExContext.ControlWord,
               sizeof(X86_FLOATING_SAVE_AREA));

        Context->X86Nt5Context.Dr0 = ExdiContext->X86ExContext.Dr0;
        Context->X86Nt5Context.Dr1 = ExdiContext->X86ExContext.Dr1;
        Context->X86Nt5Context.Dr2 = ExdiContext->X86ExContext.Dr2;
        Context->X86Nt5Context.Dr3 = ExdiContext->X86ExContext.Dr3;
        Context->X86Nt5Context.Dr6 = ExdiContext->X86ExContext.Dr6;
        Context->X86Nt5Context.Dr7 = ExdiContext->X86ExContext.Dr7;

        C_ASSERT(X86_SIZE_OF_FX_REGISTERS ==
                 sizeof(ExdiContext->X86ExContext.Sse));
        memcpy(Context->X86Nt5Context.FxSave.Reserved3,
               ExdiContext->X86ExContext.Sse,
               X86_SIZE_OF_FX_REGISTERS);
        Context->X86Nt5Context.FxSave.MXCsr =
            ExdiContext->X86ExContext.Mxcsr;
        break;
        
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
X86MachineInfo::ConvertExdiContextToSegDescs(PEXDI_CONTEXT ExdiContext,
                                             EXDI_CONTEXT_TYPE CtxType,
                                             ULONG Start, ULONG Count,
                                             PDESCRIPTOR64 Descs)
{
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        // The basic x86 context doesn't have descriptor
        // state so just fake something up for basic boot state.
        while (Count-- > 0)
        {
            ULONG Type;
        
            if (Start == SEGREG_CODE)
            {
                Descs->Base = EXTEND64(0xffff0000);
                Type = 0x13;
            }
            else
            {
                Descs->Base = 0;
                Type = 0x1b;
            }

            Descs->Limit = 0xfffff;
            Descs->Flags = X86_DESC_PRESENT | X86_DESC_DEFAULT_BIG | Type;
            Descs++;

            Start++;
        }
        break;

    case EXDI_CTX_X86_EX:
        while (Count-- > 0)
        {
            X86_SEG_DESC_INFO* Desc;

            switch(Start)
            {
            case SEGREG_CODE:
                Desc = &ExdiContext->X86ExContext.DescriptorCs;
                break;
            case SEGREG_DATA:
                Desc = &ExdiContext->X86ExContext.DescriptorDs;
                break;
            case SEGREG_STACK:
                Desc = &ExdiContext->X86ExContext.DescriptorSs;
                break;
            case SEGREG_ES:
                Desc = &ExdiContext->X86ExContext.DescriptorEs;
                break;
            case SEGREG_FS:
                Desc = &ExdiContext->X86ExContext.DescriptorFs;
                break;
            case SEGREG_GS:
                Desc = &ExdiContext->X86ExContext.DescriptorGs;
                break;
            case SEGREG_GDT:
                Descs->Base = ExdiContext->X86ExContext.GdtBase;
                Descs->Limit = ExdiContext->X86ExContext.GdtLimit;
                Descs->Flags = X86_DESC_PRESENT;
                Desc = NULL;
                break;
            case SEGREG_LDT:
                Desc = &ExdiContext->X86ExContext.DescriptorLdtr;
                break;
            default:
                Descs->Flags = SEGDESC_INVALID;
                Desc = NULL;
                break;
            }

            if (Desc != NULL)
            {
                Descs->Base = EXTEND64(Desc->Base);
                Descs->Limit = Desc->Limit;
                Descs->Flags =
                    ((Desc->Flags >> 4) & 0xf00) |
                    (Desc->Flags & 0xff);
            }

            Descs++;
            Start++;
        }
        break;
        
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
X86MachineInfo::ConvertExdiContextFromSpecial
    (PCROSS_PLATFORM_KSPECIAL_REGISTERS Special,
     PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType)
{
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        // No such information.
        break;

    case EXDI_CTX_X86_EX:
        ExdiContext->X86ExContext.Cr0 = Special->X86Special.Cr0;
        ExdiContext->X86ExContext.Cr2 = Special->X86Special.Cr2;
        ExdiContext->X86ExContext.Cr3 = Special->X86Special.Cr3;
        ExdiContext->X86ExContext.Cr4 = Special->X86Special.Cr4;
        ExdiContext->X86ExContext.Dr0 = Special->X86Special.KernelDr0;
        ExdiContext->X86ExContext.Dr1 = Special->X86Special.KernelDr1;
        ExdiContext->X86ExContext.Dr2 = Special->X86Special.KernelDr2;
        ExdiContext->X86ExContext.Dr3 = Special->X86Special.KernelDr3;
        ExdiContext->X86ExContext.Dr6 = Special->X86Special.KernelDr6;
        ExdiContext->X86ExContext.Dr7 = Special->X86Special.KernelDr7;
        ExdiContext->X86ExContext.GdtLimit = Special->X86Special.Gdtr.Limit;
        ExdiContext->X86ExContext.GdtBase = Special->X86Special.Gdtr.Base;
        ExdiContext->X86ExContext.IdtLimit = Special->X86Special.Idtr.Limit;
        ExdiContext->X86ExContext.IdtBase = Special->X86Special.Idtr.Base;
        ExdiContext->X86ExContext.Tr = Special->X86Special.Tr;
        ExdiContext->X86ExContext.Ldtr = Special->X86Special.Ldtr;
        break;
        
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

void
X86MachineInfo::ConvertExdiContextToSpecial
    (PEXDI_CONTEXT ExdiContext, EXDI_CONTEXT_TYPE CtxType,
     PCROSS_PLATFORM_KSPECIAL_REGISTERS Special)
{
    switch(CtxType)
    {
    case EXDI_CTX_X86:
        // No such information.
        break;

    case EXDI_CTX_X86_EX:
        Special->X86Special.Cr0 = ExdiContext->X86ExContext.Cr0;
        Special->X86Special.Cr2 = ExdiContext->X86ExContext.Cr2;
        Special->X86Special.Cr3 = ExdiContext->X86ExContext.Cr3;
        Special->X86Special.Cr4 = ExdiContext->X86ExContext.Cr4;
        Special->X86Special.KernelDr0 = ExdiContext->X86ExContext.Dr0;
        Special->X86Special.KernelDr1 = ExdiContext->X86ExContext.Dr1;
        Special->X86Special.KernelDr2 = ExdiContext->X86ExContext.Dr2;
        Special->X86Special.KernelDr3 = ExdiContext->X86ExContext.Dr3;
        Special->X86Special.KernelDr6 = ExdiContext->X86ExContext.Dr6;
        Special->X86Special.KernelDr7 = ExdiContext->X86ExContext.Dr7;
        Special->X86Special.Gdtr.Limit =
            (USHORT)ExdiContext->X86ExContext.GdtLimit;
        Special->X86Special.Gdtr.Base = ExdiContext->X86ExContext.GdtBase;
        Special->X86Special.Idtr.Limit =
            (USHORT)ExdiContext->X86ExContext.IdtLimit;
        Special->X86Special.Idtr.Base = ExdiContext->X86ExContext.IdtBase;
        Special->X86Special.Tr = (USHORT)ExdiContext->X86ExContext.Tr;
        Special->X86Special.Ldtr = (USHORT)ExdiContext->X86ExContext.Ldtr;
        break;
        
    default:
        DBG_ASSERT(FALSE);
        break;
    }
}

int
X86MachineInfo::GetType(ULONG Reg)
{
    if (Reg >= X86_MM_FIRST && Reg <= X86_MM_LAST)
    {
        return REGVAL_INT64;
    }
    else if (Reg >= X86_XMM_FIRST && Reg <= X86_XMM_LAST)
    {
        return REGVAL_VECTOR128;
    }
    else if (Reg >= X86_ST_FIRST && Reg <= X86_ST_LAST)
    {
        return REGVAL_FLOAT10;
    }
    else if (Reg < X86_FLAGBASE)
    {
        return REGVAL_INT32;
    }
    else
    {
        return REGVAL_SUB32;
    }
}

HRESULT
X86MachineInfo::GetVal(ULONG Reg, REGVAL* Val)
{
    HRESULT Status;
    
    if (Reg >= X86_MM_FIRST && Reg <= X86_MM_LAST)
    {
        Val->Type = REGVAL_VECTOR64;
        GetMmxReg(Reg, Val);
    }
    else if (Reg >= X86_XMM_FIRST && Reg <= X86_XMM_LAST)
    {
        if ((Status = GetContextState(MCTX_CONTEXT)) != S_OK)
        {
            return Status;
        }
        
        Val->Type = REGVAL_VECTOR128;
        memcpy(Val->Bytes, m_Context.X86Nt5Context.FxSave.Reserved3 +
               (Reg - X86_XMM_FIRST) * 16, 16);
    }
    else if (Reg >= X86_ST_FIRST && Reg <= X86_ST_LAST)
    {
        Val->Type = REGVAL_FLOAT10;
        GetFloatReg(Reg, Val);
    }
    else if (Reg < X86_FLAGBASE)
    {
        Val->Type = REGVAL_INT32;
        Val->I64 = (ULONG64)(LONG64)(LONG)GetIntReg(Reg);
    }
    else
    {
        ErrOut("X86MachineInfo::GetVal: "
               "unknown register %lx requested\n", Reg);
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
X86MachineInfo::SetVal(ULONG Reg, REGVAL* Val)
{
    HRESULT Status;
    
    if (m_ContextIsReadOnly)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    
    if (Reg >= X86_FLAGBASE)
    {
        return E_INVALIDARG;
    }

    // Optimize away some common cases where registers are
    // set to their current value.
    if ((m_ContextState >= MCTX_PC && Reg == X86_EIP &&
         Val->I32 == m_Context.X86Nt5Context.Eip) ||
        (((m_ContextState >= MCTX_DR67_REPORT &&
           m_ContextState <= MCTX_REPORT) ||
          m_ContextState >= MCTX_FULL) && Reg == X86_DR7 &&
         Val->I32 == m_Context.X86Nt5Context.Dr7))
    {
        return S_OK;
    }
    
    if ((Status = GetContextState(MCTX_DIRTY)) != S_OK)
    {
        return Status;
    }

    if (Reg >= X86_MM_FIRST && Reg <= X86_MM_LAST)
    {
        *(ULONG64 UNALIGNED *)GetMmxRegSlot(Reg) = Val->I64;
        goto Notify;
    }
    else if (Reg >= X86_XMM_FIRST && Reg <= X86_XMM_LAST)
    {
        memcpy(m_Context.X86Nt5Context.FxSave.Reserved3 +
               (Reg - X86_XMM_FIRST) * 16, Val->Bytes, 16);
        goto Notify;
    }
    else if (Reg >= X86_ST_FIRST && Reg <= X86_ST_LAST)
    {
        memcpy(m_Context.X86Nt5Context.FloatSave.RegisterArea +
               10 * (Reg - X86_ST_FIRST), Val->F10, sizeof(Val->F10));
        goto Notify;
    }

    BOOL Recognized;

    Recognized = TRUE;
    
    switch(Reg)
    {
    case X86_GS:
        m_Context.X86Nt5Context.SegGs = Val->I16;
        m_SegRegDesc[SEGREG_GS].Flags = SEGDESC_INVALID;
        break;
    case X86_FS:
        m_Context.X86Nt5Context.SegFs = Val->I16;
        m_SegRegDesc[SEGREG_FS].Flags = SEGDESC_INVALID;
        break;
    case X86_ES:
        m_Context.X86Nt5Context.SegEs = Val->I16;
        m_SegRegDesc[SEGREG_ES].Flags = SEGDESC_INVALID;
        break;
    case X86_DS:
        m_Context.X86Nt5Context.SegDs = Val->I16;
        m_SegRegDesc[SEGREG_DATA].Flags = SEGDESC_INVALID;
        break;
    case X86_EDI:
        m_Context.X86Nt5Context.Edi = Val->I32;
        break;
    case X86_ESI:
        m_Context.X86Nt5Context.Esi = Val->I32;
        break;
    case X86_EBX:
        m_Context.X86Nt5Context.Ebx = Val->I32;
        break;
    case X86_EDX:
        m_Context.X86Nt5Context.Edx = Val->I32;
        break;
    case X86_ECX:
        m_Context.X86Nt5Context.Ecx = Val->I32;
        break;
    case X86_EAX:
        m_Context.X86Nt5Context.Eax = Val->I32;
        break;
    case X86_EBP:
        m_Context.X86Nt5Context.Ebp = Val->I32;
        break;
    case X86_EIP:
        m_Context.X86Nt5Context.Eip = Val->I32;
        break;
    case X86_CS:
        m_Context.X86Nt5Context.SegCs = Val->I16;
        m_SegRegDesc[SEGREG_CODE].Flags = SEGDESC_INVALID;
        break;
    case X86_EFL:
        if (IS_KERNEL_TARGET(m_Target))
        {
            // leave TF clear
            m_Context.X86Nt5Context.EFlags = Val->I32 & ~0x100;
        }
        else
        {
            // allow TF set
            m_Context.X86Nt5Context.EFlags = Val->I32;
        }
        break;
    case X86_ESP:
        m_Context.X86Nt5Context.Esp = Val->I32;
        break;
    case X86_SS:
        m_Context.X86Nt5Context.SegSs = Val->I16;
        m_SegRegDesc[SEGREG_STACK].Flags = SEGDESC_INVALID;
        break;

    case X86_DR0:
        m_Context.X86Nt5Context.Dr0 = Val->I32;
        break;
    case X86_DR1:
        m_Context.X86Nt5Context.Dr1 = Val->I32;
        break;
    case X86_DR2:
        m_Context.X86Nt5Context.Dr2 = Val->I32;
        break;
    case X86_DR3:
        m_Context.X86Nt5Context.Dr3 = Val->I32;
        break;
    case X86_DR6:
        m_Context.X86Nt5Context.Dr6 = Val->I32;
        break;
    case X86_DR7:
        m_Context.X86Nt5Context.Dr7 = Val->I32;
        break;

    case X86_FPCW:
        m_Context.X86Nt5Context.FloatSave.ControlWord =
            (m_Context.X86Nt5Context.FloatSave.ControlWord & 0xffff0000) |
            (Val->I32 & 0xffff);
        break;
    case X86_FPSW:
        m_Context.X86Nt5Context.FloatSave.StatusWord =
            (m_Context.X86Nt5Context.FloatSave.StatusWord & 0xffff0000) |
            (Val->I32 & 0xffff);
        break;
    case X86_FPTW:
        m_Context.X86Nt5Context.FloatSave.TagWord =
            (m_Context.X86Nt5Context.FloatSave.TagWord & 0xffff0000) |
            (Val->I32 & 0xffff);
        break;
    case X86_MXCSR:
        m_Context.X86Nt5Context.FxSave.MXCsr = Val->I32;
        break;
    default:
        Recognized = FALSE;
        break;
    }
        
    if (!Recognized && IS_KERNEL_TARGET(m_Target))
    {
        Recognized = TRUE;
        
        switch(Reg)
        {
        case X86_CR0:
            m_Special.X86Special.Cr0 = Val->I32;
            break;
        case X86_CR2:
            m_Special.X86Special.Cr2 = Val->I32;
            break;
        case X86_CR3:
            m_Special.X86Special.Cr3 = Val->I32;
            break;
        case X86_CR4:
            m_Special.X86Special.Cr4 = Val->I32;
            break;
        case X86_GDTR:
            m_Special.X86Special.Gdtr.Base = Val->I32;
            break;
        case X86_GDTL:
            m_Special.X86Special.Gdtr.Limit = (USHORT)Val->I32;
            break;
        case X86_IDTR:
            m_Special.X86Special.Idtr.Base = Val->I32;
            break;
        case X86_IDTL:
            m_Special.X86Special.Idtr.Limit = (USHORT)Val->I32;
            break;
        case X86_TR:
            m_Special.X86Special.Tr = (USHORT)Val->I32;
            break;
        case X86_LDTR:
            m_Special.X86Special.Ldtr = (USHORT)Val->I32;
            break;

        default:
            Recognized = FALSE;
            break;
        }
    }

    if (!Recognized)
    {
        ErrOut("X86MachineInfo::SetVal: "
               "unknown register %lx requested\n", Reg);
        return E_INVALIDARG;
    }

 Notify:
    NotifyChangeDebuggeeState(DEBUG_CDS_REGISTERS,
                              RegCountFromIndex(Reg));
    return S_OK;
}

void
X86MachineInfo::GetPC (PADDR Address)
{
    FormAddr(SEGREG_CODE, EXTEND64(GetIntReg(X86_EIP)),
             FORM_CODE | FORM_SEGREG | X86_FORM_VM86(GetIntReg(X86_EFL)),
             Address);
}

void
X86MachineInfo::SetPC (PADDR paddr)
{
    REGVAL Val;

    // We set the EIP to the offset (the non-translated value),
    // because we may not be in "flat" mode !!!

    Val.Type = REGVAL_INT32;
    Val.I32 = (ULONG)Off(*paddr);
    SetVal(X86_EIP, &Val);
}

void
X86MachineInfo::GetFP(PADDR Addr)
{
    FormAddr(SEGREG_STACK, EXTEND64(GetIntReg(X86_EBP)),
             FORM_SEGREG | X86_FORM_VM86(GetIntReg(X86_EFL)), Addr);
}

void
X86MachineInfo::GetSP(PADDR Addr)
{
    FormAddr(SEGREG_STACK, EXTEND64(GetIntReg(X86_ESP)),
             FORM_SEGREG | X86_FORM_VM86(GetIntReg(X86_EFL)), Addr);
}

ULONG64
X86MachineInfo::GetArgReg(void)
{
    return (ULONG64)(LONG64)(LONG)GetIntReg(X86_EAX);
}

ULONG64
X86MachineInfo::GetRetReg(void)
{
    return (ULONG64)(LONG64)(LONG)GetIntReg(X86_EAX);
}

ULONG
X86MachineInfo::GetSegRegNum(ULONG SegReg)
{
    switch(SegReg)
    {
    case SEGREG_CODE:
        return X86_CS;
    case SEGREG_DATA:
        return X86_DS;
    case SEGREG_STACK:
        return X86_SS;
    case SEGREG_ES:
        return X86_ES;
    case SEGREG_FS:
        return X86_FS;
    case SEGREG_GS:
        return X86_GS;
    case SEGREG_LDT:
        return X86_LDTR;
    }

    return 0;
}

HRESULT
X86MachineInfo::GetSegRegDescriptor(ULONG SegReg, PDESCRIPTOR64 Desc)
{
    if (SegReg == SEGREG_GDT)
    {
        Desc->Base = EXTEND64(GetIntReg(X86_GDTR));
        Desc->Limit = GetIntReg(X86_GDTL);
        Desc->Flags = 0;
        return S_OK;
    }

    // Check and see if we already have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    HRESULT Status;

    // Attempt to retrieve segment descriptors directly.
    if ((Status = GetContextState(MCTX_FULL)) != S_OK)
    {
        return Status;
    }
    
    // Check and see if we now have a cached descriptor.
    if (m_SegRegDesc[SegReg].Flags != SEGDESC_INVALID)
    {
        *Desc = m_SegRegDesc[SegReg];
        return S_OK;
    }

    //
    // Direct information is not available so look things up
    // in the descriptor tables.
    //
    
    ULONG RegNum = GetSegRegNum(SegReg);
    if (RegNum == 0)
    {
        return E_INVALIDARG;
    }

    // Do a quick sanity test to prevent bad values
    // from causing problems.
    ULONG Selector = GetIntReg(RegNum);
    if (SegReg == SEGREG_LDT && (Selector & 4))
    {
        // The ldtr selector says that it's an LDT selector,
        // which is invalid.  An LDT selector should always
        // reference the GDT.
        ErrOut("Invalid LDTR contents: %04X\n", Selector);
        return E_FAIL;
    }
        
    return m_Target->GetSelDescriptor(m_Target->m_RegContextThread,
                                      this, Selector, Desc);
}

/*** X86OutputAll - output all registers and present instruction
*
*   Purpose:
*       To output the current register state of the processor.
*       All integer registers are output as well as processor status
*       registers.  Important flag fields are also output separately.
*
*   Input:
*       Mask - Which information to display.
*
*   Output:
*       None.
*
*************************************************************************/

void
X86MachineInfo::OutputAll(ULONG Mask, ULONG OutMask)
{
    if (GetContextState(MCTX_FULL) != S_OK)
    {
        ErrOut("Unable to retrieve register information\n");
        return;
    }
    
    if (Mask & (REGALL_INT32 | REGALL_INT64))
    {
        ULONG efl;

        MaskOut(OutMask, "eax=%08lx ebx=%08lx ecx=%08lx "
                "edx=%08lx esi=%08lx edi=%08lx\n",
                GetIntReg(X86_EAX),
                GetIntReg(X86_EBX),
                GetIntReg(X86_ECX),
                GetIntReg(X86_EDX),
                GetIntReg(X86_ESI),
                GetIntReg(X86_EDI));

        efl = GetIntReg(X86_EFL);
        MaskOut(OutMask, "eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx "
                "%s %s %s %s %s %s %s %s %s %s\n",
                GetIntReg(X86_EIP),
                GetIntReg(X86_ESP),
                GetIntReg(X86_EBP),
                ((efl >> X86_SHIFT_FLAGIOPL) & X86_BIT_FLAGIOPL),
                (efl & X86_BIT_FLAGVIP) ? "vip" : "   ",
                (efl & X86_BIT_FLAGVIF) ? "vif" : "   ",
                (efl & X86_BIT_FLAGOF) ? "ov" : "nv",
                (efl & X86_BIT_FLAGDF) ? "dn" : "up",
                (efl & X86_BIT_FLAGIF) ? "ei" : "di",
                (efl & X86_BIT_FLAGSF) ? "ng" : "pl",
                (efl & X86_BIT_FLAGZF) ? "zr" : "nz",
                (efl & X86_BIT_FLAGAF) ? "ac" : "na",
                (efl & X86_BIT_FLAGPF) ? "po" : "pe",
                (efl & X86_BIT_FLAGCF) ? "cy" : "nc");
    }

    if (Mask & REGALL_SEGREG)
    {
        MaskOut(OutMask, "cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  "
                "gs=%04lx             efl=%08lx\n",
                GetIntReg(X86_CS),
                GetIntReg(X86_SS),
                GetIntReg(X86_DS),
                GetIntReg(X86_ES),
                GetIntReg(X86_FS),
                GetIntReg(X86_GS),
                GetIntReg(X86_EFL));
    }

    if (Mask & REGALL_FLOAT)
    {
        ULONG i;
        REGVAL val;
        char buf[32];

        MaskOut(OutMask, "fpcw=%04X    fpsw=%04X    fptw=%04X\n",
                GetIntReg(X86_FPCW),
                GetIntReg(X86_FPSW),
                GetIntReg(X86_FPTW));
        
        for (i = X86_ST_FIRST; i <= X86_ST_LAST; i++)
        {
            GetFloatReg(i, &val);
            _uldtoa((_ULDOUBLE *)&val.F10, sizeof(buf), buf);
            MaskOut(OutMask, "st%d=%s  ", i - X86_ST_FIRST, buf);
            i++;
            GetFloatReg(i, &val);
            _uldtoa((_ULDOUBLE *)&val.F10, sizeof(buf), buf);
            MaskOut(OutMask, "st%d=%s\n", i - X86_ST_FIRST, buf);
        }
    }

    if (Mask & REGALL_MMXREG)
    {
        ULONG i;
        REGVAL val;

        for (i = X86_MM_FIRST; i <= X86_MM_LAST; i++)
        {
            GetMmxReg(i, &val);
            MaskOut(OutMask, "mm%d=%08x%08x  ",
                    i - X86_MM_FIRST,
                    val.I64Parts.High, val.I64Parts.Low);
            i++;
            GetMmxReg(i, &val);
            MaskOut(OutMask, "mm%d=%08x%08x\n",
                    i - X86_MM_FIRST,
                    val.I64Parts.High, val.I64Parts.Low);
        }
    }

    if (Mask & REGALL_XMMREG)
    {
        ULONG i;
        REGVAL Val;

        for (i = X86_XMM_FIRST; i <= X86_XMM_LAST; i++)
        {
            GetVal(i, &Val);
            MaskOut(OutMask, "xmm%d=%hg %hg %hg %hg\n", i - X86_XMM_FIRST,
                    *(float *)&Val.Bytes[3 * sizeof(float)],
                    *(float *)&Val.Bytes[2 * sizeof(float)],
                    *(float *)&Val.Bytes[1 * sizeof(float)],
                    *(float *)&Val.Bytes[0 * sizeof(float)]);
        }
    }

    if (Mask & REGALL_CREG)
    {
        MaskOut(OutMask, "cr0=%08lx cr2=%08lx cr3=%08lx\n",
                GetIntReg(X86_CR0),
                GetIntReg(X86_CR2),
                GetIntReg(X86_CR3));
    }

    if (Mask & REGALL_DREG)
    {
        MaskOut(OutMask, "dr0=%08lx dr1=%08lx dr2=%08lx\n",
                GetIntReg(X86_DR0),
                GetIntReg(X86_DR1),
                GetIntReg(X86_DR2));
        MaskOut(OutMask, "dr3=%08lx dr6=%08lx dr7=%08lx",
                GetIntReg(X86_DR3),
                GetIntReg(X86_DR6),
                GetIntReg(X86_DR7));
        if (IS_USER_TARGET(m_Target))
        {
            MaskOut(OutMask, "\n");
        }
        else
        {
            MaskOut(OutMask, " cr4=%08lx\n", GetIntReg(X86_CR4));
        }
    }

    if (Mask & REGALL_DESC)
    {
        MaskOut(OutMask, "gdtr=%08lx   gdtl=%04lx idtr=%08lx   idtl=%04lx "
                "tr=%04lx  ldtr=%04x\n",
                GetIntReg(X86_GDTR),
                GetIntReg(X86_GDTL),
                GetIntReg(X86_IDTR),
                GetIntReg(X86_IDTL),
                GetIntReg(X86_TR),
                GetIntReg(X86_LDTR));
    }
}

HRESULT
X86MachineInfo::SetAndOutputTrapFrame(ULONG64 TrapBase,
                                      PCROSS_PLATFORM_CONTEXT Context)
{
    HRESULT Status;
    X86_KTRAP_FRAME TrapContents;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           TrapBase, &TrapContents,
                                           sizeof(TrapContents))) != S_OK)
    {
        ErrOut("Unable to read trap frame at %s\n",
               FormatMachineAddr64(this, TrapBase));
        return Status;
    }

    //
    // Check to see if Esp has been edited, and dump new value if it has
    //
    if ((!(TrapContents.EFlags & X86_EFLAGS_V86_MASK)) &&
        ((TrapContents.SegCs & X86_MODE_MASK) == 0 /*KernelMode*/))
    {
        if ((TrapContents.SegCs & X86_FRAME_EDITED) == 0)
        {
            dprintf("ESP EDITED! New esp=%08lx\n", TrapContents.TempEsp);
        }
    }

    dprintf("ErrCode = %08lx\n", TrapContents.ErrCode);

    return SetAndOutputContext(Context, TRUE, REGALL_INT32 | REGALL_SEGREG);
}

HRESULT
X86MachineInfo::SetAndOutputTaskSegment(ULONG64 TssBase,
                                        PCROSS_PLATFORM_CONTEXT Context,
                                        BOOL Extended)
{
    HRESULT Status;
    X86_KTSS TSS;
    ULONG i;

    if ((Status = m_Target->ReadAllVirtual(m_Target->m_ProcessHead,
                                           TssBase, &TSS,
                                           sizeof(TSS))) != S_OK)
    {
        ErrOut("Unable to read Task State Segment from host address %s\n",
               FormatMachineAddr64(this, TssBase));
        return Status;
    }

    //
    // Display it.
    //

    if (Extended)
    {
        dprintf("\nTask State Segment 0x%p\n\n", TssBase);
        dprintf("Previous Task Link   = %4x\n", TSS.Previous);
        for (i = 0 ; i < X86_MAX_RING; i++)
        {
            dprintf("Esp%d = %8x  SS%d = %4x\n",
                    i, TSS.Ring[i].Esp,
                    i, TSS.Ring[i].Ss & 0xffff);
        }
        dprintf("CR3 (PDBR)           = %08x\n", TSS.Cr3);
        dprintf("I/O Map Base Address = %4x, Debug Trap (T) = %s\n",
                TSS.IoMapBase,
                TSS.T == 0 ? "False" : "True");
        dprintf("\nSaved General Purpose Registers\n\n");
    }

    return SetAndOutputContext(Context, TRUE, REGALL_INT32 | REGALL_SEGREG);
}

TRACEMODE
X86MachineInfo::GetTraceMode (void)
{
    if (IS_KERNEL_TARGET(m_Target))
    {
        return m_TraceMode;
    }
    else
    {
        return ((GetIntReg(X86_EFL) & X86_BIT_FLAGTF) != 0) ? 
                    TRACE_INSTRUCTION : TRACE_NONE;
    }
}

void 
X86MachineInfo::SetTraceMode (TRACEMODE Mode)
{
    DBG_ASSERT(Mode == TRACE_NONE ||
               Mode == TRACE_INSTRUCTION ||
               (IS_KERNEL_TARGET(m_Target) && m_SupportsBranchTrace &&
                Mode == TRACE_TAKEN_BRANCH));

    if (IS_KERNEL_TARGET(m_Target))
    {
        m_TraceMode = Mode;
    }
    else
    {
        ULONG Efl = GetIntReg(X86_EFL);
        switch (Mode)
        {
        case TRACE_NONE:
            Efl &= ~X86_BIT_FLAGTF;
            break;
        case TRACE_INSTRUCTION:
            Efl |= X86_BIT_FLAGTF;
            break;
        }    
        SetReg32(X86_EFL, Efl);
    }
}

BOOL
X86MachineInfo::IsStepStatusSupported(ULONG Status)
{
    switch(Status) 
    {
    case DEBUG_STATUS_STEP_INTO:
    case DEBUG_STATUS_STEP_OVER:
        return TRUE;
    case DEBUG_STATUS_STEP_BRANCH:
        return IS_KERNEL_TARGET(m_Target) && m_SupportsBranchTrace;
    default:
        return FALSE;
    }
}

void
X86MachineInfo::KdUpdateControlSet
    (PDBGKD_ANY_CONTROL_SET ControlSet)
{
    TRACEMODE TraceMode = GetTraceMode();
    ULONG64 DebugCtlMsr;
    
    ControlSet->X86ControlSet.TraceFlag = TraceMode != TRACE_NONE;
    ControlSet->X86ControlSet.Dr7 = GetIntReg(X86_DR7);

    // We assume that branch tracing is off by default so if
    // we haven't turned branch tracing on there's no need
    // to do a RMW cycle on the control MSR.  This saves two
    // protocol transactions per step.
    // The processor turns off the branch-trace and branch-record
    // flags on every debug trap.  That's not quite good enough
    // as we may need to go back to instruction tracing after an
    // AV or non-debug trap.
    if (TraceMode != TRACE_NONE &&
        m_SupportsBranchTrace &&
        (TraceMode == TRACE_TAKEN_BRANCH || m_ResetBranchTrace) &&
        m_Target->ReadMsr(X86_MSR_DEBUG_CTL, &DebugCtlMsr) == S_OK)
    {
        if (TraceMode == TRACE_TAKEN_BRANCH)
        {
            DebugCtlMsr |= (X86_DEBUG_CTL_BRANCH_TRACE |
                            X86_DEBUG_CTL_LAST_BRANCH_RECORD);
            m_ResetBranchTrace = TRUE;
        }
        else
        {
            DebugCtlMsr &= ~(X86_DEBUG_CTL_BRANCH_TRACE |
                             X86_DEBUG_CTL_LAST_BRANCH_RECORD);
            m_ResetBranchTrace = FALSE;
        }
        m_Target->WriteMsr(X86_MSR_DEBUG_CTL, DebugCtlMsr);
    }
    
    BpOut("UpdateControlSet(%d) trace %d, DR7 %X\n",
          m_Target->m_RegContextProcessor, ControlSet->X86ControlSet.TraceFlag,
          ControlSet->X86ControlSet.Dr7);

    if (!g_WatchFunctions.IsStarted() && g_WatchBeginCurFunc != 1)
    {
        ControlSet->X86ControlSet.CurrentSymbolStart = 0;
        ControlSet->X86ControlSet.CurrentSymbolEnd = 0;
    }
    else
    {
        ControlSet->X86ControlSet.CurrentSymbolStart =
            (ULONG)g_WatchBeginCurFunc;
        ControlSet->X86ControlSet.CurrentSymbolEnd =
            (ULONG)g_WatchEndCurFunc;
    }
}

ULONG
X86MachineInfo::ExecutingMachine(void)
{
    return IMAGE_FILE_MACHINE_I386;
}

HRESULT
X86MachineInfo::SetPageDirectory(ThreadInfo* Thread,
                                 ULONG Idx, ULONG64 PageDir,
                                 PULONG NextIdx)
{
    HRESULT Status;
    ULONG ValidMask;
    
    // Figure out which bits will be valid in the value.
    if (m_Target->m_KdDebuggerData.PaeEnabled)
    {
        ValidMask = X86_PDBR_MASK;
    }
    else
    {
        ValidMask = X86_VALID_PFN_MASK;
    }
    
    *NextIdx = PAGE_DIR_COUNT;
    
    if (PageDir == 0)
    {
        if (m_Target->m_ActualSystemVersion > XBOX_SVER_START &&
            m_Target->m_ActualSystemVersion < XBOX_SVER_END)
        {
            // XBox has only one page directory in CR3 for everything.
            // The process doesn't have a dirbase entry.
            PageDir = GetReg32(X86_CR3) & ValidMask;
            if (PageDir == 0)
            {
                // Register retrieval failure.
                return E_FAIL;
            }
        }
        else
        {
            // Assume NT structures.
            if ((Status = m_Target->ReadImplicitProcessInfoPointer
                 (Thread,
                  m_Target->m_KdDebuggerData.OffsetEprocessDirectoryTableBase,
                  &PageDir)) != S_OK)
            {
                return Status;
            }

            PageDir &= ValidMask;
        }

        if (m_Target->m_ImplicitProcessDataIsDefault &&
            Thread == m_Target->m_RegContextThread &&
            !IS_LOCAL_KERNEL_TARGET(m_Target))
        {
            // Verify that the process dirbase matches the CR3 setting
            // as a sanity check.
            ULONG Cr3 = GetReg32(X86_CR3) & ValidMask;
            if (Cr3 && Cr3 != (ULONG)PageDir)
            {
                WarnOut("WARNING: Process directory table base %08X "
                        "doesn't match CR3 %08X\n",
                        (ULONG)PageDir, Cr3);
            }
        }
    }
    else
    {
        PageDir &= ValidMask;
    }

    // There is only one page directory so update all the slots.
    m_PageDirectories[PAGE_DIR_USER] = PageDir;
    m_PageDirectories[PAGE_DIR_SESSION] = PageDir;
    m_PageDirectories[PAGE_DIR_KERNEL] = PageDir;
    
    return S_OK;
}

#define X86_PAGE_FILE_INDEX(Entry) \
    (((ULONG)(Entry) >> 1) & MAX_PAGING_FILE_MASK)
#define X86_PAGE_FILE_OFFSET(Entry) \
    (((Entry) >> 12) << X86_PAGE_SHIFT)

HRESULT
X86MachineInfo::GetVirtualTranslationPhysicalOffsets(ThreadInfo* Thread,
                                                     ULONG64 Virt,
                                                     PULONG64 Offsets,
                                                     ULONG OffsetsSize,
                                                     PULONG Levels,
                                                     PULONG PfIndex,
                                                     PULONG64 LastVal)
{
    ULONG64 Addr;
    HRESULT Status;

    *Levels = 0;
    
    if (m_Translating)
    {
        return E_UNEXPECTED;
    }
    m_Translating = TRUE;
    
    //
    // throw away top 32 bits on X86.
    //
    Virt &= 0x00000000FFFFFFFF;

    //
    // Reset the page directory in case it was 0
    //
    if (m_PageDirectories[PAGE_DIR_SINGLE] == 0)
    {
        if ((Status = SetDefaultPageDirectories(Thread,
                                                1 << PAGE_DIR_SINGLE)) != S_OK)
        {
            m_Translating = FALSE;
            return Status;
        }
    }

    KdOut("X86VtoP: Virt %s, pagedir %s\n",
          FormatMachineAddr64(this, Virt),
          FormatDisp64(m_PageDirectories[PAGE_DIR_SINGLE]));
    
    (*Levels)++;
    if (Offsets != NULL && OffsetsSize > 0)
    {
        *Offsets++ = m_PageDirectories[PAGE_DIR_SINGLE];
        OffsetsSize--;
    }
        
    // This routine uses the fact that the PFN shift is the same
    // as the page shift to simplify some expressions.
    C_ASSERT(X86_VALID_PFN_SHIFT == X86_PAGE_SHIFT);

    if (m_Target->m_KdDebuggerData.PaeEnabled)
    {
        ULONG64 Pdpe;
        ULONG64 Entry;

        KdOut("  x86VtoP: PaeEnabled\n");

        // Read the Page Directory Pointer entry.

        Pdpe = ((Virt >> X86_PDPE_SHIFT) * sizeof(Entry)) +
            m_PageDirectories[PAGE_DIR_SINGLE];

        KdOut("X86VtoP: PAE PDPE %s\n", FormatDisp64(Pdpe));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Pdpe;
            OffsetsSize--;
        }
        
        if ((Status = m_Target->
             ReadAllPhysical(Pdpe, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("X86VtoP: PAE PDPE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }

        // Read the Page Directory entry.
        
        Addr = (((Virt >> X86_PDE_SHIFT_PAE) & X86_PDE_MASK_PAE) *
                sizeof(Entry)) + (Entry & X86_VALID_PFN_MASK_PAE);

        KdOut("X86VtoP: PAE PDE %s\n", FormatDisp64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = m_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("X86VtoP: PAE PDE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }
        
        // Check for a large page.  Large pages can
        // never be paged out so also check for the present bit.
        if ((Entry & (X86_LARGE_PAGE_MASK | 1)) == (X86_LARGE_PAGE_MASK | 1))
        {
            //
            // If we have a large page and this is a summary dump, then
            // the page may span multiple physical pages that may -- because
            // of how the summary dump is written -- not be included in the
            // dump. Fixup the large page address to its corresponding small
            // page address.
            //

            if (IS_KERNEL_SUMMARY_DUMP(m_Target))
            {
                ULONG SpannedPages;

                SpannedPages = (ULONG)
                    ((Virt & (X86_LARGE_PAGE_SIZE_PAE - 1)) >> X86_PAGE_SHIFT);
                *LastVal = ((Entry & ~(X86_LARGE_PAGE_SIZE_PAE - 1)) |
                             ((ULONG64)SpannedPages << X86_PAGE_SHIFT) |
                             (Virt & (X86_PAGE_SIZE - 1)));
            }
            else
            {
                *LastVal = ((Entry & ~(X86_LARGE_PAGE_SIZE_PAE - 1)) |
                             (Virt & (X86_LARGE_PAGE_SIZE_PAE - 1)));
            }
            
            KdOut("X86VtoP: PAE Large page mapped phys %s\n",
                  FormatDisp64(*LastVal));

            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = *LastVal;
                OffsetsSize--;
            }
        
            m_Translating = FALSE;
            return S_OK;
        }
        
        // Read the Page Table entry.

        if (Entry == 0)
        {
            KdOut("X86VtoP: PAE zero PDE\n");
            m_Translating = FALSE;
            return HR_PAGE_NOT_AVAILABLE;
        }
        else if (!(Entry & 1))
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK_PAE) *
                    sizeof(Entry)) + X86_PAGE_FILE_OFFSET(Entry);

            KdOut("X86VtoP: pagefile PAE PTE %d:%s\n",
                  X86_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
            
            if ((Status = m_Target->
                 ReadPageFile(X86_PAGE_FILE_INDEX(Entry), Addr,
                              &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PAE PDE not present, 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        else
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK_PAE) *
                    sizeof(Entry)) + (Entry & X86_VALID_PFN_MASK_PAE);

            KdOut("X86VtoP: PAE PTE %s\n", FormatDisp64(Addr));
    
            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = Addr;
                OffsetsSize--;
            }
        
            if ((Status = m_Target->
                 ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PAE PTE read error 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        
        if (!(Entry & 0x1) &&
            ((Entry & X86_MM_PTE_PROTOTYPE_MASK) ||
             !(Entry & X86_MM_PTE_TRANSITION_MASK)))
        {
            if (Entry == 0)
            {
                KdOut("X86VtoP: PAE zero PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else if (Entry & X86_MM_PTE_PROTOTYPE_MASK)
            {
                KdOut("X86VtoP: PAE prototype PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else
            {
                *PfIndex = X86_PAGE_FILE_INDEX(Entry);
                *LastVal = (Virt & (X86_PAGE_SIZE - 1)) +
                    X86_PAGE_FILE_OFFSET(Entry);
                KdOut("X86VtoP: PAE PTE not present, pagefile %d:%s\n",
                      *PfIndex, FormatDisp64(*LastVal));
                Status = HR_PAGE_IN_PAGE_FILE;
            }
            m_Translating = FALSE;
            return Status;
        }

        *LastVal = ((Entry & X86_VALID_PFN_MASK_PAE) |
                     (Virt & (X86_PAGE_SIZE - 1)));
    
        KdOut("X86VtoP: PAE Mapped phys %s\n",
              FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
    else
    {
        ULONG Entry;

        // Read the Page Directory entry.
        
        Addr = ((Virt >> X86_PDE_SHIFT) * sizeof(Entry)) +
            m_PageDirectories[PAGE_DIR_SINGLE];

        KdOut("X86VtoP: PDE %s\n", FormatDisp64(Addr));
    
        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = Addr;
            OffsetsSize--;
        }
        
        if ((Status = m_Target->
             ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
        {
            KdOut("X86VtoP: PDE read error 0x%X\n", Status);
            m_Translating = FALSE;
            return Status;
        }

        // Check for a large page.  Large pages can
        // never be paged out so also check for the present bit.
        if ((Entry & (X86_LARGE_PAGE_MASK | 1)) == (X86_LARGE_PAGE_MASK | 1))
        {
            *LastVal = ((Entry & ~(X86_LARGE_PAGE_SIZE - 1)) |
                         (Virt & (X86_LARGE_PAGE_SIZE - 1)));
            
            KdOut("X86VtoP: Large page mapped phys %s\n",
                  FormatDisp64(*LastVal));

            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = *LastVal;
                OffsetsSize--;
            }
        
            m_Translating = FALSE;
            return S_OK;
        }
        
        // Read the Page Table entry.

        if (Entry == 0)
        {
            KdOut("X86VtoP: zero PDE\n");
            m_Translating = FALSE;
            return HR_PAGE_NOT_AVAILABLE;
        }
        else if (!(Entry & 1))
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK) *
                    sizeof(Entry)) + X86_PAGE_FILE_OFFSET(Entry);

            KdOut("X86VtoP: pagefile PTE %d:%s\n",
                  X86_PAGE_FILE_INDEX(Entry), FormatDisp64(Addr));
    
            if ((Status = m_Target->
                 ReadPageFile(X86_PAGE_FILE_INDEX(Entry), Addr,
                              &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PDE not present, 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        else
        {
            Addr = (((Virt >> X86_PTE_SHIFT) & X86_PTE_MASK) *
                   sizeof(Entry)) + (Entry & X86_VALID_PFN_MASK);

            KdOut("X86VtoP: PTE %s\n", FormatDisp64(Addr));
    
            (*Levels)++;
            if (Offsets != NULL && OffsetsSize > 0)
            {
                *Offsets++ = Addr;
                OffsetsSize--;
            }
        
            if ((Status = m_Target->
                 ReadAllPhysical(Addr, &Entry, sizeof(Entry))) != S_OK)
            {
                KdOut("X86VtoP: PTE read error 0x%X\n", Status);
                m_Translating = FALSE;
                return Status;
            }
        }
        
        if (!(Entry & 0x1) &&
            ((Entry & X86_MM_PTE_PROTOTYPE_MASK) ||
             !(Entry & X86_MM_PTE_TRANSITION_MASK)))
        {
            if (Entry == 0)
            {
                KdOut("X86VtoP: zero PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else if (Entry & X86_MM_PTE_PROTOTYPE_MASK)
            {
                KdOut("X86VtoP: prototype PTE\n");
                Status = HR_PAGE_NOT_AVAILABLE;
            }
            else
            {
                *PfIndex = X86_PAGE_FILE_INDEX(Entry);
                *LastVal = (Virt & (X86_PAGE_SIZE - 1)) +
                    X86_PAGE_FILE_OFFSET(Entry);
                KdOut("X86VtoP: PTE not present, pagefile %d:%s\n",
                      *PfIndex, FormatDisp64(*LastVal));
                Status = HR_PAGE_IN_PAGE_FILE;
            }
            m_Translating = FALSE;
            return Status;
        }

        *LastVal = ((Entry & X86_VALID_PFN_MASK) |
                     (Virt & (X86_PAGE_SIZE - 1)));
    
        KdOut("X86VtoP: Mapped phys %s\n", FormatDisp64(*LastVal));

        (*Levels)++;
        if (Offsets != NULL && OffsetsSize > 0)
        {
            *Offsets++ = *LastVal;
            OffsetsSize--;
        }
        
        m_Translating = FALSE;
        return S_OK;
    }
}

HRESULT
X86MachineInfo::GetBaseTranslationVirtualOffset(PULONG64 Offset)
{
    if (m_Target->m_KdDebuggerData.PaeEnabled)
    {
        *Offset = EXTEND64(X86_BASE_VIRT_PAE);
    }
    else
    {
        *Offset = EXTEND64(X86_BASE_VIRT);
    }
    return S_OK;
}

void
X86MachineInfo::DecodePte(ULONG64 Pte, PULONG64 PageFrameNumber,
                          PULONG Flags)
{
    *PageFrameNumber = (Pte & X86_VALID_PFN_MASK) >> X86_PAGE_SHIFT;
    *Flags = (Pte & 1) ? MPTE_FLAG_VALID : 0;
}

void
X86MachineInfo::OutputFunctionEntry(PVOID RawEntry)
{
    PFPO_DATA FpoData = (PFPO_DATA)RawEntry;

    dprintf("OffStart: %08x\n", FpoData->ulOffStart);
    dprintf("ProcSize: 0x%x\n", FpoData->cbProcSize);
    switch(FpoData->cbFrame)
    {
    case FRAME_FPO:
        dprintf("Params:    %d\n", FpoData->cdwParams);
        dprintf("Locals:    %d\n", FpoData->cdwLocals);
        dprintf("Registers: %d\n", FpoData->cbRegs);

        if (FpoData->fHasSEH)
        {
            dprintf("Has SEH\n");
        }
        if (FpoData->fUseBP)
        {
            dprintf("Uses EBP\n");
        }
        break;

    case FRAME_NONFPO:
        dprintf("Non-FPO\n");
        break;

    case FRAME_TRAP:
        if (!IS_KERNEL_TARGET(m_Target))
        {
            goto UnknownFpo;
        }
        
        dprintf("Params: %d\n", FpoData->cdwParams);
        dprintf("Locals: %d\n", FpoData->cdwLocals);
        dprintf("Trap frame\n");
        break;

    case FRAME_TSS:
        if (!IS_KERNEL_TARGET(m_Target))
        {
            goto UnknownFpo;
        }

        dprintf("Task gate\n");
        break;

    default:
    UnknownFpo:
        dprintf("Unknown FPO type\n");
        break;
    }
}

HRESULT
X86MachineInfo::ReadKernelProcessorId
    (ULONG Processor, PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id)
{
    HRESULT Status;
    ULONG64 Prcb;
    ULONG Data;

    if ((Status = m_Target->
         GetProcessorSystemDataOffset(Processor, DEBUG_DATA_KPRCB_OFFSET,
                                      &Prcb)) != S_OK)
    {
        return Status;
    }

    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead,
                        Prcb + m_Target->m_KdDebuggerData.OffsetPrcbCpuType,
                        &Data, sizeof(Data))) != S_OK)
    {
        return Status;
    }

    Id->X86.Family = Data & 0xf;
    Id->X86.Model = (Data >> 24) & 0xf;
    Id->X86.Stepping = (Data >> 16) & 0xf;


    if ((Status = m_Target->
         ReadAllVirtual(m_Target->m_ProcessHead, Prcb +
                        m_Target->m_KdDebuggerData.OffsetPrcbVendorString,
                        Id->X86.VendorString, X86_VENDOR_STRING_SIZE)) != S_OK)
    {
        return Status;
    }

    return S_OK;
}

HRESULT
X86MachineInfo::GetAlternateTriageDumpDataRanges(ULONG64 PrcbBase,
                                                 ULONG64 ThreadBase,
                                                 PADDR_RANGE Ranges)
{
    PADDR_RANGE Range = Ranges;
    
    if (m_Target->ReadPointer(m_Target->m_ProcessHead, this, PrcbBase +
                              m_Target->m_KdDebuggerData.OffsetPrcbDpcRoutine,
                              &Range->Base) == S_OK &&
        Range->Base)
    {
        Range->Base = PAGE_ALIGN(this, Range->Base);
        Range->Size = m_PageSize;
        Range++;
    }
    else
    {
        Range->Base = 0;
    }

    return S_OK;
}

void
X86MachineInfo::KdGetSpecialRegistersFromContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);
    
    m_Special.X86Special.KernelDr0 = m_Context.X86Nt5Context.Dr0;
    m_Special.X86Special.KernelDr1 = m_Context.X86Nt5Context.Dr1;
    m_Special.X86Special.KernelDr2 = m_Context.X86Nt5Context.Dr2;
    m_Special.X86Special.KernelDr3 = m_Context.X86Nt5Context.Dr3;
    m_Special.X86Special.KernelDr6 = m_Context.X86Nt5Context.Dr6;
    m_Special.X86Special.KernelDr7 = m_Context.X86Nt5Context.Dr7;
}

void
X86MachineInfo::KdSetSpecialRegistersInContext(void)
{
    DBG_ASSERT(m_ContextState >= MCTX_FULL);
    
    m_Context.X86Nt5Context.Dr0 = m_Special.X86Special.KernelDr0;
    m_Context.X86Nt5Context.Dr1 = m_Special.X86Special.KernelDr1;
    m_Context.X86Nt5Context.Dr2 = m_Special.X86Special.KernelDr2;
    m_Context.X86Nt5Context.Dr3 = m_Special.X86Special.KernelDr3;
    m_Context.X86Nt5Context.Dr6 = m_Special.X86Special.KernelDr6;
    m_Context.X86Nt5Context.Dr7 = m_Special.X86Special.KernelDr7;
}

ULONG
X86MachineInfo::GetIntReg(ULONG regnum)
{
    switch (m_ContextState)
    {
    case MCTX_PC:
        if (regnum == X86_EIP)
        {
            return m_Context.X86Nt5Context.Eip;
        }
        goto MctxContext;
        
    case MCTX_DR67_REPORT:
        switch (regnum)
        {
        case X86_DR6:    return m_Context.X86Nt5Context.Dr6;
        case X86_DR7:    return m_Context.X86Nt5Context.Dr7;
        }
        goto MctxContext;

    case MCTX_REPORT:
        switch (regnum)
        {
        case X86_CS:     return (USHORT)m_Context.X86Nt5Context.SegCs;
        case X86_DS:     return (USHORT)m_Context.X86Nt5Context.SegDs;
        case X86_ES:     return (USHORT)m_Context.X86Nt5Context.SegEs;
        case X86_FS:     return (USHORT)m_Context.X86Nt5Context.SegFs;
        case X86_EIP:    return m_Context.X86Nt5Context.Eip;
        case X86_EFL:    return m_Context.X86Nt5Context.EFlags;
        case X86_DR6:    return m_Context.X86Nt5Context.Dr6;
        case X86_DR7:    return m_Context.X86Nt5Context.Dr7;
        }
        // Fallthrough!
        
    case MCTX_NONE:
    MctxContext:
        if (GetContextState(MCTX_CONTEXT) != S_OK)
        {
            return 0;
        }
        // Fallthrough!
        
    case MCTX_CONTEXT:
        switch (regnum)
        {
        case X86_CS:     return (USHORT)m_Context.X86Nt5Context.SegCs;
        case X86_DS:     return (USHORT)m_Context.X86Nt5Context.SegDs;
        case X86_ES:     return (USHORT)m_Context.X86Nt5Context.SegEs;
        case X86_FS:     return (USHORT)m_Context.X86Nt5Context.SegFs;
        case X86_EIP:    return m_Context.X86Nt5Context.Eip;
        case X86_EFL:    return m_Context.X86Nt5Context.EFlags;

        case X86_GS:     return (USHORT)m_Context.X86Nt5Context.SegGs;
        case X86_SS:     return (USHORT)m_Context.X86Nt5Context.SegSs;
        case X86_EDI:    return m_Context.X86Nt5Context.Edi;
        case X86_ESI:    return m_Context.X86Nt5Context.Esi;
        case X86_EBX:    return m_Context.X86Nt5Context.Ebx;
        case X86_EDX:    return m_Context.X86Nt5Context.Edx;
        case X86_ECX:    return m_Context.X86Nt5Context.Ecx;
        case X86_EAX:    return m_Context.X86Nt5Context.Eax;
        case X86_EBP:    return m_Context.X86Nt5Context.Ebp;
        case X86_ESP:    return m_Context.X86Nt5Context.Esp;

        case X86_FPCW:
            return m_Context.X86Nt5Context.FloatSave.ControlWord & 0xffff;
        case X86_FPSW:
            return m_Context.X86Nt5Context.FloatSave.StatusWord & 0xffff;
        case X86_FPTW:
            return m_Context.X86Nt5Context.FloatSave.TagWord & 0xffff;

        case X86_MXCSR:
            return m_Context.X86Nt5Context.FxSave.MXCsr;
        }

        //
        // The requested register is not in our current context, load up
        // a complete context
        //

        if (GetContextState(MCTX_FULL) != S_OK)
        {
            return 0;
        }
    }

    //
    // We must have a complete context...
    //

    switch (regnum)
    {
    case X86_GS:
        return (USHORT)m_Context.X86Nt5Context.SegGs;
    case X86_FS:
        return (USHORT)m_Context.X86Nt5Context.SegFs;
    case X86_ES:
        return (USHORT)m_Context.X86Nt5Context.SegEs;
    case X86_DS:
        return (USHORT)m_Context.X86Nt5Context.SegDs;
    case X86_EDI:
        return m_Context.X86Nt5Context.Edi;
    case X86_ESI:
        return m_Context.X86Nt5Context.Esi;
    case X86_SI:
        return(m_Context.X86Nt5Context.Esi & 0xffff);
    case X86_DI:
        return(m_Context.X86Nt5Context.Edi & 0xffff);
    case X86_EBX:
        return m_Context.X86Nt5Context.Ebx;
    case X86_EDX:
        return m_Context.X86Nt5Context.Edx;
    case X86_ECX:
        return m_Context.X86Nt5Context.Ecx;
    case X86_EAX:
        return m_Context.X86Nt5Context.Eax;
    case X86_EBP:
        return m_Context.X86Nt5Context.Ebp;
    case X86_EIP:
        return m_Context.X86Nt5Context.Eip;
    case X86_CS:
        return (USHORT)m_Context.X86Nt5Context.SegCs;
    case X86_EFL:
        return m_Context.X86Nt5Context.EFlags;
    case X86_ESP:
        return m_Context.X86Nt5Context.Esp;
    case X86_SS:
        return (USHORT)m_Context.X86Nt5Context.SegSs;

    case X86_DR0:
        return m_Context.X86Nt5Context.Dr0;
    case X86_DR1:
        return m_Context.X86Nt5Context.Dr1;
    case X86_DR2:
        return m_Context.X86Nt5Context.Dr2;
    case X86_DR3:
        return m_Context.X86Nt5Context.Dr3;
    case X86_DR6:
        return m_Context.X86Nt5Context.Dr6;
    case X86_DR7:
        return m_Context.X86Nt5Context.Dr7;

    case X86_FPCW:
        return m_Context.X86Nt5Context.FloatSave.ControlWord & 0xffff;
    case X86_FPSW:
        return m_Context.X86Nt5Context.FloatSave.StatusWord & 0xffff;
    case X86_FPTW:
        return m_Context.X86Nt5Context.FloatSave.TagWord & 0xffff;

    case X86_MXCSR:
        return m_Context.X86Nt5Context.FxSave.MXCsr;
    }
    
    if (IS_KERNEL_TARGET(m_Target))
    {
        switch(regnum)
        {
        case X86_CR0:
            return m_Special.X86Special.Cr0;
        case X86_CR2:
            return m_Special.X86Special.Cr2;
        case X86_CR3:
            return m_Special.X86Special.Cr3;
        case X86_CR4:
            return m_Special.X86Special.Cr4;
        case X86_GDTR:
            return m_Special.X86Special.Gdtr.Base;
        case X86_GDTL:
            return (ULONG)m_Special.X86Special.Gdtr.Limit;
        case X86_IDTR:
            return m_Special.X86Special.Idtr.Base;
        case X86_IDTL:
            return (ULONG)m_Special.X86Special.Idtr.Limit;
        case X86_TR:
            return (ULONG)m_Special.X86Special.Tr;
        case X86_LDTR:
            return (ULONG)m_Special.X86Special.Ldtr;
        }
    }

    ErrOut("X86MachineInfo::SetVal: "
           "unknown register %lx requested\n", regnum);
    return REG_ERROR;
}

PULONG64
X86MachineInfo::GetMmxRegSlot(ULONG regnum)
{
    return (PULONG64)(m_Context.X86Nt5Context.FloatSave.RegisterArea +
                      GetMmxRegOffset(regnum - X86_MM_FIRST,
                                      GetIntReg(X86_FPSW)) * 10);
}

void
X86MachineInfo::GetMmxReg(ULONG Reg, REGVAL* Val)
{
    if (GetContextState(MCTX_CONTEXT) == S_OK)
    {
        Val->I64 = *(ULONG64 UNALIGNED *)GetMmxRegSlot(Reg);
    }
}

void
X86MachineInfo::GetFloatReg(ULONG Reg, REGVAL* Val)
{
    if (GetContextState(MCTX_CONTEXT) == S_OK)
    {
        memcpy(Val->F10, m_Context.X86Nt5Context.FloatSave.RegisterArea +
               10 * (Reg - X86_ST_FIRST), sizeof(Val->F10));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\i386_dis.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

#define X86_REPN  0xf2
#define X86_REP   0xf3

#define X86_PAUSE        0x90
#define X86_MOVFREGMEM   0x110
#define X86_MOVFMEMREG   0x111
#define X86_MOVHLPS      0x112
#define X86_MOVLHPS      0x116
#define X86_CVTSPI2SPSD  0x12a
#define X86_CVTSPSD2SPI  0x12d
#define X86_CVTSPSD2SPSD 0x15a
#define X86_CVTPS        0x15b
#define X86_MOVDQAU_MR   0x16f
#define X86_PSHUF        0x170
#define X86_MOVDQ_7E     0x17e
#define X86_MOVDQAU_RM   0x17f
#define X86_PINSRW       0x1c4
#define X86_PEXTRW       0x1c5
#define X86_MOVQ_D6      0x1d6
#define X86_PMOVMSKB     0x1d7
#define X86_CVTPD        0x1e6
#define X86_MOVNT        0x1e7
#define X86_MASKMOV      0x1f7

/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDSPSD[]   = "add:? ";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszANDNPSD[]   = "andnp?";
char dszANDPSD[]    = "andp?";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCDQE[]      = "cdqe";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLFLUSH[]   = "clflush";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMOVO[]     = "cmovo";
char dszCMOVNO[]    = "cmovno";
char dszCMOVB[]     = "cmovb";
char dszCMOVNB[]    = "cmovnb";
char dszCMOVE[]     = "cmove";
char dszCMOVNE[]    = "cmovne";
char dszCMOVBE[]    = "cmovbe";
char dszCMOVA[]     = "cmova";
char dszCMOVS[]     = "cmovs";
char dszCMOVNS[]    = "cmovns";
char dszCMOVP[]     = "cmovp";
char dszCMOVNP[]    = "cmovnp";
char dszCMOVL[]     = "cmovl";
char dszCMOVGE[]    = "cmovge";
char dszCMOVLE[]    = "cmovle";
char dszCMOVNLE[]   = "cmovnle";
char dszCMP[]       = "cmp";
char dszCMPSPSD[]   = "cmp:? ";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCMPXCHG8B[] = "cmpxchg8b";
char dszCOMISSD[]   = "comis? ";
char dszCPUID[]     = "cpuid";
char dszCS_[]       = "cs:";
char dszCVTBASE[]   = "cvt ";
char dszCVTSPI2SPSD[] = "cvt:i2:? ";
char dszCVTSPSD2SPI[] = "cvt:?2:i ";
char dszCVTSPSD2SPSD[] = "cvt:?2:, ";
char dszCVTTSPSD2SPI[] = "cvtt:?2:i ";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDIVSPSD[]   = "div:? ";
char dszDS_[]       = "ds:";
char dszEMMS[]      = "emms";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCMOVB[]    = "fcmovb";
char dszFCMOVE[]    = "fcmove";
char dszFCMOVBE[]   = "fcmovbe";
char dszFCMOVU[]    = "fcmovu";
char dszFCMOVNB[]   = "fcmovnb";
char dszFCMOVNE[]   = "fcmovne";
char dszFCMOVNBE[]  = "fcmovnbe";
char dszFCMOVNU[]   = "fcmovnu";
char dszFCOM[]      = "fcom";
char dszFCOMI[]     = "fcomi";
char dszFCOMIP[]    = "fcomip";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFEMMS[]     = "femms";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMI[]    = "fucomi";
char dszFUCOMIP[]   = "fucomip";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXSAVE[]    = "fxsave";
char dszFXRSTOR[]   = "fxrstor";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszINVD[]      = "invd";
char dszINVLPG[]    = "invlpg";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJRCXZ[]     = "jrcxz";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDMXCSR[]   = "ldmxcsr";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFENCE[]    = "lfence";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMASKMOVDQU[]= "maskmov";
char dszMAXSPSD[]   = "max:? ";
char dszMFENCE[]    = "mfence";
char dszMINSPSD[]   = "min:? ";
char dszMOV[]       = "mov";
char dszMOVBASE[]   = "mov ";
char dszMOVAPSD[]   = "movap? ";
char dszMOVD[]      = "movd";
char dszMOVDQA[]    = "movdqa";
char dszMOVDQU[]    = "movdqu";
char dszMOVHLPS[]   = "movhlps";
char dszMOVHPSD[]   = "movhp? ";
char dszMOVLHPS[]   = "movlhps";
char dszMOVLPSD[]   = "movlp? ";
char dszMOVMSKPSD[] = "movmskp? ";
char dszMOVNTI[]    = "movnti";
char dszMOVNTPSD[]  = "movntp? ";
char dszMOVNTDQ[]   = "movnt";
char dszMOVQ[]      = "movq";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVSXD[]    = "movsxd";
char dszMOVUPSSD[]  = "mov ";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszMULSPSD[]   = "mul:? ";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszORPSD[]     = "orp? ";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPACKSSDW[]  = "packssdw";
char dszPACKSSWB[]  = "packsswb";
char dszPACKUSWB[]  = "packuswb";
char dszPADDB[]     = "paddb";
char dszPADDD[]     = "paddd";
char dszPADDQ[]     = "paddq";
char dszPADDSB[]    = "paddsb";
char dszPADDSW[]    = "paddsw";
char dszPADDUSB[]   = "paddusb";
char dszPADDUSW[]   = "paddusw";
char dszPADDW[]     = "paddw";
char dszPAND[]      = "pand";
char dszPANDN[]     = "pandn";
char dszPAUSE[]     = "pause";
char dszPAVGB[]     = "pavgb";
char dszPAVGW[]     = "pavgw";
char dszPCMPEQB[]   = "pcmpeqb";
char dszPCMPEQD[]   = "pcmpeqd";
char dszPCMPEQW[]   = "pcmpeqw";
char dszPCMPGTB[]   = "pcmpgtb";
char dszPCMPGTD[]   = "pcmpgtd";
char dszPCMPGTW[]   = "pcmpgtw";
char dszPEXTRW[]    = "pextrw";
char dszPINSRW[]    = "pinsrw";
char dszPMADDWD[]   = "pmaddwd";
char dszPMAXSW[]    = "pmaxsw";
char dszPMAXUB[]    = "pmaxub";
char dszPMINSW[]    = "pminsw";
char dszPMINUB[]    = "pminub";
char dszPMOVMSKB[]  = "pmovmskb";
char dszPMULHUW[]   = "pmulhuw";
char dszPMULHW[]    = "pmulhw";
char dszPMULLW[]    = "pmullw";
char dszPMULUDQ[]   = "pmuludq";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPOR[]       = "por";
char dszPREFETCH[]  = "prefetch";
char dszPREFETCHNTA[] = "prefetchtnta";
char dszPREFETCHT0[] = "prefetcht0";
char dszPREFETCHT1[] = "prefetcht1";
char dszPREFETCHT2[] = "prefetcht2";
char dszPREFETCHW[]  = "prefetchw";
char dszPSADBW[]    = "psadbw";
char dszPSHUF[]     = "pshuf ";
char dszPSLLD[]     = "pslld";
char dszPSLLDQ[]    = "pslldq";
char dszPSLLW[]     = "psllw";
char dszPSLLQ[]     = "psllq";
char dszPSRAD[]     = "psrad";
char dszPSRAW[]     = "psraw";
char dszPSRLD[]     = "psrld";
char dszPSRLDQ[]    = "psrldq";
char dszPSRLQ[]     = "psrlq";
char dszPSRLW[]     = "psrlw";
char dszPSUBB[]     = "psubb";
char dszPSUBD[]     = "psubd";
char dszPSUBQ[]     = "psubq";
char dszPSUBSB[]    = "psubsb";
char dszPSUBSW[]    = "psubsw";
char dszPSUBUSB[]   = "psubusb";
char dszPSUBUSW[]   = "psubusw";
char dszPSUBW[]     = "psubw";
char dszPUNPCKLBW[] = "punpcklbw";
char dszPUNPCKLDQ[] = "punpckldq";
char dszPUNPCKLWD[] = "punpcklwd";
char dszPUNPCKHBW[] = "punpckhbw";
char dszPUNPCKHDQ[] = "punpckhdq";
char dszPUNPCKHWD[] = "punpckhwd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszPXOR[]      = "pxor";
char dszRCL[]       = "rcl";
char dszRCPSPSD[]   = "rcp:? ";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszRDMSR[]     = "rdmsr";
char dszRDPMC[]     = "rdpmc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszRSM[]       = "rsm";
char dszRSQRTSPSD[] = "rsqrt:? ";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSFENCE[]    = "sfence";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSHUFPSD[]   = "shufp? ";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSQRTSPSD[]  = "sqrt:? ";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTMXCSR[]   = "stmxcsr";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszSUBSPSD[]   = "sub:? ";
char dszSYSCALL[]   = "syscall";
char dszSYSENTER[]  = "sysenter";
char dszSYSEXIT[]   = "sysexit";
char dszSYSRET[]    = "sysret";
char dszTEST[]      = "test";
char dszUCOMISSD[]  = "ucomis? ";
char dszUD2[]       = "ud2";
char dszUNPCKHPSD[] = "unpckhp? ";
char dszUNPCKLPSD[] = "unpcklp? ";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszWBINVD[]    = "wbinvd";
char dszWRMSR[]     = "wrmsr";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszXORPSD[]    = "xorp? ";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  X86_GROUP, GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD,XMMWREG,
              OWORD,  XMMOWORD,XMMSD,   CMPIB,   XMMXWORD, MMORWREG,
              XORMMREG, XB,    JCC8,    JCCX,    AMD3DNOW,
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulxb        O_Ib+1
#define O_Imul          O_Imulxb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_MmReg_qModrm  O_AX_oReg+2
#define O_qModrm_MmReg  O_MmReg_qModrm+3
#define O_MmReg_dModrm  O_qModrm_MmReg+3
#define O_dModrm_MmReg  O_MmReg_dModrm+3
#define O_qModrm_Ib     O_dModrm_MmReg+3
#define O_PSHimw        O_qModrm_Ib+3
#define O_PSHimd        O_PSHimw+5
#define O_PSHimq        O_PSHimd+5
#define O_GROUP_0F_AE   O_PSHimq+5
#define O_Sd_XmmReg_oModrm O_GROUP_0F_AE+3
#define O_Sd_oModrm_XmmReg O_Sd_XmmReg_oModrm+4
#define O_Sd_Reg_XmmReg    O_Sd_oModrm_XmmReg+4
#define O_Sd_XmmReg_oModrm_CmpIb O_Sd_Reg_XmmReg+3
#define O_Sd_XmmReg_xModrm O_Sd_XmmReg_oModrm_CmpIb+5
#define O_Sd_MmOrWReg_oModrm O_Sd_XmmReg_xModrm+4
#define O_Sd_XOrMmReg_XOrMmReg O_Sd_MmOrWReg_oModrm+4
#define O_Sd_xModrm_XOrMmReg O_Sd_XOrMmReg_XOrMmReg+3
#define O_GROUP_0F_18   O_Sd_xModrm_XOrMmReg+4
#define O_Sd_XmmReg_oModrm_Ib O_GROUP_0F_18+3
#define O_Jcc8          O_Sd_XmmReg_oModrm_Ib+5
#define O_JccX          O_Jcc8+1
#define O_Sd_XmmReg_qModrm O_JccX+1
#define O_MmReg_dModrm_Ib O_Sd_XmmReg_qModrm+4
#define O_Reg_MmReg_Ib  O_MmReg_dModrm_Ib+4
#define O_Reg_MmReg O_Reg_MmReg_Ib+4
#define O_MmReg_qModrm_3DNow O_Reg_MmReg+3
#define O_GROUP_0F_0D   O_MmReg_qModrm_3DNow+4
#define O_length        O_GROUP_0F_0D+4

typedef unsigned short ActionIndex;

#if( O_length > 65535 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulxb      */ VAR+MRM,   VREG+COM,   MODRM+COM, XB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, X86_GROUP,  0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   X86_GROUP,  0,         LMODRM+COM, XB+END,
/* group1_2    */ VAR+MRM,   X86_GROUP,  0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, X86_GROUP,  1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   X86_GROUP,  1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, X86_GROUP,  1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   X86_GROUP,  1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, X86_GROUP,  1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   X86_GROUP,  1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, X86_GROUP,  2,         LMODRM+END,
/* group6      */ xWORD+MRM, X86_GROUP,  3,         LMODRM+END,
/* group8      */ xWORD+MRM, X86_GROUP,  4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, LMODRM+COM, MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM, LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, LMODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, LMODRM+COM, IB+END,
/* PSHimw      */ MMQWORD+MRM, X86_GROUP,5,          MODRM+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, X86_GROUP,6,          MODRM+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, X86_GROUP,7,          MODRM+COM, IB+END,
/* group_0f_ae */ NOP+MRM,   GROUPT,     25,
/* Sd_XmmReg_oModrm*/ XMMSD, XMMOWORD+MRM, XMMWREG+COM, LMODRM+END,
/* Sd_oModrm_XmmReg*/ XMMSD, XMMOWORD+MRM, LMODRM+COM,  XMMWREG+END,
/* Sd_Reg_XmmReg  */ XMMSD+MRM, VREG+COM, XMMWREG+END,
/* Sd_XmmReg_oModrm_CmpIb */ XMMSD, XMMOWORD+MRM, XMMWREG+COM, LMODRM+COM, CMPIB+END,
/* Sd_XmmReg_xModrm*/ XMMSD, XMMXWORD+MRM, XMMWREG+COM, LMODRM+END,
/* Sd_MmOrWReg_xModrm*/ XMMSD, XMMOWORD+MRM, MMORWREG+COM, LMODRM+END,
/* Sd_XOrMmReg_XOrMmReg */ XMMSD+MRM, XORMMREG+COM, LMODRM+END,
/* Sd_xModrm_XOrMmReg */ XMMSD, XMMXWORD+MRM, LMODRM+COM, XORMMREG+END,
/* group_0f_18 */ NOP+MRM,   GROUPT,     26,
/* Sd_XmmReg_oModrm_Ib */ XMMSD, XMMOWORD+MRM, XMMWREG+COM, LMODRM+COM, IB+END,
/* Jcc8        */ JCC8+END,
/* JccX        */ JCCX+END,
/* Sd_XmmReg_qModrm*/ XMMSD, MMQWORD+MRM, XMMWREG+COM, LMODRM+END,
/* MmReg_dModrm_Ib*/ xWORD+MRM, MMWREG+COM, LMODRM+COM, IB+END,
/* Reg_MmReg_Ib*/ MMQWORD+MRM, VREG+COM, MMWREG+COM, IB+END,
/* Reg_MmReg   */ NOP+MRM, VREG+COM, MMWREG+END,
/* MmReg_qModrm_3DNow*/ MMQWORD+MRM, MMWREG+COM, LMODRM, AMD3DNOW+END,
/* group_0f_0d */ xBYTE+MRM, X86_GROUP,  8,         LMODRM+END,
};

#if defined(_M_IX86)
#define BUILDING_ON_X86 1
#else
#define BUILDING_ON_X86 0
#endif

#if BUILDING_ON_X86 == 1
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    ActionIndex opr;
    } Tdistbl;

#if BUILDING_ON_X86 == 1
#pragma pack()
#endif

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulxb,                 /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Jcc8,                   /* 70 JO                         */
    dszJNO,   O_Jcc8,                   /* 71 JNO                        */
    dszJB,    O_Jcc8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Jcc8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Jcc8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Jcc8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Jcc8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Jcc8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Jcc8,                   /* 78 JS                         */
    dszJNS,   O_Jcc8,                   /* 79 JNS                        */
    dszJPE,   O_Jcc8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Jcc8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Jcc8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Jcc8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Jcc8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Jcc8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Jcc8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Jcc8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Jcc8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Jcc8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // Secondary opcode table begins.

    dszMULTI,    O_GROUP6,              /* 00 MULTI                      */
    dszMULTI,    O_GROUP7,              /* 01 MULTI                      */
    dszLAR,      O_Reg_Modrm,           /* 02 LAR                        */
    dszLSL,      O_Reg_Modrm,           /* 03 LSL                        */
    dszRESERVED, O_DoDB,                /* 04                            */
    dszSYSCALL,  O_NoOperands,          /* 05 SYSCALL                    */
    dszCLTS,     O_NoOperands,          /* 06 CLTS                       */
    dszSYSRET,   O_NoOperands,          /* 07 SYSRET                     */
    dszINVD,     O_NoOperands,          /* 08 INVD                       */
    dszWBINVD,   O_NoOperands,          /* 09 WBINVD                     */
    dszRESERVED, O_DoDB,                /* 0A                            */
    dszUD2,      O_NoOperands,          /* 0B UD2 undefined              */
    dszRESERVED, O_DoDB,                /* 0C                            */
    dszMULTI,    O_GROUP_0F_0D,         /* 0D PREFETCH[W]                */
    dszFEMMS,    O_NoOperands,          /* 0E FEMMS                      */
    dszRESERVED, O_MmReg_qModrm_3DNow,  /* 0F AMD 3DNow family           */
    dszMOVUPSSD, O_Sd_XmmReg_oModrm,    /* 10 MOVS[SD] MOVUP[SD] reg, mem*/
    dszMOVUPSSD, O_Sd_oModrm_XmmReg,    /* 11 MOVS[SD] MOVUP[SD] mem, reg*/
    dszMOVLPSD,  O_Sd_XmmReg_oModrm,    /* 12 MOVLP[SD] xmm, m64         */
    dszMOVLPSD,  O_Sd_oModrm_XmmReg,    /* 13 MOVLP[SD] m64, xmm         */
    dszUNPCKLPSD,O_Sd_XmmReg_oModrm,    /* 14 UNPCKLP[SD]                */
    dszUNPCKHPSD,O_Sd_XmmReg_oModrm,    /* 15 UNPCKHP[SD]                */
    dszMOVHPSD,  O_Sd_XmmReg_oModrm,    /* 16 MOVHP[SD] xmm, m64         */
    dszMOVHPSD,  O_Sd_oModrm_XmmReg,    /* 17 MOVHP[SD] m64, xmm         */
    dszMULTI,    O_GROUP_0F_18,         /* 18 MULTI                      */
    dszRESERVED, O_DoDB,                /* 19                            */
    dszRESERVED, O_DoDB,                /* 1A                            */
    dszRESERVED, O_DoDB,                /* 1B                            */
    dszRESERVED, O_DoDB,                /* 1C                            */
    dszRESERVED, O_DoDB,                /* 1D                            */
    dszRESERVED, O_DoDB,                /* 1E                            */
    dszRESERVED, O_DoDB,                /* 1F                            */
    dszMOV,      O_Modrm_CReg,          /* 20 MOV Rd,Cd                  */
    dszMOV,      O_Modrm_CReg,          /* 21 MOV Rd,Dd                  */
    dszMOV,      O_CReg_Modrm,          /* 22 MOV Cd,Rd                  */
    dszMOV,      O_CReg_Modrm,          /* 23 MOV Dd,Rd                  */
    dszMOV,      O_Modrm_CReg,          /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,      O_CReg_Modrm,          /* 26 MOV Td,Rd                  */
    dszRESERVED, O_DoDB,                /* 27                            */
    dszMOVAPSD,  O_Sd_XmmReg_oModrm,    /* 28 MOVAP[SD] xmm1, xmm2/m128  */
    dszMOVAPSD,  O_Sd_oModrm_XmmReg,    /* 29 MOVAP[SD] xmm2/m128, xmm1  */
    dszCVTSPI2SPSD, O_Sd_XmmReg_qModrm, /* 2A CVT[SP]I2[SP][SD]          */
    dszMOVNTPSD, O_Sd_oModrm_XmmReg,    /* 2B MOVNTP[SD]                 */
    dszCVTTSPSD2SPI, O_Sd_MmOrWReg_oModrm, /* 2C CVTT[SP][SD]2[SP]I      */
    dszCVTSPSD2SPI,  O_Sd_MmOrWReg_oModrm, /* 2D CVT[SP][SD]2[SP]I       */
    dszUCOMISSD, O_Sd_XmmReg_xModrm,    /* 2E UCOMIS[SD]                 */
    dszCOMISSD,  O_Sd_XmmReg_xModrm,    /* 2F COMIS[SD]                  */
    dszWRMSR,    O_NoOperands,          /* 30 WRMSR                      */
    dszRDTSC,    O_NoOperands,          /* 31 RDTSC                      */
    dszRDMSR,    O_NoOperands,          /* 32 RDMSR                      */
    dszRDPMC,    O_NoOperands,          /* 33 RDPMC                      */
    dszSYSENTER, O_NoOperands,          /* 34 SYSENTER                   */
    dszSYSEXIT,  O_NoOperands,          /* 35 SYSEXIT                    */
    dszRESERVED, O_DoDB,                /* 36                            */
    dszRESERVED, O_DoDB,                /* 37                            */
    dszRESERVED, O_DoDB,                /* 38                            */
    dszRESERVED, O_DoDB,                /* 39                            */
    dszRESERVED, O_DoDB,                /* 3A                            */
    dszRESERVED, O_DoDB,                /* 3B                            */
    dszRESERVED, O_DoDB,                /* 3C                            */
    dszRESERVED, O_DoDB,                /* 3D                            */
    dszRESERVED, O_DoDB,                /* 3E                            */
    dszRESERVED, O_DoDB,                /* 3F                            */
    dszCMOVO,    O_Reg_Modrm,           /* 40 CMOVO                      */
    dszCMOVNO,   O_Reg_Modrm,           /* 41 CMOVNO                     */
    dszCMOVB,    O_Reg_Modrm,           /* 42 CMOVB                      */
    dszCMOVNB,   O_Reg_Modrm,           /* 43 CMOVNB                     */
    dszCMOVE,    O_Reg_Modrm,           /* 44 CMOVE                      */
    dszCMOVNE,   O_Reg_Modrm,           /* 45 CMOVNE                     */
    dszCMOVBE,   O_Reg_Modrm,           /* 46 CMOVBE                     */
    dszCMOVA,    O_Reg_Modrm,           /* 47 CMOVNBE                    */
    dszCMOVS,    O_Reg_Modrm,           /* 48 CMOVS                      */
    dszCMOVNS,   O_Reg_Modrm,           /* 49 CMOVNS                     */
    dszCMOVP,    O_Reg_Modrm,           /* 4A CMOVP                      */
    dszCMOVNP,   O_Reg_Modrm,           /* 4B CMOVNP                     */
    dszCMOVL,    O_Reg_Modrm,           /* 4C CMOVL                      */
    dszCMOVGE,   O_Reg_Modrm,           /* 4D CMOVGE                     */
    dszCMOVLE,   O_Reg_Modrm,           /* 4E CMOVLE                     */
    dszCMOVNLE,  O_Reg_Modrm,           /* 4F CMOVNLE                    */
    dszMOVMSKPSD,O_Sd_Reg_XmmReg,       /* 50 MOVMSKP[SD]                */
    dszSQRTSPSD, O_Sd_XmmReg_oModrm,    /* 51 SQRT[SP][SD]               */
    dszRSQRTSPSD,O_Sd_XmmReg_oModrm,    /* 52 RSQRT[SP][SD]              */
    dszRCPSPSD,  O_Sd_XmmReg_oModrm,    /* 53 RCP[SP][SD]                */
    dszANDPSD,   O_Sd_XmmReg_oModrm,    /* 54 ANDP[SD]                   */
    dszANDNPSD,  O_Sd_XmmReg_oModrm,    /* 55 ANDNP[SD]                  */
    dszORPSD,    O_Sd_XmmReg_oModrm,    /* 56 ORP[SD]                    */
    dszXORPSD,   O_Sd_XmmReg_oModrm,    /* 57 XORP[SD]                   */
    dszADDSPSD,  O_Sd_XmmReg_oModrm,    /* 58 ADD[SP][SD]                */
    dszMULSPSD,  O_Sd_XmmReg_oModrm,    /* 59 MUL[SP][SD]                */
    dszCVTSPSD2SPSD, O_Sd_XmmReg_oModrm,/* 5A CVT[SP][SD]2[SP][SD]       */
    dszCVTBASE,  O_Sd_XmmReg_oModrm,    /* 5B CVT<PS> family             */
    dszSUBSPSD,  O_Sd_XmmReg_oModrm,    /* 5C SUB[SP][SD]                */
    dszMINSPSD,  O_Sd_XmmReg_oModrm,    /* 5D MIN[SP][SD]                */
    dszDIVSPSD,  O_Sd_XmmReg_oModrm,    /* 5E DIV[SP][SD]                */
    dszMAXSPSD,  O_Sd_XmmReg_oModrm,    /* 5F MAX[SP][SD]                */
    dszPUNPCKLBW,O_MmReg_qModrm,        /* 60 PUNPCKLBW                  */
    dszPUNPCKLWD,O_MmReg_qModrm,        /* 61 PUNPCKLWD                  */
    dszPUNPCKLDQ,O_MmReg_qModrm,        /* 62 PUNPCKLDQ                  */
    dszPACKSSWB, O_MmReg_qModrm,        /* 63 PACKSSWB                   */
    dszPCMPGTB,  O_MmReg_qModrm,        /* 64 PCMPGTB                    */
    dszPCMPGTW,  O_MmReg_qModrm,        /* 65 PCMPGTW                    */
    dszPCMPGTD,  O_MmReg_qModrm,        /* 66 PCMPGTD                    */
    dszPACKUSWB, O_MmReg_qModrm,        /* 67 PACKUSWB                   */
    dszPUNPCKHBW,O_MmReg_qModrm,        /* 68 PUNPCKHBW                  */
    dszPUNPCKHWD,O_MmReg_qModrm,        /* 69 PUNPCKHWD                  */
    dszPUNPCKHDQ,O_MmReg_qModrm,        /* 6A PUNPCKHDQ                  */
    dszPACKSSDW, O_MmReg_qModrm,        /* 6B PACKSSDW                   */
    dszRESERVED, O_DoDB,                /* 6C                            */
    dszRESERVED, O_DoDB,                /* 6D                            */
    dszMOVD,     O_MmReg_dModrm,        /* 6E MOVD                       */
    dszMOVQ,     O_MmReg_qModrm,        /* 6F MOVQ                       */
    dszPSHUF,    O_Sd_XmmReg_oModrm_Ib, /* 70 PSHUF family               */
    dszMULTI,    O_PSHimw,              /* 71 PS[LR][AL]W immediate      */
    dszMULTI,    O_PSHimd,              /* 72 PS[LR][AL]D immediate      */
    dszMULTI,    O_PSHimq,              /* 73 PS[LR]LQ immediate         */
    dszPCMPEQB,  O_MmReg_qModrm,        /* 74 PCMPEQB                    */
    dszPCMPEQW,  O_MmReg_qModrm,        /* 75 PCMPEQW                    */
    dszPCMPEQD,  O_MmReg_qModrm,        /* 76 PCMPEQD                    */
    dszEMMS,     O_NoOperands,          /* 77 EMMS                       */
    dszRESERVED, O_DoDB,                /* 78                            */
    dszRESERVED, O_DoDB,                /* 79                            */
    dszRESERVED, O_DoDB,                /* 7A                            */
    dszRESERVED, O_DoDB,                /* 7B                            */
    dszRESERVED, O_DoDB,                /* 7C                            */
    dszSETNL,    O_bModrm,              /* 7D SETNL                      */
    dszMOVD,     O_dModrm_MmReg,        /* 7E MOVD                       */
    dszMOVQ,     O_qModrm_MmReg,        /* 7F MOVQ                       */
    dszJO,       O_JccX,                /* 80 JO                         */
    dszJNO,      O_JccX,                /* 81 JNO                        */
    dszJB,       O_JccX,                /* 82 JB                         */
    dszJNB,      O_JccX,                /* 83 JNB                        */
    dszJE,       O_JccX,                /* 84 JE                         */
    dszJNE,      O_JccX,                /* 85 JNE                        */
    dszJBE,      O_JccX,                /* 86 JBE                        */
    dszJNBE,     O_JccX,                /* 87 JNBE                       */
    dszJS,       O_JccX,                /* 88 JS                         */
    dszJNS,      O_JccX,                /* 89 JNS                        */
    dszJP,       O_JccX,                /* 8A JP                         */
    dszJNP,      O_JccX,                /* 8B JNP                        */
    dszJL,       O_JccX,                /* 8C JL                         */
    dszJNL,      O_JccX,                /* 8D JNL                        */
    dszJLE,      O_JccX,                /* 8E JLE                        */
    dszJNLE,     O_JccX,                /* 8F JNLE                       */
    dszSETO,     O_bModrm,              /* 90 SETO                       */
    dszSETNO,    O_bModrm,              /* 91 SETNO                      */
    dszSETB,     O_bModrm,              /* 92 SETB                       */
    dszSETNB,    O_bModrm,              /* 93 SETNB                      */
    dszSETE,     O_bModrm,              /* 94 SETE                       */
    dszSETNE,    O_bModrm,              /* 95 SETNE                      */
    dszSETBE,    O_bModrm,              /* 96 SETBE                      */
    dszSETA,     O_bModrm,              /* 97 SETNBE                     */
    dszSETS,     O_bModrm,              /* 98 SETS                       */
    dszSETNS,    O_bModrm,              /* 99 SETNS                      */
    dszSETP,     O_bModrm,              /* 9A SETP                       */
    dszSETNP,    O_bModrm,              /* 9B SETNP                      */
    dszSETL,     O_bModrm,              /* 9C SETL                       */
    dszSETGE,    O_bModrm,              /* 9D SETGE                      */
    dszSETLE,    O_bModrm,              /* 9E SETLE                      */
    dszSETNLE,   O_bModrm,              /* 9F SETNLE                     */
    dszPUSH,     O_sReg2,               /* A0 PUSH FS                    */
    dszPOP,      O_sReg2,               /* A1 POP FS                     */
    dszCPUID,    O_NoOperands,          /* A2 CPUID                      */
    dszBT,       O_Modrm_Reg,           /* A3 BT                         */
    dszSHLD,     O_Modrm_Reg_Ib,        /* A4 SHLD                       */
    dszSHLD,     O_Modrm_Reg_CL,        /* A5 SHLD                       */
    dszRESERVED, O_DoDB,                /* A6                            */
    dszRESERVED, O_DoDB,                /* A7                            */
    dszPUSH,     O_sReg2,               /* A8 PUSH GS                    */
    dszPOP,      O_sReg2,               /* A9 POP GS                     */
    dszRSM,      O_NoOperands,          /* AA RSM                        */
    dszBTS,      O_vModrm_Reg,          /* AB BTS                        */
    dszSHRD,     O_Modrm_Reg_Ib,        /* AC SHRD                       */
    dszSHRD,     O_Modrm_Reg_CL,        /* AD SHRD                       */
    dszMULTI,    O_GROUP_0F_AE,         /* AE MULTI                      */
    dszIMUL,     O_Reg_Modrm,           /* AF IMUL                       */
    dszCMPXCHG,  O_bModrm_Reg,          /* B0 CMPXCH                     */
    dszCMPXCHG,  O_Modrm_Reg,           /* B1 CMPXCH                     */
    dszLSS,      O_fReg_Modrm,          /* B2 LSS                        */
    dszBTR,      O_Modrm_Reg,           /* B3 BTR                        */
    dszLFS,      O_fReg_Modrm,          /* B4 LFS                        */
    dszLGS,      O_fReg_Modrm,          /* B5 LGS                        */
    dszMOVZX,    O_Reg_bModrm,          /* B6 MOVZX                      */
    dszMOVZX,    O_Reg_wModrm,          /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI,    O_GROUP8,              /* BA MULTI                      */
    dszBTC,      O_Modrm_Reg,           /* BB BTC                        */
    dszBSF,      O_Reg_Modrm,           /* BC BSF                        */
    dszBSR,      O_Reg_Modrm,           /* BD BSR                        */
    dszMOVSX,    O_Reg_bModrm,          /* BE MOVSX                      */
    dszMOVSX,    O_Reg_wModrm,          /* BF MOVSX                      */
    dszXADD,     O_bModrm_Reg,          /* C0 XADD                       */
    dszXADD,     O_Modrm_Reg,           /* C1 XADD                       */
    dszCMPSPSD,  O_Sd_XmmReg_oModrm_CmpIb, /* C2 CMP[SP][SD]             */
    dszMOVNTI,   O_Modrm_Reg,           /* C3 MOVNTI                     */
    dszPINSRW,   O_MmReg_dModrm_Ib,     /* C4 PINSRW                     */
    dszPEXTRW,   O_Reg_MmReg_Ib,        /* C5 PEXTRW                     */
    dszSHUFPSD,  O_Sd_XmmReg_oModrm_Ib, /* C6 SHUFP[SD]                  */
    dszCMPXCHG8B,O_qModrm,              /* C7 CMPXCHG8B                  */
    dszBSWAP,    O_oReg,                /* C8 BSWAP                      */
    dszBSWAP,    O_oReg,                /* C9 BSWAP                      */
    dszBSWAP,    O_oReg,                /* CA BSWAP                      */
    dszBSWAP,    O_oReg,                /* CB BSWAP                      */
    dszBSWAP,    O_oReg,                /* CC BSWAP                      */
    dszBSWAP,    O_oReg,                /* CD BSWAP                      */
    dszBSWAP,    O_oReg,                /* CE BSWAP                      */
    dszBSWAP,    O_oReg,                /* CF BSWAP                      */
    dszRESERVED, O_DoDB,                /* D0                            */
    dszPSRLW,    O_MmReg_qModrm,        /* D1 PSRLW                      */
    dszPSRLD,    O_MmReg_qModrm,        /* D2 PSRLD                      */
    dszPSRLQ,    O_MmReg_qModrm,        /* D3 PSRLQ                      */
    dszPADDQ,    O_MmReg_qModrm,        /* D4 PADDQ                      */
    dszPMULLW,   O_MmReg_qModrm,        /* D5 PMULLW                     */
    dszMOVBASE,  O_Sd_oModrm_XmmReg,    /* D6 MOVDQ2Q, MOVQ, MOVQ2DQ     */
    dszPMOVMSKB, O_Reg_MmReg,           /* D7 PMOVMSKB                   */
    dszPSUBUSB,  O_MmReg_qModrm,        /* D8 PSUBUSB                    */
    dszPSUBUSW,  O_MmReg_qModrm,        /* D9 PSUBUSW                    */
    dszPMINUB,   O_MmReg_qModrm,        /* DA PMINUB                     */
    dszPAND,     O_MmReg_qModrm,        /* DB PAND                       */
    dszPADDUSB,  O_MmReg_qModrm,        /* DC PADDUSB                    */
    dszPADDUSW,  O_MmReg_qModrm,        /* DD PADDUSW                    */
    dszPMAXUB,   O_MmReg_qModrm,        /* DE PMAXUB                     */
    dszPANDN,    O_MmReg_qModrm,        /* DF PANDN                      */
    dszPAVGB,    O_MmReg_qModrm,        /* E0 PAVGB                      */
    dszPSRAW,    O_MmReg_qModrm,        /* E1 PSRAW                      */
    dszPSRAD,    O_MmReg_qModrm,        /* E2 PSRAD                      */
    dszPAVGW,    O_MmReg_qModrm,        /* E3 PAVGW                      */
    dszPMULHUW,  O_MmReg_qModrm,        /* E4 PMULHUW                    */
    dszPMULHW,   O_MmReg_qModrm,        /* E5 PMULHW                     */
    dszCVTBASE,  O_Sd_XmmReg_oModrm,    /* E6 CVT<PD> family             */
    dszMOVNTDQ,  O_Sd_xModrm_XOrMmReg,  /* E7 MOVNT{Q}{DQ}               */
    dszPSUBSB,   O_MmReg_qModrm,        /* E8 PSUBSB                     */
    dszPSUBSW,   O_MmReg_qModrm,        /* E9 PSUBSW                     */
    dszPMINSW,   O_MmReg_qModrm,        /* EA PMINSW                     */
    dszPOR,      O_MmReg_qModrm,        /* EB POR                        */
    dszPADDSB,   O_MmReg_qModrm,        /* EC PADDSB                     */
    dszPADDSW,   O_MmReg_qModrm,        /* ED PADDSW                     */
    dszPMAXSW,   O_MmReg_qModrm,        /* EE PMAXSW                     */
    dszPXOR,     O_MmReg_qModrm,        /* EF PXOR                       */
    dszRESERVED, O_DoDB,                /* F0                            */
    dszPSLLW,    O_MmReg_qModrm,        /* F1 PSLLW                      */
    dszPSLLD,    O_MmReg_qModrm,        /* F2 PSLLD                      */
    dszPSLLQ,    O_MmReg_qModrm,        /* F3 PSLLQ                      */
    dszPMULUDQ,  O_MmReg_qModrm,        /* F4 PMULUDQ                    */
    dszPMADDWD,  O_MmReg_qModrm,        /* F5 PMADDWD                    */
    dszPSADBW,   O_MmReg_qModrm,        /* F6 PSADBQ                     */
    dszMASKMOVDQU, O_Sd_XOrMmReg_XOrMmReg, /* F7 MASKMOV{Q}{DQU}         */
    dszPSUBB,    O_MmReg_qModrm,        /* F8 PSUBB                      */
    dszPSUBW,    O_MmReg_qModrm,        /* F9 PSUBW                      */
    dszPSUBD,    O_MmReg_qModrm,        /* FA PSUBD                      */
    dszPSUBQ,    O_MmReg_qModrm,        /* FB PSUBQ                      */
    dszPADDB,    O_MmReg_qModrm,        /* FC PADDB                      */
    dszPADDW,    O_MmReg_qModrm,        /* FD PADDW                      */
    dszPADDD,    O_MmReg_qModrm,        /* FE PADDD                      */
    dszRESERVED, O_DoDB,                /* FF                            */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,  dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszSHL,  dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC},

/* 05 */    {dszRESERVED, dszRESERVED, dszPSRLW,    dszRESERVED, /* PSHimw */
             dszPSRAW,    dszRESERVED, dszPSLLW,    dszRESERVED},
            
/* 06 */    {dszRESERVED, dszRESERVED, dszPSRLD,    dszRESERVED, /* PSHimd */
             dszPSRAD,    dszRESERVED, dszPSLLD,    dszRESERVED},
            
/* 07 */    {dszRESERVED, dszRESERVED, dszPSRLQ,    dszPSRLDQ,   /* PSHimq */
             dszRESERVED, dszRESERVED, dszPSLLQ,    dszPSLLDQ},
            
/* 08 */    {dszPREFETCH, dszPREFETCHW, dszPREFETCH, dszPREFETCH,/* PREFETCH */
             dszPREFETCH, dszPREFETCH,  dszPREFETCH, dszPREFETCH},
            
            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszFCMOVB,   O_ST_iST,     /* DA-0 FCMOVB  */
              dszFCMOVE,   O_ST_iST,     /* DA-1 FCMOVE  */
              dszFCMOVBE,  O_ST_iST,     /* DA-2 FCMOVBE */
              dszFCMOVU,   O_ST_iST,     /* DA-3 FCMOVU  */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUBR,    O_iST_ST,     /* DC-4 FSUBR   */
              dszFSUB,     O_iST_ST,     /* DC-5 FSUB    */
              dszFDIVR,    O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIV,     O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBRP,   O_iST_ST,     /* DE-4 FSUBRP  */
              dszFSUBP,    O_iST_ST,     /* DE-5 FSUBP   */
              dszFDIVRP,   O_iST_ST,     /* DE-6 FDIVRP  */
              dszFDIVP,    O_iST_ST },   /* DE-7 FDIVP   */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszFUCOMIP,  O_ST_iST,     /* DF-5 FUCOMIP */
              dszFCOMIP,   O_ST_iST,     /* DF-6 FCOMIP  */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszINVLPG,   O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
            { dszFCMOVNB,  O_ST_iST,     /* DB-0 FCMOVNB   */
              dszFCMOVNE,  O_ST_iST,     /* DB-1 FCMOVNE   */
              dszFCMOVNBE, O_ST_iST,     /* DB-2 FCMOVNBE  */
              dszFCMOVNU,  O_ST_iST,     /* DB-3 FCMOVNU   */
              dszRESERVED, O_DoDB,       /* DB-4           */
              dszFUCOMI,   O_ST_iST,     /* DB-5 FUCOMI    */
              dszFCOMI,    O_ST_iST,     /* DB-6 FCOMI     */
              dszRESERVED, O_DoDB },     /* DB-7           */

/* 25                 Group 0F AE                          */
            { dszFXSAVE,   O_bModrm,     /* AE-0 FXSAVE    */
              dszFXRSTOR,  O_bModrm,     /* AE-1 FXRSTOR   */
              dszLDMXCSR,  O_dModrm,     /* AE-2 LDMXCSR   */
              dszSTMXCSR,  O_dModrm,     /* AE-3 STMXCSR   */
              dszCLFLUSH,  O_bModrm,     /* AE-4 CLFLUSH   */
              dszLFENCE,   O_NoOperands, /* AE-5 LFENCE    */
              dszMFENCE,   O_NoOperands, /* AE-6 MFENCE    */
              dszSFENCE,   O_NoOperands }, /* AE-7 SFENCE  */

/* 26                 Group 0F 18                            */
            { dszPREFETCHNTA, O_bModrm,  /* 18-0 PREFETCHNTA */
              dszPREFETCHT0,  O_bModrm,  /* 18-1 PREFETCHT0  */
              dszPREFETCHT1,  O_bModrm,  /* 18-2 PREFETCHT1  */
              dszPREFETCHT2,  O_bModrm,  /* 18-3 PREFETCHT2  */
              dszRESERVED,    O_DoDB,    /* 18-4             */
              dszRESERVED,    O_DoDB,    /* 18-5             */
              dszRESERVED,    O_DoDB,    /* 18-6             */
              dszRESERVED,    O_DoDB },  /* 18-7             */

            };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ia64_dis.h ===
#ifndef _IA64_DIS_
#define _IA64_DIS_

#include <kxia64.h>

#define ASCII_BUF_LENGTH 1536

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ntsd64\ia64_dis.cpp ===
//----------------------------------------------------------------------------
//
// Disassembly portions of IA64 machine implementation.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "ntsdp.hpp"

#include "ia64_dis.h"

#define PRED0_MASK (0x3f << 5)
#define PRED1_MASK (0x3f << 14)
#define PRED2_MASK (0x3f << 23)

// Breakpoint insertion and removal are done on bundle boundaries.
#define IA64_BP_ALIGN 0xf
#define IA64_BP_LEN 16
// defined in IA64INST.H
ULONGLONG g_Ia64TrapInstr = BREAK_INSTR | (IA64_DEBUG_STOP_BREAKPOINT << 6);

#ifdef DW3      // defined in vdmdbg.h which is in conflict with iel.h
#undef DW3
#endif

#define DECEM    1    /* GetNextOffset() based on Intel Falcon decoder DLL */

#include "decem.h"

/*****************************************************************************/
// Temporary variables for IEL library

unsigned int IEL_t1, IEL_t2, IEL_t3, IEL_t4;
U32  IEL_tempc;
U64  IEL_et1, IEL_et2;
U128 IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
S128 IEL_ts1, IEL_ts2;

#define IEL_GETQW0(x) ((ULONG64)IEL_GETDW1(x)) << 32 | IEL_GETDW0(x)


/*****************************************************************************/

#ifdef    DECEM

EM_Decoder_Machine_Type machineType = EM_DECODER_CPU_P7;
EM_Decoder_Machine_Mode machineMode = EM_DECODER_MODE_EM;

BOOL fDecoderInitDone = FALSE;
BOOL fDecoderActive = FALSE;

EM_Decoder_Id    DecoderId = -1;

EM_Decoder_Id  (__cdecl *pfnEM_Decoder_open)(void);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_associate_one)(const EM_Decoder_Id,
                const EM_Decoder_Inst_Id,
                const void *);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_associate_check)(const EM_Decoder_Id,
                EM_Decoder_Inst_Id *);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_setenv)(const EM_Decoder_Id,
                const EM_Decoder_Machine_Type,
                const EM_Decoder_Machine_Mode);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_close)(const EM_Decoder_Id);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_decode)(const EM_Decoder_Id,
                const unsigned char *,
                const int,
                const EM_IL,
                EM_Decoder_Info *);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_inst_static_info)(const EM_Decoder_Id,
                const EM_Decoder_Inst_Id,
                EM_Decoder_Inst_Static_Info *);

const char* (__cdecl *pfnEM_Decoder_ver_str)(void);

void  (__cdecl *pfnEM_Decoder_get_version)(EM_library_version_t *);

const char* (__cdecl *pfnEM_Decoder_err_msg)(EM_Decoder_Err);

EM_Decoder_Err (__cdecl *pfnEM_Decoder_decode_bundle)(const EM_Decoder_Id,
                const unsigned char*,
                const int,
                EM_Decoder_Bundle_Info*);

BOOL 
InitDecoder (void)
{
    EM_library_version_t dec_vs;
    EM_library_version_t *dec_version;

    EM_Decoder_Err    err;

    HINSTANCE hmodDecoder;

        // load EM deocder library if it is not done yet
    if (!fDecoderInitDone) {
        fDecoderInitDone = TRUE;
        const char* c_szFailure = NULL;
        if (
            (hmodDecoder = LoadLibrary("DECEM.DLL")) &&
            (pfnEM_Decoder_open = (EM_Decoder_Id (__cdecl*)(void))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_open")
            ) &&
            (pfnEM_Decoder_associate_one = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const EM_Decoder_Inst_Id, const void*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_associate_one")
            ) &&
            (pfnEM_Decoder_associate_check = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, EM_Decoder_Inst_Id*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_associate_check")
            ) &&
            (pfnEM_Decoder_setenv = 
                (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const EM_Decoder_Machine_Type, const EM_Decoder_Machine_Mode))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_setenv")
            ) &&
            (pfnEM_Decoder_close = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_close")
            ) &&
            (pfnEM_Decoder_decode = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const unsigned char*, const int, const EM_IL, EM_Decoder_Info*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_decode")
            ) &&
            (pfnEM_Decoder_inst_static_info = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const EM_Decoder_Inst_Id, EM_Decoder_Inst_Static_Info*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_inst_static_info")
            ) &&
            (pfnEM_Decoder_ver_str = (const char* (__cdecl*)(void))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_ver_str")
            ) &&
            (pfnEM_Decoder_get_version = (void (__cdecl*)(EM_library_version_t*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_get_version")
            ) &&
            (pfnEM_Decoder_err_msg = (const char* (__cdecl*)(EM_Decoder_Err))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_err_msg")
            ) &&
            (pfnEM_Decoder_decode_bundle = (EM_Decoder_Err (__cdecl*)(const EM_Decoder_Id, const unsigned char*, const int, EM_Decoder_Bundle_Info*))
                GetProcAddress(hmodDecoder, c_szFailure = "em_decoder_decode_bundle")
            )
        ){
            // Display DECEM.DLL version on initial load
            dec_version = &dec_vs;
            (*pfnEM_Decoder_get_version)(dec_version);
            dprintf("Falcon EM Decoder xversion "
                    "%d.%d, api %d.%d, emdb %d.%d\n",
                    dec_version->xversion.major, dec_version->xversion.minor,
                    dec_version->api.major, dec_version->api.minor,
                    dec_version->emdb.major, dec_version->emdb.minor);

            if ((DecoderId = (*pfnEM_Decoder_open)()) == -1) 
            {
                ErrOut("em_decoder_open failed\n");
            }
            else {
                if (
                    (err = (*pfnEM_Decoder_setenv)(DecoderId, 
                                                   machineType, 
                                                   machineMode)
                    ) != EM_DECODER_NO_ERROR)
                {
                    ErrOut("em_decoder_setenv: %s\n", (*pfnEM_Decoder_err_msg)((EM_Decoder_Err)err));
                } 
                else 
                {
                    fDecoderActive = TRUE;
                }
            }
        }
        else
        {
            // error processing....
            if (!hmodDecoder) 
            {
                ErrOut("LoadLibrary(DECEM.DLL) failed.\n");
            }
            else if (c_szFailure && *c_szFailure) 
            {
                ErrOut("GetProcAddress failed for %s at DECEM.DLL\n", c_szFailure);
            }
            else
            {
                ErrOut("Unknown failure while initializing DECEM.DLL\n");
            }
        }
    }

    return fDecoderActive;
}

#endif    /* DECEM */


BOOL fDisasmInitDone = FALSE;
BOOL fDisasmActive = FALSE;

//
// CIa64Disasm - disassemble an IA64 instruction
//
typedef class CIa64Disasm 
{
public:

    typedef union SBundle 
    {
        UCHAR BundleBuffer[EM_BUNDLE_SIZE];
    } typedef_SBundle;

    static bool GetBundleAndSlot(ULONG64 uLocation, 
                                 ULONG64* pBundleLoc, 
                                 UINT* pSlotNum)
    {
        if (pSlotNum) 
        {
            switch (uLocation & 0xf) 
            {
            case 0:  *pSlotNum = 0; break;
            case 4:  *pSlotNum = 1; break;
            case 8:  *pSlotNum = 2; break;
            default: return false;
            }
        } 

        if (pBundleLoc) 
        {
            *pBundleLoc = uLocation & ~0xf;
        }

        return true;
    }

    CIa64Disasm(TargetInfo* Target,
                Ia64MachineInfo* pMachineInit);
    
    bool 
    DecodeInstruction(ULONG64 uBundleLoc, const SBundle& r_Bundle, 
                      UINT uSlotNum, EM_Decoder_Info* pInstrInfo);

    bool Disassemble(ULONG64 uLocation, const SBundle& r_Bundle,
                     UINT* pInstrLen, char* szDisBuf, size_t nDisBufSize, 
                     bool bContext);

private:

    TargetInfo* m_Target;
    Ia64MachineInfo* m_Machine;

    typedef class CSzBuffer 
    {
    public:
        CSzBuffer(char* szDisBuf, size_t nDisBufSize);
        void Add(const char* szSrc, size_t nStart = 0);
        void Validate();
        bool IsValid() const {return bValid;}
        size_t length() const {return nSize;}
        const char* c_str() const {return szBuf;}
    protected:
        char* szBuf;
        size_t nMaxSize;
        size_t nSize;
        bool bValid;
    } typedef_CSzBuffer;

    typedef struct SRegFileInfo 
    {
	    EM_Decoder_Regfile_Name DecoderName;
	    char* szName;
	    char* szAlias;
	    char* szMasm;
    } typedef_SRegFileInfo;

    typedef struct SRegInfo
    {
	    EM_Decoder_Reg_Name DecoderName;
	    char* szName;
	    char* szAlias;
	    char* szMasm;
    } typedef_SRegInfo;

    void 
    AddRegister(CSzBuffer* pBuf, const EM_Decoder_Reg_Info& c_RegInfo);

    void 
    AddRegister(CSzBuffer* pBuf, const EM_Decoder_Regfile_Info& c_RegInfo);

    void 
    AddRegister(CSzBuffer* pBuf, EM_Decoder_Reg_Name RegName);

    void 
    AddPredicate(CSzBuffer* pBuf, 
                 const EM_Decoder_Info& c_InstrInfo, bool bContext);

    void 
    AddMnemonic(CSzBuffer* pBuf, const EM_Decoder_Info& c_InstrInfo);


    void 
    AddOperandList(CSzBuffer* pBuf, ULONG64 uBundleLoc, 
                   UINT uSlotNum, const EM_Decoder_Info& c_InstrInfo);

    void 
    AddComment(CSzBuffer* pBuf, ULONG64 uBundleLoc, 
               UINT uSlotNum, const EM_Decoder_Info& c_InstrInfo, 
               bool bContext);

    bool 
    AddOperand(CSzBuffer* pBuf, ULONG64 uBundleLoc, UINT uSlotNum, 
               const EM_Decoder_Operand_Info& c_OperandInfo, 
               bool bSeparator);

    void 
    AddSeparator(CSzBuffer* pBuf);

    static void 
    AddString(CSzBuffer* pBuf, const char* szSrc, size_t nStart = 0)
    {
        pBuf->Add(szSrc, nStart);
    }

    void 
    AddSymAddr(CSzBuffer* pBuf, ULONG64 uAddress);

    static SRegFileInfo c_aRegFileInfo[];
    static SRegInfo c_aRegInfo[];
} typedef_CIa64Disasm;

//
// CIa64Disasm::CSzBuffer implementation
//

CIa64Disasm::CSzBuffer::CSzBuffer(char* szDisBuf, 
                                  size_t nDisBufSize)

    :szBuf(szDisBuf), nMaxSize(nDisBufSize)
{
    if (nMaxSize) 
    {
        --nMaxSize;
    }
    Validate();
}

void 
CIa64Disasm::CSzBuffer::Validate() 
{
    nSize = 0;
    bValid = false;
    if (szBuf && nMaxSize) 
    {
        nSize = strlen(szBuf);
        bValid = true;
    } 
}

void 
CIa64Disasm::CSzBuffer::Add(const char* szSrc, 
                            size_t nStart /*= 0*/)
{
    if (!bValid || (nSize >= nMaxSize)) 
    {
        return;
    }

    if (nSize < nStart) 
    {
        size_t nSpaceSize = nStart - nSize;
        memset(szBuf + nSize, ' ', nSpaceSize);
        szBuf[nStart] = char(0);
        nSize = nStart;
    } 

    if (!(szSrc && *szSrc)) 
    {
        return;
    }

    strncat(szBuf, szSrc,  nMaxSize - nSize);
    szBuf[nMaxSize] = char(0);
    nSize += strlen(szBuf + nSize);
}

//
// CIa64Disasm implementation
//

CIa64Disasm::CIa64Disasm(TargetInfo* Target, Ia64MachineInfo* pMachineInit)
    : m_Target(Target), m_Machine(pMachineInit)
{
    InitDecoder();
}

bool 
CIa64Disasm::DecodeInstruction(ULONG64 uBundleLoc, 
                               const SBundle& r_Bundle, 
                               UINT uSlot, 
                               EM_Decoder_Info* pInstrInfo)
{
    if ((uBundleLoc & 0xf) || (uSlot > 2) || !pInstrInfo) 
    {
        return false;
    }

    uBundleLoc += uSlot;

    U64 Location;
    //IEL_ZERO(DecLocation);
    IEL_ASSIGNU(Location, *(U64*)&uBundleLoc);
    
    EM_Decoder_Err Error = pfnEM_Decoder_decode(DecoderId, 
                                                (unsigned char*)&r_Bundle, 
                                                sizeof(r_Bundle), Location, 
                                                pInstrInfo);

    return ((Error == EM_DECODER_NO_ERROR) && (pInstrInfo->inst != EM_IGNOP));
}


bool 
CIa64Disasm::Disassemble(ULONG64 uLocation,
                         const CIa64Disasm::SBundle& r_Bundle, 
                         UINT* pInstrLen,
                         char* szDisBuf,
                         size_t nDisBufSize,
                         bool bContext)
{
    if (!InitDecoder()) 
    {
        ErrOut("EM decoder library(DECEM.DLL) not active\n");
        return false;
    } 
    
    ULONG64 uBundleLoc;
    UINT uSlotNum;
    if (!GetBundleAndSlot(uLocation, &uBundleLoc, &uSlotNum)) 
    {
        return false;
    }

    CSzBuffer Buf(szDisBuf, nDisBufSize);
        
    EM_Decoder_Info InstrInfo;
    if (!DecodeInstruction(uBundleLoc, r_Bundle, uSlotNum, &InstrInfo)) 
    {
        EM_Decoder_static_info_t StaticInfo; 
        ZeroMemory(&StaticInfo, sizeof(StaticInfo));
        StaticInfo.mnemonic = "???";
        InstrInfo.static_info = &StaticInfo;
        AddMnemonic(&Buf, InstrInfo);
        return true;
    }

    AddPredicate(&Buf, InstrInfo, bContext);
    AddMnemonic(&Buf, InstrInfo);
    AddString(&Buf, " ");
    AddOperandList(&Buf, uBundleLoc, uSlotNum, InstrInfo);

    if (EM_DECODER_CYCLE_BREAK((&InstrInfo))) 
    {
        AddString(&Buf, " ;;");
    } 

    AddComment(&Buf, uBundleLoc, uSlotNum, InstrInfo, bContext);

    if (pInstrLen) 
    {
        *pInstrLen = InstrInfo.size;
    }

    return true;
}

void 
CIa64Disasm::AddRegister(CSzBuffer* pBuf,
                         const EM_Decoder_Reg_Info& c_RegInfo)
{
    AddString(pBuf, c_aRegInfo[c_RegInfo.name].szAlias);
} 

void 
CIa64Disasm::AddRegister(CSzBuffer* pBuf,
                         const EM_Decoder_Regfile_Info& c_RegFileInfo)
{
    AddString(pBuf, c_aRegFileInfo[c_RegFileInfo.index.name].szName);
} 

void 
CIa64Disasm::AddRegister(CSzBuffer* pBuf,
                         EM_Decoder_Reg_Name RegName)
{
    AddString(pBuf, c_aRegInfo[RegName].szAlias);
}

void 
CIa64Disasm::AddPredicate(CSzBuffer* pBuf,
                          const EM_Decoder_Info& c_InstrInfo,
                          bool bContext)
{
    if (!(c_InstrInfo.pred.valid && c_InstrInfo.pred.value)) 
    {
        return;
    }

    AddString(pBuf, "(");

    AddRegister(pBuf, c_InstrInfo.pred);

    const char* szClose;
    if (bContext)
    {
        if ((m_Machine->GetReg64(PREDS) >> c_InstrInfo.pred.value) & 0x1) 
        {
            szClose = "=1)"; 
        } 
        else 
        {
            szClose = "=0)"; 
        }
    }
    else 
    {
        szClose = ")";
    }
    AddString(pBuf, szClose);
}

void 
CIa64Disasm::AddMnemonic(CSzBuffer* pBuf,
                         const EM_Decoder_Info& c_InstrInfo)
{
    AddString(pBuf, c_InstrInfo.static_info->mnemonic, 7);
    AddString(pBuf, NULL, 13);
}

void 
CIa64Disasm::AddOperandList(CSzBuffer* pBuf,
                            ULONG64 uBundleLoc,
                            UINT uSlotNum,
                            const EM_Decoder_Info& c_InstrInfo)
{
    bool bAdd = false;

    bAdd |= AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.dst1, false);
    bAdd |= AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.dst2, bAdd);

    if ((c_InstrInfo.dst1.type != EM_DECODER_NO_OPER) &&
        (c_InstrInfo.src1.type != EM_DECODER_NO_OPER))
    {
        AddString(pBuf, "=");
        bAdd = false;
    } 

    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src1, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src2, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src3, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src4, bAdd);
    bAdd = AddOperand(pBuf, uBundleLoc, uSlotNum, c_InstrInfo.src5, bAdd);
}

void 
CIa64Disasm::AddComment(CSzBuffer* pBuf, 
                        ULONG64 uBundleLoc, 
                        UINT uSlotNum, 
                        const EM_Decoder_Info& c_InstrInfo,
                        bool bContext)
{
    if (bContext) 
    {
        char szComment[128]; 
        *szComment = 0;
        CSzBuffer Comment(szComment, sizeof(szComment) / sizeof(*szComment));

        if (
            !strncmp(c_InstrInfo.static_info->mnemonic, "br.", 3) &&
            (c_InstrInfo.src1.reg_info.type == EM_DECODER_BR_REG))    
        {
            ULONG64 uTargetAddr = 
                m_Machine->GetReg64(c_InstrInfo.src1.reg_info.value + BRRP);

            Comment.Add(" // ");
            AddSymAddr(&Comment, uTargetAddr);

            if ((uTargetAddr == IA64_MM_EPC_VA + 0x20) &&
                !IS_KERNEL_TARGET(m_Target))
            {
                Comment.Add(" system call");
            }
        }

        if (Comment.length())
        {
            long iCommentStart =
                (g_AsmOptions & DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH) ?
                0 : (long(g_OutputWidth) - Comment.length() - 18);
            AddString(pBuf, Comment.c_str(), 
                      (iCommentStart > 0) ? size_t(iCommentStart) : 0);
        }
    }
}

bool 
CIa64Disasm::AddOperand(CSzBuffer* pBuf,
                        ULONG64 uBundleLoc,
                        UINT uSlotNum,
                        const EM_Decoder_Operand_Info& c_OperandInfo,
                        bool bSeparator)
{
    switch (c_OperandInfo.type) 
    {
    case EM_DECODER_REGISTER: 
    {  
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }
        AddRegister(pBuf, c_OperandInfo.reg_info);
    }
    break;
        
    case EM_DECODER_REGFILE: 
    {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }
        AddString(pBuf,
                  c_aRegFileInfo[c_OperandInfo.regfile_info.name].szName);
        AddString(pBuf, "[");
        AddRegister(pBuf, c_OperandInfo.regfile_info.index.name);
        AddString(pBuf, "]");
    }
    break;
    
    case EM_DECODER_IMMEDIATE: 
    {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }

        if (EM_DECODER_OPER_IMM_REG((&c_OperandInfo))) 
        {
            EM_Decoder_Reg_Name RegName;
        
            if (EM_DECODER_OPER_IMM_FREG((&c_OperandInfo))) 
            {
                RegName = EM_DECODER_REG_F0;
            }
            else
            {
                DBG_ASSERT(EM_DECODER_OPER_IMM_IREG((&c_OperandInfo)));
                
                RegName = EM_DECODER_REG_R0;
            }
        
            RegName = EM_Decoder_Reg_Name(
                UINT(RegName) + IEL_GETDW0(c_OperandInfo.imm_info.val64));

            AddRegister(pBuf, RegName);
        }
        else 
        {
            U64 ImmVal = c_OperandInfo.imm_info.val64;

            ULONG64 uImmVal = IEL_GETQW0(ImmVal);

            if (c_OperandInfo.imm_info.size == 64) 
            {
                AddSymAddr(pBuf, uImmVal);
            }
            else 
            {
                AddString(pBuf, FormatDisp64(uImmVal));
            }
        }
    }
    break;
    
    case EM_DECODER_MEMORY: 
    {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }
        AddString(pBuf, "[");
        AddRegister(pBuf, c_OperandInfo.mem_info.mem_base.name);
        AddString(pBuf, "]");
    }
    break;
    
    case EM_DECODER_IP_RELATIVE: {
        if (bSeparator) 
        {
            AddSeparator(pBuf); 
        }

        ULONG64 uOffset = IEL_GETQW0(c_OperandInfo.imm_info.val64);
        if (uOffset) 
        {
            uOffset += uBundleLoc;
            AddSymAddr(pBuf, uOffset);
        }
        else 
        {
            AddString(pBuf, "+0");
        }
    }
    break;

    default: {
        return false;
    }
    }

    return true;
}

void 
CIa64Disasm::AddSeparator(CSzBuffer* pBuf)
{
    AddString(pBuf, ", ");
}

void 
CIa64Disasm::AddSymAddr(CSzBuffer* pBuf,
                        ULONG64 uAddress)
{
    char szSymbol[MAX_SYMBOL_LEN]; 
    ULONG64 uDisplacement = 0;

    GetSymbol(uAddress, szSymbol, sizeof(szSymbol), &uDisplacement);
    szSymbol[MAX_SYMBOL_LEN - 1] = char(0);

    if (*szSymbol) 
    {
        AddString(pBuf, szSymbol);
        AddString(pBuf, "+");
        AddString(pBuf, FormatDisp64(uDisplacement));
        AddString(pBuf, " (");
        AddString(pBuf, FormatAddr64(uAddress));
        AddString(pBuf, ")");
    }
    else 
    {
        AddString(pBuf, FormatAddr64(uAddress));
    }
}

CIa64Disasm::SRegFileInfo CIa64Disasm::c_aRegFileInfo[] = {
    {EM_DECODER_NO_REGFILE,    "no",    "no",    "no"   },
    {EM_DECODER_REGFILE_PMC,   "pmc",   "pmc",   "pmc"  },
    {EM_DECODER_REGFILE_PMD,   "pmd",   "pmd",   "pmd"  },
    {EM_DECODER_REGFILE_PKR,   "pkr",   "pkr",   "pkr"  },
    {EM_DECODER_REGFILE_RR,    "rr",    "rr",    "rr"   },
    {EM_DECODER_REGFILE_IBR,   "ibr",   "ibr",   "ibr"  },
    {EM_DECODER_REGFILE_DBR,   "dbr",   "dbr",   "dbr"  },
    {EM_DECODER_REGFILE_ITR,   "itr",   "itr",   "itr"  },
    {EM_DECODER_REGFILE_DTR,   "dtr",   "dtr",   "dtr"  },
    {EM_DECODER_REGFILE_MSR,   "msr",   "msr",   "msr"  },
    {EM_DECODER_REGFILE_CPUID, "cpuid", "cpuid", "cpuid"},
    {EM_DECODER_REGFILE_LAST,  "last",  "last",  "last" }
}; // CIa64Disasm::c_aRegFileInfo

CIa64Disasm::SRegInfo CIa64Disasm::c_aRegInfo[] = {
    {EM_DECODER_NO_REG, "%mm", "%mm", "mm"},

    {EM_DECODER_NO_REG, "%error", "%error", "error"}, 
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},
    {EM_DECODER_NO_REG, "%error", "%error", "error"},

    {EM_DECODER_REG_R0,   "r0",   "r0",   "r0"  },
    {EM_DECODER_REG_R1,   "r1",   "gp",   "gp"  },
    {EM_DECODER_REG_R2,   "r2",   "r2",   "r2"  },
    {EM_DECODER_REG_R3,   "r3",   "r3",   "r3"  },
    {EM_DECODER_REG_R4,   "r4",   "r4",   "r4"  },
    {EM_DECODER_REG_R5,   "r5",   "r5",   "r5"  },
    {EM_DECODER_REG_R6,   "r6",   "r6",   "r6"  },
    {EM_DECODER_REG_R7,   "r7",   "r7",   "r7"  },
    {EM_DECODER_REG_R8,   "r8",   "ret0", "ret0"},
    {EM_DECODER_REG_R9,   "r9",   "ret1", "ret1"},
    {EM_DECODER_REG_R10,  "r10",  "ret2", "ret2"},
    {EM_DECODER_REG_R11,  "r11",  "ret3", "ret3"},
    {EM_DECODER_REG_R12,  "r12",  "sp",   "sp"  },
    {EM_DECODER_REG_R13,  "r13",  "r13",  "r13" },
    {EM_DECODER_REG_R14,  "r14",  "r14",  "r14" },
    {EM_DECODER_REG_R15,  "r15",  "r15",  "r15" },
    {EM_DECODER_REG_R16,  "r16",  "r16",  "r16" },
    {EM_DECODER_REG_R17,  "r17",  "r17",  "r17" },
    {EM_DECODER_REG_R18,  "r18",  "r18",  "r18" },
    {EM_DECODER_REG_R19,  "r19",  "r19",  "r19" },
    {EM_DECODER_REG_R20,  "r20",  "r20",  "r20" },
    {EM_DECODER_REG_R21,  "r21",  "r21",  "r21" },
    {EM_DECODER_REG_R22,  "r22",  "r22",  "r22" },
    {EM_DECODER_REG_R23,  "r23",  "r23",  "r23" },
    {EM_DECODER_REG_R24,  "r24",  "r24",  "r24" },
    {EM_DECODER_REG_R25,  "r25",  "r25",  "r25" },
    {EM_DECODER_REG_R26,  "r26",  "r26",  "r26" },
    {EM_DECODER_REG_R27,  "r27",  "r27",  "r27" },
    {EM_DECODER_REG_R28,  "r28",  "r28",  "r28" },
    {EM_DECODER_REG_R29,  "r29",  "r29",  "r29" },
    {EM_DECODER_REG_R30,  "r30",  "r30",  "r30" },
    {EM_DECODER_REG_R31,  "r31",  "r31",  "r31" },
    {EM_DECODER_REG_R32,  "r32",  "r32",  "r32" },
    {EM_DECODER_REG_R33,  "r33",  "r33",  "r33" },
    {EM_DECODER_REG_R34,  "r34",  "r34",  "r34" },
    {EM_DECODER_REG_R35,  "r35",  "r35",  "r35" },
    {EM_DECODER_REG_R36,  "r36",  "r36",  "r36" },
    {EM_DECODER_REG_R37,  "r37",  "r37",  "r37" },
    {EM_DECODER_REG_R38,  "r38",  "r38",  "r38" },
    {EM_DECODER_REG_R39,  "r39",  "r39",  "r39" },
    {EM_DECODER_REG_R40,  "r40",  "r40",  "r40" },
    {EM_DECODER_REG_R41,  "r41",  "r41",  "r41" },
    {EM_DECODER_REG_R42,  "r42",  "r42",  "r42" },
    {EM_DECODER_REG_R43,  "r43",  "r43",  "r43" },
    {EM_DECODER_REG_R44,  "r44",  "r44",  "r44" },
    {EM_DECODER_REG_R45,  "r45",  "r45",  "r45" },
    {EM_DECODER_REG_R46,  "r46",  "r46",  "r46" },
    {EM_DECODER_REG_R47,  "r47",  "r47",  "r47" },
    {EM_DECODER_REG_R48,  "r48",  "r48",  "r48" },
    {EM_DECODER_REG_R49,  "r49",  "r49",  "r49" },
    {EM_DECODER_REG_R50,  "r50",  "r50",  "r50" },
    {EM_DECODER_REG_R51,  "r51",  "r51",  "r51" },
    {EM_DECODER_REG_R52,  "r52",  "r52",  "r52" },
    {EM_DECODER_REG_R53,  "r53",  "r53",  "r53" },
    {EM_DECODER_REG_R54,  "r54",  "r54",  "r54" },
    {EM_DECODER_REG_R55,  "r55",  "r55",  "r55" },
    {EM_DECODER_REG_R56,  "r56",  "r56",  "r56" },
    {EM_DECODER_REG_R57,  "r57",  "r57",  "r57" },
    {EM_DECODER_REG_R58,  "r58",  "r58",  "r58" },
    {EM_DECODER_REG_R59,  "r59",  "r59",  "r59" },
    {EM_DECODER_REG_R60,  "r60",  "r60",  "r60" },
    {EM_DECODER_REG_R61,  "r61",  "r61",  "r61" },
    {EM_DECODER_REG_R62,  "r62",  "r62",  "r62" },
    {EM_DECODER_REG_R63,  "r63",  "r63",  "r63" },
    {EM_DECODER_REG_R64,  "r64",  "r64",  "r64" },
    {EM_DECODER_REG_R65,  "r65",  "r65",  "r65" },
    {EM_DECODER_REG_R66,  "r66",  "r66",  "r66" },
    {EM_DECODER_REG_R67,  "r67",  "r67",  "r67" },
    {EM_DECODER_REG_R68,  "r68",  "r68",  "r68" },
    {EM_DECODER_REG_R69,  "r69",  "r69",  "r69" },
    {EM_DECODER_REG_R70,  "r70",  "r70",  "r70" },
    {EM_DECODER_REG_R71,  "r71",  "r71",  "r71" },
    {EM_DECODER_REG_R72,  "r72",  "r72",  "r72" },
    {EM_DECODER_REG_R73,  "r73",  "r73",  "r73" },
    {EM_DECODER_REG_R74,  "r74",  "r74",  "r74" },
    {EM_DECODER_REG_R75,  "r75",  "r75",  "r75" },
    {EM_DECODER_REG_R76,  "r76",  "r76",  "r76" },
    {EM_DECODER_REG_R77,  "r77",  "r77",  "r77" },
    {EM_DECODER_REG_R78,  "r78",  "r78",  "r78" },
    {EM_DECODER_REG_R79,  "r79",  "r79",  "r79" },
    {EM_DECODER_REG_R80,  "r80",  "r80",  "r80" },
    {EM_DECODER_REG_R81,  "r81",  "r81",  "r81" },
    {EM_DECODER_REG_R82,  "r82",  "r82",  "r82" },
    {EM_DECODER_REG_R83,  "r83",  "r83",  "r83" },
    {EM_DECODER_REG_R84,  "r84",  "r84",  "r84" },
    {EM_DECODER_REG_R85,  "r85",  "r85",  "r85" },
    {EM_DECODER_REG_R86,  "r86",  "r86",  "r86" },
    {EM_DECODER_REG_R87,  "r87",  "r87",  "r87" },
    {EM_DECODER_REG_R88,  "r88",  "r88",  "r88" },
    {EM_DECODER_REG_R89,  "r89",  "r89",  "r89" },
    {EM_DECODER_REG_R90,  "r90",  "r90",  "r90" },
    {EM_DECODER_REG_R91,  "r91",  "r91",  "r91" },
    {EM_DECODER_REG_R92,  "r92",  "r92",  "r92" },
    {EM_DECODER_REG_R93,  "r93",  "r93",  "r93" },
    {EM_DECODER_REG_R94,  "r94",  "r94",  "r94" },
    {EM_DECODER_REG_R95,  "r95",  "r95",  "r95" },
    {EM_DECODER_REG_R96,  "r96",  "r96",  "r96" },
    {EM_DECODER_REG_R97,  "r97",  "r97",  "r97" },
    {EM_DECODER_REG_R98,  "r98",  "r98",  "r98" },
    {EM_DECODER_REG_R99,  "r99",  "r99",  "r99" },
    {EM_DECODER_REG_R100, "r100", "r100", "r100"},
    {EM_DECODER_REG_R101, "r101", "r101", "r101"},
    {EM_DECODER_REG_R102, "r102", "r102", "r102"},
    {EM_DECODER_REG_R103, "r103", "r103", "r103"},
    {EM_DECODER_REG_R104, "r104", "r104", "r104"},
    {EM_DECODER_REG_R105, "r105", "r105", "r105"},
    {EM_DECODER_REG_R106, "r106", "r106", "r106"},
    {EM_DECODER_REG_R107, "r107", "r107", "r107"},
    {EM_DECODER_REG_R108, "r108", "r108", "r108"},
    {EM_DECODER_REG_R109, "r109", "r109", "r109"},
    {EM_DECODER_REG_R110, "r110", "r110", "r110"},
    {EM_DECODER_REG_R111, "r111", "r111", "r111"},
    {EM_DECODER_REG_R112, "r112", "r112", "r112"},
    {EM_DECODER_REG_R113, "r113", "r113", "r113"},
    {EM_DECODER_REG_R114, "r114", "r114", "r114"},
    {EM_DECODER_REG_R115, "r115", "r115", "r115"},
    {EM_DECODER_REG_R116, "r116", "r116", "r116"},
    {EM_DECODER_REG_R117, "r117", "r117", "r117"},
    {EM_DECODER_REG_R118, "r118", "r118", "r118"},
    {EM_DECODER_REG_R119, "r119", "r119", "r119"},
    {EM_DECODER_REG_R120, "r120", "r120", "r120"},
    {EM_DECODER_REG_R121, "r121", "r121", "r121"},
    {EM_DECODER_REG_R122, "r122", "r122", "r122"},
    {EM_DECODER_REG_R123, "r123", "r123", "r123"},
    {EM_DECODER_REG_R124, "r124", "r124", "r124"},
    {EM_DECODER_REG_R125, "r125", "r125", "r125"},
    {EM_DECODER_REG_R126, "r126", "r126", "r126"},
    {EM_DECODER_REG_R127, "r127", "r127", "r127"},

    {EM_DECODER_REG_F0,   "f0",   "f0",    "f0"   },
    {EM_DECODER_REG_F1,   "f1",   "f1",    "f1"   },
    {EM_DECODER_REG_F2,   "f2",   "f2",    "f2"   },
    {EM_DECODER_REG_F3,   "f3",   "f3",    "f3"   },
    {EM_DECODER_REG_F4,   "f4",   "f4",    "f4"   },
    {EM_DECODER_REG_F5,   "f5",   "f5",    "f5"   },
    {EM_DECODER_REG_F6,   "f6",   "f6",    "f6"   },
    {EM_DECODER_REG_F7,   "f7",   "f7",    "f7"   },
    {EM_DECODER_REG_F8,   "f8",   "farg0", "fret0"},
    {EM_DECODER_REG_F9,   "f9",   "farg1", "fret1"},
    {EM_DECODER_REG_F10,  "f10",  "farg2", "fret2"},
    {EM_DECODER_REG_F11,  "f11",  "farg3", "fret3"},
    {EM_DECODER_REG_F12,  "f12",  "farg4", "fret4"},
    {EM_DECODER_REG_F13,  "f13",  "farg5", "fret5"},
    {EM_DECODER_REG_F14,  "f14",  "farg6", "fret6"},
    {EM_DECODER_REG_F15,  "f15",  "farg7", "fret7"},
    {EM_DECODER_REG_F16,  "f16",  "f16",   "f16"  },
    {EM_DECODER_REG_F17,  "f17",  "f17",   "f17"  },
    {EM_DECODER_REG_F18,  "f18",  "f18",   "f18"  },
    {EM_DECODER_REG_F19,  "f19",  "f19",   "f19"  },
    {EM_DECODER_REG_F20,  "f20",  "f20",   "f20"  },
    {EM_DECODER_REG_F21,  "f21",  "f21",   "f21"  },
    {EM_DECODER_REG_F22,  "f22",  "f22",   "f22"  },
    {EM_DECODER_REG_F23,  "f23",  "f23",   "f23"  },
    {EM_DECODER_REG_F24,  "f24",  "f24",   "f24"  },
    {EM_DECODER_REG_F25,  "f25",  "f25",   "f25"  },
    {EM_DECODER_REG_F26,  "f26",  "f26",   "f26"  },
    {EM_DECODER_REG_F27,  "f27",  "f27",   "f27"  },
    {EM_DECODER_REG_F28,  "f28",  "f28",   "f28"  },
    {EM_DECODER_REG_F29,  "f29",  "f29",   "f29"  },
    {EM_DECODER_REG_F30,  "f30",  "f30",   "f30"  },
    {EM_DECODER_REG_F31,  "f31",  "f31",   "f31"  },
    {EM_DECODER_REG_F32,  "f32",  "f32",   "f32"  },
    {EM_DECODER_REG_F33,  "f33",  "f33",   "f33"  },
    {EM_DECODER_REG_F34,  "f34",  "f34",   "f34"  },
    {EM_DECODER_REG_F35,  "f35",  "f35",   "f35"  },
    {EM_DECODER_REG_F36,  "f36",  "f36",   "f36"  },
    {EM_DECODER_REG_F37,  "f37",  "f37",   "f37"  },
    {EM_DECODER_REG_F38,  "f38",  "f38",   "f38"  },
    {EM_DECODER_REG_F39,  "f39",  "f39",   "f39"  },
    {EM_DECODER_REG_F40,  "f40",  "f40",   "f40"  },
    {EM_DECODER_REG_F41,  "f41",  "f41",   "f41"  },
    {EM_DECODER_REG_F42,  "f42",  "f42",   "f42"  },
    {EM_DECODER_REG_F43,  "f43",  "f43",   "f43"  },
    {EM_DECODER_REG_F44,  "f44",  "f44",   "f44"  },
    {EM_DECODER_REG_F45,  "f45",  "f45",   "f45"  },
    {EM_DECODER_REG_F46,  "f46",  "f46",   "f46"  },
    {EM_DECODER_REG_F47,  "f47",  "f47",   "f47"  },
    {EM_DECODER_REG_F48,  "f48",  "f48",   "f48"  },
    {EM_DECODER_REG_F49,  "f49",  "f49",   "f49"  },
    {EM_DECODER_REG_F50,  "f50",  "f50",   "f50"  },
    {EM_DECODER_REG_F51,  "f51",  "f51",   "f51"  },
    {EM_DECODER_REG_F52,  "f52",  "f52",   "f52"  },
    {EM_DECODER_REG_F53,  "f53",  "f53",   "f53"  },
    {EM_DECODER_REG_F54,  "f54",  "f54",   "f54"  },
    {EM_DECODER_REG_F55,  "f55",  "f55",   "f55"  },
    {EM_DECODER_REG_F56,  "f56",  "f56",   "f56"  },
    {EM_DECODER_REG_F57,  "f57",  "f57",   "f57"  },
    {EM_DECODER_REG_F58,  "f58",  "f58",   "f58"  },
    {EM_DECODER_REG_F59,  "f59",  "f59",   "f59"  },
    {EM_DECODER_REG_F60,  "f60",  "f60",   "f60"  },
    {EM_DECODER_REG_F61,  "f61",  "f61",   "f61"  },
    {EM_DECODER_REG_F62,  "f62",  "f62",   "f62"  },
    {EM_DECODER_REG_F63,  "f63",  "f63",   "f63"  },
    {EM_DECODER_REG_F64,  "f64",  "f64",   "f64"  },
    {EM_DECODER_REG_F65,  "f65",  "f65",   "f65"  },
    {EM_DECODER_REG_F66,  "f66",  "f66",   "f66"  },
    {EM_DECODER_REG_F67,  "f67",  "f67",   "f67"  },
    {EM_DECODER_REG_F68,  "f68",  "f68",   "f68"  },
    {EM_DECODER_REG_F69,  "f69",  "f69",   "f69"  },
    {EM_DECODER_REG_F70,  "f70",  "f70",   "f70"  },
    {EM_DECODER_REG_F71,  "f71",  "f71",   "f71"  },
    {EM_DECODER_REG_F72,  "f72",  "f72",   "f72"  },
    {EM_DECODER_REG_F73,  "f73",  "f73",   "f73"  },
    {EM_DECODER_REG_F74,  "f74",  "f74",   "f74"  },
    {EM_DECODER_REG_F75,  "f75",  "f75",   "f75"  },
    {EM_DECODER_REG_F76,  "f76",  "f76",   "f76"  },
    {EM_DECODER_REG_F77,  "f77",  "f77",   "f77"  },
    {EM_DECODER_REG_F78,  "f78",  "f78",   "f78"  },
    {EM_DECODER_REG_F79,  "f79",  "f79",   "f79"  },
    {EM_DECODER_REG_F80,  "f80",  "f80",   "f80"  },
    {EM_DECODER_REG_F81,  "f81",  "f81",   "f81"  },
    {EM_DECODER_REG_F82,  "f82",  "f82",   "f82"  },
    {EM_DECODER_REG_F83,  "f83",  "f83",   "f83"  },
    {EM_DECODER_REG_F84,  "f84",  "f84",   "f84"  },
    {EM_DECODER_REG_F85,  "f85",  "f85",   "f85"  },
    {EM_DECODER_REG_F86,  "f86",  "f86",   "f86"  },
    {EM_DECODER_REG_F87,  "f87",  "f87",   "f87"  },
    {EM_DECODER_REG_F88,  "f88",  "f88",   "f88"  },
    {EM_DECODER_REG_F89,  "f89",  "f89",   "f89"  },
    {EM_DECODER_REG_F90,  "f90",  "f90",   "f90"  },
    {EM_DECODER_REG_F91,  "f91",  "f91",   "f91"  },
    {EM_DECODER_REG_F92,  "f92",  "f92",   "f92"  },
    {EM_DECODER_REG_F93,  "f93",  "f93",   "f93"  },
    {EM_DECODER_REG_F94,  "f94",  "f94",   "f94"  },
    {EM_DECODER_REG_F95,  "f95",  "f95",   "f95"  },
    {EM_DECODER_REG_F96,  "f96",  "f96",   "f96"  },
    {EM_DECODER_REG_F97,  "f97",  "f97",   "f97"  },
    {EM_DECODER_REG_F98,  "f98",  "f98",   "f98"  },
    {EM_DECODER_REG_F99,  "f99",  "f99",   "f99"  },
    {EM_DECODER_REG_F100, "f100", "f100",  "f100" },
    {EM_DECODER_REG_F101, "f101", "f101",  "f101" },
    {EM_DECODER_REG_F102, "f102", "f102",  "f102" },
    {EM_DECODER_REG_F103, "f103", "f103",  "f103" },
    {EM_DECODER_REG_F104, "f104", "f104",  "f104" },
    {EM_DECODER_REG_F105, "f105", "f105",  "f105" },
    {EM_DECODER_REG_F106, "f106", "f106",  "f106" },
    {EM_DECODER_REG_F107, "f107", "f107",  "f107" },
    {EM_DECODER_REG_F108, "f108", "f108",  "f108" },
    {EM_DECODER_REG_F109, "f109", "f109",  "f109" },
    {EM_DECODER_REG_F110, "f110", "f110",  "f110" },
    {EM_DECODER_REG_F111, "f111", "f111",  "f111" },
    {EM_DECODER_REG_F112, "f112", "f112",  "f112" },
    {EM_DECODER_REG_F113, "f113", "f113",  "f113" },
    {EM_DECODER_REG_F114, "f114", "f114",  "f114" },
    {EM_DECODER_REG_F115, "f115", "f115",  "f115" },
    {EM_DECODER_REG_F116, "f116", "f116",  "f116" },
    {EM_DECODER_REG_F117, "f117", "f117",  "f117" },
    {EM_DECODER_REG_F118, "f118", "f118",  "f118" },
    {EM_DECODER_REG_F119, "f119", "f119",  "f119" },
    {EM_DECODER_REG_F120, "f120", "f120",  "f120" },
    {EM_DECODER_REG_F121, "f121", "f121",  "f121" },
    {EM_DECODER_REG_F122, "f122", "f122",  "f122" },
    {EM_DECODER_REG_F123, "f123", "f123",  "f123" },
    {EM_DECODER_REG_F124, "f124", "f124",  "f124" },
    {EM_DECODER_REG_F125, "f125", "f125",  "f125" },
    {EM_DECODER_REG_F126, "f126", "f126",  "f126" },
    {EM_DECODER_REG_F127, "f127", "f127",  "f127" },

    {EM_DECODER_REG_AR0,   "ar0",   "ar.k0",       "ar.kr0"     },
    {EM_DECODER_REG_AR1,   "ar1",   "ar.k1",       "ar.kr1"     },
    {EM_DECODER_REG_AR2,   "ar2",   "ar.k2",       "ar.kr2"     },
    {EM_DECODER_REG_AR3,   "ar3",   "ar.k3",       "ar.kr3"     },
    {EM_DECODER_REG_AR4,   "ar4",   "ar.k4",       "ar.kr4"     },
    {EM_DECODER_REG_AR5,   "ar5",   "ar.k5",       "ar.kr5"     },
    {EM_DECODER_REG_AR6,   "ar6",   "ar.k6",       "ar.kr6"     },
    {EM_DECODER_REG_AR7,   "ar7",   "ar.k7",       "ar.kr7"     },
    {EM_DECODER_REG_AR8,   "ar8",   "ar8",         "ar8-res"    },
    {EM_DECODER_REG_AR9,   "ar9",   "ar9",         "ar9-res"    },
    {EM_DECODER_REG_AR10,  "ar10",  "ar10",        "ar10-res"   },
    {EM_DECODER_REG_AR11,  "ar11",  "ar11",        "ar11-res"   },
    {EM_DECODER_REG_AR12,  "ar12",  "ar12",        "ar12-res"   },
    {EM_DECODER_REG_AR13,  "ar13",  "ar13",        "ar13-res"   },
    {EM_DECODER_REG_AR14,  "ar14",  "ar14",        "ar14-res"   },
    {EM_DECODER_REG_AR15,  "ar15",  "ar15",        "ar15-res"   },
    {EM_DECODER_REG_AR16,  "ar16",  "ar.rsc",      "ar.rsc"     },
    {EM_DECODER_REG_AR17,  "ar17",  "ar.bsp",      "ar.bsp"     },
    {EM_DECODER_REG_AR18,  "ar18",  "ar.bspstore", "ar.bspstore"},
    {EM_DECODER_REG_AR19,  "ar19",  "ar.rnat",     "ar.rnat"    },
    {EM_DECODER_REG_AR20,  "ar20",  "ar20",        "ar20-res"   },
    {EM_DECODER_REG_AR21,  "ar21",  "ar.fcr",      "ar21-ia32"  },
    {EM_DECODER_REG_AR22,  "ar22",  "ar22",        "ar22-res"   },
    {EM_DECODER_REG_AR23,  "ar23",  "ar23",        "ar23-res"   },
    {EM_DECODER_REG_AR24,  "ar24",  "ar.eflag",    "ar24-ia32"  },
    {EM_DECODER_REG_AR25,  "ar25",  "ar.csd",      "ar25-ia32"  },
    {EM_DECODER_REG_AR26,  "ar26",  "ar.ssd",      "ar26-ia32"  },
    {EM_DECODER_REG_AR27,  "ar27",  "ar.cflg",     "ar27-ia32"  },
    {EM_DECODER_REG_AR28,  "ar28",  "ar.fsr",      "ar28-ia32"  },
    {EM_DECODER_REG_AR29,  "ar29",  "ar.fir",      "ar29-ia32"  },
    {EM_DECODER_REG_AR30,  "ar30",  "ar.fdr",      "ar30-ia32"  },
    {EM_DECODER_REG_AR31,  "ar31",  "ar31",        "ar31-res"   },
    {EM_DECODER_REG_AR32,  "ar32",  "ar.ccv",      "ar.ccv"     },
    {EM_DECODER_REG_AR33,  "ar33",  "ar33",        "ar33-res"   },
    {EM_DECODER_REG_AR34,  "ar34",  "ar34",        "ar34-res"   },
    {EM_DECODER_REG_AR35,  "ar35",  "ar35",        "ar35-res"   },
    {EM_DECODER_REG_AR36,  "ar36",  "ar.unat",     "ar.unat"    },
    {EM_DECODER_REG_AR37,  "ar37",  "ar37",        "ar37-res"   },
    {EM_DECODER_REG_AR38,  "ar38",  "ar38",        "ar38-res"   },
    {EM_DECODER_REG_AR39,  "ar39",  "ar39",        "ar39-res"   },
    {EM_DECODER_REG_AR40,  "ar40",  "ar.fpsr",     "ar.fpsr"    },
    {EM_DECODER_REG_AR41,  "ar41",  "ar41",        "ar41-res"   },
    {EM_DECODER_REG_AR42,  "ar42",  "ar42",        "ar42-res"   },
    {EM_DECODER_REG_AR43,  "ar43",  "ar43",        "ar43-res"   },
    {EM_DECODER_REG_AR44,  "ar44",  "ar.itc",      "ar.itc"     },
    {EM_DECODER_REG_AR45,  "ar45",  "ar45",        "ar45-res"   },
    {EM_DECODER_REG_AR46,  "ar46",  "ar46",        "ar46-res"   },
    {EM_DECODER_REG_AR47,  "ar47",  "ar47",        "ar47-res"   },
    {EM_DECODER_REG_AR48,  "ar48",  "ar48",        "ar48-ign"   },
    {EM_DECODER_REG_AR49,  "ar49",  "ar49",        "ar49-ign"   },
    {EM_DECODER_REG_AR50,  "ar50",  "ar50",        "ar50-ign"   },
    {EM_DECODER_REG_AR51,  "ar51",  "ar51",        "ar51-ign"   },
    {EM_DECODER_REG_AR52,  "ar52",  "ar52",        "ar52-ign"   },
    {EM_DECODER_REG_AR53,  "ar53",  "ar53",        "ar53-ign"   },
    {EM_DECODER_REG_AR54,  "ar54",  "ar54",        "ar54-ign"   },
    {EM_DECODER_REG_AR55,  "ar55",  "ar55",        "ar55-ign"   },
    {EM_DECODER_REG_AR56,  "ar56",  "ar56",        "ar56-ign"   },
    {EM_DECODER_REG_AR57,  "ar57",  "ar57",        "ar57-ign"   },
    {EM_DECODER_REG_AR58,  "ar58",  "ar58",        "ar58-ign"   },
    {EM_DECODER_REG_AR59,  "ar59",  "ar59",        "ar59-ign"   },
    {EM_DECODER_REG_AR60,  "ar60",  "ar60",        "ar60-ign"   },
    {EM_DECODER_REG_AR61,  "ar61",  "ar61",        "ar61-ign"   },
    {EM_DECODER_REG_AR62,  "ar62",  "ar62",        "ar62-ign"   },
    {EM_DECODER_REG_AR63,  "ar63",  "ar63",        "ar63-ign"   },
    {EM_DECODER_REG_AR64,  "ar64",  "ar.pfs",      "ar.pfs"     },
    {EM_DECODER_REG_AR65,  "ar65",  "ar.lc",       "ar.lc"      },
    {EM_DECODER_REG_AR66,  "ar66",  "ar.ec",       "ar.ec"      },
    {EM_DECODER_REG_AR67,  "ar67",  "ar67",        "ar67-res"   },
    {EM_DECODER_REG_AR68,  "ar68",  "ar68",        "ar68-res"   },
    {EM_DECODER_REG_AR69,  "ar69",  "ar69",        "ar69-res"   },
    {EM_DECODER_REG_AR70,  "ar70",  "ar70",        "ar70-res"   },
    {EM_DECODER_REG_AR71,  "ar71",  "ar71",        "ar71-res"   },
    {EM_DECODER_REG_AR72,  "ar72",  "ar72",        "ar72-res"   },
    {EM_DECODER_REG_AR73,  "ar73",  "ar73",        "ar73-res"   },
    {EM_DECODER_REG_AR74,  "ar74",  "ar74",        "ar74-res"   },
    {EM_DECODER_REG_AR75,  "ar75",  "ar75",        "ar75-res"   },
    {EM_DECODER_REG_AR76,  "ar76",  "ar76",        "ar76-res"   },
    {EM_DECODER_REG_AR77,  "ar77",  "ar77",        "ar77-res"   },
    {EM_DECODER_REG_AR78,  "ar78",  "ar78",        "ar78-res"   },
    {EM_DECODER_REG_AR79,  "ar79",  "ar79",        "ar79-res"   },
    {EM_DECODER_REG_AR80,  "ar80",  "ar80",        "ar80-res"   },
    {EM_DECODER_REG_AR81,  "ar81",  "ar81",        "ar81-res"   },
    {EM_DECODER_REG_AR82,  "ar82",  "ar82",        "ar82-res"   },
    {EM_DECODER_REG_AR83,  "ar83",  "ar83",        "ar83-res"   },
    {EM_DECODER_REG_AR84,  "ar84",  "ar84",        "ar84-res"   },
    {EM_DECODER_REG_AR85,  "ar85",  "ar85",        "ar85-res"   },
    {EM_DECODER_REG_AR86,  "ar86",  "ar86",        "ar86-res"   },
    {EM_DECODER_REG_AR87,  "ar87",  "ar87",        "ar87-res"   },
    {EM_DECODER_REG_AR88,  "ar88",  "ar88",        "ar88-res"   },
    {EM_DECODER_REG_AR89,  "ar89",  "ar89",        "ar89-res"   },
    {EM_DECODER_REG_AR90,  "ar90",  "ar90",        "ar90-res"   },
    {EM_DECODER_REG_AR91,  "ar91",  "ar91",        "ar91-res"   },
    {EM_DECODER_REG_AR92,  "ar92",  "ar92",        "ar92-res"   },
    {EM_DECODER_REG_AR93,  "ar93",  "ar93",        "ar93-res"   },
    {EM_DECODER_REG_AR94,  "ar94",  "ar94",        "ar94-res"   },
    {EM_DECODER_REG_AR95,  "ar95",  "ar95",        "ar95-res"   },
    {EM_DECODER_REG_AR96,  "ar96",  "ar96",        "ar96-res"   },
    {EM_DECODER_REG_AR97,  "ar97",  "ar97",        "ar97-res"   },
    {EM_DECODER_REG_AR98,  "ar98",  "ar98",        "ar98-res"   },
    {EM_DECODER_REG_AR99,  "ar99",  "ar99",        "ar99-res"   },
    {EM_DECODER_REG_AR100, "ar100", "ar100",       "ar100-res"  },
    {EM_DECODER_REG_AR101, "ar101", "ar101",       "ar101-res"  },
    {EM_DECODER_REG_AR102, "ar102", "ar102",       "ar102-res"  },
    {EM_DECODER_REG_AR103, "ar103", "ar103",       "ar103-res"  },
    {EM_DECODER_REG_AR104, "ar104", "ar104",       "ar104-res"  },
    {EM_DECODER_REG_AR105, "ar105", "ar105",       "ar105-res"  },
    {EM_DECODER_REG_AR106, "ar106", "ar106",       "ar106-res"  },
    {EM_DECODER_REG_AR107, "ar107", "ar107",       "ar107-res"  },
    {EM_DECODER_REG_AR108, "ar108", "ar108",       "ar108-res"  },
    {EM_DECODER_REG_AR109, "ar109", "ar109",       "ar109-res"  },
    {EM_DECODER_REG_AR110, "ar110", "ar110",       "ar110-res"  },
    {EM_DECODER_REG_AR111, "ar111", "ar111",       "ar111-res"  },
    {EM_DECODER_REG_AR112, "ar112", "ar112",       "ar112-ign"  },
    {EM_DECODER_REG_AR113, "ar113", "ar113",       "ar113-ign"  },
    {EM_DECODER_REG_AR114, "ar114", "ar114",       "ar114-ign"  },
    {EM_DECODER_REG_AR115, "ar115", "ar115",       "ar115-ign"  },
    {EM_DECODER_REG_AR116, "ar116", "ar116",       "ar116-ign"  },
    {EM_DECODER_REG_AR117, "ar117", "ar117",       "ar117-ign"  },
    {EM_DECODER_REG_AR118, "ar118", "ar118",       "ar118-ign"  },
    {EM_DECODER_REG_AR119, "ar119", "ar119",       "ar119-ign"  },
    {EM_DECODER_REG_AR120, "ar120", "ar120",       "ar120-ign"  },
    {EM_DECODER_REG_AR121, "ar121", "ar121",       "ar121-ign"  },
    {EM_DECODER_REG_AR122, "ar122", "ar122",       "ar122-ign"  },
    {EM_DECODER_REG_AR123, "ar123", "ar123",       "ar123-ign"  },
    {EM_DECODER_REG_AR124, "ar124", "ar124",       "ar124-ign"  },
    {EM_DECODER_REG_AR125, "ar125", "ar125",       "ar125-ign"  },
    {EM_DECODER_REG_AR126, "ar126", "ar126",       "ar126-ign"  },
    {EM_DECODER_REG_AR127, "ar127", "ar127",       "ar127-ign"  },

    {EM_DECODER_REG_P0,  "p0",  "p0",  "p0" },
    {EM_DECODER_REG_P1,  "p1",  "p1",  "p1" },
    {EM_DECODER_REG_P2,  "p2",  "p2",  "p2" },
    {EM_DECODER_REG_P3,  "p3",  "p3",  "p3" },
    {EM_DECODER_REG_P4,  "p4",  "p4",  "p4" },
    {EM_DECODER_REG_P5,  "p5",  "p5",  "p5" },
    {EM_DECODER_REG_P6,  "p6",  "p6",  "p6" },
    {EM_DECODER_REG_P7,  "p7",  "p7",  "p7" },
    {EM_DECODER_REG_P8,  "p8",  "p8",  "p8" },
    {EM_DECODER_REG_P9,  "p9",  "p9",  "p9" },
    {EM_DECODER_REG_P10, "p10", "p10", "p10"},
    {EM_DECODER_REG_P11, "p11", "p11", "p11"},
    {EM_DECODER_REG_P12, "p12", "p12", "p12"},
    {EM_DECODER_REG_P13, "p13", "p13", "p13"},
    {EM_DECODER_REG_P14, "p14", "p14", "p14"},
    {EM_DECODER_REG_P15, "p15", "p15", "p15"},
    {EM_DECODER_REG_P16, "p16", "p16", "p16"},
    {EM_DECODER_REG_P17, "p17", "p17", "p17"},
    {EM_DECODER_REG_P18, "p18", "p18", "p18"},
    {EM_DECODER_REG_P19, "p19", "p19", "p19"},
    {EM_DECODER_REG_P20, "p20", "p20", "p20"},
    {EM_DECODER_REG_P21, "p21", "p21", "p21"},
    {EM_DECODER_REG_P22, "p22", "p22", "p22"},
    {EM_DECODER_REG_P23, "p23", "p23", "p23"},
    {EM_DECODER_REG_P24, "p24", "p24", "p24"},
    {EM_DECODER_REG_P25, "p25", "p25", "p25"},
    {EM_DECODER_REG_P26, "p26", "p26", "p26"},
    {EM_DECODER_REG_P27, "p27", "p27", "p27"},
    {EM_DECODER_REG_P28, "p28", "p28", "p28"},
    {EM_DECODER_REG_P29, "p29", "p29", "p29"},
    {EM_DECODER_REG_P30, "p30", "p30", "p30"},
    {EM_DECODER_REG_P31, "p31", "p31", "p31"},
    {EM_DECODER_REG_P32, "p32", "p32", "p32"},
    {EM_DECODER_REG_P33, "p33", "p33", "p33"},
    {EM_DECODER_REG_P34, "p34", "p34", "p34"},
    {EM_DECODER_REG_P35, "p35", "p35", "p35"},
    {EM_DECODER_REG_P36, "p36", "p36", "p36"},
    {EM_DECODER_REG_P37, "p37", "p37", "p37"},
    {EM_DECODER_REG_P38, "p38", "p38", "p38"},
    {EM_DECODER_REG_P39, "p39", "p39", "p39"},
    {EM_DECODER_REG_P40, "p40", "p40", "p40"},
    {EM_DECODER_REG_P41, "p41", "p41", "p41"},
    {EM_DECODER_REG_P42, "p42", "p42", "p42"},
    {EM_DECODER_REG_P43, "p43", "p43", "p43"},
    {EM_DECODER_REG_P44, "p44", "p44", "p44"},
    {EM_DECODER_REG_P45, "p45", "p45", "p45"},
    {EM_DECODER_REG_P46, "p46", "p46", "p46"},
    {EM_DECODER_REG_P47, "p47", "p47", "p47"},
    {EM_DECODER_REG_P48, "p48", "p48", "p48"},
    {EM_DECODER_REG_P49, "p49", "p49", "p49"},
    {EM_DECODER_REG_P50, "p50", "p50", "p50"},
    {EM_DECODER_REG_P51, "p51", "p51", "p51"},
    {EM_DECODER_REG_P52, "p52", "p52", "p52"},
    {EM_DECODER_REG_P53, "p53", "p53", "p53"},
    {EM_DECODER_REG_P54, "p54", "p54", "p54"},
    {EM_DECODER_REG_P55, "p55", "p55", "p55"},
    {EM_DECODER_REG_P56, "p56", "p56", "p56"},
    {EM_DECODER_REG_P57, "p57", "p57", "p57"},
    {EM_DECODER_REG_P58, "p58", "p58", "p58"},
    {EM_DECODER_REG_P59, "p59", "p59", "p59"},
    {EM_DECODER_REG_P60, "p60", "p60", "p60"},
    {EM_DECODER_REG_P61, "p61", "p61", "p61"},
    {EM_DECODER_REG_P62, "p62", "p62", "p62"},
    {EM_DECODER_REG_P63, "p63", "p63", "p63"},

    {EM_DECODER_REG_BR0, "b0", "rp", "bret"},
    {EM_DECODER_REG_BR1, "b1", "b1", "b1"  },
    {EM_DECODER_REG_BR2, "b2", "b2", "b2"  },
    {EM_DECODER_REG_BR3, "b3", "b3", "b3"  },
    {EM_DECODER_REG_BR4, "b4", "b4", "b4"  },
    {EM_DECODER_REG_BR5, "b5", "b5", "b5"  },
    {EM_DECODER_REG_BR6, "b6", "b6", "b6"  },
    {EM_DECODER_REG_BR7, "b7", "b7", "b7"  },

    {EM_DECODER_REG_PR,     "pr",     "pr",      "pr"       },
    {EM_DECODER_REG_PR_ROT, "pr.rot", "pr.rot",  "pr.rot"   },
    {EM_DECODER_REG_CR0,    "cr0",    "cr.dcr",  "cr.dcr"   },
    {EM_DECODER_REG_CR1,    "cr1",    "cr.itm",  "cr.itm"   },
    {EM_DECODER_REG_CR2,    "cr2",    "cr.iva",  "cr.iva"   },
    {EM_DECODER_REG_CR3,    "cr3",    "cr3",     "cr3-res"  },
    {EM_DECODER_REG_CR4,    "cr4",    "cr4",     "cr4-res"  },
    {EM_DECODER_REG_CR5,    "cr5",    "cr5",     "cr5-res"  },
    {EM_DECODER_REG_CR6,    "cr6",    "cr6",     "cr6-res"  },
    {EM_DECODER_REG_CR7,    "cr7",    "cr7",     "cr7-res"  },
    {EM_DECODER_REG_CR8,    "cr8",    "cr.pta",  "cr.pta"   },
    {EM_DECODER_REG_CR9,    "cr9",    "cr.gpta", "cr.gpta"  },
    {EM_DECODER_REG_CR10,   "cr10",   "cr10",    "cr10-res" },
    {EM_DECODER_REG_CR11,   "cr11",   "cr11",    "cr11-res" },
    {EM_DECODER_REG_CR12,   "cr12",   "cr12",    "cr12-res" },
    {EM_DECODER_REG_CR13,   "cr13",   "cr13",    "cr13-res" },
    {EM_DECODER_REG_CR14,   "cr14",   "cr14",    "cr14-res" },
    {EM_DECODER_REG_CR15,   "cr15",   "cr15",    "cr15-res" },
    {EM_DECODER_REG_CR16,   "cr16",   "cr.ipsr", "cr.ipsr"  },
    {EM_DECODER_REG_CR17,   "cr17",   "cr.isr",  "cr.isr"   },
    {EM_DECODER_REG_CR18,   "cr18",   "cr18",    "cr18-res" },
    {EM_DECODER_REG_CR19,   "cr19",   "cr.iip",  "cr.iip"   },
    {EM_DECODER_REG_CR20,   "cr20",   "cr.ifa",  "cr.ifa"   },
    {EM_DECODER_REG_CR21,   "cr21",   "cr.itir", "cr.itir"  },
    {EM_DECODER_REG_CR22,   "cr22",   "cr.iipa", "cr.iipa"  },
    {EM_DECODER_REG_CR23,   "cr23",   "cr.ifs",  "cr.ifs"   },
    {EM_DECODER_REG_CR24,   "cr24",   "cr.iim",  "cr.iim"   },
    {EM_DECODER_REG_CR25,   "cr25",   "cr.iha",  "cr.iha"   },
    {EM_DECODER_REG_CR26,   "cr26",   "cr26",    "cr26-res" },
    {EM_DECODER_REG_CR27,   "cr27",   "cr27",    "cr27-res" },
    {EM_DECODER_REG_CR28,   "cr28",   "cr28",    "cr28-res" },
    {EM_DECODER_REG_CR29,   "cr29",   "cr29",    "cr29-res" },
    {EM_DECODER_REG_CR30,   "cr30",   "cr30",    "cr30-res" },
    {EM_DECODER_REG_CR31,   "cr31",   "cr31",    "cr31-res" },
    {EM_DECODER_REG_CR32,   "cr32",   "cr32",    "cr32-res" },
    {EM_DECODER_REG_CR33,   "cr33",   "cr33",    "cr33-res" },
    {EM_DECODER_REG_CR34,   "cr34",   "cr34",    "cr34-res" },
    {EM_DECODER_REG_CR35,   "cr35",   "cr35",    "cr35-res" },
    {EM_DECODER_REG_CR36,   "cr36",   "cr36",    "cr36-res" },
    {EM_DECODER_REG_CR37,   "cr37",   "cr37",    "cr37-res" },
    {EM_DECODER_REG_CR38,   "cr38",   "cr38",    "cr38-res" },
    {EM_DECODER_REG_CR39,   "cr39",   "cr39",    "cr39-res" },
    {EM_DECODER_REG_CR40,   "cr40",   "cr40",    "cr40-res" },
    {EM_DECODER_REG_CR41,   "cr41",   "cr41",    "cr41-res" },
    {EM_DECODER_REG_CR42,   "cr42",   "cr42",    "cr42-res" },
    {EM_DECODER_REG_CR43,   "cr43",   "cr43",    "cr43-res" },
    {EM_DECODER_REG_CR44,   "cr44",   "cr44",    "cr44-res" },
    {EM_DECODER_REG_CR45,   "cr45",   "cr45",    "cr45-res" },
    {EM_DECODER_REG_CR46,   "cr46",   "cr46",    "cr46-res" },
    {EM_DECODER_REG_CR47,   "cr47",   "cr47",    "cr47-res" },
    {EM_DECODER_REG_CR48,   "cr48",   "cr48",    "cr48-res" },
    {EM_DECODER_REG_CR49,   "cr49",   "cr49",    "cr49-res" },
    {EM_DECODER_REG_CR50,   "cr50",   "cr50",    "cr50-res" },
    {EM_DECODER_REG_CR51,   "cr51",   "cr51",    "cr51-res" },
    {EM_DECODER_REG_CR52,   "cr52",   "cr52",    "cr52-res" },
    {EM_DECODER_REG_CR53,   "cr53",   "cr53",    "cr53-res" },
    {EM_DECODER_REG_CR54,   "cr54",   "cr54",    "cr54-res" },
    {EM_DECODER_REG_CR55,   "cr55",   "cr55",    "cr55-res" },
    {EM_DECODER_REG_CR56,   "cr56",   "cr56",    "cr56-res" },
    {EM_DECODER_REG_CR57,   "cr57",   "cr57",    "cr57-res" },
    {EM_DECODER_REG_CR58,   "cr58",   "cr58",    "cr58-res" },
    {EM_DECODER_REG_CR59,   "cr59",   "cr59",    "cr59-res" },
    {EM_DECODER_REG_CR60,   "cr60",   "cr60",    "cr60-res" },
    {EM_DECODER_REG_CR61,   "cr61",   "cr61",    "cr61-res" },
    {EM_DECODER_REG_CR62,   "cr62",   "cr62",    "cr62-res" },
    {EM_DECODER_REG_CR63,   "cr63",   "cr63",    "cr63-res" },
    {EM_DECODER_REG_CR64,   "cr64",   "cr.lid",  "cr.lid"   },
    {EM_DECODER_REG_CR65,   "cr65",   "cr.ivr",  "cr.ivr"   },
    {EM_DECODER_REG_CR66,   "cr66",   "cr.tpr",  "cr.tpr"   },
    {EM_DECODER_REG_CR67,   "cr67",   "cr.eoi",  "cr.eoi"   },
    {EM_DECODER_REG_CR68,   "cr68",   "cr.irr0", "cr.irr0"  },
    {EM_DECODER_REG_CR69,   "cr69",   "cr.irr1", "cr.irr1"  },
    {EM_DECODER_REG_CR70,   "cr70",   "cr.irr2", "cr.irr2"  },
    {EM_DECODER_REG_CR71,   "cr71",   "cr.irr3", "cr.irr3"  },
    {EM_DECODER_REG_CR72,   "cr72",   "cr.itv",  "cr.itv"   },
    {EM_DECODER_REG_CR73,   "cr73",   "cr.pmv",  "cr.pmv"   },
    {EM_DECODER_REG_CR74,   "cr74",   "cr.cmcv", "cr.cmcv"  },
    {EM_DECODER_REG_CR75,   "cr75",   "cr75",    "cr75-res" },
    {EM_DECODER_REG_CR76,   "cr76",   "cr76",    "cr76-res" },
    {EM_DECODER_REG_CR77,   "cr77",   "cr77",    "cr77-res" },
    {EM_DECODER_REG_CR78,   "cr78",   "cr78",    "cr78-res" },
    {EM_DECODER_REG_CR79,   "cr79",   "cr79",    "cr79-res" },
    {EM_DECODER_REG_CR80,   "cr80",   "cr.lrr0", "cr.lrr0"  },
    {EM_DECODER_REG_CR81,   "cr81",   "cr.lrr1", "cr.lrr1"  },
    {EM_DECODER_REG_CR82,   "cr82",   "cr82",    "cr82-res" },
    {EM_DECODER_REG_CR83,   "cr83",   "cr83",    "cr83-res" },
    {EM_DECODER_REG_CR84,   "cr84",   "cr84",    "cr84-res" },
    {EM_DECODER_REG_CR85,   "cr85",   "cr85",    "cr85-res" },
    {EM_DECODER_REG_CR86,   "cr86",   "cr86",    "cr86-res" },
    {EM_DECODER_REG_CR87,   "cr87",   "cr87",    "cr87-res" },
    {EM_DECODER_REG_CR88,   "cr88",   "cr88",    "cr88-res" },
    {EM_DECODER_REG_CR89,   "cr89",   "cr89",    "cr89-res" },
    {EM_DECODER_REG_CR90,   "cr90",   "cr90",    "cr90-res" },
    {EM_DECODER_REG_CR91,   "cr91",   "cr91",    "cr91-res" },
    {EM_DECODER_REG_CR92,   "cr92",   "cr92",    "cr92-res" },
    {EM_DECODER_REG_CR93,   "cr93",   "cr93",    "cr93-res" },
    {EM_DECODER_REG_CR94,   "cr94",   "cr94",    "cr94-res" },
    {EM_DECODER_REG_CR95,   "cr95",   "cr95",    "cr95-res" },
    {EM_DECODER_REG_CR96,   "cr96",   "cr96",    "cr96-res" },
    {EM_DECODER_REG_CR97,   "cr97",   "cr97",    "cr97-res" },
    {EM_DECODER_REG_CR98,   "cr98",   "cr98",    "cr98-res" },
    {EM_DECODER_REG_CR99,   "cr99",   "cr99",    "cr99-res" },
    {EM_DECODER_REG_CR100,  "cr100",  "cr100",   "cr100-res"},
    {EM_DECODER_REG_CR101,  "cr101",  "cr101",   "cr101-res"},
    {EM_DECODER_REG_CR102,  "cr102",  "cr102",   "cr102-res"},
    {EM_DECODER_REG_CR103,  "cr103",  "cr103",   "cr103-res"},
    {EM_DECODER_REG_CR104,  "cr104",  "cr104",   "cr104-res"},
    {EM_DECODER_REG_CR105,  "cr105",  "cr105",   "cr105-res"},
    {EM_DECODER_REG_CR106,  "cr106",  "cr106",   "cr106-res"},
    {EM_DECODER_REG_CR107,  "cr107",  "cr107",   "cr107-res"},
    {EM_DECODER_REG_CR108,  "cr108",  "cr108",   "cr108-res"},
    {EM_DECODER_REG_CR109,  "cr109",  "cr109",   "cr109-res"},
    {EM_DECODER_REG_CR110,  "cr110",  "cr110",   "cr110-res"},
    {EM_DECODER_REG_CR111,  "cr111",  "cr111",   "cr111-res"},
    {EM_DECODER_REG_CR112,  "cr112",  "cr112",   "cr112-res"},
    {EM_DECODER_REG_CR113,  "cr113",  "cr113",   "cr113-res"},
    {EM_DECODER_REG_CR114,  "cr114",  "cr114",   "cr114-res"},
    {EM_DECODER_REG_CR115,  "cr115",  "cr115",   "cr115-res"},
    {EM_DECODER_REG_CR116,  "cr116",  "cr116",   "cr116-res"},
    {EM_DECODER_REG_CR117,  "cr117",  "cr117",   "cr117-res"},
    {EM_DECODER_REG_CR118,  "cr118",  "cr118",   "cr118-res"},
    {EM_DECODER_REG_CR119,  "cr119",  "cr119",   "cr119-res"},
    {EM_DECODER_REG_CR120,  "cr120",  "cr120",   "cr120-res"},
    {EM_DECODER_REG_CR121,  "cr121",  "cr121",   "cr121-res"},
    {EM_DECODER_REG_CR122,  "cr122",  "cr122",   "cr122-res"},
    {EM_DECODER_REG_CR123,  "cr123",  "cr123",   "cr123-res"},
    {EM_DECODER_REG_CR124,  "cr124",  "cr124",   "cr124-res"},
    {EM_DECODER_REG_CR125,  "cr125",  "cr125",   "cr125-res"},
    {EM_DECODER_REG_CR126,  "cr126",  "cr126",   "cr126-res"},
    {EM_DECODER_REG_CR127,  "cr127",  "cr127",   "cr127-res"},
    {EM_DECODER_REG_PSR,    "psr",    "psr",     "psr"      },
    {EM_DECODER_REG_PSR_L,  "psr.l",  "psr.l",   "psr.l"    },
    {EM_DECODER_REG_PSR_UM, "psr.um", "psr.um",  "psr.um"   },
    {EM_DECODER_REG_IP, "IP", "IP", "ip" },
    {EM_DECODER_EM_REG_LAST, "", "", ""},
    {EM_DECODER_REG_LAST, "", "", ""}
};



UCHAR g_Ia64Disinstr[EM_BUNDLE_SIZE];

/******************************************************************
** Simple IA64 template info... Thierry 12/99.
**
*/

#define GET_TEMPLATE(Bits) \
    ((EM_template_t)(((Bits) >> EM_TEMPLATE_POS) & (EM_NUM_OF_TEMPLATES - 1)))

typedef enum _EM_UNIT { 
   I_Unit, 
   M_Unit, 
   F_Unit, 
   B_Unit, 
   X_Unit, 
   L_Unit, 
   A_Unit, 
   No_Unit 
} EM_UNIT;

typedef enum _EM_SB { 
   SB_Cont, 
   SB_Stop 
} EM_SB;

typedef struct _EM_TEMPLATE_INFO {
   struct {
       EM_UNIT unit;
       EM_SB   stop;
   } slot[EM_SLOT_LAST];
   const char *name;
} EM_TEMPLATE_INFO, *PEM_TEMPLATE_INFO;

EM_TEMPLATE_INFO EmTemplates[] = {
/*      Slot 0               Slot 1             Slot 2
----------------------------------------------------------*/
{ {{M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".mii " },
{ {{M_Unit,  SB_Cont}, {I_Unit,  SB_Stop}, {I_Unit,  SB_Cont}}, ".mi_i" },
{ {{M_Unit,  SB_Cont}, {L_Unit,  SB_Cont}, {X_Unit,  SB_Cont}}, ".mlx " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
{ {{M_Unit,  SB_Cont}, {M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".mmi " },
{ {{M_Unit,  SB_Stop}, {M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".m_mi" },
{ {{M_Unit,  SB_Cont}, {F_Unit,  SB_Cont}, {I_Unit,  SB_Cont}}, ".mfi " },
{ {{M_Unit,  SB_Cont}, {M_Unit,  SB_Cont}, {F_Unit,  SB_Cont}}, ".mmf " },
{ {{M_Unit,  SB_Cont}, {I_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mib " },
{ {{M_Unit,  SB_Cont}, {B_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mbb " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
{ {{B_Unit,  SB_Cont}, {B_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".bbb " },
{ {{M_Unit,  SB_Cont}, {M_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mmb " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
{ {{M_Unit,  SB_Cont}, {F_Unit,  SB_Cont}, {B_Unit,  SB_Cont}}, ".mfb " },
{ {{No_Unit, SB_Cont}, {No_Unit, SB_Cont}, {No_Unit, SB_Cont}}, "?res " },
};

PEM_TEMPLATE_INFO __inline
EmTemplateInfo(EM_template_t Template)
{
   if (Template >= sizeof(EmTemplates)/sizeof(EmTemplates[0]))
   {
      return NULL;
   }
   return &EmTemplates[Template];
}

/*
** End of Simple IA64 template info.
*******************************************************************
*/


/**** disasm - disassemble an IA64 instruction
* Purpose:
*       Disassemble version based on Falcon DISASM.DLL
*
*  Input:
*       pOffset = pointer to offset to start disassembly
*       fEAout = if set, include EA (effective address)
*
*  Output:
*       pOffset = pointer to offset of next instruction
*       pchDst = pointer to result string
*
***************************************************************************/

BOOL
Ia64MachineInfo::Disassemble(ProcessInfo* Process,
                             PADDR poffset, PSTR bufptr, BOOL fEAout)
{
    U64     location;
    ULONG64 gb_offset;
    UINT    ascii_inst_buf_length;
    PUINT   pascii_inst_buf_length = &ascii_inst_buf_length;
    ULONG bin_inst_buf_length;
    unsigned int actual_length;
    ADDR    tempaddr;
    UCHAR * pbin_inst_buf = &g_Ia64Disinstr[0];
    CIa64Disasm Disasm(m_Target, this);

    if (IS_CONTEXT_POSSIBLE(m_Target) && IsIA32InstructionSet())
    {
        WarnOut("The current context is in IA32 mode.  "
                "IA64 disassembly may be inaccurate.\n");
    }

    IEL_ZERO(location);
    // convert EM address to Gambit internal address.
    // i.e., move slot number from bit(2,3) to bit(0,1)
    gb_offset = ((Flat(*poffset) & (~0xf)) | ((Flat(*poffset) & 0xf) >> 2));
    IEL_ASSIGNU(location, *(U64*)(&gb_offset));

    // convert to bundle address. must be 16 byte aligned
    ADDRFLAT(&tempaddr, (Flat(*poffset) & ~0xf));

    // copy data (if KD, from remote system) to local temp buffer -
    // g_Ia64Disinstr[]
    if (m_Target->ReadVirtual(Process, Flat(tempaddr),
                              pbin_inst_buf, sizeof(U128),
                              &bin_inst_buf_length) != S_OK)
    {
        bin_inst_buf_length = 0;
    }
        
    m_BufStart = (PCHAR)bufptr;
    m_Buf = m_BufStart;
        
    // display 64-bit address
    sprintf(m_Buf, "%s ", FormatAddr64(Flat(*poffset)));
    m_Buf += strlen(m_Buf);
        
    // TBD display opcode

    // If we're in verbose mode leave space for the bundle type.
    if (g_AsmOptions & DEBUG_ASMOPT_VERBOSE) 
    {
        // Show the bundle type at the beginning of the bundle.
        if (AddrEqu(tempaddr, *poffset)) 
        {
            if (bin_inst_buf_length == sizeof(U128)) 
            {
                PEM_TEMPLATE_INFO Templ = 
                    EmTemplateInfo(GET_TEMPLATE(pbin_inst_buf[0]));
                if (Templ)
                {
                    sprintf(m_Buf, "{ %s", Templ->name);
                }
                else
                {
                    sprintf(m_Buf, "{ invalid_template");
                }
            } 
            else 
            {
                strcpy(m_Buf, "{ ??? ");
            }
        } 
        else 
        {
            strcpy(m_Buf, "       ");
        }
        m_Buf += strlen(m_Buf);
    }
        
    if (bin_inst_buf_length != sizeof(U128)) 
    {
        BufferString(" ???????? ????\n");
        *m_Buf = '\0';
        return FALSE;
    }

    *pascii_inst_buf_length = ASCII_BUF_LENGTH;

    if (!Disasm.Disassemble(
            Flat(*poffset), *(CIa64Disasm::SBundle*)pbin_inst_buf, 
            &actual_length,
            m_Buf, *pascii_inst_buf_length, (fEAout != FALSE)))
    {
        ErrOut("Dissassembler failure!!!!\n");        
    }

    switch (EM_IL_GET_SLOT_NO(location))
    {
    case 0:
        IEL_INCU(location);
        break;

    case 1:
        IEL_INCU(location);
        if ((actual_length) != 2)
        {
            break;
        }
        /*** else fall-through ***/

    case 2:
        U32 syl_size;
        IEL_CONVERT1(syl_size, EM_BUNDLE_SIZE-2);
        IEL_ADDU((location), syl_size, (location));
        break;
    }

    gb_offset = ((ULONG64)IEL_GETQW0(location));

    // convert Gambit internal address to EM address
    Off(*poffset) =  (gb_offset & (~0xf)) | ((gb_offset & 0xf) << 2);
    NotFlat(*poffset);
    ComputeFlatAddress(poffset, NULL);

    m_Buf += strlen(m_Buf);
    
    // If this the last instruction of a bundle mark it.
    if ((Flat(*poffset) & 0xf) == 0) 
    {
        if (g_AsmOptions & DEBUG_ASMOPT_VERBOSE)
        {
            strcpy(m_Buf, "}\n");
            m_Buf += strlen(m_Buf);
        } 
        else 
        {
            *m_Buf++ = '\n';
        }
    }
    
    /* add new line at the end */
    *m_Buf++ = '\n';
    *m_Buf = '\0';
    return TRUE;
}

HRESULT
Ia64MachineInfo::NewBreakpoint(DebugClient* Client, 
                               ULONG Type,
                               ULONG Id,
                               Breakpoint** RetBp)
{
    HRESULT Status;

    switch(Type & (DEBUG_BREAKPOINT_CODE | DEBUG_BREAKPOINT_DATA))
    {
    case DEBUG_BREAKPOINT_CODE:
        *RetBp = new CodeBreakpoint(Client, Id, IMAGE_FILE_MACHINE_IA64);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;

        break;
    case DEBUG_BREAKPOINT_DATA:
        *RetBp = new Ia64DataBreakpoint(Client, Id);
        Status = (*RetBp) ? S_OK : E_OUTOFMEMORY;
        break;
    default:
        // Unknown breakpoint type.
        Status = E_NOINTERFACE;
    }

    return Status;
}

BOOL
Ia64MachineInfo::IsBreakpointInstruction(ProcessInfo* Process, PADDR Addr)
{
    ULONG64 Instr;

    if (IsIA32InstructionSet())
    {
        return m_Target->m_Machines[MACHIDX_I386]->
            IsBreakpointInstruction(Process, Addr);
    }
    else
    {
        // No need to align for this check.
        if (m_Target->ReadAllVirtual(Process, Flat(*Addr),
                                     &Instr, sizeof(Instr)) != S_OK)
        {
            return FALSE;
        }
    
        // Ignore predicates so any break instruction
        // is detected regardless of predication.
        switch (Flat(*Addr) & 0xf)
        {
        case 0:
            if ((Instr & (INST_SLOT0_MASK & ~PRED0_MASK)) ==
                (g_Ia64TrapInstr << 5))
            {
                return TRUE;
            }
            break;

        case 4:
            if ((Instr & (INST_SLOT1_MASK & ~PRED1_MASK)) ==
                (g_Ia64TrapInstr << 14))
            {
                return TRUE;
            }
            break;
            
        case 8:
            if ((Instr & (INST_SLOT2_MASK & ~PRED2_MASK)) ==
                (g_Ia64TrapInstr << 23))
            {
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}

HRESULT
Ia64MachineInfo::InsertBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                             ULONG64 Process,
                                             ULONG64 Offset,
                                             ULONG Flags,
                                             PUCHAR SaveInstr,
                                             PULONG64 ChangeStart,
                                             PULONG ChangeLen)
{
    ULONG64 Aligned;
    ULONG Off;
    ULONG Done;
    HRESULT Status;

    if (Flags & ~IBI_IA64_PRED_MASK)
    {
        return E_INVALIDARG;
    }
    
    // Make sure the storage area has space for both the saved
    // instruction bundle and some flags.
    DBG_ASSERT(MAX_BREAKPOINT_LENGTH >= IA64_BP_LEN + sizeof(BOOL));
    
    Aligned = Offset;
    Off = (ULONG)(Aligned & IA64_BP_ALIGN);
    Aligned -= Off;

    *ChangeStart = Aligned;
    *ChangeLen = IA64_BP_LEN;
    
    Status = Services->ReadVirtual(Process, Aligned, SaveInstr,
                                   IA64_BP_LEN, &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Done != IA64_BP_LEN)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }

    UCHAR TempInstr[IA64_BP_LEN];
    ULONG64 UNALIGNED *New = (ULONG64 UNALIGNED *)(TempInstr + Off);
    PBOOL Mli = (PBOOL)(SaveInstr + IA64_BP_LEN);
    ULONG64 TrapInstr = g_Ia64TrapInstr | (Flags & IBI_IA64_PRED_MASK);

    memcpy(TempInstr, SaveInstr, IA64_BP_LEN);
    *Mli = FALSE;
    
    switch(Off)
    {
    case 0:
        *New = (*New & ~(INST_SLOT0_MASK)) | (TrapInstr << 5);
        break;

    case 4:
        *New = (*New & ~(INST_SLOT1_MASK)) | (TrapInstr << 14);
        break;

    case 8:
        *New = (*New & ~(INST_SLOT2_MASK)) | (TrapInstr << 23);
        break;

    default:
        return E_INVALIDARG;
    }

    // If current instruction is
    // NOT slot 0 check for two-slot MOVL instruction.  Reject
    // request if attempt to set break in slot 2 of MLI template.

    if (Off != 0)
    {
        New = (PULONG64)TempInstr;
        if (((*New & INST_TEMPL_MASK) >> 1) == 0x2)
        {
            if (Off == 4)
            {
                // if template= type 2 MLI, change to type 0
                *New &= ~((INST_TEMPL_MASK >> 1) << 1);
                *Mli = TRUE;
            }
            else
            {
                // set breakpoint at slot 2 of MOVL is illegal
                return E_UNEXPECTED;
            }
        }
    }

    Status = Services->WriteVirtual(Process, Aligned, TempInstr,
                                    IA64_BP_LEN, &Done);
    if (Status == S_OK && Done != IA64_BP_LEN)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    return Status;
}

HRESULT
Ia64MachineInfo::RemoveBreakpointInstruction(PUSER_DEBUG_SERVICES Services,
                                             ULONG64 Process,
                                             ULONG64 Offset,
                                             PUCHAR SaveInstr,
                                             PULONG64 ChangeStart,
                                             PULONG ChangeLen)
{
    ULONG64 Aligned;
    ULONG Off;
    ULONG Done;
    HRESULT Status;

    Aligned = Offset;
    Off = (ULONG)(Aligned & IA64_BP_ALIGN);
    Aligned -= Off;

    *ChangeStart = Aligned;
    *ChangeLen = IA64_BP_LEN;
    
    UCHAR TempInstr[IA64_BP_LEN];
    ULONG64 UNALIGNED *New;
    ULONG64 UNALIGNED *Old;
    PBOOL Mli;

    // Read in memory since adjacent instructions in the same bundle
    // may have been modified after we save them. We only restore the
    // content of the slot which has the break instruction inserted.
    Status = Services->ReadVirtual(Process, Aligned, TempInstr,
                                   IA64_BP_LEN, &Done);
    if (Status != S_OK)
    {
        return Status;
    }
    if (Done != IA64_BP_LEN)
    {
        return HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
            
    New = (ULONG64 UNALIGNED *)(TempInstr + Off);
    Old = (ULONG64 UNALIGNED *)(SaveInstr + Off);
    Mli = (PBOOL)(SaveInstr + IA64_BP_LEN);
    
    switch(Off)
    {
    case 0:
        *New = (*New & ~(INST_SLOT0_MASK)) | (*Old & INST_SLOT0_MASK);
        break;

    case 4:
        *New = (*New & ~(INST_SLOT1_MASK)) | (*Old & INST_SLOT1_MASK);
        break;

    case 8:
        *New = (*New & ~(INST